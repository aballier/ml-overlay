From 7615424aae96df4379604179f89c748c3d3ff394 Mon Sep 17 00:00:00 2001
From: Calascibetta Romain <romain.calascibetta@gmail.com>
Date: Mon, 22 Jul 2024 14:36:31 +0200
Subject: [PATCH 1/9] wip: remove cstruct

---
 lib/ciphersuite.ml        |   7 +-
 lib/config.ml             |   7 +-
 lib/config.mli            |   2 +-
 lib/core.ml               |  84 +++++++-------
 lib/crypto.ml             |  77 ++++++-------
 lib/dune                  |   2 +-
 lib/engine.ml             | 126 +++++++++++----------
 lib/engine.mli            |  26 ++---
 lib/handshake_client.mli  |   4 +-
 lib/handshake_client13.ml |  63 ++++++-----
 lib/handshake_common.ml   |  43 ++++----
 lib/handshake_crypto.ml   |   6 +-
 lib/handshake_crypto.mli  |   6 +-
 lib/handshake_crypto13.ml |  58 +++++-----
 lib/handshake_server.mli  |   4 +-
 lib/handshake_server13.ml |  72 +++++++-----
 lib/packet.ml             |  12 +-
 lib/reader.ml             | 225 +++++++++++++++++++-------------------
 lib/reader.mli            |  40 +++----
 lib/state.ml              |  76 ++++++-------
 lib/writer.ml             |   3 -
 lib/writer.mli            |  34 +++---
 tls.opam                  |  14 +--
 23 files changed, 504 insertions(+), 487 deletions(-)

diff --git a/lib/ciphersuite.ml b/lib/ciphersuite.ml
index 8035666b..13842cef 100644
--- a/lib/ciphersuite.ml
+++ b/lib/ciphersuite.ml
@@ -48,7 +48,7 @@ let pp_payload_protection13 ppf = function
 
 type payload_protection =  [
   payload_protection13
-  | `Block of block_cipher * Mirage_crypto.Hash.hash
+  | `Block of block_cipher * Digestif.hash'
   ]
 
 let pp_hash ppf = function
@@ -74,7 +74,10 @@ let kn_13 = function
 (** [key_length iv payload_protection] is [(key size, IV size, mac size)] where key IV, and mac sizes are the required bytes for the given [payload_protection] *)
 (* NB only used for <= TLS 1.2, IV length for AEAD defined in RFC 5288 Section 3 (for GCM), salt[4] for CCM in RFC 6655 Section 3 *)
 let key_length iv pp =
-  let mac_size = Mirage_crypto.Hash.digest_size in
+  let mac_size m =
+    let module H = (val Digestif.module_of_hash' m) in
+    H.digest_size
+  in
   match pp with
   | `AEAD AES_128_CCM                -> (16, 4 , 0)
   | `AEAD AES_256_CCM                -> (32, 4 , 0)
diff --git a/lib/config.ml b/lib/config.ml
index d9a3a743..12ee9889 100644
--- a/lib/config.ml
+++ b/lib/config.ml
@@ -36,7 +36,7 @@ let pp_own_cert ppf = function
 type session_cache = SessionID.t -> epoch_data option
 
 type ticket_cache = {
-  lookup : Cstruct.t -> (psk13 * epoch_data) option ;
+  lookup : string -> (psk13 * epoch_data) option ;
   ticket_granted : psk13 -> epoch_data -> unit ;
   lifetime : int32 ;
   timestamp : unit -> Ptime.t
@@ -398,7 +398,7 @@ let validate_certificate_chain = function
           invalid "RSA key too short!"
       | _ -> () );
     ( let eq_pub a b =
-        Cstruct.equal
+        String.equal
           (X509.Public_key.fingerprint a)
           (X509.Public_key.fingerprint b)
       in
@@ -509,8 +509,7 @@ let validate_server config =
             | `ED25519 _ -> add `ED25519 cs acc
             | `P256 _ -> add `P256 cs acc
             | `P384 _ -> add `P384 cs acc
-            | `P521 _ -> add `P521 cs acc
-            | _ -> invalid "unknown key type")
+            | `P521 _ -> add `P521 cs acc)
           PK.empty cs
       in
       PK.iter (fun _ chains -> non_overlapping chains) pk
diff --git a/lib/config.mli b/lib/config.mli
index cf547f79..834db29d 100644
--- a/lib/config.mli
+++ b/lib/config.mli
@@ -18,7 +18,7 @@ type own_cert = [
 type session_cache = SessionID.t -> epoch_data option
 
 type ticket_cache = {
-  lookup : Cstruct.t -> (psk13 * epoch_data) option ;
+  lookup : string -> (psk13 * epoch_data) option ;
   ticket_granted : psk13 -> epoch_data -> unit ;
   lifetime : int32 ;
   timestamp : unit -> Ptime.t
diff --git a/lib/core.ml b/lib/core.ml
index e43d0b32..58d49530 100644
--- a/lib/core.ml
+++ b/lib/core.ml
@@ -3,8 +3,6 @@
 open Packet
 open Ciphersuite
 
-let (<+>) = Cstruct.append
-
 let ( let* ) = Result.bind
 
 let guard p e = if p then Ok () else Error e
@@ -121,24 +119,24 @@ let pp_tls_hdr ppf { content_type ; version } =
     pp_tls_any_version version
 
 module SessionID = struct
-  type t = Cstruct.t
-  let compare = Cstruct.compare
-  let hash t = Hashtbl.hash (Cstruct.to_bigarray t)
-  let equal = Cstruct.equal
+  type t = string
+  let compare = String.compare
+  let hash t = Hashtbl.hash t
+  let equal = String.equal
 end
 
 module PreSharedKeyID = struct
-  type t = Cstruct.t
-  let compare = Cstruct.compare
-  let hash t = Hashtbl.hash (Cstruct.to_bigarray t)
-  let equal = Cstruct.equal
+  type t = string
+  let compare = String.compare
+  let hash t = Hashtbl.hash t
+  let equal = String.equal
 end
 
-type psk_identity = (Cstruct.t * int32) * Cstruct.t
+type psk_identity = (string * int32) * string
 
 let binders_len psks =
   let binder_len (_, binder) =
-    Cstruct.length binder + 1 (* binder len *)
+    String.length binder + 1 (* binder len *)
   in
   2 (* binder len *) + List.fold_left (+) 0 (List.map binder_len psks)
 
@@ -303,24 +301,24 @@ type client_extension = [
   | `Hostname of [`host] Domain_name.t
   | `MaxFragmentLength of max_fragment_length
   | `SupportedGroups of Packet.named_group list
-  | `SecureRenegotiation of Cstruct.t
+  | `SecureRenegotiation of string
   | `Padding of int
   | `SignatureAlgorithms of signature_algorithm list
   | `ExtendedMasterSecret
   | `ALPN of string list
-  | `KeyShare of (Packet.named_group * Cstruct.t) list
+  | `KeyShare of (Packet.named_group * string) list
   | `EarlyDataIndication
   | `PreSharedKeys of psk_identity list
   | `SupportedVersions of tls_any_version list
   | `PostHandshakeAuthentication
-  | `Cookie of Cstruct.t
+  | `Cookie of string
   | `PskKeyExchangeModes of psk_key_exchange_mode list
   | `ECPointFormats
-  | `UnknownExtension of (int * Cstruct.t)
+  | `UnknownExtension of (int * string)
 ]
 
 type server13_extension = [
-  | `KeyShare of (group * Cstruct.t)
+  | `KeyShare of (group * string)
   | `PreSharedKey of int
   | `SelectedVersion of tls_version (* only used internally in writer!! *)
 ]
@@ -329,11 +327,11 @@ type server_extension = [
   server13_extension
   | `Hostname
   | `MaxFragmentLength of max_fragment_length
-  | `SecureRenegotiation of Cstruct.t
+  | `SecureRenegotiation of string
   | `ExtendedMasterSecret
   | `ALPN of string
   | `ECPointFormats
-  | `UnknownExtension of (int * Cstruct.t)
+  | `UnknownExtension of (int * string)
 ]
 
 type encrypted_extension = [
@@ -342,19 +340,19 @@ type encrypted_extension = [
   | `SupportedGroups of group list
   | `ALPN of string
   | `EarlyDataIndication
-  | `UnknownExtension of (int * Cstruct.t)
+  | `UnknownExtension of (int * string)
 ]
 
 type hello_retry_extension = [
   | `SelectedGroup of group (* only used internally in writer!! *)
-  | `Cookie of Cstruct.t
+  | `Cookie of string
   | `SelectedVersion of tls_version (* only used internally in writer!! *)
-  | `UnknownExtension of (int * Cstruct.t)
+  | `UnknownExtension of (int * string)
 ]
 
 type client_hello = {
   client_version : tls_any_version;
-  client_random  : Cstruct.t;
+  client_random  : string;
   sessionid      : SessionID.t option;
   ciphersuites   : any_ciphersuite list;
   extensions     : client_extension list
@@ -362,16 +360,16 @@ type client_hello = {
 
 type server_hello = {
   server_version : tls_version;
-  server_random  : Cstruct.t;
+  server_random  : string;
   sessionid      : SessionID.t option;
   ciphersuite    : ciphersuite;
   extensions     : server_extension list
 }
 
 type dh_parameters = {
-  dh_p  : Cstruct.t;
-  dh_g  : Cstruct.t;
-  dh_Ys : Cstruct.t;
+  dh_p  : string;
+  dh_g  : string;
+  dh_Ys : string;
 }
 
 type hello_retry = {
@@ -384,14 +382,14 @@ type hello_retry = {
 
 type session_ticket_extension = [
   | `EarlyDataIndication of int32
-  | `UnknownExtension of int * Cstruct.t
+  | `UnknownExtension of int * string
 ]
 
 type session_ticket = {
   lifetime : int32 ;
   age_add : int32 ;
-  nonce : Cstruct.t ;
-  ticket : Cstruct.t ;
+  nonce : string ;
+  ticket : string ;
   extensions : session_ticket_extension list
 }
 
@@ -402,7 +400,7 @@ type certificate_request_extension = [
   | `CertificateAuthorities of X509.Distinguished_name.t list
   (* | `OidFilters *)
   (* | `SignatureAlgorithmsCert *)
-  | `UnknownExtension of (int * Cstruct.t)
+  | `UnknownExtension of (int * string)
 ]
 
 type tls_handshake =
@@ -412,12 +410,12 @@ type tls_handshake =
   | ServerHelloDone
   | ClientHello of client_hello
   | ServerHello of server_hello
-  | Certificate of Cstruct.t
-  | ServerKeyExchange of Cstruct.t
-  | CertificateRequest of Cstruct.t
-  | ClientKeyExchange of Cstruct.t
-  | CertificateVerify of Cstruct.t
-  | Finished of Cstruct.t
+  | Certificate of string
+  | ServerKeyExchange of string
+  | CertificateRequest of string
+  | ClientKeyExchange of string
+  | CertificateVerify of string
+  | Finished of string
   | SessionTicket of session_ticket
   | KeyUpdate of key_update_request_type
   | EndOfEarlyData
@@ -442,19 +440,19 @@ let pp_handshake ppf = function
 let src = Logs.Src.create "tls.tracing" ~doc:"TLS tracing"
 module Tracing = struct
   include (val Logs.src_log src : Logs.LOG)
-  let cs ~tag buf = debug (fun m -> m "%s@.%a" tag Cstruct.hexdump_pp buf)
+  let cs ~tag buf = debug (fun m -> m "%s@.%a" tag (Ohex.pp_hexdump ()) buf)
   let hs ~tag hs = debug (fun m -> m "%s %a" tag pp_handshake hs)
 end
 
 type tls_alert = alert_level * alert_type
 
 (** the master secret of a TLS connection *)
-type master_secret = Cstruct.t
+type master_secret = string
 
 type psk13 = {
-  identifier : Cstruct.t ;
+  identifier : string ;
   obfuscation : int32 ;
-  secret : Cstruct.t ;
+  secret : string ;
   lifetime : int32 ;
   early_data : int32 ;
   issued_at : Ptime.t ;
@@ -469,13 +467,13 @@ type epoch_data = {
   state                  : epoch_state ;
   protocol_version       : tls_version ;
   ciphersuite            : Ciphersuite.ciphersuite ;
-  peer_random            : Cstruct.t ;
+  peer_random            : string ;
   peer_certificate_chain : X509.Certificate.t list ;
   peer_certificate       : X509.Certificate.t option ;
   peer_name              : [`host] Domain_name.t option ;
   trust_anchor           : X509.Certificate.t option ;
   received_certificates  : X509.Certificate.t list ;
-  own_random             : Cstruct.t ;
+  own_random             : string ;
   own_certificate        : X509.Certificate.t list ;
   own_private_key        : X509.Private_key.t option ;
   own_name               : [`host] Domain_name.t option ;
diff --git a/lib/crypto.ml b/lib/crypto.ml
index 0ae1c7b4..86b4dc32 100644
--- a/lib/crypto.ml
+++ b/lib/crypto.ml
@@ -2,15 +2,13 @@ open Mirage_crypto
 
 open Ciphersuite
 
-let (<+>) = Cstruct.append
-
 (* on-the-wire dh_params <-> (group, pub_message) *)
 let dh_params_pack { Mirage_crypto_pk.Dh.p; gg ; _ } message =
-  let cs_of_z = Mirage_crypto_pk.Z_extra.to_cstruct_be ?size:None in
+  let cs_of_z = Mirage_crypto_pk.Z_extra.to_octets_be ?size:None in
   { Core.dh_p = cs_of_z p ; dh_g = cs_of_z gg ; dh_Ys = message }
 
 and dh_params_unpack { Core.dh_p ; dh_g ; dh_Ys } =
-  let z_of_cs = Mirage_crypto_pk.Z_extra.of_cstruct_be ?bits:None in
+  let z_of_cs = Mirage_crypto_pk.Z_extra.of_octets_be ?bits:None in
   match Mirage_crypto_pk.Dh.group ~p:(z_of_cs dh_p) ~gg:(z_of_cs dh_g) () with
   | Ok dh -> Ok (dh, dh_Ys)
   | Error _ as e -> e
@@ -19,7 +17,7 @@ module Ciphers = struct
 
   (* I'm not sure how to get rid of this type, but would welcome a solution *)
   (* only used as result of get_block, which is called by get_cipher below *)
-  type keyed = | K_CBC : 'k State.cbc_cipher * (Cstruct.t -> 'k) -> keyed
+  type keyed = | K_CBC : 'k State.cbc_cipher * (string -> 'k) -> keyed
 
   let get_block = function
     | TRIPLE_DES_EDE_CBC ->
@@ -37,7 +35,7 @@ module Ciphers = struct
         K_CBC ( (module CBC : Cipher_block.S.CBC with type key = CBC.key),
                 CBC.of_secret )
 
-  type aead_keyed = | K_AEAD : 'k State.aead_cipher * (Cstruct.t -> 'k) * bool -> aead_keyed
+  type aead_keyed = | K_AEAD : 'k State.aead_cipher * (string -> 'k) * bool -> aead_keyed
   let get_aead =
     let open Cipher_block.AES in
     function
@@ -69,19 +67,18 @@ module Ciphers = struct
 end
 
 let sequence_buf seq =
-  let open Cstruct in
-  let buf = create 8 in
-  BE.set_uint64 buf 0 seq ;
-  buf
+  let buf = Bytes.create 8 in
+  Bytes.set_int64_be buf 0 seq ;
+  Bytes.unsafe_to_string buf
 
 let aead_nonce nonce seq =
   let s =
-    let l = Cstruct.length nonce in
-    let s = sequence_buf seq in
-    let pad = Cstruct.create (l - 8) in
-    pad <+> s
+    let l = String.length nonce in
+    let buf = Bytes.make l '\x00' in
+    Bytes.set_int64_be buf 0 seq;
+    Bytes.unsafe_to_string buf
   in
-  Uncommon.Cs.xor nonce s
+  Uncommon.xor nonce s
 
 let adata_1_3 len =
   (* additional data in TLS 1.3 is using the header (RFC 8446 Section 5.2):
@@ -89,56 +86,50 @@ let adata_1_3 len =
      - 0x03 0x03 (for TLS version 1.2 -- binary representation is 0x03 0x03)
      - <length in 16 bit>
   *)
-  let buf = Cstruct.create 5 in
-  Cstruct.set_uint8 buf 0 (Packet.content_type_to_int Packet.APPLICATION_DATA) ;
-  Cstruct.set_uint8 buf 1 3;
-  Cstruct.set_uint8 buf 2 3;
-  Cstruct.BE.set_uint16 buf 3 len ;
-  buf
+  let buf = Bytes.create 5 in
+  Bytes.set_uint8 buf 0 (Packet.content_type_to_int Packet.APPLICATION_DATA) ;
+  Bytes.set_uint8 buf 1 3;
+  Bytes.set_uint8 buf 2 3;
+  Bytes.set_uint16_be buf 3 len ;
+  Bytes.unsafe_to_string buf
 
 let pseudo_header seq ty (v_major, v_minor) v_length =
-  let open Cstruct in
-  let prefix = create 5 in
-  set_uint8 prefix 0 (Packet.content_type_to_int ty);
-  set_uint8 prefix 1 v_major;
-  set_uint8 prefix 2 v_minor;
-  BE.set_uint16 prefix 3 v_length;
-  sequence_buf seq <+> prefix
+  let buf = Bytes.create 13 in
+  Bytes.set_int64_be buf 0 seq;
+  Bytes.set_uint8 buf 8 (Packet.content_type_to_int ty);
+  Bytes.set_uint8 buf 9 v_major;
+  Bytes.set_uint8 buf 10 v_minor;
+  Bytes.set_uint16_be buf 11 v_length;
+  Bytes.unsafe_to_string buf
 
 (* MAC used in TLS *)
 let mac hash key pseudo_hdr data =
-  Hash.mac hash ~key (pseudo_hdr <+> data)
+  let module H = (val Digestif.module_of_hash' hash) in
+  H.(to_raw_string (hmac_string ~key (pseudo_hdr ^ data)))
 
 let cbc_block (type a) cipher =
   let module C = (val cipher : Cipher_block.S.CBC with type key = a) in C.block_size
 
 (* crazy CBC padding and unpadding for TLS *)
 let cbc_pad block data =
-  let open Cstruct in
-
   (* 1 is the padding length, encoded as 8 bit at the end of the fragment *)
-  let len = 1 + length data in
+  let len = 1 + String.length data in
   (* we might want to add additional blocks of padding *)
   let padding_length = block - (len mod block) in
   (* 1 is again padding length field *)
   let cstruct_len = padding_length + 1 in
-  let pad = create_unsafe cstruct_len in
-  memset pad padding_length;
-  pad
+  String.make cstruct_len (Char.unsafe_chr padding_length)
 
 let cbc_unpad data =
-  let open Cstruct in
-
-  let len = length data in
-  let padlen = get_uint8 data (pred len) in
-  let (res, pad) = split data (len - padlen - 1) in
+  let len = String.length data in
+  let padlen = String.get_uint8 data (pred len) in
 
   let rec check = function
     | i when i > padlen -> true
-    | i -> (get_uint8 pad i = padlen) && check (succ i) in
+    | i -> (String.get_uint8 data (len - padlen - 1 + i) = padlen) && check (succ i) in
 
   try
-    if check 0 then Some res else None
+    if check 0 then Some (String.sub data 0 (len - padlen - 1)) else None
   with Invalid_argument _ -> None
 
 let tag_len (type a) cipher =
@@ -155,7 +146,7 @@ let decrypt_aead (type a) ~cipher ~key ~nonce ?adata data =
 
 let encrypt_cbc (type a) ~cipher ~key ~iv data =
   let module C = (val cipher : Cipher_block.S.CBC with type key = a) in
-  let message = C.encrypt ~key ~iv (data <+> cbc_pad C.block_size data) in
+  let message = C.encrypt ~key ~iv (data ^ cbc_pad C.block_size data) in
   (message, C.next_iv ~iv message)
 
 let decrypt_cbc (type a) ~cipher ~key ~iv data =
diff --git a/lib/dune b/lib/dune
index ccbf124a..f23d6d8d 100644
--- a/lib/dune
+++ b/lib/dune
@@ -1,4 +1,4 @@
 (library
  (name tls)
  (public_name tls)
- (libraries cstruct logs hkdf mirage-crypto mirage-crypto-rng mirage-crypto-pk x509 domain-name fmt mirage-crypto-ec ipaddr))
+ (libraries logs hkdf ohex digestif mirage-crypto mirage-crypto-rng mirage-crypto-pk x509 domain-name fmt mirage-crypto-ec ipaddr))
diff --git a/lib/engine.ml b/lib/engine.ml
index 44febeef..7a519697 100644
--- a/lib/engine.ml
+++ b/lib/engine.ml
@@ -84,9 +84,9 @@ let string_of_failure = Fmt.to_to_string pp_failure
 
 type ret =
   (state * [ `Eof ] option
-   * [ `Response of Cstruct.t option ]
-   * [ `Data of Cstruct.t option ],
-   failure * [ `Response of Cstruct.t ]) result
+   * [ `Response of string option ]
+   * [ `Data of string option ],
+   failure * [ `Response of string ]) result
 
 let new_state config role =
   let handshake_state = match role with
@@ -100,26 +100,26 @@ let new_state config role =
     early_data_left  = 0l ;
     machina          = handshake_state ;
     config           = config ;
-    hs_fragment      = Cstruct.create 0 ;
+    hs_fragment      = "" ;
   }
   in
   {
     handshake = handshake ;
     decryptor = None ;
     encryptor = None ;
-    fragment  = Cstruct.empty ;
+    fragment  = "" ;
     read_closed = false ;
     write_closed = false ;
   }
 
-type raw_record = tls_hdr * Cstruct.t
+type raw_record = tls_hdr * string
 
 let pp_raw_record ppf (hdr, data) =
-  Fmt.pf ppf "%a (%u bytes data)" pp_tls_hdr hdr (Cstruct.length data)
+  Fmt.pf ppf "%a (%u bytes data)" pp_tls_hdr hdr (String.length data)
 
 let pp_frame ppf (ty, data) =
   Fmt.pf ppf "%a (%u bytes data)" Packet.pp_content_type ty
-    (Cstruct.length data)
+    (String.length data)
 
 (* well-behaved pure encryptor *)
 let encrypt (version : tls_version) (st : crypto_state) ty buf =
@@ -131,12 +131,11 @@ let encrypt (version : tls_version) (st : crypto_state) ty buf =
         (match ctx.cipher_st with
          | AEAD c ->
             let buf =
-              let t = Cstruct.create 1 in
-              Cstruct.set_uint8 t 0 (Packet.content_type_to_int ty) ;
-              buf <+> t
+              let t = String.make 1 (Char.unsafe_chr (Packet.content_type_to_int ty)) in
+              buf ^ t
             in
             let nonce = Crypto.aead_nonce c.nonce ctx.sequence in
-            let adata = Crypto.adata_1_3 (Cstruct.length buf + Crypto.tag_len c.cipher) in
+            let adata = Crypto.adata_1_3 (String.length buf + Crypto.tag_len c.cipher) in
             let buf = Crypto.encrypt_aead ~cipher:c.cipher ~adata ~key:c.cipher_secret ~nonce buf in
             (Some { ctx with sequence = Int64.succ ctx.sequence }, Packet.APPLICATION_DATA, buf)
          | _ -> assert false)
@@ -144,12 +143,12 @@ let encrypt (version : tls_version) (st : crypto_state) ty buf =
         let pseudo_hdr =
           let seq = ctx.sequence
           and ver = pair_of_tls_version version
-        in
-        Crypto.pseudo_header seq ty ver (Cstruct.length buf)
+          in
+          Crypto.pseudo_header seq ty ver (String.length buf)
         in
         let to_encrypt mac mac_k =
           let signature = Crypto.mac mac mac_k pseudo_hdr buf in
-          buf <+> signature
+          buf ^ signature
         in
         let c_st, enc =
           match ctx.cipher_st with
@@ -162,7 +161,7 @@ let encrypt (version : tls_version) (st : crypto_state) ty buf =
                | Random_iv ->
                   let iv = Mirage_crypto_rng.generate (Crypto.cbc_block c.cipher) in
                   let m, _ = enc iv in
-                  (CBC c, iv <+> m)
+                  (CBC c, iv ^ m)
                | Iv iv ->
                   let m, iv' = enc iv in
                   (CBC { c with iv_mode = Iv iv' }, m) )
@@ -170,12 +169,12 @@ let encrypt (version : tls_version) (st : crypto_state) ty buf =
           | AEAD c ->
             if c.explicit_nonce then
               let explicit_nonce = Crypto.sequence_buf ctx.sequence in
-              let nonce = c.nonce <+> explicit_nonce
+              let nonce = c.nonce ^ explicit_nonce
               in
               let msg =
                 Crypto.encrypt_aead ~cipher:c.cipher ~key:c.cipher_secret ~nonce ~adata:pseudo_hdr buf
               in
-              (AEAD c, explicit_nonce <+> msg)
+              (AEAD c, explicit_nonce ^ msg)
             else
               (* RFC 7905: no explicit nonce, instead TLS 1.3 construction is adapted *)
               let nonce = Crypto.aead_nonce c.nonce ctx.sequence in
@@ -188,14 +187,17 @@ let encrypt (version : tls_version) (st : crypto_state) ty buf =
 
 (* well-behaved pure decryptor *)
 let verify_mac sequence mac mac_k ty ver decrypted =
-  let macstart = Cstruct.length decrypted - Mirage_crypto.Hash.digest_size mac in
+  let macstart =
+    let module H = (val Digestif.module_of_hash' mac) in
+    String.length decrypted - H.digest_size
+  in
   let* () = guard (macstart >= 0) (`Fatal `MACUnderflow) in
   let (body, mmac) = Cstruct.split decrypted macstart in
   let cmac =
     let ver = pair_of_tls_version ver in
-    let hdr = Crypto.pseudo_header sequence ty ver (Cstruct.length body) in
+    let hdr = Crypto.pseudo_header sequence ty ver (String.length body) in
     Crypto.mac mac mac_k hdr body in
-  let* () = guard (Cstruct.equal cmac mmac) (`Fatal `MACMismatch) in
+  let* () = guard (String.equal cmac mmac) (`Fatal `MACMismatch) in
   Ok body
 
 
@@ -233,7 +235,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
             let* msg, iv' = dec iv buf in
             Ok (CBC { c with iv_mode = Iv iv' }, msg)
          | Random_iv ->
-            if Cstruct.length buf < Crypto.cbc_block c.cipher then
+            if String.length buf < Crypto.cbc_block c.cipher then
               Error (`Fatal `MACUnderflow)
             else
               let iv, buf = Cstruct.split buf (Crypto.cbc_block c.cipher) in
@@ -243,14 +245,14 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
     | AEAD c ->
       if c.explicit_nonce then
         let explicit_nonce_len = 8 in
-        if Cstruct.length buf < explicit_nonce_len then
+        if String.length buf < explicit_nonce_len then
           Error (`Fatal `MACUnderflow)
         else
           let explicit_nonce, buf = Cstruct.split buf explicit_nonce_len in
           let adata =
             let ver = pair_of_tls_version version in
-            Crypto.pseudo_header seq ty ver (Cstruct.length buf - Crypto.tag_len c.cipher)
-          and nonce = c.nonce <+> explicit_nonce
+            Crypto.pseudo_header seq ty ver (String.length buf - Crypto.tag_len c.cipher)
+          and nonce = c.nonce ^ explicit_nonce
           in
           match Crypto.decrypt_aead ~cipher:c.cipher ~key:c.cipher_secret ~nonce ~adata buf with
           | None -> Error (`Fatal `MACMismatch)
@@ -259,7 +261,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
         (* RFC 7905: no explicit nonce, instead TLS 1.3 construction is adapted *)
         let adata =
           let ver = pair_of_tls_version version in
-          Crypto.pseudo_header seq ty ver (Cstruct.length buf - Crypto.tag_len c.cipher)
+          Crypto.pseudo_header seq ty ver (String.length buf - Crypto.tag_len c.cipher)
         and nonce = Crypto.aead_nonce c.nonce seq
         in
         (match Crypto.decrypt_aead ~adata ~cipher:c.cipher ~key:c.cipher_secret ~nonce buf with
@@ -275,7 +277,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
        CH [+key_share] ----->
        the APP_DATA above cannot be decrypted or used, so we drop it.
     *)
-    Ok (None, Cstruct.empty, Packet.APPLICATION_DATA)
+    Ok (None, "", Packet.APPLICATION_DATA)
   | None, _ -> Ok (st, buf, ty)
   | Some ctx, `TLS_1_3 ->
     (match ty with
@@ -287,19 +289,19 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
           let unpad x =
             let rec eat = function
               | -1 -> Error (`Fatal `MissingContentType)
-              | idx -> match Cstruct.get_uint8 x idx with
+              | idx -> match String.get_uint8 x idx with
                 | 0 -> eat (pred idx)
                 | n -> match Packet.int_to_content_type n with
-                  | Some ct -> Ok (Cstruct.sub x 0 idx, ct)
+                  | Some ct -> Ok (String.sub x 0 idx, ct)
                   | None -> Error (`Fatal `MACUnderflow) (* TODO better error? *)
             in
-            eat (pred (Cstruct.length x))
+            eat (pred (String.length x))
           in
-          let adata = Crypto.adata_1_3 (Cstruct.length buf) in
+          let adata = Crypto.adata_1_3 (String.length buf) in
           (match Crypto.decrypt_aead ~adata ~cipher:c.cipher ~key:c.cipher_secret ~nonce buf with
            | None ->
              if trial then
-               Ok (Some ctx, Cstruct.empty, Packet.APPLICATION_DATA)
+               Ok (Some ctx, "", Packet.APPLICATION_DATA)
              else
                Error (`Fatal `MACMismatch)
            | Some x ->
@@ -313,7 +315,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
     Ok (Some ctx', msg, ty)
 
 (* party time *)
-let rec separate_records : Cstruct.t -> ((tls_hdr * Cstruct.t) list * Cstruct.t, failure) result
+let rec separate_records : string -> ((tls_hdr * string) list * string, failure) result
 = fun buf ->
   let open Reader in
   match parse_record buf with
@@ -338,7 +340,7 @@ let rec separate_records : Cstruct.t -> ((tls_hdr * Cstruct.t) list * Cstruct.t,
 let encrypt_records encryptor version records =
   let rec split = function
     | [] -> []
-    | (t1, a) :: xs when Cstruct.length a >= 1 lsl 14 ->
+    | (t1, a) :: xs when String.length a >= 1 lsl 14 ->
       let fst, snd = Cstruct.split a (1 lsl 14) in
       (t1, fst) :: split ((t1, snd) :: xs)
     | x::xs -> x :: split xs
@@ -423,7 +425,7 @@ and handle_handshake = function
   | Server13 ss -> Handshake_server13.handle_handshake ss
 
 let non_empty cs =
-  if Cstruct.length cs = 0 then None else Some cs
+  if String.length cs = 0 then None else Some cs
 
 let handle_packet hs buf = function
 (* RFC 5246 -- 6.2.1.:
@@ -438,7 +440,7 @@ let handle_packet hs buf = function
     Ok (hs, [], None, eof)
 
   | Packet.APPLICATION_DATA ->
-    if hs_can_handle_appdata hs || (early_data hs && Cstruct.length hs.hs_fragment = 0) then
+    if hs_can_handle_appdata hs || (early_data hs && String.length hs.hs_fragment = 0) then
       (Tracing.cs ~tag:"application-data-in" buf;
        Ok (hs, [], non_empty buf, false))
     else
@@ -449,7 +451,7 @@ let handle_packet hs buf = function
      Ok (hs, items, None, false)
 
   | Packet.HANDSHAKE ->
-     let hss, hs_fragment = separate_handshakes (hs.hs_fragment <+> buf) in
+     let hss, hs_fragment = separate_handshakes (hs.hs_fragment ^ buf) in
      let hs = { hs with hs_fragment } in
      let* hs, items =
        List.fold_left (fun acc raw ->
@@ -462,7 +464,7 @@ let handle_packet hs buf = function
 
 let decrement_early_data hs ty buf =
   let bytes left cipher =
-    let count = Cstruct.length buf - fst (Ciphersuite.kn_13 (Ciphersuite.privprot13 cipher)) in
+    let count = String.length buf - fst (Ciphersuite.kn_13 (Ciphersuite.privprot13 cipher)) in
     let left' = Int32.sub left (Int32.of_int count) in
     if left' < 0l then Error (`Fatal `Toomany0rttbytes) else Ok left'
   in
@@ -493,7 +495,7 @@ let handle_raw_record state (hdr, buf as record : raw_record) =
   in
   let trial = match hs.machina with
     | Server13 (AwaitEndOfEarlyData13 _) | Server13 Established13 -> false
-    | Server13 _ -> hs.early_data_left > 0l && Cstruct.length hs.hs_fragment = 0
+    | Server13 _ -> hs.early_data_left > 0l && String.length hs.hs_fragment = 0
     | _ -> false
   in
   let* dec_st, dec, ty = decrypt ~trial version state.decryptor hdr.content_type buf in
@@ -517,14 +519,14 @@ let handle_raw_record state (hdr, buf as record : raw_record) =
   Ok (state', encs, data)
 
 let maybe_app a b = match a, b with
-  | Some x, Some y -> Some (x <+> y)
+  | Some x, Some y -> Some (x ^ y)
   | Some x, None   -> Some x
   | None  , Some y -> Some y
   | None  , None   -> None
 
 let assemble_records (version : tls_version) rs =
   let version = match version with `TLS_1_3 -> `TLS_1_2 | x -> x in
-  Cstruct.concat (List.map (Writer.assemble_hdr version) rs)
+  String.concat "" (List.map (Writer.assemble_hdr version) rs)
 
 (* main entry point *)
 let handle_tls state buf =
@@ -538,7 +540,7 @@ let handle_tls state buf =
       Ok (st', raw_rs @ raw_rs', maybe_app data data')
   in
   match
-    let* in_records, fragment = separate_records (state.fragment <+> buf) in
+    let* in_records, fragment = separate_records (state.fragment ^ buf) in
     let* state', out_records, data = handle_records state in_records in
     let version = state'.handshake.protocol_version in
     let resp = match out_records with
@@ -593,7 +595,7 @@ let send_application_data st css =
     List.iter (fun cs -> Tracing.cs ~tag:"application-data-out" cs) css ;
     let datas = match st.encryptor with
       (* Mitigate implicit IV in CBC mode: prepend empty fragment *)
-      | Some { cipher_st = CBC { iv_mode = Iv _ ; _ } ; _ } -> Cstruct.create 0 :: css
+      | Some { cipher_st = CBC { iv_mode = Iv _ ; _ } ; _ } -> "" :: css
       | _                                                   -> css
     in
     let ty = Packet.APPLICATION_DATA in
@@ -658,7 +660,7 @@ let client config =
    be safely sent to any server. *)
     | (_, `TLS_1_0) -> ([Packet.TLS_EMPTY_RENEGOTIATION_INFO_SCSV], [])
     | (`TLS_1_3, _) -> ([], [])
-    | _ -> ([], [`SecureRenegotiation (Cstruct.create 0)])
+    | _ -> ([], [`SecureRenegotiation ""])
   in
 
   let client_hello =
@@ -689,21 +691,24 @@ let client config =
       in
       (* if all goes well, we can compute the binder key and embed into ch! *)
       let early_secret = Handshake_crypto13.(derive (empty cipher) psk.secret) in
-      let binder_key = Handshake_crypto13.derive_secret early_secret "res binder" Cstruct.empty in
+      let binder_key = Handshake_crypto13.derive_secret early_secret "res binder" "" in
 
-      let hash = Cstruct.create (Mirage_crypto.Hash.digest_size (Ciphersuite.hash13 cipher)) in
+      let hash =
+        let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 cipher)) in
+        String.make H.digest_size '\x00'
+      in
       let incomplete_psks = [ (psk.identifier, obf_age), hash ] in
       let ch' = { client_hello with extensions = client_hello.extensions @ [ kex ; `PreSharedKeys incomplete_psks ] } in
       let ch'_raw = Writer.assemble_handshake (ClientHello ch') in
 
       let binders_len = binders_len incomplete_psks in
-      let ch_part = Cstruct.(sub ch'_raw 0 (length ch'_raw - binders_len)) in
+      let ch_part = String.(sub ch'_raw 0 (length ch'_raw - binders_len)) in
       let binder = Handshake_crypto13.finished early_secret.hash binder_key ch_part in
-      let blen = Cstruct.length binder in
-      let prefix = Cstruct.create 3 in
-      Cstruct.BE.set_uint16 prefix 0 (blen + 1) ;
-      Cstruct.set_uint8 prefix 2 blen ;
-      let raw = Cstruct.concat [ ch_part ; prefix ; binder ] in
+      let blen = String.length binder in
+      let prefix = Bytes.create 3 in
+      Bytes.set_uint16_be prefix 0 (blen + 1) ;
+      Bytes.set_uint8 prefix 2 blen ;
+      let raw = String.concat "" [ ch_part ; Bytes.unsafe_to_string prefix ; binder ] in
 
       let psks = [(psk.identifier, obf_age), binder] in
       let client_hello' = { client_hello with extensions = client_hello.extensions @ [ kex ; `PreSharedKeys psks ] } in
@@ -743,28 +748,29 @@ let export_key_material (e : epoch_data) ?context label length =
       let cipher = Option.get (Ciphersuite.ciphersuite_to_ciphersuite13 e.ciphersuite) in
       Ciphersuite.hash13 cipher
     in
+    let module H = (val Digestif.module_of_hash' hash) in
     let ems = e.exporter_master_secret in
     let prk =
-      let ctx = Mirage_crypto.Hash.digest hash Cstruct.empty in
+      let ctx = H.(to_raw_string (digest_string "")) in
       Handshake_crypto13.derive_secret_no_hash hash ems ~ctx label
     in
-    let ctx = Option.(value ~default:Cstruct.empty (map Cstruct.of_string context)) in
+    let ctx = Option.value ~default:"" context in
     Handshake_crypto13.derive_secret_no_hash
-      hash prk ~ctx:(Mirage_crypto.Hash.digest hash ctx)
+      hash prk ~ctx:H.(to_raw_string (digest_string ctx))
       ~length "exporter"
   | #tls_before_13 as v ->
     let seed =
       let base =
         match e.side with
-        | `Server -> Cstruct.append e.peer_random e.own_random
-        | `Client -> Cstruct.append e.own_random e.peer_random
+        | `Server -> e.peer_random ^ e.own_random
+        | `Client -> e.own_random ^ e.peer_random
       in
       match context with
       | None -> base
       | Some data ->
-        let len = Cstruct.create 2 in
-        Cstruct.BE.set_uint16 len 0 (String.length data);
-        Cstruct.concat [ base ; len ; Cstruct.of_string data ]
+        let len = Bytes.create 2 in
+        Bytes.set_uint16_be len 0 (String.length data);
+        String.concat "" [ base ; Bytes.unsafe_to_string len ; data ]
     in
     Handshake_crypto.pseudo_random_function v e.ciphersuite
       length e.master_secret label seed
diff --git a/lib/engine.mli b/lib/engine.mli
index eb89d1dd..8f88ddbd 100644
--- a/lib/engine.mli
+++ b/lib/engine.mli
@@ -44,7 +44,7 @@ type state
 
 (** [client client] is [tls * out] where [tls] is the initial state,
     and [out] the initial client hello *)
-val client : Config.client -> (state * Cstruct.t)
+val client : Config.client -> (state * string)
 
 (** [server server] is [tls] where [tls] is the initial server
     state *)
@@ -73,8 +73,8 @@ type client_hello_errors = [
   | `NoKeyShareExtension
   | `NoSupportedGroupExtension
   | `NotSetSupportedGroup of Packet.named_group list
-  | `NotSetKeyShare of (Packet.named_group * Cstruct.t) list
-  | `NotSubsetKeyShareSupportedGroup of (Packet.named_group list * (Packet.named_group * Cstruct.t) list)
+  | `NotSetKeyShare of (Packet.named_group * string) list
+  | `NotSubsetKeyShareSupportedGroup of (Packet.named_group list * (Packet.named_group * string) list)
   | `Has0rttAfterHRR
   | `NoCookie
 ]
@@ -151,13 +151,13 @@ val pp_failure : failure Fmt.t
     potentially some [`Data] for the application was received. *)
 type ret =
   (state * [ `Eof ] option
-   * [ `Response of Cstruct.t option ]
-   * [ `Data of Cstruct.t option ],
-   failure * [ `Response of Cstruct.t ]) result
+   * [ `Response of string option ]
+   * [ `Data of string option ],
+   failure * [ `Response of string ]) result
 
 (** [handle_tls state buffer] is [ret], depending on incoming [state]
     and [buffer], the result is the appropriate {!ret} *)
-val handle_tls           : state -> Cstruct.t -> ret
+val handle_tls           : state -> string -> ret
 
 (** [handshake_in_progrss state] is a predicate which indicates whether there
     is a handshake in progress or scheduled. *)
@@ -167,11 +167,11 @@ val handshake_in_progress : state -> bool
     [tls'] is the new tls state, and [out] the cstruct to send over the
     wire (encrypted [outs]) when the TLS session is ready. When the TLS
     session is not ready it is [None]. *)
-val send_application_data : state -> Cstruct.t list -> (state * Cstruct.t) option
+val send_application_data : state -> string list -> (state * string) option
 
 (** [send_close_notify tls] is [tls' * out] where [tls'] is the new
     tls state, and out the (possible encrypted) close notify alert. *)
-val send_close_notify     : state -> state * Cstruct.t
+val send_close_notify     : state -> state * string
 
 (** [reneg ~authenticator ~acceptable_cas ~cert tls] initiates a renegotation on
     [tls], using the provided [authenticator]. It is [tls' * out] where [tls']
@@ -179,12 +179,12 @@ val send_close_notify     : state -> state * Cstruct.t
     (depending on which communication endpoint [tls] is). *)
 val reneg : ?authenticator:X509.Authenticator.t ->
   ?acceptable_cas:X509.Distinguished_name.t list -> ?cert:Config.own_cert ->
-  state -> (state * Cstruct.t) option
+  state -> (state * string) option
 
 (** [key_update ~request state] initiates a KeyUpdate (TLS 1.3 only). If
     [request] is provided and [true] (the default), the KeyUpdate message
     contains a request that the peer should update their traffic key as well. *)
-val key_update : ?request:bool -> state -> (state * Cstruct.t, failure) result
+val key_update : ?request:bool -> state -> (state * string, failure) result
 
 (** {1 Session information} *)
 
@@ -196,7 +196,7 @@ val epoch : state -> (Core.epoch_data, unit) result
     exported key material of [length] bytes using [label] and, if provided,
     [context]. *)
 val export_key_material : Core.epoch_data -> ?context:string -> string -> int ->
-  Cstruct.t
+  string
 
 (** [channel_binding epoch_data mode] is the RFC 5929 and RFC 9266 specified
     channel binding. Please note that [`Tls_unique] will error for TLS 1.3
@@ -204,4 +204,4 @@ val export_key_material : Core.epoch_data -> ?context:string -> string -> int ->
     (unless the uniqueness is ensured via another path). *)
 val channel_binding : Core.epoch_data ->
   [ `Tls_exporter | `Tls_unique | `Tls_server_endpoint ] ->
-  (Cstruct.t, [ `Msg of string ]) result
+  (string, [ `Msg of string ]) result
diff --git a/lib/handshake_client.mli b/lib/handshake_client.mli
index f10a0c61..ea944c22 100644
--- a/lib/handshake_client.mli
+++ b/lib/handshake_client.mli
@@ -2,6 +2,6 @@ open Core
 open State
 
 val default_client_hello : Config.config -> (client_hello * tls_version * (group * dh_secret) list)
-val handle_change_cipher_spec : client_handshake_state -> handshake_state -> Cstruct.t -> (handshake_return, failure) result
-val handle_handshake : client_handshake_state -> handshake_state -> Cstruct.t -> (handshake_return, failure) result
+val handle_change_cipher_spec : client_handshake_state -> handshake_state -> string -> (handshake_return, failure) result
+val handle_handshake : client_handshake_state -> handshake_state -> string -> (handshake_return, failure) result
 val answer_hello_request : handshake_state -> (handshake_return, failure) result
diff --git a/lib/handshake_client13.ml b/lib/handshake_client13.ml
index bae2a12d..2111b42f 100644
--- a/lib/handshake_client13.ml
+++ b/lib/handshake_client13.ml
@@ -9,7 +9,7 @@ let answer_server_hello state ch (sh : server_hello) secrets raw log =
   | None -> Error (`Fatal `InvalidServerHello)
   | Some cipher ->
     let* () = guard (List.mem cipher (ciphers13 state.config)) (`Fatal `InvalidServerHello) in
-    let* () = guard (Cstruct.length state.hs_fragment = 0) (`Fatal `HandshakeFragmentsNotEmpty) in
+    let* () = guard (String.length state.hs_fragment = 0) (`Fatal `HandshakeFragmentsNotEmpty) in
 
     (* TODO: PSK *)
     (* TODO: early_secret elsewhere *)
@@ -20,24 +20,27 @@ let answer_server_hello state ch (sh : server_hello) secrets raw log =
       | None -> Error (`Fatal `InvalidServerHello)
       | Some (_, secret) ->
         let* shared = Handshake_crypto13.dh_shared secret share in
-        let hlen = Mirage_crypto.Hash.digest_size (Ciphersuite.hash13 cipher) in
+        let hlen =
+          let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 cipher)) in
+          H.digest_size
+        in
         let* psk, resumed =
           match
             Utils.map_find ~f:(function `PreSharedKey idx -> Some idx | _ -> None) sh.extensions,
             state.config.Config.cached_ticket
           with
-          | None, _ | _, None -> Ok (Cstruct.create hlen, false)
+          | None, _ | _, None -> Ok (String.make hlen '\x00', false)
           | Some idx, Some (psk, _epoch) ->
             let* () = guard (idx = 0) (`Fatal `InvalidServerHello) in
             Ok (psk.secret, true)
         in
         let early_secret = Handshake_crypto13.(derive (empty cipher) psk) in
         let hs_secret = Handshake_crypto13.derive early_secret shared in
-        let log = log <+> raw in
+        let log = log ^ raw in
         let server_hs_secret, server_ctx, client_hs_secret, client_ctx =
           Handshake_crypto13.hs_ctx hs_secret log in
         let master_secret =
-          Handshake_crypto13.derive hs_secret (Cstruct.create hlen)
+          Handshake_crypto13.derive hs_secret (String.make hlen '\x00')
         in
         let session =
           let base = empty_session13 cipher in
@@ -77,9 +80,12 @@ let answer_hello_retry_request state (ch : client_hello) hrr _secrets raw log =
   let other_exts = List.filter (function `KeyShare _ -> false | _ -> true) ch.extensions in
   let new_ch = { ch with extensions = `KeyShare [keyshare] :: other_exts @ cookie} in
   let new_ch_raw = Writer.assemble_handshake (ClientHello new_ch) in
-  let ch0_data = Mirage_crypto.Hash.digest (Ciphersuite.hash13 hrr.ciphersuite) log in
-  let ch0_hdr = Writer.assemble_message_hash (Cstruct.length ch0_data) in
-  let st = AwaitServerHello13 (new_ch, [secret], Cstruct.concat [ ch0_hdr ; ch0_data ; raw ; new_ch_raw ]) in
+  let ch0_data =
+    let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 hrr.ciphersuite)) in
+    H.(to_raw_string (digest_string log))
+  in
+  let ch0_hdr = Writer.assemble_message_hash (String.length ch0_data) in
+  let st = AwaitServerHello13 (new_ch, [secret], String.concat "" [ ch0_hdr ; ch0_data ; raw ; new_ch_raw ]) in
 
   Tracing.hs ~tag:"handshake-out" (ClientHello new_ch);
   Ok ({ state with machina = Client13 st ; protocol_version = `TLS_1_3 }, [`Record (Packet.HANDSHAKE, new_ch_raw)])
@@ -94,9 +100,9 @@ let answer_encrypted_extensions state (session : session_data13) server_hs_secre
   in
   let st =
     if session.resumed then
-      AwaitServerFinished13 (session, server_hs_secret, client_hs_secret, None, log <+> raw)
+      AwaitServerFinished13 (session, server_hs_secret, client_hs_secret, None, log ^ raw)
     else
-      AwaitServerCertificateRequestOrCertificate13 (session, server_hs_secret, client_hs_secret, log <+> raw)
+      AwaitServerCertificateRequestOrCertificate13 (session, server_hs_secret, client_hs_secret, log ^ raw)
   in
   Ok ({ state with machina = Client13 st }, [])
 
@@ -113,18 +119,21 @@ let answer_certificate state (session : session_data13) server_hs_secret client_
     } in
     { session with common_session_data13 }
   in
-  let st = AwaitServerCertificateVerify13 (session, server_hs_secret, client_hs_secret, sigalgs, log <+> raw) in
+  let st = AwaitServerCertificateVerify13 (session, server_hs_secret, client_hs_secret, sigalgs, log ^ raw) in
   Ok ({ state with machina = Client13 st }, [])
 
 let answer_certificate_verify (state : handshake_state) (session : session_data13) server_hs_secret client_hs_secret sigalgs cv raw log =
-  let tbs = Mirage_crypto.Hash.digest (Ciphersuite.hash13 session.ciphersuite13) log in
+  let tbs =
+    let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 session.ciphersuite13)) in
+    H.(to_raw_string (digest_string log))
+  in
   let* () =
     verify_digitally_signed state.protocol_version
       ~context_string:"TLS 1.3, server CertificateVerify"
       state.config.signature_algorithms cv tbs
       session.common_session_data13.peer_certificate
   in
-  let st = AwaitServerFinished13 (session, server_hs_secret, client_hs_secret, sigalgs, log <+> raw) in
+  let st = AwaitServerFinished13 (session, server_hs_secret, client_hs_secret, sigalgs, log ^ raw) in
   Ok ({ state with machina = Client13 st }, [])
 
 let answer_certificate_request (state : handshake_state) (session : session_data13) server_hs_secret client_hs_secret extensions raw log =
@@ -134,15 +143,15 @@ let answer_certificate_request (state : handshake_state) (session : session_data
     { session with common_session_data13 }
   in
   let sigalgs = Utils.map_find ~f:(function `SignatureAlgorithms s -> Some s | _ -> None) extensions in
-  let st = AwaitServerCertificate13 (session, server_hs_secret, client_hs_secret, sigalgs, log <+> raw) in
+  let st = AwaitServerCertificate13 (session, server_hs_secret, client_hs_secret, sigalgs, log ^ raw) in
   Ok ({ state with machina = Client13 st }, [])
 
 let answer_finished state (session : session_data13) server_hs_secret client_hs_secret sigalgs fin raw log =
   let hash = Ciphersuite.hash13 session.ciphersuite13 in
   let f_data = Handshake_crypto13.finished hash server_hs_secret log in
-  let* () = guard (Cstruct.equal fin f_data) (`Fatal `BadFinished) in
-  let* () = guard (Cstruct.length state.hs_fragment = 0) (`Fatal `HandshakeFragmentsNotEmpty) in
-  let log = log <+> raw in
+  let* () = guard (String.equal fin f_data) (`Fatal `BadFinished) in
+  let* () = guard (String.length state.hs_fragment = 0) (`Fatal `HandshakeFragmentsNotEmpty) in
+  let log = log ^ raw in
   let server_app_secret, server_app_ctx, client_app_secret, client_app_ctx =
     Handshake_crypto13.app_ctx session.master_secret log
   in
@@ -157,16 +166,19 @@ let answer_finished state (session : session_data13) server_hs_secret client_hs_
       in
       let certificate =
         let cs = List.map X509.Certificate.encode_der own_certificate in
-        Certificate (Writer.assemble_certificates_1_3 Cstruct.empty cs)
+        Certificate (Writer.assemble_certificates_1_3 "" cs)
       in
       let cert_raw = Writer.assemble_handshake certificate in
       Tracing.hs ~tag:"handshake-out" certificate ;
-      let log = log <+> cert_raw in
+      let log = log ^ cert_raw in
       match own_private_key with
       | None ->
         Ok ([cert_raw], log)
       | Some priv ->
-        let tbs = Mirage_crypto.Hash.digest hash log in
+        let tbs =
+          let module H = (val Digestif.module_of_hash' hash) in
+          H.(to_raw_string (digest_string log))
+        in
         let* signed =
           signature `TLS_1_3 ~context_string:"TLS 1.3, client CertificateVerify"
             tbs sigalgs state.config.Config.signature_algorithms priv
@@ -174,7 +186,7 @@ let answer_finished state (session : session_data13) server_hs_secret client_hs_
         let cv = CertificateVerify signed in
         Tracing.hs ~tag:"handshake-out" cv ;
         let cv_raw = Writer.assemble_handshake cv in
-        Ok ([ cert_raw ; cv_raw ], log <+> cv_raw)
+        Ok ([ cert_raw ; cv_raw ], log ^ cv_raw)
     else
       Ok ([], log)
   in
@@ -182,7 +194,8 @@ let answer_finished state (session : session_data13) server_hs_secret client_hs_
   let myfin = Handshake_crypto13.finished hash client_hs_secret log in
   let mfin = Writer.assemble_handshake (Finished myfin) in
 
-  let resumption_secret = Handshake_crypto13.resumption session.master_secret (log <+> mfin) in
+  let exporter_master_secret = Handshake_crypto13.exporter session.master_secret log in
+  let resumption_secret = Handshake_crypto13.resumption session.master_secret (log ^ mfin) in
   let session = { session with resumption_secret ; exporter_master_secret ; client_app_secret ; server_app_secret } in
   let machina = Client13 Established13 in
 
@@ -218,7 +231,7 @@ let answer_session_ticket state st =
 let handle_key_update state req =
   match state.session with
   | `TLS13 session :: _ ->
-    let* () = guard (Cstruct.length state.hs_fragment = 0) (`Fatal `HandshakeFragmentsNotEmpty) in
+    let* () = guard (String.length state.hs_fragment = 0) (`Fatal `HandshakeFragmentsNotEmpty) in
     let server_app_secret, server_ctx =
       Handshake_crypto13.app_secret_n_1 session.master_secret session.server_app_secret
     in
@@ -257,12 +270,12 @@ let handle_handshake cs hs buf =
   | AwaitServerCertificateRequestOrCertificate13 (sd, es, ss, log), Certificate cs ->
     let* con, cs = map_reader_error (parse_certificates_1_3 cs) in
     (* during handshake, context must be empty! and we'll not get any new certificate from server *)
-    let* () = guard (Cstruct.length con = 0) (`Fatal `InvalidMessage) in
+    let* () = guard (String.length con = 0) (`Fatal `InvalidMessage) in
     answer_certificate hs sd es ss None cs buf log
   | AwaitServerCertificate13 (sd, es, ss, sigalgs, log), Certificate cs ->
     let* con, cs = map_reader_error (parse_certificates_1_3 cs) in
     (* during handshake, context must be empty! and we'll not get any new certificate from server *)
-    let* () = guard (Cstruct.length con = 0) (`Fatal `InvalidMessage) in
+    let* () = guard (String.length con = 0) (`Fatal `InvalidMessage) in
     answer_certificate hs sd es ss sigalgs cs buf log
   | AwaitServerCertificateVerify13 (sd, es, ss, sigalgs, log), CertificateVerify cv ->
     answer_certificate_verify hs sd es ss sigalgs cv buf log
diff --git a/lib/handshake_common.ml b/lib/handshake_common.ml
index fc6519fe..ec111b9c 100644
--- a/lib/handshake_common.ml
+++ b/lib/handshake_common.ml
@@ -104,8 +104,8 @@ let get_alpn_protocol (sh : server_hello) =
   Utils.map_find ~f:(function `ALPN protocol -> Some protocol | _ -> None) sh.extensions
 
 let empty_common_session_data = {
-  server_random          = Cstruct.create 0 ;
-  client_random          = Cstruct.create 0 ;
+  server_random          = "" ;
+  client_random          = "" ;
   peer_certificate_chain = [] ;
   peer_certificate       = None ;
   trust_anchor           = None ;
@@ -114,7 +114,7 @@ let empty_common_session_data = {
   own_private_key        = None ;
   own_name               = None ;
   client_auth            = false ;
-  master_secret          = Cstruct.empty ;
+  master_secret          = "" ;
   alpn_protocol          = None ;
 }
 
@@ -123,8 +123,8 @@ let empty_session = {
   client_version      = `TLS_1_2 ;
   ciphersuite         = `DHE_RSA_WITH_AES_256_CBC_SHA ;
   group               = Some `FFDHE2048 ;
-  renegotiation       = Cstruct.(empty, empty) ;
-  session_id          = Cstruct.empty ;
+  renegotiation       = "", "" ;
+  session_id          = "" ;
   extended_ms         = false ;
   tls_unique          = Cstruct.empty ;
 }
@@ -133,12 +133,12 @@ let empty_session13 cipher = {
   common_session_data13  = empty_common_session_data ;
   ciphersuite13          = cipher ;
   master_secret          = Handshake_crypto13.empty cipher ;
-  exporter_master_secret = Cstruct.empty ;
-  resumption_secret      = Cstruct.empty ;
+  exporter_master_secret = "" ;
+  resumption_secret      = "" ;
   state                  = `Established ;
   resumed                = false ;
-  client_app_secret      = Cstruct.empty ;
-  server_app_secret      = Cstruct.empty ;
+  client_app_secret      = "" ;
+  server_app_secret      = "" ;
 }
 
 let common_session_data_of_epoch (epoch : epoch_data) common_session_data =
@@ -332,15 +332,14 @@ let server_hello_valid (sh : server_hello) =
 let to_sign_1_3 context_string =
   (* input is prepended by 64 * 0x20 (to avoid cross-version attacks) *)
   (* input for signature now contains also a context string *)
-  let prefix = Cstruct.create 64 in
-  Cstruct.memset prefix 0x20 ;
+  let prefix = String.make 64 '\x20' in
   let ctx =
-    let stop = Cstruct.create 1 (* trailing 0 byte *) in
+    let stop = String.make 1 '\x00' (* trailing 0 byte *) in
     match context_string with
     | None -> stop
-    | Some x -> Cstruct.of_string x <+> stop
+    | Some x -> x ^ stop
   in
-  prefix <+> ctx
+  prefix ^ ctx
 
 let signature version ?context_string data client_sig_algs signature_algorithms (private_key : X509.Private_key.t) =
   match version with
@@ -349,7 +348,10 @@ let signature version ?context_string data client_sig_algs signature_algorithms
       match private_key with
       | `RSA key ->
         begin try
-            let data = Hash.MD5.digest data <+> Hash.SHA1.digest data in
+            let data =
+              Digestif.(MD5.(to_raw_string (digest_string data)) ^
+                        SHA1.(to_raw_string (digest_string data)))
+            in
             Ok (Mirage_crypto_pk.Rsa.PKCS1.sig_encode ~key data)
           with Mirage_crypto_pk.Rsa.Insufficient_key ->
             Error (`Fatal `KeyTooSmall)
@@ -385,7 +387,7 @@ let signature version ?context_string data client_sig_algs signature_algorithms
   | `TLS_1_3 ->
     let to_sign =
       let prefix = to_sign_1_3 context_string in
-      prefix <+> data
+      prefix ^ data
     in
     let* sig_alg =
       let* client_algos =
@@ -426,9 +428,10 @@ let verify_digitally_signed version ?context_string sig_algs data signature_data
             (Mirage_crypto_pk.Rsa.PKCS1.sig_decode ~key signature)
         in
         let computed =
-          Hash.(MD5.digest signature_data <+> SHA1.digest signature_data)
+          Digestif.(MD5.(to_raw_string (digest_string signature_data)) ^
+                    SHA1.(to_raw_string (digest_string signature_data)))
         in
-        guard (Cstruct.equal raw computed)
+        guard (String.equal raw computed)
           (`Fatal (`SignatureVerificationFailed "RSA PKCS1 raw <> computed"))
       | key ->
         Result.map_error
@@ -461,7 +464,7 @@ let verify_digitally_signed version ?context_string sig_algs data signature_data
     and scheme = signature_scheme_of_signature_algorithm sig_alg
     and data =
       let prefix = to_sign_1_3 context_string in
-      prefix <+> signature_data
+      prefix ^ signature_data
     in
     Result.map_error
       (function `Msg m -> `Fatal (`SignatureVerificationFailed m))
@@ -488,7 +491,7 @@ let validate_chain authenticator certificates ip hostname =
         | Ok c -> Some c
         | Error `Msg msg ->
           Log.warn (fun m -> m "cannot decode certificate %s:@.%a" msg
-                       Cstruct.hexdump_pp cs);
+                       (Ohex.pp_hexdump ()) cs);
           None
       in
       List.filter_map f certs
diff --git a/lib/handshake_crypto.ml b/lib/handshake_crypto.ml
index d213c1f3..3ba524c8 100644
--- a/lib/handshake_crypto.ml
+++ b/lib/handshake_crypto.ml
@@ -1,11 +1,7 @@
-open Mirage_crypto.Hash
-
 open State
 
-let (<+>) = Cstruct.append
-
 let halve secret =
-  let size = Cstruct.length secret in
+  let size = String.length secret in
   let half = size - size / 2 in
   Cstruct.(sub secret 0 half, sub secret (size - half) half)
 
diff --git a/lib/handshake_crypto.mli b/lib/handshake_crypto.mli
index fa638e46..6ad85c94 100644
--- a/lib/handshake_crypto.mli
+++ b/lib/handshake_crypto.mli
@@ -1,9 +1,9 @@
 open State
 
-val derive_master_secret : Core.tls_before_13 -> session_data -> Cstruct.t -> Cstruct.t list -> Core.master_secret
+val derive_master_secret : Core.tls_before_13 -> session_data -> string -> string list -> Core.master_secret
 val initialise_crypto_ctx : Core.tls_before_13 -> session_data -> (crypto_context * crypto_context)
-val finished : Core.tls_before_13 -> Ciphersuite.ciphersuite -> Cstruct.t -> string -> Cstruct.t list -> Cstruct.t
+val finished : Core.tls_before_13 -> Ciphersuite.ciphersuite -> string -> string -> string list -> string
 
 (** [pseudo_random_function version cipher length secret label seed] *)
 val pseudo_random_function : Core.tls_before_13 -> Ciphersuite.ciphersuite ->
-  int -> Cstruct.t -> string -> Cstruct.t -> Cstruct.t
+  int -> string -> string -> string -> string
diff --git a/lib/handshake_crypto13.ml b/lib/handshake_crypto13.ml
index bad8134e..6f2995a5 100644
--- a/lib/handshake_crypto13.ml
+++ b/lib/handshake_crypto13.ml
@@ -7,13 +7,13 @@ let cdiv (x : int) (y : int) =
 
 let left_pad_dh group msg =
   let bytes = cdiv (Mirage_crypto_pk.Dh.modulus_size group) 8 in
-  let padding = Cstruct.create (bytes - Cstruct.length msg) in
-  padding <+> msg
+  let padding = String.make (bytes - String.length msg) '\x00' in
+  padding ^ msg
 
 let not_all_zero r =
   let* cs = r in
-  let all_zero = Cstruct.create (Cstruct.length cs) in
-  if Cstruct.equal all_zero cs then
+  let all_zero = String.make (String.length cs) '\x00' in
+  if String.equal all_zero cs then
     Error (`Fatal `InvalidDH)
   else
     Ok cs
@@ -29,7 +29,7 @@ let dh_shared secret share =
        let bits = Mirage_crypto_pk.Dh.modulus_size group in
        let* () =
          (* truncated share, better reject this *)
-         guard (Cstruct.length share = cdiv bits 8) (`Fatal `InvalidDH)
+         guard (String.length share = cdiv bits 8) (`Fatal `InvalidDH)
        in
        let* shared =
          Option.to_result
@@ -72,27 +72,25 @@ let pp_hash_k_n ciphersuite =
   (pp, hash, k, n)
 
 let hkdflabel label context length =
-  let len =
-    let b = Cstruct.create 2 in
-    Cstruct.BE.set_uint16 b 0 length ;
-    b
-  and label =
-    let lbl = Cstruct.of_string ("tls13 " ^ label) in
-    let l = Cstruct.create 1 in
-    Cstruct.set_uint8 l 0 (Cstruct.length lbl) ;
-    l <+> lbl
-  and context =
-    let l = Cstruct.create 1 in
-    Cstruct.set_uint8 l 0 (Cstruct.length context) ;
-    l <+> context
+  let lbl = "tls13 " ^ label in
+  let len_llen = Bytes.create 3 in
+  Bytes.set_uint16_be len_llen 0 length;
+  Bytes.set_uint8 len_llen 2 (String.length lbl);
+  let clen = String.make 1 (Char.unsafe_chr (String.length context)) in
+  let lbl = String.concat ""
+      [ Bytes.unsafe_to_string len_llen ;
+        lbl ;
+        clen ;
+        context ]
   in
-  let lbl = len <+> label <+> context in
   trace "hkdflabel" lbl ;
   lbl
 
-let derive_secret_no_hash hash prk ?length ?(ctx = Cstruct.empty) label =
+let derive_secret_no_hash hash prk ?length ?(ctx = "") label =
   let length = match length with
-    | None -> Mirage_crypto.Hash.digest_size hash
+    | None ->
+      let module H = (val Digestif.module_of_hash' hash) in
+      H.digest_size
     | Some x -> x
   in
   let info = hkdflabel label ctx length in
@@ -102,22 +100,23 @@ let derive_secret_no_hash hash prk ?length ?(ctx = Cstruct.empty) label =
   key
 
 let derive_secret t label log =
-  let ctx = Mirage_crypto.Hash.digest t.State.hash log in
+  let module H = (val Digestif.module_of_hash' t.State.hash) in
+  let ctx = H.(to_raw_string (digest_string log)) in
   trace "derive secret ctx" ctx ;
   derive_secret_no_hash t.State.hash t.State.secret ~ctx label
 
 let empty cipher = {
-  State.secret = Cstruct.empty ;
+  State.secret = "" ;
   cipher ;
   hash = Ciphersuite.hash13 cipher
 }
 
 let derive t secret_ikm =
   let salt =
-    if Cstruct.equal t.State.secret Cstruct.empty then
-      Cstruct.empty
+    if String.equal t.State.secret "" then
+      ""
     else
-      derive_secret t "derived" Cstruct.empty
+      derive_secret t "derived" ""
   in
   trace "derive: secret_ikm" secret_ikm ;
   trace "derive: salt" salt ;
@@ -127,9 +126,9 @@ let derive t secret_ikm =
 
 let traffic_key cipher prk =
   let _, hash, key_len, iv_len = pp_hash_k_n cipher in
-  let key_info = hkdflabel "key" Cstruct.empty key_len in
+  let key_info = hkdflabel "key" "" key_len in
   let key = Hkdf.expand ~hash ~prk ~info:key_info key_len in
-  let iv_info = hkdflabel "iv" Cstruct.empty iv_len in
+  let iv_info = hkdflabel "iv" "" iv_len in
   let iv = Hkdf.expand ~hash ~prk ~info:iv_info iv_len in
   (key, iv)
 
@@ -175,5 +174,6 @@ let res_secret hash secret nonce =
   derive_secret_no_hash hash secret ~ctx:nonce "resumption"
 
 let finished hash secret data =
+  let module H = (val Digestif.module_of_hash' hash) in
   let key = derive_secret_no_hash hash secret "finished" in
-  Mirage_crypto.Hash.mac hash ~key (Mirage_crypto.Hash.digest hash data)
+  H.(to_raw_string (hmac_string ~key (to_raw_string (digest_string data))))
diff --git a/lib/handshake_server.mli b/lib/handshake_server.mli
index 424cb953..d0a31ad6 100644
--- a/lib/handshake_server.mli
+++ b/lib/handshake_server.mli
@@ -2,5 +2,5 @@ open State
 
 val hello_request : handshake_state -> (handshake_return, failure) result
 
-val handle_change_cipher_spec : server_handshake_state -> handshake_state -> Cstruct.t -> (handshake_return, failure) result
-val handle_handshake : server_handshake_state -> handshake_state -> Cstruct.t -> (handshake_return, failure) result
+val handle_change_cipher_spec : server_handshake_state -> handshake_state -> string -> (handshake_return, failure) result
+val handle_handshake : server_handshake_state -> handshake_state -> string -> (handshake_return, failure) result
diff --git a/lib/handshake_server13.ml b/lib/handshake_server13.ml
index dd25aaa7..3965d6b8 100644
--- a/lib/handshake_server13.ml
+++ b/lib/handshake_server13.ml
@@ -82,7 +82,10 @@ let answer_client_hello ~hrr state ch raw =
       begin match Utils.first_match groups config.Config.groups with
         | None -> Error (`Fatal `NoSupportedGroup)
         | Some group ->
-          let cookie = Mirage_crypto.Hash.digest (Ciphersuite.hash13 cipher) raw in
+          let cookie =
+            let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 cipher)) in
+            H.(to_raw_string (digest_string raw))
+          in
           let hrr = { retry_version = `TLS_1_3 ; ciphersuite = cipher ; sessionid = ch.sessionid ; selected_group = group ; extensions = [ `Cookie cookie ] } in
           let hrr_raw = Writer.assemble_handshake (HelloRetryRequest hrr) in
           Tracing.hs ~tag:"handshake-out" (HelloRetryRequest hrr) ;
@@ -113,19 +116,22 @@ let answer_client_hello ~hrr state ch raw =
               (Utils.map_find ~f:(function `Cookie c -> Some c | _ -> None) ch.extensions)
           in
           (* log is: 254 00 00 length c :: HRR *)
-          let hash_hdr = Writer.assemble_message_hash (Cstruct.length c) in
+          let hash_hdr = Writer.assemble_message_hash (String.length c) in
           let hrr = { retry_version = `TLS_1_3 ; ciphersuite = cipher ; sessionid = ch.sessionid ; selected_group = group ; extensions = [ `Cookie c ]} in
           let hs_buf = Writer.assemble_handshake (HelloRetryRequest hrr) in
-          Ok (Cstruct.concat [ hash_hdr ; c ; hs_buf ])
+          Ok (String.concat "" [ hash_hdr ; c ; hs_buf ])
         else
-          Ok Cstruct.empty
+          Ok ""
       in
 
       let hostname = hostname ch in
-      let hlen = Mirage_crypto.Hash.digest_size (Ciphersuite.hash13 cipher) in
+      let hlen =
+        let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 cipher)) in
+        H.digest_size
+      in
 
       let early_secret, epoch, exts, can_use_early_data =
-        let secret ?(psk = Cstruct.create hlen) () = Handshake_crypto13.(derive (empty cipher) psk) in
+        let secret ?(psk = String.make hlen '\x00') () = Handshake_crypto13.(derive (empty cipher) psk) in
         let no_resume = secret (), None, [], false in
         match
           config.Config.ticket_cache,
@@ -191,12 +197,12 @@ let answer_client_hello ~hrr state ch raw =
                       in
                       if Ptime.is_earlier now ~than:until then
                         let early_secret = secret ~psk:psk.secret () in
-                        let binder_key = Handshake_crypto13.derive_secret early_secret "res binder" Cstruct.empty in
+                        let binder_key = Handshake_crypto13.derive_secret early_secret "res binder" "" in
                         let binders_len = binders_len ids in
-                        let ch_part = Cstruct.(sub raw 0 (length raw - binders_len)) in
-                        let log = Cstruct.append log ch_part in
+                        let ch_part = String.(sub raw 0 (length raw - binders_len)) in
+                        let log = log ^ ch_part in
                         let binder' = Handshake_crypto13.finished early_secret.hash binder_key log in
-                        if Cstruct.equal binder binder' then begin
+                        if String.equal binder binder' then begin
                           (* from 4.1.2 - earlydata is not allowed after hrr *)
                           let zero = idx = 0 && not hrr && List.mem `EarlyDataIndication ch.extensions in
                           early_secret, Some old_epoch, [ `PreSharedKey idx ], zero
@@ -219,7 +225,7 @@ let answer_client_hello ~hrr state ch raw =
       let sh_raw = Writer.assemble_handshake (ServerHello sh) in
       Tracing.hs ~tag:"handshake-out" (ServerHello sh) ;
 
-      let log = log <+> raw <+> sh_raw in
+      let log = log ^ raw ^ sh_raw in
       let server_hs_secret, server_ctx, client_hs_secret, client_ctx = hs_ctx hs_secret log in
 
       let* sigalgs =
@@ -255,7 +261,7 @@ let answer_client_hello ~hrr state ch raw =
       (* TODO also max_fragment_length ; client_certificate_url ; trusted_ca_keys ; user_mapping ; client_authz ; server_authz ; cert_type ; use_srtp ; heartbeat ; alpn ; status_request_v2 ; signed_cert_timestamp ; client_cert_type ; server_cert_type *)
       let ee_raw = Writer.assemble_handshake ee in
       Tracing.hs ~tag:"handshake-out" ee ;
-      let log = Cstruct.append log ee_raw in
+      let log = log ^ ee_raw in
 
       let* c_out, log, session' =
         if session.resumed then
@@ -276,16 +282,19 @@ let answer_client_hello ~hrr state ch raw =
               Tracing.hs ~tag:"handshake-out" certreq ;
               let raw_cert_req = Writer.assemble_handshake certreq in
               let common_session_data13 = { session.common_session_data13 with client_auth = true } in
-              [raw_cert_req], log <+> raw_cert_req, { session with common_session_data13 }
+              [raw_cert_req], log ^ raw_cert_req, { session with common_session_data13 }
           in
 
           let certs = List.map X509.Certificate.encode_der chain in
-          let cert = Certificate (Writer.assemble_certificates_1_3 Cstruct.empty certs) in
+          let cert = Certificate (Writer.assemble_certificates_1_3 "" certs) in
           let cert_raw = Writer.assemble_handshake cert in
           Tracing.hs ~tag:"handshake-out" cert ;
-          let log = log <+> cert_raw in
+          let log = log ^ cert_raw in
 
-          let tbs = Mirage_crypto.Hash.digest (Ciphersuite.hash13 cipher) log in
+          let tbs =
+            let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 cipher)) in
+            H.(to_raw_string (digest_string log))
+          in
           let* signed =
             signature `TLS_1_3
               ~context_string:"TLS 1.3, server CertificateVerify"
@@ -294,11 +303,11 @@ let answer_client_hello ~hrr state ch raw =
           let cv = CertificateVerify signed in
           let cv_raw = Writer.assemble_handshake cv in
           Tracing.hs ~tag:"handshake-out" cv ;
-          let log = log <+> cv_raw in
+          let log = log ^ cv_raw in
           Ok (out @ [cert_raw; cv_raw], log, session)
       in
 
-      let master_secret = Handshake_crypto13.derive hs_secret (Cstruct.create hlen) in
+      let master_secret = Handshake_crypto13.derive hs_secret (String.make hlen '\x00') in
       Tracing.cs ~tag:"master-secret" master_secret.secret ;
 
       let f_data = finished hs_secret.hash server_hs_secret log in
@@ -307,7 +316,7 @@ let answer_client_hello ~hrr state ch raw =
 
       Tracing.hs ~tag:"handshake-out" fin ;
 
-      let log = log <+> fin_raw in
+      let log = log ^ fin_raw in
       let server_app_secret, server_app_ctx, client_app_secret, client_app_ctx =
         app_ctx master_secret log
       in
@@ -315,7 +324,7 @@ let answer_client_hello ~hrr state ch raw =
       let session' = { session' with server_app_secret ; client_app_secret ; exporter_master_secret } in
 
       let* () =
-        guard (Cstruct.length state.hs_fragment = 0)
+        guard (String.length state.hs_fragment = 0)
           (`Fatal `HandshakeFragmentsNotEmpty)
       in
 
@@ -327,7 +336,7 @@ let answer_client_hello ~hrr state ch raw =
         | false, Some cache ->
           let age_add =
             let cs = Mirage_crypto_rng.generate 4 in
-            Cstruct.BE.get_uint32 cs 0
+            String.get_int32_be cs 0
           in
           let psk_id = Mirage_crypto_rng.generate 32 in
           let nonce = Mirage_crypto_rng.generate 4 in
@@ -383,7 +392,7 @@ let answer_client_certificate state cert (sd : session_data13) client_fini dec_c
         in
         let common_session_data13 = { sd.common_session_data13 with trust_anchor } in
         let sd = { sd with common_session_data13 } in
-        let st = AwaitClientFinished13 (client_fini, dec_ctx, st, log <+> raw) in
+        let st = AwaitClientFinished13 (client_fini, dec_ctx, st, log ^ raw) in
         Ok ({ state with machina = Server13 st ; session = `TLS13 sd :: state.session }, [])
       | Error e -> Error (`Error (`AuthenticationFailure e))
     end
@@ -403,18 +412,21 @@ let answer_client_certificate state cert (sd : session_data13) client_fini dec_c
       } in
       { sd with common_session_data13 }
     in
-    let st = AwaitClientCertificateVerify13 (sd', client_fini, dec_ctx, st, log <+> raw) in
+    let st = AwaitClientCertificateVerify13 (sd', client_fini, dec_ctx, st, log ^ raw) in
     Ok ({ state with machina = Server13 st }, [])
 
 let answer_client_certificate_verify state cv (sd : session_data13) client_fini dec_ctx st raw log =
-  let tbs = Mirage_crypto.Hash.digest (Ciphersuite.hash13 sd.ciphersuite13) log in
+  let tbs =
+    let module H = (val Digestif.module_of_hash' (Ciphersuite.hash13 sd.ciphersuite13)) in
+    H.(to_raw_string (digest_string log))
+  in
   let* () =
     verify_digitally_signed `TLS_1_3
       ~context_string:"TLS 1.3, client CertificateVerify"
       state.config.Config.signature_algorithms cv tbs
       sd.common_session_data13.peer_certificate
   in
-  let st = AwaitClientFinished13 (client_fini, dec_ctx, st, log <+> raw) in
+  let st = AwaitClientFinished13 (client_fini, dec_ctx, st, log ^ raw) in
   Ok ({ state with machina = Server13 st ; session = `TLS13 sd :: state.session }, [])
 
 let answer_client_finished state fin client_fini dec_ctx st raw log =
@@ -422,15 +434,15 @@ let answer_client_finished state fin client_fini dec_ctx st raw log =
   | `TLS13 session :: rest ->
     let hash = Ciphersuite.hash13 session.ciphersuite13 in
     let data = finished hash client_fini log in
-    let* () = guard (Cstruct.equal data fin) (`Fatal `BadFinished) in
+    let* () = guard (String.equal data fin) (`Fatal `BadFinished) in
     let* () =
-      guard (Cstruct.length state.hs_fragment = 0)
+      guard (String.length state.hs_fragment = 0)
         (`Fatal `HandshakeFragmentsNotEmpty)
     in
     let session' = match st, state.config.Config.ticket_cache with
       | None, _ | _, None -> session
       | Some st, Some cache ->
-        let resumption_secret = Handshake_crypto13.resumption session.master_secret (log <+> raw) in
+        let resumption_secret = Handshake_crypto13.resumption session.master_secret (log ^ raw) in
         let session = { session with resumption_secret } in
         let secret = Handshake_crypto13.res_secret hash resumption_secret st.nonce in
         let issued_at = cache.Config.timestamp () in
@@ -444,7 +456,7 @@ let answer_client_finished state fin client_fini dec_ctx st raw log =
   | _ -> Error (`Fatal `InvalidSession)
 
 let handle_end_of_early_data state cf hs_ctx cc st buf log =
-  let machina = AwaitClientFinished13 (cf, cc, st, log <+> buf) in
+  let machina = AwaitClientFinished13 (cf, cc, st, log ^ buf) in
   match state.session with
   | `TLS13 s1 :: _ ->
     let session = `TLS13 { s1 with state = `Established } :: state.session in
@@ -456,7 +468,7 @@ let handle_key_update state req =
   match state.session with
   | `TLS13 session :: _ ->
     let* () =
-      guard (Cstruct.length state.hs_fragment = 0)
+      guard (String.length state.hs_fragment = 0)
         (`Fatal `HandshakeFragmentsNotEmpty)
     in
     let client_app_secret, client_ctx =
diff --git a/lib/packet.ml b/lib/packet.ml
index 9694dc17..c6997bfe 100644
--- a/lib/packet.ml
+++ b/lib/packet.ml
@@ -2,11 +2,11 @@
 
 (* HACK: 24 bits type not in cstruct *)
 let get_uint24_len buf =
-  (Cstruct.BE.get_uint16 buf 0) * 0x100 + (Cstruct.get_uint8 buf 2)
+  (String.get_uint16_be buf 0) * 0x100 + (String.get_uint8 buf 2)
 
 let set_uint24_len buf num =
-  Cstruct.BE.set_uint16 buf 0 (num / 0x100);
-  Cstruct.set_uint8 buf 2 (num mod 0x100)
+  Bytes.set_uint16_be buf 0 (num / 0x100);
+  Bytes.set_uint8 buf 2 (num mod 0x100)
 
 (* TLS record content type *)
 type content_type =
@@ -789,6 +789,6 @@ and int_to_key_update_request_type = function
   | 1 -> Some UPDATE_REQUESTED
   | _ -> None
 
-let helloretryrequest = Mirage_crypto.Hash.digest `SHA256 (Cstruct.of_string "HelloRetryRequest")
-let downgrade12 = Cstruct.of_hex "44 4F 57 4E 47 52 44 01"
-let downgrade11 = Cstruct.of_hex "44 4F 57 4E 47 52 44 00"
+let helloretryrequest = Digestif.SHA256.(to_raw_string (digest_string "HelloRetryRequest"))
+let downgrade12 = "\x44\x4F\x57\x4E\x47\x52\x44\x01"
+let downgrade11 = "\x44\x4F\x57\x4E\x47\x52\x44\x00"
diff --git a/lib/reader.ml b/lib/reader.ml
index b1805648..927cfa5b 100644
--- a/lib/reader.ml
+++ b/lib/reader.ml
@@ -1,6 +1,5 @@
 open Packet
 open Core
-open Cstruct
 
 type error =
   | TrailingBytes  of string
@@ -36,8 +35,8 @@ let catch f x =
   | Invalid_argument _ -> Error Underflow
 
 let parse_version_int buf =
-  let major = get_uint8 buf 0 in
-  let minor = get_uint8 buf 1 in
+  let major = String.get_uint8 buf 0 in
+  let minor = String.get_uint8 buf 1 in
   (major, minor)
 
 let parse_version_exn buf =
@@ -56,7 +55,7 @@ let parse_any_version_exn buf =
   match parse_any_version_opt buf with
   | Some x, _ -> x
   | None, _ ->
-    let major, minor = (get_uint8 buf 0, get_uint8 buf 1) in
+    let major, minor = (String.get_uint8 buf 0, String.get_uint8 buf 1) in
     raise (Reader_error (UnknownVersion (major, minor)))
 
 let parse_version = catch parse_version_exn
@@ -64,19 +63,19 @@ let parse_version = catch parse_version_exn
 let parse_any_version = catch parse_any_version_exn
 
 let parse_record buf =
-  if length buf < 5 then
+  if String.length buf < 5 then
     Ok (`Fragment buf)
   else
-    let typ = get_uint8 buf 0
+    let typ = String.get_uint8 buf 0
     and version = parse_version_int (shift buf 1)
     in
-    match BE.get_uint16 buf 3 with
+    match String.get_uint16_be buf 3 with
     | x when x > (1 lsl 14 + 2048) ->
       (* 2 ^ 14 + 2048 for TLSCiphertext
          2 ^ 14 + 1024 for TLSCompressed
          2 ^ 14 for TLSPlaintext *)
       Error (Overflow x)
-    | x when 5 + x > length buf -> Ok (`Fragment buf)
+    | x when 5 + x > String.length buf -> Ok (`Fragment buf)
     | x ->
       match
         tls_any_version_of_pair version,
@@ -111,18 +110,18 @@ let validate_alert (lvl, typ) =
   | lvl, typ -> (lvl, typ)
 
 let parse_alert = catch @@ fun buf ->
-  if length buf <> 2 then
+  if String.length buf <> 2 then
     raise_trailing_bytes "after alert"
   else
-    let level = get_uint8 buf 0 in
-    let typ = get_uint8 buf 1 in
+    let level = String.get_uint8 buf 0 in
+    let typ = String.get_uint8 buf 1 in
     match int_to_alert_level level, int_to_alert_type typ with
       | (Some lvl, Some msg) -> validate_alert (lvl, msg)
       | (Some _  , None)     -> raise_unknown @@ "alert type " ^ string_of_int typ
       | _                    -> raise_unknown @@ "alert level " ^ string_of_int level
 
 let parse_change_cipher_spec buf =
-  match length buf, get_uint8 buf 0 with
+  match String.length buf, String.get_uint8 buf 0 with
   | 1, 1 -> Ok ()
   | _    -> Error (Unknown "bad change cipher spec message")
 
@@ -134,7 +133,7 @@ let rec parse_count_list parsef buf acc = function
      | None     , buf' -> parse_count_list parsef buf'          acc  (pred n)
 
 let rec parse_list parsef buf acc =
-  match length buf with
+  match String.length buf with
   | 0 -> List.rev acc
   | _ ->
      match parsef buf with
@@ -142,19 +141,19 @@ let rec parse_list parsef buf acc =
      | None     , buf' -> parse_list parsef buf'          acc
 
 let parse_compression_method buf =
-  let cm = get_uint8 buf 0 in
+  let cm = String.get_uint8 buf 0 in
   (int_to_compression_method cm, shift buf 1)
 
 let parse_compression_methods buf =
-  let count = get_uint8 buf 0 in
+  let count = String.get_uint8 buf 0 in
   parse_count_list parse_compression_method (shift buf 1) [] count
 
 let parse_any_ciphersuite buf =
-  let typ = BE.get_uint16 buf 0 in
+  let typ = String.get_uint16_be buf 0 in
   (int_to_any_ciphersuite typ, shift buf 2)
 
 let parse_any_ciphersuites buf =
-  let count = BE.get_uint16 buf 0 in
+  let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "ciphersuite list"
   else
@@ -168,42 +167,42 @@ let parse_ciphersuite buf =
                        | Some cs' -> (Some cs', buf')
 
 let parse_hostnames buf =
-  match length buf with
+  match String.length buf with
   | 0 -> []
   | n ->
      let parsef buf =
-       let typ = get_uint8 buf 0 in
-       let entrylen = BE.get_uint16 buf 1 in
+       let typ = String.get_uint8 buf 0 in
+       let entrylen = String.get_uint16_be buf 1 in
        let rt = shift buf (3 + entrylen) in
        match typ with
        | 0 -> let hostname = to_string ~off:3 ~len:entrylen buf in
               (Some hostname, rt)
        | _ -> (None, rt)
      in
-     let list_length = BE.get_uint16 buf 0 in
+     let list_length = String.get_uint16_be buf 0 in
      if list_length + 2 <> n then
        raise_trailing_bytes "hostname"
      else
        parse_list parsef (sub buf 2 list_length) []
 
 let parse_fragment_length buf =
-  if length buf <> 1 then
+  if String.length buf <> 1 then
     raise_trailing_bytes "fragment length"
   else
-    int_to_max_fragment_length (get_uint8 buf 0)
+    int_to_max_fragment_length (String.get_uint8 buf 0)
 
 let parse_supported_version buf =
   parse_any_version_opt buf
 
 let parse_supported_versions buf =
-  let len = get_uint8 buf 0 in
+  let len = String.get_uint8 buf 0 in
   if len mod 2 <> 0 then
     raise_wrong_length "supported versions"
   else
     parse_count_list parse_supported_version (shift buf 1) [] (len / 2)
 
 let parse_named_group buf =
-  let typ = BE.get_uint16 buf 0 in
+  let typ = String.get_uint16_be buf 0 in
   (int_to_named_group typ, shift buf 2)
 
 let parse_group buf =
@@ -212,49 +211,49 @@ let parse_group buf =
   | None, buf -> (None, buf)
 
 let parse_supported_groups buf =
-  let count = BE.get_uint16 buf 0 in
+  let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "elliptic curve list"
   else
     let cs, rt = parse_count_list parse_named_group (shift buf 2) [] (count / 2) in
-    if length rt <> 0 then
+    if String.length rt <> 0 then
       raise_trailing_bytes "elliptic curves"
     else
       cs
 
 let parse_signature_algorithm buf =
-  match int_to_signature_alg (BE.get_uint16 buf 0) with
+  match int_to_signature_alg (String.get_uint16_be buf 0) with
   | Some sig_alg -> of_signature_alg sig_alg
   | _            -> None
 
 let parse_signature_algorithms buf =
   let parsef buf = parse_signature_algorithm buf, shift buf 2 in
-  let count = BE.get_uint16 buf 0 in
+  let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "signature hash"
   else
     parse_count_list parsef (shift buf 2) [] (count / 2)
 
 let parse_alpn_protocol raw =
-  let length = get_uint8 raw 0 in
+  let length = String.get_uint8 raw 0 in
   let buf = sub raw 1 length in
   let protocol = Cstruct.to_string buf in
   (Some protocol, shift raw (1 + length))
 
 let parse_alpn_protocols buf =
-  let len = BE.get_uint16 buf 0 in
-  if length buf <> len + 2 then
+  let len = String.get_uint16_be buf 0 in
+  if String.length buf <> len + 2 then
     raise_trailing_bytes "alpn"
   else
     parse_list parse_alpn_protocol (sub buf 2 len) []
 
 let parse_ec_point_format buf =
   (* this is deprecated, we only check that uncompressed (typ 0) is present *)
-  let data = get_uint8 buf 0 in
+  let data = String.get_uint8 buf 0 in
   Some (data = 0), shift buf 1
 
 let parse_ec_point_formats buf =
-  let count = get_uint8 buf 0 in
+  let count = String.get_uint8 buf 0 in
   parse_count_list parse_ec_point_format (shift buf 1) [] count
 
 let parse_extension buf = function
@@ -263,19 +262,19 @@ let parse_extension buf = function
       | Some mfl -> `MaxFragmentLength mfl
       | None     -> raise_unknown "maximum fragment length")
   | RENEGOTIATION_INFO ->
-       let len' = get_uint8 buf 0 in
-       if length buf <> len' + 1 then
+       let len' = String.get_uint8 buf 0 in
+       if String.length buf <> len' + 1 then
          raise_trailing_bytes "renegotiation"
        else
          `SecureRenegotiation (sub buf 1 len')
   | EXTENDED_MASTER_SECRET ->
-      if length buf > 0 then
+      if String.length buf > 0 then
          raise_trailing_bytes "extended master secret"
       else
         `ExtendedMasterSecret
   | EC_POINT_FORMATS ->
     let formats, rt = parse_ec_point_formats buf in
-    if length rt <> 0 then
+    if String.length rt <> 0 then
       raise_trailing_bytes "ec point formats"
     else if List.mem true formats then
       `ECPointFormats
@@ -285,7 +284,7 @@ let parse_extension buf = function
 
 let parse_keyshare_entry buf =
   let parse_share data =
-    let size = BE.get_uint16 data 0 in
+    let size = String.get_uint16_be data 0 in
     split (shift data 2) size
   in
   let g, rest = parse_named_group buf in
@@ -295,43 +294,43 @@ let parse_keyshare_entry buf =
   | Some g -> Some (g, share), left
 
 let parse_id buf =
-  let id_len = BE.get_uint16 buf 0 in
+  let id_len = String.get_uint16_be buf 0 in
   if id_len = 0 then (* id must be non-empty! *)
     raise_wrong_length "PSK id is empty"
   else
-    let age = BE.get_uint32 buf (id_len + 2) in
+    let age = String.get_int32_be buf (id_len + 2) in
     (Some (sub buf 2 id_len, age), shift buf (id_len + 6))
 
 let parse_binder buf =
-  let l = get_uint8 buf 0 in
+  let l = String.get_uint8 buf 0 in
   Some (sub buf 1 l), shift buf (l + 1)
 
 let parse_client_presharedkeys buf =
-  let id_len = BE.get_uint16 buf 0 in
+  let id_len = String.get_uint16_be buf 0 in
   let identities = parse_list parse_id (sub buf 2 id_len) [] in
-  let binders_len = BE.get_uint16 buf (id_len + 2) in
+  let binders_len = String.get_uint16_be buf (id_len + 2) in
   let binders = parse_list parse_binder (sub buf (4 + id_len) binders_len) [] in
   let id_binder = List.combine identities binders in
-  if length buf <> 4 + binders_len + id_len then
+  if String.length buf <> 4 + binders_len + id_len then
     raise_trailing_bytes "psk"
   else
     id_binder
 
 let parse_cookie buf =
-  let len = BE.get_uint16 buf 0 in
+  let len = String.get_uint16_be buf 0 in
   (sub buf 2 len, shift buf (2 + len))
 
 let parse_psk_key_exchange_mode buf =
-  let data = get_uint8 buf 0 in
+  let data = String.get_uint8 buf 0 in
   (int_to_psk_key_exchange_mode data, shift buf 1)
 
 let parse_psk_key_exchange_modes buf =
-  let count = get_uint8 buf 0 in
+  let count = String.get_uint8 buf 0 in
   parse_count_list parse_psk_key_exchange_mode (shift buf 1) [] count
 
 let parse_ext raw =
-  let etype = BE.get_uint16 raw 0
-  and length = BE.get_uint16 raw 2
+  let etype = String.get_uint16_be raw 0
+  and length = String.get_uint16_be raw 2
   in
   (etype, length, sub raw 4 length)
 
@@ -358,7 +357,7 @@ let parse_client_extension raw =
        let rec check = function
          | 0 -> `Padding len
          | n -> let idx = pred n in
-                if get_uint8 buf idx <> 0 then
+                if String.get_uint8 buf idx <> 0 then
                   raise_unknown "bad padding in padding extension"
                 else
                   check idx
@@ -366,7 +365,7 @@ let parse_client_extension raw =
        check len
     | Some SIGNATURE_ALGORITHMS ->
        let algos, rt = parse_signature_algorithms buf in
-       if length rt <> 0 then
+       if String.length rt <> 0 then
          raise_trailing_bytes "signature algorithms"
        else
          `SignatureAlgorithms algos
@@ -374,8 +373,8 @@ let parse_client_extension raw =
       let protocols = parse_alpn_protocols buf in
       `ALPN protocols
     | Some KEY_SHARE ->
-       let ll = BE.get_uint16 buf 0 in
-       if ll + 2 <> length buf then
+       let ll = String.get_uint16_be buf 0 in
+       if ll + 2 <> String.length buf then
          raise_unknown "bad key share extension"
        else
          let shares = parse_list parse_keyshare_entry (sub buf 2 ll) [] in
@@ -384,30 +383,30 @@ let parse_client_extension raw =
       let ids = parse_client_presharedkeys buf in
       `PreSharedKeys ids
     | Some EARLY_DATA ->
-      if length buf <> 0 then
+      if String.length buf <> 0 then
         raise_trailing_bytes "early data"
       else
         `EarlyDataIndication
     | Some SUPPORTED_VERSIONS ->
       let versions, rt = parse_supported_versions buf in
-      if length rt <> 0 then
+      if String.length rt <> 0 then
         raise_trailing_bytes "supported versions"
       else
         `SupportedVersions versions
     | Some POST_HANDSHAKE_AUTH ->
-      if length buf = 0 then
+      if String.length buf = 0 then
         `PostHandshakeAuthentication
       else
         raise_unknown "non-empty post handshake authentication"
     | Some COOKIE ->
       let c, rt = parse_cookie buf in
-      if length rt <> 0 then
+      if String.length rt <> 0 then
         raise_trailing_bytes "cookie"
       else
         `Cookie c
     | Some PSK_KEY_EXCHANGE_MODES ->
       let modes, rt = parse_psk_key_exchange_modes buf in
-      if length rt <> 0 then
+      if String.length rt <> 0 then
         raise_trailing_bytes "psk key exchange modes"
       else
         `PskKeyExchangeModes modes
@@ -426,17 +425,17 @@ let parse_server_extension raw =
         | _      -> raise_unknown "bad server name indication (multiple names)")
     | Some KEY_SHARE ->
        (match parse_keyshare_entry buf with
-        | _, xs when length xs <> 0 -> raise_trailing_bytes "server keyshare"
+        | _, xs when String.length xs <> 0 -> raise_trailing_bytes "server keyshare"
         | None, _ -> raise_unknown "keyshare entry"
         | Some (g, ks), _ ->
           match named_group_to_group g with
           | Some g -> `KeyShare (g, ks)
           | None -> raise_unknown "keyshare entry")
     | Some PRE_SHARED_KEY ->
-      if length buf <> 2 then
+      if String.length buf <> 2 then
         raise_trailing_bytes "server pre_shared_key"
       else
-        `PreSharedKey (BE.get_uint16 buf 0)
+        `PreSharedKey (String.get_uint16_be buf 0)
     | Some SUPPORTED_GROUPS | Some SIGNATURE_ALGORITHMS | Some PADDING ->
        raise_unknown "invalid extension in server hello!"
     | Some APPLICATION_LAYER_PROTOCOL_NEGOTIATION ->
@@ -468,7 +467,7 @@ let parse_encrypted_extension raw =
        | [protocol] -> `ALPN protocol
        | _ -> raise_unknown "bad ALPN (none or multiple names)")
     | Some EARLY_DATA ->
-       if length buf <> 0 then
+       if String.length buf <> 0 then
          raise_trailing_bytes "server early_data"
        else
          `EarlyDataIndication
@@ -484,7 +483,7 @@ let parse_retry_extension raw =
     | Some KEY_SHARE ->
       begin
         let group, rt = parse_group buf in
-        if length rt <> 0 then
+        if String.length rt <> 0 then
           raise_trailing_bytes "key share"
         else
           match group with
@@ -496,7 +495,7 @@ let parse_retry_extension raw =
       `SelectedVersion version
     | Some COOKIE ->
       let c, rt = parse_cookie buf in
-       if length rt <> 0 then
+       if String.length rt <> 0 then
          raise_trailing_bytes "cookie"
        else
          `Cookie c
@@ -505,8 +504,8 @@ let parse_retry_extension raw =
   (Some data, shift raw (4 + len))
 
 let parse_extensions parse_ext buf =
-  let len = BE.get_uint16 buf 0 in
-  if length buf <> len + 2 then
+  let len = String.get_uint16_be buf 0 in
+  if String.length buf <> len + 2 then
     raise_trailing_bytes "extensions"
   else
     parse_list parse_ext (sub buf 2 len) []
@@ -514,12 +513,12 @@ let parse_extensions parse_ext buf =
 let parse_client_hello buf =
   let client_version = parse_any_version_exn buf in
   let client_random = sub buf 2 32 in
-  let slen = get_uint8 buf 34 in
+  let slen = String.get_uint8 buf 34 in
   let sessionid = if slen = 0 then None else Some (sub buf 35 slen) in
   let ciphersuites, rt = parse_any_ciphersuites (shift buf (35 + slen)) in
   let _, rt' = parse_compression_methods rt in
   let extensions =
-    if length rt' = 0 then [] else parse_extensions parse_client_extension rt'
+    if String.length rt' = 0 then [] else parse_extensions parse_client_extension rt'
   in
   (* TLS 1.3 mandates PreSharedKeys to be the last extension *)
   (if List.exists (function `PreSharedKeys _ -> true | _ -> false) extensions then
@@ -531,7 +530,7 @@ let parse_client_hello buf =
 let parse_server_hello buf =
   let server_version = parse_version_exn buf in
   let server_random = sub buf 2 32 in
-  let slen = get_uint8 buf 34 in
+  let slen = String.get_uint8 buf 34 in
   let sessionid = if slen = 0 then None else Some (sub buf 35 slen) in
   let ciphersuite, rt = match parse_ciphersuite (shift buf (35 + slen)) with
     | Some x, buf' -> (x, buf')
@@ -543,13 +542,13 @@ let parse_server_hello buf =
     | None     , _    -> raise_unknown "compression method"
   in
   (* depending on the content of the server_random we have to diverge in behaviour *)
-  if Cstruct.equal server_random helloretryrequest then begin
+  if String.equal server_random helloretryrequest then begin
     (* hello retry request, TODO: verify compression=empty *)
     match Ciphersuite.ciphersuite_to_ciphersuite13 ciphersuite with
     | None -> raise_unknown "unsupported ciphersuite in hello retry request"
     | Some ciphersuite ->
       let extensions =
-        if length rt' = 0 then [] else parse_extensions parse_retry_extension rt'
+        if String.length rt' = 0 then [] else parse_extensions parse_retry_extension rt'
       in
       let retry_version =
         match Utils.map_find ~f:(function `SelectedVersion v -> Some v | _ -> None) extensions with
@@ -564,7 +563,7 @@ let parse_server_hello buf =
       HelloRetryRequest { retry_version ; sessionid ; ciphersuite ; selected_group ; extensions }
   end else begin
     let extensions =
-      if length rt' = 0 then [] else parse_extensions parse_server_extension rt'
+      if String.length rt' = 0 then [] else parse_extensions parse_server_extension rt'
     in
     let server_version =
       match Utils.map_find ~f:(function `SelectedVersion v -> Some v | _ -> None) extensions with
@@ -580,7 +579,7 @@ let parse_certificates_exn buf =
     (Some (sub buf 3 len), shift buf (len + 3))
   in
   let len = get_uint24_len buf in
-  if length buf <> len + 3 then
+  if String.length buf <> len + 3 then
     raise_trailing_bytes "certificates"
   else
     parse_list parsef (sub buf 3 len) []
@@ -588,13 +587,13 @@ let parse_certificates_exn buf =
 let parse_certificates = catch @@ parse_certificates_exn
 
 (* TODO finish implementation of certificate extensions *)
-let parse_certificate_ext _ = None, Cstruct.empty
+let parse_certificate_ext _ = None, ""
 
 let parse_certificate_ext_1_3_exn buf =
   let certlen = get_uint24_len buf in
   let cert, extbuf, rest =
     let cert, rt = split (shift buf 3) certlen in
-    let ext_len = BE.get_uint16 rt 0 in
+    let ext_len = String.get_uint16_be rt 0 in
     let extbuf, rt = split (shift rt 2) ext_len in
     cert, extbuf, rt
   in
@@ -603,13 +602,13 @@ let parse_certificate_ext_1_3_exn buf =
 
 let parse_certificate_ext_list_1_3_exn buf =
   let len = get_uint24_len buf in
-  if length buf <> len + 3 then
+  if String.length buf <> len + 3 then
     raise_trailing_bytes "certificates"
   else
     parse_list parse_certificate_ext_1_3_exn (shift buf 3) []
 
 let parse_certificates_1_3_exn buf =
-  let clen = get_uint8 buf 0 in
+  let clen = String.get_uint8 buf 0 in
   let context, rt = split (shift buf 1) clen in
   let certs = parse_certificate_ext_list_1_3_exn rt in
   (context, certs)
@@ -618,26 +617,26 @@ let parse_certificates_1_3 = catch @@ parse_certificates_1_3_exn
 
 let parse_certificate_types buf =
   let parsef buf =
-    let byte = get_uint8 buf 0 in
+    let byte = String.get_uint8 buf 0 in
     (int_to_client_certificate_type byte, shift buf 1)
   in
-  let count = get_uint8 buf 0 in
+  let count = String.get_uint8 buf 0 in
   parse_count_list parsef (shift buf 1) [] count
 
 let parse_cas buf =
   let parsef buf =
-    let length = BE.get_uint16 buf 0 in
+    let length = String.get_uint16_be buf 0 in
     let name = sub buf 2 length in
     (Some name, shift buf (2 + length))
   in
-  let calength = BE.get_uint16 buf 0 in
+  let calength = String.get_uint16_be buf 0 in
   let cas, rt = split (shift buf 2) calength in
   (parse_list parsef cas [], rt)
 
 let parse_certificate_request_exn buf =
   let certificate_types, buf' = parse_certificate_types buf in
   let certificate_authorities, buf' = parse_cas buf' in
-  if length buf' <> 0 then
+  if String.length buf' <> 0 then
     raise_trailing_bytes "certificate request"
   else
     (certificate_types, certificate_authorities)
@@ -649,7 +648,7 @@ let parse_certificate_request_1_2_exn buf =
   let certificate_types, buf' = parse_certificate_types buf in
   let sigs, buf' = parse_signature_algorithms buf' in
   let cas, buf' = parse_cas buf' in
-  if length buf' <> 0 then
+  if String.length buf' <> 0 then
     raise_trailing_bytes "certificate request"
   else
     (certificate_types, sigs, cas)
@@ -662,13 +661,13 @@ let parse_certificate_request_extension raw =
   let data = match int_to_extension_type etype with
     | Some SIGNATURE_ALGORITHMS ->
       let algos, rt = parse_signature_algorithms buf in
-      if length rt <> 0 then
+      if String.length rt <> 0 then
         raise_trailing_bytes "signature algorithms"
       else
         `SignatureAlgorithms algos
     | Some CERTIFICATE_AUTHORITIES ->
       let cas, rt = parse_cas buf in
-      if length rt <> 0 then
+      if String.length rt <> 0 then
         raise_trailing_bytes "certificate authorities"
       else
         let cas = List.fold_left (fun cas buf ->
@@ -683,7 +682,7 @@ let parse_certificate_request_extension raw =
   (Some data, shift raw (4 + len))
 
 let parse_certificate_request_1_3_exn buf =
-  let contextlen = get_uint8 buf 0 in
+  let contextlen = String.get_uint8 buf 0 in
   let context, rt =
     if contextlen = 0 then
       None, shift buf 1
@@ -698,27 +697,27 @@ let parse_certificate_request_1_3 =
   catch parse_certificate_request_1_3_exn
 
 let parse_dh_parameters = catch @@ fun raw ->
-  let plength = BE.get_uint16 raw 0 in
+  let plength = String.get_uint16_be raw 0 in
   let dh_p = sub raw 2 plength in
   let buf = shift raw (2 + plength) in
-  let glength = BE.get_uint16 buf 0 in
+  let glength = String.get_uint16_be buf 0 in
   let dh_g = sub buf 2 glength in
   let buf = shift buf (2 + glength) in
-  let yslength = BE.get_uint16 buf 0 in
+  let yslength = String.get_uint16_be buf 0 in
   let dh_Ys = sub buf 2 yslength in
   let buf = shift buf (2 + yslength) in
   let rawparams = sub raw 0 (plength + glength + yslength + 6) in
   ({ dh_p ; dh_g ; dh_Ys }, rawparams, buf)
 
 let parse_ec_parameters = catch @@ fun raw ->
-  if get_uint8 raw 0 <> ec_curve_type_to_int NAMED_CURVE then
+  if String.get_uint8 raw 0 <> ec_curve_type_to_int NAMED_CURVE then
     raise_unknown "EC curve type"
   else
-    match int_to_named_group (BE.get_uint16 raw 1) with
+    match int_to_named_group (String.get_uint16_be raw 1) with
     | Some g ->
       begin match named_group_to_group g with
         | Some ((`X25519 | `P256 | `P384 | `P521) as g) ->
-          let data_len = get_uint8 raw 3 in
+          let data_len = String.get_uint8 raw 3 in
           let d, rest = split (shift raw 4) data_len in
           g, d, sub raw 0 (data_len + 4), rest
         | _ -> raise_unknown "EC group"
@@ -726,8 +725,8 @@ let parse_ec_parameters = catch @@ fun raw ->
     | None -> raise_unknown "EC named group"
 
 let parse_digitally_signed_exn buf =
-  let siglen = BE.get_uint16 buf 0 in
-  if length buf <> siglen + 2 then
+  let siglen = String.get_uint16_be buf 0 in
+  if String.length buf <> siglen + 2 then
     raise_trailing_bytes "digitally signed"
   else
     sub buf 2 siglen
@@ -746,29 +745,29 @@ let parse_session_ticket_extension raw =
   let etype, len, buf = parse_ext raw in
   let data = match int_to_extension_type etype with
     | Some EARLY_DATA ->
-      if length buf <> 4 then
+      if String.length buf <> 4 then
         raise_unknown "bad early_data extension in session ticket"
       else
-        let size = BE.get_uint32 buf 0 in
+        let size = String.get_int32_be buf 0 in
         `EarlyDataIndication size
     | _ -> `UnknownExtension (etype, buf)
   in
   (Some data, shift raw (4 + len))
 
 let parse_session_ticket buf =
-  let lifetime = BE.get_uint32 buf 0
-  and age_add = BE.get_uint32 buf 4
-  and nonce_len = get_uint8 buf 8
+  let lifetime = String.get_int32_be buf 0
+  and age_add = String.get_int32_be buf 4
+  and nonce_len = String.get_uint8 buf 8
   in
   let nonce = sub buf 9 nonce_len in
-  let ticket_len = BE.get_uint16 buf (9 + nonce_len) in
+  let ticket_len = String.get_uint16_be buf (9 + nonce_len) in
   let ticket, exts_buf = split (shift buf (11 + nonce_len)) ticket_len in
   let extensions = parse_extensions parse_session_ticket_extension exts_buf in
   { lifetime ; age_add ; nonce ; ticket ; extensions }
 
 let parse_client_dh_key_exchange_exn buf =
-  let len = BE.get_uint16 buf 0 in
-  if length buf <> len + 2 then
+  let len = String.get_uint16_be buf 0 in
+  if String.length buf <> len + 2 then
     raise_trailing_bytes "client key exchange"
   else
     sub buf 2 len
@@ -776,8 +775,8 @@ let parse_client_dh_key_exchange_exn buf =
 let parse_client_dh_key_exchange = catch parse_client_dh_key_exchange_exn
 
 let parse_client_ec_key_exchange_exn buf =
-  let len = get_uint8 buf 0 in
-  if length buf <> len + 1 then
+  let len = String.get_uint8 buf 0 in
+  if String.length buf <> len + 1 then
     raise_trailing_bytes "client key exchange"
   else
     sub buf 1 len
@@ -785,43 +784,43 @@ let parse_client_ec_key_exchange_exn buf =
 let parse_client_ec_key_exchange = catch parse_client_ec_key_exchange_exn
 
 let parse_keyupdate buf =
-  if length buf <> 1 then
+  if String.length buf <> 1 then
     raise_trailing_bytes "key update"
   else
-    match int_to_key_update_request_type (get_uint8 buf 0) with
+    match int_to_key_update_request_type (String.get_uint8 buf 0) with
     | Some y -> y
     | None -> raise_unknown "key update content"
 
 let parse_handshake_frame buf =
-  if length buf < 4 then
+  if String.length buf < 4 then
     (None, buf)
   else
     let l = get_uint24_len (shift buf 1) in
     let hslen = l + 4 in
-    if length buf >= hslen then
+    if String.length buf >= hslen then
       let hs, rest = split buf hslen in
       (Some hs, rest)
     else
       (None, buf)
 
 let parse_handshake = catch @@ fun buf ->
-  let typ = get_uint8 buf 0 in
+  let typ = String.get_uint8 buf 0 in
   let handshake_type = int_to_handshake_type typ in
   let len = get_uint24_len (shift buf 1) in
-  if length buf <> len + 4 then
+  if String.length buf <> len + 4 then
     raise_trailing_bytes "handshake"
   else
     let payload = sub buf 4 len in
     match handshake_type with
     | Some HELLO_REQUEST ->
-      if length payload = 0 then HelloRequest else raise_trailing_bytes "hello request"
+      if String.length payload = 0 then HelloRequest else raise_trailing_bytes "hello request"
     | Some CLIENT_HELLO -> parse_client_hello payload
     | Some SERVER_HELLO -> parse_server_hello payload
     | Some CERTIFICATE -> Certificate payload
     | Some CERTIFICATE_VERIFY -> CertificateVerify payload
     | Some SERVER_KEY_EXCHANGE -> ServerKeyExchange payload
     | Some SERVER_HELLO_DONE ->
-      if length payload = 0 then ServerHelloDone else raise_trailing_bytes "server hello done"
+      if String.length payload = 0 then ServerHelloDone else raise_trailing_bytes "server hello done"
     | Some CERTIFICATE_REQUEST -> CertificateRequest payload
     | Some CLIENT_KEY_EXCHANGE -> ClientKeyExchange payload
     | Some FINISHED -> Finished payload
diff --git a/lib/reader.mli b/lib/reader.mli
index 59c3d5dc..1782aba6 100644
--- a/lib/reader.mli
+++ b/lib/reader.mli
@@ -10,31 +10,31 @@ type error =
 
 val pp_error : error Fmt.t
 
-val parse_version     : Cstruct.t -> (Core.tls_version, error) result
-val parse_any_version : Cstruct.t -> (Core.tls_any_version, error) result
-val parse_record      : Cstruct.t ->
-  ([ `Record of (Core.tls_hdr * Cstruct.t) * Cstruct.t
-   | `Fragment of Cstruct.t
+val parse_version     : string -> (Core.tls_version, error) result
+val parse_any_version : string -> (Core.tls_any_version, error) result
+val parse_record      : string ->
+  ([ `Record of (Core.tls_hdr * string) * string
+   | `Fragment of string
    ], error) result
 
-val parse_handshake_frame : Cstruct.t -> (Cstruct.t option * Cstruct.t)
-val parse_handshake : Cstruct.t -> (Core.tls_handshake, error) result
+val parse_handshake_frame : string -> (string option * string)
+val parse_handshake : string -> (Core.tls_handshake, error) result
 
-val parse_alert     : Cstruct.t -> (Core.tls_alert, error) result
+val parse_alert     : string -> (Core.tls_alert, error) result
 
-val parse_change_cipher_spec   : Cstruct.t -> (unit, error) result
+val parse_change_cipher_spec   : string -> (unit, error) result
 
-val parse_certificate_request     : Cstruct.t -> (Packet.client_certificate_type list * Cstruct.t list, error) result
-val parse_certificate_request_1_2 : Cstruct.t -> (Packet.client_certificate_type list * Core.signature_algorithm list * Cstruct.t list, error) result
-val parse_certificate_request_1_3 : Cstruct.t -> (Cstruct.t option * Core.certificate_request_extension list, error) result
+val parse_certificate_request     : string -> (Packet.client_certificate_type list * string list, error) result
+val parse_certificate_request_1_2 : string -> (Packet.client_certificate_type list * Core.signature_algorithm list * string list, error) result
+val parse_certificate_request_1_3 : string -> (string option * Core.certificate_request_extension list, error) result
 
-val parse_certificates : Cstruct.t -> (Cstruct.t list, error) result
-val parse_certificates_1_3 : Cstruct.t -> (Cstruct.t * (Cstruct.t * 'a list) list, error) result
+val parse_certificates : string -> (string list, error) result
+val parse_certificates_1_3 : string -> (string * (string * 'a list) list, error) result
 
-val parse_client_dh_key_exchange : Cstruct.t -> (Cstruct.t, error) result
-val parse_client_ec_key_exchange : Cstruct.t -> (Cstruct.t, error) result
+val parse_client_dh_key_exchange : string -> (string, error) result
+val parse_client_ec_key_exchange : string -> (string, error) result
 
-val parse_dh_parameters        : Cstruct.t -> (Core.dh_parameters * Cstruct.t * Cstruct.t, error) result
-val parse_ec_parameters        : Cstruct.t -> ([ `X25519 | `P256 | `P384 | `P521 ] * Cstruct.t * Cstruct.t * Cstruct.t, error) result
-val parse_digitally_signed     : Cstruct.t -> (Cstruct.t, error) result
-val parse_digitally_signed_1_2 : Cstruct.t -> (Core.signature_algorithm * Cstruct.t, error) result
+val parse_dh_parameters        : string -> (Core.dh_parameters * string * string, error) result
+val parse_ec_parameters        : string -> ([ `X25519 | `P256 | `P384 | `P521 ] * string * string * string, error) result
+val parse_digitally_signed     : string -> (string, error) result
+val parse_digitally_signed_1_2 : string -> (Core.signature_algorithm * string, error) result
diff --git a/lib/state.ml b/lib/state.ml
index a74e8c93..93e9c1d6 100644
--- a/lib/state.ml
+++ b/lib/state.ml
@@ -4,11 +4,11 @@
 open Core
 open Mirage_crypto
 
-type hmac_key = Cstruct.t
+type hmac_key = string
 
 (* initialisation vector style, depending on TLS version *)
 type iv_mode =
-  | Iv of Cstruct.t  (* traditional CBC (reusing last cipherblock) *)
+  | Iv of string  (* traditional CBC (reusing last cipherblock) *)
   | Random_iv        (* TLS 1.1 and higher explicit IV (we use random) *)
 
 type 'k cbc_cipher    = (module Cipher_block.S.CBC with type key = 'k)
@@ -16,11 +16,11 @@ type 'k cbc_state = {
   cipher         : 'k cbc_cipher ;
   cipher_secret  : 'k ;
   iv_mode        : iv_mode ;
-  hmac           : Hash.hash ;
+  hmac           : Digestif.hash' ;
   hmac_secret    : hmac_key
 }
 
-type nonce = Cstruct.t
+type nonce = string
 
 type 'k aead_cipher = (module AEAD with type key = 'k)
 type 'k aead_state = {
@@ -42,7 +42,7 @@ type crypto_context = {
   cipher_st : cipher_st ; (* cipher state *)
 }
 (* the raw handshake log we need to carry around *)
-type hs_log = Cstruct.t list
+type hs_log = string list
 
 type dh_secret = [
   | `Finite_field of Mirage_crypto_pk.Dh.secret
@@ -53,11 +53,11 @@ type dh_secret = [
 ]
 
 (* a collection of client and server verify bytes for renegotiation *)
-type reneg_params = Cstruct.t * Cstruct.t
+type reneg_params = string * string
 
 type common_session_data = {
-  server_random          : Cstruct.t ; (* 32 bytes random from the server hello *)
-  client_random          : Cstruct.t ; (* 32 bytes random from the client hello *)
+  server_random          : string ; (* 32 bytes random from the server hello *)
+  client_random          : string ; (* 32 bytes random from the client hello *)
   peer_certificate_chain : X509.Certificate.t list ;
   peer_certificate       : X509.Certificate.t option ;
   trust_anchor           : X509.Certificate.t option ;
@@ -76,7 +76,7 @@ type session_data = {
   ciphersuite            : Ciphersuite.ciphersuite ;
   group                  : group option ;
   renegotiation          : reneg_params ; (* renegotiation data *)
-  session_id             : Cstruct.t ;
+  session_id             : string ;
   extended_ms            : bool ;
   tls_unique             : Cstruct.t ;
 }
@@ -91,9 +91,9 @@ type server_handshake_state =
   | AwaitClientKeyExchange_DHE of session_data * dh_secret * hs_log (* server hello done is sent, and DHE_RSA key exchange used, waiting for client key exchange *)
   | AwaitClientCertificateVerify of session_data * crypto_context * crypto_context * hs_log
   | AwaitClientChangeCipherSpec of session_data * crypto_context * crypto_context * hs_log (* client key exchange received, next should be change cipher spec *)
-  | AwaitClientChangeCipherSpecResume of session_data * crypto_context * Cstruct.t * hs_log (* resumption: next should be change cipher spec *)
+  | AwaitClientChangeCipherSpecResume of session_data * crypto_context * string * hs_log (* resumption: next should be change cipher spec *)
   | AwaitClientFinished of session_data * hs_log (* change cipher spec received, next should be the finished including a hmac over all handshake packets *)
-  | AwaitClientFinishedResume of session_data * Cstruct.t * hs_log (* change cipher spec received, next should be the finished including a hmac over all handshake packets *)
+  | AwaitClientFinishedResume of session_data * string * hs_log (* change cipher spec received, next should be the finished including a hmac over all handshake packets *)
   | Established (* handshake successfully completed *)
 
 (* state machine of the client *)
@@ -104,18 +104,18 @@ type client_handshake_state =
   | AwaitCertificate_RSA of session_data * hs_log (* certificate expected with RSA key exchange *)
   | AwaitCertificate_DHE of session_data * hs_log (* certificate expected with DHE key exchange *)
   | AwaitServerKeyExchange_DHE of session_data * hs_log (* server key exchange expected with DHE *)
-  | AwaitCertificateRequestOrServerHelloDone of session_data * Cstruct.t * Cstruct.t * hs_log (* server hello done expected, client key exchange and premastersecret are ready *)
-  | AwaitServerHelloDone of session_data * signature_algorithm list option * Cstruct.t * Cstruct.t * hs_log (* server hello done expected, client key exchange and premastersecret are ready *)
-  | AwaitServerChangeCipherSpec of session_data * crypto_context * Cstruct.t * hs_log (* change cipher spec expected *)
+  | AwaitCertificateRequestOrServerHelloDone of session_data * string * string * hs_log (* server hello done expected, client key exchange and premastersecret are ready *)
+  | AwaitServerHelloDone of session_data * signature_algorithm list option * string * string * hs_log (* server hello done expected, client key exchange and premastersecret are ready *)
+  | AwaitServerChangeCipherSpec of session_data * crypto_context * string * hs_log (* change cipher spec expected *)
   | AwaitServerChangeCipherSpecResume of session_data * crypto_context * crypto_context * hs_log (* change cipher spec expected *)
-  | AwaitServerFinished of session_data * Cstruct.t * hs_log (* finished expected with a hmac over all handshake packets *)
+  | AwaitServerFinished of session_data * string * hs_log (* finished expected with a hmac over all handshake packets *)
   | AwaitServerFinishedResume of session_data * hs_log (* finished expected with a hmac over all handshake packets *)
   | Established (* handshake successfully completed *)
 
 type kdf = {
-  secret : Cstruct.t ;
+  secret : string ;
   cipher : Ciphersuite.ciphersuite13 ;
-  hash : Mirage_crypto.Hash.hash ;
+  hash : Digestif.hash' ;
 }
 
 (* TODO needs log of CH..CF for post-handshake auth *)
@@ -124,29 +124,29 @@ type session_data13 = {
   common_session_data13  : common_session_data ;
   ciphersuite13          : Ciphersuite.ciphersuite13 ;
   master_secret          : kdf ;
-  exporter_master_secret : Cstruct.t ;
-  resumption_secret      : Cstruct.t ;
+  exporter_master_secret : string ;
+  resumption_secret      : string ;
   state                  : epoch_state ;
   resumed                : bool ;
-  client_app_secret      : Cstruct.t ;
-  server_app_secret      : Cstruct.t ;
+  client_app_secret      : string ;
+  server_app_secret      : string ;
 }
 
 type client13_handshake_state =
-  | AwaitServerHello13 of client_hello * (group * dh_secret) list * Cstruct.t (* this is for CH1 ~> HRR ~> CH2 <~ WAIT SH *)
-  | AwaitServerEncryptedExtensions13 of session_data13 * Cstruct.t * Cstruct.t * Cstruct.t
-  | AwaitServerCertificateRequestOrCertificate13 of session_data13 * Cstruct.t * Cstruct.t * Cstruct.t
-  | AwaitServerCertificate13 of session_data13 * Cstruct.t * Cstruct.t * signature_algorithm list option * Cstruct.t
-  | AwaitServerCertificateVerify13 of session_data13 * Cstruct.t * Cstruct.t * signature_algorithm list option * Cstruct.t
-  | AwaitServerFinished13 of session_data13 * Cstruct.t * Cstruct.t * signature_algorithm list option * Cstruct.t
+  | AwaitServerHello13 of client_hello * (group * dh_secret) list * string (* this is for CH1 ~> HRR ~> CH2 <~ WAIT SH *)
+  | AwaitServerEncryptedExtensions13 of session_data13 * string * string * string
+  | AwaitServerCertificateRequestOrCertificate13 of session_data13 * string * string * string
+  | AwaitServerCertificate13 of session_data13 * string * string * signature_algorithm list option * string
+  | AwaitServerCertificateVerify13 of session_data13 * string * string * signature_algorithm list option * string
+  | AwaitServerFinished13 of session_data13 * string * string * signature_algorithm list option * string
   | Established13
 
 type server13_handshake_state =
   | AwaitClientHelloHRR13 (* if we sent out HRR (also to-be-used for tls13-only) *)
-  | AwaitClientCertificate13 of session_data13 * Cstruct.t * crypto_context * session_ticket option * Cstruct.t
-  | AwaitClientCertificateVerify13 of session_data13 * Cstruct.t * crypto_context * session_ticket option * Cstruct.t
-  | AwaitClientFinished13 of Cstruct.t * crypto_context * session_ticket option * Cstruct.t
-  | AwaitEndOfEarlyData13 of Cstruct.t * crypto_context * crypto_context * session_ticket option * Cstruct.t
+  | AwaitClientCertificate13 of session_data13 * string * crypto_context * session_ticket option * string
+  | AwaitClientCertificateVerify13 of session_data13 * string * crypto_context * session_ticket option * string
+  | AwaitClientFinished13 of string * crypto_context * session_ticket option * string
+  | AwaitEndOfEarlyData13 of string * crypto_context * crypto_context * session_ticket option * string
   | Established13
 
 type handshake_machina_state =
@@ -162,14 +162,14 @@ type handshake_state = {
   early_data_left  : int32 ;
   machina          : handshake_machina_state ; (* state machine state *)
   config           : Config.config ; (* given config *)
-  hs_fragment      : Cstruct.t ; (* handshake messages can be fragmented, leftover from before *)
+  hs_fragment      : string ; (* handshake messages can be fragmented, leftover from before *)
 }
 
 (* connection state: initially None, after handshake a crypto context *)
 type crypto_state = crypto_context option
 
 (* record consisting of a content type and a byte vector *)
-type record = Packet.content_type * Cstruct.t
+type record = Packet.content_type * string
 
 (* response returned by a handler *)
 type rec_resp = [
@@ -186,7 +186,7 @@ type state = {
   handshake : handshake_state ; (* the current handshake state *)
   decryptor : crypto_state ; (* the current decryption state *)
   encryptor : crypto_state ; (* the current encryption state *)
-  fragment  : Cstruct.t ; (* the leftover fragment from TCP fragmentation *)
+  fragment  : string ; (* the leftover fragment from TCP fragmentation *)
   read_closed : bool ;
   write_closed : bool ;
 }
@@ -228,8 +228,8 @@ type client_hello_errors = [
   | `NoKeyShareExtension
   | `NoSupportedGroupExtension
   | `NotSetSupportedGroup of Packet.named_group list
-  | `NotSetKeyShare of (Packet.named_group * Cstruct.t) list
-  | `NotSubsetKeyShareSupportedGroup of Packet.named_group list * (Packet.named_group * Cstruct.t) list
+  | `NotSetKeyShare of (Packet.named_group * string) list
+  | `NotSubsetKeyShareSupportedGroup of Packet.named_group list * (Packet.named_group * string) list
   | `Has0rttAfterHRR
   | `NoCookie
 ]
@@ -400,9 +400,9 @@ let common_data_to_epoch common is_server peer_name =
       own_name               = common.own_name ;
       received_certificates  = common.received_certificates ;
       master_secret          = common.master_secret ;
-      exporter_master_secret = Cstruct.empty ;
+      exporter_master_secret = "" ;
       alpn_protocol          = common.alpn_protocol ;
-      session_id             = Cstruct.empty ;
+      session_id             = "" ;
       extended_ms            = false ;
       tls_unique             = None ;
     } in
diff --git a/lib/writer.ml b/lib/writer.ml
index c027f290..713bc7a2 100644
--- a/lib/writer.ml
+++ b/lib/writer.ml
@@ -1,8 +1,5 @@
 open Packet
 open Core
-open Cstruct
-
-let (<+>) = Cstruct.append
 
 let assemble_protocol_version_int buf version =
   let major, minor = pair_of_tls_version version in
diff --git a/lib/writer.mli b/lib/writer.mli
index b888068c..c89a15d5 100644
--- a/lib/writer.mli
+++ b/lib/writer.mli
@@ -1,34 +1,34 @@
 
-val assemble_protocol_version : Core.tls_version -> Cstruct.t
+val assemble_protocol_version : Core.tls_version -> string
 
-val assemble_handshake : Core.tls_handshake -> Cstruct.t
+val assemble_handshake : Core.tls_handshake -> string
 
-val assemble_message_hash : int -> Cstruct.t
+val assemble_message_hash : int -> string
 
-val assemble_hdr : Core.tls_version -> (Packet.content_type * Cstruct.t) -> Cstruct.t
+val assemble_hdr : Core.tls_version -> (Packet.content_type * string) -> string
 
-val assemble_alert : ?level:Packet.alert_level -> Packet.alert_type -> Cstruct.t
+val assemble_alert : ?level:Packet.alert_level -> Packet.alert_type -> string
 
-val assemble_change_cipher_spec : Cstruct.t
+val assemble_change_cipher_spec : string
 
-val assemble_dh_parameters : Core.dh_parameters -> Cstruct.t
+val assemble_dh_parameters : Core.dh_parameters -> string
 
-val assemble_ec_parameters : Core.group -> Cstruct.t -> Cstruct.t
+val assemble_ec_parameters : Core.group -> string -> string
 
-val assemble_client_dh_key_exchange : Cstruct.t -> Cstruct.t
+val assemble_client_dh_key_exchange : string -> string
 
-val assemble_client_ec_key_exchange : Cstruct.t -> Cstruct.t
+val assemble_client_ec_key_exchange : string -> string
 
-val assemble_digitally_signed : Cstruct.t -> Cstruct.t
+val assemble_digitally_signed : string -> string
 
-val assemble_digitally_signed_1_2 : Core.signature_algorithm -> Cstruct.t -> Cstruct.t
+val assemble_digitally_signed_1_2 : Core.signature_algorithm -> string -> string
 
-val assemble_certificate_request : Packet.client_certificate_type list -> Cstruct.t list -> Cstruct.t
+val assemble_certificate_request : Packet.client_certificate_type list -> string list -> string
 
-val assemble_certificate_request_1_2 : Packet.client_certificate_type list -> Core.signature_algorithm list -> Cstruct.t list -> Cstruct.t
+val assemble_certificate_request_1_2 : Packet.client_certificate_type list -> Core.signature_algorithm list -> string list -> string
 
-val assemble_certificate_request_1_3 : ?context:Cstruct.t -> Core.certificate_request_extension list -> Cstruct.t
+val assemble_certificate_request_1_3 : ?context:string -> Core.certificate_request_extension list -> string
 
-val assemble_certificates : Cstruct.t list -> Cstruct.t
+val assemble_certificates : string list -> string
 
-val assemble_certificates_1_3 : Cstruct.t -> Cstruct.t list -> Cstruct.t
+val assemble_certificates_1_3 : string -> string list -> string
diff --git a/tls.opam b/tls.opam
index d50fb888..a65ae5b7 100644
--- a/tls.opam
+++ b/tls.opam
@@ -17,19 +17,19 @@ build: [
 depends: [
   "ocaml" {>= "4.08.0"}
   "dune" {>= "3.0"}
-  "cstruct" {>= "6.0.0"}
-  "mirage-crypto" {>= "0.11.0"}
-  "mirage-crypto-ec" {>= "0.10.0"}
+  "mirage-crypto" {>= "1.0.0"}
+  "mirage-crypto-ec" {>= "1.0.0"}
   "mirage-crypto-pk"
-  "mirage-crypto-rng" {>= "0.8.0"}
-  "x509" {>= "0.15.0"}
+  "mirage-crypto-rng" {>= "1.0.0"}
+  "x509" {>= "1.0.0"}
   "domain-name" {>= "0.3.0"}
   "fmt" {>= "0.8.7"}
-  "cstruct-unix" {with-test & >= "3.0.0"}
   "ounit2" {with-test & >= "2.2.0"}
   "hkdf"
   "logs"
   "ipaddr"
+  "ohex" {>= "0.2.0"}
+  "digestif"
   "alcotest" {with-test}
 ]
 conflicts: [ "result" {< "1.5"} ]

From 8b4ae813518b3d328a875a7cbad2d4aac6d242e4 Mon Sep 17 00:00:00 2001
From: Hannes Mehnert <hannes@mehnert.org>
Date: Thu, 4 Apr 2024 00:21:33 +0200
Subject: [PATCH 2/9] more wip

---
 lib/core.ml             |   4 +
 lib/engine.ml           |   8 +-
 lib/handshake_client.ml |  43 ++++----
 lib/handshake_crypto.ml |  47 ++++----
 lib/handshake_server.ml |  48 +++++----
 lib/packet.ml           |  10 +-
 lib/reader.ml           | 234 ++++++++++++++++++++--------------------
 lwt/tls_lwt.ml          |  53 +++++----
 lwt/tls_lwt.mli         |   6 +-
 lwt/x509_lwt.ml         |   4 +-
 lwt/x509_lwt.mli        |  10 +-
 11 files changed, 244 insertions(+), 223 deletions(-)

diff --git a/lib/core.ml b/lib/core.ml
index 58d49530..ca7a951f 100644
--- a/lib/core.ml
+++ b/lib/core.ml
@@ -7,6 +7,10 @@ let ( let* ) = Result.bind
 
 let guard p e = if p then Ok () else Error e
 
+let split_str ?(start = 0) str off =
+  String.sub str start (start + off),
+  String.sub str (start + off) (String.length str - off - start)
+
 let map_reader_error r = Result.map_error (fun re -> `Fatal (`ReaderError re)) r
 
 type tls13 = [ `TLS_1_3 ]
diff --git a/lib/engine.ml b/lib/engine.ml
index 7a519697..997263c2 100644
--- a/lib/engine.ml
+++ b/lib/engine.ml
@@ -192,7 +192,7 @@ let verify_mac sequence mac mac_k ty ver decrypted =
     String.length decrypted - H.digest_size
   in
   let* () = guard (macstart >= 0) (`Fatal `MACUnderflow) in
-  let (body, mmac) = Cstruct.split decrypted macstart in
+  let (body, mmac) = split_str decrypted macstart in
   let cmac =
     let ver = pair_of_tls_version ver in
     let hdr = Crypto.pseudo_header sequence ty ver (String.length body) in
@@ -238,7 +238,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
             if String.length buf < Crypto.cbc_block c.cipher then
               Error (`Fatal `MACUnderflow)
             else
-              let iv, buf = Cstruct.split buf (Crypto.cbc_block c.cipher) in
+              let iv, buf = split_str buf (Crypto.cbc_block c.cipher) in
               let* msg, _ = dec iv buf in
               Ok (CBC c, msg) )
 
@@ -248,7 +248,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
         if String.length buf < explicit_nonce_len then
           Error (`Fatal `MACUnderflow)
         else
-          let explicit_nonce, buf = Cstruct.split buf explicit_nonce_len in
+          let explicit_nonce, buf = split_str buf explicit_nonce_len in
           let adata =
             let ver = pair_of_tls_version version in
             Crypto.pseudo_header seq ty ver (String.length buf - Crypto.tag_len c.cipher)
@@ -341,7 +341,7 @@ let encrypt_records encryptor version records =
   let rec split = function
     | [] -> []
     | (t1, a) :: xs when String.length a >= 1 lsl 14 ->
-      let fst, snd = Cstruct.split a (1 lsl 14) in
+      let fst, snd = split_str a (1 lsl 14) in
       (t1, fst) :: split ((t1, snd) :: xs)
     | x::xs -> x :: split xs
 
diff --git a/lib/handshake_client.ml b/lib/handshake_client.ml
index f3203b86..c7185cf3 100644
--- a/lib/handshake_client.ml
+++ b/lib/handshake_client.ml
@@ -57,8 +57,8 @@ let default_client_hello config =
   in
   let sessionid =
     match config.use_reneg, config.cached_session with
-    | _, Some { session_id ; extended_ms ; _ } when extended_ms && not (Cstruct.length session_id = 0) -> Some session_id
-    | false, Some { session_id ; _ } when not (Cstruct.length session_id = 0) -> Some session_id
+    | _, Some { session_id ; extended_ms ; _ } when extended_ms && not (String.length session_id = 0) -> Some session_id
+    | false, Some { session_id ; _ } when not (String.length session_id = 0) -> Some session_id
     | _ -> None
   in
   let ch = {
@@ -74,9 +74,9 @@ let default_client_hello config =
 let common_server_hello_validation config reneg (sh : server_hello) (ch : client_hello) =
   let validate_reneg data =
     match reneg, data with
-    | Some (cvd, svd), Some x -> guard (Cstruct.equal (cvd <+> svd) x) (`Fatal `InvalidRenegotiation)
+    | Some (cvd, svd), Some x -> guard (String.equal (cvd ^ svd) x) (`Fatal `InvalidRenegotiation)
     | Some _, None -> Error (`Fatal `NoSecureRenegotiation)
-    | None, Some x -> guard (Cstruct.length x = 0) (`Fatal `InvalidRenegotiation)
+    | None, Some x -> guard (String.length x = 0) (`Fatal `InvalidRenegotiation)
     | None, None -> Ok ()
   in
   let* () =
@@ -98,7 +98,7 @@ let common_server_hello_validation config reneg (sh : server_hello) (ch : client
 
 let common_server_hello_machina state (sh : server_hello) (ch : client_hello) raw log =
   let cipher = sh.ciphersuite in
-  let session_id = match sh.sessionid with None -> Cstruct.create 0 | Some x -> x in
+  let session_id = match sh.sessionid with None -> "" | Some x -> x in
   let extended_ms =
     List.mem `ExtendedMasterSecret ch.extensions &&
     List.mem `ExtendedMasterSecret sh.extensions
@@ -141,9 +141,9 @@ let answer_server_hello state (ch : client_hello) sh secrets raw log =
 
   let* () =
     if max_protocol_version state.config.protocol_versions = `TLS_1_3 then
-      let piece = Cstruct.sub sh.server_random 24 8 in
-      let* () = guard (not (Cstruct.equal Packet.downgrade12 piece)) (`Fatal `Downgrade12) in
-      guard (not (Cstruct.equal Packet.downgrade11 piece)) (`Fatal `Downgrade11)
+      let piece = String.sub sh.server_random 24 8 in
+      let* () = guard (not (String.equal Packet.downgrade12 piece)) (`Fatal `Downgrade12) in
+      guard (not (String.equal Packet.downgrade11 piece)) (`Fatal `Downgrade11)
     else
       Ok ()
   in
@@ -162,7 +162,7 @@ let answer_server_hello state (ch : client_hello) sh secrets raw log =
   let state = { state with protocol_version = sh.server_version } in
   match sh.server_version with
   | #tls13 ->
-    Handshake_client13.answer_server_hello state ch sh secrets raw (Cstruct.concat log)
+    Handshake_client13.answer_server_hello state ch sh secrets raw (String.concat "" log)
   | #tls_before_13 as v ->
     match state.config.cached_session with
     | Some epoch when epoch_matches epoch ->
@@ -225,7 +225,7 @@ let answer_certificate_RSA state (session : session_data) cs raw log =
     | x -> Error (`Fatal (`NoVersions [ x ])) (* TODO: get rid of this... *)
   in
   let ver = Writer.assemble_protocol_version version in
-  let premaster = ver <+> Mirage_crypto_rng.generate 46 in
+  let premaster = ver ^ Mirage_crypto_rng.generate 46 in
   let* k = peer_key peer_certificate in
   match k with
   | `RSA key ->
@@ -276,8 +276,11 @@ let answer_server_key_exchange_DHE state (session : session_data) kex raw log =
   in
 
   let sigdata =
-    session.common_session_data.client_random <+>
-    session.common_session_data.server_random <+> raw_dh_params
+    String.concat "" [
+      session.common_session_data.client_random ;
+      session.common_session_data.server_random ;
+      raw_dh_params
+    ]
   in
   let* () =
     verify_digitally_signed state.protocol_version
@@ -366,7 +369,7 @@ let answer_server_hello_done state (session : session_data) sigalgs kex premaste
        let cert = Certificate (Writer.assemble_certificates cs) in
        let ccert = Writer.assemble_handshake cert in
        let to_sign = log @ [ raw ; ccert ; ckex ] in
-       let data = Cstruct.concat to_sign in
+       let data = String.concat "" to_sign in
        let ver = state.protocol_version
        and my_sigalgs = state.config.signature_algorithms in
        let* signature = signature ver data sigalgs my_sigalgs p in
@@ -424,9 +427,9 @@ let answer_server_finished state (session : session_data) client_verify fin log
   let computed =
     Handshake_crypto.finished (state_version state) session.ciphersuite session.common_session_data.master_secret "server finished" log
   in
-  let* () = guard (Cstruct.equal computed fin) (`Fatal `BadFinished) in
+  let* () = guard (String.equal computed fin) (`Fatal `BadFinished) in
   let* () =
-    guard (Cstruct.length state.hs_fragment = 0)
+    guard (String.length state.hs_fragment = 0)
       (`Fatal `HandshakeFragmentsNotEmpty)
   in
   let machina = Established
@@ -438,10 +441,10 @@ let answer_server_finished_resume state (session : session_data) fin raw log =
     let checksum = Handshake_crypto.finished (state_version state) session.ciphersuite session.common_session_data.master_secret in
     (checksum "client finished" (log @ [raw]), checksum "server finished" log)
   in
-  let* () = guard (Cstruct.equal server fin) (`Fatal `BadFinished) in
+  let* () = guard (String.equal server fin) (`Fatal `BadFinished) in
   let session = { session with tls_unique = server } in
   let* () =
-    guard (Cstruct.length state.hs_fragment = 0)
+    guard (String.length state.hs_fragment = 0)
       (`Fatal `HandshakeFragmentsNotEmpty)
   in
   let machina = Established
@@ -478,7 +481,7 @@ let handle_change_cipher_spec cs state packet =
   match cs with
   | AwaitServerChangeCipherSpec (session, server_ctx, client_verify, log) ->
     let* () =
-      guard (Cstruct.length state.hs_fragment = 0)
+      guard (String.length state.hs_fragment = 0)
         (`Fatal `HandshakeFragmentsNotEmpty)
     in
     let machina = AwaitServerFinished (session, client_verify, log) in
@@ -486,7 +489,7 @@ let handle_change_cipher_spec cs state packet =
     Ok ({ state with machina = Client machina }, [`Change_dec server_ctx])
   | AwaitServerChangeCipherSpecResume (session, client_ctx, server_ctx, log) ->
     let* () =
-      guard (Cstruct.length state.hs_fragment = 0)
+      guard (String.length state.hs_fragment = 0)
         (`Fatal `HandshakeFragmentsNotEmpty)
     in
     let ccs = change_cipher_spec in
@@ -505,7 +508,7 @@ let handle_handshake cs hs buf =
   | AwaitServerHello (ch, secrets, log), ServerHello sh ->
     answer_server_hello hs ch sh secrets buf log
   | AwaitServerHello (ch, secrets, log), HelloRetryRequest hrr ->
-    Handshake_client13.answer_hello_retry_request hs ch hrr secrets buf (Cstruct.concat log)
+    Handshake_client13.answer_hello_retry_request hs ch hrr secrets buf (String.concat "" log)
   | AwaitServerHelloRenegotiate (session, ch, log), ServerHello sh ->
     answer_server_hello_renegotiate hs session ch sh buf log
   | AwaitCertificate_RSA (session, log), Certificate cs ->
diff --git a/lib/handshake_crypto.ml b/lib/handshake_crypto.ml
index 3ba524c8..66dabf84 100644
--- a/lib/handshake_crypto.ml
+++ b/lib/handshake_crypto.ml
@@ -3,14 +3,14 @@ open State
 let halve secret =
   let size = String.length secret in
   let half = size - size / 2 in
-  Cstruct.(sub secret 0 half, sub secret (size - half) half)
+  String.(sub secret 0 half, sub secret (size - half) half)
 
 let p_hash (hmac, hmac_n) key seed len =
   let rec expand a to_go =
-    let res = hmac ~key (a <+> seed) in
+    let res = hmac ~key (a ^ seed) in
     if to_go > hmac_n then
-      res <+> expand (hmac ~key a) (to_go - hmac_n)
-    else Cstruct.sub res 0 to_go
+      res ^ expand (hmac ~key a) (to_go - hmac_n)
+    else String.sub res 0 to_go
   in
   expand (hmac ~key seed) len
 
@@ -20,43 +20,42 @@ let prf_mac = function
   | `ECDHE_RSA_WITH_AES_256_GCM_SHA384
   | `ECDHE_RSA_WITH_AES_256_CBC_SHA384
   | `ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
-  | `ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 -> (module SHA384 : S)
-  | _ -> (module SHA256 : S)
+  | `ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 -> (module Digestif.SHA384 : Digestif.S)
+  | _ -> (module Digestif.SHA256 : Digestif.S)
 
 let pseudo_random_function version cipher len secret label seed =
-  let labelled = Cstruct.of_string label <+> seed in
+  let labelled = label ^ seed in
   match version with
   | `TLS_1_1 | `TLS_1_0 ->
      let (s1, s2) = halve secret in
-     let md5 = p_hash (MD5.hmac, MD5.digest_size) s1 labelled len
-     and sha = p_hash (SHA1.hmac, SHA1.digest_size) s2 labelled len in
-     Mirage_crypto.Uncommon.Cs.xor md5 sha
+     let md5 = p_hash ((fun ~key s -> Digestif.MD5.(to_raw_string (hmac_string ~key s))), Digestif.MD5.digest_size) s1 labelled len
+     and sha = p_hash ((fun ~key s -> Digestif.SHA1.(to_raw_string (hmac_string ~key s))), Digestif.SHA1.digest_size) s2 labelled len in
+     Mirage_crypto.Uncommon.xor md5 sha
   | `TLS_1_2 ->
      let module D = (val (prf_mac cipher)) in
-     p_hash (D.hmac, D.digest_size) secret labelled len
+     p_hash ((fun ~key s -> D.(to_raw_string (hmac_string ~key s))), D.digest_size) secret labelled len
 
 let key_block version cipher len master_secret seed =
   pseudo_random_function version cipher len master_secret "key expansion" seed
 
 let hash version cipher data =
   match version with
-  | `TLS_1_0 | `TLS_1_1 -> MD5.digest data <+> SHA1.digest data
+  | `TLS_1_0 | `TLS_1_1 -> Digestif.(MD5.(to_raw_string (digest_string data)) ^ SHA1.(to_raw_string (digest_string data)))
   | `TLS_1_2 ->
-    let module H = (val (prf_mac cipher)) in
-    H.digest data
+    let module H = (val prf_mac cipher) in
+    H.(to_raw_string (digest_string data))
 
 let finished version cipher master_secret label ps =
-  let data = Cstruct.concat ps in
+  let data = String.concat "" ps in
   let seed = hash version cipher data in
   pseudo_random_function version cipher 12 master_secret label seed
 
 let divide_keyblock key mac iv buf =
-  let open Cstruct in
-  let c_mac, rt0 = split buf mac in
-  let s_mac, rt1 = split rt0 mac in
-  let c_key, rt2 = split rt1 key in
-  let s_key, rt3 = split rt2 key in
-  let c_iv , s_iv = split rt3 iv
+  let c_mac, rt0 = Core.split_str buf mac in
+  let s_mac, rt1 = Core.split_str rt0 mac in
+  let c_key, rt2 = Core.split_str rt1 key in
+  let s_key, rt3 = Core.split_str rt2 key in
+  let c_iv , s_iv = Core.split_str rt3 iv
   in
   (c_mac, s_mac, c_key, s_key, c_iv, s_iv)
 
@@ -64,12 +63,12 @@ let derive_master_secret version (session : session_data) premaster log =
   let prf = pseudo_random_function version session.ciphersuite 48 premaster in
   if session.extended_ms then
     let session_hash =
-      let data = Cstruct.concat log in
+      let data = String.concat "" log in
       hash version session.ciphersuite data
     in
     prf "extended master secret" session_hash
   else
-    prf "master secret" (session.common_session_data.client_random <+> session.common_session_data.server_random)
+    prf "master secret" (session.common_session_data.client_random ^ session.common_session_data.server_random)
 
 let initialise_crypto_ctx version (session : session_data) =
   let open Ciphersuite in
@@ -88,7 +87,7 @@ let initialise_crypto_ctx version (session : session_data) =
     in
     let key_len, iv_len, mac_len = Ciphersuite.key_length iv_l pp in
     let kblen = 2 * key_len + 2 * mac_len + 2 * iv_len
-    and rand = server_random <+> client_random
+    and rand = server_random ^ client_random
     in
     let keyblock = key_block version cipher kblen master rand in
     divide_keyblock key_len mac_len iv_len keyblock
diff --git a/lib/handshake_server.ml b/lib/handshake_server.ml
index aec95a5a..ff2ba6b5 100644
--- a/lib/handshake_server.ml
+++ b/lib/handshake_server.ml
@@ -24,13 +24,13 @@ let answer_client_finished state (session : session_data) client_fin raw log =
     in
     (checksum "client finished" log, checksum "server finished" (log @ [raw]))
   in
-  let* () = guard (Cstruct.equal client client_fin) (`Fatal `BadFinished) in
+  let* () = guard (String.equal client client_fin) (`Fatal `BadFinished) in
   let session = { session with tls_unique = client } in
   let fin = Finished server in
   let fin_raw = Writer.assemble_handshake fin in
   (* we really do not want to have any leftover handshake fragments *)
   let* () =
-    guard (Cstruct.length state.hs_fragment = 0)
+    guard (String.length state.hs_fragment = 0)
       (`Fatal `HandshakeFragmentsNotEmpty)
   in
   let session = { session with renegotiation = (client, server) }
@@ -44,10 +44,10 @@ let answer_client_finished_resume state (session : session_data) server_verify c
   let client_verify =
     Handshake_crypto.finished (state_version state) session.ciphersuite session.common_session_data.master_secret "client finished" log
   in
-  let* () = guard (Cstruct.equal client_verify client_fin) (`Fatal `BadFinished) in
+  let* () = guard (String.equal client_verify client_fin) (`Fatal `BadFinished) in
   (* we really do not want to have any leftover handshake fragments *)
   let* () =
-    guard (Cstruct.length state.hs_fragment = 0)
+    guard (String.length state.hs_fragment = 0)
       (`Fatal `HandshakeFragmentsNotEmpty)
   in
   let session = { session with renegotiation = (client_verify, server_verify) }
@@ -108,7 +108,7 @@ let answer_client_certificate_DHE state (session : session_data) dh_sent certs r
   Ok ({ state with machina = Server machina }, [])
 
 let answer_client_certificate_verify state (session : session_data) sctx cctx verify raw log =
-  let sigdata = Cstruct.concat log in
+  let sigdata = String.concat "" log in
   let* () =
     verify_digitally_signed state.protocol_version
       state.config.signature_algorithms verify sigdata
@@ -120,7 +120,7 @@ let answer_client_certificate_verify state (session : session_data) sctx cctx ve
 let answer_client_key_exchange_RSA state (session : session_data) kex raw log =
   (* due to bleichenbacher attach, we should use a random pms *)
   (* then we do not leak any decryption or padding errors! *)
-  let other = Writer.assemble_protocol_version state.protocol_version <+> Mirage_crypto_rng.generate 46 in
+  let other = Writer.assemble_protocol_version state.protocol_version ^ Mirage_crypto_rng.generate 46 in
   let validate_premastersecret k =
     (* Client implementations MUST always send the correct version number in
        PreMasterSecret.  If ClientHello.client_version is TLS 1.1 or higher,
@@ -130,7 +130,7 @@ let answer_client_key_exchange_RSA state (session : session_data) kex raw log =
        configuration option to disable the check.  Note that if the check
        fails, the PreMasterSecret SHOULD be randomized as described below *)
     (* we do not provide an option to disable the version checking (yet!) *)
-    match Cstruct.length k = 48, Reader.parse_any_version k with
+    match String.length k = 48, Reader.parse_any_version k with
     | true, Ok c_ver when c_ver = session.client_version -> k
     | _ -> other
   in
@@ -199,19 +199,19 @@ let server_hello config (client_hello : client_hello) (session : session_data) v
       match version, max_protocol_version config.protocol_versions with
       | `TLS_1_2, `TLS_1_3 -> Packet.downgrade12
       | _, `TLS_1_3 -> Packet.downgrade11
-      | _ -> Cstruct.create 0
+      | _ -> ""
     in
-    let rst = Mirage_crypto_rng.generate (32 - Cstruct.length suffix) in
-    rst <+> suffix
+    let rst = Mirage_crypto_rng.generate (32 - String.length suffix) in
+    rst ^ suffix
   and secren = match reneg with
-    | None            -> `SecureRenegotiation (Cstruct.create 0)
-    | Some (cvd, svd) -> `SecureRenegotiation (cvd <+> svd)
+    | None            -> `SecureRenegotiation ""
+    | Some (cvd, svd) -> `SecureRenegotiation (cvd ^ svd)
   and ems = if session.extended_ms then
       [`ExtendedMasterSecret]
     else
       []
   and session_id =
-    match Cstruct.length session.session_id with
+    match String.length session.session_id with
     | 0 -> Mirage_crypto_rng.generate 32
     | _ -> session.session_id
   and alpn =
@@ -273,7 +273,6 @@ let answer_client_hello_common state reneg ch raw =
         | `P256 _ -> List.mem `P256 groups
         | `P384 _ -> List.mem `P384 groups
         | `P521 _ -> List.mem `P521 groups
-        | _ -> false
       in
       fun s ->
         kt_filter s && ku_filter s && kt_matches_group s
@@ -402,10 +401,15 @@ let answer_client_hello_common state reneg ch raw =
           let params = Writer.assemble_ec_parameters `X25519 shared in
           Ok (`X25519 secret, params)
     in
-    let data = session.common_session_data.client_random <+> session.common_session_data.server_random <+> written in
+    let data = String.concat "" [
+        session.common_session_data.client_random ;
+        session.common_session_data.server_random ;
+        written
+      ]
+    in
     let* priv = private_key session in
     let* sgn = signature version data sig_algs config.signature_algorithms priv in
-    let kex = ServerKeyExchange (written <+> sgn) in
+    let kex = ServerKeyExchange (written ^ sgn) in
     let hs = Writer.assemble_handshake kex in
     Tracing.hs ~tag:"handshake-out" kex ;
     Ok (hs, secret)
@@ -450,7 +454,7 @@ let answer_client_hello_common state reneg ch raw =
   in
 
   Ok ({ state with machina = Server machina },
-      [`Record (Packet.HANDSHAKE, Cstruct.concat out_recs)])
+      [`Record (Packet.HANDSHAKE, String.concat "" out_recs)])
 
 (* TODO could benefit from result monadd *)
 let agreed_version supported (client_hello : client_hello) =
@@ -482,7 +486,7 @@ let answer_client_hello state (ch : client_hello) raw =
   let ensure_reneg ciphers their_data  =
     let reneg_cs = List.mem Packet.TLS_EMPTY_RENEGOTIATION_INFO_SCSV ciphers in
     match reneg_cs, their_data with
-    | _, Some x -> guard (Cstruct.length x = 0) (`Fatal `InvalidRenegotiation)
+    | _, Some x -> guard (String.length x = 0) (`Fatal `InvalidRenegotiation)
     | true, _ -> Ok ()
     | _ -> Error (`Fatal `NoSecureRenegotiation)
 
@@ -514,7 +518,7 @@ let answer_client_hello state (ch : client_hello) raw =
     let sh, session = server_hello state.config ch session version None in
     (* we really do not want to have any leftover handshake fragments *)
     let* () =
-      guard (Cstruct.length state.hs_fragment = 0)
+      guard (String.length state.hs_fragment = 0)
         (`Fatal `HandshakeFragmentsNotEmpty)
     in
     let client_ctx, server_ctx =
@@ -572,7 +576,7 @@ let answer_client_hello_reneg state (ch : client_hello) raw =
   (* ensure reneg allowed and supplied *)
   let ensure_reneg our_data their_data  =
     match our_data, their_data with
-    | (cvd, _), Some x -> guard (Cstruct.equal cvd x) (`Fatal `InvalidRenegotiation)
+    | (cvd, _), Some x -> guard (String.equal cvd x) (`Fatal `InvalidRenegotiation)
     | _ -> Error (`Fatal `NoSecureRenegotiation)
   in
 
@@ -609,7 +613,7 @@ let handle_change_cipher_spec ss state packet =
   match ss with
   | AwaitClientChangeCipherSpec (session, server_ctx, client_ctx, log) ->
      let* () =
-       guard (Cstruct.length state.hs_fragment = 0)
+       guard (String.length state.hs_fragment = 0)
          (`Fatal `HandshakeFragmentsNotEmpty)
      in
      let ccs = change_cipher_spec in
@@ -622,7 +626,7 @@ let handle_change_cipher_spec ss state packet =
              [`Record ccs; `Change_enc server_ctx; `Change_dec client_ctx])
   | AwaitClientChangeCipherSpecResume (session, client_ctx, server_verify, log) ->
      let* () =
-       guard (Cstruct.length state.hs_fragment = 0)
+       guard (String.length state.hs_fragment = 0)
          (`Fatal `HandshakeFragmentsNotEmpty)
      in
      let machina = AwaitClientFinishedResume (session, server_verify, log)
diff --git a/lib/packet.ml b/lib/packet.ml
index c6997bfe..67e3c4af 100644
--- a/lib/packet.ml
+++ b/lib/packet.ml
@@ -1,12 +1,12 @@
 (** Magic numbers of the TLS protocol. *)
 
 (* HACK: 24 bits type not in cstruct *)
-let get_uint24_len buf =
-  (String.get_uint16_be buf 0) * 0x100 + (String.get_uint8 buf 2)
+let get_uint24_len ~off buf =
+  (String.get_uint16_be buf off) * 0x100 + (String.get_uint8 buf (off + 2))
 
-let set_uint24_len buf num =
-  Bytes.set_uint16_be buf 0 (num / 0x100);
-  Bytes.set_uint8 buf 2 (num mod 0x100)
+let set_uint24_len ~off buf num =
+  Bytes.set_uint16_be buf off (num / 0x100);
+  Bytes.set_uint8 buf (off + 2) (num mod 0x100)
 
 (* TLS record content type *)
 type content_type =
diff --git a/lib/reader.ml b/lib/reader.ml
index 927cfa5b..a38d882e 100644
--- a/lib/reader.ml
+++ b/lib/reader.ml
@@ -34,25 +34,25 @@ let catch f x =
   | Reader_error err   -> Error err
   | Invalid_argument _ -> Error Underflow
 
-let parse_version_int buf =
-  let major = String.get_uint8 buf 0 in
-  let minor = String.get_uint8 buf 1 in
+let parse_version_int buf off =
+  let major = String.get_uint8 buf off in
+  let minor = String.get_uint8 buf (off + 1) in
   (major, minor)
 
-let parse_version_exn buf =
-  let version = parse_version_int buf in
+let parse_version_exn buf off =
+  let version = parse_version_int buf off in
   match tls_version_of_pair version with
   | Some x -> x
   | None   ->
     let major, minor = version in
     raise (Reader_error (UnknownVersion (major, minor)))
 
-let parse_any_version_opt buf =
-  let version = parse_version_int buf in
-  tls_any_version_of_pair version, shift buf 2
+let parse_any_version_opt buf off =
+  let version = parse_version_int buf off in
+  tls_any_version_of_pair version, off + 2
 
-let parse_any_version_exn buf =
-  match parse_any_version_opt buf with
+let parse_any_version_exn buf off =
+  match parse_any_version_opt buf off with
   | Some x, _ -> x
   | None, _ ->
     let major, minor = (String.get_uint8 buf 0, String.get_uint8 buf 1) in
@@ -67,7 +67,7 @@ let parse_record buf =
     Ok (`Fragment buf)
   else
     let typ = String.get_uint8 buf 0
-    and version = parse_version_int (shift buf 1)
+    and version = parse_version_int buf 1
     in
     match String.get_uint16_be buf 3 with
     | x when x > (1 lsl 14 + 2048) ->
@@ -84,7 +84,7 @@ let parse_record buf =
       | None, _ -> Error (UnknownVersion version)
       | _, None -> Error (UnknownContent typ)
       | Some version, Some content_type ->
-        let payload, rest = split ~start:5 buf x in
+        let payload, rest = Core.split_str ~start:5 buf x in
         Ok (`Record (({ content_type ; version }, payload), rest))
 
 let validate_alert (lvl, typ) =
@@ -125,156 +125,155 @@ let parse_change_cipher_spec buf =
   | 1, 1 -> Ok ()
   | _    -> Error (Unknown "bad change cipher spec message")
 
-let rec parse_count_list parsef buf acc = function
-  | 0 -> (List.rev acc, buf)
+let rec parse_count_list parsef buf off acc = function
+  | 0 -> (List.rev acc, off)
   | n ->
-     match parsef buf with
-     | Some elem, buf' -> parse_count_list parsef buf' (elem :: acc) (pred n)
-     | None     , buf' -> parse_count_list parsef buf'          acc  (pred n)
+     match parsef buf off with
+     | Some elem, off' -> parse_count_list parsef buf off' (elem :: acc) (pred n)
+     | None     , off' -> parse_count_list parsef buf off'          acc  (pred n)
 
-let rec parse_list parsef buf acc =
-  match String.length buf with
-  | 0 -> List.rev acc
+let rec parse_list parsef buf ~off ~len acc =
+  match String.length buf - off with
+  | x when x = len -> List.rev acc
   | _ ->
-     match parsef buf with
-     | Some elem, buf' -> parse_list parsef buf' (elem :: acc)
-     | None     , buf' -> parse_list parsef buf'          acc
+     match parsef buf off with
+     | Some elem, off -> parse_list parsef buf ~off ~len (elem :: acc)
+     | None     , off -> parse_list parsef buf ~off ~len         acc
 
-let parse_compression_method buf =
-  let cm = String.get_uint8 buf 0 in
-  (int_to_compression_method cm, shift buf 1)
+let parse_compression_method buf off =
+  let cm = String.get_uint8 buf off in
+  (int_to_compression_method cm, off + 1)
 
-let parse_compression_methods buf =
-  let count = String.get_uint8 buf 0 in
-  parse_count_list parse_compression_method (shift buf 1) [] count
+let parse_compression_methods buf off =
+  let count = String.get_uint8 buf off in
+  parse_count_list parse_compression_method buf (off + 1) [] count
 
-let parse_any_ciphersuite buf =
-  let typ = String.get_uint16_be buf 0 in
-  (int_to_any_ciphersuite typ, shift buf 2)
+let parse_any_ciphersuite buf off =
+  let typ = String.get_uint16_be buf off in
+  (int_to_any_ciphersuite typ, off + 2)
 
-let parse_any_ciphersuites buf =
-  let count = String.get_uint16_be buf 0 in
+let parse_any_ciphersuites buf off =
+  let count = String.get_uint16_be buf off in
   if count mod 2 <> 0 then
     raise_wrong_length "ciphersuite list"
   else
-    parse_count_list parse_any_ciphersuite (shift buf 2) [] (count / 2)
-
-let parse_ciphersuite buf =
-  match parse_any_ciphersuite buf with
-  | None   , buf' -> (None, buf')
-  | Some cs, buf' -> match Ciphersuite.any_ciphersuite_to_ciphersuite cs with
-                       | None     -> (None, buf')
-                       | Some cs' -> (Some cs', buf')
-
-let parse_hostnames buf =
-  match String.length buf with
-  | 0 -> []
+    parse_count_list parse_any_ciphersuite buf (off + 2) [] (count / 2)
+
+let parse_ciphersuite buf off =
+  match parse_any_ciphersuite buf off with
+  | None   , off' -> (None, off')
+  | Some cs, off' -> match Ciphersuite.any_ciphersuite_to_ciphersuite cs with
+                       | None     -> (None, off')
+                       | Some cs' -> (Some cs', off')
+
+let parse_hostnames buf ~off ~len =
+  match String.length buf - off with
+  | x when x = len -> []
   | n ->
-     let parsef buf =
-       let typ = String.get_uint8 buf 0 in
-       let entrylen = String.get_uint16_be buf 1 in
-       let rt = shift buf (3 + entrylen) in
+     let parsef buf off =
+       let typ = String.get_uint8 buf off in
+       let entrylen = String.get_uint16_be buf (off + 1) in
        match typ with
-       | 0 -> let hostname = to_string ~off:3 ~len:entrylen buf in
-              (Some hostname, rt)
-       | _ -> (None, rt)
+       | 0 ->
+         let hostname = String.sub buf (off + 3) entrylen in
+         (Some hostname, off + 3 + entrylen)
+       | _ -> (None, off + 3 + entrylen)
      in
-     let list_length = String.get_uint16_be buf 0 in
-     if list_length + 2 <> n then
+     let list_length = String.get_uint16_be buf off in
+     if list_length + 2 <> len then
        raise_trailing_bytes "hostname"
      else
-       parse_list parsef (sub buf 2 list_length) []
+       parse_list parsef buf ~off:(off + 2) ~len []
 
-let parse_fragment_length buf =
-  if String.length buf <> 1 then
+let parse_fragment_length buf off =
+  if String.length buf - off <> 1 then
     raise_trailing_bytes "fragment length"
   else
-    int_to_max_fragment_length (String.get_uint8 buf 0)
+    int_to_max_fragment_length (String.get_uint8 buf off)
 
-let parse_supported_version buf =
-  parse_any_version_opt buf
+let parse_supported_version buf off =
+  parse_any_version_opt buf off
 
-let parse_supported_versions buf =
-  let len = String.get_uint8 buf 0 in
+let parse_supported_versions buf off =
+  let len = String.get_uint8 buf off in
   if len mod 2 <> 0 then
     raise_wrong_length "supported versions"
   else
-    parse_count_list parse_supported_version (shift buf 1) [] (len / 2)
+    parse_count_list parse_supported_version buf (off + 1) [] (len / 2)
 
-let parse_named_group buf =
-  let typ = String.get_uint16_be buf 0 in
-  (int_to_named_group typ, shift buf 2)
+let parse_named_group buf off =
+  let typ = String.get_uint16_be buf off in
+  (int_to_named_group typ, off + 2)
 
-let parse_group buf =
-  match parse_named_group buf with
-  | Some x, buf -> (named_group_to_group x, buf)
-  | None, buf -> (None, buf)
+let parse_group buf off =
+  match parse_named_group buf off with
+  | Some x, off' -> (named_group_to_group x, off')
+  | None, off' -> (None, off')
 
-let parse_supported_groups buf =
-  let count = String.get_uint16_be buf 0 in
+let parse_supported_groups buf off =
+  let count = String.get_uint16_be buf off in
   if count mod 2 <> 0 then
     raise_wrong_length "elliptic curve list"
   else
-    let cs, rt = parse_count_list parse_named_group (shift buf 2) [] (count / 2) in
-    if String.length rt <> 0 then
+    let cs, off' = parse_count_list parse_named_group buf (off + 2) [] (count / 2) in
+    if String.length buf + off <> off' then
       raise_trailing_bytes "elliptic curves"
     else
       cs
 
-let parse_signature_algorithm buf =
-  match int_to_signature_alg (String.get_uint16_be buf 0) with
+let parse_signature_algorithm buf off =
+  match int_to_signature_alg (String.get_uint16_be buf off) with
   | Some sig_alg -> of_signature_alg sig_alg
   | _            -> None
 
-let parse_signature_algorithms buf =
-  let parsef buf = parse_signature_algorithm buf, shift buf 2 in
+let parse_signature_algorithms buf off =
+  let parsef buf off = parse_signature_algorithm buf off, off + 2 in
   let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "signature hash"
   else
-    parse_count_list parsef (shift buf 2) [] (count / 2)
+    parse_count_list parsef buf (off + 2) [] (count / 2)
 
-let parse_alpn_protocol raw =
-  let length = String.get_uint8 raw 0 in
-  let buf = sub raw 1 length in
-  let protocol = Cstruct.to_string buf in
-  (Some protocol, shift raw (1 + length))
+let parse_alpn_protocol raw off =
+  let length = String.get_uint8 raw off in
+  let protocol = String.sub raw (off + 1) length in
+  (Some protocol, off + 1 + length)
 
-let parse_alpn_protocols buf =
-  let len = String.get_uint16_be buf 0 in
-  if String.length buf <> len + 2 then
+let parse_alpn_protocols buf off =
+  let len = String.get_uint16_be buf off in
+  if String.length buf - off < len + 2 then
     raise_trailing_bytes "alpn"
   else
-    parse_list parse_alpn_protocol (sub buf 2 len) []
+    parse_list parse_alpn_protocol buf ~off:(off + 2) ~len []
 
-let parse_ec_point_format buf =
+let parse_ec_point_format buf off =
   (* this is deprecated, we only check that uncompressed (typ 0) is present *)
-  let data = String.get_uint8 buf 0 in
-  Some (data = 0), shift buf 1
+  let data = String.get_uint8 buf off in
+  Some (data = 0), off + 1
 
-let parse_ec_point_formats buf =
-  let count = String.get_uint8 buf 0 in
-  parse_count_list parse_ec_point_format (shift buf 1) [] count
+let parse_ec_point_formats buf off =
+  let count = String.get_uint8 buf off in
+  parse_count_list parse_ec_point_format buf (off + 1) [] count
 
-let parse_extension buf = function
+let parse_extension buf off = function
   | MAX_FRAGMENT_LENGTH ->
-     (match parse_fragment_length buf with
+     (match parse_fragment_length buf off with
       | Some mfl -> `MaxFragmentLength mfl
       | None     -> raise_unknown "maximum fragment length")
   | RENEGOTIATION_INFO ->
-       let len' = String.get_uint8 buf 0 in
-       if String.length buf <> len' + 1 then
+       let len' = String.get_uint8 buf off in
+       if String.length buf - off <> len' + 1 then
          raise_trailing_bytes "renegotiation"
        else
-         `SecureRenegotiation (sub buf 1 len')
+         `SecureRenegotiation (String.sub buf off len')
   | EXTENDED_MASTER_SECRET ->
       if String.length buf > 0 then
          raise_trailing_bytes "extended master secret"
       else
         `ExtendedMasterSecret
   | EC_POINT_FORMATS ->
-    let formats, rt = parse_ec_point_formats buf in
-    if String.length rt <> 0 then
+    let formats, off' = parse_ec_point_formats buf off in
+    if String.length buf <> 0 then
       raise_trailing_bytes "ec point formats"
     else if List.mem true formats then
       `ECPointFormats
@@ -503,22 +502,25 @@ let parse_retry_extension raw =
   in
   (Some data, shift raw (4 + len))
 
-let parse_extensions parse_ext buf =
-  let len = String.get_uint16_be buf 0 in
-  if String.length buf <> len + 2 then
+let parse_extensions parse_ext buf off =
+  let len = String.get_uint16_be buf off in
+  if String.length buf - off <> len + 2 then
     raise_trailing_bytes "extensions"
   else
-    parse_list parse_ext (sub buf 2 len) []
+    parse_list parse_ext buf ~off:(2 + off) ~len []
 
 let parse_client_hello buf =
-  let client_version = parse_any_version_exn buf in
-  let client_random = sub buf 2 32 in
+  let client_version = parse_any_version_exn buf 0 in
+  let client_random = String.sub buf 2 32 in
   let slen = String.get_uint8 buf 34 in
-  let sessionid = if slen = 0 then None else Some (sub buf 35 slen) in
-  let ciphersuites, rt = parse_any_ciphersuites (shift buf (35 + slen)) in
-  let _, rt' = parse_compression_methods rt in
+  let sessionid = if slen = 0 then None else Some (String.sub buf 35 slen) in
+  let ciphersuites, off = parse_any_ciphersuites buf (35 + slen) in
+  let _, off = parse_compression_methods buf off in
   let extensions =
-    if String.length rt' = 0 then [] else parse_extensions parse_client_extension rt'
+    if String.length buf - off = 0 then
+      []
+    else
+      parse_extensions parse_client_extension off
   in
   (* TLS 1.3 mandates PreSharedKeys to be the last extension *)
   (if List.exists (function `PreSharedKeys _ -> true | _ -> false) extensions then
@@ -795,10 +797,10 @@ let parse_handshake_frame buf =
   if String.length buf < 4 then
     (None, buf)
   else
-    let l = get_uint24_len (shift buf 1) in
+    let l = get_uint24_len ~off:1 buf in
     let hslen = l + 4 in
     if String.length buf >= hslen then
-      let hs, rest = split buf hslen in
+      let hs, rest = split_str buf hslen in
       (Some hs, rest)
     else
       (None, buf)
@@ -806,11 +808,11 @@ let parse_handshake_frame buf =
 let parse_handshake = catch @@ fun buf ->
   let typ = String.get_uint8 buf 0 in
   let handshake_type = int_to_handshake_type typ in
-  let len = get_uint24_len (shift buf 1) in
+  let len = get_uint24_len ~off:1 buf in
   if String.length buf <> len + 4 then
     raise_trailing_bytes "handshake"
   else
-    let payload = sub buf 4 len in
+    let payload = String.sub buf 4 len in
     match handshake_type with
     | Some HELLO_REQUEST ->
       if String.length payload = 0 then HelloRequest else raise_trailing_bytes "hello request"
diff --git a/lwt/tls_lwt.ml b/lwt/tls_lwt.ml
index de42f093..9a34ffa6 100644
--- a/lwt/tls_lwt.ml
+++ b/lwt/tls_lwt.ml
@@ -3,8 +3,6 @@ open Lwt.Infix
 exception Tls_alert   of Tls.Packet.alert_type
 exception Tls_failure of Tls.Engine.failure
 
-let o f g x = f (g x)
-
 (* This really belongs just about anywhere else: generic unix name resolution. *)
 let resolve host service =
   let open Lwt_unix in
@@ -17,18 +15,24 @@ let resolve host service =
 
 module Lwt_cs = struct
 
-  let naked ~name f fd cs =
-    Cstruct.(f fd cs.buffer cs.off cs.len) >>= fun res ->
+  let naked ~name f fd cs off len =
+    f fd cs off len >>= fun res ->
     match Lwt_unix.getsockopt_error fd with
     | None     -> Lwt.return res
     | Some err -> Lwt.reraise @@ Unix.Unix_error (err, name, "")
 
-  let write = naked ~name:"Tls_lwt.write" Lwt_bytes.write
-  and read  = naked ~name:"Tls_lwt.read"  Lwt_bytes.read
+  let write = naked ~name:"Tls_lwt.write" Lwt_unix.write
+  and read  = naked ~name:"Tls_lwt.read"  Lwt_unix.read
+
+  let rec write_full ?(off = 0) ?len fd buf =
+    let len = Option.value ~default:(String.length buf - off) len in
+    if len = 0 then
+      Lwt.return_unit
+    else
+      write fd (Bytes.unsafe_of_string buf) off len >>= fun written ->
+      write_full ~off:(off + written) ~len:(len - written) fd buf
 
-  let rec write_full fd = function
-    | cs when Cstruct.length cs = 0 -> Lwt.return_unit
-    | cs -> write fd cs >>= o (write_full fd) (Cstruct.shift cs)
+  let read fd buf = read fd buf 0 (Bytes.length buf)
 end
 
 module Unix = struct
@@ -40,8 +44,8 @@ module Unix = struct
                      | `Write_closed of Tls.Engine.state
                      | `Closed
                      | `Error of exn ] ;
-    mutable linger : Cstruct.t option ;
-    recv_buf       : Cstruct.t ;
+    mutable linger : string option ;
+    recv_buf       : bytes ;
   }
 
   let half_close state mode =
@@ -114,18 +118,17 @@ module Unix = struct
           match t.state with
           | `Error e -> Lwt.reraise e
           | `Active tls | `Read_closed tls | `Write_closed tls ->
-            handle tls (Cstruct.sub t.recv_buf 0 n)
+            handle tls (String.sub (Bytes.unsafe_to_string t.recv_buf) 0 n)
           | `Closed -> Lwt.return `Eof
 
   let rec read t buf =
 
     let writeout res =
-      let open Cstruct in
-      let rlen = length res in
-      let n    = min (length buf) rlen in
-      blit res 0 buf 0 n ;
+      let rlen = String.length res in
+      let n    = min (Bytes.length buf) rlen in
+      Bytes.blit_string res 0 buf 0 n ;
       t.linger <-
-        (if n < rlen then Some (sub res n (rlen - n)) else None) ;
+        (if n < rlen then Some (String.sub res n (rlen - n)) else None) ;
       Lwt.return n in
 
     match t.linger with
@@ -160,7 +163,7 @@ module Unix = struct
       match (mcs, t.linger) with
       | (None, _)         -> ()
       | (scs, None)       -> t.linger <- scs
-      | (Some cs, Some l) -> t.linger <- Some (Cstruct.append l cs)
+      | (Some cs, Some l) -> t.linger <- Some (l ^ cs)
     in
     match t.state with
     | `Active tls when not (Tls.Engine.handshake_in_progress tls) ->
@@ -218,7 +221,7 @@ module Unix = struct
       state    = `Active (Tls.Engine.server config) ;
       fd       = fd ;
       linger   = None ;
-      recv_buf = Cstruct.create 4096
+      recv_buf = Bytes.create 4096
     }
 
   let client_of_fd config ?host fd =
@@ -231,7 +234,7 @@ module Unix = struct
       state    = `Active tls ;
       fd       = fd ;
       linger   = None ;
-      recv_buf = Cstruct.create 4096
+      recv_buf = Bytes.create 4096
     }
     in
     write_t t init >>= fun () ->
@@ -258,10 +261,16 @@ module Unix = struct
         | exn -> safely (Lwt_unix.close fd) >>= fun () -> Lwt.reraise exn)
 
   let read_bytes t bs off len =
-    read t (Cstruct.of_bigarray ~off ~len bs)
+    let buf = Bytes.create len in
+    read t buf >|= fun n ->
+    let to_copy = min n len in
+    Lwt_bytes.blit_from_bytes buf 0 bs off to_copy;
+    to_copy
 
   let write_bytes t bs off len =
-    write t (Cstruct.of_bigarray ~off ~len bs)
+    let buf = Bytes.create len in
+    Lwt_bytes.blit_to_bytes bs off buf 0 len;
+    write t (Bytes.unsafe_to_string buf)
 
   let epoch t =
     match t.state with
diff --git a/lwt/tls_lwt.mli b/lwt/tls_lwt.mli
index ee89fcff..c6b7e1f2 100644
--- a/lwt/tls_lwt.mli
+++ b/lwt/tls_lwt.mli
@@ -45,13 +45,13 @@ module Unix : sig
 
   (** [read t buffer] is [length], the number of bytes read into
       [buffer]. *)
-  val read   : t -> Cstruct.t      -> int  Lwt.t
+  val read   : t -> bytes       -> int  Lwt.t
 
   (** [write t buffer] writes the [buffer] to the session. *)
-  val write  : t -> Cstruct.t      -> unit Lwt.t
+  val write  : t -> string      -> unit Lwt.t
 
   (** [writev t buffers] writes the [buffers] to the session. *)
-  val writev : t -> Cstruct.t list -> unit Lwt.t
+  val writev : t -> string list -> unit Lwt.t
 
   (** [read_bytes t bytes offset len] is [read_bytes], the amount of
       bytes read. *)
diff --git a/lwt/x509_lwt.ml b/lwt/x509_lwt.ml
index 120c6d03..7dfd192f 100644
--- a/lwt/x509_lwt.ml
+++ b/lwt/x509_lwt.ml
@@ -15,7 +15,7 @@ let o f g x = f (g x)
 let read_file path =
   let open Lwt_io in
   open_file ~mode:Input path >>= fun file ->
-  read file >|= Cstruct.of_string >>= fun cs ->
+  read file >>= fun cs ->
   close file >|= fun () ->
   cs
 
@@ -90,7 +90,7 @@ let authenticator ?allowed_hashes ?crls param =
     crls_of_pem_dir crls >|= fun crls ->
     X509.Authenticator.chain_of_trust ?allowed_hashes ?crls ~time cas
   and dotted_hex_to_cs hex =
-    Cstruct.of_hex (String.map (function ':' -> ' ' | x -> x) hex)
+    Ohex.decode (String.map (function ':' -> ' ' | x -> x) hex)
   and fingerp hash fingerprint =
     X509.Authenticator.server_key_fingerprint ~time ~hash ~fingerprint
   and cert_fingerp hash fingerprint =
diff --git a/lwt/x509_lwt.mli b/lwt/x509_lwt.mli
index c625dfbe..e2bdeb28 100644
--- a/lwt/x509_lwt.mli
+++ b/lwt/x509_lwt.mli
@@ -15,12 +15,12 @@ val certs_of_pem_dir : Lwt_io.file_name -> X509.Certificate.t list Lwt.t
 
 (** [authenticator methods] constructs an [authenticator] using the
     specified method and data. *)
-val authenticator : ?allowed_hashes:Mirage_crypto.Hash.hash list -> ?crls:Lwt_io.file_name ->
+val authenticator : ?allowed_hashes:Digestif.hash' list -> ?crls:Lwt_io.file_name ->
   [ `Ca_file of Lwt_io.file_name
   | `Ca_dir  of Lwt_io.file_name
-  | `Key_fingerprint of Mirage_crypto.Hash.hash * Cstruct.t
-  | `Hex_key_fingerprint of Mirage_crypto.Hash.hash * string
-  | `Cert_fingerprint of Mirage_crypto.Hash.hash * Cstruct.t
-  | `Hex_cert_fingerprint of Mirage_crypto.Hash.hash * string
+  | `Key_fingerprint of Digestif.hash' * string
+  | `Hex_key_fingerprint of Digestif.hash' * string
+  | `Cert_fingerprint of Digestif.hash' * string
+  | `Hex_cert_fingerprint of Digestif.hash' * string
   ]
   -> X509.Authenticator.t Lwt.t

From 115247102169ebae92ea7d0ee7b907de3aface8d Mon Sep 17 00:00:00 2001
From: Hannes Mehnert <hannes@mehnert.org>
Date: Thu, 4 Apr 2024 01:40:06 +0200
Subject: [PATCH 3/9] more -- tls & tls-lwt compile and tests are running

---
 lib/core.ml                |   2 +-
 lib/engine.ml              |   3 +-
 lib/handshake_client.ml    |   3 +-
 lib/handshake_server13.ml  |   3 +-
 lib/reader.ml              | 289 +++++++++++++++--------------
 lib/writer.ml              | 360 ++++++++++++++++++-------------------
 tests/dune                 |   4 +-
 tests/key_derivation.ml    | 195 ++++++++++----------
 tests/readertests.ml       | 103 ++++++-----
 tests/readerwritertests.ml |  14 +-
 tests/testlib.ml           |  23 +--
 tests/writertests.ml       |  88 ++++-----
 12 files changed, 540 insertions(+), 547 deletions(-)

diff --git a/lib/core.ml b/lib/core.ml
index ca7a951f..64be5479 100644
--- a/lib/core.ml
+++ b/lib/core.ml
@@ -8,7 +8,7 @@ let ( let* ) = Result.bind
 let guard p e = if p then Ok () else Error e
 
 let split_str ?(start = 0) str off =
-  String.sub str start (start + off),
+  String.sub str start off,
   String.sub str (start + off) (String.length str - off - start)
 
 let map_reader_error r = Result.map_error (fun re -> `Fatal (`ReaderError re)) r
diff --git a/lib/engine.ml b/lib/engine.ml
index 997263c2..26ed6f1b 100644
--- a/lib/engine.ml
+++ b/lib/engine.ml
@@ -317,8 +317,7 @@ let decrypt ?(trial = false) (version : tls_version) (st : crypto_state) ty buf
 (* party time *)
 let rec separate_records : string -> ((tls_hdr * string) list * string, failure) result
 = fun buf ->
-  let open Reader in
-  match parse_record buf with
+  match Reader.parse_record buf with
   | Ok (`Fragment b) -> Ok ([], b)
   | Ok (`Record (packet, fragment)) ->
     let* tl, frag = separate_records fragment in
diff --git a/lib/handshake_client.ml b/lib/handshake_client.ml
index c7185cf3..618937a4 100644
--- a/lib/handshake_client.ml
+++ b/lib/handshake_client.ml
@@ -501,8 +501,7 @@ let handle_change_cipher_spec cs state packet =
   | _ -> Error (`Fatal `UnexpectedCCS)
 
 let handle_handshake cs hs buf =
-  let open Reader in
-  let* handshake = map_reader_error (parse_handshake buf) in
+  let* handshake = map_reader_error (Reader.parse_handshake buf) in
   Tracing.hs ~tag:"handshake-in" handshake ;
   match cs, handshake with
   | AwaitServerHello (ch, secrets, log), ServerHello sh ->
diff --git a/lib/handshake_server13.ml b/lib/handshake_server13.ml
index 3965d6b8..62435d81 100644
--- a/lib/handshake_server13.ml
+++ b/lib/handshake_server13.ml
@@ -493,8 +493,7 @@ let handle_key_update state req =
   | _ -> Error (`Fatal `InvalidSession)
 
 let handle_handshake cs hs buf =
-  let open Reader in
-  let* handshake = map_reader_error (parse_handshake buf) in
+  let* handshake = map_reader_error (Reader.parse_handshake buf) in
   Tracing.hs ~tag:"handshake-in" handshake;
   match cs, handshake with
   | AwaitClientHelloHRR13, ClientHello ch ->
diff --git a/lib/reader.ml b/lib/reader.ml
index a38d882e..e01d65df 100644
--- a/lib/reader.ml
+++ b/lib/reader.ml
@@ -29,30 +29,32 @@ let raise_unknown msg        = raise (Reader_error (Unknown msg))
 and raise_wrong_length msg   = raise (Reader_error (WrongLength msg))
 and raise_trailing_bytes msg = raise (Reader_error (TrailingBytes msg))
 
+let shift str amount = String.sub str amount (String.length str - amount)
+
 let catch f x =
   try Ok (f x) with
   | Reader_error err   -> Error err
   | Invalid_argument _ -> Error Underflow
 
-let parse_version_int buf off =
-  let major = String.get_uint8 buf off in
-  let minor = String.get_uint8 buf (off + 1) in
+let parse_version_int buf =
+  let major = String.get_uint8 buf 0 in
+  let minor = String.get_uint8 buf 1 in
   (major, minor)
 
-let parse_version_exn buf off =
-  let version = parse_version_int buf off in
+let parse_version_exn buf =
+  let version = parse_version_int buf in
   match tls_version_of_pair version with
   | Some x -> x
   | None   ->
     let major, minor = version in
     raise (Reader_error (UnknownVersion (major, minor)))
 
-let parse_any_version_opt buf off =
-  let version = parse_version_int buf off in
-  tls_any_version_of_pair version, off + 2
+let parse_any_version_opt buf =
+  let version = parse_version_int buf in
+  tls_any_version_of_pair version, shift buf 2
 
-let parse_any_version_exn buf off =
-  match parse_any_version_opt buf off with
+let parse_any_version_exn buf =
+  match parse_any_version_opt buf with
   | Some x, _ -> x
   | None, _ ->
     let major, minor = (String.get_uint8 buf 0, String.get_uint8 buf 1) in
@@ -67,7 +69,7 @@ let parse_record buf =
     Ok (`Fragment buf)
   else
     let typ = String.get_uint8 buf 0
-    and version = parse_version_int buf 1
+    and version = parse_version_int (shift buf 1)
     in
     match String.get_uint16_be buf 3 with
     | x when x > (1 lsl 14 + 2048) ->
@@ -84,7 +86,7 @@ let parse_record buf =
       | None, _ -> Error (UnknownVersion version)
       | _, None -> Error (UnknownContent typ)
       | Some version, Some content_type ->
-        let payload, rest = Core.split_str ~start:5 buf x in
+        let payload, rest = split_str ~start:5 buf x in
         Ok (`Record (({ content_type ; version }, payload), rest))
 
 let validate_alert (lvl, typ) =
@@ -125,155 +127,155 @@ let parse_change_cipher_spec buf =
   | 1, 1 -> Ok ()
   | _    -> Error (Unknown "bad change cipher spec message")
 
-let rec parse_count_list parsef buf off acc = function
-  | 0 -> (List.rev acc, off)
+let rec parse_count_list parsef buf acc = function
+  | 0 -> (List.rev acc, buf)
   | n ->
-     match parsef buf off with
-     | Some elem, off' -> parse_count_list parsef buf off' (elem :: acc) (pred n)
-     | None     , off' -> parse_count_list parsef buf off'          acc  (pred n)
+     match parsef buf with
+     | Some elem, buf' -> parse_count_list parsef buf' (elem :: acc) (pred n)
+     | None     , buf' -> parse_count_list parsef buf'          acc  (pred n)
 
-let rec parse_list parsef buf ~off ~len acc =
-  match String.length buf - off with
-  | x when x = len -> List.rev acc
+let rec parse_list parsef buf acc =
+  match String.length buf with
+  | 0 -> List.rev acc
   | _ ->
-     match parsef buf off with
-     | Some elem, off -> parse_list parsef buf ~off ~len (elem :: acc)
-     | None     , off -> parse_list parsef buf ~off ~len         acc
+     match parsef buf with
+     | Some elem, buf' -> parse_list parsef buf' (elem :: acc)
+     | None     , buf' -> parse_list parsef buf'          acc
 
-let parse_compression_method buf off =
-  let cm = String.get_uint8 buf off in
-  (int_to_compression_method cm, off + 1)
+let parse_compression_method buf =
+  let cm = String.get_uint8 buf 0 in
+  (int_to_compression_method cm, shift buf 1)
 
-let parse_compression_methods buf off =
-  let count = String.get_uint8 buf off in
-  parse_count_list parse_compression_method buf (off + 1) [] count
+let parse_compression_methods buf =
+  let count = String.get_uint8 buf 0 in
+  parse_count_list parse_compression_method (shift buf 1) [] count
 
-let parse_any_ciphersuite buf off =
-  let typ = String.get_uint16_be buf off in
-  (int_to_any_ciphersuite typ, off + 2)
+let parse_any_ciphersuite buf =
+  let typ = String.get_uint16_be buf 0 in
+  (int_to_any_ciphersuite typ, shift buf 2)
 
-let parse_any_ciphersuites buf off =
-  let count = String.get_uint16_be buf off in
+let parse_any_ciphersuites buf =
+  let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "ciphersuite list"
   else
-    parse_count_list parse_any_ciphersuite buf (off + 2) [] (count / 2)
-
-let parse_ciphersuite buf off =
-  match parse_any_ciphersuite buf off with
-  | None   , off' -> (None, off')
-  | Some cs, off' -> match Ciphersuite.any_ciphersuite_to_ciphersuite cs with
-                       | None     -> (None, off')
-                       | Some cs' -> (Some cs', off')
-
-let parse_hostnames buf ~off ~len =
-  match String.length buf - off with
-  | x when x = len -> []
+    parse_count_list parse_any_ciphersuite (shift buf 2) [] (count / 2)
+
+let parse_ciphersuite buf =
+  match parse_any_ciphersuite buf with
+  | None   , buf' -> (None, buf')
+  | Some cs, buf' -> match Ciphersuite.any_ciphersuite_to_ciphersuite cs with
+                       | None     -> (None, buf')
+                       | Some cs' -> (Some cs', buf')
+
+let parse_hostnames buf =
+  match String.length buf with
+  | 0 -> []
   | n ->
-     let parsef buf off =
-       let typ = String.get_uint8 buf off in
-       let entrylen = String.get_uint16_be buf (off + 1) in
+     let parsef buf =
+       let typ = String.get_uint8 buf 0 in
+       let entrylen = String.get_uint16_be buf 1 in
+       let rt = shift buf (3 + entrylen) in
        match typ with
-       | 0 ->
-         let hostname = String.sub buf (off + 3) entrylen in
-         (Some hostname, off + 3 + entrylen)
-       | _ -> (None, off + 3 + entrylen)
+       | 0 -> let hostname = String.sub buf 3 entrylen in
+              (Some hostname, rt)
+       | _ -> (None, rt)
      in
-     let list_length = String.get_uint16_be buf off in
-     if list_length + 2 <> len then
+     let list_length = String.get_uint16_be buf 0 in
+     if list_length + 2 <> n then
        raise_trailing_bytes "hostname"
      else
-       parse_list parsef buf ~off:(off + 2) ~len []
+       parse_list parsef (String.sub buf 2 list_length) []
 
-let parse_fragment_length buf off =
-  if String.length buf - off <> 1 then
+let parse_fragment_length buf =
+  if String.length buf <> 1 then
     raise_trailing_bytes "fragment length"
   else
-    int_to_max_fragment_length (String.get_uint8 buf off)
+    int_to_max_fragment_length (String.get_uint8 buf 0)
 
-let parse_supported_version buf off =
-  parse_any_version_opt buf off
+let parse_supported_version buf =
+  parse_any_version_opt buf
 
-let parse_supported_versions buf off =
-  let len = String.get_uint8 buf off in
+let parse_supported_versions buf =
+  let len = String.get_uint8 buf 0 in
   if len mod 2 <> 0 then
     raise_wrong_length "supported versions"
   else
-    parse_count_list parse_supported_version buf (off + 1) [] (len / 2)
+    parse_count_list parse_supported_version (shift buf 1) [] (len / 2)
 
-let parse_named_group buf off =
-  let typ = String.get_uint16_be buf off in
-  (int_to_named_group typ, off + 2)
+let parse_named_group buf =
+  let typ = String.get_uint16_be buf 0 in
+  (int_to_named_group typ, shift buf 2)
 
-let parse_group buf off =
-  match parse_named_group buf off with
-  | Some x, off' -> (named_group_to_group x, off')
-  | None, off' -> (None, off')
+let parse_group buf =
+  match parse_named_group buf with
+  | Some x, buf -> (named_group_to_group x, buf)
+  | None, buf -> (None, buf)
 
-let parse_supported_groups buf off =
-  let count = String.get_uint16_be buf off in
+let parse_supported_groups buf =
+  let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "elliptic curve list"
   else
-    let cs, off' = parse_count_list parse_named_group buf (off + 2) [] (count / 2) in
-    if String.length buf + off <> off' then
+    let cs, rt = parse_count_list parse_named_group (shift buf 2) [] (count / 2) in
+    if String.length rt <> 0 then
       raise_trailing_bytes "elliptic curves"
     else
       cs
 
-let parse_signature_algorithm buf off =
-  match int_to_signature_alg (String.get_uint16_be buf off) with
+let parse_signature_algorithm buf =
+  match int_to_signature_alg (String.get_uint16_be buf 0) with
   | Some sig_alg -> of_signature_alg sig_alg
   | _            -> None
 
-let parse_signature_algorithms buf off =
-  let parsef buf off = parse_signature_algorithm buf off, off + 2 in
+let parse_signature_algorithms buf =
+  let parsef buf = parse_signature_algorithm buf, shift buf 2 in
   let count = String.get_uint16_be buf 0 in
   if count mod 2 <> 0 then
     raise_wrong_length "signature hash"
   else
-    parse_count_list parsef buf (off + 2) [] (count / 2)
+    parse_count_list parsef (shift buf 2) [] (count / 2)
 
-let parse_alpn_protocol raw off =
-  let length = String.get_uint8 raw off in
-  let protocol = String.sub raw (off + 1) length in
-  (Some protocol, off + 1 + length)
+let parse_alpn_protocol raw =
+  let length = String.get_uint8 raw 0 in
+  let protocol = String.sub raw 1 length in
+  (Some protocol, shift raw (1 + length))
 
-let parse_alpn_protocols buf off =
-  let len = String.get_uint16_be buf off in
-  if String.length buf - off < len + 2 then
+let parse_alpn_protocols buf =
+  let len = String.get_uint16_be buf 0 in
+  if String.length buf <> len + 2 then
     raise_trailing_bytes "alpn"
   else
-    parse_list parse_alpn_protocol buf ~off:(off + 2) ~len []
+    parse_list parse_alpn_protocol (String.sub buf 2 len) []
 
-let parse_ec_point_format buf off =
+let parse_ec_point_format buf =
   (* this is deprecated, we only check that uncompressed (typ 0) is present *)
-  let data = String.get_uint8 buf off in
-  Some (data = 0), off + 1
+  let data = String.get_uint8 buf 0 in
+  Some (data = 0), shift buf 1
 
-let parse_ec_point_formats buf off =
-  let count = String.get_uint8 buf off in
-  parse_count_list parse_ec_point_format buf (off + 1) [] count
+let parse_ec_point_formats buf =
+  let count = String.get_uint8 buf 0 in
+  parse_count_list parse_ec_point_format (shift buf 1) [] count
 
-let parse_extension buf off = function
+let parse_extension buf = function
   | MAX_FRAGMENT_LENGTH ->
-     (match parse_fragment_length buf off with
+     (match parse_fragment_length buf with
       | Some mfl -> `MaxFragmentLength mfl
       | None     -> raise_unknown "maximum fragment length")
   | RENEGOTIATION_INFO ->
-       let len' = String.get_uint8 buf off in
-       if String.length buf - off <> len' + 1 then
+       let len' = String.get_uint8 buf 0 in
+       if String.length buf <> len' + 1 then
          raise_trailing_bytes "renegotiation"
        else
-         `SecureRenegotiation (String.sub buf off len')
+         `SecureRenegotiation (String.sub buf 1 len')
   | EXTENDED_MASTER_SECRET ->
       if String.length buf > 0 then
          raise_trailing_bytes "extended master secret"
       else
         `ExtendedMasterSecret
   | EC_POINT_FORMATS ->
-    let formats, off' = parse_ec_point_formats buf off in
-    if String.length buf <> 0 then
+    let formats, rt = parse_ec_point_formats buf in
+    if String.length rt <> 0 then
       raise_trailing_bytes "ec point formats"
     else if List.mem true formats then
       `ECPointFormats
@@ -284,7 +286,7 @@ let parse_extension buf off = function
 let parse_keyshare_entry buf =
   let parse_share data =
     let size = String.get_uint16_be data 0 in
-    split (shift data 2) size
+    split_str ~start:2 data size
   in
   let g, rest = parse_named_group buf in
   let share, left = parse_share rest in
@@ -298,17 +300,17 @@ let parse_id buf =
     raise_wrong_length "PSK id is empty"
   else
     let age = String.get_int32_be buf (id_len + 2) in
-    (Some (sub buf 2 id_len, age), shift buf (id_len + 6))
+    (Some (String.sub buf 2 id_len, age), shift buf (id_len + 6))
 
 let parse_binder buf =
   let l = String.get_uint8 buf 0 in
-  Some (sub buf 1 l), shift buf (l + 1)
+  Some (String.sub buf 1 l), shift buf (l + 1)
 
 let parse_client_presharedkeys buf =
   let id_len = String.get_uint16_be buf 0 in
-  let identities = parse_list parse_id (sub buf 2 id_len) [] in
+  let identities = parse_list parse_id (String.sub buf 2 id_len) [] in
   let binders_len = String.get_uint16_be buf (id_len + 2) in
-  let binders = parse_list parse_binder (sub buf (4 + id_len) binders_len) [] in
+  let binders = parse_list parse_binder (String.sub buf (4 + id_len) binders_len) [] in
   let id_binder = List.combine identities binders in
   if String.length buf <> 4 + binders_len + id_len then
     raise_trailing_bytes "psk"
@@ -317,7 +319,7 @@ let parse_client_presharedkeys buf =
 
 let parse_cookie buf =
   let len = String.get_uint16_be buf 0 in
-  (sub buf 2 len, shift buf (2 + len))
+  (String.sub buf 2 len, shift buf (2 + len))
 
 let parse_psk_key_exchange_mode buf =
   let data = String.get_uint8 buf 0 in
@@ -331,7 +333,7 @@ let parse_ext raw =
   let etype = String.get_uint16_be raw 0
   and length = String.get_uint16_be raw 2
   in
-  (etype, length, sub raw 4 length)
+  (etype, length, String.sub raw 4 length)
 
 let parse_client_extension raw =
   let etype, len, buf = parse_ext raw in
@@ -376,7 +378,7 @@ let parse_client_extension raw =
        if ll + 2 <> String.length buf then
          raise_unknown "bad key share extension"
        else
-         let shares = parse_list parse_keyshare_entry (sub buf 2 ll) [] in
+         let shares = parse_list parse_keyshare_entry (String.sub buf 2 ll) [] in
          `KeyShare shares
     | Some PRE_SHARED_KEY ->
       let ids = parse_client_presharedkeys buf in
@@ -502,25 +504,22 @@ let parse_retry_extension raw =
   in
   (Some data, shift raw (4 + len))
 
-let parse_extensions parse_ext buf off =
-  let len = String.get_uint16_be buf off in
-  if String.length buf - off <> len + 2 then
+let parse_extensions parse_ext buf =
+  let len = String.get_uint16_be buf 0 in
+  if String.length buf <> len + 2 then
     raise_trailing_bytes "extensions"
   else
-    parse_list parse_ext buf ~off:(2 + off) ~len []
+    parse_list parse_ext (String.sub buf 2 len) []
 
 let parse_client_hello buf =
-  let client_version = parse_any_version_exn buf 0 in
+  let client_version = parse_any_version_exn buf in
   let client_random = String.sub buf 2 32 in
   let slen = String.get_uint8 buf 34 in
   let sessionid = if slen = 0 then None else Some (String.sub buf 35 slen) in
-  let ciphersuites, off = parse_any_ciphersuites buf (35 + slen) in
-  let _, off = parse_compression_methods buf off in
+  let ciphersuites, rt = parse_any_ciphersuites (shift buf (35 + slen)) in
+  let _, rt' = parse_compression_methods rt in
   let extensions =
-    if String.length buf - off = 0 then
-      []
-    else
-      parse_extensions parse_client_extension off
+    if String.length rt' = 0 then [] else parse_extensions parse_client_extension rt'
   in
   (* TLS 1.3 mandates PreSharedKeys to be the last extension *)
   (if List.exists (function `PreSharedKeys _ -> true | _ -> false) extensions then
@@ -531,9 +530,9 @@ let parse_client_hello buf =
 
 let parse_server_hello buf =
   let server_version = parse_version_exn buf in
-  let server_random = sub buf 2 32 in
+  let server_random = String.sub buf 2 32 in
   let slen = String.get_uint8 buf 34 in
-  let sessionid = if slen = 0 then None else Some (sub buf 35 slen) in
+  let sessionid = if slen = 0 then None else Some (String.sub buf 35 slen) in
   let ciphersuite, rt = match parse_ciphersuite (shift buf (35 + slen)) with
     | Some x, buf' -> (x, buf')
     | None  , _    -> raise_unknown "ciphersuite"
@@ -577,14 +576,14 @@ let parse_server_hello buf =
 
 let parse_certificates_exn buf =
   let parsef buf =
-    let len = get_uint24_len buf in
-    (Some (sub buf 3 len), shift buf (len + 3))
+    let len = get_uint24_len ~off:0 buf in
+    (Some (String.sub buf 3 len), shift buf (len + 3))
   in
-  let len = get_uint24_len buf in
+  let len = get_uint24_len ~off:0 buf in
   if String.length buf <> len + 3 then
     raise_trailing_bytes "certificates"
   else
-    parse_list parsef (sub buf 3 len) []
+    parse_list parsef (String.sub buf 3 len) []
 
 let parse_certificates = catch @@ parse_certificates_exn
 
@@ -592,18 +591,18 @@ let parse_certificates = catch @@ parse_certificates_exn
 let parse_certificate_ext _ = None, ""
 
 let parse_certificate_ext_1_3_exn buf =
-  let certlen = get_uint24_len buf in
+  let certlen = get_uint24_len ~off:0 buf in
   let cert, extbuf, rest =
-    let cert, rt = split (shift buf 3) certlen in
+    let cert, rt = split_str ~start:3 buf certlen in
     let ext_len = String.get_uint16_be rt 0 in
-    let extbuf, rt = split (shift rt 2) ext_len in
+    let extbuf, rt = split_str ~start:2 rt ext_len in
     cert, extbuf, rt
   in
   let exts = parse_list parse_certificate_ext extbuf [] in
   (Some (cert, exts), rest)
 
 let parse_certificate_ext_list_1_3_exn buf =
-  let len = get_uint24_len buf in
+  let len = get_uint24_len ~off:0 buf in
   if String.length buf <> len + 3 then
     raise_trailing_bytes "certificates"
   else
@@ -611,7 +610,7 @@ let parse_certificate_ext_list_1_3_exn buf =
 
 let parse_certificates_1_3_exn buf =
   let clen = String.get_uint8 buf 0 in
-  let context, rt = split (shift buf 1) clen in
+  let context, rt = split_str ~start:1 buf clen in
   let certs = parse_certificate_ext_list_1_3_exn rt in
   (context, certs)
 
@@ -628,11 +627,11 @@ let parse_certificate_types buf =
 let parse_cas buf =
   let parsef buf =
     let length = String.get_uint16_be buf 0 in
-    let name = sub buf 2 length in
+    let name = String.sub buf 2 length in
     (Some name, shift buf (2 + length))
   in
   let calength = String.get_uint16_be buf 0 in
-  let cas, rt = split (shift buf 2) calength in
+  let cas, rt = split_str ~start:2 buf calength in
   (parse_list parsef cas [], rt)
 
 let parse_certificate_request_exn buf =
@@ -689,7 +688,7 @@ let parse_certificate_request_1_3_exn buf =
     if contextlen = 0 then
       None, shift buf 1
     else
-      let ctx, rest = split (shift buf 1) contextlen in
+      let ctx, rest = split_str ~start:1 buf contextlen in
       Some ctx, rest
   in
   let exts = parse_extensions parse_certificate_request_extension rt in
@@ -700,15 +699,15 @@ let parse_certificate_request_1_3 =
 
 let parse_dh_parameters = catch @@ fun raw ->
   let plength = String.get_uint16_be raw 0 in
-  let dh_p = sub raw 2 plength in
+  let dh_p = String.sub raw 2 plength in
   let buf = shift raw (2 + plength) in
   let glength = String.get_uint16_be buf 0 in
-  let dh_g = sub buf 2 glength in
+  let dh_g = String.sub buf 2 glength in
   let buf = shift buf (2 + glength) in
   let yslength = String.get_uint16_be buf 0 in
-  let dh_Ys = sub buf 2 yslength in
+  let dh_Ys = String.sub buf 2 yslength in
   let buf = shift buf (2 + yslength) in
-  let rawparams = sub raw 0 (plength + glength + yslength + 6) in
+  let rawparams = String.sub raw 0 (plength + glength + yslength + 6) in
   ({ dh_p ; dh_g ; dh_Ys }, rawparams, buf)
 
 let parse_ec_parameters = catch @@ fun raw ->
@@ -720,8 +719,8 @@ let parse_ec_parameters = catch @@ fun raw ->
       begin match named_group_to_group g with
         | Some ((`X25519 | `P256 | `P384 | `P521) as g) ->
           let data_len = String.get_uint8 raw 3 in
-          let d, rest = split (shift raw 4) data_len in
-          g, d, sub raw 0 (data_len + 4), rest
+          let d, rest = split_str ~start:4 raw data_len in
+          g, d, String.sub raw 0 (data_len + 4), rest
         | _ -> raise_unknown "EC group"
       end
     | None -> raise_unknown "EC named group"
@@ -731,7 +730,7 @@ let parse_digitally_signed_exn buf =
   if String.length buf <> siglen + 2 then
     raise_trailing_bytes "digitally signed"
   else
-    sub buf 2 siglen
+    String.sub buf 2 siglen
 
 let parse_digitally_signed =
   catch parse_digitally_signed_exn
@@ -761,9 +760,9 @@ let parse_session_ticket buf =
   and age_add = String.get_int32_be buf 4
   and nonce_len = String.get_uint8 buf 8
   in
-  let nonce = sub buf 9 nonce_len in
+  let nonce = String.sub buf 9 nonce_len in
   let ticket_len = String.get_uint16_be buf (9 + nonce_len) in
-  let ticket, exts_buf = split (shift buf (11 + nonce_len)) ticket_len in
+  let ticket, exts_buf = split_str ~start:(11 + nonce_len) buf ticket_len in
   let extensions = parse_extensions parse_session_ticket_extension exts_buf in
   { lifetime ; age_add ; nonce ; ticket ; extensions }
 
@@ -772,7 +771,7 @@ let parse_client_dh_key_exchange_exn buf =
   if String.length buf <> len + 2 then
     raise_trailing_bytes "client key exchange"
   else
-    sub buf 2 len
+    String.sub buf 2 len
 
 let parse_client_dh_key_exchange = catch parse_client_dh_key_exchange_exn
 
@@ -781,7 +780,7 @@ let parse_client_ec_key_exchange_exn buf =
   if String.length buf <> len + 1 then
     raise_trailing_bytes "client key exchange"
   else
-    sub buf 1 len
+    String.sub buf 1 len
 
 let parse_client_ec_key_exchange = catch parse_client_ec_key_exchange_exn
 
diff --git a/lib/writer.ml b/lib/writer.ml
index 713bc7a2..ab0cbafd 100644
--- a/lib/writer.ml
+++ b/lib/writer.ml
@@ -1,29 +1,32 @@
 open Packet
 open Core
 
-let assemble_protocol_version_int buf version =
+let assemble_protocol_version_int buf off version =
   let major, minor = pair_of_tls_version version in
-  set_uint8 buf 0 major;
-  set_uint8 buf 1 minor
+  Bytes.set_uint8 buf off major;
+  Bytes.set_uint8 buf (off + 1) minor
 
 let assemble_protocol_version version =
-  let buf = create 2 in
-  assemble_protocol_version_int buf version;
-  buf
+  let buf = Bytes.create 2 in
+  assemble_protocol_version_int buf 0 version;
+  Bytes.unsafe_to_string buf
 
-let assemble_any_protocol_version version =
-  let buf = create 2 in
+let assemble_any_protocol_version_into buf off version =
   let major, minor = pair_of_tls_any_version version in
-  set_uint8 buf 0 major ;
-  set_uint8 buf 1 minor ;
-  buf
+  Bytes.set_uint8 buf off major;
+  Bytes.set_uint8 buf (off + 1) minor
+
+let assemble_any_protocol_version version =
+  let buf = Bytes.create 2 in
+  assemble_any_protocol_version_into buf 0 version;
+  Bytes.unsafe_to_string buf
 
 let assemble_hdr version (content_type, payload) =
-  let buf = create 5 in
-  set_uint8 buf 0 (content_type_to_int content_type);
-  assemble_protocol_version_int (shift buf 1) version;
-  BE.set_uint16 buf 3 (length payload);
-  buf <+> payload
+  let buf = Bytes.create 5 in
+  Bytes.set_uint8 buf 0 (content_type_to_int content_type);
+  assemble_protocol_version_int buf 1 version;
+  Bytes.set_uint16_be buf 3 (String.length payload);
+  Bytes.unsafe_to_string buf ^ payload
 
 type len = One | Two | Three
 
@@ -31,50 +34,48 @@ let assemble_list ?none_if_empty lenb f elements =
   let length body =
     match lenb with
     | One   ->
-       let l = create 1 in
-       set_uint8 l 0 (length body) ;
-       l
+       let l = Bytes.create 1 in
+       Bytes.set_uint8 l 0 (String.length body) ;
+       Bytes.unsafe_to_string l
     | Two   ->
-       let l = create 2 in
-       BE.set_uint16 l 0 (length body) ;
-       l
+       let l = Bytes.create 2 in
+       Bytes.set_uint16_be l 0 (String.length body) ;
+       Bytes.unsafe_to_string l
     | Three ->
-       let l = create 3 in
-       set_uint24_len l (length body) ;
-       l
+       let l = Bytes.create 3 in
+       set_uint24_len ~off:0 l (String.length body) ;
+       Bytes.unsafe_to_string l
   in
-  let b es = Cstruct.concat (List.map f es) in
+  let b es = String.concat "" (List.map f es) in
   let full es =
     let body = b es in
-    length body <+> body
+    length body ^ body
   in
   match none_if_empty with
   | Some _ -> (match elements with
-               | []   -> create 0
+               | []   -> ""
                | eles -> full eles)
   | None   -> full elements
 
 let assemble_certificate c =
-  let length = length c in
-  let buf = create 3 in
-  set_uint24_len buf length;
-  buf <+> c
+  let length = String.length c in
+  let buf = Bytes.create 3 in
+  set_uint24_len ~off:0 buf length;
+  Bytes.unsafe_to_string buf ^ c
 
 let assemble_certificates cs =
   assemble_list Three assemble_certificate cs
 
 let assemble_compression_method m =
-  let buf = create 1 in
-  set_uint8 buf 0 (compression_method_to_int m);
-  buf
+  String.make 1 (Char.unsafe_chr (compression_method_to_int m))
 
 let assemble_compression_methods ms =
   assemble_list One assemble_compression_method ms
 
 let assemble_any_ciphersuite c =
-  let buf = create 2 in
-  BE.set_uint16 buf 0 (any_ciphersuite_to_int c);
-  buf
+  let buf = Bytes.create 2 in
+  Bytes.set_uint16_be buf 0 (any_ciphersuite_to_int c);
+  Bytes.unsafe_to_string buf
 
 let assemble_any_ciphersuites cs =
   assemble_list Two assemble_any_ciphersuite cs
@@ -87,50 +88,50 @@ let assemble_hostname host =
   let host = Domain_name.to_string host in
   (* 8 bit hostname type; 16 bit length; value *)
   let vallength = String.length host in
-  let buf = create 3 in
-  set_uint8 buf 0 0; (* type, only 0 registered *)
-  BE.set_uint16 buf 1 vallength;
-  buf <+> (of_string host)
+  let buf = Bytes.create 3 in
+  Bytes.set_uint8 buf 0 0; (* type, only 0 registered *)
+  Bytes.set_uint16_be buf 1 vallength;
+  Bytes.unsafe_to_string buf ^ host
 
 let assemble_hostnames hosts =
   assemble_list Two assemble_hostname hosts
 
 let assemble_hash_signature sigalg =
-  let buf = create 2 in
-  BE.set_uint16 buf 0 (signature_alg_to_int (to_signature_alg sigalg)) ;
-  buf
+  let buf = Bytes.create 2 in
+  Bytes.set_uint16_be buf 0 (signature_alg_to_int (to_signature_alg sigalg)) ;
+  Bytes.unsafe_to_string buf
 
 let assemble_signature_algorithms s =
   assemble_list Two assemble_hash_signature s
 
 let assemble_certificate_types ts =
   let ass x =
-    let buf = create 1 in
-    set_uint8 buf 0 (client_certificate_type_to_int x) ;
-    buf
+    String.make 1 (Char.unsafe_chr (client_certificate_type_to_int x))
   in
   assemble_list One ass ts
 
 let assemble_cas cas =
   let ass x =
-    let buf = create 2 in
-    BE.set_uint16 buf 0 (length x) ;
-    buf <+> x
+    let buf = Bytes.create 2 in
+    Bytes.set_uint16_be buf 0 (String.length x) ;
+    Bytes.unsafe_to_string buf ^ x
   in
   assemble_list Two ass cas
 
 let assemble_certificate_request ts cas =
-  assemble_certificate_types ts <+> assemble_cas cas
+  assemble_certificate_types ts ^ assemble_cas cas
 
 let assemble_certificate_request_1_2 ts sigalgs cas =
-  assemble_certificate_types ts <+>
-    assemble_signature_algorithms sigalgs <+>
+  String.concat "" [
+    assemble_certificate_types ts;
+    assemble_signature_algorithms sigalgs;
     assemble_cas cas
+  ]
 
 let assemble_named_group g =
-  let buf = create 2 in
-  BE.set_uint16 buf 0 (named_group_to_int g);
-  buf
+  let buf = Bytes.create 2 in
+  Bytes.set_uint16_be buf 0 (named_group_to_int g);
+  Bytes.unsafe_to_string buf
 
 let assemble_group g =
   assemble_named_group (group_to_named_group g)
@@ -140,32 +141,30 @@ let assemble_supported_groups groups =
 
 let assemble_keyshare_entry (ng, ks) =
   let g = assemble_named_group ng in
-  let l = create 2 in
-  BE.set_uint16 l 0 (length ks) ;
-  g <+> l <+> ks
+  let l = Bytes.create 2 in
+  Bytes.set_uint16_be l 0 (String.length ks) ;
+  String.concat "" [ g ; Bytes.unsafe_to_string l ; ks ]
 
 let assemble_psk_id (id, age) =
-  let id_len = create 2 in
-  BE.set_uint16 id_len 0 (length id) ;
-  let age_buf = create 4 in
-  BE.set_uint32 age_buf 0 age ;
-  id_len <+> id <+> age_buf
+  let id_len = Bytes.create 2 in
+  Bytes.set_uint16_be id_len 0 (String.length id) ;
+  let age_buf = Bytes.create 4 in
+  Bytes.set_int32_be age_buf 0 age ;
+  String.concat "" [ Bytes.unsafe_to_string id_len ; id ; Bytes.unsafe_to_string age_buf ]
 
 let assemble_binder b =
-  let b_len = create 1 in
-  set_uint8 b_len 0 (length b) ;
-  b_len <+> b
+  let b_len = String.make 1 (Char.unsafe_chr (String.length b)) in
+  b_len ^ b
 
 let assemble_client_psks psks =
   let ids, binders = List.split psks in
   let ids_buf = assemble_list Two assemble_psk_id ids in
   let binders_buf = assemble_list Two assemble_binder binders in
-  ids_buf <+> binders_buf
+  ids_buf ^ binders_buf
 
 let assemble_alpn_protocol p =
-  let buf = create 1 in
-  set_uint8 buf 0 (String.length p) ;
-  buf <+> Cstruct.of_string p
+  let buf = String.make 1 (Char.unsafe_chr (String.length p)) in
+  buf ^ p
 
 let assemble_alpn_protocols protocols =
   assemble_list Two assemble_alpn_protocol protocols
@@ -175,44 +174,41 @@ let assemble_supported_versions vs =
 
 let assemble_extension = function
   | `SecureRenegotiation x ->
-     let buf = create 1 in
-     set_uint8 buf 0 (length x);
-     (buf <+> x, RENEGOTIATION_INFO)
-  | `ExtendedMasterSecret -> (create 0, EXTENDED_MASTER_SECRET)
+     let buf = String.make 1 (Char.unsafe_chr (String.length x)) in
+     (buf ^ x, RENEGOTIATION_INFO)
+  | `ExtendedMasterSecret -> ("", EXTENDED_MASTER_SECRET)
   | `ECPointFormats ->
     (* a list of point formats, we support type 0 = uncompressed unconditionally *)
-    let data = Cstruct.create 2 in
-    Cstruct.set_uint8 data 0 1;
-    (data, EC_POINT_FORMATS)
+    let data = Bytes.make 2 '\x00' in
+    Bytes.set_uint8 data 0 1;
+    (Bytes.unsafe_to_string data, EC_POINT_FORMATS)
   | _ -> invalid_arg "unknown extension"
 
 let assemble_cookie c =
-  let l = create 2 in
-  BE.set_uint16 l 0 (length c) ;
-  l <+> c
+  let l = Bytes.create 2 in
+  Bytes.set_uint16_be l 0 (String.length c) ;
+  Bytes.unsafe_to_string l ^ c
 
 let assemble_psk_key_exchange_mode mode =
-  let c = create 1 in
-  set_uint8 c 0 (psk_key_exchange_mode_to_int mode) ;
-  c
+  String.make 1 (Char.unsafe_chr (psk_key_exchange_mode_to_int mode))
 
 let assemble_psk_key_exchange_modes modes =
   assemble_list One assemble_psk_key_exchange_mode modes
 
 let assemble_ext (pay, typ) =
-  let buf = Cstruct.create 4 in
-  BE.set_uint16 buf 0 (extension_type_to_int typ);
-  BE.set_uint16 buf 2 (length pay);
-  buf <+> pay
+  let buf = Bytes.create 4 in
+  Bytes.set_uint16_be buf 0 (extension_type_to_int typ);
+  Bytes.set_uint16_be buf 2 (String.length pay);
+  Bytes.unsafe_to_string buf ^ pay
 
 let assemble_extensions ?none_if_empty assemble_e es =
   assemble_list ?none_if_empty Two assemble_e es
 
 let assemble_ca ca =
-  let lenbuf = create 2 in
+  let lenbuf = Bytes.create 2 in
   let data = X509.Distinguished_name.encode_der ca in
-  BE.set_uint16 lenbuf 0 (length data) ;
-  lenbuf <+> data
+  Bytes.set_uint16_be lenbuf 0 (String.length data) ;
+  Bytes.unsafe_to_string lenbuf ^ data
 
 let assemble_certificate_authorities cas =
   assemble_list Two assemble_ca cas
@@ -225,18 +221,17 @@ let assemble_certificate_request_extension e =
     (assemble_certificate_authorities cas, CERTIFICATE_AUTHORITIES)
   | _ -> invalid_arg "unknown extension"
 
-let assemble_certificate_request_1_3 ?(context = Cstruct.empty) exts =
-  let clen = create 1 in
-  set_uint8 clen 0 (length context) ;
+let assemble_certificate_request_1_3 ?(context = "") exts =
+  let clen = String.make 1 (Char.unsafe_chr (String.length context)) in
   let exts = assemble_extensions assemble_certificate_request_extension exts in
-  clen <+> context <+> exts
+  String.concat "" [ clen ; context ; exts ]
 
 let assemble_client_extension e =
   assemble_ext @@ match e with
     | `SupportedGroups groups ->
       (assemble_supported_groups groups, SUPPORTED_GROUPS)
     | `Hostname name -> (assemble_hostnames [name], SERVER_NAME)
-    | `Padding x -> (create x, PADDING)
+    | `Padding x -> (String.make x '\x00', PADDING)
     | `SignatureAlgorithms s ->
       (assemble_signature_algorithms s, SIGNATURE_ALGORITHMS)
     | `ALPN protocols ->
@@ -246,11 +241,11 @@ let assemble_client_extension e =
     | `PreSharedKeys ids ->
       (assemble_client_psks ids, PRE_SHARED_KEY)
     | `EarlyDataIndication ->
-      (create 0, EARLY_DATA)
+      ("", EARLY_DATA)
     | `SupportedVersions vs ->
       (assemble_supported_versions vs, SUPPORTED_VERSIONS)
     | `PostHandshakeAuthentication ->
-      (Cstruct.empty, POST_HANDSHAKE_AUTH)
+      ("", POST_HANDSHAKE_AUTH)
     | `Cookie c ->
       (assemble_cookie c, COOKIE)
     | `PskKeyExchangeModes modes ->
@@ -259,27 +254,27 @@ let assemble_client_extension e =
 
 let assemble_server_extension e =
   assemble_ext @@ match e with
-    | `Hostname -> (create 0, SERVER_NAME)
+    | `Hostname -> ("", SERVER_NAME)
     | `ALPN protocol ->
       (assemble_alpn_protocols [protocol], APPLICATION_LAYER_PROTOCOL_NEGOTIATION)
     | `KeyShare (g, ks) ->
       let ng = group_to_named_group g in
       (assemble_keyshare_entry (ng, ks), KEY_SHARE)
     | `PreSharedKey id ->
-      let data = create 2 in
-      BE.set_uint16 data 0 id ;
-      (data, PRE_SHARED_KEY)
+      let data = Bytes.create 2 in
+      Bytes.set_uint16_be data 0 id ;
+      (Bytes.unsafe_to_string data, PRE_SHARED_KEY)
     | `SelectedVersion v -> (assemble_protocol_version v, SUPPORTED_VERSIONS)
     | x -> assemble_extension x
 
 let assemble_encrypted_extension e =
   assemble_ext @@ match e with
-    | `Hostname -> (create 0, SERVER_NAME)
+    | `Hostname -> ("", SERVER_NAME)
     | `ALPN protocol ->
       (assemble_alpn_protocols [protocol], APPLICATION_LAYER_PROTOCOL_NEGOTIATION)
     | `SupportedGroups groups ->
       (assemble_supported_groups (List.map group_to_named_group groups), SUPPORTED_GROUPS)
-    | `EarlyDataIndication -> (create 0, EARLY_DATA)
+    | `EarlyDataIndication -> ("", EARLY_DATA)
     | _ -> invalid_arg "unknown extension"
 
 let assemble_retry_extension e =
@@ -293,23 +288,21 @@ let assemble_cert_ext (certificate, extensions) =
   let cert = assemble_certificate certificate
   and exts = assemble_list Two assemble_server_extension extensions
   in
-  cert <+> exts
+  cert ^ exts
 
 let assemble_certs_exts cs =
   assemble_list Three assemble_cert_ext cs
 
 let assemble_certificates_1_3 context certs =
-  let l = create 1 in
-  set_uint8 l 0 (length context) ;
-  l <+> context <+> assemble_certs_exts (List.map (fun c -> c, []) certs)
+  let l = String.make 1 (Char.unsafe_chr (String.length context)) in
+  String.concat "" [ l ; context ; assemble_certs_exts (List.map (fun c -> c, []) certs) ]
 
 let assemble_sid sid =
-  let buf = create 1 in
   match sid with
-  | None   -> buf
-  | Some s -> set_uint8 buf 0 (length s); buf <+> s
+  | None   -> String.make 1 '\x00'
+  | Some s -> String.make 1 (Char.unsafe_chr (String.length s)) ^ s
 
-let assemble_client_hello (cl : client_hello) : Cstruct.t =
+let assemble_client_hello (cl : client_hello) : string =
   let version = match cl.client_version with
     | `TLS_1_3 -> `TLS_1_2 (* keep 0x03 0x03 on wire *)
     | x -> x
@@ -319,7 +312,7 @@ let assemble_client_hello (cl : client_hello) : Cstruct.t =
   let css = assemble_any_ciphersuites cl.ciphersuites in
   (* compression methods, completely useless *)
   let cms = assemble_compression_methods [NULL] in
-  let bbuf = v <+> cl.client_random <+> sid <+> css <+> cms in
+  let bbuf = String.concat "" [ v ; cl.client_random ; sid ; css ; cms ] in
   let extensions = assemble_extensions ~none_if_empty:true assemble_client_extension cl.extensions in
   (* some widely deployed firewalls drop ClientHello messages which are
      > 256 and < 511 byte, insert PADDING extension for these *)
@@ -340,32 +333,32 @@ let assemble_client_hello (cl : client_hello) : Cstruct.t =
        when it is present. rationale from ietf-tls WG
        "Padding extension and 0-RTT" thread (2016-10-30) *)
     if List.exists (function `PreSharedKeys _ -> true | _ -> false) cl.extensions then
-      Cstruct.empty
+      ""
     else
-      let buflen = length bbuf + length extensions + 4 (* see above, header *) in
+      let buflen = String.length bbuf + String.length extensions + 4 (* see above, header *) in
       if buflen >= 256 && buflen <= 511 then
-        match length extensions with
+        match String.length extensions with
         | 0 -> (* need to construct a 2 byte extension length as well *)
           let l = 512 (* desired length *) - 2 (* extension length *) - 4 (* padding extension header *) - buflen in
           let l = max l 0 in (* negative size is not good *)
           let padding = assemble_client_extension (`Padding l) in
-          let extension_length = create 2 in
-          BE.set_uint16 extension_length 0 (length padding);
-          extension_length <+> padding
+          let extension_length = Bytes.create 2 in
+          Bytes.set_uint16_be extension_length 0 (String.length padding);
+          Bytes.unsafe_to_string extension_length ^ padding
         | _ ->
           let l = 512 - 4 (* padding extension header *) - buflen in
           let l = max l 0 in
           let padding = assemble_client_extension (`Padding l) in
           (* extensions include the 16 bit extension length field *)
-          let elen = length extensions + length padding - 2 (* the 16 bit length field *) in
-          BE.set_uint16 extensions 0 elen;
+          let elen = String.length extensions + String.length padding - 2 (* the 16 bit length field *) in
+          Bytes.set_uint16_be (Bytes.unsafe_of_string extensions) 0 elen;
           padding
       else
-        create 0
+        ""
   in
-  bbuf <+> extensions <+> extrapadding
+  String.concat "" [ bbuf ; extensions ; extrapadding ]
 
-let assemble_server_hello (sh : server_hello) : Cstruct.t =
+let assemble_server_hello (sh : server_hello) : string =
   let version, exts = match sh.server_version with
     | `TLS_1_3 -> `TLS_1_2, `SelectedVersion `TLS_1_3 :: sh.extensions
     | x -> x, sh.extensions
@@ -376,66 +369,65 @@ let assemble_server_hello (sh : server_hello) : Cstruct.t =
   (* useless compression method *)
   let cm = assemble_compression_method NULL in
   let extensions = assemble_extensions ~none_if_empty:true assemble_server_extension exts in
-  v <+> sh.server_random <+> sid <+> cs <+> cm <+> extensions
+  String.concat "" [ v ; sh.server_random ; sid ; cs ; cm ; extensions ]
 
 let assemble_dh_parameters p =
-  let plen, glen, yslen = (length p.dh_p, length p.dh_g, length p.dh_Ys) in
-  let buf = create (2 + 2 + 2 + plen + glen + yslen) in
-  BE.set_uint16  buf  0 plen;
-  blit p.dh_p  0 buf  2 plen;
-  BE.set_uint16  buf (2 + plen) glen;
-  blit p.dh_g  0 buf (4 + plen) glen;
-  BE.set_uint16  buf (4 + plen + glen) yslen;
-  blit p.dh_Ys 0 buf (6 + plen + glen) yslen;
-  buf
+  let plen, glen, yslen = (String.length p.dh_p, String.length p.dh_g, String.length p.dh_Ys) in
+  let buf = Bytes.create (2 + 2 + 2 + plen + glen + yslen) in
+  Bytes.set_uint16_be  buf  0 plen;
+  Bytes.blit_string p.dh_p  0 buf  2 plen;
+  Bytes.set_uint16_be  buf (2 + plen) glen;
+  Bytes.blit_string p.dh_g  0 buf (4 + plen) glen;
+  Bytes.set_uint16_be  buf (4 + plen + glen) yslen;
+  Bytes.blit_string p.dh_Ys 0 buf (6 + plen + glen) yslen;
+  Bytes.unsafe_to_string buf
 
 let assemble_ec_parameters named_curve point =
-  let hdr = create 4 in
-  set_uint8 hdr 0 (ec_curve_type_to_int NAMED_CURVE);
-  BE.set_uint16 hdr 1 (named_group_to_int (group_to_named_group named_curve));
-  set_uint8 hdr 3 (length point);
-  hdr <+> point
+  let hdr = Bytes.create 4 in
+  Bytes.set_uint8 hdr 0 (ec_curve_type_to_int NAMED_CURVE);
+  Bytes.set_uint16_be hdr 1 (named_group_to_int (group_to_named_group named_curve));
+  Bytes.set_uint8 hdr 3 (String.length point);
+  Bytes.unsafe_to_string hdr ^ point
 
 let assemble_digitally_signed signature =
-  let lenbuf = create 2 in
-  BE.set_uint16 lenbuf 0 (length signature);
-  lenbuf <+> signature
+  let lenbuf = Bytes.create 2 in
+  Bytes.set_uint16_be lenbuf 0 (String.length signature);
+  Bytes.unsafe_to_string lenbuf ^ signature
 
 let assemble_digitally_signed_1_2 sigalg signature =
-  (assemble_hash_signature sigalg) <+>
-    (assemble_digitally_signed signature)
+  (assemble_hash_signature sigalg) ^ (assemble_digitally_signed signature)
 
 let assemble_session_ticket_extension e =
   assemble_ext @@ match e with
   | `EarlyDataIndication max ->
-    let buf = create 4 in
-    BE.set_uint32 buf 0 max ;
-    (buf, EARLY_DATA)
+    let buf = Bytes.create 4 in
+    Bytes.set_int32_be buf 0 max ;
+    (Bytes.unsafe_to_string buf, EARLY_DATA)
   | _ -> invalid_arg "unknown extension"
 
 let assemble_session_ticket (se : session_ticket) =
-  let buf = create 9 in
-  BE.set_uint32 buf 0 se.lifetime ;
-  BE.set_uint32 buf 4 se.age_add ;
-  set_uint8 buf 8 (length se.nonce) ;
-  let ticketlen = create 2 in
-  BE.set_uint16 ticketlen 0 (length se.ticket) ;
+  let buf = Bytes.create 9 in
+  Bytes.set_int32_be buf 0 se.lifetime ;
+  Bytes.set_int32_be buf 4 se.age_add ;
+  Bytes.set_uint8 buf 8 (String.length se.nonce) ;
+  let ticketlen = Bytes.create 2 in
+  Bytes.set_uint16_be ticketlen 0 (String.length se.ticket) ;
   let exts = assemble_extensions assemble_session_ticket_extension se.extensions in
-  buf <+> se.nonce <+> ticketlen <+> se.ticket <+> exts
+  String.concat "" [ Bytes.unsafe_to_string buf ; se.nonce ; Bytes.unsafe_to_string ticketlen ; se.ticket ; exts ]
 
 let assemble_client_dh_key_exchange kex =
-  let len = length kex in
-  let buf = create (len + 2) in
-  BE.set_uint16 buf 0 len;
-  blit kex 0 buf 2 len;
-  buf
+  let len = String.length kex in
+  let buf = Bytes.create (len + 2) in
+  Bytes.set_uint16_be buf 0 len;
+  Bytes.blit_string kex 0 buf 2 len;
+  Bytes.unsafe_to_string buf
 
 let assemble_client_ec_key_exchange kex =
-  let len = length kex in
-  let buf = create (len + 1) in
-  set_uint8 buf 0 len;
-  blit kex 0 buf 1 len;
-  buf
+  let len = String.length kex in
+  let buf = Bytes.create (len + 1) in
+  Bytes.set_uint8 buf 0 len;
+  Bytes.blit_string kex 0 buf 1 len;
+  Bytes.unsafe_to_string buf
 
 let assemble_hello_retry_request hrr =
   let exts = `SelectedGroup hrr.selected_group :: hrr.extensions in
@@ -447,23 +439,21 @@ let assemble_hello_retry_request hrr =
   let sid = assemble_sid hrr.sessionid in
   let cs = assemble_ciphersuite (hrr.ciphersuite :> Ciphersuite.ciphersuite) in
   (* useless compression method *)
-  let cm = create 1 in
+  let cm = String.make 1 '\x00' in
   let extensions = assemble_extensions ~none_if_empty:true assemble_retry_extension exts in
-  v <+> helloretryrequest <+> sid <+> cs <+> cm <+> extensions
+  String.concat "" [ v ; helloretryrequest ; sid ; cs ; cm ; extensions ]
 
 let assemble_hs typ len =
-  let buf = create 4 in
-  set_uint8 buf 0 (handshake_type_to_int typ);
-  set_uint24_len (shift buf 1) len;
-  buf
+  let buf = Bytes.create 4 in
+  Bytes.set_uint8 buf 0 (handshake_type_to_int typ);
+  set_uint24_len ~off:1 buf len;
+  Bytes.unsafe_to_string buf
 
 let assemble_message_hash len =
   assemble_hs MESSAGE_HASH len
 
 let assemble_key_update req =
-  let cs = create 1 in
-  set_uint8 cs 0 (key_update_request_type_to_int req);
-  cs
+  String.make 1 (Char.unsafe_chr (key_update_request_type_to_int req))
 
 let assemble_handshake hs =
   let (payload, payload_type) =
@@ -476,8 +466,8 @@ let assemble_handshake hs =
     | CertificateVerify c -> (c, CERTIFICATE_VERIFY)
     | ServerKeyExchange kex -> (kex, SERVER_KEY_EXCHANGE)
     | ClientKeyExchange kex -> (kex, CLIENT_KEY_EXCHANGE)
-    | ServerHelloDone -> (create 0, SERVER_HELLO_DONE)
-    | HelloRequest -> (create 0, HELLO_REQUEST)
+    | ServerHelloDone -> ("", SERVER_HELLO_DONE)
+    | HelloRequest -> ("", HELLO_REQUEST)
     | Finished fs -> (fs, FINISHED)
     | SessionTicket st -> (assemble_session_ticket st, SESSION_TICKET)
     | EncryptedExtensions ee ->
@@ -486,19 +476,17 @@ let assemble_handshake hs =
     | KeyUpdate req ->
       let cs = assemble_key_update req in
       (cs, KEY_UPDATE)
-    | EndOfEarlyData -> (create 0, END_OF_EARLY_DATA)
+    | EndOfEarlyData -> ("", END_OF_EARLY_DATA)
   in
-  let pay_len = length payload in
+  let pay_len = String.length payload in
   let buf = assemble_hs payload_type pay_len in
-  buf <+> payload
+  buf ^ payload
 
 let assemble_alert ?(level = Packet.FATAL) typ =
-  let buf = create 2 in
-  set_uint8 buf 1 (alert_type_to_int typ);
-  set_uint8 buf 0 (alert_level_to_int level) ;
-  buf
+  let buf = Bytes.create 2 in
+  Bytes.set_uint8 buf 1 (alert_type_to_int typ);
+  Bytes.set_uint8 buf 0 (alert_level_to_int level) ;
+  Bytes.unsafe_to_string buf
 
 let assemble_change_cipher_spec =
-  let ccs = create 1 in
-  set_uint8 ccs 0 1;
-  ccs
+  String.make 1 '\x01'
diff --git a/tests/dune b/tests/dune
index 14566e33..6cf9967f 100644
--- a/tests/dune
+++ b/tests/dune
@@ -1,14 +1,14 @@
 (library
  (name testlib)
  (modules testlib)
- (libraries tls ounit2 cstruct-unix mirage-crypto-rng.unix)
+ (libraries tls ounit2 mirage-crypto-rng.unix)
  (optional))
 
 (test
  (name unittestrunner)
  (package tls)
  (modules readertests readerwritertests writertests unittests unittestrunner)
- (libraries tls ounit2 cstruct-unix testlib))
+ (libraries tls ounit2 testlib))
 
 (test
  (name key_derivation)
diff --git a/tests/key_derivation.ml b/tests/key_derivation.ml
index a0a0e4c2..bc9c11af 100644
--- a/tests/key_derivation.ml
+++ b/tests/key_derivation.ml
@@ -1,12 +1,12 @@
 (* key derivation example trace taken from draft-ietf-tls-tls13-vectors-07 *)
 let cs =
   let module M = struct
-    type t = Cstruct.t
-    let pp = Cstruct.hexdump_pp
-    let equal = Cstruct.equal
+    type t = string
+    let pp = Ohex.pp_hexdump ()
+    let equal = String.equal
   end in (module M : Alcotest.TESTABLE with type t = M.t)
 
-let secret0 = Cstruct.of_hex {|
+let secret0 = Ohex.decode {|
 33 ad 0a 1c 60 7e c0 3b  09 e6 cd 98 93 68 0c e2
 10 ad f3 00 aa 1f 26 60  e1 b2 2e 10 f1 70 f9 2a
 |}
@@ -18,32 +18,33 @@ let my_secret = ref None
 
 let extract_secret_early () =
   (* draft-ietf-tls-tls13-vectors-07 Sec 3*)
-  let salt = Cstruct.empty
-  and ikm = Cstruct.create 32
+  let salt = ""
+  and ikm = String.make 32 '\x00'
   in
   Alcotest.check cs __LOC__ secret0 (Hkdf.extract ~hash ~salt ikm) ;
   let t = Tls.Handshake_crypto13.(derive (empty cipher) ikm) in
   my_secret := Some t ;
   Alcotest.check cs __LOC__ secret0 t.secret
 
-let expand0 = Cstruct.of_hex {|
+let expand0 = Ohex.decode {|
 6f 26 15 a1 08 c7 02 c5  67 8f 54 fc 9d ba b6 97
 16 c0 76 18 9c 48 25 0c  eb ea c3 57 6c 36 11 ba
 |}
 
 let derive_hs_secret () =
-  let hash_val = Mirage_crypto.Hash.digest hash Cstruct.empty in
+  let module H = (val Digestif.module_of_hash' hash) in
+  let hash_val = H.(to_raw_string (digest_string "")) in
   Alcotest.check cs __LOC__ expand0
     (Tls.Handshake_crypto13.derive_secret_no_hash hash secret0 ~ctx:hash_val "derived")
 
-let hs_secret = Cstruct.of_hex {|
+let hs_secret = Ohex.decode {|
 1d c8 26 e9 36 06 aa 6f  dc 0a ad c1 2f 74 1b 01
 04 6a a6 b9 9f 69 1e d2  21 a9 f0 ca 04 3f be ac
 |}
 
 (* TODO: ikm should be computed (ECDHE) from the key share in client hello (see
    below), and the private key written in the RFC. *)
-let ikm = Cstruct.of_hex {|
+let ikm = Ohex.decode {|
 8b d4 05 4f b5 5b 9d 63  fd fb ac f9 f0 4b 9f 0d
 35 e6 d6 3f 53 75 63 ef  d4 62 72 90 0f 89 49 2d
 |}
@@ -57,7 +58,7 @@ let extract_handshake () =
     my_secret := Some t' ;
     Alcotest.check cs __LOC__ hs_secret t'.secret
 
-let ch = Cstruct.of_hex {|
+let ch = Ohex.decode {|
 01 00 00 c0 03 03 cb 34  ec b1 e7 81 63 ba 1c 38
 c6 da cb 19 6a 6d ff a2  1a 8d 99 12 ec 18 a2 ef
 62 83 02 4d ec e7 00 00  06 13 01 13 03 13 02 01
@@ -73,7 +74,7 @@ e5 60 e4 bd 43 d2 3d 8e  43 5a 7d ba fe b3 c0 6e
 00 02 40 01
 |}
 
-let sh = Cstruct.of_hex {|
+let sh = Ohex.decode {|
 02 00 00 56 03 03 a6 af  06 a4 12 18 60 dc 5e 6e
 60 24 9c d3 4c 95 93 0c  8a c5 cb 14 34 da c1 55
 77 2e d3 e2 69 28 00 13  01 00 00 2e 00 33 00 24
@@ -82,22 +83,25 @@ f7 c6 72 e1 56 d6 cc 25  3b 83 3d f1 dd 69 b1 b0
 4e 75 1f 0f 00 2b 00 02  03 04
 |}
 
-let c_hs_traffic_secret = Cstruct.of_hex {|
+let c_hs_traffic_secret = Ohex.decode {|
 b3 ed db 12 6e 06 7f 35  a7 80 b3 ab f4 5e 2d 8f
 3b 1a 95 07 38 f5 2e 96  00 74 6a 0e 27 a5 5a 21
 |}
 
-let read_handshake_key = Cstruct.of_hex {|
+let read_handshake_key = Ohex.decode {|
 db fa a6 93 d1 76 2c 5b  66 6a f5 d9 50 25 8d 01
 |}
 
-let read_handshake_iv = Cstruct.of_hex {|
+let read_handshake_iv = Ohex.decode {|
 5b d3 c7 1b 83 6e 0b 76  bb 73 26 5f
 |}
 
 let derive_c_hs_traffic () =
-  let log = Cstruct.append ch sh in
-  let hash_val = Mirage_crypto.Hash.digest hash log in
+  let log = ch ^ sh in
+  let hash_val =
+    let module H = (val Digestif.module_of_hash' hash) in
+    H.(to_raw_string (digest_string log))
+  in
   Alcotest.check cs __LOC__ c_hs_traffic_secret
     (Tls.Handshake_crypto13.derive_secret_no_hash hash hs_secret ~ctx:hash_val "c hs traffic") ;
   match !my_secret with
@@ -115,22 +119,25 @@ let derive_read_handshake_keys () =
   Alcotest.check cs __LOC__ read_handshake_iv
     (Tls.Handshake_crypto13.derive_secret_no_hash hash c_hs_traffic_secret ~length:12 "iv")
 
-let s_hs_traffic_secret = Cstruct.of_hex {|
+let s_hs_traffic_secret = Ohex.decode {|
 b6 7b 7d 69 0c c1 6c 4e  75 e5 42 13 cb 2d 37 b4
 e9 c9 12 bc de d9 10 5d  42 be fd 59 d3 91 ad 38
 |}
 
-let write_handshake_key = Cstruct.of_hex {|
+let write_handshake_key = Ohex.decode {|
 3f ce 51 60 09 c2 17 27  d0 f2 e4 e8 6e e4 03 bc
 |}
 
-let write_handshake_iv = Cstruct.of_hex {|
+let write_handshake_iv = Ohex.decode {|
 5d 31 3e b2 67 12 76 ee  13 00 0b 30
 |}
 
 let derive_s_hs_traffic () =
-  let log = Cstruct.append ch sh in
-  let hash_val = Mirage_crypto.Hash.digest hash log in
+  let log = ch ^ sh in
+  let hash_val =
+    let module H = (val Digestif.module_of_hash' hash) in
+    H.(to_raw_string (digest_string log))
+  in
   Alcotest.check cs __LOC__ s_hs_traffic_secret
     (Tls.Handshake_crypto13.derive_secret_no_hash hash hs_secret ~ctx:hash_val "s hs traffic") ;
   match !my_secret with
@@ -148,23 +155,23 @@ let derive_write_handshake_keys () =
   Alcotest.check cs __LOC__ write_handshake_iv
     (Tls.Handshake_crypto13.derive_secret_no_hash hash s_hs_traffic_secret ~length:12"iv")
 
-let finished_expanded = Cstruct.of_hex {|
+let finished_expanded = Ohex.decode {|
 00 8d 3b 66 f8 16 ea 55  9f 96 b5 37 e8 85 c3 1f
 c0 68 bf 49 2c 65 2f 01  f2 88 a1 d8 cd c1 9f c8
 |}
 
-let finished_key = Cstruct.of_hex {|
+let finished_key = Ohex.decode {|
 9b 9b 14 1d 90 63 37 fb  d2 cb dc e7 1d f4 de da
 4a b4 2c 30 95 72 cb 7f  ff ee 54 54 b7 8f 07 18
 |}
 
-let enc_ext = Cstruct.of_hex {|
+let enc_ext = Ohex.decode {|
 08 00 00 24 00 22 00 0a  00 14 00 12 00 1d 00 17
 00 18 00 19 01 00 01 01  01 02 01 03 01 04 00 1c
 00 02 40 01 00 00 00 00
 |}
 
-let cert = Cstruct.of_hex {|
+let cert = Ohex.decode {|
 0b 00 01 b9 00 00 01 b5  00 01 b0 30 82 01 ac 30
 82 01 15 a0 03 02 01 02  02 01 02 30 0d 06 09 2a
 86 48 86 f7 0d 01 01 0b  05 00 30 0e 31 0c 30 0a
@@ -195,7 +202,7 @@ a8 b2 f7 59 40 9b a3 ea  c9 d9 1d 40 2d cc 0c c8
 f8 96 12 29 ac 91 87 b4  2b 4d e1 00 00
 |}
 
-let cert_verify = Cstruct.of_hex {|
+let cert_verify = Ohex.decode {|
 0f 00 00 84 08 04 00 80  5a 74 7c 5d 88 fa 9b d2
 e5 5a b0 85 a6 10 15 b7  21 1f 82 4c d4 84 14 5a
 b3 ff 52 f1 fd a8 47 7b  0b 7a bc 90 db 78 e2 d3
@@ -208,84 +215,87 @@ d3 be 15 2a 3d a5 04 3e  06 3d da 65 cd f5 ae a2
 |}
 
 let derive_finished () =
-  let log = Cstruct.concat [ ch ; sh ; enc_ext ; cert ; cert_verify ] in
+  let log = String.concat "" [ ch ; sh ; enc_ext ; cert ; cert_verify ] in
   Alcotest.check cs __LOC__ finished_expanded
     (Tls.Handshake_crypto13.derive_secret_no_hash hash s_hs_traffic_secret "finished") ;
-  let hash_val = Mirage_crypto.Hash.digest hash log in
+  let module H = (val Digestif.module_of_hash' hash) in
+  let hash_val = H.(to_raw_string (digest_string log)) in
   Alcotest.check cs __LOC__ finished_key
-    (Mirage_crypto.Hash.mac hash ~key:finished_expanded hash_val) ;
+    H.(to_raw_string (hmac_string ~key:finished_expanded hash_val)) ;
   match !my_secret with
   | None -> Alcotest.fail "expected some secret"
   | Some t ->
-    let s_hs_traffic = Tls.Handshake_crypto13.derive_secret t "s hs traffic" (Cstruct.append ch sh) in
+    let s_hs_traffic = Tls.Handshake_crypto13.derive_secret t "s hs traffic" (ch ^ sh) in
     Alcotest.check cs __LOC__ s_hs_traffic_secret s_hs_traffic ;
     Alcotest.check cs __LOC__ finished_key
       (Tls.Handshake_crypto13.finished t.hash s_hs_traffic log)
 
-let finished = Cstruct.of_hex {|
+let finished = Ohex.decode {|
 14 00 00 20 9b 9b 14 1d  90 63 37 fb d2 cb dc e7
 1d f4 de da 4a b4 2c 30  95 72 cb 7f ff ee 54 54
 b7 8f 07 18
 |}
 
-let master = Cstruct.of_hex {|
+let master = Ohex.decode {|
 43 de 77 e0 c7 77 13 85  9a 94 4d b9 db 25 90 b5
 31 90 a6 5b 3e e2 e4 f1  2d d7 a0 bb 7c e2 54 b4
 |}
 
 let derive_master () =
-  let hash_val = Mirage_crypto.Hash.digest hash Cstruct.empty in
+  let module H = (val Digestif.module_of_hash' hash) in
+  let hash_val = H.(to_raw_string (digest_string "")) in
   Alcotest.check cs __LOC__ master
     (Tls.Handshake_crypto13.derive_secret_no_hash hash hs_secret ~ctx:hash_val "derived")
 
-let master_secret = Cstruct.of_hex {|
+let master_secret = Ohex.decode {|
 18 df 06 84 3d 13 a0 8b  f2 a4 49 84 4c 5f 8a 47
 80 01 bc 4d 4c 62 79 84  d5 a4 1d a8 d0 40 29 19
 |}
 
 let extract_master () =
-  Alcotest.check cs __LOC__ master_secret (Hkdf.extract ~hash ~salt:master (Cstruct.create 32)) ;
+  Alcotest.check cs __LOC__ master_secret (Hkdf.extract ~hash ~salt:master (String.make 32 '\x00')) ;
   match !my_secret with
   | None -> Alcotest.fail "expected my secret"
   | Some t ->
-    let t' = Tls.Handshake_crypto13.derive t (Cstruct.create 32) in
+    let t' = Tls.Handshake_crypto13.derive t (String.make 32 '\x00') in
     my_secret := Some t' ;
     Alcotest.check cs __LOC__ master_secret t'.secret
 
-let c_ap_traffic = Cstruct.of_hex {|
+let c_ap_traffic = Ohex.decode {|
 9e 40 64 6c e7 9a 7f 9d  c0 5a f8 88 9b ce 65 52
 87 5a fa 0b 06 df 00 87  f7 92 eb b7 c1 75 04 a5
 |}
 
-let s_ap_traffic = Cstruct.of_hex {|
+let s_ap_traffic = Ohex.decode {|
 a1 1a f9 f0 55 31 f8 56  ad 47 11 6b 45 a9 50 32
 82 04 b4 f4 4b fb 6b 3a  4b 4f 1f 3f cb 63 16 43
 |}
 
-let exp_master = Cstruct.of_hex {|
+let exp_master = Ohex.decode {|
 fe 22 f8 81 17 6e da 18  eb 8f 44 52 9e 67 92 c5
 0c 9a 3f 89 45 2f 68 d8  ae 31 1b 43 09 d3 cf 50
 |}
 
-let app_write_key = Cstruct.of_hex {|
+let app_write_key = Ohex.decode {|
 9f 02 28 3b 6c 9c 07 ef  c2 6b b9 f2 ac 92 e3 56
 |}
 
-let app_write_iv = Cstruct.of_hex {|
+let app_write_iv = Ohex.decode {|
 cf 78 2b 88 dd 83 54 9a  ad f1 e9 84
 |}
 
-let app_read_key = Cstruct.of_hex {|
+let app_read_key = Ohex.decode {|
 17 42 2d da 59 6e d5 d9  ac d8 90 e3 c6 3f 50 51
 |}
 
-let app_read_iv = Cstruct.of_hex {|
+let app_read_iv = Ohex.decode {|
 5b 78 92 3d ee 08 57 90  33 e5 23 d9
 |}
 
 let derive_traffic_keys () =
-  let log = Cstruct.concat [ ch ; sh ; enc_ext ; cert ; cert_verify ; finished ] in
-  let hash_val = Mirage_crypto.Hash.digest hash log in
+  let log = String.concat "" [ ch ; sh ; enc_ext ; cert ; cert_verify ; finished ] in
+  let module H = (val Digestif.module_of_hash' hash) in
+  let hash_val = H.(to_raw_string (digest_string log)) in
   Alcotest.check cs __LOC__ c_ap_traffic
     (Tls.Handshake_crypto13.derive_secret_no_hash hash master_secret ~ctx:hash_val "c ap traffic") ;
   Alcotest.check cs __LOC__ s_ap_traffic
@@ -318,7 +328,7 @@ let appdata_read () =
   Alcotest.check cs __LOC__ app_read_iv
     (Tls.Handshake_crypto13.derive_secret_no_hash hash c_ap_traffic ~length:12 "iv")
 
-let server_payload = Cstruct.of_hex {|
+let server_payload = Ohex.decode {|
 08 00 00 24 00 22 00 0a  00 14 00 12 00 1d 00 17
 00 18 00 19 01 00 01 01  01 02 01 03 01 04 00 1c
 00 02 40 01 00 00 00 00  0b 00 01 b9 00 00 01 b5
@@ -365,9 +375,9 @@ da 4a b4 2c 30 95 72 cb  7f ff ee 54 54 b7 8f 07
 
 let payload_is_good () =
   Alcotest.check cs __LOC__ server_payload
-    (Cstruct.concat [ enc_ext ; cert ; cert_verify ; finished ])
+    (String.concat "" [ enc_ext ; cert ; cert_verify ; finished ])
 
-let server_payload_processed = Cstruct.of_hex {|
+let server_payload_processed = Ohex.decode {|
 17 03 03 02 a2 d1 ff 33   4a 56 f5 bf f6 59 4a 07
 cc 87 b5 80 23 3f 50 0f  45 e4 89 e7 f3 3a f3 5e
 df 78 69 fc f4 0a a4 0a  a2 b8 ea 73 f8 48 a7 ca
@@ -415,34 +425,34 @@ ed e4 2c 17 19 bf da bf  02 53 fe 51 75 be 89 8e
 
 let processed_payload () =
   let buf =
-    let t = Cstruct.create 1 in
-    Cstruct.set_uint8 t 0 (Tls.Packet.content_type_to_int Tls.Packet.HANDSHAKE) ;
-    Cstruct.append server_payload t
+    let t = String.make 1 (Char.unsafe_chr (Tls.Packet.content_type_to_int Tls.Packet.HANDSHAKE)) in
+    server_payload ^ t
   in
   let nonce = Tls.Crypto.aead_nonce write_handshake_iv 0L in
   let key = Mirage_crypto.Cipher_block.AES.GCM.of_secret write_handshake_key in
-  let adata = Tls.Writer.assemble_hdr `TLS_1_2 (Tls.Packet.APPLICATION_DATA, Cstruct.empty) in
-  Cstruct.BE.set_uint16 adata 3 (17 + Cstruct.length server_payload) ;
+  let adata = Tls.Writer.assemble_hdr `TLS_1_2 (Tls.Packet.APPLICATION_DATA, "") in
+  Bytes.set_uint16_be (Bytes.unsafe_of_string adata) 3 (17 + String.length server_payload) ;
   let res =
     Mirage_crypto.Cipher_block.AES.GCM.authenticate_encrypt ~key ~adata ~nonce buf
   in
   let data = Tls.Writer.assemble_hdr `TLS_1_2 (Tls.Packet.APPLICATION_DATA, res) in
   Alcotest.check cs __LOC__ server_payload_processed data
 
-let c_finished = Cstruct.of_hex {|
+let c_finished = Ohex.decode {|
 14 00 00 20 a8 ec 43 6d  67 76 34 ae 52 5a c1 fc
 eb e1 1a 03 9e c1 76 94  fa c6 e9 85 27 b6 42 f2
 ed d5 ce 61
 |}
 
-let res_master = Cstruct.of_hex {|
+let res_master = Ohex.decode {|
 7d f2 35 f2 03 1d 2a 05  12 87 d0 2b 02 41 b0 bf
 da f8 6c c8 56 23 1f 2d  5a ba 46 c4 34 ec 19 6c
 |}
 
 let resumption () =
-  let log = Cstruct.concat [ ch ; sh ; enc_ext ; cert ; cert_verify ; finished ; c_finished ] in
-  let hash_val = Mirage_crypto.Hash.digest hash log in
+  let log = String.concat "" [ ch ; sh ; enc_ext ; cert ; cert_verify ; finished ; c_finished ] in
+  let module H = (val Digestif.module_of_hash' hash) in
+  let hash_val = H.(to_raw_string (digest_string log)) in
   Alcotest.check cs __LOC__ res_master
     (Tls.Handshake_crypto13.derive_secret_no_hash hash master_secret ~ctx:hash_val "res master") ;
   match !my_secret with
@@ -450,7 +460,7 @@ let resumption () =
   | Some s -> Alcotest.check cs __LOC__ res_master (Tls.Handshake_crypto13.resumption s log)
 
 let private_key =
-  let _modulus = Cstruct.of_hex {|
+  let _modulus = Ohex.decode {|
 b4 bb 49 8f 82 79 30 3d  98 08 36 39 9b 36 c6 98
 8c 0c 68 de 55 e1 bd b8  26 d3 90 1a 24 61 ea fd
 2d e4 9a 91 d0 15 ab bc  9a 95 13 7a ce 6c 1a f1
@@ -460,8 +470,8 @@ e2 2a 5f da 43 08 46 74  80 30 53 0e f0 46 1c 8c
 a9 d9 ef bf ae 8e a6 d1  d0 3e 2b d1 93 ef f0 ab
 9a 80 02 c4 74 28 a6 d3  5a 8d 88 d7 9f 7f 1e 3f
 |}
-  and public_exponent = Cstruct.of_hex "01 00 01"
-  and _private_exponent = Cstruct.of_hex {|
+  and public_exponent = Ohex.decode "01 00 01"
+  and _private_exponent = Ohex.decode {|
 04 de a7 05 d4 3a 6e a7  20 9d d8 07 21 11 a8 3c
 81 e3 22 a5 92 78 b3 34  80 64 1e af 7c 0a 69 85
 b8 e3 1c 44 f6 de 62 e1  b4 c2 30 9f 61 26 e7 7b
@@ -471,55 +481,56 @@ b8 e3 1c 44 f6 de 62 e1  b4 c2 30 9f 61 26 e7 7b
 9f 89 34 92 fc 2a 62 2e  08 97 0a ac 44 1c e4 e0
 c3 08 8d f2 5a e6 79 23  3d f8 a3 bd a2 ff 99 41
 |}
-  and prime1 = Cstruct.of_hex {|
+  and prime1 = Ohex.decode {|
 e4 35 fb 7c c8 37 37 75 6d ac ea 96 ab 7f 59 a2
 cc 10 69 db 7d eb 19 0e 17 e3 3a 53 2b 27 3f 30
 a3 27 aa 0a aa bc 58 cd 67 46 6a f9 84 5f ad c6
 75 fe 09 4a f9 2c 4b d1 f2 c1 bc 33 dd 2e 05 15
 |}
-  and prime2 = Cstruct.of_hex {|
+  and prime2 = Ohex.decode {|
 ca bd 3b c0 e0 43 86 64 c8 d4 cc 9f 99 97 7a 94
 d9 bb fe ad 8e 43 87 0a ba e3 f7 eb 8b 4e 0e ee
 8a f1 d9 b4 71 9b a6 19 6c f2 cb ba ee eb f8 b3
 49 0a fe 9e 9f fa 74 a8 8a a5 1f c6 45 62 93 03
 |}
-  and _exponent1 = Cstruct.of_hex {|
+  and _exponent1 = Ohex.decode {|
 3f 57 34 5c 27 fe 1b 68 7e 6e 76 16 27 b7 8b 1b
 82 64 33 dd 76 0f a0 be a6 a6 ac f3 94 90 aa 1b
 47 cd a4 86 9d 68 f5 84 dd 5b 50 29 bd 32 09 3b
 82 58 66 1f e7 15 02 5e 5d 70 a4 5a 08 d3 d3 19
 |}
-  and _exponent2 = Cstruct.of_hex {|
+  and _exponent2 = Ohex.decode {|
 18 3d a0 13 63 bd 2f 28 85 ca cb dc 99 64 bf 47
 64 f1 51 76 36 f8 64 01 28 6f 71 89 3c 52 cc fe
 40 a6 c2 3d 0d 08 6b 47 c6 fb 10 d8 fd 10 41 e0
 4d ef 7e 9a 40 ce 95 7c 41 77 94 e1 04 12 d1 39
 |}
-  and _coefficient = Cstruct.of_hex {|
+  and _coefficient = Ohex.decode {|
 83 9c a9 a0 85 e4 28 6b 2c 90 e4 66 99 7a 2c 68
 1f 21 33 9a a3 47 78 14 e4 de c1 18 33 05 0e d5
 0d d1 3c c0 38 04 8a 43 c5 9b 2a cc 41 68 89 c0
 37 66 5f e5 af a6 05 96 9f 8c 01 df a5 ca 96 9d
 |}
   in
-  let e = Mirage_crypto_pk.Z_extra.of_cstruct_be public_exponent
-  and p = Mirage_crypto_pk.Z_extra.of_cstruct_be prime1
-  and q = Mirage_crypto_pk.Z_extra.of_cstruct_be prime2
+  let e = Mirage_crypto_pk.Z_extra.of_octets_be public_exponent
+  and p = Mirage_crypto_pk.Z_extra.of_octets_be prime1
+  and q = Mirage_crypto_pk.Z_extra.of_octets_be prime2
   in
   match Mirage_crypto_pk.Rsa.priv_of_primes ~e ~p ~q with
   | Ok p -> p
   | Error (`Msg m) -> invalid_arg m
 
-let log = Cstruct.concat [ ch ; sh ; enc_ext ; cert ]
-and cert = match X509.Certificate.decode_der (Cstruct.sub cert 11 0x01b0) with
+let log = String.concat "" [ ch ; sh ; enc_ext ; cert ]
+and cert = match X509.Certificate.decode_der (String.sub cert 11 0x01b0) with
   | Ok c -> Some c
   | Error _ -> None
 
 let self_signature () =
+  let module H = (val Digestif.module_of_hash' hash) in
   match
     Tls.Handshake_common.signature `TLS_1_3
       ~context_string:"TLS 1.3, server CertificateVerify"
-      (Mirage_crypto.Hash.digest hash log)
+      H.(to_raw_string (digest_string log))
       (Some [ `RSA_PSS_RSAENC_SHA256 ]) [ `RSA_PSS_RSAENC_SHA256 ]
       (`RSA private_key)
   with
@@ -528,7 +539,7 @@ let self_signature () =
     match Tls.Handshake_common.verify_digitally_signed `TLS_1_3
             ~context_string:"TLS 1.3, server CertificateVerify"
              [ `RSA_PSS_RSAENC_SHA256 ] data
-             (Mirage_crypto.Hash.digest hash log) cert
+             H.(to_raw_string (digest_string log)) cert
     with
     | Ok () -> ()
     | Error e -> Alcotest.fail ("self-verification failed " ^ Tls.Engine.string_of_failure e)
@@ -536,34 +547,35 @@ let self_signature () =
 let wire_signature () =
   (* let buf = Writer.assemble_handshake (CertificateVerify data) in
      Alcotest.check cs __LOC__ cert_verify buf *)
+  let module H = (val Digestif.module_of_hash' hash) in
   match Tls.Handshake_common.verify_digitally_signed `TLS_1_3
           ~context_string:"TLS 1.3, server CertificateVerify"
-          [ `RSA_PSS_RSAENC_SHA256 ] (Cstruct.shift cert_verify 4)
-          (Mirage_crypto.Hash.digest hash log) cert
+          [ `RSA_PSS_RSAENC_SHA256 ] (String.sub cert_verify 4 (String.length cert_verify - 4))
+          H.(to_raw_string (digest_string log)) cert
   with
   | Ok () -> ()
   | Error e -> Alcotest.fail ("trace-verification failed " ^ Tls.Engine.string_of_failure e)
 
-let res_secret_00 = Cstruct.of_hex {|
+let res_secret_00 = Ohex.decode {|
 4e cd 0e b6 ec 3b 4d 87  f5 d6 02 8f 92 2c a4 c5
 85 1a 27 7f d4 13 11 c9  e6 2d 2c 94 92 e1 c4 f3
 |}
 
 let res_secret () =
-  let nonce = Cstruct.create 2 in
+  let nonce = String.make 2 '\x00' in
   Alcotest.check cs __LOC__ res_secret_00
     (Tls.Handshake_crypto13.derive_secret_no_hash hash res_master ~ctx:nonce "resumption") ;
   Alcotest.check cs __LOC__ res_secret_00
     (Tls.Handshake_crypto13.res_secret hash res_master nonce)
 
 
-let early_secret1 = Cstruct.of_hex {|
+let early_secret1 = Ohex.decode {|
 9b 21 88 e9 b2 fc 6d 64  d7 1d c3 29 90 0e 20 bb
 41 91 50 00 f6 78 aa 83  9c bb 79 7c b7 d8 33 2c
 |}
 
 let early1 () =
-  let salt = Cstruct.empty
+  let salt = ""
   and ikm = res_secret_00
   in
   Alcotest.check cs __LOC__ early_secret1 (Hkdf.extract ~hash ~salt ikm) ;
@@ -571,7 +583,7 @@ let early1 () =
   my_secret := Some t ;
   Alcotest.check cs __LOC__ early_secret1 t.secret
 
-let ch_res_prefix = Cstruct.of_hex {|
+let ch_res_prefix = Ohex.decode {|
 01 00 01 fc 03 03 1b c3  ce b6 bb e3 9c ff 93 83
 55 b5 a5 0a db 6d b2 1b  7a 6a f6 49 d7 b4 bc 41
 9d 78 76 48 7d 95 00 00  06 13 01 13 03 13 02 01
@@ -605,41 +617,42 @@ be 7f d6 1d 28 27 db 27  9c ce 14 50 77 d4 54 a3
 |}
 
 let binder () =
-  let binder_hash = Cstruct.of_hex "63 22 4b 2e 45 73 f2 d3 45 4c a8 4b 9d 00 9a 04 f6 be 9e 05 71 1a 83 96 47 3a ef a0 1e 92 4a 14" in
-  Alcotest.check cs __LOC__ binder_hash (Mirage_crypto.Hash.digest hash ch_res_prefix) ;
+  let module H = (val Digestif.module_of_hash' hash) in
+  let binder_hash = Ohex.decode "63 22 4b 2e 45 73 f2 d3 45 4c a8 4b 9d 00 9a 04 f6 be 9e 05 71 1a 83 96 47 3a ef a0 1e 92 4a 14" in
+  Alcotest.check cs __LOC__ binder_hash H.(to_raw_string (digest_string ch_res_prefix)) ;
   match !my_secret with
   | None -> Alcotest.fail "expected secret"
   | Some s ->
-    let prk = Cstruct.of_hex "69 fe 13 1a 3b ba d5 d6 3c 64 ee bc c3 0e 39 5b 9d 81 07 72 6a 13 d0 74 e3 89 db c8 a4 e4 72 56" in
-    Alcotest.check cs __LOC__ prk (Tls.Handshake_crypto13.derive_secret s "res binder" Cstruct.empty) ;
-    let finished = Cstruct.of_hex "3a dd 4f b2 d8 fd f8 22 a0 ca 3c f7 67 8e f5 e8 8d ae 99 01 41 c5 92 4d 57 bb 6f a3 1b 9e 5f 9d" in
+    let prk = Ohex.decode "69 fe 13 1a 3b ba d5 d6 3c 64 ee bc c3 0e 39 5b 9d 81 07 72 6a 13 d0 74 e3 89 db c8 a4 e4 72 56" in
+    Alcotest.check cs __LOC__ prk (Tls.Handshake_crypto13.derive_secret s "res binder" "") ;
+    let finished = Ohex.decode "3a dd 4f b2 d8 fd f8 22 a0 ca 3c f7 67 8e f5 e8 8d ae 99 01 41 c5 92 4d 57 bb 6f a3 1b 9e 5f 9d" in
     Alcotest.check cs __LOC__ finished (Tls.Handshake_crypto13.finished hash prk ch_res_prefix)
 
 let x25519 () =
-  let c_priv = Cstruct.of_hex {|
+  let c_priv = Ohex.decode {|
 49 af 42 ba 7f 79 94 85  2d 71 3e f2 78 4b cb ca
 a7 91 1d e2 6a dc 56 42  cb 63 45 40 e7 ea 50 05
 |}
-  and c_keyshare = Cstruct.of_hex {|
+  and c_keyshare = Ohex.decode {|
 99 38 1d e5 60 e4 bd 43  d2 3d 8e 43 5a 7d ba fe
 b3 c0 6e 51 c1 3c ae 4d  54 13 69 1e 52 9a af 2c
 |}
-  and s_priv = Cstruct.of_hex {|
+  and s_priv = Ohex.decode {|
 b1 58 0e ea df 6d d5 89  b8 ef 4f 2d 56 52 57 8c
 c8 10 e9 98 01 91 ec 8d  05 83 08 ce a2 16 a2 1e
 |}
-  and s_keyshare = Cstruct.of_hex {|
+  and s_keyshare = Ohex.decode {|
 c9 82 88 76 11 20 95 fe  66 76 2b db f7 c6 72 e1
 56 d6 cc 25 3b 83 3d f1  dd 69 b1 b0 4e 75 1f 0f
 |}
   in
   let check_pub pr pu =
-    match Mirage_crypto_ec.X25519.secret_of_cs pr with
+    match Mirage_crypto_ec.X25519.secret_of_octets pr with
     | Ok (_, pub) -> Alcotest.check cs __LOC__ pu pub
     | Error _ -> Alcotest.fail "couldn't decode DH secret"
   in
   let check_one p ks =
-    match Mirage_crypto_ec.X25519.secret_of_cs p with
+    match Mirage_crypto_ec.X25519.secret_of_octets p with
     | Error _ -> Alcotest.fail "couldn't decode DH secret"
     | Ok (priv, _) ->
       match Mirage_crypto_ec.X25519.key_exchange priv ks with
diff --git a/tests/readertests.ml b/tests/readertests.ml
index 8f6b66ad..e9c25fa4 100644
--- a/tests/readertests.ml
+++ b/tests/readertests.ml
@@ -97,7 +97,7 @@ let good_record_parser (bytes, result) _ =
 let good_records =
   let open Core in
   let open Packet in
-  let empty = Cstruct.create 0 in
+  let empty = "" in
   [
     ([ 20 ; 3 ; 1 ; 0 ; 0 ], `Record (({ content_type = CHANGE_CIPHER_SPEC ; version = `TLS_1_0 }, empty), empty) ) ;
     ([ 21 ; 3 ; 2 ; 0 ; 0 ], `Record (({ content_type = ALERT ; version = `TLS_1_1 }, empty), empty) ) ;
@@ -426,7 +426,7 @@ let good_dh_param_parser xs _ =
   let buf = list_to_cstruct xs in
   match Reader.parse_dh_parameters buf with
   | Error _        -> assert_failure "dh params parser broken"
-  | Ok (_, _, rst) -> assert_equal 0 (Cstruct.length rst)
+  | Ok (_, _, rst) -> assert_equal 0 (String.length rst)
 
 let good_dh_params_tests =
   List.mapi
@@ -437,33 +437,33 @@ let bad_dh_param_parser buf _ =
   match Reader.parse_dh_parameters buf with
   | Error _ -> ()
   | Ok (_, _, rst) ->
-      if Cstruct.length rst = 0 then
+      if String.length rst = 0 then
         assert_failure "dh params parser broken"
 
 let bad_dh_params_tests =
   let param = list_to_cstruct (List.hd good_dhparams) in
-  let l = Cstruct.length param in
+  let l = String.length param in
   let bad_params =
     [
-      param <+> Cstruct.create 1 ;
-      Cstruct.sub param 2 20 ;
-      Cstruct.sub param 0 20 ;
-      list_to_cstruct [2] <+> param ;
-      list_to_cstruct [0] <+> param ;
-      list_to_cstruct [0; 1] <+> param ;
-      list_to_cstruct [0; 0] <+> param ;
-      list_to_cstruct [0xff; 0xff] <+> param ;
-      list_to_cstruct [0; 0xff] <+> param ;
-      Cstruct.shift param 1 ;
-      Cstruct.sub param 0 (pred l)
+      param ^ String.make 1 '\x00' ;
+      String.sub param 2 20 ;
+      String.sub param 0 20 ;
+      list_to_cstruct [2] ^ param ;
+      list_to_cstruct [0] ^ param ;
+      list_to_cstruct [0; 1] ^ param ;
+      list_to_cstruct [0; 0] ^ param ;
+      list_to_cstruct [0xff; 0xff] ^ param ;
+      list_to_cstruct [0; 0xff] ^ param ;
+      String.sub param 1 (String.length param - 1);
+      String.sub param 0 (pred l)
     ]
   in
   let lastparam = list_to_cstruct (List.nth good_dhparams 5) in
-  let l = Cstruct.length lastparam in
+  let l = String.length lastparam in
   let more_bad =
     [
-      Cstruct.sub lastparam 0 130 <+> list_to_cstruct [0 ; 5 ; 1] <+> Cstruct.sub lastparam 130 (l - 130) ;
-      Cstruct.sub lastparam 0 133 <+> list_to_cstruct [0 ; 5 ; 1] <+> Cstruct.sub lastparam 133 (l - 133)
+      String.sub lastparam 0 130 ^ list_to_cstruct [0 ; 5 ; 1] ^ String.sub lastparam 130 (l - 130) ;
+      String.sub lastparam 0 133 ^ list_to_cstruct [0 ; 5 ; 1] ^ String.sub lastparam 133 (l - 133)
     ]
   in
   List.mapi
@@ -587,25 +587,25 @@ let good_digitally_signed_1_2_tests =
 
 let bad_dss_1_2 =
   let ds = list_to_cstruct (List.hd good_digitally_signed_1_2) in
-  let l = Cstruct.length ds in
+  let l = String.length ds in
   [
-    Cstruct.sub ds 2 20 ;
-    Cstruct.sub ds 0 20 ;
-    list_to_cstruct [2] <+> ds ;
-    list_to_cstruct [0] <+> ds ;
-    list_to_cstruct [0; 1] <+> ds ;
-    list_to_cstruct [0; 0] <+> ds ;
-    list_to_cstruct [0xff; 0xff] <+> ds ;
-    list_to_cstruct [0; 0xff] <+> ds ;
-    Cstruct.shift ds 2 ;
-    Cstruct.sub ds 0 (pred l) ;
-    list_to_cstruct [7] <+> Cstruct.shift ds 1 ;
-    list_to_cstruct [8] <+> Cstruct.shift ds 1 ;
-    list_to_cstruct [1 ; 7] <+> Cstruct.shift ds 2 ;
-    list_to_cstruct [7 ; 2] <+> Cstruct.shift ds 2 ;
-    list_to_cstruct [1 ; 1 ; 1; 0xff] <+> Cstruct.shift ds 4 ;
-    list_to_cstruct [1 ; 1 ; 0xff ; 0] <+> Cstruct.shift ds 4 ;
-    ds <+> Cstruct.create 1
+    String.sub ds 2 20 ;
+    String.sub ds 0 20 ;
+    list_to_cstruct [2] ^ ds ;
+    list_to_cstruct [0] ^ ds ;
+    list_to_cstruct [0; 1] ^ ds ;
+    list_to_cstruct [0; 0] ^ ds ;
+    list_to_cstruct [0xff; 0xff] ^ ds ;
+    list_to_cstruct [0; 0xff] ^ ds ;
+    String.sub ds 2 (String.length ds - 2) ;
+    String.sub ds 0 (pred l) ;
+    list_to_cstruct [7] ^ String.sub ds 1 (String.length ds - 1) ;
+    list_to_cstruct [8] ^ String.sub ds 1 (String.length ds - 1) ;
+    list_to_cstruct [1 ; 7] ^ String.sub ds 2 (String.length ds - 2) ;
+    list_to_cstruct [7 ; 2] ^ String.sub ds 2 (String.length ds - 2) ;
+    list_to_cstruct [1 ; 1 ; 1; 0xff] ^ String.sub ds 4 (String.length ds - 4) ;
+    list_to_cstruct [1 ; 1 ; 0xff ; 0] ^ String.sub ds 4 (String.length ds - 4) ;
+    ds ^ String.make 1 '\x00'
   ]
 
 let bad_digitally_signed_1_2_parser buf _ =
@@ -619,7 +619,10 @@ let bad_digitally_signed_1_2_tests =
     bad_dss_1_2
 
 let good_digitally_signed_parser xs _ =
-  let buf = Cstruct.shift (list_to_cstruct xs) 2 in
+  let buf =
+    let b = list_to_cstruct xs in
+    String.sub b 2 (String.length b - 2)
+  in
   match Reader.parse_digitally_signed buf with
   | Error _ -> assert_failure "digitally signed parser broken"
   | Ok _    -> ()
@@ -630,15 +633,17 @@ let good_digitally_signed_tests =
     good_digitally_signed_1_2
 
 let bad_dss =
-  let ds = Cstruct.shift (list_to_cstruct (List.hd good_digitally_signed_1_2)) 2 in
-  let l = Cstruct.length ds in
+  let ds =
+    let buf = list_to_cstruct (List.hd good_digitally_signed_1_2) in
+    String.sub buf 2 (String.length buf - 2) in
+  let l = String.length ds in
   [
-    list_to_cstruct [0xff ; 0xff] <+> ds ;
-    list_to_cstruct [0xff ; 0xff] <+> Cstruct.shift ds 2 ;
-    Cstruct.shift ds 2 ;
-    Cstruct.sub ds 0 (pred l) ;
-    list_to_cstruct [1; 1] <+> Cstruct.shift ds 2 ;
-    ds <+> Cstruct.create 1
+    list_to_cstruct [0xff ; 0xff] ^ ds ;
+    list_to_cstruct [0xff ; 0xff] ^ String.sub ds 2 (String.length ds - 2);
+    String.sub ds 2 (String.length ds - 2) ;
+    String.sub ds 0 (pred l) ;
+    list_to_cstruct [1; 1] ^ String.sub ds 2 (String.length ds - 2);
+    ds ^ String.make 1 '\x00'
   ]
 
 let bad_digitally_signed_parser buf _ =
@@ -653,7 +658,7 @@ let bad_digitally_signed_tests =
 
 let good_handshake_hdrs =
   let data = [ 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11 ] in
-  let empty = Cstruct.create 0 in
+  let empty = "" in
   [
   ([0; 0; 0], (None, list_to_cstruct [0;0;0])) ;
   ([0; 0; 0; 0], (Some (list_to_cstruct [0;0;0;0]), empty)) ;
@@ -1334,7 +1339,7 @@ let good_client_hellos =
             { ch with client_version = `TLS_1_3 ;
                       client_random = list_to_cstruct [ 0xf1; 0xb2; 0x50; 0x16; 0x4b; 0x77; 0x50; 0xb3; 0xdc; 0xcb; 0x1c; 0x6a; 0xae; 0x1a; 0x94; 0x87; 0xc4; 0x17; 0xbb; 0xa4; 0xf7; 0x92; 0xf8; 0x16; 0x56; 0x12; 0x03; 0x38; 0x1e; 0xe5; 0xc1; 0xae ] ;
                       ciphersuites = Packet.([TLS_RSA_WITH_AES_256_CBC_SHA ; TLS_DHE_RSA_WITH_AES_256_CBC_SHA ; TLS_RSA_WITH_AES_128_CBC_SHA ; TLS_DHE_RSA_WITH_AES_128_CBC_SHA ; TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA ; TLS_RSA_WITH_3DES_EDE_CBC_SHA]) ;
-                      extensions = [ `SecureRenegotiation (Cstruct.create 0) ;
+                      extensions = [ `SecureRenegotiation "" ;
                                      make_hostname_ext "example.com" ;
                                      `SignatureAlgorithms
                                        [`RSA_PKCS1_SHA512 ;
@@ -1505,7 +1510,7 @@ let good_server_hellos =
                server_random = list_to_cstruct [ 0x53; 0x66; 0x2d; 0xf0; 0x1b; 0x61; 0x55; 0x8f; 0x74; 0x2a; 0xbf; 0xf4; 0x99; 0x86; 0x30; 0x99; 0x32; 0xe4; 0xd0; 0x1e; 0x2b; 0xa9; 0x2e; 0x86; 0x7b; 0xeb; 0x03; 0x00; 0xf9; 0x11; 0x3e; 0xc5 ] ;
                sessionid = Some (list_to_cstruct [ 0xd1; 0x54; 0xd9; 0x05; 0x61; 0x41; 0x53; 0x33; 0xb2; 0xf0; 0x13; 0x78; 0x1a; 0x17; 0xb3; 0x1d; 0x09; 0xf6; 0x59; 0x70; 0xfe; 0x5d; 0x58; 0x22; 0xfa; 0x8c; 0x5c; 0x89; 0xe9; 0xa2; 0xb4; 0x70 ]) ;
                extensions = [`Hostname;
-                             `SecureRenegotiation (Cstruct.create 0);
+                             `SecureRenegotiation "";
                              `ALPN "h2"] }) ;
 
           ( [
@@ -1525,7 +1530,7 @@ let good_server_hellos =
               server_random = list_to_cstruct [ 0x53; 0x66; 0x2f; 0xb7; 0x35; 0x3a; 0x42; 0xee; 0x1c; 0xe6; 0xed; 0x63; 0x8a; 0x1d; 0x3d; 0xb3; 0x71; 0x9c; 0xf5; 0x64; 0x45; 0xc5; 0xe9; 0xf4; 0x11; 0x8b; 0x9f; 0x41; 0x5a; 0x5f; 0xf1; 0xf6 ] ;
               sessionid = Some (list_to_cstruct [ 0xdf; 0xe1; 0x09; 0x8a; 0x42; 0xf0; 0x25; 0xc7; 0xbd; 0xe5; 0xe9; 0x02; 0x6a; 0x03; 0xaf; 0xb4; 0x70; 0x80; 0xe9; 0x2f; 0x07; 0x3f; 0x53; 0xd3; 0xc8; 0x97; 0x3f; 0xc4; 0x44; 0x23; 0xf5; 0x94 ] ) ;
               extensions = [`Hostname;
-                            `SecureRenegotiation (Cstruct.create 0)] }) ;
+                            `SecureRenegotiation ""] }) ;
 
        ])
 
diff --git a/tests/readerwritertests.ml b/tests/readerwritertests.ml
index f0a2fa1f..ee486161 100644
--- a/tests/readerwritertests.ml
+++ b/tests/readerwritertests.ml
@@ -24,14 +24,14 @@ let readerwriter_header (v, ct, cs) _ =
   match Reader.parse_record buf with
   | Ok (`Record ((hdr, payload), f)) ->
     let open Core in
-    assert_equal 0 (Cstruct.length f) ;
+    assert_equal 0 (String.length f) ;
     assert_equal (v :> tls_any_version) hdr.version ;
     assert_equal ct hdr.content_type ;
     assert_cs_eq cs payload ;
     let buf' = Writer.assemble_hdr v (hdr.content_type, payload) in
     (match Reader.parse_record buf' with
      | Ok (`Record ((hdr, payload), f)) ->
-       assert_equal 0 (Cstruct.length f) ;
+       assert_equal 0 (String.length f) ;
        assert_equal (v :> tls_any_version) hdr.version ;
        assert_equal ct hdr.content_type ;
        assert_cs_eq cs payload ;
@@ -184,14 +184,14 @@ let readerwriter_dh_params params _ =
   let buf = Writer.assemble_dh_parameters params in
   match Reader.parse_dh_parameters buf with
   | Ok (p, raw, rst) ->
-      assert_equal (Cstruct.length rst) 0 ;
+      assert_equal (String.length rst) 0 ;
       assert_dh_eq p params ;
       assert_equal buf raw ;
       (* lets get crazy and do it one more time *)
       let buf' = Writer.assemble_dh_parameters p in
       (match Reader.parse_dh_parameters buf' with
       | Ok (p', raw', rst') ->
-          assert_equal (Cstruct.length rst') 0 ;
+          assert_equal (String.length rst') 0 ;
           assert_dh_eq p' params ;
           assert_equal buf raw' ;
       | Error _ -> assert_failure "inner read and write dh params broken")
@@ -205,7 +205,7 @@ let rw_dh_params =
          { dh_p = a ; dh_g = emp ; dh_Ys = emp } ;
          { dh_p = emp ; dh_g = a ; dh_Ys = emp } ;
          { dh_p = emp ; dh_g = emp ; dh_Ys = a } ;
-         { dh_p = a <+> a ; dh_g = a <+> a ; dh_Ys = a <+> a } ;
+         { dh_p = a ^ a ; dh_g = a ^ a ; dh_Ys = a ^ a } ;
        ])
 
 let rw_dh_tests =
@@ -228,7 +228,7 @@ let readerwriter_digitally_signed params _ =
 let rw_ds_params =
   let a = list_to_cstruct [ 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15 ] in
   let emp = list_to_cstruct [] in
-  [ a ; a <+> a ; emp ; emp <+> a ]
+  [ a ; a ^ a ; emp ; emp ^ a ]
 
 let rw_ds_tests =
   List.mapi
@@ -258,7 +258,7 @@ let rec cartesian_product f a b =
 let rw_ds_1_2_params =
   let a = list_to_cstruct [ 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15 ] in
   let emp = list_to_cstruct [] in
-  let cs = [ a ; a <+> a ; emp ; emp <+> a ] in
+  let cs = [ a ; a ^ a ; emp ; emp ^ a ] in
   let sig_algs = [
     `RSA_PKCS1_MD5 ; `RSA_PKCS1_SHA1 ; `RSA_PKCS1_SHA224 ; `RSA_PKCS1_SHA256 ;
     `RSA_PKCS1_SHA384 ; `RSA_PKCS1_SHA512 ;
diff --git a/tests/testlib.ml b/tests/testlib.ml
index 5d40c440..6f681a12 100644
--- a/tests/testlib.ml
+++ b/tests/testlib.ml
@@ -8,28 +8,22 @@ let time f =
   let t2 = Sys.time () in
   ( Printf.eprintf "[time] %f.04 s\n%!" (t2 -.  t1) ; r )
 
-let (<+>) = Cstruct.append
-
 let list_to_cstruct xs =
-  let open Cstruct in
-  let buf = create (List.length xs) in
-  List.iteri (set_uint8 buf) xs ;
-  buf
+  let buf = Bytes.create (List.length xs) in
+  List.iteri (Bytes.set_uint8 buf) xs ;
+  Bytes.unsafe_to_string buf
 
 let uint16_to_cstruct i =
-  let open Cstruct in
-  let buf = create 2 in
-  BE.set_uint16 buf 0 i;
+  let buf = Bytes.create 2 in
+  Bytes.set_uint16_be buf 0 i;
   buf
 
 let hexdump_to_str cs =
-  let b = Buffer.create 16 in
-  Cstruct.hexdump_to_buffer b cs ;
-  Buffer.contents b
+  Ohex.encode cs
 
 let assert_cs_eq ?msg cs1 cs2 =
   assert_equal
-    ~cmp:Cstruct.equal
+    ~cmp:String.equal
     ~printer:hexdump_to_str
     ?msg
     cs1 cs2
@@ -67,8 +61,5 @@ let assert_server_extension_equal a b =
   | `ALPN a, `ALPN b -> assert_equal a b
   | _ -> assert_failure "extensions did not match"
 
-let cs_mmap file =
-  Unix_cstruct.of_fd Unix.(openfile file [O_RDONLY] 0)
-
 let make_hostname_ext h =
   (`Hostname (Domain_name.of_string_exn h |> Domain_name.host_exn))
diff --git a/tests/writertests.ml b/tests/writertests.ml
index 588724fe..442eb332 100644
--- a/tests/writertests.ml
+++ b/tests/writertests.ml
@@ -174,16 +174,16 @@ let dh_assembler_tests =
   let emp, empl = (list_to_cstruct [], list_to_cstruct [ 0; 0 ]) in
   Core.([
     ( { dh_p = a ; dh_g = a ; dh_Ys = a },
-      le <+> a <+> le <+> a <+> le <+> a ) ;
-    ( { dh_p = a <+> a ; dh_g = a ; dh_Ys = a <+> a },
-      le2 <+> a <+> a <+> le <+> a <+> le2 <+> a <+> a ) ;
-    ( { dh_p = emp ; dh_g = emp ; dh_Ys = emp }, empl <+> empl <+> empl ) ;
-    ( { dh_p = a ; dh_g = emp ; dh_Ys = emp }, le <+> a <+> empl <+> empl ) ;
-    ( { dh_p = emp ; dh_g = a ; dh_Ys = emp }, empl <+> le <+> a <+> empl ) ;
-    ( { dh_p = emp ; dh_g = emp ; dh_Ys = a }, empl <+> empl <+> le <+> a ) ;
-    ( { dh_p = emp ; dh_g = a ; dh_Ys = a }, empl <+> le <+> a <+> le <+> a ) ;
-    ( { dh_p = a ; dh_g = a ; dh_Ys = emp }, le <+> a <+> le <+> a <+> empl ) ;
-    ( { dh_p = a ; dh_g = emp ; dh_Ys = a }, le <+> a <+> empl <+> le <+> a ) ;
+      le ^ a ^ le ^ a ^ le ^ a ) ;
+    ( { dh_p = a ^ a ; dh_g = a ; dh_Ys = a ^ a },
+      le2 ^ a ^ a ^ le ^ a ^ le2 ^ a ^ a ) ;
+    ( { dh_p = emp ; dh_g = emp ; dh_Ys = emp }, empl ^ empl ^ empl ) ;
+    ( { dh_p = a ; dh_g = emp ; dh_Ys = emp }, le ^ a ^ empl ^ empl ) ;
+    ( { dh_p = emp ; dh_g = a ; dh_Ys = emp }, empl ^ le ^ a ^ empl ) ;
+    ( { dh_p = emp ; dh_g = emp ; dh_Ys = a }, empl ^ empl ^ le ^ a ) ;
+    ( { dh_p = emp ; dh_g = a ; dh_Ys = a }, empl ^ le ^ a ^ le ^ a ) ;
+    ( { dh_p = a ; dh_g = a ; dh_Ys = emp }, le ^ a ^ le ^ a ^ empl ) ;
+    ( { dh_p = a ; dh_g = emp ; dh_Ys = a }, le ^ a ^ empl ^ le ^ a ) ;
        ])
 
 let dh_tests =
@@ -202,8 +202,8 @@ let ds_assembler_tests =
   let le2 = list_to_cstruct [ 0; 32 ] in
   let emp, empl = (list_to_cstruct [], list_to_cstruct [ 0; 0 ]) in
   [
-    ( a , le <+> a ) ;
-    ( a <+> a , le2 <+> a <+> a ) ;
+    ( a , le ^ a ) ;
+    ( a ^ a , le2 ^ a ^ a ) ;
     ( emp , empl )
   ]
 
@@ -222,9 +222,9 @@ let ds_1_2_assembler_tests =
   let le2 = list_to_cstruct [ 0; 32 ] in
   let emp, empl = (list_to_cstruct [], list_to_cstruct [0; 0]) in
   [
-    ( `RSA_PKCS1_MD5, a , list_to_cstruct [1; 1] <+> le <+> a ) ;
-    ( `RSA_PKCS1_SHA1, a <+> a , list_to_cstruct [2; 1] <+> le2 <+> a <+> a ) ;
-    ( `RSA_PSS_RSAENC_SHA256, emp , list_to_cstruct [8; 4] <+> empl )
+    ( `RSA_PKCS1_MD5, a , list_to_cstruct [1; 1] ^ le ^ a ) ;
+    ( `RSA_PKCS1_SHA1, a ^ a , list_to_cstruct [2; 1] ^ le2 ^ a ^ a ) ;
+    ( `RSA_PSS_RSAENC_SHA256, emp , list_to_cstruct [8; 4] ^ empl )
   ]
 
 let ds_1_2_tests =
@@ -249,15 +249,15 @@ let handshake_assembler_tests =
 
    ( Finished a_cs , [ 20 ] @ le @ a_l ) ;
    ( Finished emp , [ 20 ] @ empl ) ;
-   ( Finished (a_cs <+> a_cs) , [ 20 ] @ le2 @ a_l @ a_l ) ;
+   ( Finished (a_cs ^ a_cs) , [ 20 ] @ le2 @ a_l @ a_l ) ;
 
    ( ClientKeyExchange emp , [ 16; 0; 0; 0 ] ) ;
    ( ClientKeyExchange a_cs , [ 16; 0; 0; 16 ] @ a_l ) ;
-   ( ClientKeyExchange (a_cs <+> a_cs) , [ 16; 0; 0; 32 ] @ a_l @ a_l ) ;
+   ( ClientKeyExchange (a_cs ^ a_cs) , [ 16; 0; 0; 32 ] @ a_l @ a_l ) ;
 
    ( ServerKeyExchange emp , [ 12 ] @ empl ) ;
    ( ServerKeyExchange a_cs , [ 12 ] @ le @ a_l ) ;
-   ( ServerKeyExchange (a_cs <+> a_cs) , [ 12 ] @ le2 @ a_l @ a_l ) ;
+   ( ServerKeyExchange (a_cs ^ a_cs) , [ 12 ] @ le2 @ a_l @ a_l ) ;
 
    ( Certificate (Writer.assemble_certificates []) , [ 11; 0; 0; 3; 0; 0; 0 ] ) ;
    ( Certificate (Writer.assemble_certificates[emp]) , [ 11; 0; 0; 6; 0; 0; 3; 0; 0; 0 ] ) ;
@@ -271,35 +271,35 @@ let handshake_assembler_tests =
    ( Certificate (Writer.assemble_certificates[a_cs ; emp ; a_cs ; emp]) , [ 11; 0; 0; 47; 0; 0; 44 ] @ le @ a_l @ [ 0; 0; 0 ] @ le @ a_l @ [ 0; 0; 0 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [] ;
                    extensions = [] },
      [ 1; 0; 0; 39; 3; 3 ] @ a_l @ a_l @ [ 0; 0; 0; 1; 0 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_1 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [] ;
                    extensions = [] },
      [ 1; 0; 0; 39; 3; 2 ] @ a_l @ a_l @ [ 0; 0; 0; 1; 0 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_0 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [] ;
                    extensions = [] },
      [ 1; 0; 0; 39; 3; 1 ] @ a_l @ a_l @ [ 0; 0; 0; 1; 0 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [] },
      [ 1; 0; 0; 41; 3; 3 ] @ a_l @ a_l @ [ 0; 0; 2; 0; 0x0a; 1; 0 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = Packet.([TLS_RSA_WITH_3DES_EDE_CBC_SHA ; TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA ; TLS_RSA_WITH_AES_128_CBC_SHA ; TLS_DHE_RSA_WITH_AES_128_CBC_SHA]);
                    extensions = [] },
@@ -307,7 +307,7 @@ let handshake_assembler_tests =
 
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = Packet.([TLS_RSA_WITH_3DES_EDE_CBC_SHA ; TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA ; TLS_RSA_WITH_AES_128_CBC_SHA ; TLS_DHE_RSA_WITH_AES_128_CBC_SHA]);
                    extensions = [
@@ -324,7 +324,7 @@ let handshake_assembler_tests =
 
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [`ALPN ["h2"; "http/1.1"]] },
@@ -332,21 +332,21 @@ let handshake_assembler_tests =
 
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [make_hostname_ext "foo"] },
      [ 1; 0; 0; 55; 3; 3 ] @ a_l @ a_l @ [ 0; 0; 2; 0; 0x0A; 1; 0; 0; 12; 0; 0; 0; 8; 0; 6; 0; 0; 3; 102; 111; 111 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [make_hostname_ext "foofoofoofoofoofoofoofoofoofoo"] },
      [ 1; 0; 0; 82; 3; 3 ] @ a_l @ a_l @ [ 0; 0; 2; 0; 0x0A; 1; 0; 0; 39; 0; 0; 0; 35; 0; 33; 0; 0; 30; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111; 102; 111; 111 ] ) ;
 
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [make_hostname_ext "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoof"] },
@@ -355,7 +355,7 @@ let handshake_assembler_tests =
    (* this one is the smallest which needs extra padding
      (due to its size being > 256 and < 511) *)
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [make_hostname_ext "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofo"] },
@@ -363,7 +363,7 @@ let handshake_assembler_tests =
 
    (* this one is the biggest which needs no extra padding *)
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA] ;
                    extensions = [make_hostname_ext "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo.foofoofoofoofoof"] },
@@ -371,7 +371,7 @@ let handshake_assembler_tests =
 
    (* this one is the biggest which needs no extra padding, and no exts *)
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;
 Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;
@@ -384,7 +384,7 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
 
    (* add one more, and we get into padding no exts *)
    ( ClientHello { client_version = `TLS_1_2 ;
-                   client_random = a_cs <+> a_cs ;
+                   client_random = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuites = [Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA; Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;
 Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;
@@ -400,7 +400,7 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
  ] ) ;
 
    ( ServerHello { server_version = `TLS_1_2 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
                    extensions = []
@@ -408,7 +408,7 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
      [2; 0; 0; 38; 3; 3] @ a_l @ a_l @ [(* session id *) 0; (* cipher *) 0xc0; 0x9c; (* comp *) 0; (* exts *)] ) ;
 
    ( ServerHello { server_version = `TLS_1_1 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
                    extensions = []
@@ -416,7 +416,7 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
      [2; 0; 0; 38; 3; 2] @ a_l @ a_l @ [(* session id *) 0; (* cipher *) 0xc0; 0x9c; (* comp *) 0; (* exts *)] ) ;
 
    ( ServerHello { server_version = `TLS_1_0 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
                    extensions = []
@@ -425,7 +425,7 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
 
 
    ( ServerHello { server_version = `TLS_1_0 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = Some a_cs ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
                    extensions = []
@@ -433,7 +433,7 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
      [2; 0; 0; 54; 3; 1] @ a_l @ a_l @ (* session id *) [ 16 ] @ a_l @ [(* cipher *) 0xc0; 0x9c; (* comp *) 0; (* exts *)] ) ;
 
    ( ServerHello { server_version = `TLS_1_2 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
                    extensions = [`Hostname]
@@ -442,31 +442,31 @@ Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet.TLS_RSA_WITH_3DES_EDE_CBC_SHA;Packet
 
 
    ( ServerHello { server_version = `TLS_1_2 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
-                   extensions = [`SecureRenegotiation (Cstruct.create 0)]
+                   extensions = [`SecureRenegotiation ("")]
                  } ,
      [2; 0; 0; 45; 3; 3] @ a_l @ a_l @ [(* session id *) 0; (* cipher *) 0xc0; 0x9c; (* comp *) 0; (* exts *) 0; 5; 0xFF; 1; 0; 1; 0] ) ;
 
    ( ServerHello { server_version = `TLS_1_2 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
-                   extensions = [`Hostname ; `SecureRenegotiation (Cstruct.create 0)]
+                   extensions = [`Hostname ; `SecureRenegotiation ("")]
                  } ,
      [2; 0; 0; 49; 3; 3] @ a_l @ a_l @ [(* session id *) 0; (* cipher *) 0xc0; 0x9c; (* comp *) 0; (* exts *) 0; 9; 0; 0; 0; 0; 0xFF; 1; 0; 1; 0] ) ;
 
    ( ServerHello { server_version = `TLS_1_2 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
-                   extensions = [`SecureRenegotiation (Cstruct.create 0); `Hostname ]
+                   extensions = [`SecureRenegotiation (""); `Hostname ]
                  } ,
      [2; 0; 0; 49; 3; 3] @ a_l @ a_l @ [(* session id *) 0; (* cipher *) 0xc0; 0x9c; (* comp *) 0; (* exts *) 0; 9; 0xFF; 1; 0; 1; 0; 0; 0; 0; 0] ) ;
 
    ( ServerHello { server_version = `TLS_1_2 ;
-                   server_random  = a_cs <+> a_cs ;
+                   server_random  = a_cs ^ a_cs ;
                    sessionid = None ;
                    ciphersuite = `RSA_WITH_AES_128_CCM ;
                    extensions = [`ALPN "h2"]

From afe73baad0264d4389623f7ee38f690cd22cbbd2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Reynir=20Bj=C3=B6rnsson?= <reynir@reynir.dk>
Date: Fri, 5 Apr 2024 15:56:49 +0200
Subject: [PATCH 4/9] minor

---
 lib/handshake_common.ml | 2 --
 lwt/examples/dune       | 2 +-
 2 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/lib/handshake_common.ml b/lib/handshake_common.ml
index ec111b9c..ffe014cd 100644
--- a/lib/handshake_common.ml
+++ b/lib/handshake_common.ml
@@ -1,8 +1,6 @@
 open Core
 open State
 
-open Mirage_crypto
-
 let src = Logs.Src.create "handshake" ~doc:"TLS handshake"
 module Log = (val Logs.src_log src : Logs.LOG)
 
diff --git a/lwt/examples/dune b/lwt/examples/dune
index 645f4748..da153d28 100644
--- a/lwt/examples/dune
+++ b/lwt/examples/dune
@@ -1,6 +1,6 @@
 (library
  (name ex_common)
- (libraries lwt lwt.unix sexplib tls tls-lwt cmdliner fmt.cli logs.fmt fmt.tty logs.cli)
+ (libraries lwt lwt.unix tls tls-lwt cmdliner fmt.cli logs.fmt fmt.tty logs.cli)
  (modules ex_common))
 
 (executable

From b1bf9f048d353933da869dfe4cb1fd156041e5c9 Mon Sep 17 00:00:00 2001
From: Hannes Mehnert <hannes@mehnert.org>
Date: Sun, 7 Apr 2024 22:40:11 +0200
Subject: [PATCH 5/9] fixes

---
 lib/crypto.ml                      |  2 +-
 lwt/examples/echo_client.ml        |  6 +++---
 lwt/examples/echo_server.ml        |  2 +-
 lwt/examples/fuzz_server.ml        |  4 ++--
 lwt/examples/resume_client.ml      |  4 ++--
 lwt/examples/resume_echo_server.ml |  6 +++---
 tests/feedback.ml                  | 13 ++++++++++---
 7 files changed, 22 insertions(+), 15 deletions(-)

diff --git a/lib/crypto.ml b/lib/crypto.ml
index 86b4dc32..e0337f3b 100644
--- a/lib/crypto.ml
+++ b/lib/crypto.ml
@@ -75,7 +75,7 @@ let aead_nonce nonce seq =
   let s =
     let l = String.length nonce in
     let buf = Bytes.make l '\x00' in
-    Bytes.set_int64_be buf 0 seq;
+    Bytes.set_int64_be buf (l - 8) seq;
     Bytes.unsafe_to_string buf
   in
   Uncommon.xor nonce s
diff --git a/lwt/examples/echo_client.ml b/lwt/examples/echo_client.ml
index cd618a51..e5022c72 100644
--- a/lwt/examples/echo_client.ml
+++ b/lwt/examples/echo_client.ml
@@ -3,7 +3,7 @@ open Ex_common
 open Lwt
 
 let cached_session : Tls.Core.epoch_data =
-  let hex = Cstruct.of_hex in
+  let hex = Ohex.decode in
   {
     Tls.Core.side = `Client ;
     protocol_version = `TLS_1_3 ;
@@ -19,8 +19,8 @@ let cached_session : Tls.Core.epoch_data =
     own_private_key = None ;
     own_name = None ;
     master_secret = hex "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f" ;
-    exporter_master_secret = Cstruct.empty ;
-    session_id = Cstruct.empty ;
+    exporter_master_secret = "" ;
+    session_id = "" ;
     extended_ms = true ;
     alpn_protocol = None ;
     state = `Established ;
diff --git a/lwt/examples/echo_server.ml b/lwt/examples/echo_server.ml
index 2c81ca4f..2e38c5ff 100644
--- a/lwt/examples/echo_server.ml
+++ b/lwt/examples/echo_server.ml
@@ -37,7 +37,7 @@ let serve_ssl port callback =
   yap ~tag ("-> start @ " ^ string_of_int port) >>= fun () ->
   let rec loop s =
     let authenticator = null_auth in
-    let config = Tls.Config.server ~reneg:true ~certificates:(`Single cert) ~authenticator () in
+    let config = Tls.Config.server ~version:(`TLS_1_0, `TLS_1_3) ~ciphers:Tls.Config.Ciphers.supported ~reneg:true ~certificates:(`Single cert) ~authenticator () in
     (Lwt.catch
        (fun () -> Tls_lwt.accept_ext config s >|= fun r -> `R r)
        (function
diff --git a/lwt/examples/fuzz_server.ml b/lwt/examples/fuzz_server.ml
index 48523818..f5979bfb 100644
--- a/lwt/examples/fuzz_server.ml
+++ b/lwt/examples/fuzz_server.ml
@@ -9,9 +9,9 @@ let add_to_cache, find_in_cache =
   let c = ref [] in
   (fun ticket session ->
      let id = ticket.Tls.Core.identifier in
-     Logs.info (fun m -> m "adding id %a to cache" Cstruct.hexdump_pp id) ;
+     Logs.info (fun m -> m "adding id %a to cache" Ohex.pp id) ;
      c := (id, (ticket, session)) :: !c),
-  (fun id -> match List.find_opt (fun (id', _) -> Cstruct.compare id id' = 0) !c with
+  (fun id -> match List.find_opt (fun (id', _) -> String.compare id id' = 0) !c with
      | None -> None
      | Some (_, ep) -> Some ep)
 
diff --git a/lwt/examples/resume_client.ml b/lwt/examples/resume_client.ml
index 63c985f2..54b54735 100644
--- a/lwt/examples/resume_client.ml
+++ b/lwt/examples/resume_client.ml
@@ -7,8 +7,8 @@ let http_client ?ca ?fp hostname port =
   auth ?ca ?fp () >>= fun authenticator ->
   let config = Tls.Config.client ~authenticator () in
   Tls_lwt.Unix.connect config (hostname, port) >>= fun t ->
-  Tls_lwt.Unix.write t (Cstruct.of_string "foo\n") >>= fun () ->
-  let cs = Cstruct.create 4 in
+  Tls_lwt.Unix.write t "foo\n" >>= fun () ->
+  let cs = Bytes.create 4 in
   Tls_lwt.Unix.read t cs >>= fun _len ->
   let cached_session = match Tls_lwt.Unix.epoch t with
     | Ok e -> e
diff --git a/lwt/examples/resume_echo_server.ml b/lwt/examples/resume_echo_server.ml
index a54bdc66..2ad7b03d 100644
--- a/lwt/examples/resume_echo_server.ml
+++ b/lwt/examples/resume_echo_server.ml
@@ -27,7 +27,7 @@ let serve_ssl port callback =
     ~cert:server_cert
     ~priv_key:server_key >>= fun cert ->
 
-  let hex = Cstruct.of_hex in
+  let hex = Ohex.decode in
   let epoch =
     {
       Tls.Core.side = `Client ;
@@ -45,8 +45,8 @@ let serve_ssl port callback =
       own_private_key = Some (snd cert) ;
       own_name = Some Domain_name.(host_exn (of_string_exn "tls13test.nqsb.io")) ;
       master_secret = hex "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f" ;
-      exporter_master_secret = Cstruct.empty ;
-      session_id = Cstruct.empty ;
+      exporter_master_secret = "" ;
+      session_id = "" ;
       extended_ms = true ;
       alpn_protocol = None ;
       tls_unique = None ;
diff --git a/tests/feedback.ml b/tests/feedback.ml
index 6d175452..7529e121 100644
--- a/tests/feedback.ml
+++ b/tests/feedback.ml
@@ -65,13 +65,20 @@ let loop_chatter ~certificate ~loops ~size =
     in
     let (srv, cli) = handshake (`S server) (`C client) init in
     let message' = chat srv cli message loops in
-    if Cstruct.equal message message' then ()
+    if String.equal message message' then ()
     else failwith @@ "the message got corrupted :("
 
+let string_of_file file =
+  try
+    let fh = open_in file in
+    let content = really_input_string fh (in_channel_length fh) in
+    close_in_noerr fh;
+    content
+  with _ -> invalid_arg "Error reading file"
 
 let load_priv () =
-  let cs1 = Testlib.cs_mmap "./certificates/server.pem"
-  and cs2 = Testlib.cs_mmap "./certificates/server.key" in
+  let cs1 = string_of_file "./certificates/server.pem"
+  and cs2 = string_of_file "./certificates/server.key" in
   match
     X509.Certificate.decode_pem_multiple cs1, X509.Private_key.decode_pem cs2
   with

From d88358c36a8526e792bcd62daf10e3cb0ef7fc84 Mon Sep 17 00:00:00 2001
From: Hannes Mehnert <hannes@mehnert.org>
Date: Wed, 10 Apr 2024 12:18:08 +0200
Subject: [PATCH 6/9] update to recent mirage-crypto API changes

---
 lib/crypto.ml           | 30 +++++++++++++-----------------
 lib/state.ml            |  2 +-
 tests/key_derivation.ml |  4 ++--
 3 files changed, 16 insertions(+), 20 deletions(-)

diff --git a/lib/crypto.ml b/lib/crypto.ml
index e0337f3b..abf56020 100644
--- a/lib/crypto.ml
+++ b/lib/crypto.ml
@@ -21,30 +21,26 @@ module Ciphers = struct
 
   let get_block = function
     | TRIPLE_DES_EDE_CBC ->
-        let open Cipher_block.DES in
-        K_CBC ( (module CBC : Cipher_block.S.CBC with type key = CBC.key),
-                CBC.of_secret )
+        K_CBC ( (module DES.CBC : Block.CBC with type key = DES.CBC.key),
+                DES.CBC.of_secret )
 
     | AES_128_CBC ->
-        let open Cipher_block.AES in
-        K_CBC ( (module CBC : Cipher_block.S.CBC with type key = CBC.key),
-                CBC.of_secret )
+        K_CBC ( (module AES.CBC : Block.CBC with type key = AES.CBC.key),
+                AES.CBC.of_secret )
 
     | AES_256_CBC ->
-        let open Cipher_block.AES in
-        K_CBC ( (module CBC : Cipher_block.S.CBC with type key = CBC.key),
-                CBC.of_secret )
+        K_CBC ( (module AES.CBC : Block.CBC with type key = AES.CBC.key),
+                AES.CBC.of_secret )
 
   type aead_keyed = | K_AEAD : 'k State.aead_cipher * (string -> 'k) * bool -> aead_keyed
   let get_aead =
-    let open Cipher_block.AES in
     function
     | AES_128_CCM | AES_256_CCM ->
-       K_AEAD ((module CCM16 : AEAD with type key = CCM16.key),
-               CCM16.of_secret, true)
+       K_AEAD ((module AES.CCM16 : AEAD with type key = AES.CCM16.key),
+               AES.CCM16.of_secret, true)
     | AES_128_GCM | AES_256_GCM ->
-       K_AEAD ((module GCM : AEAD with type key = GCM.key),
-               GCM.of_secret, true)
+       K_AEAD ((module AES.GCM : AEAD with type key = AES.GCM.key),
+               AES.GCM.of_secret, true)
     | CHACHA20_POLY1305 ->
        K_AEAD ((module Chacha20 : AEAD with type key = Chacha20.key),
                Chacha20.of_secret, false)
@@ -108,7 +104,7 @@ let mac hash key pseudo_hdr data =
   H.(to_raw_string (hmac_string ~key (pseudo_hdr ^ data)))
 
 let cbc_block (type a) cipher =
-  let module C = (val cipher : Cipher_block.S.CBC with type key = a) in C.block_size
+  let module C = (val cipher : Block.CBC with type key = a) in C.block_size
 
 (* crazy CBC padding and unpadding for TLS *)
 let cbc_pad block data =
@@ -145,12 +141,12 @@ let decrypt_aead (type a) ~cipher ~key ~nonce ?adata data =
   C.authenticate_decrypt ~key ~nonce ?adata data
 
 let encrypt_cbc (type a) ~cipher ~key ~iv data =
-  let module C = (val cipher : Cipher_block.S.CBC with type key = a) in
+  let module C = (val cipher : Block.CBC with type key = a) in
   let message = C.encrypt ~key ~iv (data ^ cbc_pad C.block_size data) in
   (message, C.next_iv ~iv message)
 
 let decrypt_cbc (type a) ~cipher ~key ~iv data =
-  let module C = (val cipher : Cipher_block.S.CBC with type key = a) in
+  let module C = (val cipher : Block.CBC with type key = a) in
   try
     let message = C.decrypt ~key ~iv data in
     match cbc_unpad message with
diff --git a/lib/state.ml b/lib/state.ml
index 93e9c1d6..e4292348 100644
--- a/lib/state.ml
+++ b/lib/state.ml
@@ -11,7 +11,7 @@ type iv_mode =
   | Iv of string  (* traditional CBC (reusing last cipherblock) *)
   | Random_iv        (* TLS 1.1 and higher explicit IV (we use random) *)
 
-type 'k cbc_cipher    = (module Cipher_block.S.CBC with type key = 'k)
+type 'k cbc_cipher    = (module Block.CBC with type key = 'k)
 type 'k cbc_state = {
   cipher         : 'k cbc_cipher ;
   cipher_secret  : 'k ;
diff --git a/tests/key_derivation.ml b/tests/key_derivation.ml
index bc9c11af..2aa70f30 100644
--- a/tests/key_derivation.ml
+++ b/tests/key_derivation.ml
@@ -429,11 +429,11 @@ let processed_payload () =
     server_payload ^ t
   in
   let nonce = Tls.Crypto.aead_nonce write_handshake_iv 0L in
-  let key = Mirage_crypto.Cipher_block.AES.GCM.of_secret write_handshake_key in
+  let key = Mirage_crypto.AES.GCM.of_secret write_handshake_key in
   let adata = Tls.Writer.assemble_hdr `TLS_1_2 (Tls.Packet.APPLICATION_DATA, "") in
   Bytes.set_uint16_be (Bytes.unsafe_of_string adata) 3 (17 + String.length server_payload) ;
   let res =
-    Mirage_crypto.Cipher_block.AES.GCM.authenticate_encrypt ~key ~adata ~nonce buf
+    Mirage_crypto.AES.GCM.authenticate_encrypt ~key ~adata ~nonce buf
   in
   let data = Tls.Writer.assemble_hdr `TLS_1_2 (Tls.Packet.APPLICATION_DATA, res) in
   Alcotest.check cs __LOC__ server_payload_processed data

From 858db7d3dccb5478dffb1f4ae15b0e63905f6fe0 Mon Sep 17 00:00:00 2001
From: Calascibetta Romain <romain.calascibetta@gmail.com>
Date: Thu, 27 Jun 2024 05:25:48 +0200
Subject: [PATCH 7/9] Rebase no-cstruct to include #495 and #496

---
 lib/core.ml               | 2 +-
 lib/handshake_client13.ml | 1 -
 lib/handshake_common.ml   | 2 +-
 lib/state.ml              | 2 +-
 4 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/lib/core.ml b/lib/core.ml
index 64be5479..7279760a 100644
--- a/lib/core.ml
+++ b/lib/core.ml
@@ -486,7 +486,7 @@ type epoch_data = {
   session_id             : SessionID.t ;
   extended_ms            : bool ;
   alpn_protocol          : string option ;
-  tls_unique             : Cstruct.t option ;
+  tls_unique             : string option ;
 }
 
 let supports_key_usage ?(not_present = false) usage cert =
diff --git a/lib/handshake_client13.ml b/lib/handshake_client13.ml
index 2111b42f..3b03aa8b 100644
--- a/lib/handshake_client13.ml
+++ b/lib/handshake_client13.ml
@@ -194,7 +194,6 @@ let answer_finished state (session : session_data13) server_hs_secret client_hs_
   let myfin = Handshake_crypto13.finished hash client_hs_secret log in
   let mfin = Writer.assemble_handshake (Finished myfin) in
 
-  let exporter_master_secret = Handshake_crypto13.exporter session.master_secret log in
   let resumption_secret = Handshake_crypto13.resumption session.master_secret (log ^ mfin) in
   let session = { session with resumption_secret ; exporter_master_secret ; client_app_secret ; server_app_secret } in
   let machina = Client13 Established13 in
diff --git a/lib/handshake_common.ml b/lib/handshake_common.ml
index ffe014cd..08b26496 100644
--- a/lib/handshake_common.ml
+++ b/lib/handshake_common.ml
@@ -124,7 +124,7 @@ let empty_session = {
   renegotiation       = "", "" ;
   session_id          = "" ;
   extended_ms         = false ;
-  tls_unique          = Cstruct.empty ;
+  tls_unique          = "" ;
 }
 
 let empty_session13 cipher = {
diff --git a/lib/state.ml b/lib/state.ml
index e4292348..05d7bcb8 100644
--- a/lib/state.ml
+++ b/lib/state.ml
@@ -78,7 +78,7 @@ type session_data = {
   renegotiation          : reneg_params ; (* renegotiation data *)
   session_id             : string ;
   extended_ms            : bool ;
-  tls_unique             : Cstruct.t ;
+  tls_unique             : string ;
 }
 
 (* state machine of the server *)

From 80f9830b3d5646ea0b67f1d56cb3be89e2592ff1 Mon Sep 17 00:00:00 2001
From: Calascibetta Romain <romain.calascibetta@gmail.com>
Date: Thu, 27 Jun 2024 05:46:28 +0200
Subject: [PATCH 8/9] tls-async uses string now

---
 async/io.ml          | 21 +++++++++---------
 async/io_intf.ml     |  8 +++----
 async/session.ml     |  8 +++----
 async/tls_async.ml   |  6 +++---
 async/x509_async.ml  | 51 +++++++++++++++++++-------------------------
 async/x509_async.mli | 30 +++++++++++++-------------
 6 files changed, 58 insertions(+), 66 deletions(-)

diff --git a/async/io.ml b/async/io.ml
index a3a885b2..c85a452f 100644
--- a/async/io.ml
+++ b/async/io.ml
@@ -39,8 +39,8 @@ module Make (Fd : Fd) : S with module Fd := Fd = struct
   type t =
     { fd : Fd.t
     ; mutable state : State.t
-    ; mutable linger : Cstruct.t option
-    ; recv_buf : Cstruct.t
+    ; mutable linger : string option
+    ; recv_buf : bytes
     }
 
   let tls_error = Fn.compose Deferred.Or_error.error_s Tls_error.sexp_of_t
@@ -73,18 +73,17 @@ module Make (Fd : Fd) : S with module Fd := Fd = struct
        | Active _, `Eof ->
          t.state <- Eof;
          return `Eof
-       | Active tls, `Ok n -> handle tls (Cstruct.sub t.recv_buf 0 n)
+       | Active tls, `Ok n -> handle tls (Stdlib.Bytes.sub_string t.recv_buf 0 n)
        | Error e, _ -> tls_error e
        | Eof, _ -> return `Eof)
   ;;
 
   let rec read t buf =
     let writeout res =
-      let open Cstruct in
-      let rlen = length res in
-      let n = min (length buf) rlen in
-      blit res 0 buf 0 n;
-      t.linger <- (if n < rlen then Some (sub res n (rlen - n)) else None);
+      let rlen = String.length res in
+      let n = min (Bytes.length buf) rlen in
+      Stdlib.Bytes.blit_string res 0 buf 0 n;
+      t.linger <- (if n < rlen then Some (Stdlib.String.sub res n (rlen - n)) else None);
       return n
     in
     match t.linger with
@@ -120,7 +119,7 @@ module Make (Fd : Fd) : S with module Fd := Fd = struct
       match mcs, t.linger with
       | None, _ -> ()
       | scs, None -> t.linger <- scs
-      | Some cs, Some l -> t.linger <- Some (Cstruct.append l cs)
+      | Some cs, Some l -> t.linger <- Some (l ^ cs)
     in
     match t.state with
     | Active tls when not (Tls.Engine.handshake_in_progress tls) -> return t
@@ -173,7 +172,7 @@ module Make (Fd : Fd) : S with module Fd := Fd = struct
       { state = Active (Tls.Engine.server config)
       ; fd
       ; linger = None
-      ; recv_buf = Cstruct.create 4096
+      ; recv_buf = Bytes.create 4096
       }
   ;;
 
@@ -183,7 +182,7 @@ module Make (Fd : Fd) : S with module Fd := Fd = struct
       | None -> config
       | Some host -> Tls.Config.peer config host
     in
-    let t = { state = Eof; fd; linger = None; recv_buf = Cstruct.create 4096 } in
+    let t = { state = Eof; fd; linger = None; recv_buf = Bytes.create 4096 } in
     let tls, init = Tls.Engine.client config' in
     let t = { t with state = Active tls } in
     let%bind () = Fd.write_full t.fd init in
diff --git a/async/io_intf.ml b/async/io_intf.ml
index d90cd6be..f5edcc04 100644
--- a/async/io_intf.ml
+++ b/async/io_intf.ml
@@ -4,8 +4,8 @@ open! Async
 module type Fd = sig
   type t
 
-  val read : t -> Cstruct.t -> [ `Ok of int | `Eof ] Deferred.Or_error.t
-  val write_full : t -> Cstruct.t -> unit Deferred.Or_error.t
+  val read : t -> bytes -> [ `Ok of int | `Eof ] Deferred.Or_error.t
+  val write_full : t -> string -> unit Deferred.Or_error.t
 end
 
 module type S = sig
@@ -32,10 +32,10 @@ module type S = sig
 
   (** [read t buffer] is [length], the number of bytes read into
       [buffer]. *)
-  val read : t -> Cstruct.t -> int Deferred.Or_error.t
+  val read : t -> bytes -> int Deferred.Or_error.t
 
   (** [writev t buffers] writes the [buffers] to the session. *)
-  val writev : t -> Cstruct.t list -> unit Deferred.Or_error.t
+  val writev : t -> string list -> unit Deferred.Or_error.t
 
   (** [close t] closes the TLS session by sending a close notify to the peer. *)
   val close_tls : t -> unit Deferred.Or_error.t
diff --git a/async/session.ml b/async/session.ml
index 665a7a95..0920a560 100644
--- a/async/session.ml
+++ b/async/session.ml
@@ -5,22 +5,22 @@ module Fd = struct
   type t = Reader.t * Writer.t
 
   let read (reader, (_ : Writer.t)) buf =
-    Deferred.Or_error.try_with (fun () -> Async_cstruct.read reader buf)
+    Deferred.Or_error.try_with (fun () -> Reader.read reader buf)
   ;;
 
   let write ((_ : Reader.t), writer) buf =
     Deferred.Or_error.try_with (fun () ->
-      Async_cstruct.schedule_write writer buf;
+      Writer.write writer buf;
       Writer.flushed writer)
   ;;
 
   let rec write_full fd buf =
     let open Deferred.Or_error.Let_syntax in
-    match Cstruct.length buf with
+    match String.length buf with
     | 0 -> return ()
     | len ->
       let%bind () = write fd buf in
-      write_full fd (Cstruct.shift buf len)
+      write_full fd (String.sub buf ~pos:len ~len:(String.length buf - len))
   ;;
 end
 
diff --git a/async/tls_async.ml b/async/tls_async.ml
index afeedfec..15082923 100644
--- a/async/tls_async.ml
+++ b/async/tls_async.ml
@@ -10,14 +10,14 @@ let try_to_close t =
 ;;
 
 let pipe t =
-  let b_reader = Cstruct.create 0x8000 in
+  let b_reader = Bytes.create 0x8000 in
   let rec f_reader writer =
     match%bind Session.read t b_reader with
     | Ok 0 ->
       Pipe.close writer;
       return ()
     | Ok len ->
-      let%bind () = Pipe.write writer (Cstruct.to_string (Cstruct.sub b_reader 0 len)) in
+      let%bind () = Pipe.write writer (Stdlib.Bytes.sub_string b_reader 0 len) in
       f_reader writer
     | Error read_error ->
       Log.Global.error_s [%sexp (read_error : Error.t)];
@@ -28,7 +28,7 @@ let pipe t =
     let%bind pipe_read = Pipe.read reader in
     match pipe_read with
     | `Ok s ->
-      (match%bind Session.writev t [ Cstruct.of_string s ] with
+      (match%bind Session.writev t [ s ] with
        | Ok () -> f_writer reader
        | Error (_ : Error.t) -> try_to_close t)
     | `Eof -> try_to_close t
diff --git a/async/x509_async.ml b/async/x509_async.ml
index 4ee466a7..1195f38f 100644
--- a/async/x509_async.ml
+++ b/async/x509_async.ml
@@ -20,19 +20,19 @@ module Or_error = struct
   let of_result ~to_string = Result.map_error ~f:(Fn.compose Error.of_string to_string)
   let of_result_msg x = of_result x ~to_string:(fun (`Msg msg) -> msg)
 
-  let lift_result_msg_of_cstruct f ~contents =
-    f (Cstruct.of_string contents) |> of_result_msg
+  let lift_result_msg_of_string f ~contents =
+    f contents |> of_result_msg
   ;;
 
-  let lift_asn_error_of_cstruct f ~contents =
-    f (Cstruct.of_string contents) |> of_result ~to_string:(fun (`Parse msg) -> msg)
+  let lift_asn_error_of_string f ~contents =
+    f contents |> of_result ~to_string:(fun (`Parse msg) -> msg)
   ;;
 end
 
 module CRL = struct
   include X509.CRL
 
-  let decode_der = Or_error.lift_result_msg_of_cstruct decode_der
+  let decode_der = Or_error.lift_result_msg_of_string decode_der
 
   let revoke ?digest ~issuer ~this_update ?next_update ?extensions revoked_certs key =
     revoke ?digest ~issuer ~this_update ?next_update ?extensions revoked_certs key
@@ -58,9 +58,9 @@ module Certificate = struct
   include X509.Certificate
   open Deferred.Or_error.Let_syntax
 
-  let decode_pem_multiple = Or_error.lift_result_msg_of_cstruct decode_pem_multiple
-  let decode_pem = Or_error.lift_result_msg_of_cstruct decode_pem
-  let decode_der = Or_error.lift_result_msg_of_cstruct decode_der
+  let decode_pem_multiple = Or_error.lift_result_msg_of_string decode_pem_multiple
+  let decode_pem = Or_error.lift_result_msg_of_string decode_pem
+  let decode_der = Or_error.lift_result_msg_of_string decode_der
 
   let of_pem_file ca_file =
     let%bind contents = file_contents ca_file in
@@ -81,7 +81,7 @@ module Authenticator = struct
     module Chain_of_trust = struct
       type t =
         { trust_anchors : [ `File of Filename.t | `Directory of Filename.t ]
-        ; allowed_hashes : Mirage_crypto.Hash.hash list option
+        ; allowed_hashes : Digestif.hash' list option
         ; crls : Filename.t option
         }
 
@@ -93,8 +93,8 @@ module Authenticator = struct
 
     type t =
       | Chain_of_trust of Chain_of_trust.t
-      | Cert_fingerprint of Mirage_crypto.Hash.hash * string
-      | Key_fingerprint of Mirage_crypto.Hash.hash * string
+      | Cert_fingerprint of Digestif.hash' * string
+      | Key_fingerprint of Digestif.hash' * string
 
     let ca_file ?allowed_hashes ?crls filename () =
       let trust_anchors = `File filename in
@@ -114,7 +114,7 @@ module Authenticator = struct
       let known_delimiters = [ ':'; ' ' ] in
       String.filter fingerprint ~f:(fun c ->
         not (List.exists known_delimiters ~f:(Char.equal c)))
-      |> Cstruct.of_hex
+      |> Ohex.decode
     ;;
 
     let of_cas ~time ({ trust_anchors; allowed_hashes; crls } : Chain_of_trust.t) =
@@ -156,7 +156,7 @@ end
 module Distinguished_name = struct
   include X509.Distinguished_name
 
-  let decode_der = Or_error.lift_result_msg_of_cstruct decode_der
+  let decode_der = Or_error.lift_result_msg_of_string decode_der
 end
 
 module OCSP = struct
@@ -169,7 +169,7 @@ module OCSP = struct
       create ?certs ?digest ?requestor_name ?key cert_ids |> Or_error.of_result_msg
     ;;
 
-    let decode_der = Or_error.lift_asn_error_of_cstruct decode_der
+    let decode_der = Or_error.lift_asn_error_of_string decode_der
   end
 
   module Response = struct
@@ -196,14 +196,14 @@ module OCSP = struct
     ;;
 
     let responses t = responses t |> Or_error.of_result_msg
-    let decode_der = Or_error.lift_asn_error_of_cstruct decode_der
+    let decode_der = Or_error.lift_asn_error_of_string decode_der
   end
 end
 
 module PKCS12 = struct
   include X509.PKCS12
 
-  let decode_der = Or_error.lift_result_msg_of_cstruct decode_der
+  let decode_der = Or_error.lift_result_msg_of_string decode_der
   let verify password t = verify password t |> Or_error.of_result_msg
 end
 
@@ -213,11 +213,10 @@ module Private_key = struct
   let sign hash ?scheme key data =
     sign hash ?scheme key data
     |> Or_error.of_result_msg
-    |> Or_error.map ~f:Cstruct.to_string
   ;;
 
-  let decode_der = Or_error.lift_result_msg_of_cstruct decode_der
-  let decode_pem = Or_error.lift_result_msg_of_cstruct decode_pem
+  let decode_der = Or_error.lift_result_msg_of_string decode_der
+  let decode_pem = Or_error.lift_result_msg_of_string decode_pem
 
   let of_pem_file file =
     let%map contents = Reader.file_contents file in
@@ -229,27 +228,21 @@ module Public_key = struct
   include X509.Public_key
 
   let verify hash ?scheme ~signature key data =
-    let signature = Cstruct.of_string signature in
-    let data =
-      match data with
-      | `Digest data -> `Digest (Cstruct.of_string data)
-      | `Message data -> `Message (Cstruct.of_string data)
-    in
     verify hash ?scheme ~signature key data |> Or_error.of_result_msg
   ;;
 
-  let decode_der = Or_error.lift_result_msg_of_cstruct decode_der
-  let decode_pem = Or_error.lift_result_msg_of_cstruct decode_pem
+  let decode_der = Or_error.lift_result_msg_of_string decode_der
+  let decode_pem = Or_error.lift_result_msg_of_string decode_pem
 end
 
 module Signing_request = struct
   include X509.Signing_request
 
   let decode_der ?allowed_hashes der =
-    Cstruct.of_string der |> decode_der ?allowed_hashes |> Or_error.of_result_msg
+    decode_der ?allowed_hashes der |> Or_error.of_result_msg
   ;;
 
-  let decode_pem pem = Cstruct.of_string pem |> decode_pem |> Or_error.of_result_msg
+  let decode_pem pem = decode_pem pem |> Or_error.of_result_msg
 
   let create subject ?digest ?extensions key =
     create subject ?digest ?extensions key |> Or_error.of_result_msg
diff --git a/async/x509_async.mli b/async/x509_async.mli
index cadd4c02..9bf35368 100644
--- a/async/x509_async.mli
+++ b/async/x509_async.mli
@@ -14,14 +14,14 @@ module Authenticator : sig
     type t
 
     val ca_file
-      :  ?allowed_hashes:Mirage_crypto.Hash.hash list
+      :  ?allowed_hashes:Digestif.hash' list
       -> ?crls:Filename.t
       -> Filename.t
       -> unit
       -> t
 
     val ca_dir
-      :  ?allowed_hashes:Mirage_crypto.Hash.hash list
+      :  ?allowed_hashes:Digestif.hash' list
       -> ?crls:Filename.t
       -> Filename.t
       -> unit
@@ -30,14 +30,14 @@ module Authenticator : sig
     (** The fingerprint can be collected from a browser or by invoking an openssl command
         like 'openssl x509 -in <pem_file> -noout -fingerprint -sha256' *)
     val cert_fingerprint
-      :  Mirage_crypto.Hash.hash
+      :  Digestif.hash'
       -> string
       -> t
 
     (** The fingerprint can be collected from a browser or by invoking an openssl command
         like 'openssl x509 -in <pem_file> -noout -pubkey | openssl pkey -pubin -outform DER | openssl dgst -sha256' *)
     val key_fingerprint
-      :  Mirage_crypto.Hash.hash
+      :  Digestif.hash'
       -> string
       -> t
 
@@ -58,10 +58,10 @@ module Private_key : sig
   end
 
   val sign
-    :  Mirage_crypto.Hash.hash
+    :  Digestif.hash'
     -> ?scheme:Key_type.signature_scheme
     -> t
-    -> [ `Digest of Cstruct.t | `Message of Cstruct.t ]
+    -> [ `Digest of string | `Message of string ]
     -> string Or_error.t
 
   val decode_der : contents:string -> t Or_error.t
@@ -75,7 +75,7 @@ module Public_key : sig
   end
 
   val verify
-    :  Mirage_crypto.Hash.hash
+    :  Digestif.hash'
     -> ?scheme:Key_type.signature_scheme
     -> signature:string
     -> t
@@ -114,7 +114,7 @@ module CRL : sig
   val decode_der : contents:string -> t Or_error.t
 
   val revoke
-    :  ?digest:Mirage_crypto.Hash.hash
+    :  ?digest:Digestif.hash'
     -> issuer:Distinguished_name.t
     -> this_update:Ptime.t
     -> ?next_update:Ptime.t
@@ -154,7 +154,7 @@ module OCSP : sig
 
     val create
       :  ?certs:Certificate.t list
-      -> ?digest:Mirage_crypto.Hash.hash
+      -> ?digest:Digestif.hash'
       -> ?requestor_name:General_name.b
       -> ?key:Private_key.t
       -> cert_id list
@@ -169,7 +169,7 @@ module OCSP : sig
     end
 
     val create_success
-      :  ?digest:Mirage_crypto.Hash.hash
+      :  ?digest:Digestif.hash'
       -> ?certs:Certificate.t list
       -> ?response_extensions:Extension.t
       -> Private_key.t
@@ -207,20 +207,20 @@ module Signing_request : sig
     include Signing_request
   end
 
-  val decode_der : ?allowed_hashes:Mirage_crypto.Hash.hash list -> string -> t Or_error.t
+  val decode_der : ?allowed_hashes:Digestif.hash' list -> string -> t Or_error.t
   val decode_pem : string -> t Or_error.t
 
   val create
     :  Distinguished_name.t
-    -> ?digest:Mirage_crypto.Hash.hash
+    -> ?digest:Digestif.hash'
     -> ?extensions:Ext.t
     -> Private_key.t
     -> t Or_error.t
 
   val sign
-    :  ?allowed_hashes:Mirage_crypto.Hash.hash list
-    -> ?digest:Mirage_crypto.Hash.hash
-    -> ?serial:Z.t
+    :  ?allowed_hashes:Digestif.hash' list
+    -> ?digest:Digestif.hash'
+    -> ?serial:string
     -> ?extensions:Extension.t
     -> t
     -> Private_key.t

From 71bd0105c11dc97c3c23bb67a86fc4410ce2c087 Mon Sep 17 00:00:00 2001
From: Calascibetta Romain <romain.calascibetta@gmail.com>
Date: Thu, 27 Jun 2024 06:18:02 +0200
Subject: [PATCH 9/9] tls-mirage keeps cstruct but we do casts internally

---
 mirage/tls_mirage.ml  | 24 +++++++++++++-----------
 mirage/tls_mirage.mli |  2 +-
 2 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/mirage/tls_mirage.ml b/mirage/tls_mirage.ml
index 6df07126..7938345d 100644
--- a/mirage/tls_mirage.ml
+++ b/mirage/tls_mirage.ml
@@ -27,7 +27,7 @@ module Make (F : Mirage_flow.S) = struct
                      | `Write_closed of Tls.Engine.state
                      | `Closed
                      | `Error of error ] ;
-    mutable linger : Cstruct.t list ;
+    mutable linger : string list ;
   }
 
   let half_close state mode =
@@ -51,7 +51,7 @@ module Make (F : Mirage_flow.S) = struct
   let tls_fail f  = `Error (`Tls_failure f)
 
   let write_flow flow buf =
-    F.write flow.flow buf >>= function
+    F.write flow.flow (Cstruct.of_string buf) >>= function
     | Ok _ as o -> Lwt.return o
     | Error `Closed ->
       flow.state <- half_close flow.state `write;
@@ -70,14 +70,14 @@ module Make (F : Mirage_flow.S) = struct
         ( match resp with
           | None     -> Lwt.return @@ Ok ()
           | Some buf -> write_flow flow buf) >>= fun _ ->
-        Lwt.return @@ `Ok data
+        Lwt.return @@ `Ok (Option.map Cstruct.of_string data)
       | Error (fail, `Response resp) ->
         let reason = match fail with
           | `Alert a -> tls_alert a
           | f -> tls_fail f
         in
         flow.state <- reason ;
-        F.write flow.flow resp >>= fun _ ->
+        F.write flow.flow (Cstruct.of_string resp) >>= fun _ ->
         Lwt.return reason
     in
     match flow.state with
@@ -92,7 +92,7 @@ module Make (F : Mirage_flow.S) = struct
         flow.state <- half_close flow.state `read;
         Lwt.return `Eof
       | Ok `Data buf -> match flow.state with
-        | `Active tls | `Write_closed tls -> handle tls buf
+        | `Active tls | `Write_closed tls -> handle tls (Cstruct.to_string buf)
         | `Read_closed _ | `Closed -> Lwt.return `Eof
         | `Error _ as e -> Lwt.return e
 
@@ -106,13 +106,15 @@ module Make (F : Mirage_flow.S) = struct
           | `Error e       -> Lwt.return @@ Error e )
     | bufs ->
       flow.linger <- [] ;
-      Lwt.return @@ Ok (`Data (Cstruct.concat @@ List.rev bufs))
+      let str = String.concat "" (List.rev bufs) in
+      Lwt.return @@ Ok (`Data (Cstruct.of_string str))
 
   let writev flow bufs =
     match flow.state with
     | `Closed | `Write_closed _ -> Lwt.return @@ Error `Closed
     | `Error e -> Lwt.return @@ Error (e :> write_error)
     | `Active tls | `Read_closed tls ->
+        let bufs = List.map Cstruct.to_string bufs in
         match Tls.Engine.send_application_data tls bufs with
         | Some (tls, answer) ->
             flow.state <- `Active tls ;
@@ -138,7 +140,7 @@ module Make (F : Mirage_flow.S) = struct
       (* read_react re-throws *)
         read_react flow >>= function
         | `Ok mbuf ->
-            flow.linger <- Option.to_list mbuf @ flow.linger ;
+            flow.linger <- Option.(to_list (map Cstruct.to_string mbuf)) @ flow.linger ;
             drain_handshake flow
         | `Error e -> Lwt.return @@ Error (e :> write_error)
         | `Eof     -> Lwt.return @@ Error `Closed
@@ -273,13 +275,13 @@ module X509 (KV : Mirage_kv.RO) (C: Mirage_clock.PCLOCK) = struct
     | None -> Lwt.return None
     | Some filename ->
       read kv (Mirage_kv.Key.v filename) >>= fun data ->
-      err_fail pp_msg (X509.CRL.decode_der data) >|= fun crl ->
+      err_fail pp_msg (X509.CRL.decode_der (Cstruct.to_string data)) >|= fun crl ->
       Some [ crl ]
 
   let authenticator ?allowed_hashes ?crl kv =
     let time () = Some (Ptime.v (C.now_d_ps ())) in
     let now = Ptime.v (C.now_d_ps ()) in
-    read kv ca_roots_file >>=
+    read kv ca_roots_file >|= Cstruct.to_string >>=
     decode_or_fail X509.Certificate.decode_pem_multiple >>= fun cas ->
     let ta = X509.Validation.valid_cas ~time:now cas in
     read_crl kv crl >|= fun crls ->
@@ -287,9 +289,9 @@ module X509 (KV : Mirage_kv.RO) (C: Mirage_clock.PCLOCK) = struct
 
   let certificate kv =
     let read name =
-      read kv (Mirage_kv.Key.v (name ^ ".pem")) >>=
+      read kv (Mirage_kv.Key.v (name ^ ".pem")) >|= Cstruct.to_string >>=
       decode_or_fail X509.Certificate.decode_pem_multiple >>= fun certs ->
-      read kv (Mirage_kv.Key.v (name ^ ".key")) >>=
+      read kv (Mirage_kv.Key.v (name ^ ".key")) >|= Cstruct.to_string >>=
       decode_or_fail X509.Private_key.decode_pem >|= fun pk ->
       (certs, pk)
     in function | `Default   -> read default_cert
diff --git a/mirage/tls_mirage.mli b/mirage/tls_mirage.mli
index 2c32df1d..d68593c6 100644
--- a/mirage/tls_mirage.mli
+++ b/mirage/tls_mirage.mli
@@ -60,7 +60,7 @@ module X509 (KV : Mirage_kv.RO) (C : Mirage_clock.PCLOCK) : sig
       If [crl] is provided, the corresponding file is read and used as
       revocation list (DER encoded). Both options only apply if [`CAs] is used.
  *)
-  val authenticator : ?allowed_hashes:Mirage_crypto.Hash.hash list -> ?crl:string ->
+  val authenticator : ?allowed_hashes:Digestif.hash' list -> ?crl:string ->
     KV.t -> X509.Authenticator.t Lwt.t
 
   (** [certificate store typ] unmarshals a certificate chain and
