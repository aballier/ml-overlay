From 0ad9f7a40ba5e112842765f05535553f17b6f97f Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Tue, 13 Aug 2024 20:53:44 +0100
Subject: [PATCH] v0.17~preview.129.36+325

---
 bigstring_unix/src/bigstring_unix.ml          |    2 +-
 bigstring_unix/src/bigstring_unix.mli         |   12 +-
 bigstring_unix/src/bigstring_unix_stubs.c     |  143 +-
 bigstring_unix/src/dune                       |    3 +-
 bigstring_unix/src/recvmmsg.c                 |   16 +-
 bigstring_unix/src/recvmmsg.h                 |    5 +-
 bigstring_unix/test/dune                      |    4 +-
 bigstring_unix/test/test_bigstring_unix.ml    |    4 +-
 .../src/command_test_helpers.mli              |    2 +-
 command_test_helpers/test/src/dune            |    2 +-
 .../test/src/test_command_test_helpers.ml     |    2 +-
 .../test/src/test_complete.ml                 |   27 +-
 .../test/src/test_validate_command.ml         |    2 +-
 command_unix/src/command_unix.ml              |   28 +-
 command_unix/src/dune                         |    2 +-
 .../test-bin/command_shape_test_shared.ml     |    8 +-
 command_unix/test/dune                        |    3 +-
 command_unix/test/test_command.ml             |   39 +-
 command_unix/test/test_command_arg_map.ml     |    6 +-
 command_unix/test/test_command_choose_one.ml  |   45 +-
 command_unix/test/test_command_completion.ml  |   30 +-
 command_unix/test/test_command_env.ml         |    3 +-
 command_unix/test/test_command_escape_anon.ml |    5 +-
 core_thread/src/dune                          |    3 +-
 core_thread/src/pthread_np_stubs.c            |    6 +-
 core_unix/example/dune                        |    2 +-
 core_unix/src/core_unix.ml                    |  153 +-
 core_unix/src/core_unix.mli                   |   56 +-
 core_unix/src/core_unix_stubs.c               |  158 +-
 core_unix/src/core_unix_time_stubs.c          |   31 +-
 core_unix/src/dune                            |    2 +-
 core_unix/src/nss_stubs.c                     |   16 +-
 core_unix/test-manual/dune                    |    2 +-
 .../test-manual/getgrgid_thread_safety.ml     |   14 +-
 core_unix/test/cidr_tests.ml                  |    9 +-
 core_unix/test/test_iovec.ml                  |   54 +-
 core_unix/test/test_unix.ml                   |   68 +-
 core_unix/test/test_unix_cidr.ml              |   16 +-
 daemon/test-bin/dune                          |    2 +-
 date_unix/src/dune                            |    2 +-
 date_unix/test/dune                           |    2 +-
 error_checking_mutex/test/dune                |    2 +-
 .../test/test_error_checking_mutex.ml         |    4 +-
 filename_unix/src/dune                        |    2 +-
 filename_unix/test/dune                       |    4 +-
 filename_unix/test/test_filename_unix.ml      |    1 -
 interval_lib/src/dune                         |    2 +-
 interval_lib/src/interval.ml                  |   83 +-
 interval_lib/src/interval_intf.ml             |   46 +-
 interval_lib/test/test_interval.ml            |   97 +-
 interval_unix/src/dune                        |    2 +-
 interval_unix/test/dune                       |    4 +-
 interval_unix/test/test_interval_unix.ml      |    2 +-
 iobuf_unix/src/dune                           |    2 +-
 iobuf_unix/src/iobuf_stubs.c                  |    2 +
 iobuf_unix/src/iobuf_unix.ml                  |    4 +-
 iobuf_unix/src/iobuf_unix.mli                 |   14 +-
 iobuf_unix/test/dune                          |    4 +-
 iobuf_unix/test/test_iobuf_unix.ml            |   86 +-
 linux_ext/bench/dune                          |    2 +-
 linux_ext/src/dune                            |    4 +-
 linux_ext/src/epoll.ml                        |   96 +-
 linux_ext/src/linux_ext.ml                    |  102 +-
 linux_ext/src/linux_ext_intf.ml               |   16 +-
 linux_ext/src/linux_ext_stubs.c               |   93 +-
 linux_ext/test/dune                           |    5 +-
 linux_ext/test/test_linux_ext.ml              |   66 +-
 lock_file_blocking/src/dune                   |    3 +-
 lock_file_blocking/src/lock_file_blocking.ml  |  229 +-
 lock_file_blocking/src/lock_file_blocking.mli |  110 +-
 lock_file_blocking/src/nfs_lock.ml            |  416 +++
 lock_file_blocking/src/nfs_lock.mli           |  108 +
 lock_file_blocking/src/shared.ml              |   56 +
 lock_file_blocking/src/shared.mli             |   12 +
 lock_file_blocking/test-bin/dune              |    2 +-
 lock_file_blocking/test-bin/jbuild-ignore     |    1 +
 .../test-bin/test_lock_file_blocking.ml       |  132 +-
 lock_file_blocking/test/dune                  |    4 +-
 .../test/test_lock_file_blocking.ml           |  132 +-
 nano_mutex/src/nano_mutex.ml                  |   14 +-
 nano_mutex/test/dune                          |    2 +-
 ocaml_c_utils/src/dune                        |    2 +-
 ocaml_c_utils/src/ocaml_c_utils_stubs.c       |    2 +
 process_env/test/dune                         |    2 +-
 signal_unix/src/dune                          |    2 +-
 sys_unix/src/sys_unix.ml                      |    2 +-
 sys_unix/src/sys_unix.mli                     |    2 +-
 sys_unix/src/sys_unix_stubs.c                 |    4 +-
 sys_unix/test/dune                            |    2 +-
 sys_unix/test/test_sys_unix.ml                |    3 +-
 syslog/src/syslog.mli                         |    2 +-
 time_float_unix/bench-bin/dune                |    2 +-
 time_float_unix/bench/bench_time.ml           | 1388 +--------
 time_float_unix/bench/dune                    |    2 +-
 time_float_unix/src/dune                      |    3 +-
 time_float_unix/src/time_float_unix.ml        |  262 +-
 time_float_unix/src/time_float_unix.mli       |  170 +-
 time_float_unix/src/time_functor.ml           |  372 ---
 time_float_unix/src/time_functor.mli          |    1 -
 time_float_unix/src/time_functor_intf.ml      |  353 ---
 time_float_unix/test/dune                     |    4 +-
 time_float_unix/test/test_container_sexps.ml  |    5 +-
 time_float_unix/test/test_time_transitions.ml |   31 +-
 time_float_unix/test/test_time_unix.ml        |   89 +-
 time_float_unix/test/test_time_unix_legacy.ml |   57 +-
 time_float_unix/test/test_zone.ml             |   14 +-
 time_ns_unix/bench/bench_time_ns_unix.ml      | 2737 +----------------
 time_ns_unix/bench/dune                       |    2 +-
 time_ns_unix/src/dune                         |    3 +-
 time_ns_unix/src/time_ns_unix.ml              |  451 ---
 time_ns_unix/src/time_ns_unix.mli             |   67 +-
 time_ns_unix/src/time_ns_unix_intf.ml         |  361 ---
 time_ns_unix/test/dune                        |    4 +-
 time_ns_unix/test/test_time_ns_unix.ml        |  227 +-
 time_stamp_counter/src/time_stamp_counter.ml  |   38 +-
 time_stamp_counter/src/time_stamp_counter.mli |   34 +-
 .../src/time_stamp_counter_stubs.wat          |   49 +
 .../test/test_time_stamp_counter.ml           |    3 +-
 unix_pseudo_terminal/test/testpty.ml          |    2 +-
 uuid_unix/bench/dune                          |    2 +-
 uuid_unix/test/dune                           |    3 +-
 uuid_unix/test/test_uuid.ml                   |    8 +-
 123 files changed, 2241 insertions(+), 7484 deletions(-)
 create mode 100644 lock_file_blocking/src/nfs_lock.ml
 create mode 100644 lock_file_blocking/src/nfs_lock.mli
 create mode 100644 lock_file_blocking/src/shared.ml
 create mode 100644 lock_file_blocking/src/shared.mli
 create mode 100644 lock_file_blocking/test-bin/jbuild-ignore
 delete mode 100644 time_float_unix/src/time_functor.ml
 delete mode 100644 time_float_unix/src/time_functor.mli
 delete mode 100644 time_float_unix/src/time_functor_intf.ml
 delete mode 100644 time_ns_unix/src/time_ns_unix_intf.ml
 create mode 100644 time_stamp_counter/src/time_stamp_counter_stubs.wat

diff --git a/bigstring_unix/src/bigstring_unix.ml b/bigstring_unix/src/bigstring_unix.ml
index ab785dd..2f1f0ff 100644
--- a/bigstring_unix/src/bigstring_unix.ml
+++ b/bigstring_unix/src/bigstring_unix.ml
@@ -232,7 +232,7 @@ external unsafe_send_nonblocking_no_sigpipe
   -> t
   -> Syscall_result.Int.t
   = "bigstring_send_nonblocking_no_sigpipe_stub"
-  [@@noalloc]
+[@@noalloc]
 
 let send_nonblocking_no_sigpipe fd ?(pos = 0) ?len bstr =
   let len = get_opt_len bstr ~pos len in
diff --git a/bigstring_unix/src/bigstring_unix.mli b/bigstring_unix/src/bigstring_unix.mli
index 6328131..e37409f 100644
--- a/bigstring_unix/src/bigstring_unix.mli
+++ b/bigstring_unix/src/bigstring_unix.mli
@@ -200,7 +200,7 @@ val really_send_no_sigpipe
      -> ?len:int (** default = [length bstr - pos] *)
      -> t
      -> unit)
-    Or_error.t
+      Or_error.t
 
 (** [send_nonblocking_no_sigpipe sock ?pos ?len bstr] tries to send [len] bytes in
     bigstring [bstr] starting at position [pos] to socket [sock]. Returns [bytes_written].
@@ -212,7 +212,7 @@ val send_nonblocking_no_sigpipe
      -> ?len:int (** default = [length bstr - pos] *)
      -> t
      -> Unix.Syscall_result.Int.t)
-    Or_error.t
+      Or_error.t
 
 (** [sendto_nonblocking_no_sigpipe sock ?pos ?len bstr sockaddr] tries to send [len] bytes
     in bigstring [bstr] starting at position [pos] to socket [sock] using address
@@ -226,7 +226,7 @@ val sendto_nonblocking_no_sigpipe
      -> t
      -> Unix.sockaddr
      -> Unix.Syscall_result.Int.t)
-    Or_error.t
+      Or_error.t
 
 (** [write fd ?pos ?len bstr] writes [len] bytes in bigstring [bstr] starting at position
     [pos] to file descriptor [fd].  Returns the number of bytes actually written.
@@ -320,7 +320,7 @@ val recvmmsg_assume_fd_is_nonblocking
      -> t Unix.IOVec.t array
      -> lens:int array
      -> int)
-    Or_error.t
+      Or_error.t
 
 val unsafe_recvmmsg_assume_fd_is_nonblocking
   : (Unix.File_descr.t
@@ -329,7 +329,7 @@ val unsafe_recvmmsg_assume_fd_is_nonblocking
      -> Unix.sockaddr array option
      -> int array
      -> int)
-    Or_error.t
+      Or_error.t
 
 (** [sendmsg_nonblocking_no_sigpipe sock ?count iovecs] sends [count] [iovecs] of
     bigstrings to socket [sock]. Returns [Some bytes_written], or [None] if the operation
@@ -343,7 +343,7 @@ val sendmsg_nonblocking_no_sigpipe
      -> ?count:int (** default = [Array.length iovecs] *)
      -> t Unix.IOVec.t array
      -> int option)
-    Or_error.t
+      Or_error.t
 
 (** [output ?min_len oc ?pos ?len bstr] tries to output [len] bytes (guarantees to write
     at least [min_len] bytes, which must be [>= 0]), if possible, before returning, from
diff --git a/bigstring_unix/src/bigstring_unix_stubs.c b/bigstring_unix/src/bigstring_unix_stubs.c
index 604ab1a..0d4c7df 100644
--- a/bigstring_unix/src/bigstring_unix_stubs.c
+++ b/bigstring_unix/src/bigstring_unix_stubs.c
@@ -1,3 +1,5 @@
+#undef Hide_upstream_size_macros
+
 #include "config.h"
 
 #define _FILE_OFFSET_BITS 64
@@ -84,8 +86,7 @@ static inline void raise_io_error(value v_n_good, value v_exc) {
   raise_with_two_args(*bigstring_exc_IOError, v_n_good, v_exc);
 }
 
-static inline value mk_unix_error_exn(int errcode, char *cmdname,
-                                      value cmdarg) {
+static inline value mk_unix_error_exn(int errcode, char *cmdname, value cmdarg) {
   CAMLparam0();
   CAMLlocal3(name, err, arg);
   value res;
@@ -104,8 +105,7 @@ static inline value mk_uerror_exn(char *cmdname, value cmdarg) {
   return mk_unix_error_exn(errno, cmdname, cmdarg);
 }
 
-static inline void raise_unix_io_error(value v_n_good, char *cmdname,
-                                       value cmdarg) {
+static inline void raise_unix_io_error(value v_n_good, char *cmdname, value cmdarg) {
   value v_uerror = mk_uerror_exn(cmdname, cmdarg);
   raise_io_error(v_n_good, v_uerror);
 }
@@ -117,8 +117,8 @@ static inline void raise_eof_io_error(value v_n_good) {
 
 /* Input of bigstrings from file descriptors */
 
-CAMLprim value bigstring_read_stub(value v_min_len, value v_fd, value v_pos,
-                                   value v_len, value v_bstr) {
+CAMLprim value bigstring_read_stub(value v_min_len, value v_fd, value v_pos, value v_len,
+                                   value v_bstr) {
   CAMLparam1(v_bstr);
   size_t min_len = Long_val(v_min_len);
   int fd = Int_val(v_fd);
@@ -152,10 +152,8 @@ CAMLprim value bigstring_read_stub(value v_min_len, value v_fd, value v_pos,
   CAMLreturn(Val_long(bstr - bstr_start));
 }
 
-CAMLprim value bigstring_read_assume_fd_is_nonblocking_stub(value v_fd,
-                                                            value v_pos,
-                                                            value v_len,
-                                                            value v_bstr) {
+CAMLprim value bigstring_read_assume_fd_is_nonblocking_stub(value v_fd, value v_pos,
+                                                            value v_len, value v_bstr) {
   struct caml_ba_array *ba = Caml_ba_array_val(v_bstr);
   char *bstr = (char *)ba->data + Long_val(v_pos);
   size_t len = Long_val(v_len);
@@ -202,6 +200,7 @@ CAMLprim value bigstring_pread_stub(value v_min_len, value v_fd, value v_offset,
         raise_unix_io_error(v_n_good, "pread", Nothing);
     } else {
       bstr += n_read;
+      offset += n_read;
       len -= n_read;
     }
   } while (bstr < bstr_min);
@@ -211,12 +210,12 @@ CAMLprim value bigstring_pread_stub(value v_min_len, value v_fd, value v_offset,
 
 CAMLprim value bigstring_pread_bytecode(value *argv, int argn) {
   assert(argn == 6);
-  return bigstring_pread_stub(argv[0], argv[1], argv[2], argv[3], argv[4],
-                              argv[5]);
+  return bigstring_pread_stub(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
 }
 
-CAMLprim value bigstring_pread_assume_fd_is_nonblocking_stub(
-    value v_fd, value v_offset, value v_pos, value v_len, value v_bstr) {
+CAMLprim value bigstring_pread_assume_fd_is_nonblocking_stub(value v_fd, value v_offset,
+                                                             value v_pos, value v_len,
+                                                             value v_bstr) {
   char *bstr = get_bstr(v_bstr, v_pos);
   size_t len = Long_val(v_len);
   ssize_t n_read;
@@ -230,8 +229,7 @@ CAMLprim value bigstring_pread_assume_fd_is_nonblocking_stub(
 /* Input of bigstrings from sockets */
 
 CAMLprim value bigstring_recv_peek_assume_fd_is_nonblocking_stub(value v_sock,
-                                                                 value v_pos,
-                                                                 value v_len,
+                                                                 value v_pos, value v_len,
                                                                  value v_bstr) {
   CAMLparam4(v_sock, v_pos, v_len, v_bstr);
   size_t len = Long_val(v_len);
@@ -248,8 +246,8 @@ CAMLprim value bigstring_recv_peek_assume_fd_is_nonblocking_stub(value v_sock,
   }
 }
 
-CAMLprim value bigstring_really_recv_stub(value v_sock, value v_pos,
-                                          value v_len, value v_bstr) {
+CAMLprim value bigstring_really_recv_stub(value v_sock, value v_pos, value v_len,
+                                          value v_bstr) {
   size_t len = Long_val(v_len);
   if (len == 0)
     return Val_long(0);
@@ -282,8 +280,7 @@ CAMLprim value bigstring_really_recv_stub(value v_sock, value v_pos,
   }
 }
 
-CAMLprim value bigstring_recvfrom_assume_fd_is_nonblocking_stub(value v_sock,
-                                                                value v_pos,
+CAMLprim value bigstring_recvfrom_assume_fd_is_nonblocking_stub(value v_sock, value v_pos,
                                                                 value v_len,
                                                                 value v_bstr) {
   CAMLparam1(v_bstr);
@@ -501,33 +498,33 @@ CAMLprim value bigstring_output_stub(value v_min_len, value v_chan, value v_pos,
 
 /* Output macros and functions */
 
-#define MakeReallyOutputFun(NAME, CALL_WRITE)                                  \
-  CAMLprim value bigstring_really_##NAME##_stub(value v_fd, value v_pos,       \
-                                                value v_len, value v_bstr) {   \
-    CAMLparam1(v_bstr);                                                        \
-    int fd = Int_val(v_fd);                                                    \
-    size_t len = Long_val(v_len);                                              \
-    ssize_t written;                                                           \
-    char *bstr_start = get_bstr(v_bstr, v_pos);                                \
-    char *bstr = bstr_start;                                                   \
-    char *bstr_max = bstr + len;                                               \
-    caml_enter_blocking_section();                                             \
-    do {                                                                       \
-      CALL_WRITE;                                                              \
-      if (written == -1) {                                                     \
-        if (errno == EINTR)                                                    \
-          continue;                                                            \
-        {                                                                      \
-          value v_n_good = Val_long(bstr - bstr_start);                        \
-          caml_leave_blocking_section();                                       \
-          raise_unix_io_error(v_n_good, STR(really_##NAME), Nothing);          \
-        }                                                                      \
-      };                                                                       \
-      len -= written;                                                          \
-      bstr += written;                                                         \
-    } while (bstr < bstr_max);                                                 \
-    caml_leave_blocking_section();                                             \
-    CAMLreturn(Val_unit);                                                      \
+#define MakeReallyOutputFun(NAME, CALL_WRITE)                                            \
+  CAMLprim value bigstring_really_##NAME##_stub(value v_fd, value v_pos, value v_len,    \
+                                                value v_bstr) {                          \
+    CAMLparam1(v_bstr);                                                                  \
+    int fd = Int_val(v_fd);                                                              \
+    size_t len = Long_val(v_len);                                                        \
+    ssize_t written;                                                                     \
+    char *bstr_start = get_bstr(v_bstr, v_pos);                                          \
+    char *bstr = bstr_start;                                                             \
+    char *bstr_max = bstr + len;                                                         \
+    caml_enter_blocking_section();                                                       \
+    do {                                                                                 \
+      CALL_WRITE;                                                                        \
+      if (written == -1) {                                                               \
+        if (errno == EINTR)                                                              \
+          continue;                                                                      \
+        {                                                                                \
+          value v_n_good = Val_long(bstr - bstr_start);                                  \
+          caml_leave_blocking_section();                                                 \
+          raise_unix_io_error(v_n_good, STR(really_##NAME), Nothing);                    \
+        }                                                                                \
+      };                                                                                 \
+      len -= written;                                                                    \
+      bstr += written;                                                                   \
+    } while (bstr < bstr_max);                                                           \
+    caml_leave_blocking_section();                                                       \
+    CAMLreturn(Val_unit);                                                                \
   }
 
 MakeReallyOutputFun(write, written = write(fd, bstr, len))
@@ -546,8 +543,9 @@ MakeReallyOutputFun(write, written = write(fd, bstr, len))
   CAMLreturn(Val_long(written));
 }
 
-CAMLprim value bigstring_pwrite_assume_fd_is_nonblocking_stub(
-    value v_fd, value v_offset, value v_pos, value v_len, value v_bstr) {
+CAMLprim value bigstring_pwrite_assume_fd_is_nonblocking_stub(value v_fd, value v_offset,
+                                                              value v_pos, value v_len,
+                                                              value v_bstr) {
   char *bstr = get_bstr(v_bstr, v_pos);
   size_t len = Long_val(v_len);
   ssize_t written;
@@ -558,10 +556,8 @@ CAMLprim value bigstring_pwrite_assume_fd_is_nonblocking_stub(
   return Val_long(written);
 }
 
-CAMLprim value bigstring_write_assume_fd_is_nonblocking_stub(value v_fd,
-                                                             value v_pos,
-                                                             value v_len,
-                                                             value v_bstr) {
+CAMLprim value bigstring_write_assume_fd_is_nonblocking_stub(value v_fd, value v_pos,
+                                                             value v_len, value v_bstr) {
   struct caml_ba_array *ba = Caml_ba_array_val(v_bstr);
   char *bstr = (char *)ba->data + Long_val(v_pos);
   size_t len = Long_val(v_len);
@@ -580,8 +576,7 @@ CAMLprim value bigstring_write_assume_fd_is_nonblocking_stub(value v_fd,
 }
 
 static inline ssize_t writev_in_blocking_section(value v_fd, value v_iovecs,
-                                                 struct iovec *iovecs,
-                                                 int count) {
+                                                 struct iovec *iovecs, int count) {
   ssize_t ret;
   CAMLparam1(v_iovecs); /* To protect bigstrings outside of OCaml lock */
   caml_enter_blocking_section();
@@ -591,8 +586,7 @@ static inline ssize_t writev_in_blocking_section(value v_fd, value v_iovecs,
   CAMLreturn(ret);
 }
 
-CAMLprim value bigstring_writev_stub(value v_fd, value v_iovecs,
-                                     value v_count) {
+CAMLprim value bigstring_writev_stub(value v_fd, value v_iovecs, value v_count) {
   int count = Int_val(v_count);
   size_t total_len = 0;
   struct iovec *iovecs = copy_iovecs(&total_len, v_iovecs, count);
@@ -612,8 +606,7 @@ __pure static inline int contains_mmapped(value v_iovecs, int n) {
   return 0;
 }
 
-CAMLprim value bigstring_writev_assume_fd_is_nonblocking_stub(value v_fd,
-                                                              value v_iovecs,
+CAMLprim value bigstring_writev_assume_fd_is_nonblocking_stub(value v_fd, value v_iovecs,
                                                               value v_count) {
   int count = Int_val(v_count);
   size_t total_len = 0;
@@ -688,8 +681,7 @@ CAMLprim value bigstring_recvmmsg_assume_fd_is_nonblocking_stub(
       iovecs[i].iov_len = Long_val(v_len);
     }
 
-    n_read =
-        recvmmsg_assume_fd_is_nonblocking(v_fd, iovecs, count, v_srcs, hdrs);
+    n_read = recvmmsg_assume_fd_is_nonblocking(v_fd, iovecs, count, v_srcs, hdrs);
 
     for (i = 0; (int)i < n_read; i++) {
       Field(v_lens, i) = Val_long(hdrs[i].msg_len);
@@ -704,45 +696,40 @@ CAMLprim value bigstring_recvmmsg_assume_fd_is_nonblocking_stub(
 #if defined(JSC_MSG_NOSIGNAL) || defined(JSC_SO_NOSIGPIPE)
 
 #if defined(JSC_MSG_NOSIGNAL)
-MakeReallyOutputFun(send_no_sigpipe,
-                    written = send(fd, bstr, len, MSG_NOSIGNAL))
+MakeReallyOutputFun(send_no_sigpipe, written = send(fd, bstr, len, MSG_NOSIGNAL))
 
     static int nonblocking_no_sigpipe_flag = MSG_DONTWAIT | MSG_NOSIGNAL;
 #elif defined(JSC_SO_NOSIGPIPE)
-MakeReallyOutputFun(send_no_sigpipe,
-                    written = send(fd, bstr, len, SO_NOSIGPIPE))
+MakeReallyOutputFun(send_no_sigpipe, written = send(fd, bstr, len, SO_NOSIGPIPE))
 
     static int nonblocking_no_sigpipe_flag = MSG_DONTWAIT | SO_NOSIGPIPE;
 #endif
 
-CAMLprim value bigstring_send_nonblocking_no_sigpipe_stub(value v_fd,
-                                                          value v_pos,
-                                                          value v_len,
-                                                          value v_bstr) {
+CAMLprim value bigstring_send_nonblocking_no_sigpipe_stub(value v_fd, value v_pos,
+                                                          value v_len, value v_bstr) {
   char *bstr = get_bstr(v_bstr, v_pos);
-  ssize_t ret =
-      send(Int_val(v_fd), bstr, Long_val(v_len), nonblocking_no_sigpipe_flag);
+  ssize_t ret = send(Int_val(v_fd), bstr, Long_val(v_len), nonblocking_no_sigpipe_flag);
   if (ret == -1)
     ret = -errno;
   return Val_long(ret);
 }
 
-CAMLprim value bigstring_sendto_nonblocking_no_sigpipe_stub(
-    value v_fd, value v_pos, value v_len, value v_bstr, value v_addr) {
+CAMLprim value bigstring_sendto_nonblocking_no_sigpipe_stub(value v_fd, value v_pos,
+                                                            value v_len, value v_bstr,
+                                                            value v_addr) {
   char *bstr = get_bstr(v_bstr, v_pos);
   union sock_addr_union addr;
   socklen_param_type addr_len = sizeof(addr);
   ssize_t ret;
   get_sockaddr(v_addr, &addr, &addr_len);
-  ret = sendto(Int_val(v_fd), bstr, Long_val(v_len),
-               nonblocking_no_sigpipe_flag, &addr.s_gen, addr_len);
+  ret = sendto(Int_val(v_fd), bstr, Long_val(v_len), nonblocking_no_sigpipe_flag,
+               &addr.s_gen, addr_len);
   if (ret == -1)
     ret = -errno;
   return Val_long(ret);
 }
 
-CAMLprim value bigstring_sendmsg_nonblocking_no_sigpipe_stub(value v_fd,
-                                                             value v_iovecs,
+CAMLprim value bigstring_sendmsg_nonblocking_no_sigpipe_stub(value v_fd, value v_iovecs,
                                                              value v_count) {
   int count = Int_val(v_count);
   size_t total_len = 0;
@@ -769,7 +756,7 @@ CAMLprim value bigstring_sendmsg_nonblocking_no_sigpipe_stub(value v_fd,
   return Val_long(ret);
 }
 #else
-#warning                                                                       \
+#warning                                                                                 \
     "Neither MSG_NOSIGNAL nor SO_NOSIGPIPE defined; bigstring_send{,msg}_noblocking_no_sigpipe not implemented"
 #warning "Platform not supported. Please report this."
 #endif /* JSC_MSG_NOSIGNAL || JSC_SO_NOSIGPIPE */
diff --git a/bigstring_unix/src/dune b/bigstring_unix/src/dune
index a5b6227..d857278 100644
--- a/bigstring_unix/src/dune
+++ b/bigstring_unix/src/dune
@@ -1,7 +1,8 @@
 (library
  (foreign_stubs
   (language c)
-  (names bigstring_unix_stubs recvmmsg))
+  (names bigstring_unix_stubs recvmmsg)
+  (flags :standard))
  (name bigstring_unix)
  (public_name core_unix.bigstring_unix)
  (libraries core core_unix ocaml_c_utils)
diff --git a/bigstring_unix/src/recvmmsg.c b/bigstring_unix/src/recvmmsg.c
index 3b7d211..70cf8ef 100644
--- a/bigstring_unix/src/recvmmsg.c
+++ b/bigstring_unix/src/recvmmsg.c
@@ -1,5 +1,7 @@
 #define _GNU_SOURCE /* recvmmsg */
 
+#undef Hide_upstream_size_macros
+
 #include <stdio.h>
 #include <errno.h>
 #include <sys/socket.h>
@@ -12,9 +14,8 @@
 
 #ifdef JSC_RECVMMSG
 
-int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs,
-                                      unsigned count, value v_srcs,
-                                      struct mmsghdr *hdrs) {
+int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs, unsigned count,
+                                      value v_srcs, struct mmsghdr *hdrs) {
   CAMLparam2(v_fd, v_srcs);
   CAMLlocal1(v_sockaddrs);
   size_t total_len = 0;
@@ -24,8 +25,7 @@ int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs,
   int fd;
 
   if ((int)count < 0) {
-    caml_failwith(
-        "recvmmsg_assume_fd_is_nonblocking: apparently negative count");
+    caml_failwith("recvmmsg_assume_fd_is_nonblocking: apparently negative count");
   }
 
   {
@@ -40,8 +40,7 @@ int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs,
     }
     for (i = 0; i < count; i++) {
       hdrs[i].msg_hdr.msg_name = (save_source_addresses ? &addrs[i].s_gen : 0);
-      hdrs[i].msg_hdr.msg_namelen =
-          (save_source_addresses ? sizeof(addrs[i]) : 0);
+      hdrs[i].msg_hdr.msg_namelen = (save_source_addresses ? sizeof(addrs[i]) : 0);
 
 #if DEBUG
       fprintf(stderr, "i=%u, count=%u, save_source_addresses=%d\n", i, count,
@@ -92,8 +91,7 @@ int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs,
         }
 
         for (i = 0; (int)i < n_read; i++) {
-          value addr =
-              alloc_sockaddr(&addrs[i], hdrs[i].msg_hdr.msg_namelen, -1);
+          value addr = alloc_sockaddr(&addrs[i], hdrs[i].msg_hdr.msg_namelen, -1);
           Store_field(v_sockaddrs, i, addr);
         }
       }
diff --git a/bigstring_unix/src/recvmmsg.h b/bigstring_unix/src/recvmmsg.h
index 0bca232..8fabb63 100644
--- a/bigstring_unix/src/recvmmsg.h
+++ b/bigstring_unix/src/recvmmsg.h
@@ -11,9 +11,8 @@
    the from addresses in [v_srcs], if supplied.  Use [hdrs], in
    particular, fully initializing and saving results there, including
    lengths of data read, flags, etc. */
-int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs,
-                                      unsigned count, value v_srcs,
-                                      struct mmsghdr *hdrs);
+int recvmmsg_assume_fd_is_nonblocking(value v_fd, struct iovec *iovecs, unsigned count,
+                                      value v_srcs, struct mmsghdr *hdrs);
 
 #define RECVMMSG_MAX_COUNT 64
 
diff --git a/bigstring_unix/test/dune b/bigstring_unix/test/dune
index e9ce88b..b8d428a 100644
--- a/bigstring_unix/test/dune
+++ b/bigstring_unix/test/dune
@@ -1,6 +1,6 @@
 (library
  (name bistring_unix_test)
- (libraries bigbuffer_blocking bigstring_unix core_thread filename_unix
-   quickcheck_deprecated)
+ (libraries bigbuffer_blocking bigstring_unix core_kernel.caml_unix core
+   core_thread core_unix filename_unix quickcheck_deprecated unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/bigstring_unix/test/test_bigstring_unix.ml b/bigstring_unix/test/test_bigstring_unix.ml
index 1ca17b1..48a04b6 100644
--- a/bigstring_unix/test/test_bigstring_unix.ml
+++ b/bigstring_unix/test/test_bigstring_unix.ml
@@ -66,8 +66,8 @@ let%test_module "recvmmsg smoke" =
       | Ok recvmmsg_assume_fd_is_nonblocking ->
         [%test_pred: (int, exn) Result.t]
           (function
-           | Ok i -> ok_pred i
-           | Error e -> error_pred e)
+            | Ok i -> ok_pred i
+            | Error e -> error_pred e)
           (Result.try_with (fun () ->
              recvmmsg_assume_fd_is_nonblocking fd iovecs ?count ?srcs ~lens))
     ;;
diff --git a/command_test_helpers/src/command_test_helpers.mli b/command_test_helpers/src/command_test_helpers.mli
index 3288b30..755aa84 100644
--- a/command_test_helpers/src/command_test_helpers.mli
+++ b/command_test_helpers/src/command_test_helpers.mli
@@ -20,7 +20,7 @@ val parse_command_line
   -> ?readme:(unit -> string)
   -> 'a Command.Param.t
   -> (?on_error:(unit -> unit) -> ?on_success:('a -> unit) -> string list -> unit)
-     Staged.t
+       Staged.t
 
 val parse_command_line_or_error
   :  ?path:string list
diff --git a/command_test_helpers/test/src/dune b/command_test_helpers/test/src/dune
index 4653129..1db1a6a 100644
--- a/command_test_helpers/test/src/dune
+++ b/command_test_helpers/test/src/dune
@@ -2,6 +2,6 @@
  (name command_test_helpers_test)
  (public_name core_unix.command_test_helpers_test)
  (libraries command_test_helpers command_unix core_kernel.composition_infix
-   core_unix expect_test_helpers_core)
+   core core_unix expect_test_helpers_core)
  (preprocess
   (pps ppx_jane)))
diff --git a/command_test_helpers/test/src/test_command_test_helpers.ml b/command_test_helpers/test/src/test_command_test_helpers.ml
index a1e4514..4d5405e 100644
--- a/command_test_helpers/test/src/test_command_test_helpers.ml
+++ b/command_test_helpers/test/src/test_command_test_helpers.ml
@@ -95,6 +95,6 @@ let%expect_test "parsing values" =
   print_s [%sexp (a : string)];
   [%expect {| XYZ |}];
   let b = commander_arg [ "-bar"; "XYZ" ] in
-  require_equal [%here] (module String) a b;
+  require_equal (module String) a b;
   ()
 ;;
diff --git a/command_test_helpers/test/src/test_complete.ml b/command_test_helpers/test/src/test_complete.ml
index 46b08c7..5d16dcd 100644
--- a/command_test_helpers/test/src/test_complete.ml
+++ b/command_test_helpers/test/src/test_complete.ml
@@ -11,13 +11,15 @@ let%expect_test "simple" =
     ()
   in
   Command_test_helpers.complete param ~args:[ "" ];
-  [%expect {|
+  [%expect
+    {|
     false
     true
     (command.ml.Exit_called (status 0))
     |}];
   Command_test_helpers.complete param ~args:[ "t" ];
-  [%expect {|
+  [%expect
+    {|
     true
     (command.ml.Exit_called (status 0))
     |}];
@@ -33,28 +35,33 @@ let%expect_test "simple" =
     (command.ml.Exit_called (status 0))
     |}];
   Command_test_helpers.complete param ~args:[ "t"; "-f" ];
-  [%expect {|
+  [%expect
+    {|
     -foo
     (command.ml.Exit_called (status 0))
     |}];
   Command_test_helpers.complete param ~args:[ "t"; "-f" ] ~which_arg:0;
-  [%expect {|
+  [%expect
+    {|
     true
     (command.ml.Exit_called (status 0))
     |}];
   Command_test_helpers.complete param ~args:[ "t"; "-b" ];
-  [%expect {|
+  [%expect
+    {|
     -bar
     -build-info
     (command.ml.Exit_called (status 0))
     |}];
   Command_test_helpers.complete param ~args:[ "t"; "-bar" ];
-  [%expect {|
+  [%expect
+    {|
     -bar
     (command.ml.Exit_called (status 0))
     |}];
   Command_test_helpers.complete param ~args:[ "t"; "-bar"; "" ];
-  [%expect {|
+  [%expect
+    {|
     false
     true
     (command.ml.Exit_called (status 0))
@@ -87,12 +94,12 @@ let%expect_test "side effects" =
   in
   let param =
     let%map_open.Command () = anon ("_" %: Arg_type.create ~complete (const ())) in
-    print_cr [%here] [%message "This shouldn't have run."];
+    print_cr [%message "This shouldn't have run."];
     state := "set by param";
     Unix.putenv ~key:var ~data:"set by param"
   in
   Command_test_helpers.complete param ~args:[ "" ];
-  require_compare_equal [%here] (module String) !state set_by_complete;
-  require_compare_equal [%here] (module String) (Sys.getenv_exn var) set_by_complete;
+  require_compare_equal (module String) !state set_by_complete;
+  require_compare_equal (module String) (Sys.getenv_exn var) set_by_complete;
   [%expect {| (command.ml.Exit_called (status 0)) |}]
 ;;
diff --git a/command_test_helpers/test/src/test_validate_command.ml b/command_test_helpers/test/src/test_validate_command.ml
index 7509e6a..3ee69b3 100644
--- a/command_test_helpers/test/src/test_validate_command.ml
+++ b/command_test_helpers/test/src/test_validate_command.ml
@@ -13,7 +13,7 @@ let get_output_or_error command args ~f =
    | Ok () -> ()
    | Error error -> print_s [%sexp (error : Error.t)]
    | exception exn -> print_s [%sexp "Raised", (exn : exn)]);
-  expect_test_output [%here]
+  expect_test_output ()
 ;;
 
 (* Opam cannot distinguish between dependencies of the implementation and dependencies of
diff --git a/command_unix/src/command_unix.ml b/command_unix/src/command_unix.ml
index 5527c39..d475a5c 100644
--- a/command_unix/src/command_unix.ml
+++ b/command_unix/src/command_unix.ml
@@ -2,23 +2,23 @@ open! Core
 module Path = Command.Private.Path
 
 module For_unix = Command.Private.For_unix (struct
-  module Pid = Pid
-  module Signal = Signal
-  module Thread = Core_thread
+    module Pid = Pid
+    module Signal = Signal
+    module Thread = Core_thread
 
-  module Unix = struct
-    include Core_unix
+    module Unix = struct
+      include Core_unix
 
-    let unsafe_getenv = Sys_unix.unsafe_getenv
-    let create_process_env = create_process_env ?setpgid:None
-    let wait pid = ignore (wait (`Pid pid) : Pid.t * Exit_or_signal.t)
-  end
+      let unsafe_getenv = Sys_unix.unsafe_getenv
+      let create_process_env = create_process_env ?setpgid:None
+      let wait pid = ignore (wait (`Pid pid) : Pid.t * Exit_or_signal.t)
+    end
 
-  module Version_util = struct
-    include Version_util
-    module Time = Time_float_unix
-  end
-end)
+    module Version_util = struct
+      include Version_util
+      module Time = Time_float_unix
+    end
+  end)
 
 let run = For_unix.run
 let shape = For_unix.shape
diff --git a/command_unix/src/dune b/command_unix/src/dune
index 2dd8fab..e9f6db0 100644
--- a/command_unix/src/dune
+++ b/command_unix/src/dune
@@ -1,7 +1,7 @@
 (library
  (name command_unix)
  (public_name core_unix.command_unix)
- (libraries core core_thread sys_unix time_float_unix
+ (libraries core core_thread core_unix sys_unix time_float_unix
    core_kernel.version_util)
  (preprocess
   (pps ppx_jane)))
diff --git a/command_unix/test-bin/command_shape_test_shared.ml b/command_unix/test-bin/command_shape_test_shared.ml
index 8548c4a..0b94714 100644
--- a/command_unix/test-bin/command_shape_test_shared.ml
+++ b/command_unix/test-bin/command_shape_test_shared.ml
@@ -26,10 +26,10 @@ let in_child () =
   |> Sexp.of_string
   |> [%of_sexp: t list]
   |> List.iter ~f:(function
-       | Write_stdout -> ignore (Unix.write_substring Unix.stdout ~buf : int)
-       | Write_stderr -> ignore (Unix.write_substring Unix.stderr ~buf : int)
-       | Close_stdout -> Unix.close Unix.stdout
-       | Close_stderr -> Unix.close Unix.stderr)
+    | Write_stdout -> ignore (Unix.write_substring Unix.stdout ~buf : int)
+    | Write_stderr -> ignore (Unix.write_substring Unix.stderr ~buf : int)
+    | Close_stdout -> Unix.close Unix.stdout
+    | Close_stderr -> Unix.close Unix.stderr)
 ;;
 
 let parent_cmd =
diff --git a/command_unix/test/dune b/command_unix/test/dune
index b2b1a84..fd4f0c1 100644
--- a/command_unix/test/dune
+++ b/command_unix/test/dune
@@ -1,6 +1,7 @@
 (library
  (name command_unix_test)
  (libraries textutils.ascii_table async command_test_helpers command_unix
-   expect_test_helpers_async expect_test_patterns)
+   core core_unix expect_test_helpers_async expect_test_helpers_core
+   expect_test_patterns sexp_pretty)
  (preprocess
   (pps ppx_jane)))
diff --git a/command_unix/test/test_command.ml b/command_unix/test/test_command.ml
index 63338d3..1dd3313 100644
--- a/command_unix/test/test_command.ml
+++ b/command_unix/test/test_command.ml
@@ -214,7 +214,8 @@ let%expect_test "basic_or_error works as expected" =
        main)
   in
   run (fun () -> error_s [%message "an error"]);
-  [%expect {|
+  [%expect
+    {|
     "an error"
     (raised (command.ml.Exit_called (status 1)))
     |}];
@@ -398,7 +399,7 @@ let%test_unit _ =
   ; "foo", "../bar", "foo/../bar"
   ]
   |> List.iter ~f:(fun (dir, path, expected) ->
-       [%test_eq: string] (abs_path ~dir path) expected)
+    [%test_eq: string] (abs_path ~dir path) expected)
 ;;
 
 let%expect_test "choose_one strings" =
@@ -512,7 +513,8 @@ let%expect_test "[?verbose_on_parse_error]" =
     (raised (command.ml.Exit_called (status 1)))
     |}];
   test ~verbose_on_parse_error:false ();
-  [%expect {|
+  [%expect
+    {|
     Fail!
     (raised (command.ml.Exit_called (status 1)))
     |}]
@@ -651,7 +653,7 @@ let%expect_test "[and_arg_name]" =
 let truncate_long_lines output =
   String.split output ~on:'\n'
   |> List.map ~f:(fun line ->
-       if String.length line > 80 then String.prefix line 80 ^ " ..." else line)
+    if String.length line > 80 then String.prefix line 80 ^ " ..." else line)
   |> String.concat ~sep:"\n"
 ;;
 
@@ -673,7 +675,7 @@ let%expect_test "double-dash built-in flags" =
     let output1 = run_test_command (args @ [ "-" ^ flag ]) in
     let output2 = run_test_command (args @ [ "--" ^ flag ]) in
     print_string (truncate_long_lines output1);
-    require_compare_equal [%here] (module String) output1 output2
+    require_compare_equal (module String) output1 output2
   in
   run_with_both_flags [] "help";
   [%expect
@@ -695,7 +697,8 @@ let%expect_test "double-dash built-in flags" =
     (command.ml.Exit_called (status 0))
     |}];
   run_with_both_flags [] "version";
-  [%expect {|
+  [%expect
+    {|
     NO_VERSION_UTIL
     (command.ml.Exit_called (status 0))
     |}];
@@ -753,7 +756,8 @@ let%expect_test "when_parsing_succeeds" =
       command
   in
   run [ "-input"; "test" ];
-  [%expect {|
+  [%expect
+    {|
     Parsing Succeeded
     test
     |}];
@@ -806,18 +810,18 @@ let%expect_test "global normalized path and args" =
   in
   let print_normalized_path_and_args () =
     let default = "<NO-VALUE>" in
-    let normalized_path =
-      Command.For_telemetry.normalized_path ()
-      |> Option.value_map ~f:(String.concat ~sep:" ") ~default
-    in
-    let normalized_args =
-      Command.For_telemetry.normalized_args ()
-      |> Option.value_map ~f:(String.concat ~sep:" ") ~default
+    let normalized_path, normalized_args =
+      match Command.For_telemetry.normalized_path_and_args () with
+      | `Ok (`Path path, `Args args) ->
+        let concat = String.concat ~sep:" " in
+        concat path, concat args
+      | `Not_initialized_through_command -> default, default
     in
     printf "Normalized path: %s\nNormalized args: %s\n" normalized_path normalized_args
   in
   print_normalized_path_and_args ();
-  [%expect {|
+  [%expect
+    {|
     Normalized path: __exe_name__
     Normalized args:
     |}];
@@ -854,7 +858,7 @@ let%expect_test "special cased help before group member" =
     |}];
   (* A corner case of parsing--make sure that we don't break horribly on this command
      line, though we do see it as unclear. *)
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Command_unix.run ~argv:[ "binary"; "-help"; "-help"; "group" ] Simple_group.command);
   [%expect
     {|
@@ -895,7 +899,8 @@ let%expect_test "lazy Arg_type" =
   [%expect {| |}];
   (* Completions should still work. *)
   Command_test_helpers.complete param ~args:[ "t" ];
-  [%expect {|
+  [%expect
+    {|
     true
     (command.ml.Exit_called (status 0))
     |}]
diff --git a/command_unix/test/test_command_arg_map.ml b/command_unix/test/test_command_arg_map.ml
index 3af5fdb..fee8cec 100644
--- a/command_unix/test/test_command_arg_map.ml
+++ b/command_unix/test/test_command_arg_map.ml
@@ -11,10 +11,10 @@ let%expect_test "raising in arg types" =
     |> unstage
   in
   (* does not raise at all *)
-  require_does_not_raise [%here] (fun () -> test [ "true" ]);
+  require_does_not_raise (fun () -> test [ "true" ]);
   [%expect {| |}];
   (* raises in constructed arg type *)
-  require_does_raise [%here] (fun () -> test [ "not a boolean" ]);
+  require_does_raise (fun () -> test [ "not a boolean" ]);
   [%expect
     {|
     Error parsing command line:
@@ -29,7 +29,7 @@ let%expect_test "raising in arg types" =
     (command.ml.Exit_called (status 1))
     |}];
   (* raises in map function *)
-  require_does_raise [%here] (fun () -> test [ "false" ]);
+  require_does_raise (fun () -> test [ "false" ]);
   [%expect
     {|
     Error parsing command line:
diff --git a/command_unix/test/test_command_choose_one.ml b/command_unix/test/test_command_choose_one.ml
index 3244821..b071174 100644
--- a/command_unix/test/test_command_choose_one.ml
+++ b/command_unix/test/test_command_choose_one.ml
@@ -25,7 +25,7 @@ let%expect_test "basic" =
   [%expect {| (data ((AB 1 123))) |}];
   test [];
   [%expect {| (data ()) |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1" ]);
+  require_does_raise (fun () -> test [ "-a"; "1" ]);
   [%expect
     {|
     Error parsing command line:
@@ -38,7 +38,7 @@ let%expect_test "basic" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "not-an-int" ]);
+  require_does_raise (fun () -> test [ "-a"; "not-an-int" ]);
   [%expect
     {|
     Error parsing command line:
@@ -92,7 +92,7 @@ let%expect_test "interaction with no_arg" =
   [%expect {| (data ((1 false 100))) |}];
   test [];
   [%expect {| (data ()) |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "10" ]);
+  require_does_raise (fun () -> test [ "-a"; "10" ]);
   [%expect
     {|
     Error parsing command line:
@@ -105,7 +105,7 @@ let%expect_test "interaction with no_arg" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-b" ]);
+  require_does_raise (fun () -> test [ "-b" ]);
   [%expect
     {|
     Error parsing command line:
@@ -165,7 +165,7 @@ let%expect_test "with choose one" =
   [%expect {| (data (CD 3 world)) |}];
   test [ "-e"; "hello"; "-f"; "456"; "-g"; "world" ];
   [%expect {| (data (EFG hello 456 world)) |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1" ]);
+  require_does_raise (fun () -> test [ "-a"; "1" ]);
   [%expect
     {|
     Error parsing command line:
@@ -178,7 +178,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-g"; "abcde" ]);
+  require_does_raise (fun () -> test [ "-g"; "abcde" ]);
   [%expect
     {|
     Error parsing command line:
@@ -191,7 +191,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test []);
+  require_does_raise (fun () -> test []);
   [%expect
     {|
     Error parsing command line:
@@ -207,8 +207,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () ->
-    test [ "-a"; "1"; "-b"; "123"; "-c"; "3"; "-d"; "world" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-b"; "123"; "-c"; "3"; "-d"; "world" ]);
   [%expect
     {|
     Error parsing command line:
@@ -223,7 +222,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-b"; "123"; "-c"; "3" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-b"; "123"; "-c"; "3" ]);
   [%expect
     {|
     Error parsing command line:
@@ -238,7 +237,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-b"; "123"; "-g"; "abcde" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-b"; "123"; "-g"; "abcde" ]);
   [%expect
     {|
     Error parsing command line:
@@ -253,7 +252,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-c"; "3" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-c"; "3" ]);
   [%expect
     {|
     Error parsing command line:
@@ -269,7 +268,7 @@ let%expect_test "with choose one" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-g"; "3" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-g"; "3" ]);
   [%expect
     {|
     Error parsing command line:
@@ -345,7 +344,7 @@ let%expect_test "listed flag" =
 ;;
 
 let%expect_test "[return] is disallowed as a standalone item given to choose_one" =
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Command.Param.choose_one_non_optional
       ~if_nothing_chosen:Raise
       [ Command.Param.return 8 ]);
@@ -371,7 +370,7 @@ let%expect_test "listed flag as a standalone item given to choose_one" =
   let on_success data = print_s [%message (data : int list)] in
   let test = (Command_test_helpers.parse_command_line param |> unstage) ~on_success in
   test [ "-help" ];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-a"; "2"; "-b"; "3" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-a"; "2"; "-b"; "3" ]);
   [%expect
     {|
     CMD SUMMARY
@@ -403,7 +402,7 @@ let%expect_test "listed flag as a standalone item given to choose_one" =
   [%expect {| (data (1)) |}];
   test [ "-b"; "1" ];
   [%expect "(data (1))"];
-  require_does_raise [%here] (fun () -> test []);
+  require_does_raise (fun () -> test []);
   [%expect
     {|
     Error parsing command line:
@@ -466,7 +465,7 @@ let%expect_test "nested" =
 
     (command.ml.Exit_called (status 0))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-b"; "2"; "-yes"; "-no" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-b"; "2"; "-yes"; "-no" ]);
   [%expect
     {|
     Error parsing command line:
@@ -481,7 +480,7 @@ let%expect_test "nested" =
 
     (command.ml.Exit_called (status 1))
     |}];
-  require_does_raise [%here] (fun () -> test [ "-a"; "1"; "-b"; "2" ]);
+  require_does_raise (fun () -> test [ "-a"; "1"; "-b"; "2" ]);
   [%expect
     {|
     Error parsing command line:
@@ -583,7 +582,7 @@ let%expect_test "with regular flags" =
 
     (command.ml.Exit_called (status 0))
     |}];
-  require_does_raise [%here] (fun () -> test []);
+  require_does_raise (fun () -> test []);
   [%expect
     {|
     Error parsing command line:
@@ -674,7 +673,7 @@ let%expect_test "with anon" =
   in
   let on_success data = print_s [%message (data : bool * int)] in
   let test = (Command_test_helpers.parse_command_line param |> unstage) ~on_success in
-  require_does_raise [%here] (fun () -> test [ "-search-in-errors" ]);
+  require_does_raise (fun () -> test [ "-search-in-errors" ]);
   [%expect
     {|
     Error parsing command line:
@@ -710,7 +709,7 @@ let%expect_test "no_arg_required" =
   [%expect {| (data ((() false))) |}];
   test [];
   [%expect {| (data ()) |}];
-  require_does_raise [%here] (fun () -> test [ "-optional-flag" ]);
+  require_does_raise (fun () -> test [ "-optional-flag" ]);
   [%expect
     {|
     Error parsing command line:
@@ -779,7 +778,7 @@ let%expect_test "choose_one with an optional that can be set from an environment
   [%expect {| (data value) |}];
   (* If the environment_variable is set AND "the other option" is set, we expect
      choose_one to fail. *)
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     test_choose_one (Some "value") [ "-some-other-option"; "value" ]);
   [%expect
     {|
@@ -836,7 +835,7 @@ let%expect_test "choose_one with an optional that can be suppressed from an \
     [ "-suppressed-via-env-var"; "value"; "-other-option"; "other-value" ];
   [%expect {| (data other-value) |}];
   (* We expect [choose_one] to say there's nothing to choose from. *)
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     test_choose_one true [ "-suppressed-via-env-var"; "value" ]);
   [%expect
     {|
diff --git a/command_unix/test/test_command_completion.ml b/command_unix/test/test_command_completion.ml
index 4632b50..b6694f9 100644
--- a/command_unix/test/test_command_completion.ml
+++ b/command_unix/test/test_command_completion.ml
@@ -18,42 +18,49 @@ let test args = Command_test_helpers.complete param ~args
 
 let%expect_test "completion of anons" =
   test [ "" ];
-  [%expect {|
+  [%expect
+    {|
     false
     true
     (command.ml.Exit_called (status 0))
     |}];
   test [ "t" ];
-  [%expect {|
+  [%expect
+    {|
     true
     (command.ml.Exit_called (status 0))
     |}];
   test [ "f" ];
-  [%expect {|
+  [%expect
+    {|
     false
     (command.ml.Exit_called (status 0))
     |}];
   test [ "true"; "" ];
-  [%expect {|
+  [%expect
+    {|
     false
     true
     (command.ml.Exit_called (status 0))
     |}];
   test [ "true"; "t" ];
-  [%expect {|
+  [%expect
+    {|
     true
     (command.ml.Exit_called (status 0))
     |}];
   (* First argument is invalid, but we can still complete later arguments. *)
   test [ "bool"; "" ];
-  [%expect {|
+  [%expect
+    {|
     false
     true
     (command.ml.Exit_called (status 0))
     |}];
   (* The list passed into the escape completer is all the args after the escape flag. *)
   test [ "a"; "b"; "--"; "c"; "d" ];
-  [%expect {|
+  [%expect
+    {|
     c
     d
     (command.ml.Exit_called (status 0))
@@ -72,12 +79,14 @@ let%expect_test "completion after [-help]" =
     (command.ml.Exit_called (status 0))
     |}];
   test [ "-h" ];
-  [%expect {|
+  [%expect
+    {|
     -help
     (command.ml.Exit_called (status 0))
     |}];
   test [ "-help"; "" ];
-  [%expect {|
+  [%expect
+    {|
     false
     true
     (command.ml.Exit_called (status 0))
@@ -158,7 +167,8 @@ let%expect_test "demo [complete_subcommands]" =
     Command_test_helpers.complete_command command ?complete_subcommands ~args
   in
   test Simple_group.command ?complete_subcommands:None ~args:[ "g" ];
-  [%expect {|
+  [%expect
+    {|
     group
     (command.ml.Exit_called (status 0))
     |}];
diff --git a/command_unix/test/test_command_env.ml b/command_unix/test/test_command_env.ml
index c12a386..f9c673d 100644
--- a/command_unix/test/test_command_env.ml
+++ b/command_unix/test/test_command_env.ml
@@ -19,7 +19,8 @@ let%expect_test "clear" =
 
 let%expect_test "set" =
   let%map () = run "set" in
-  [%expect {|
+  [%expect
+    {|
     TEST_VAR=TEST_VALUE
     DUMMY_VARIABLE=DUMMY
     |}]
diff --git a/command_unix/test/test_command_escape_anon.ml b/command_unix/test/test_command_escape_anon.ml
index 04613d6..c8affc1 100644
--- a/command_unix/test/test_command_escape_anon.ml
+++ b/command_unix/test/test_command_escape_anon.ml
@@ -33,7 +33,7 @@ let%expect_test "execution" =
 ;;
 
 let%expect_test "anon after [anon_escape]" =
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Command.basic
       ~summary:"this won't validate"
       (let%map_open.Command () = return ()
@@ -49,7 +49,8 @@ let%expect_test "anon after [anon_escape]" =
 
 let%expect_test "completion" =
   Command_test_helpers.complete param ~args:[ "" ];
-  [%expect {|
+  [%expect
+    {|
     Bar
     Foo
     (command.ml.Exit_called (status 0))
diff --git a/core_thread/src/dune b/core_thread/src/dune
index 28fbe4d..694db0c 100644
--- a/core_thread/src/dune
+++ b/core_thread/src/dune
@@ -10,7 +10,8 @@
   (names pthread_np_stubs))
  (name core_thread)
  (public_name core_unix.core_thread)
- (libraries core_kernel.caml_threads core signal_unix unix)
+ (libraries core_kernel.caml_threads core_kernel.caml_unix core signal_unix
+   threads unix)
  (preprocessor_deps config.h)
  (preprocess
   (pps ppx_jane ppx_optcomp)))
diff --git a/core_thread/src/pthread_np_stubs.c b/core_thread/src/pthread_np_stubs.c
index b5bdc50..5cc4fdb 100644
--- a/core_thread/src/pthread_np_stubs.c
+++ b/core_thread/src/pthread_np_stubs.c
@@ -1,5 +1,7 @@
 #define _GNU_SOURCE
 
+#undef Hide_upstream_size_macros
+
 #include "config.h"
 #include "ocaml_utils.h"
 
@@ -24,13 +26,13 @@ CAMLprim value pthread_np_setaffinity_self(value cpuids)
   CPU_ZERO(&cpuset);
 
   length = Wosize_val(cpuids);
-  for (i = 0; i < length; i++) 
+  for (i = 0; i < length; i++)
   {
     CPU_SET(Int_val(Field(cpuids, i)), &cpuset);
   }
 
   result = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
-  if (result < 0) 
+  if (result < 0)
   {
     uerror("pthread_setaffinity_np", Nothing);
   }
diff --git a/core_unix/example/dune b/core_unix/example/dune
index 259ebf3..53485ac 100644
--- a/core_unix/example/dune
+++ b/core_unix/example/dune
@@ -1,6 +1,6 @@
 (executables
  (modes byte exe)
  (names example)
- (libraries async command_unix core)
+ (libraries async command_unix core core_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/core_unix/src/core_unix.ml b/core_unix/src/core_unix.ml
index cabc2c6..b3e2ee3 100644
--- a/core_unix/src/core_unix.ml
+++ b/core_unix/src/core_unix.ml
@@ -1324,6 +1324,27 @@ let stat = unary_filename Unix.LargeFile.stat
 let lstat = unary_filename Unix.LargeFile.lstat
 let fstat = unary_fd Unix.LargeFile.fstat
 
+module Statvfs = struct
+  (* WARNING: do not add, remove, or reorder fields from this record without also changing
+     [core_unix_statvfs_stub]. *)
+  type t =
+    { bsize : int (* file system block size *)
+    ; frsize : int (* fragment size *)
+    ; blocks : int (* size of fs in frsize units *)
+    ; bfree : int (* # free blocks *)
+    ; bavail : int (* # free blocks for non-root *)
+    ; files : int (* # inodes *)
+    ; ffree : int (* # free inodes *)
+    ; favail : int (* # free inodes for non-root *)
+    ; fsid : int (* file system ID *)
+    ; flag : int (* mount flags *)
+    ; namemax : int (* maximum filename length *)
+    }
+  [@@deriving sexp, bin_io]
+end
+
+external statvfs : string -> Statvfs.t = "core_unix_statvfs_stub"
+
 let src_dst f ~src ~dst =
   improve (fun () -> f ~src ~dst) (fun () -> [ "src", atom src; "dst", atom dst ])
 ;;
@@ -1503,12 +1524,12 @@ module Open_flags = struct
   let access_modes = [ rdonly, "rdonly"; rdwr, "rdwr"; wronly, "wronly" ]
 
   include Flags.Make (struct
-    let allow_intersecting = true
-    let should_print_error = true
-    let known = known
-    let remove_zero_flags = true
-    (* remove non existing flags, like cloexec on centos5 *)
-  end)
+      let allow_intersecting = true
+      let should_print_error = true
+      let known = known
+      let remove_zero_flags = true
+      (* remove non existing flags, like cloexec on centos5 *)
+    end)
 
   (* The lower two bits of the open flags are used to specify the access mode:
      rdonly, wronly, rdwr.  So, we have some code to treat those two bits together rather
@@ -1790,8 +1811,8 @@ end = struct
       Sys.getenv "PATH"
       |> Option.value_map ~f:(String.split ~on:':') ~default:[ "/bin"; "/usr/bin" ]
       |> List.map ~f:(function
-           | "" -> "."
-           | x -> x)
+        | "" -> "."
+        | x -> x)
   ;;
 
   let candidate_paths ?prog_search_path prog =
@@ -2377,52 +2398,52 @@ module Inet_addr0 = struct
   include Stable.V1
 
   include Stable_unit_test.Make (struct
-    type nonrec t = t [@@deriving sexp, bin_io]
-
-    let equal = equal
-
-    let tests =
-      (* IPv4 *)
-      [ of_string "0.0.0.0", "0.0.0.0", "\0070.0.0.0"
-      ; of_string "10.0.0.0", "10.0.0.0", "\00810.0.0.0"
-      ; of_string "127.0.0.1", "127.0.0.1", "\009127.0.0.1"
-      ; of_string "192.168.1.101", "192.168.1.101", "\013192.168.1.101"
-      ; of_string "255.255.255.255", "255.255.255.255", "\015255.255.255.255" (* IPv6 *)
-      ; ( of_string "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
-        , "2001:db8:85a3::8a2e:370:7334"
-        , "\0282001:db8:85a3::8a2e:370:7334" )
-      ; ( of_string "2001:db8:85a3:0:0:8a2e:370:7334"
-        , "2001:db8:85a3::8a2e:370:7334"
-        , "\0282001:db8:85a3::8a2e:370:7334" )
-      ; ( of_string "2001:db8:85a3::8a2e:370:7334"
-        , "2001:db8:85a3::8a2e:370:7334"
-        , "\0282001:db8:85a3::8a2e:370:7334" )
-      ; of_string "0:0:0:0:0:0:0:1", "::1", "\003::1"
-      ; of_string "::1", "::1", "\003::1"
-      ; of_string "0:0:0:0:0:0:0:0", "::", "\002::"
-      ; of_string "::", "::", "\002::"
-      ; of_string "::ffff:c000:0280", "::ffff:192.0.2.128", "\018::ffff:192.0.2.128"
-      ; of_string "::ffff:192.0.2.128", "::ffff:192.0.2.128", "\018::ffff:192.0.2.128"
-      ; of_string "2001:0db8::0001", "2001:db8::1", "\0112001:db8::1"
-      ; of_string "2001:db8::1", "2001:db8::1", "\0112001:db8::1"
-      ; of_string "2001:db8::2:1", "2001:db8::2:1", "\0132001:db8::2:1"
-      ; ( of_string "2001:db8:0000:1:1:1:1:1"
-        , "2001:db8:0:1:1:1:1:1"
-        , "\0202001:db8:0:1:1:1:1:1" )
-      ; ( of_string "2001:db8::1:1:1:1:1"
-        , "2001:db8:0:1:1:1:1:1"
-        , "\0202001:db8:0:1:1:1:1:1" )
-      ; ( of_string "2001:db8:0:1:1:1:1:1"
-        , "2001:db8:0:1:1:1:1:1"
-        , "\0202001:db8:0:1:1:1:1:1" )
-      ; of_string "2001:db8:0:0:1:0:0:1", "2001:db8::1:0:0:1", "\0172001:db8::1:0:0:1"
-      ; of_string "2001:db8:0:0:1::1", "2001:db8::1:0:0:1", "\0172001:db8::1:0:0:1"
-      ; of_string "2001:db8::1:0:0:1", "2001:db8::1:0:0:1", "\0172001:db8::1:0:0:1"
-      ; of_string "2001:DB8::1", "2001:db8::1", "\0112001:db8::1"
-      ; of_string "2001:db8::1", "2001:db8::1", "\0112001:db8::1"
-      ]
-    ;;
-  end)
+      type nonrec t = t [@@deriving sexp, bin_io]
+
+      let equal = equal
+
+      let tests =
+        (* IPv4 *)
+        [ of_string "0.0.0.0", "0.0.0.0", "\0070.0.0.0"
+        ; of_string "10.0.0.0", "10.0.0.0", "\00810.0.0.0"
+        ; of_string "127.0.0.1", "127.0.0.1", "\009127.0.0.1"
+        ; of_string "192.168.1.101", "192.168.1.101", "\013192.168.1.101"
+        ; of_string "255.255.255.255", "255.255.255.255", "\015255.255.255.255" (* IPv6 *)
+        ; ( of_string "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
+          , "2001:db8:85a3::8a2e:370:7334"
+          , "\0282001:db8:85a3::8a2e:370:7334" )
+        ; ( of_string "2001:db8:85a3:0:0:8a2e:370:7334"
+          , "2001:db8:85a3::8a2e:370:7334"
+          , "\0282001:db8:85a3::8a2e:370:7334" )
+        ; ( of_string "2001:db8:85a3::8a2e:370:7334"
+          , "2001:db8:85a3::8a2e:370:7334"
+          , "\0282001:db8:85a3::8a2e:370:7334" )
+        ; of_string "0:0:0:0:0:0:0:1", "::1", "\003::1"
+        ; of_string "::1", "::1", "\003::1"
+        ; of_string "0:0:0:0:0:0:0:0", "::", "\002::"
+        ; of_string "::", "::", "\002::"
+        ; of_string "::ffff:c000:0280", "::ffff:192.0.2.128", "\018::ffff:192.0.2.128"
+        ; of_string "::ffff:192.0.2.128", "::ffff:192.0.2.128", "\018::ffff:192.0.2.128"
+        ; of_string "2001:0db8::0001", "2001:db8::1", "\0112001:db8::1"
+        ; of_string "2001:db8::1", "2001:db8::1", "\0112001:db8::1"
+        ; of_string "2001:db8::2:1", "2001:db8::2:1", "\0132001:db8::2:1"
+        ; ( of_string "2001:db8:0000:1:1:1:1:1"
+          , "2001:db8:0:1:1:1:1:1"
+          , "\0202001:db8:0:1:1:1:1:1" )
+        ; ( of_string "2001:db8::1:1:1:1:1"
+          , "2001:db8:0:1:1:1:1:1"
+          , "\0202001:db8:0:1:1:1:1:1" )
+        ; ( of_string "2001:db8:0:1:1:1:1:1"
+          , "2001:db8:0:1:1:1:1:1"
+          , "\0202001:db8:0:1:1:1:1:1" )
+        ; of_string "2001:db8:0:0:1:0:0:1", "2001:db8::1:0:0:1", "\0172001:db8::1:0:0:1"
+        ; of_string "2001:db8:0:0:1::1", "2001:db8::1:0:0:1", "\0172001:db8::1:0:0:1"
+        ; of_string "2001:db8::1:0:0:1", "2001:db8::1:0:0:1", "\0172001:db8::1:0:0:1"
+        ; of_string "2001:DB8::1", "2001:db8::1", "\0112001:db8::1"
+        ; of_string "2001:db8::1", "2001:db8::1", "\0112001:db8::1"
+        ]
+      ;;
+    end)
 
   let arg_type = Core.Command.Arg_type.create of_string
 end
@@ -2561,15 +2582,15 @@ module Cidr = struct
       module T1 = Sexpable.Stable.Of_stringable.V1 (T0)
 
       module T2 = Comparator.Stable.V1.Make (struct
-        include T0
-        include T1
-      end)
+          include T0
+          include T1
+        end)
 
       module T3 = Comparable.Stable.V1.With_stable_witness.Make (struct
-        include T0
-        include T1
-        include T2
-      end)
+          include T0
+          include T1
+          include T2
+        end)
 
       include T0
       include T1
@@ -2619,12 +2640,12 @@ module Cidr = struct
   ;;
 
   include Identifiable.Make_using_comparator (struct
-    let module_name = "Core_unix.Cidr"
+      let module_name = "Core_unix.Cidr"
 
-    include Stable.V1.T0
-    include Stable.V1.T1
-    include Stable.V1.T2
-  end)
+      include Stable.V1.T0
+      include Stable.V1.T1
+      include Stable.V1.T2
+    end)
 
   let arg_type = Core.Command.Arg_type.create of_string
 end
diff --git a/core_unix/src/core_unix.mli b/core_unix/src/core_unix.mli
index 5432b84..85865dc 100644
--- a/core_unix/src/core_unix.mli
+++ b/core_unix/src/core_unix.mli
@@ -82,10 +82,10 @@ type error = Unix.error =
 [@@deprecated "[since 2016-10] use [Unix.Error.t] instead"]
 
 val sexp_of_error : Unix.error -> Sexp.t
-  [@@deprecated "[since 2016-10] use [Unix.Error.t] instead"]
+[@@deprecated "[since 2016-10] use [Unix.Error.t] instead"]
 
 val error_of_sexp : Sexp.t -> Unix.error
-  [@@deprecated "[since 2016-10] use [Unix.Error.t] instead"]
+[@@deprecated "[since 2016-10] use [Unix.Error.t] instead"]
 
 module Error : sig
   (** The type of error codes.  Errors defined in the POSIX standard and additional
@@ -189,7 +189,7 @@ module Syscall_result : module type of Syscall_result with type 'a t = 'a Syscal
 val unix_error : int -> string -> string -> _
 
 val error_message : Error.t -> string
-  [@@deprecated "[since 2016-10] use [Unix.Error.message] instead"]
+[@@deprecated "[since 2016-10] use [Unix.Error.message] instead"]
 
 (** [handle_unix_error f] runs [f ()] and returns the result.  If the exception
     [Unix_error] is raised, it prints a message describing the error and exits with code
@@ -688,6 +688,26 @@ val lstat : string -> stats
     descriptor. *)
 val fstat : File_descr.t -> stats
 
+module Statvfs : sig
+  type t =
+    { bsize : int (** file system block size *)
+    ; frsize : int (** fragment size *)
+    ; blocks : int (** size of fs in frsize units *)
+    ; bfree : int (** # free blocks *)
+    ; bavail : int (** # free blocks for non-root *)
+    ; files : int (** # inodes *)
+    ; ffree : int (** # free inodes *)
+    ; favail : int (** # free inodes for non-root *)
+    ; fsid : int (** file system ID *)
+    ; flag : int (** mount flags *)
+    ; namemax : int (** maximum filename length *)
+    }
+  [@@deriving sexp, bin_io]
+end
+
+(** Return the information for a mounted filesystem. *)
+val statvfs : string -> Statvfs.t
+
 (** This sub-module provides the normal OCaml Unix functions that deal with file size
     using native ints.  These are here because, in general, you should be using 64bit
     file operations so that large files aren't an issue.  If you have a real need to
@@ -935,7 +955,7 @@ val readdir_opt : dir_handle -> string option
 (** Same as [readdir_opt] except that it signals the end of the directory by raising
     [End_of_file]. *)
 val readdir : dir_handle -> string
-  [@@deprecated "[since 2016-08] use [readdir_opt] instead"]
+[@@deprecated "[since 2016-08] use [readdir_opt] instead"]
 
 (** Reposition the descriptor to the beginning of the directory *)
 val rewinddir : dir_handle -> unit
@@ -948,7 +968,7 @@ module Readdir_detailed : sig
     { name : string
     ; inode : Nativeint.t
     ; kind : file_kind option
-        (** Some OS/filesystems provide the file type of the directory entry, some don't, some
+    (** Some OS/filesystems provide the file type of the directory entry, some don't, some
         do based on mount options. Code should not require the file type to be present,
         merely use it as a way to increase speed or reduce race conditions. *)
     }
@@ -1291,11 +1311,11 @@ val utimes : string -> access:float -> modif:float -> unit
 (** The three kinds of interval timers. *)
 type interval_timer = Unix.interval_timer =
   | ITIMER_REAL
-      (** decrements in real time, and sends the signal [SIGALRM] when expired.*)
+  (** decrements in real time, and sends the signal [SIGALRM] when expired.*)
   | ITIMER_VIRTUAL
-      (**  decrements in process virtual time, and sends [SIGVTALRM] when expired. *)
+  (**  decrements in process virtual time, and sends [SIGVTALRM] when expired. *)
   | ITIMER_PROF
-      (** (for profiling) decrements both when the process
+  (** (for profiling) decrements both when the process
       is running and when the system is running on behalf of the
       process; it sends [SIGPROF] when expired. *)
 [@@deriving sexp]
@@ -1424,7 +1444,7 @@ module Inet_addr : sig
       want a sexp converter to do that.  As we transition away, one can use
       [Blocking_sexp], which has the old behavior. *)
   val t_of_sexp : Sexp.t -> t
-    [@@deprecated "[since 2015-10] Replace [t] by [Stable.V1.t] or by [Blocking_sexp.t]"]
+  [@@deprecated "[since 2015-10] Replace [t] by [Stable.V1.t] or by [Blocking_sexp.t]"]
 
   (** [Blocking_sexp] performs DNS lookup to resolve hostnames to IP addresses. *)
   module Blocking_sexp : sig
@@ -1477,8 +1497,8 @@ module Inet_addr : sig
 
       include
         Stable_with_witness
-          with type t := t
-           and type comparator_witness = comparator_witness
+        with type t := t
+         and type comparator_witness = comparator_witness
     end
   end
 end
@@ -1540,8 +1560,8 @@ module Cidr : sig
   module Stable : sig
     module V1 :
       Stable_comparable.With_stable_witness.V1
-        with type t = t
-        with type comparator_witness = comparator_witness
+      with type t = t
+      with type comparator_witness = comparator_witness
   end
 end
 
@@ -1573,7 +1593,7 @@ type sockaddr = Unix.sockaddr =
 [@@deriving bin_io, compare, sexp_of]
 
 val sockaddr_of_sexp : Sexp.t -> sockaddr
-  [@@deprecated "[since 2015-10] Replace [sockaddr] by [sockaddr_blocking_sexp]"]
+[@@deprecated "[since 2015-10] Replace [sockaddr] by [sockaddr_blocking_sexp]"]
 
 (** [sockaddr_blocking_sexp] is like [sockaddr], with [of_sexp] that performs DNS lookup
     to resolve [Inet_addr.t]. *)
@@ -1746,7 +1766,7 @@ type socket_int_option =
   | SO_SNDBUF (** Size of send buffer *)
   | SO_RCVBUF (** Size of received buffer *)
   | SO_ERROR [@alert deprecated "Use Unix.getsockopt_error instead."]
-      (** Report the error status and clear it *)
+  (** Report the error status and clear it *)
   | SO_TYPE (** Report the socket type *)
   | SO_RCVLOWAT (** Minimum number of bytes to process for input operations *)
   | SO_SNDLOWAT (** Minimum number of bytes to process for output operations *)
@@ -1757,7 +1777,7 @@ type socket_int_option =
     value of type [int option], with [None] meaning ``disabled''. *)
 type socket_optint_option =
   | SO_LINGER
-      (** Whether to linger on closed connections with sexp that have
+  (** Whether to linger on closed connections with sexp that have
       data present, and for how long (in seconds) *)
 
 (** The socket options that can be consulted with {!UnixLabels.getsockopt_float}
@@ -1987,7 +2007,7 @@ module Terminal_io : sig
     ; (*_ Local modes: *)
       mutable c_isig : bool (** Generate signal on INTR, QUIT, SUSP. *)
     ; mutable c_icanon : bool
-        (** Enable canonical processing (line buffering and editing) *)
+    (** Enable canonical processing (line buffering and editing) *)
     ; mutable c_noflsh : bool (** Disable flush after INTR, QUIT, SUSP. *)
     ; mutable c_echo : bool (** Echo input characters. *)
     ; mutable c_echoe : bool (** Echo ERASE (to erase previous character). *)
@@ -2001,7 +2021,7 @@ module Terminal_io : sig
     ; mutable c_veof : char (** End-of-file character (usually ctrl-D). *)
     ; mutable c_veol : char (** Alternate end-of-line char. (usually none). *)
     ; mutable c_vmin : int
-        (** Minimum number of characters to read before the read request is satisfied. *)
+    (** Minimum number of characters to read before the read request is satisfied. *)
     ; mutable c_vtime : int (** Maximum read wait (in 0.1s units). *)
     ; mutable c_vstart : char (** Start character (usually ctrl-Q). *)
     ; mutable c_vstop : char (** Stop character (usually ctrl-S). *)
diff --git a/core_unix/src/core_unix_stubs.c b/core_unix/src/core_unix_stubs.c
index 44b52dd..f461db1 100644
--- a/core_unix/src/core_unix_stubs.c
+++ b/core_unix/src/core_unix_stubs.c
@@ -2,6 +2,8 @@
 
 #define _GNU_SOURCE
 
+#undef Hide_upstream_size_macros
+
 #include <string.h>
 #include <pthread.h>
 /* Darwin needs this to be included before if.h*/
@@ -27,6 +29,7 @@
 #include <grp.h>
 #include <sys/select.h>
 #include <sys/stat.h>
+#include <sys/statvfs.h>
 #include <sys/types.h>
 #include <fnmatch.h>
 #include <stdio.h>
@@ -43,7 +46,7 @@
 #include <sys/wait.h>
 
 /* makedev */
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) ||       \
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) ||                 \
     defined(__OpenBSD__)
 /* The BSDs expose the definition for this macro via <sys/types.h>. */
 #else
@@ -74,8 +77,7 @@ CAMLprim value core_code_of_unix_error(value error) {
   return Val_int(code_of_unix_error(error));
 }
 
-CAMLprim value core_unix_error_stub(value v_errcode, value v_cmdname,
-                                    value cmd_arg) {
+CAMLprim value core_unix_error_stub(value v_errcode, value v_cmdname, value cmd_arg) {
   unix_error(Int_val(v_errcode), String_val(v_cmdname), cmd_arg);
   return Val_unit;
 }
@@ -160,8 +162,7 @@ CAMLprim value core_unix_get_close_on_exec(value fd) {
   int flags;
   flags = fcntl(Int_val(fd), F_GETFD);
   if (flags == -1) {
-    unix_error(errno, "get_close_on_exec: unable to get flags for descr",
-               Nothing);
+    unix_error(errno, "get_close_on_exec: unable to get flags for descr", Nothing);
   }
 
   if (flags & FD_CLOEXEC) {
@@ -234,8 +235,7 @@ CAMLprim value core_unix_getpwent(value v_unit) {
 
 #define FLOCK_BUF_LENGTH 80
 
-CAMLprim value core_unix_flock(value v_blocking, value v_fd,
-                               value v_lock_type) {
+CAMLprim value core_unix_flock(value v_blocking, value v_fd, value v_lock_type) {
   CAMLparam2(v_fd, v_lock_type);
   int blocking = Bool_val(v_blocking);
   int fd = Int_val(v_fd);
@@ -256,8 +256,8 @@ CAMLprim value core_unix_flock(value v_blocking, value v_fd,
     operation = LOCK_UN;
     break;
   default:
-    snprintf(error, FLOCK_BUF_LENGTH,
-             "bug in flock C stub: unknown lock type: %d", lock_type);
+    snprintf(error, FLOCK_BUF_LENGTH, "bug in flock C stub: unknown lock type: %d",
+             lock_type);
     caml_invalid_argument(error);
   };
 
@@ -283,9 +283,8 @@ CAMLprim value core_unix_flock(value v_blocking, value v_fd,
 
 /* Filesystem functions */
 
-CAMLprim value core_unix_mknod_stub(value v_pathname, value v_mode,
-                                    value v_perm, value v_major,
-                                    value v_minor) {
+CAMLprim value core_unix_mknod_stub(value v_pathname, value v_mode, value v_perm,
+                                    value v_major, value v_minor) {
   CAMLparam1(v_pathname);
 
   int ret, len;
@@ -362,8 +361,7 @@ CAMLprim value core_unix_fdatasync(value v_fd) {
   return Val_unit;
 }
 #else
-#warning                                                                       \
-    "_POSIX_SYNCHRONIZED_IO undefined or <= 0; aliasing unix_fdatasync to unix_fsync"
+#warning "_POSIX_SYNCHRONIZED_IO undefined or <= 0; aliasing unix_fdatasync to unix_fsync"
 CAMLprim value core_unix_fdatasync(value v_fd) { return core_unix_fsync(v_fd); }
 #endif
 
@@ -446,10 +444,36 @@ CAMLprim value core_unix_readdir_detailed_stub(value v_dh) {
   }
 }
 
-CAMLprim value core_unix_read_assume_fd_is_nonblocking_stub(value v_fd,
-                                                            value v_buf,
-                                                            value v_pos,
-                                                            value v_len) {
+CAMLprim value core_unix_statvfs_stub(value v_path) {
+  CAMLparam1(v_path);
+  CAMLlocal1(v_stat);
+  struct statvfs s;
+  int ret, len = caml_string_length(v_path) + 1;
+  char *pathname = caml_stat_alloc(len);
+  memcpy(pathname, String_val(v_path), len);
+  caml_enter_blocking_section();
+  ret = statvfs(pathname, &s);
+  caml_leave_blocking_section();
+  caml_stat_free(pathname);
+  if (ret != 0)
+    uerror("statvfs", v_path);
+  v_stat = caml_alloc(11, 0);
+  Store_field(v_stat, 0, Val_long(s.f_bsize));
+  Store_field(v_stat, 1, Val_long(s.f_frsize));
+  Store_field(v_stat, 2, Val_long(s.f_blocks));
+  Store_field(v_stat, 3, Val_long(s.f_bfree));
+  Store_field(v_stat, 4, Val_long(s.f_bavail));
+  Store_field(v_stat, 5, Val_long(s.f_files));
+  Store_field(v_stat, 6, Val_long(s.f_ffree));
+  Store_field(v_stat, 7, Val_long(s.f_favail));
+  Store_field(v_stat, 8, Val_long(s.f_fsid));
+  Store_field(v_stat, 9, Val_long(s.f_flag));
+  Store_field(v_stat, 10, Val_long(s.f_namemax));
+  CAMLreturn(v_stat);
+}
+
+CAMLprim value core_unix_read_assume_fd_is_nonblocking_stub(value v_fd, value v_buf,
+                                                            value v_pos, value v_len) {
   unsigned char *buf = Bytes_val(v_buf) + Long_val(v_pos);
   ssize_t ret = read(Int_val(v_fd), buf, Long_val(v_len));
   if (ret == -1)
@@ -457,10 +481,8 @@ CAMLprim value core_unix_read_assume_fd_is_nonblocking_stub(value v_fd,
   return Val_long(ret);
 }
 
-CAMLprim value core_unix_write_assume_fd_is_nonblocking_stub(value v_fd,
-                                                             value v_buf,
-                                                             value v_pos,
-                                                             value v_len) {
+CAMLprim value core_unix_write_assume_fd_is_nonblocking_stub(value v_fd, value v_buf,
+                                                             value v_pos, value v_len) {
   /* note that [v_buf] is a [Bytes.t] in practice */
   const char *buf = String_val(v_buf) + Long_val(v_pos);
   ssize_t ret = write(Int_val(v_fd), buf, Long_val(v_len));
@@ -469,8 +491,7 @@ CAMLprim value core_unix_write_assume_fd_is_nonblocking_stub(value v_fd,
   return Val_long(ret);
 }
 
-CAMLprim value core_unix_writev_assume_fd_is_nonblocking_stub(value v_fd,
-                                                              value v_iovecs,
+CAMLprim value core_unix_writev_assume_fd_is_nonblocking_stub(value v_fd, value v_iovecs,
                                                               value v_count) {
   int count = Int_val(v_count);
   ssize_t ret;
@@ -492,8 +513,7 @@ CAMLprim value core_unix_writev_assume_fd_is_nonblocking_stub(value v_fd,
   return Val_long(ret);
 }
 
-CAMLprim value core_unix_writev_stub(value v_fd, value v_iovecs,
-                                     value v_count) {
+CAMLprim value core_unix_writev_stub(value v_fd, value v_iovecs, value v_count) {
   int i, count = Int_val(v_count), len = 0;
   ssize_t ret;
   char *buf, *dst;
@@ -641,9 +661,7 @@ CAMLprim value core_unix_clock_getres(value v_cl) {
    clearly does not do what is intended in the general case, but will
    probably usually do the right thing.
 */
-static inline pthread_t pthread_t_val(value __unused v_tid) {
-  return pthread_self();
-}
+static inline pthread_t pthread_t_val(value __unused v_tid) { return pthread_self(); }
 
 #if defined(JSC_THREAD_CPUTIME)
 CAMLprim value core_unix_pthread_getcpuclockid(value v_tid) {
@@ -829,12 +847,12 @@ static value core_unix_alloc_rusage(struct rusage ru) {
   CAMLparam0();
   CAMLlocal1(v_usage);
   v_usage = caml_alloc(16, 0);
-  Store_field(v_usage, 0,
-              caml_copy_double((double)ru.ru_utime.tv_sec +
-                               (double)ru.ru_utime.tv_usec / 1e6));
-  Store_field(v_usage, 1,
-              caml_copy_double((double)ru.ru_stime.tv_sec +
-                               (double)ru.ru_stime.tv_usec / 1e6));
+  Store_field(
+      v_usage, 0,
+      caml_copy_double((double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1e6));
+  Store_field(
+      v_usage, 1,
+      caml_copy_double((double)ru.ru_stime.tv_sec + (double)ru.ru_stime.tv_usec / 1e6));
   Store_field(v_usage, 2, caml_copy_int64(ru.ru_maxrss));
   Store_field(v_usage, 3, caml_copy_int64(ru.ru_ixrss));
   Store_field(v_usage, 4, caml_copy_int64(ru.ru_idrss));
@@ -1217,8 +1235,7 @@ CAMLprim value core_unix_if_nametoindex(value v_name) {
 #define INT_MCAST_ACTION_DROP (1)
 
 CAMLprim value core_unix_mcast_modify(value v_action, value v_ifname_opt,
-                                      value v_source_opt, value v_fd,
-                                      value v_sa) {
+                                      value v_source_opt, value v_fd, value v_sa) {
   int ret, fd = Int_val(v_fd);
   union sock_addr_union sau;
   struct sockaddr *sa = &sau.s_gen;
@@ -1242,8 +1259,7 @@ CAMLprim value core_unix_mcast_modify(value v_action, value v_ifname_opt,
       if (ioctl(fd, SIOCGIFADDR, &ifreq) < 0)
         uerror("core_unix_mcast_modify: ioctl", Nothing);
 
-      memcpy(&mreq.imr_interface,
-             &((struct sockaddr_in *)&ifreq.ifr_addr)->sin_addr,
+      memcpy(&mreq.imr_interface, &((struct sockaddr_in *)&ifreq.ifr_addr)->sin_addr,
              sizeof(struct in_addr));
     } else {
       assert(v_ifname_opt == Val_long(0) /* None */);
@@ -1279,8 +1295,7 @@ CAMLprim value core_unix_mcast_modify(value v_action, value v_ifname_opt,
       mreq_source.imr_interface = mreq.imr_interface;
       mreq_source.imr_sourceaddr = GET_INET_ADDR(Field(v_source_opt, 0));
 
-      ret = setsockopt(fd, IPPROTO_IP, optname, &mreq_source,
-                       sizeof(mreq_source));
+      ret = setsockopt(fd, IPPROTO_IP, optname, &mreq_source, sizeof(mreq_source));
 #endif
     } else {
       int optname;
@@ -1333,20 +1348,19 @@ enum option_type {
 #define caml_unix_setsockopt_aux unix_setsockopt_aux
 #endif
 
-extern value caml_unix_getsockopt_aux(char *name, enum option_type ty,
-                                      int level, int option, value v_socket);
-extern value caml_unix_setsockopt_aux(char *name, enum option_type ty,
-                                      int level, int option, value v_socket,
-                                      value v_status);
+extern value caml_unix_getsockopt_aux(char *name, enum option_type ty, int level,
+                                      int option, value v_socket);
+extern value caml_unix_setsockopt_aux(char *name, enum option_type ty, int level,
+                                      int option, value v_socket, value v_status);
 
 CAMLprim value core_unix_mcast_get_ttl(value v_socket) {
-  return caml_unix_getsockopt_aux("getsockopt", TYPE_INT, IPPROTO_IP,
-                                  IP_MULTICAST_TTL, v_socket);
+  return caml_unix_getsockopt_aux("getsockopt", TYPE_INT, IPPROTO_IP, IP_MULTICAST_TTL,
+                                  v_socket);
 }
 
 CAMLprim value core_unix_mcast_set_ttl(value v_socket, value v_ttl) {
-  return caml_unix_setsockopt_aux("setsockopt", TYPE_INT, IPPROTO_IP,
-                                  IP_MULTICAST_TTL, v_socket, v_ttl);
+  return caml_unix_setsockopt_aux("setsockopt", TYPE_INT, IPPROTO_IP, IP_MULTICAST_TTL,
+                                  v_socket, v_ttl);
 }
 
 CAMLprim value core_unix_mcast_set_ifname(value v_socket, value v_ifname) {
@@ -1358,19 +1372,18 @@ CAMLprim value core_unix_mcast_set_ifname(value v_socket, value v_ifname) {
   addr = core_unix_get_in_addr_for_interface(v_ifname);
 
   /* Now setsockopt to publish on the interface using the address. */
-  return caml_unix_setsockopt_aux("setsockopt", TYPE_INT, IPPROTO_IP,
-                                  IP_MULTICAST_IF, v_socket,
-                                  Val_int(addr.s_addr));
+  return caml_unix_setsockopt_aux("setsockopt", TYPE_INT, IPPROTO_IP, IP_MULTICAST_IF,
+                                  v_socket, Val_int(addr.s_addr));
 }
 
 CAMLprim value core_unix_mcast_get_loop(value v_socket) {
-  return caml_unix_getsockopt_aux("getsockopt", TYPE_BOOL, IPPROTO_IP,
-                                  IP_MULTICAST_LOOP, v_socket);
+  return caml_unix_getsockopt_aux("getsockopt", TYPE_BOOL, IPPROTO_IP, IP_MULTICAST_LOOP,
+                                  v_socket);
 }
 
 CAMLprim value core_unix_mcast_set_loop(value v_socket, value v_loop) {
-  return caml_unix_setsockopt_aux("setsockopt", TYPE_BOOL, IPPROTO_IP,
-                                  IP_MULTICAST_LOOP, v_socket, v_loop);
+  return caml_unix_setsockopt_aux("setsockopt", TYPE_BOOL, IPPROTO_IP, IP_MULTICAST_LOOP,
+                                  v_socket, v_loop);
 }
 
 /* Scheduling */
@@ -1396,8 +1409,7 @@ CAMLprim value core_unix_sched_setscheduler(value v_pid, value v_policy,
 }
 #else
 #warning "_POSIX_PRIORITY_SCHEDULING not present; sched_setscheduler undefined"
-CAMLprim value core_unix_sched_setscheduler(value __unused v_pid,
-                                            value __unused v_policy,
+CAMLprim value core_unix_sched_setscheduler(value __unused v_pid, value __unused v_policy,
                                             value __unused v_priority) {
   caml_invalid_argument("sched_setscheduler unimplemented");
 }
@@ -1457,8 +1469,7 @@ static value alloc_tm(struct tm *tm) {
   return res;
 }
 
-CAMLprim value core_unix_strptime(value v_allow_trailing_input, value v_fmt,
-                                  value v_s) {
+CAMLprim value core_unix_strptime(value v_allow_trailing_input, value v_fmt, value v_s) {
   CAMLparam3(v_allow_trailing_input, v_fmt, v_s);
 
   struct tm tm;
@@ -1472,8 +1483,7 @@ CAMLprim value core_unix_strptime(value v_allow_trailing_input, value v_fmt,
   tm.tm_yday = 0;
   tm.tm_isdst = 0;
 
-  char *end_of_consumed_input =
-      strptime(String_val(v_s), String_val(v_fmt), &tm);
+  char *end_of_consumed_input = strptime(String_val(v_s), String_val(v_fmt), &tm);
 
   if (end_of_consumed_input == NULL)
     caml_failwith("unix_strptime: match failed");
@@ -1503,14 +1513,11 @@ CAMLprim value core_unix_remove(value v_path) {
 
 #if defined(GET_THREAD_ID)
 
-CAMLprim value core_unix_gettid(value v_unit __unused) {
-  return Val_long(GET_THREAD_ID);
-}
+CAMLprim value core_unix_gettid(value v_unit __unused) { return Val_long(GET_THREAD_ID); }
 
 #endif
 
-static value sockaddr_to_caml_string_of_octets(struct sockaddr *sa,
-                                               int family) {
+static value sockaddr_to_caml_string_of_octets(struct sockaddr *sa, int family) {
   CAMLparam0();
   CAMLlocal1(caml_addr);
   struct sockaddr_in *sin;
@@ -1525,8 +1532,7 @@ static value sockaddr_to_caml_string_of_octets(struct sockaddr *sa,
     CAMLreturn(caml_alloc_string(0));
 
   if (family != sa->sa_family)
-    caml_failwith(
-        "Not all addresses provided by getifaddrs have matching families.");
+    caml_failwith("Not all addresses provided by getifaddrs have matching families.");
 
   switch (sa->sa_family) {
   case AF_INET:
@@ -1568,15 +1574,11 @@ static value alloc_ifaddrs(struct ifaddrs *ifap, value family_variant) {
   Store_field(res, 0, caml_copy_string(ifap->ifa_name));
   Store_field(res, 1, family_variant);
   Store_field(res, 2, Val_int(ifap->ifa_flags));
-  Store_field(res, 3,
-              sockaddr_to_caml_string_of_octets(ifap->ifa_addr, family));
-  Store_field(res, 4,
-              sockaddr_to_caml_string_of_octets(ifap->ifa_netmask, family));
+  Store_field(res, 3, sockaddr_to_caml_string_of_octets(ifap->ifa_addr, family));
+  Store_field(res, 4, sockaddr_to_caml_string_of_octets(ifap->ifa_netmask, family));
   /* Including both may be the most portable thing to do. */
-  Store_field(res, 5,
-              sockaddr_to_caml_string_of_octets(ifap->ifa_broadaddr, family));
-  Store_field(res, 6,
-              sockaddr_to_caml_string_of_octets(ifap->ifa_dstaddr, family));
+  Store_field(res, 5, sockaddr_to_caml_string_of_octets(ifap->ifa_broadaddr, family));
+  Store_field(res, 6, sockaddr_to_caml_string_of_octets(ifap->ifa_dstaddr, family));
 
   CAMLreturn(res);
 }
diff --git a/core_unix/src/core_unix_time_stubs.c b/core_unix/src/core_unix_time_stubs.c
index 113674d..01008af 100644
--- a/core_unix/src/core_unix_time_stubs.c
+++ b/core_unix/src/core_unix_time_stubs.c
@@ -74,15 +74,15 @@ CAMLprim value caml_clock_getcpuclockid(value v_pid) {
 value caml_clock_getres(value clock_type) {
   struct timespec tp;
   clock_getres(clockid_t_of_val(clock_type), &tp);
-  return (caml_alloc_int63(((int64_t)tp.tv_sec * 1000 * 1000 * 1000) +
-                           (int64_t)tp.tv_nsec));
+  return (
+      caml_alloc_int63(((int64_t)tp.tv_sec * 1000 * 1000 * 1000) + (int64_t)tp.tv_nsec));
 }
 
 value caml_clock_gettime(value clock_type) {
   struct timespec tp;
   clock_gettime(clockid_t_of_val(clock_type), &tp);
-  return (caml_alloc_int63(((int64_t)tp.tv_sec * 1000 * 1000 * 1000) +
-                           (int64_t)tp.tv_nsec));
+  return (
+      caml_alloc_int63(((int64_t)tp.tv_sec * 1000 * 1000 * 1000) + (int64_t)tp.tv_nsec));
 }
 
 #endif /* JSC_POSIX_TIMERS */
@@ -160,8 +160,7 @@ CAMLprim value core_time_ns_nanosleep(value v_seconds) {
     else
       uerror("nanosleep", Nothing);
   } else
-    caml_failwith(
-        "core_time_ns_nanosleep: impossible return value from nanosleep(2)");
+    caml_failwith("core_time_ns_nanosleep: impossible return value from nanosleep(2)");
 }
 
 /*
@@ -169,16 +168,16 @@ CAMLprim value core_time_ns_nanosleep(value v_seconds) {
  * {localtime,gmtime}_r instead of {localtime,gmtime} to avoid setting the
  * global tzname (instead setting the tm_store value that we discard).
  */
-#define WRAP_TIME_FUN(NAME, ERROR)                                             \
-  CAMLprim value core_##NAME(value t) {                                        \
-    time_t clock;                                                              \
-    struct tm *tm;                                                             \
-    struct tm tm_store;                                                        \
-    clock = (time_t)Double_val(t);                                             \
-    tm = NAME##_r(&clock, &tm_store);                                          \
-    if (tm == NULL)                                                            \
-      caml_failwith(ERROR);                                                    \
-    return alloc_tm(tm);                                                       \
+#define WRAP_TIME_FUN(NAME, ERROR)                                                       \
+  CAMLprim value core_##NAME(value t) {                                                  \
+    time_t clock;                                                                        \
+    struct tm *tm;                                                                       \
+    struct tm tm_store;                                                                  \
+    clock = (time_t)Double_val(t);                                                       \
+    tm = NAME##_r(&clock, &tm_store);                                                    \
+    if (tm == NULL)                                                                      \
+      caml_failwith(ERROR);                                                              \
+    return alloc_tm(tm);                                                                 \
   }
 
 WRAP_TIME_FUN(localtime, "localtime")
diff --git a/core_unix/src/dune b/core_unix/src/dune
index 296dac2..7609024 100644
--- a/core_unix/src/dune
+++ b/core_unix/src/dune
@@ -8,7 +8,7 @@
  (name core_unix)
  (public_name core_unix)
  (libraries core error_checking_mutex core_kernel.flags sexplib.unix
-   signal_unix spawn)
+   signal_unix spawn ppx_stable_witness.stable_witness unix)
  (preprocess
   (pps ppx_jane ppx_optcomp))
  (preprocessor_deps config.h))
diff --git a/core_unix/src/nss_stubs.c b/core_unix/src/nss_stubs.c
index 9d45102..4574e4b 100644
--- a/core_unix/src/nss_stubs.c
+++ b/core_unix/src/nss_stubs.c
@@ -66,8 +66,8 @@ CAMLprim value core_unix_getgrgid_r(value v_gid, value v_buf) {
   retval = getgrgid_r(gid, &entry, buf, buflen, &result);
   caml_leave_blocking_section();
   /* See [man getgrgid_r] for which return values count as errors */
-  if (retval == EINTR || retval == EIO || retval == EMFILE ||
-      retval == ENFILE || retval == ENOMEM || retval == ERANGE) {
+  if (retval == EINTR || retval == EIO || retval == EMFILE || retval == ENFILE ||
+      retval == ENOMEM || retval == ERANGE) {
     unix_error(retval, "getgrgid_r", caml_alloc_sprintf("%d", Int_val(v_gid)));
   } else {
     if (!result) {
@@ -96,8 +96,8 @@ CAMLprim value core_unix_getpwuid_r(value v_uid, value v_buf) {
   retval = getpwuid_r(uid, &entry, buf, buflen, &result);
   caml_leave_blocking_section();
   /* See [man getpwuid_r] for which return values count as errors */
-  if (retval == EINTR || retval == EIO || retval == EMFILE ||
-      retval == ENFILE || retval == ENOMEM || retval == ERANGE) {
+  if (retval == EINTR || retval == EIO || retval == EMFILE || retval == ENFILE ||
+      retval == ENOMEM || retval == ERANGE) {
     unix_error(retval, "getpwuid_r", caml_alloc_sprintf("%d", Int_val(v_uid)));
   } else {
     if (!result) {
@@ -126,8 +126,8 @@ CAMLprim value core_unix_getpwnam_r(value v_nam, value v_buf) {
   retval = getpwnam_r(nam, &entry, buf, buflen, &result);
   caml_leave_blocking_section();
   /* See [man getpwnam_r] for which return values count as errors */
-  if (retval == EINTR || retval == EIO || retval == EMFILE ||
-      retval == ENFILE || retval == ENOMEM || retval == ERANGE) {
+  if (retval == EINTR || retval == EIO || retval == EMFILE || retval == ENFILE ||
+      retval == ENOMEM || retval == ERANGE) {
     unix_error(retval, "getpwnam_r", v_nam);
   } else {
     if (!result) {
@@ -156,8 +156,8 @@ CAMLprim value core_unix_getgrnam_r(value v_nam, value v_buf) {
   retval = getgrnam_r(nam, &entry, buf, buflen, &result);
   caml_leave_blocking_section();
   /* See [man getgrnam_r] for which return values count as errors */
-  if (retval == EINTR || retval == EIO || retval == EMFILE ||
-      retval == ENFILE || retval == ENOMEM || retval == ERANGE) {
+  if (retval == EINTR || retval == EIO || retval == EMFILE || retval == ENFILE ||
+      retval == ENOMEM || retval == ERANGE) {
     unix_error(retval, "getgrnam_r", v_nam);
   } else {
     if (!result) {
diff --git a/core_unix/test-manual/dune b/core_unix/test-manual/dune
index 35df377..a53f42c 100644
--- a/core_unix/test-manual/dune
+++ b/core_unix/test-manual/dune
@@ -1,6 +1,6 @@
 (executables
  (modes byte exe)
  (names getgrgid_thread_safety)
- (libraries core_kernel.caml_threads core core_unix)
+ (libraries core_kernel.caml_threads core core_unix unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/core_unix/test-manual/getgrgid_thread_safety.ml b/core_unix/test-manual/getgrgid_thread_safety.ml
index bc323c8..2e1ffa3 100644
--- a/core_unix/test-manual/getgrgid_thread_safety.ml
+++ b/core_unix/test-manual/getgrgid_thread_safety.ml
@@ -41,11 +41,11 @@ let alloc n = ignore (List.init (exp2 n) ~f:(fun x -> x))
 let add_finaliser n =
   Gc.finalise
     (function
-     | None -> assert false
-     | Some n ->
-       Printf.printf "finalising %d\n%!" n;
-       alloc n;
-       ())
+      | None -> assert false
+      | Some n ->
+        Printf.printf "finalising %d\n%!" n;
+        alloc n;
+        ())
     (Some n)
 ;;
 
@@ -90,8 +90,8 @@ let () =
     List.concat
       (List.map
          (function
-          | None -> []
-          | Some x -> [ x ])
+           | None -> []
+           | Some x -> [ x ])
          all_groups)
   in
   let group_min, group_min_size = List.fold_left mn (0, 1000000) all_groups in
diff --git a/core_unix/test/cidr_tests.ml b/core_unix/test/cidr_tests.ml
index 5103134..f7393c4 100644
--- a/core_unix/test/cidr_tests.ml
+++ b/core_unix/test/cidr_tests.ml
@@ -7,7 +7,6 @@ open Cidr
 let does_match ?(expected = true) cidr inet_addr =
   let matches = does_match cidr inet_addr in
   require
-    [%here]
     (Bool.equal expected matches)
     ~if_false_then_print_s:
       (lazy
@@ -30,11 +29,9 @@ let invariant ?(expected = Ok ()) string =
   | Ok _, Ok _ | Error _, Error _ -> ()
   | Ok _, Error _ ->
     print_cr
-      [%here]
       [%message "[of_string] + [invariant] succeeded unexpectedly" (string : string)]
   | Error error, Ok _ ->
     print_cr
-      [%here]
       [%message
         "[of_string] + [invariant] failed unexpectedly"
           (string : string)
@@ -46,7 +43,6 @@ let test_all_matching_addresses cidr_string expected_strings =
   let addresses = all_matching_addresses cidr |> Sequence.to_list in
   let expected = List.map expected_strings ~f:Inet_addr.of_string in
   require
-    [%here]
     (List.equal Inet_addr.equal addresses expected)
     ~if_false_then_print_s:
       (lazy
@@ -59,7 +55,6 @@ let test_all_matching_addresses cidr_string expected_strings =
 
 let same str1 str2 =
   require
-    [%here]
     (equal (of_string str1) (of_string str2))
     ~if_false_then_print_s:
       (lazy [%message "should be equal" (str1 : string) (str2 : string)])
@@ -67,7 +62,6 @@ let same str1 str2 =
 
 let diff str1 str2 =
   require
-    [%here]
     (not (equal (of_string str1) (of_string str2)))
     ~if_false_then_print_s:
       (lazy [%message "should NOT be equal" (str1 : string) (str2 : string)])
@@ -120,7 +114,6 @@ let%expect_test _ = match_strings "172.25.42.0/24" "172.26.42.208" ~expected:fal
 let is_subset_strings ?(expected = true) t ~of_ =
   let is_subset = is_subset (of_string t) ~of_:(of_string of_) in
   require
-    [%here]
     (Bool.equal expected is_subset)
     ~if_false_then_print_s:
       (lazy
@@ -209,7 +202,7 @@ let%expect_test "hash function consistency" =
   in
   List.iter t_list ~f:(fun t1 ->
     List.iter t_list ~f:(fun t2 ->
-      if Cidr.compare t1 t2 = 0 then require [%here] (hash t1 = hash t2)))
+      if Cidr.compare t1 t2 = 0 then require (hash t1 = hash t2)))
 ;;
 
 (* differentiate bit counts *)
diff --git a/core_unix/test/test_iovec.ml b/core_unix/test/test_iovec.ml
index 447b50c..68646fc 100644
--- a/core_unix/test/test_iovec.ml
+++ b/core_unix/test/test_iovec.ml
@@ -10,19 +10,22 @@ let print_of_string ?pos ?len str =
 
 let%expect_test "[IOVec.of_string] on empty string" =
   print_of_string "";
-  [%expect {|
+  [%expect
+    {|
     ((buf "")
      (pos 0)
      (len 0))
     |}];
   print_of_string "foo" ~len:0;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 0)
      (len 0))
     |}];
   print_of_string "foo" ~pos:3;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 3)
      (len 0))
@@ -32,13 +35,15 @@ let%expect_test "[IOVec.of_string] on empty string" =
 
 let%expect_test "[IOVec.of_string] on full string" =
   print_of_string "foo";
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 0)
      (len 3))
     |}];
   print_of_string "foo" ~len:3;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 0)
      (len 3))
@@ -48,13 +53,15 @@ let%expect_test "[IOVec.of_string] on full string" =
 
 let%expect_test "[IOVec.of_string] on trailing end of string" =
   print_of_string "foo" ~pos:1;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 1)
      (len 2))
     |}];
   print_of_string "foo" ~pos:1 ~len:2;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 1)
      (len 2))
@@ -63,11 +70,11 @@ let%expect_test "[IOVec.of_string] on trailing end of string" =
 ;;
 
 let%expect_test "[IOVec.of_string] on string too short" =
-  require_does_raise [%here] (fun () -> print_of_string "foo" ~pos:4);
+  require_does_raise (fun () -> print_of_string "foo" ~pos:4);
   [%expect {| (Invalid_argument "IOVec.of_string: pos > length buf") |}];
-  require_does_raise [%here] (fun () -> print_of_string "foo" ~len:4);
+  require_does_raise (fun () -> print_of_string "foo" ~len:4);
   [%expect {| (Invalid_argument "IOVec.of_string: pos + len > length buf") |}];
-  require_does_raise [%here] (fun () -> print_of_string "foo" ~pos:1 ~len:3);
+  require_does_raise (fun () -> print_of_string "foo" ~pos:1 ~len:3);
   [%expect {| (Invalid_argument "IOVec.of_string: pos + len > length buf") |}];
   return ()
 ;;
@@ -79,19 +86,22 @@ let print_of_bigstring ?pos ?len str =
 
 let%expect_test "[IOVec.of_bigstring] on empty bigstring" =
   print_of_bigstring "";
-  [%expect {|
+  [%expect
+    {|
     ((buf "")
      (pos 0)
      (len 0))
     |}];
   print_of_bigstring "foo" ~len:0;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 0)
      (len 0))
     |}];
   print_of_bigstring "foo" ~pos:3;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 3)
      (len 0))
@@ -101,13 +111,15 @@ let%expect_test "[IOVec.of_bigstring] on empty bigstring" =
 
 let%expect_test "[IOVec.of_bigstring] on full bigstring" =
   print_of_bigstring "foo";
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 0)
      (len 3))
     |}];
   print_of_bigstring "foo" ~len:3;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 0)
      (len 3))
@@ -117,13 +129,15 @@ let%expect_test "[IOVec.of_bigstring] on full bigstring" =
 
 let%expect_test "[IOVec.of_bigstring] on trailing end of bigstring" =
   print_of_bigstring "foo" ~pos:1;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 1)
      (len 2))
     |}];
   print_of_bigstring "foo" ~pos:1 ~len:2;
-  [%expect {|
+  [%expect
+    {|
     ((buf foo)
      (pos 1)
      (len 2))
@@ -132,11 +146,11 @@ let%expect_test "[IOVec.of_bigstring] on trailing end of bigstring" =
 ;;
 
 let%expect_test "[IOVec.of_bigstring] on bigstring too short" =
-  require_does_raise [%here] (fun () -> print_of_bigstring "foo" ~pos:4);
+  require_does_raise (fun () -> print_of_bigstring "foo" ~pos:4);
   [%expect {| (Invalid_argument "IOVec.of_bigstring: pos > length buf") |}];
-  require_does_raise [%here] (fun () -> print_of_bigstring "foo" ~len:4);
+  require_does_raise (fun () -> print_of_bigstring "foo" ~len:4);
   [%expect {| (Invalid_argument "IOVec.of_bigstring: pos + len > length buf") |}];
-  require_does_raise [%here] (fun () -> print_of_bigstring "foo" ~pos:1 ~len:3);
+  require_does_raise (fun () -> print_of_bigstring "foo" ~pos:1 ~len:3);
   [%expect {| (Invalid_argument "IOVec.of_bigstring: pos + len > length buf") |}];
   return ()
 ;;
diff --git a/core_unix/test/test_unix.ml b/core_unix/test/test_unix.ml
index e50778d..9fb9d21 100644
--- a/core_unix/test/test_unix.ml
+++ b/core_unix/test/test_unix.ml
@@ -6,8 +6,9 @@ let%expect_test "[File_descr.sexp_of_t]" =
   print_s
     [%sexp
       (List.map [ -1; 0; 1; 2; 3 ] ~f:(fun i -> i, i |> File_descr.of_int)
-        : (int * File_descr.t) list)];
-  [%expect {|
+       : (int * File_descr.t) list)];
+  [%expect
+    {|
     ((-1 -1)
      (0  0)
      (1  1)
@@ -33,7 +34,7 @@ let%expect_test "[mkdir_p ~perm name] sets the permissions on [name] and all oth
   let make_require_and_remove_dir lex dir =
     let dir_perms = (stat dir).st_perm in
     let lazy_sexp = lazy (Sexp.Atom (sprintf "%s has perms %o" dir dir_perms)) in
-    require ~if_false_then_print_s:lazy_sexp lex (perm = dir_perms);
+    require ~if_false_then_print_s:lazy_sexp ~here:lex (perm = dir_perms);
     remove dir
   in
   make_require_and_remove_dir [%here] dir;
@@ -53,7 +54,6 @@ let%expect_test "[mkdtemp] dir name contains [.tmp.]" =
   let dir = mkdtemp "foo" in
   rmdir dir;
   require
-    [%here]
     (String.is_substring (Filename.basename dir) ~substring:".tmp.")
     ~if_false_then_print_s:(lazy [%message (dir : string)]);
   [%expect {| |}]
@@ -64,7 +64,6 @@ let%expect_test "[mkstemp] file name contains [.tmp.]" =
   unlink file;
   close fd;
   require
-    [%here]
     (String.is_substring (Filename.basename file) ~substring:".tmp.")
     ~if_false_then_print_s:(lazy [%message (file : string)]);
   [%expect {| |}]
@@ -98,26 +97,26 @@ let%test_unit "fork_exec ~env last binding takes precedence" =
     ~finally:remove
     (Filename_unix.temp_file "test" "fork_exec.env.last-wins")
     ~f:(fun temp_file ->
-    let var_in_child env =
-      waitpid_exn
-        (fork_exec
-           ()
-           ~env
-           ~prog:"sh"
-           ~argv:[ "sh"; "-c"; "echo -n ${VAR-undefined} > " ^ temp_file ]);
-      In_channel.read_all temp_file
-    in
-    let env = [ "VAR", "first"; "VAR", "last" ] in
-    List.iter
-      [ `Replace_raw (List.map env ~f:(fun (v, s) -> v ^ "=" ^ s))
-      ; `Replace env
-      ; `Extend env
-      ; `Override (List.map env ~f:(fun (v, s) -> v, Some s))
-      ]
-      ~f:(fun env -> [%test_result: string] ~expect:"last" (var_in_child env));
-    Unix.putenv ~key:"VAR" ~data:"in-process";
-    let env = `Override [ "VAR", None ] in
-    [%test_result: string] ~expect:"undefined" (var_in_child env))
+      let var_in_child env =
+        waitpid_exn
+          (fork_exec
+             ()
+             ~env
+             ~prog:"sh"
+             ~argv:[ "sh"; "-c"; "echo -n ${VAR-undefined} > " ^ temp_file ]);
+        In_channel.read_all temp_file
+      in
+      let env = [ "VAR", "first"; "VAR", "last" ] in
+      List.iter
+        [ `Replace_raw (List.map env ~f:(fun (v, s) -> v ^ "=" ^ s))
+        ; `Replace env
+        ; `Extend env
+        ; `Override (List.map env ~f:(fun (v, s) -> v, Some s))
+        ]
+        ~f:(fun env -> [%test_result: string] ~expect:"last" (var_in_child env));
+      Unix.putenv ~key:"VAR" ~data:"in-process";
+      let env = `Override [ "VAR", None ] in
+      [%test_result: string] ~expect:"undefined" (var_in_child env))
 ;;
 
 let%test_module _ =
@@ -150,9 +149,9 @@ let%test_module _ =
 let%expect_test "close-on-exec" =
   let r, w = pipe ~close_on_exec:true () in
   clear_close_on_exec r;
-  require_equal [%here] (module Bool) false (get_close_on_exec r);
+  require_equal (module Bool) false (get_close_on_exec r);
   [%expect {| |}];
-  require_equal [%here] (module Bool) true (get_close_on_exec w);
+  require_equal (module Bool) true (get_close_on_exec w);
   [%expect {| |}];
   close r;
   close w
@@ -231,7 +230,6 @@ let%expect_test "strptime match" =
     { res with Unix.tm_wday; tm_yday }
   in
   require_equal
-    [%here]
     (module Unix_tm_for_testing)
     res
     { Unix.tm_sec = 23
@@ -247,7 +245,7 @@ let%expect_test "strptime match" =
 ;;
 
 let%expect_test "strptime match failed" =
-  require_does_raise [%here] (fun () -> strptime ~fmt:"%Y-%m-%d" "2012-05-");
+  require_does_raise (fun () -> strptime ~fmt:"%Y-%m-%d" "2012-05-");
   [%expect {| (Failure "unix_strptime: match failed") |}]
 ;;
 
@@ -255,7 +253,7 @@ let%expect_test "strptime trailing input" =
   print_s
     [%sexp
       (strptime ~allow_trailing_input:true ~fmt:"%Y-%m-%d" "2012-05-23 10:14:23"
-        : Unix_tm_for_testing.t)];
+       : Unix_tm_for_testing.t)];
   [%expect
     {|
     ((tm_sec   0)
@@ -268,7 +266,7 @@ let%expect_test "strptime trailing input" =
      (tm_yday  143)
      (tm_isdst false))
     |}];
-  require_does_raise [%here] (fun () -> strptime ~fmt:"%Y-%m-%d" "2012-05-23 10:14:23");
+  require_does_raise (fun () -> strptime ~fmt:"%Y-%m-%d" "2012-05-23 10:14:23");
   [%expect {| (Failure "unix_strptime: did not consume entire input") |}]
 ;;
 
@@ -421,11 +419,11 @@ let%test_module "the search path passed to [create_process_env] has an effect" =
     let call_ls = Unix.create_process_env ~prog:"ls" ~args:[] ~env:(`Extend [])
 
     let%expect_test "default search path" =
-      require_does_not_raise [%here] (fun () -> ignore (Sys.opaque_identity (call_ls ())))
+      require_does_not_raise (fun () -> ignore (Sys.opaque_identity (call_ls ())))
     ;;
 
     let%expect_test "empty search path" =
-      require_does_raise [%here] (fun () -> call_ls ~prog_search_path:[] ());
+      require_does_raise (fun () -> call_ls ~prog_search_path:[] ());
       [%expect
         {| (Invalid_argument "Core_unix.create_process: empty prog_search_path") |}]
     ;;
@@ -492,13 +490,13 @@ let%expect_test ("Clock.get_cpuclock_for" [@tags "64-bits-only"]) =
   let gettime = ok_exn Unix.Clock.gettime in
   (* This pid is too large to be real  *)
   let bad_pid = Pid.of_int 100_000_000 in
-  require_does_raise [%here] (fun () -> get_cpuclock_for bad_pid);
+  require_does_raise (fun () -> get_cpuclock_for bad_pid);
   [%expect {| (Unix.Unix_error "No such process" clock_getcpuclockid "") |}];
   let clock = get_cpuclock_for (Unix.getpid ()) in
   let cputime = gettime (Custom clock) in
   (* Testing cpu clocks are hard, but this doesn't crash, and we've definitely accrued cpu
      time. *)
-  require [%here] Int63.(cputime > zero);
+  require Int63.(cputime > zero);
   [%expect {| |}]
 ;;
 
diff --git a/core_unix/test/test_unix_cidr.ml b/core_unix/test/test_unix_cidr.ml
index 9ad6559..8fa7535 100644
--- a/core_unix/test/test_unix_cidr.ml
+++ b/core_unix/test/test_unix_cidr.ml
@@ -3,14 +3,14 @@ open! Import
 
 let%test_module "Unix.Cidr.Stable.V1" =
   (module Stable_unit_test.Make (struct
-    include Unix.Cidr.Stable.V1
+      include Unix.Cidr.Stable.V1
 
-    let equal a b = compare a b = 0
+      let equal a b = compare a b = 0
 
-    let tests =
-      [ Unix.Cidr.of_string "0.0.0.0/8", "0.0.0.0/8", "\000\b"
-      ; Unix.Cidr.of_string "123.213.1.51/13", "123.208.0.0/13", "\253\000\000\208{\r"
-      ]
-    ;;
-  end))
+      let tests =
+        [ Unix.Cidr.of_string "0.0.0.0/8", "0.0.0.0/8", "\000\b"
+        ; Unix.Cidr.of_string "123.213.1.51/13", "123.208.0.0/13", "\253\000\000\208{\r"
+        ]
+      ;;
+    end))
 ;;
diff --git a/daemon/test-bin/dune b/daemon/test-bin/dune
index 25c81ff..3493d6f 100644
--- a/daemon/test-bin/dune
+++ b/daemon/test-bin/dune
@@ -7,6 +7,6 @@
 (executables
  (modes byte exe)
  (names daemonize_test)
- (libraries core_unix daemon)
+ (libraries core core_unix daemon unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/date_unix/src/dune b/date_unix/src/dune
index 9f5d9c0..e3c81bd 100644
--- a/date_unix/src/dune
+++ b/date_unix/src/dune
@@ -1,6 +1,6 @@
 (library
  (name date_unix)
  (public_name core_unix.date_unix)
- (libraries core time_float_unix)
+ (libraries core core_unix time_float_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/date_unix/test/dune b/date_unix/test/dune
index 3326588..ee3fd05 100644
--- a/date_unix/test/dune
+++ b/date_unix/test/dune
@@ -1,5 +1,5 @@
 (library
  (name date_unix_test)
- (libraries date_unix)
+ (libraries core date_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/error_checking_mutex/test/dune b/error_checking_mutex/test/dune
index 27deb38..0a2d9c8 100644
--- a/error_checking_mutex/test/dune
+++ b/error_checking_mutex/test/dune
@@ -1,6 +1,6 @@
 (library
  (name error_checking_mutex_test)
- (libraries core_kernel.caml_threads error_checking_mutex
+ (libraries core_kernel.caml_threads core error_checking_mutex
    expect_test_helpers_core)
  (preprocess
   (pps ppx_jane)))
diff --git a/error_checking_mutex/test/test_error_checking_mutex.ml b/error_checking_mutex/test/test_error_checking_mutex.ml
index a7cd765..1d1d9b2 100644
--- a/error_checking_mutex/test/test_error_checking_mutex.ml
+++ b/error_checking_mutex/test/test_error_checking_mutex.ml
@@ -14,17 +14,15 @@ let try_with_mutex f =
 
 let%expect_test "double lock" =
   require
-    [%here]
     (try_with_mutex (fun mtx ->
        Mutex.lock mtx;
        Mutex.lock mtx))
 ;;
 
-let%expect_test "unlock unlocked" = require [%here] (try_with_mutex Mutex.unlock)
+let%expect_test "unlock unlocked" = require (try_with_mutex Mutex.unlock)
 
 let%expect_test "unlock other locked" =
   require
-    [%here]
     (try_with_mutex (fun mtx ->
        Thread.join (Thread.create (fun () -> Mutex.lock mtx) ());
        Mutex.unlock mtx))
diff --git a/filename_unix/src/dune b/filename_unix/src/dune
index 76eedf1..334c79a 100644
--- a/filename_unix/src/dune
+++ b/filename_unix/src/dune
@@ -7,6 +7,6 @@
    ()))
  (name filename_unix)
  (public_name core_unix.filename_unix)
- (libraries unix core sys_unix)
+ (libraries unix core_kernel.caml_unix core sys_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/filename_unix/test/dune b/filename_unix/test/dune
index 8b20212..e5d58eb 100644
--- a/filename_unix/test/dune
+++ b/filename_unix/test/dune
@@ -1,6 +1,6 @@
 (library
  (name filename_unix_test)
- (libraries expect_test_helpers_core.expect_test_helpers_base filename_unix
-   sys_unix)
+ (libraries core expect_test_helpers_core.expect_test_helpers_base
+   filename_unix sys_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/filename_unix/test/test_filename_unix.ml b/filename_unix/test/test_filename_unix.ml
index aef4d5a..2631b13 100644
--- a/filename_unix/test/test_filename_unix.ml
+++ b/filename_unix/test/test_filename_unix.ml
@@ -5,7 +5,6 @@ let%expect_test "temporary file names contain [.tmp.]" =
   let file = Filename_unix.temp_file "foo" "" in
   Sys_unix.remove file;
   require
-    [%here]
     (String.equal ".tmp." (String.sub file ~pos:(String.length file - 11) ~len:5))
     ~if_false_then_print_s:(lazy [%message (file : string)]);
   [%expect {| |}]
diff --git a/interval_lib/src/dune b/interval_lib/src/dune
index 9f6cbd1..3e70889 100644
--- a/interval_lib/src/dune
+++ b/interval_lib/src/dune
@@ -1,6 +1,6 @@
 (library
  (name interval_lib)
  (public_name core_unix.interval_lib)
- (libraries core)
+ (libraries core ppx_stable_witness.stable_witness)
  (preprocess
   (pps ppx_jane)))
diff --git a/interval_lib/src/interval.ml b/interval_lib/src/interval.ml
index 86d3ec7..4c724be 100644
--- a/interval_lib/src/interval.ml
+++ b/interval_lib/src/interval.ml
@@ -9,10 +9,11 @@ module Stable = struct
       type 'a t =
         | Interval of 'a * 'a
         | Empty
-      [@@deriving bin_io, of_sexp, variants, compare, hash, sexp_grammar, stable_witness]
+      [@@deriving
+        bin_io, of_sexp, variants, compare, equal, hash, sexp_grammar, stable_witness]
 
       type 'a interval = 'a t
-      [@@deriving bin_io, of_sexp, compare, hash, sexp_grammar, stable_witness]
+      [@@deriving bin_io, of_sexp, compare, equal, hash, sexp_grammar, stable_witness]
 
       let interval_of_sexp a_of_sexp sexp =
         try interval_of_sexp a_of_sexp sexp (* for backwards compatibility *) with
@@ -46,12 +47,12 @@ module Stable = struct
     open T
 
     type 'a t = 'a interval
-    [@@deriving sexp, bin_io, compare, hash, sexp_grammar, stable_witness]
+    [@@deriving sexp, bin_io, compare, equal, hash, sexp_grammar, stable_witness]
 
     module Float = struct
       module T = struct
         type t = float interval
-        [@@deriving sexp, bin_io, compare, hash, sexp_grammar, stable_witness]
+        [@@deriving sexp, bin_io, compare, equal, hash, sexp_grammar, stable_witness]
       end
 
       include T
@@ -61,7 +62,7 @@ module Stable = struct
     module Int = struct
       module T = struct
         type t = int interval
-        [@@deriving sexp, bin_io, compare, hash, sexp_grammar, stable_witness]
+        [@@deriving sexp, bin_io, compare, equal, hash, sexp_grammar, stable_witness]
       end
 
       include T
@@ -74,7 +75,7 @@ module Stable = struct
     module Ofday = struct
       module T = struct
         type t = Core.Time_float.Stable.Ofday.V1.t interval
-        [@@deriving sexp, bin_io, compare, hash, sexp_grammar, stable_witness]
+        [@@deriving sexp, bin_io, compare, equal, hash, sexp_grammar, stable_witness]
       end
 
       include T
@@ -84,7 +85,7 @@ module Stable = struct
     module Ofday_ns = struct
       module T = struct
         type t = Core.Time_ns.Stable.Ofday.V1.t interval
-        [@@deriving sexp, bin_io, compare, sexp_grammar, stable_witness]
+        [@@deriving sexp, bin_io, compare, equal, hash, sexp_grammar, stable_witness]
       end
 
       include T
@@ -309,12 +310,12 @@ module Raw_make (T : Bound) = struct
          intersect, and that will capture all necessary merges.  *)
       drop_empty_intervals_and_sort intervals
       |> List.fold ~init:[] ~f:(fun acc interval ->
-           match acc with
-           | [] -> [ interval ]
-           | prev_interval :: tl ->
-             if Interval.are_disjoint [ prev_interval; interval ]
-             then interval :: acc
-             else Interval.convex_hull [ prev_interval; interval ] :: tl)
+        match acc with
+        | [] -> [ interval ]
+        | prev_interval :: tl ->
+          if Interval.are_disjoint [ prev_interval; interval ]
+          then interval :: acc
+          else Interval.convex_hull [ prev_interval; interval ] :: tl)
       |> List.rev
     ;;
 
@@ -369,13 +370,13 @@ module Raw_make (T : Bound) = struct
   end
 end
 
-type 'a t = 'a interval [@@deriving bin_io, sexp, compare, hash]
+type 'a t = 'a interval [@@deriving bin_io, sexp, compare, equal, hash]
 
 module C = Raw_make (struct
-  type 'a bound = 'a
+    type 'a bound = 'a
 
-  include Poly
-end)
+    include Poly
+  end)
 
 include C.Interval
 
@@ -386,28 +387,28 @@ let t_of_sexp a_of_sexp s =
 ;;
 
 module Set = struct
-  type 'a t = 'a interval list [@@deriving bin_io, sexp, compare, hash]
+  type 'a t = 'a interval list [@@deriving bin_io, sexp, compare, equal, hash]
 
   include C.Set
 end
 
 module Make (Bound : sig
-  type t [@@deriving bin_io, sexp, hash]
+    type t [@@deriving bin_io, compare, equal, hash, sexp]
 
-  include Comparable.S with type t := t
-end) =
+    include Comparable.S with type t := t
+  end) =
 struct
-  type t = Bound.t interval [@@deriving bin_io, sexp, compare, hash]
+  type t = Bound.t interval [@@deriving bin_io, sexp, compare, equal, hash]
   type interval = t [@@deriving bin_io, sexp]
   type bound = Bound.t
 
   module C = Raw_make (struct
-    type 'a bound = Bound.t
+      type 'a bound = Bound.t
 
-    let compare = Bound.compare
+      let compare = Bound.compare
 
-    include (Bound : Comparable.Infix with type t := Bound.t)
-  end)
+      include (Bound : Comparable.Infix with type t := Bound.t)
+    end)
 
   include C.Interval
 
@@ -490,14 +491,14 @@ module Int = struct
   ;;
 
   module For_container = Container.Make0 (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    module Elt = Int
+      module Elt = Int
 
-    let iter = `Custom iter
-    let fold = fold
-    let length = `Custom length
-  end)
+      let iter = `Custom iter
+      let fold = fold
+      let length = `Custom length
+    end)
 
   let exists = For_container.exists
   let for_all = For_container.for_all
@@ -522,27 +523,25 @@ module Int = struct
     else ubound t
   ;;
 
-  let mem t x =
-    if not (phys_equal equal Int.equal) then For_container.mem t x else contains t x
-  ;;
+  let mem t x = contains t x
 
   (* Note that we use zero-based indexing here, because that's what Binary_searchable
      requires, even though at the end we want to export functions that use the natural
      bounds of the interval.  *)
   module For_binary_search = Binary_searchable.Make (struct
-    type nonrec t = t
-    type nonrec elt = bound
+      type nonrec t = t
+      type nonrec elt = bound
 
-    let length = length
-    let get = get
-  end)
+      let length = length
+      let get = get
+    end)
 
   let binary_search ?pos ?len t ~compare which elt =
     let zero_based_pos = Option.map pos ~f:(fun x -> x - lbound_exn t) in
     let zero_based_result =
       For_binary_search.binary_search ?pos:zero_based_pos ?len t ~compare which elt
     in
-    Option.map zero_based_result ~f:(fun x -> x + lbound_exn t)
+    Option.map_local zero_based_result ~f:(fun x -> x + lbound_exn t)
   ;;
 
   let binary_search_segmented ?pos ?len t ~segment_of which =
@@ -555,7 +554,7 @@ module Int = struct
         ~segment_of
         which
     in
-    Option.map zero_based_result ~f:(fun x -> x + lbound_exn t)
+    Option.map_local zero_based_result ~f:(fun x -> x + lbound_exn t)
   ;;
 
   module Private = struct
diff --git a/interval_lib/src/interval_intf.ml b/interval_lib/src/interval_intf.ml
index ae16e80..598c536 100644
--- a/interval_lib/src/interval_intf.ml
+++ b/interval_lib/src/interval_intf.ml
@@ -156,7 +156,7 @@ module type Gen_set = sig
 end
 
 module type S = sig
-  type t [@@deriving bin_io, sexp, compare, hash]
+  type t [@@deriving bin_io, sexp, compare, equal, hash]
   type bound
 
   include Gen with type 'a t := t with type 'a bound := bound (** @inline *)
@@ -172,37 +172,37 @@ module type S = sig
   type 'a poly_set
 
   module Set : sig
-    type t [@@deriving bin_io, sexp]
+      type t [@@deriving bin_io, sexp]
 
-    include Gen_set with type 'a t := t with type 'a bound := bound (** @inline *)
+      include Gen_set with type 'a t := t with type 'a bound := bound (** @inline *)
 
-    val to_poly : t -> bound poly_set
+      val to_poly : t -> bound poly_set
 
-    (** [to_list] will return a list of non-overlapping intervals defining the set, in
+      (** [to_list] will return a list of non-overlapping intervals defining the set, in
         ascending order.  *)
-    val to_list : t -> bound interval list
-  end
-  with type 'a interval := t
+      val to_list : t -> bound interval list
+    end
+    with type 'a interval := t
 end
 
 module type S1 = sig
   (** This type [t] supports bin-io and sexp conversion by way of the
       [[@@deriving bin_io, sexp]] extensions, which inline the relevant function
       signatures (like [bin_read_t] and [t_of_sexp]). *)
-  type 'a t [@@deriving bin_io, sexp, compare, hash]
+  type 'a t [@@deriving bin_io, sexp, compare, equal, hash]
 
   include Gen with type 'a t := 'a t with type 'a bound := 'a (** @inline *)
 
   module Set : sig
-    type 'a t [@@deriving bin_io, sexp]
+      type 'a t [@@deriving bin_io, sexp]
 
-    include Gen_set with type 'a t := 'a t with type 'a bound := 'a (** @inline *)
-  end
-  with type 'a interval := 'a t
+      include Gen_set with type 'a t := 'a t with type 'a bound := 'a (** @inline *)
+    end
+    with type 'a interval := 'a t
 end
 
 module type S_stable = sig
-  type t [@@deriving sexp_grammar]
+  type t [@@deriving equal, hash, sexp_grammar]
 
   include Stable_with_witness with type t := t
 end
@@ -302,7 +302,7 @@ module type Interval = sig
       {[
         module Percent = struct
           module T = struct
-            type t = float [@@deriving bin_io, compare, sexp]
+            type t = float [@@deriving bin_io, compare, equal, hash, sexp]
           end
           include T
           include Comparable.Make_binable(T)
@@ -310,10 +310,10 @@ module type Interval = sig
       ]}
   *)
   module Make (Bound : sig
-    type t [@@deriving bin_io, sexp, hash]
+      type t [@@deriving bin_io, compare, equal, hash, sexp]
 
-    include Comparable.S with type t := t
-  end) : S with type bound = Bound.t and type t = Bound.t t
+      include Comparable.S with type t := t
+    end) : S with type bound = Bound.t and type t = Bound.t t
 
   (**
      [Stable] is used to build stable protocols. It ensures backwards compatibility by
@@ -323,7 +323,7 @@ module type Interval = sig
   module Stable : sig
     module V1 : sig
       type nonrec 'a t = 'a t
-      [@@deriving bin_io, compare, hash, sexp, sexp_grammar, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
 
       module Float : S_stable with type t = Float.t
       module Int : S_stable with type t = Int.t
@@ -343,7 +343,7 @@ module type Interval = sig
         type 'a t =
           | Interval of 'a * 'a
           | Empty
-        [@@deriving compare, variants]
+        [@@deriving compare, equal, hash, variants]
 
         val to_float : float t -> Float.t
         val to_int : int t -> Int.t
@@ -363,9 +363,9 @@ module type Interval = sig
     https://opensource.janestreet.com/standards/#private-submodules *)
   module Private : sig
     module Make (Bound : sig
-      type t [@@deriving bin_io, sexp, hash]
+        type t [@@deriving bin_io, sexp, hash]
 
-      include Comparable.S with type t := t
-    end) : S with type bound = Bound.t and type t = Bound.t t
+        include Comparable.S with type t := t
+      end) : S with type bound = Bound.t and type t = Bound.t t
   end
 end
diff --git a/interval_lib/test/test_interval.ml b/interval_lib/test/test_interval.ml
index b917239..f33b84d 100644
--- a/interval_lib/test/test_interval.ml
+++ b/interval_lib/test/test_interval.ml
@@ -6,7 +6,8 @@ let%expect_test "list_intersect" =
   let i = Interval.create in
   let x = Interval.list_intersect [ i 4 7; i 9 15 ] [ i 2 4; i 5 10; i 14 20 ] in
   print_s [%sexp (x : int Interval.t list)];
-  [%expect {|
+  [%expect
+    {|
     ((4  4)
      (5  7)
      (9  10)
@@ -36,20 +37,20 @@ let%test_module _ =
 
     let%test_module "Interval.V1.Float" =
       (module Stable_unit_test.Make (struct
-        include V1.Float
+          include V1.Float
 
-        let equal = [%compare.equal: t]
+          let equal = [%compare.equal: t]
 
-        let tests =
-          make_stable_unit_tests_v1
-            ~coerce:V1.Private.to_float
-            ~non_empty:
-              [ ( (1.5, 120.)
-                , "(1.5 120)"
-                , "\000\000\000\000\000\000\000\248?\000\000\000\000\000\000^@" )
-              ]
-        ;;
-      end))
+          let tests =
+            make_stable_unit_tests_v1
+              ~coerce:V1.Private.to_float
+              ~non_empty:
+                [ ( (1.5, 120.)
+                  , "(1.5 120)"
+                  , "\000\000\000\000\000\000\000\248?\000\000\000\000\000\000^@" )
+                ]
+          ;;
+        end))
     ;;
 
     let%expect_test "Interval.V1.Float.t_sexp_grammar" =
@@ -59,16 +60,16 @@ let%test_module _ =
 
     let%test_module "Interval.V1.Int" =
       (module Stable_unit_test.Make (struct
-        include V1.Int
+          include V1.Int
 
-        let equal = [%compare.equal: t]
+          let equal = [%compare.equal: t]
 
-        let tests =
-          make_stable_unit_tests_v1
-            ~coerce:V1.Private.to_int
-            ~non_empty:[ (-5, 789), "(-5 789)", "\000\255\251\254\021\003" ]
-        ;;
-      end))
+          let tests =
+            make_stable_unit_tests_v1
+              ~coerce:V1.Private.to_int
+              ~non_empty:[ (-5, 789), "(-5 789)", "\000\255\251\254\021\003" ]
+          ;;
+        end))
     ;;
 
     let%expect_test "Interval.V1.Int.t_sexp_grammar" =
@@ -78,22 +79,22 @@ let%test_module _ =
 
     let%test_module "Interval.V1.Ofday" =
       (module Stable_unit_test.Make (struct
-        include V1.Ofday
+          include V1.Ofday
 
-        let equal = [%compare.equal: t]
+          let equal = [%compare.equal: t]
 
-        let tests =
-          let t1 = Time_float.Ofday.create ~hr:7 ~min:30 ~sec:7 ~ms:12 ~us:5 () in
-          let t2 = Time_float.Ofday.create ~hr:9 ~min:45 ~sec:8 ~ms:0 ~us:1 () in
-          make_stable_unit_tests_v1
-            ~coerce:V1.Private.to_ofday
-            ~non_empty:
-              [ ( (t1, t2)
-                , "(07:30:07.012005 09:45:08.000001)"
-                , "\000\153\158\176\196\192_\218@\223\024\002\000\128$\225@" )
-              ]
-        ;;
-      end))
+          let tests =
+            let t1 = Time_float.Ofday.create ~hr:7 ~min:30 ~sec:7 ~ms:12 ~us:5 () in
+            let t2 = Time_float.Ofday.create ~hr:9 ~min:45 ~sec:8 ~ms:0 ~us:1 () in
+            make_stable_unit_tests_v1
+              ~coerce:V1.Private.to_ofday
+              ~non_empty:
+                [ ( (t1, t2)
+                  , "(07:30:07.012005 09:45:08.000001)"
+                  , "\000\153\158\176\196\192_\218@\223\024\002\000\128$\225@" )
+                ]
+          ;;
+        end))
     ;;
 
     let%expect_test "Interval.V1.Ofday.t_sexp_grammar" =
@@ -270,7 +271,9 @@ let%test_module "vs array" =
         interval_and_nearby_int
         ~sexp_of:[%sexp_of: t * int]
         ~f:(fun (t, i) ->
-        [%test_result: bool] ~expect:(Array.mem ~equal:Int.equal (to_array t) i) (mem t i))
+          [%test_result: bool]
+            ~expect:(Array.mem ~equal:Int.equal (to_array t) i)
+            (mem t i))
     ;;
 
     let%test_unit "binary_search" =
@@ -283,12 +286,18 @@ let%test_module "vs array" =
           [%test_result: int option]
             ~expect:
               (Array.binary_search array ~compare which i
+               |> [%globalize: int option]
                |> Option.map ~f:(Array.get array))
-            (binary_search t ~compare which i))
+            (binary_search t ~compare which i |> [%globalize: int option]))
     ;;
 
     let%expect_test "explicit binary_search" =
-      let pr x = print_endline @@ Sexp.to_string_hum @@ [%sexp_of: int option] x in
+      let pr x =
+        print_endline
+        @@ Sexp.to_string_hum
+        @@ [%sexp_of: int option]
+        @@ [%globalize: int option] x
+      in
       pr
       @@ binary_search (create 4 80) ~compare:Int.compare `First_strictly_greater_than 18;
       [%expect {| (19) |}];
@@ -360,7 +369,8 @@ let%test_module _ =
       test [ 1; 3; 4 ];
       [%expect {| ((1 3)) |}];
       test [ 5; 1; 10; 11; 1; 7; 9; 2; 5 ];
-      [%expect {|
+      [%expect
+        {|
         ((1 2)
          (5 7)
          (9 10))
@@ -417,7 +427,8 @@ let%test_module _ =
 
     let%expect_test "union demo" =
       print_s [%sexp (Set.union t1 t2 : int Set.t)];
-      [%expect {|
+      [%expect
+        {|
         ((1  12)
          (15 20))
         |}]
@@ -425,7 +436,8 @@ let%test_module _ =
 
     let%expect_test "intersect demo" =
       print_s [%sexp (Set.inter t1 t2 : int Set.t)];
-      [%expect {|
+      [%expect
+        {|
         ((3 5)
          (6 10))
         |}]
@@ -434,7 +446,8 @@ let%test_module _ =
     let%expect_test "union_list demo" =
       let ts = [ t1; t2; Set.create_exn [ 11, 13; 14, 15 ]; Set.create_exn [ 20, 22 ] ] in
       print_s [%sexp (Set.union_list ts : int Set.t)];
-      [%expect {|
+      [%expect
+        {|
         ((1  13)
          (14 22))
         |}]
diff --git a/interval_unix/src/dune b/interval_unix/src/dune
index 5a5826e..f55ff89 100644
--- a/interval_unix/src/dune
+++ b/interval_unix/src/dune
@@ -1,6 +1,6 @@
 (library
  (name interval_unix)
  (public_name core_unix.interval_unix)
- (libraries core interval_lib time_ns_unix)
+ (libraries core interval_lib time_float_unix time_ns_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/interval_unix/test/dune b/interval_unix/test/dune
index 4a925b2..1a19ae8 100644
--- a/interval_unix/test/dune
+++ b/interval_unix/test/dune
@@ -1,6 +1,6 @@
 (library
  (name interval_unix_test)
- (libraries expect_test_helpers_core interval_lib_test interval_unix
-   jane_timezone time_float_unix)
+ (libraries core expect_test_helpers_core interval_lib interval_lib_test
+   interval_unix time_float_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/interval_unix/test/test_interval_unix.ml b/interval_unix/test/test_interval_unix.ml
index cd62505..6706c98 100644
--- a/interval_unix/test/test_interval_unix.ml
+++ b/interval_unix/test/test_interval_unix.ml
@@ -9,7 +9,7 @@ let%test_module "Interval.V1.Time" =
       include Interval_unix.Stable.V1.Time
 
       let equal = [%compare.equal: t]
-      let zone = force Jane_timezone.nyc
+      let zone = force Timezone.nyc
 
       let tests =
         let t1 =
diff --git a/iobuf_unix/src/dune b/iobuf_unix/src/dune
index ad30b53..7052873 100644
--- a/iobuf_unix/src/dune
+++ b/iobuf_unix/src/dune
@@ -4,7 +4,7 @@
   (names iobuf_stubs))
  (name iobuf_unix)
  (public_name core_unix.iobuf_unix)
- (libraries bigstring_unix core core_kernel.iobuf)
+ (libraries bigstring_unix core core_unix core_kernel.iobuf)
  (preprocessor_deps config.h)
  (preprocess
   (pps ppx_jane ppx_optcomp)))
diff --git a/iobuf_unix/src/iobuf_stubs.c b/iobuf_unix/src/iobuf_stubs.c
index 5ff2fd0..cc8e075 100644
--- a/iobuf_unix/src/iobuf_stubs.c
+++ b/iobuf_unix/src/iobuf_stubs.c
@@ -1,3 +1,5 @@
+#undef Hide_upstream_size_macros
+
 #include "config.h"
 #include "iobuf.h"
 #include "unix_utils.h"
diff --git a/iobuf_unix/src/iobuf_unix.ml b/iobuf_unix/src/iobuf_unix.ml
index cb3cb58..f500a36 100644
--- a/iobuf_unix/src/iobuf_unix.ml
+++ b/iobuf_unix/src/iobuf_unix.ml
@@ -109,7 +109,7 @@ external unsafe_recvmmsg_assume_fd_is_nonblocking
   -> Recvmmsg_context.ctx
   -> Unix.Syscall_result.Int.t
   = "iobuf_recvmmsg_assume_fd_is_nonblocking_stub"
-  [@@noalloc]
+[@@noalloc]
 
 let recvmmsg_assume_fd_is_nonblocking fd { Recvmmsg_context.iobufs; ctx; _ } =
   unsafe_recvmmsg_assume_fd_is_nonblocking fd iobufs ctx
@@ -229,7 +229,7 @@ module Expert = struct
     -> (float[@unboxed])
     -> int
     = "iobuf_unsafe_pokef_double_bytecode" "iobuf_unsafe_pokef_double"
-    [@@noalloc]
+  [@@noalloc]
 
   let fillf_float t ~c_format value =
     let limit = length t in
diff --git a/iobuf_unix/src/iobuf_unix.mli b/iobuf_unix/src/iobuf_unix.mli
index 16f6b9b..7f107e1 100644
--- a/iobuf_unix/src/iobuf_unix.mli
+++ b/iobuf_unix/src/iobuf_unix.mli
@@ -40,14 +40,14 @@ val recvfrom_assume_fd_is_nonblocking
     returned iobufs have had their underlying bigstring or limits changed (e.g., through a
     call to [set_bounds_and_buffer] or [narrow_lo]), the call will fail with [EINVAL]. *)
 module Recvmmsg_context : sig
-  type ('rw, 'seek) iobuf
-  type t
+    type ('rw, 'seek) iobuf
+    type t
 
-  (** Do not change these [Iobuf]'s [buf]s or limits before calling
+    (** Do not change these [Iobuf]'s [buf]s or limits before calling
       [recvmmsg_assume_fd_is_nonblocking]. *)
-  val create : (read_write, seek) iobuf array -> t
-end
-with type ('rw, 'seek) iobuf := ('rw, 'seek) t
+    val create : (read_write, seek) iobuf array -> t
+  end
+  with type ('rw, 'seek) iobuf := ('rw, 'seek) t
 
 (** [recvmmsg_assume_fd_is_nonblocking fd context] returns the number of [context] iobufs
     read into (or [errno]).  [fd] must not block.  [THREAD_IO_CUTOFF] is ignored.
@@ -67,7 +67,7 @@ val sendto_nonblocking_no_sigpipe
       -> Unix.File_descr.t
       -> Unix.sockaddr
       -> Unix.Syscall_result.Unit.t)
-     Or_error.t
+       Or_error.t
 
 (** Write from the iobuf to the specified channel without changing the iobuf
     window.  Returns the number of bytes written. *)
diff --git a/iobuf_unix/test/dune b/iobuf_unix/test/dune
index 7c9c7ed..5850c55 100644
--- a/iobuf_unix/test/dune
+++ b/iobuf_unix/test/dune
@@ -1,6 +1,6 @@
 (library
  (name iobuf_unix_test)
- (libraries bigstring_unix iobuf_unix core_thread expect_test_helpers_core
-   iobuf_test)
+ (libraries bigstring_unix iobuf_unix core core_thread core_unix
+   expect_test_helpers_core core_kernel.iobuf iobuf_test)
  (preprocess
   (pps ppx_jane)))
diff --git a/iobuf_unix/test/test_iobuf_unix.ml b/iobuf_unix/test/test_iobuf_unix.ml
index 1460f86..d8bdf87 100644
--- a/iobuf_unix/test/test_iobuf_unix.ml
+++ b/iobuf_unix/test/test_iobuf_unix.ml
@@ -14,16 +14,16 @@ let%test_unit _ =
   List.iter
     [ Iobuf.Expert.to_bigstring_shared; to_bigstring_shared_via_iovec ]
     ~f:(fun to_bstr ->
-    let iobuf = Iobuf.of_string "0123456789" in
-    let bstr0 = to_bstr iobuf in
-    [%test_result: Bigstring.t] bstr0 ~expect:(Bigstring.of_string "0123456789");
-    Iobuf.Poke.char iobuf ~pos:0 'X';
-    [%test_result: Bigstring.t] bstr0 ~expect:(Bigstring.of_string "X123456789");
-    let bstr1 = to_bstr iobuf ~pos:1 ~len:8 in
-    [%test_result: Bigstring.t] bstr1 ~expect:(Bigstring.of_string "12345678");
-    Iobuf.Poke.char iobuf ~pos:1 'X';
-    [%test_result: Bigstring.t] bstr1 ~expect:(Bigstring.of_string "X2345678");
-    [%test_result: Bigstring.t] bstr0 ~expect:(Bigstring.of_string "XX23456789"))
+      let iobuf = Iobuf.of_string "0123456789" in
+      let bstr0 = to_bstr iobuf in
+      [%test_result: Bigstring.t] bstr0 ~expect:(Bigstring.of_string "0123456789");
+      Iobuf.Poke.char iobuf ~pos:0 'X';
+      [%test_result: Bigstring.t] bstr0 ~expect:(Bigstring.of_string "X123456789");
+      let bstr1 = to_bstr iobuf ~pos:1 ~len:8 in
+      [%test_result: Bigstring.t] bstr1 ~expect:(Bigstring.of_string "12345678");
+      Iobuf.Poke.char iobuf ~pos:1 'X';
+      [%test_result: Bigstring.t] bstr1 ~expect:(Bigstring.of_string "X2345678");
+      [%test_result: Bigstring.t] bstr0 ~expect:(Bigstring.of_string "XX23456789"))
 ;;
 
 let%expect_test "fillf_float.Ok" =
@@ -50,19 +50,19 @@ type nonrec ok_or_eof = ok_or_eof =
 let iter_examples = Iobuf_test.Test_iobuf.iter_examples
 
 module Io_test (Ch : sig
-  type in_
+    type in_
 
-  val create_in : string -> in_
-  val close_in : in_ -> unit
-  val read : ([> write ], seek) Iobuf.t -> in_ -> ok_or_eof
+    val create_in : string -> in_
+    val close_in : in_ -> unit
+    val read : ([> write ], seek) Iobuf.t -> in_ -> ok_or_eof
 
-  type out_
+    type out_
 
-  val create_out : Unix.File_descr.t -> out_
-  val close_out : out_ -> unit
-  val write : ([> read ], seek) Iobuf.t -> out_ -> unit
-  val peek_write : ([> read ], _) Iobuf.t -> out_ -> int
-end) =
+    val create_out : Unix.File_descr.t -> out_
+    val close_out : out_ -> unit
+    val write : ([> read ], seek) Iobuf.t -> out_ -> unit
+    val peek_write : ([> read ], _) Iobuf.t -> out_ -> int
+  end) =
 struct
   let%test_unit "write + read" =
     iter_examples ~f:(fun t string ~pos ->
@@ -118,35 +118,35 @@ let output = output
 let input = input
 
 include Io_test (struct
-  type in_ = In_channel.t
+    type in_ = In_channel.t
 
-  let create_in file = In_channel.create file
-  let close_in = In_channel.close
+    let create_in file = In_channel.create file
+    let close_in = In_channel.close
 
-  type out_ = Out_channel.t
+    type out_ = Out_channel.t
 
-  let create_out = Unix.out_channel_of_descr
-  let close_out = Out_channel.close
-  let write = output
-  let peek_write = Peek.output
-  let read = input
-end)
+    let create_out = Unix.out_channel_of_descr
+    let close_out = Out_channel.close
+    let write = output
+    let peek_write = Peek.output
+    let read = input
+  end)
 
 let read = read
 let write = write
 
 include Io_test (struct
-  type in_ = Unix.File_descr.t
-  type out_ = in_
-
-  let create_in file = Unix.openfile ~mode:[ Unix.O_RDONLY ] file
-  let close_in fd = Unix.close fd
-  let create_out = Fn.id
-  let close_out = close_in
-  let read = read
-  let peek_write = Peek.write
-  let write = write
-end)
+    type in_ = Unix.File_descr.t
+    type out_ = in_
+
+    let create_in file = Unix.openfile ~mode:[ Unix.O_RDONLY ] file
+    let close_in fd = Unix.close fd
+    let create_out = Fn.id
+    let close_out = close_in
+    let read = read
+    let peek_write = Peek.write
+    let write = write
+  end)
 
 let read_assume_fd_is_nonblocking = read_assume_fd_is_nonblocking
 let write_assume_fd_is_nonblocking = write_assume_fd_is_nonblocking
@@ -428,7 +428,6 @@ let%expect_test "[In_channel.input_lines]" =
           let base = Option.try_with (fun () -> Array.get base i) in
           let fast = Option.try_with (fun () -> Array.get fast i) in
           Expect_test_helpers_core.require_equal
-            [%here]
             (module SO)
             base
             fast
@@ -473,7 +472,8 @@ let%expect_test "[In_channel.fold_lines_raw]" =
         i + 1
       in
       assert (3 = In_channel_optimized.fold_lines_raw ch ~init:0 ~f));
-  [%expect {|
+  [%expect
+    {|
     ((buf a) (i 0))
     ((buf bc) (i 1))
     ((buf def) (i 2))
diff --git a/linux_ext/bench/dune b/linux_ext/bench/dune
index d20151a..1ae6f55 100644
--- a/linux_ext/bench/dune
+++ b/linux_ext/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name bench_linux_ext)
- (libraries linux_ext)
+ (libraries core linux_ext)
  (preprocess
   (pps ppx_jane)))
diff --git a/linux_ext/src/dune b/linux_ext/src/dune
index 7c2eb4c..c6ef708 100644
--- a/linux_ext/src/dune
+++ b/linux_ext/src/dune
@@ -4,8 +4,8 @@
   (names linux_ext_stubs))
  (name linux_ext)
  (public_name core_unix.linux_ext)
- (libraries core_kernel.bounded_int_table core core_thread filename_unix
-   time_ns_unix)
+ (libraries core_kernel.bounded_int_table core core_thread core_unix
+   filename_unix core_kernel.flags time_ns_unix)
  (preprocessor_deps config.h)
  (preprocess
   (pps ppx_jane ppx_optcomp)))
diff --git a/linux_ext/src/epoll.ml b/linux_ext/src/epoll.ml
index d8d24e1..7311806 100644
--- a/linux_ext/src/epoll.ml
+++ b/linux_ext/src/epoll.ml
@@ -3,53 +3,53 @@ open! Core
 include Epoll_intf
 
 module Epoll_flags (Flag_values : sig
-  (* We use [Int63] rather than [Int] because these flags use 32 bits. *)
-  val in_ : Int63.t
-  val out : Int63.t
-
-  (* val rdhup   : Int63.t *)
-  val pri : Int63.t
-  val err : Int63.t
-  val hup : Int63.t
-  val et : Int63.t
-  val oneshot : Int63.t
-end) =
+    (* We use [Int63] rather than [Int] because these flags use 32 bits. *)
+    val in_ : Int63.t
+    val out : Int63.t
+
+    (* val rdhup   : Int63.t *)
+    val pri : Int63.t
+    val err : Int63.t
+    val hup : Int63.t
+    val et : Int63.t
+    val oneshot : Int63.t
+  end) =
 struct
   let none = Int63.zero
 
   include Flag_values
 
   include Flags.Make (struct
-    let allow_intersecting = false
-    let should_print_error = true
-    let remove_zero_flags = false
-
-    let known =
-      [ in_, "in"
-      ; out, "out"
-      ; (* rdhup, "rdhup"; *)
-        pri, "pri"
-      ; err, "err"
-      ; hup, "hup"
-      ; et, "et"
-      ; oneshot, "oneshot"
-      ]
-    ;;
-  end)
+      let allow_intersecting = false
+      let should_print_error = true
+      let remove_zero_flags = false
+
+      let known =
+        [ in_, "in"
+        ; out, "out"
+        ; (* rdhup, "rdhup"; *)
+          pri, "pri"
+        ; err, "err"
+        ; hup, "hup"
+        ; et, "et"
+        ; oneshot, "oneshot"
+        ]
+      ;;
+    end)
 end
 
 module Null_impl : S = struct
   module Flags = Epoll_flags (struct
-    let in_ = Int63.of_int (1 lsl 0)
-    let out = Int63.of_int (1 lsl 1)
+      let in_ = Int63.of_int (1 lsl 0)
+      let out = Int63.of_int (1 lsl 1)
 
-    (* let rdhup   = Int63.of_int (1 lsl 2) *)
-    let pri = Int63.of_int (1 lsl 3)
-    let err = Int63.of_int (1 lsl 4)
-    let hup = Int63.of_int (1 lsl 5)
-    let et = Int63.of_int (1 lsl 6)
-    let oneshot = Int63.of_int (1 lsl 7)
-  end)
+      (* let rdhup   = Int63.of_int (1 lsl 2) *)
+      let pri = Int63.of_int (1 lsl 3)
+      let err = Int63.of_int (1 lsl 4)
+      let hup = Int63.of_int (1 lsl 5)
+      let et = Int63.of_int (1 lsl 6)
+      let oneshot = Int63.of_int (1 lsl 7)
+    end)
 
   type t = [ `Epoll_is_not_implemented ] [@@deriving sexp_of]
 
@@ -94,16 +94,16 @@ module Impl = struct
   external flag_epolloneshot : unit -> Int63.t = "core_linux_epoll_EPOLLONESHOT_flag"
 
   module Flags = Epoll_flags (struct
-    let in_ = flag_epollin ()
-    let out = flag_epollout ()
+      let in_ = flag_epollin ()
+      let out = flag_epollout ()
 
-    (* let rdhup   = flag_epollrdhup () *)
-    let pri = flag_epollpri ()
-    let err = flag_epollerr ()
-    let hup = flag_epollhup ()
-    let et = flag_epollet ()
-    let oneshot = flag_epolloneshot ()
-  end)
+      (* let rdhup   = flag_epollrdhup () *)
+      let pri = flag_epollpri ()
+      let err = flag_epollerr ()
+      let hup = flag_epollhup ()
+      let et = flag_epollet ()
+      let oneshot = flag_epolloneshot ()
+    end)
 
   external epoll_create : unit -> File_descr.t = "core_linux_epoll_create"
 
@@ -119,16 +119,16 @@ module Impl = struct
   type ready_events = Bigstring.t
 
   external epoll_sizeof_epoll_event : unit -> int = "core_linux_epoll_sizeof_epoll_event"
-    [@@noalloc]
+  [@@noalloc]
 
   external epoll_offsetof_readyfd : unit -> int = "core_linux_epoll_offsetof_readyfd"
-    [@@noalloc]
+  [@@noalloc]
 
   external epoll_offsetof_readyflags
     :  unit
     -> int
     = "core_linux_epoll_offsetof_readyflags"
-    [@@noalloc]
+  [@@noalloc]
 
   let sizeof_epoll_event = epoll_sizeof_epoll_event ()
   let offsetof_readyfd = epoll_offsetof_readyfd ()
diff --git a/linux_ext/src/linux_ext.ml b/linux_ext/src/linux_ext.ml
index 9680556..a75ab6b 100644
--- a/linux_ext/src/linux_ext.ml
+++ b/linux_ext/src/linux_ext.ml
@@ -256,11 +256,11 @@ module Null : Linux_ext_intf.S = struct
       let semaphore = Int63.of_int 0o1
 
       include Flags.Make (struct
-        let allow_intersecting = true
-        let should_print_error = true
-        let remove_zero_flags = false
-        let known = [ nonblock, "nonblock"; cloexec, "cloexec"; semaphore, "semaphore" ]
-      end)
+          let allow_intersecting = true
+          let should_print_error = true
+          let remove_zero_flags = false
+          let known = [ nonblock, "nonblock"; cloexec, "cloexec"; semaphore, "semaphore" ]
+        end)
     end
 
     let create = Or_error.unimplemented "Linux_ext.Eventfd.create"
@@ -282,11 +282,11 @@ module Null : Linux_ext_intf.S = struct
       let cloexec = Int63.of_int 0o2000000
 
       include Flags.Make (struct
-        let allow_intersecting = false
-        let should_print_error = true
-        let remove_zero_flags = false
-        let known = List.rev [ nonblock, "nonblock"; cloexec, "cloexec" ]
-      end)
+          let allow_intersecting = false
+          let should_print_error = true
+          let remove_zero_flags = false
+          let known = List.rev [ nonblock, "nonblock"; cloexec, "cloexec" ]
+        end)
     end
 
     type t = File_descr.t [@@deriving compare, sexp_of]
@@ -326,21 +326,21 @@ module Null : Linux_ext_intf.S = struct
       let huge_1gb = i63 (30 lsl hugetlb_flag_encode_shift)
 
       include Flags.Make (struct
-        let allow_intersecting = true (* huge_* flags intersect *)
-        let should_print_error = true
-        let remove_zero_flags = false
-
-        let known =
-          [ cloexec, "cloexec"
-          ; allow_sealing, "allow_sealing"
-          ; hugetlb, "hugetlb"
-          ; noexec_seal, "noexec_seal"
-          ; exec, "exec"
-          ; huge_2mb, "huge_2mb"
-          ; huge_1gb, "huge_1gb"
-          ]
-        ;;
-      end)
+          let allow_intersecting = true (* huge_* flags intersect *)
+          let should_print_error = true
+          let remove_zero_flags = false
+
+          let known =
+            [ cloexec, "cloexec"
+            ; allow_sealing, "allow_sealing"
+            ; hugetlb, "hugetlb"
+            ; noexec_seal, "noexec_seal"
+            ; exec, "exec"
+            ; huge_2mb, "huge_2mb"
+            ; huge_1gb, "huge_1gb"
+            ]
+          ;;
+        end)
     end
 
     type t = File_descr.t [@@deriving sexp_of]
@@ -457,11 +457,11 @@ module Timerfd = struct
     let cloexec = cloexec ()
 
     include Flags.Make (struct
-      let allow_intersecting = false
-      let should_print_error = true
-      let remove_zero_flags = false
-      let known = List.rev [ nonblock, "nonblock"; cloexec, "cloexec" ]
-    end)
+        let allow_intersecting = false
+        let should_print_error = true
+        let remove_zero_flags = false
+        let known = List.rev [ nonblock, "nonblock"; cloexec, "cloexec" ]
+      end)
   end
 
   type t = File_descr.t [@@deriving compare, sexp_of]
@@ -500,7 +500,7 @@ module Timerfd = struct
     -> interval:Int63.t
     -> Syscall_result.Unit.t
     = "core_linux_timerfd_settime"
-    [@@noalloc]
+  [@@noalloc]
 
   let timerfd_settime t ~absolute ~initial ~interval =
     (* We could accept [interval < 0] or [initial < 0 when absolute], but then the
@@ -631,21 +631,21 @@ module Memfd = struct
     let huge_1gb = huge_1gb ()
 
     include Flags.Make (struct
-      let allow_intersecting = true (* huge_* flags intersect *)
-      let should_print_error = true
-      let remove_zero_flags = false
-
-      let known =
-        [ cloexec, "cloexec"
-        ; allow_sealing, "allow_sealing"
-        ; hugetlb, "hugetlb"
-        ; noexec_seal, "noexec_seal"
-        ; exec, "exec"
-        ; huge_2mb, "huge_2mb"
-        ; huge_1gb, "huge_1gb"
-        ]
-      ;;
-    end)
+        let allow_intersecting = true (* huge_* flags intersect *)
+        let should_print_error = true
+        let remove_zero_flags = false
+
+        let known =
+          [ cloexec, "cloexec"
+          ; allow_sealing, "allow_sealing"
+          ; hugetlb, "hugetlb"
+          ; noexec_seal, "noexec_seal"
+          ; exec, "exec"
+          ; huge_2mb, "huge_2mb"
+          ; huge_1gb, "huge_1gb"
+          ]
+        ;;
+      end)
   end
 
   type t = File_descr.t [@@deriving compare, sexp_of]
@@ -688,11 +688,11 @@ module Eventfd = struct
     let known = [ cloexec, "cloexec"; nonblock, "nonblock"; semaphore, "semaphore" ]
 
     include Flags.Make (struct
-      let allow_intersecting = true
-      let should_print_error = true
-      let known = known
-      let remove_zero_flags = false
-    end)
+        let allow_intersecting = true
+        let should_print_error = true
+        let known = known
+        let remove_zero_flags = false
+      end)
   end
 
   type t = File_descr.t [@@deriving compare, sexp_of]
diff --git a/linux_ext/src/linux_ext_intf.ml b/linux_ext/src/linux_ext_intf.ml
index c64c24e..4b342eb 100644
--- a/linux_ext/src/linux_ext_intf.ml
+++ b/linux_ext/src/linux_ext_intf.ml
@@ -50,7 +50,7 @@ module type S = sig
        -> fd:File_descr.t
        -> File_descr.t
        -> int)
-      Or_error.t
+        Or_error.t
 
   (** Type for status of SO_BINDTODEVICE socket option. The socket may either restrict the
       traffic to a given (by name, e.g. "eth0") interface, or do no restriction at all. *)
@@ -65,7 +65,7 @@ module type S = sig
 
   type tcp_bool_option =
     | TCP_CORK
-        (** (Since Linux 2.2) If set, dont send out partial frames.  All queued partial
+    (** (Since Linux 2.2) If set, dont send out partial frames.  All queued partial
         frames are sent when the option is cleared again.  This is useful for prepending
         headers before calling [sendfile(2)], or for throughput optimization.  As
         currently implemented, there is a 200ms ceiling on the time for which output is
@@ -74,7 +74,7 @@ module type S = sig
 
         This option should not be used in code intended to be portable. *)
     | TCP_QUICKACK
-        (** (Since Linux 2.4.4) Quick ack solves an unfortunate interaction between the
+    (** (Since Linux 2.4.4) Quick ack solves an unfortunate interaction between the
         delayed acks and the Nagle algorithm (TCP_NODELAY).  On fast LANs, the Linux TCP
         stack quickly reaches a CWND (congestion window) of 1 (Linux interprets this as "1
         unacknowledged packet", BSD/Windows and others consider it "1 unacknowledged
@@ -90,7 +90,7 @@ module type S = sig
 
   type tcp_string_option =
     | TCP_CONGESTION
-        (** (Since Linux 2.6.13) Get or set the congestion-control algorithm for this socket.
+    (** (Since Linux 2.6.13) Get or set the congestion-control algorithm for this socket.
 
         The algorithm "reno" is always permitted; other algorithms may be available,
         depending on kernel configuration and loaded modules (see
@@ -131,7 +131,7 @@ module type S = sig
        -> ?len:int (** default = [Bytes.length buf - pos] *)
        -> Bytes.t
        -> int option)
-      Or_error.t
+        Or_error.t
 
   (** [send_no_sigpipe sock ?pos ?len buf] tries to do a blocking send on socket [sock]
       given buffer [buf], offset [pos] and length [len]. Prevents [SIGPIPE], i.e., raises
@@ -145,7 +145,7 @@ module type S = sig
        -> ?len:int (** default = [Bytes.length buf - pos] *)
        -> Bytes.t
        -> int)
-      Or_error.t
+        Or_error.t
 
   (** [sendmsg_nonblocking_no_sigpipe sock ?count iovecs] tries to do a nonblocking send
       on socket [sock] using [count] I/O-vectors [iovecs].  Prevents [SIGPIPE],
@@ -562,7 +562,7 @@ module type S = sig
 
     val getxattr
       : (follow_symlinks:bool -> path:string -> name:string -> Get_attr_result.t)
-        Or_error.t
+          Or_error.t
 
     (** [setxattr] sets the value of the extended attribute identified by name and
         associated with the given path in the filesystem.
@@ -594,6 +594,6 @@ module type S = sig
          -> value:string
          -> unit
          -> Set_attr_result.t)
-        Or_error.t
+          Or_error.t
   end
 end
diff --git a/linux_ext/src/linux_ext_stubs.c b/linux_ext/src/linux_ext_stubs.c
index 1783404..132ed34 100644
--- a/linux_ext/src/linux_ext_stubs.c
+++ b/linux_ext/src/linux_ext_stubs.c
@@ -111,27 +111,24 @@ enum option_type {
 /* unix_getsockopt_aux and unix_setsockopt_aux come from C stubs distributed
    with the OCaml compiler.  At the time of writing they live in
    otherlibs/unix/sockopt.c. */
-extern value caml_unix_getsockopt_aux(char *name, enum option_type ty,
-                                      int level, int option, value v_socket);
-extern value caml_unix_setsockopt_aux(char *name, enum option_type ty,
-                                      int level, int option, value v_socket,
-                                      value v_status);
+extern value caml_unix_getsockopt_aux(char *name, enum option_type ty, int level,
+                                      int option, value v_socket);
+extern value caml_unix_setsockopt_aux(char *name, enum option_type ty, int level,
+                                      int option, value v_socket, value v_status);
 
 CAMLprim value core_linux_gettcpopt_bool_stub(value v_socket, value v_option) {
   int option = linux_tcpopt_bool[Int_val(v_option)];
-  return caml_unix_getsockopt_aux("getsockopt", TYPE_BOOL, SOL_TCP, option,
-                                  v_socket);
+  return caml_unix_getsockopt_aux("getsockopt", TYPE_BOOL, SOL_TCP, option, v_socket);
 }
 
 CAMLprim value core_linux_settcpopt_bool_stub(value v_socket, value v_option,
                                               value v_status) {
   int option = linux_tcpopt_bool[Int_val(v_option)];
-  return caml_unix_setsockopt_aux("setsockopt", TYPE_BOOL, SOL_TCP, option,
-                                  v_socket, v_status);
+  return caml_unix_setsockopt_aux("setsockopt", TYPE_BOOL, SOL_TCP, option, v_socket,
+                                  v_status);
 }
 
-CAMLprim value core_linux_gettcpopt_string_stub(value v_socket,
-                                                value v_optname) {
+CAMLprim value core_linux_gettcpopt_string_stub(value v_socket, value v_optname) {
   CAMLparam2(v_socket, v_optname);
 
   int optname = linux_tcpopt_string[Int_val(v_optname)];
@@ -209,20 +206,17 @@ CAMLprim value core_linux_settcpopt_string_stub(value v_socket, value v_optname,
 
 static int nonblocking_no_sigpipe_flag = MSG_DONTWAIT | MSG_NOSIGNAL;
 
-CAMLprim value core_linux_send_nonblocking_no_sigpipe_stub(value v_fd,
-                                                           value v_pos,
-                                                           value v_len,
-                                                           value v_buf) {
+CAMLprim value core_linux_send_nonblocking_no_sigpipe_stub(value v_fd, value v_pos,
+                                                           value v_len, value v_buf) {
   unsigned char *buf = Bytes_val(v_buf) + Long_val(v_pos);
-  ssize_t ret =
-      send(Int_val(v_fd), buf, Long_val(v_len), nonblocking_no_sigpipe_flag);
+  ssize_t ret = send(Int_val(v_fd), buf, Long_val(v_len), nonblocking_no_sigpipe_flag);
   if (ret == -1 && errno != EAGAIN && errno != EWOULDBLOCK)
     uerror("send_nonblocking_no_sigpipe", Nothing);
   return Val_long(ret);
 }
 
-CAMLprim value core_linux_send_no_sigpipe_stub(value v_fd, value v_pos,
-                                               value v_len, value v_buf) {
+CAMLprim value core_linux_send_no_sigpipe_stub(value v_fd, value v_pos, value v_len,
+                                               value v_buf) {
   unsigned char *buf = Bytes_val(v_buf) + Long_val(v_pos);
   ssize_t ret = send(Int_val(v_fd), buf, Long_val(v_len), MSG_NOSIGNAL);
   if (ret == -1)
@@ -230,8 +224,7 @@ CAMLprim value core_linux_send_no_sigpipe_stub(value v_fd, value v_pos,
   return Val_long(ret);
 }
 
-CAMLprim value core_linux_sendmsg_nonblocking_no_sigpipe_stub(value v_fd,
-                                                              value v_iovecs,
+CAMLprim value core_linux_sendmsg_nonblocking_no_sigpipe_stub(value v_fd, value v_iovecs,
                                                               value v_count) {
   int count = Int_val(v_count);
   ssize_t ret;
@@ -402,8 +395,7 @@ CAMLprim value core_linux_get_mac_address(value v_interface) {
     error = "core_linux_get_mac_address: couldn't allocate socket";
   else {
     if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0)
-      error =
-          "core_linux_get_mac_address: ioctl(fd, SIOCGIFHWADDR, ...) failed";
+      error = "core_linux_get_mac_address: ioctl(fd, SIOCGIFHWADDR, ...) failed";
 
     (void)core_unix_close_durably(fd);
   }
@@ -417,9 +409,8 @@ CAMLprim value core_linux_get_mac_address(value v_interface) {
        the canonical representation of mac addresses.  It drops leading zeros
        and does not zero pad. */
     snprintf(buf, 18, "%02x:%02x:%02x:%02x:%02x:%02x", ea->ether_addr_octet[0],
-             ea->ether_addr_octet[1], ea->ether_addr_octet[2],
-             ea->ether_addr_octet[3], ea->ether_addr_octet[4],
-             ea->ether_addr_octet[5]);
+             ea->ether_addr_octet[1], ea->ether_addr_octet[2], ea->ether_addr_octet[3],
+             ea->ether_addr_octet[4], ea->ether_addr_octet[5]);
     CAMLreturn(caml_copy_string(buf));
   }
 
@@ -499,8 +490,7 @@ CAMLprim value core_linux_peer_credentials(value v_fd) {
 
 /** Core epoll methods **/
 
-#define EPOLL_FLAG(FLAG)                                                       \
-  DEFINE_INT63_CONSTANT(core_linux_epoll_##FLAG##_flag, FLAG)
+#define EPOLL_FLAG(FLAG) DEFINE_INT63_CONSTANT(core_linux_epoll_##FLAG##_flag, FLAG)
 
 EPOLL_FLAG(EPOLLIN)
 EPOLL_FLAG(EPOLLOUT)
@@ -525,8 +515,7 @@ CAMLprim value core_linux_epoll_create(value __unused v_unit) {
   return Val_long(retcode);
 }
 
-static value linux_epoll_ctl(value v_epfd, value v_fd, value v_flags,
-                             int operation) {
+static value linux_epoll_ctl(value v_epfd, value v_fd, value v_flags, int operation) {
   struct epoll_event evt;
 
   evt.data.ptr = NULL;
@@ -544,13 +533,11 @@ static value linux_epoll_ctl(value v_epfd, value v_fd, value v_flags,
  * adding an fd to a set a second time to change the event flags. Use
  * mod()...
  */
-CAMLprim value core_linux_epoll_ctl_add(value v_epfd, value v_fd,
-                                        value v_flags) {
+CAMLprim value core_linux_epoll_ctl_add(value v_epfd, value v_fd, value v_flags) {
   return linux_epoll_ctl(v_epfd, v_fd, v_flags, EPOLL_CTL_ADD);
 }
 
-CAMLprim value core_linux_epoll_ctl_mod(value v_epfd, value v_fd,
-                                        value v_flags) {
+CAMLprim value core_linux_epoll_ctl_mod(value v_epfd, value v_fd, value v_flags) {
   return linux_epoll_ctl(v_epfd, v_fd, v_flags, EPOLL_CTL_MOD);
 }
 
@@ -566,8 +553,7 @@ CAMLprim value core_linux_epoll_ctl_del(value v_epfd, value v_fd) {
   return Val_unit;
 }
 
-CAMLprim value core_linux_epoll_wait(value v_epfd, value v_array,
-                                     value v_timeout) {
+CAMLprim value core_linux_epoll_wait(value v_epfd, value v_array, value v_timeout) {
   struct epoll_event *evt;
   int retcode, maxevents;
   int timeout = Long_val(v_timeout);
@@ -625,9 +611,9 @@ CAMLprim value core_linux_epoll_offsetof_readyflags(value __unused v_unit) {
 #define TFD_CLOEXEC 02000000
 #endif
 
-#define TIMERFD_INT63(X)                                                       \
-  CAMLprim value core_linux_timerfd_##X(value __unused v_unit) {               \
-    return caml_alloc_int63(X);                                                \
+#define TIMERFD_INT63(X)                                                                 \
+  CAMLprim value core_linux_timerfd_##X(value __unused v_unit) {                         \
+    return caml_alloc_int63(X);                                                          \
   }
 
 TIMERFD_INT63(TFD_NONBLOCK)
@@ -654,21 +640,21 @@ static inline void set_timespec(struct timespec *ts, value v) {
   ts->tv_nsec = (long)(d - (ts->tv_sec * NANOS_PER_SECOND));
 }
 
-CAMLprim value core_linux_timerfd_settime(value v_fd, value v_absolute,
-                                          value v_initial, value v_interval) {
+CAMLprim value core_linux_timerfd_settime(value v_fd, value v_absolute, value v_initial,
+                                          value v_interval) {
   int retcode;
   struct itimerspec old, new;
 
   set_timespec(&new.it_value, v_initial);
   set_timespec(&new.it_interval, v_interval);
 
-  retcode = timerfd_settime(
-      Int_val(v_fd), Bool_val(v_absolute) ? TFD_TIMER_ABSTIME : 0, &new, &old);
+  retcode = timerfd_settime(Int_val(v_fd), Bool_val(v_absolute) ? TFD_TIMER_ABSTIME : 0,
+                            &new, &old);
 
   return retcode < 0 ? Val_int(-errno) : Val_unit;
 }
 
-#define Int63_ns_of_timespec(ts)                                               \
+#define Int63_ns_of_timespec(ts)                                                         \
   caml_alloc_int63((uint64_t)ts.tv_sec *NANOS_PER_SECOND + (uint64_t)ts.tv_nsec)
 
 static value alloc_spec(struct itimerspec *spec) {
@@ -715,9 +701,9 @@ CAMLprim value core_linux_timerfd_gettime(value v_fd) {
 #define MFD_HUGE_1GB (30U << 26)
 #endif
 
-#define MEMFD_INT63(X)                                                         \
-  CAMLprim value core_linux_memfd_##X(value __unused v_unit) {                 \
-    return caml_alloc_int63(X);                                                \
+#define MEMFD_INT63(X)                                                                   \
+  CAMLprim value core_linux_memfd_##X(value __unused v_unit) {                           \
+    return caml_alloc_int63(X);                                                          \
   }
 
 MEMFD_INT63(MFD_CLOEXEC)
@@ -805,14 +791,12 @@ CAMLprim value core_linux_eventfd_write(value v_fd, value v_val) {
   CAMLreturn(Val_unit);
 }
 
-#define XATTR_FLAG(FLAG)                                                       \
-  DEFINE_INT63_CONSTANT(core_linux_xattr_##FLAG##_flag, FLAG)
+#define XATTR_FLAG(FLAG) DEFINE_INT63_CONSTANT(core_linux_xattr_##FLAG##_flag, FLAG)
 
 XATTR_FLAG(XATTR_CREATE)
 XATTR_FLAG(XATTR_REPLACE)
 
-CAMLprim value core_linux_getxattr(value v_follow_symlinks, value v_path,
-                                   value v_name) {
+CAMLprim value core_linux_getxattr(value v_follow_symlinks, value v_path, value v_name) {
   CAMLparam3(v_follow_symlinks, v_path, v_name);
   CAMLlocal1(res);
 
@@ -862,8 +846,8 @@ CAMLprim value core_linux_getxattr(value v_follow_symlinks, value v_path,
   CAMLreturn(res);
 }
 
-CAMLprim value core_linux_setxattr(value v_follow_symlinks, value v_path,
-                                   value v_name, value v_value, value v_flags) {
+CAMLprim value core_linux_setxattr(value v_follow_symlinks, value v_path, value v_name,
+                                   value v_value, value v_flags) {
   CAMLparam5(v_follow_symlinks, v_path, v_name, v_value, v_flags);
   CAMLlocal1(res);
 
@@ -929,7 +913,6 @@ CAMLprim value core_linux_setxattr(value v_follow_symlinks, value v_path,
 
 #else
 
-void avoid_empty_translation_unit_compilation_error_in_core_unix_linux_ext(
-    void) {}
+void avoid_empty_translation_unit_compilation_error_in_core_unix_linux_ext(void) {}
 
 #endif /* JSC_LINUX_EXT */
diff --git a/linux_ext/test/dune b/linux_ext/test/dune
index 10973b6..d4ff3ec 100644
--- a/linux_ext/test/dune
+++ b/linux_ext/test/dune
@@ -1,6 +1,7 @@
 (library
  (name linux_ext_test)
- (libraries bigstring_unix core_kernel.caml_threads expect_test_helpers_core
-   filename_unix linux_ext)
+ (libraries bigstring_unix core_kernel.caml_threads core core_thread
+   core_unix expect_test_helpers_core.expect_test_helpers_base
+   expect_test_helpers_core filename_unix linux_ext)
  (preprocess
   (pps ppx_jane)))
diff --git a/linux_ext/test/test_linux_ext.ml b/linux_ext/test/test_linux_ext.ml
index 7b19dcf..fc4e65b 100644
--- a/linux_ext/test/test_linux_ext.ml
+++ b/linux_ext/test/test_linux_ext.ml
@@ -254,7 +254,7 @@ let make_socket () = Unix.socket ~domain:Unix.PF_INET ~kind:Unix.SOCK_DGRAM ~pro
 let%expect_test "[Epoll.set] has allocation limits" =
   with_epoll ~f:(fun epset ->
     let sock1 = make_socket () in
-    require_allocation_does_not_exceed (Minor_words 6) [%here] (fun () ->
+    require_allocation_does_not_exceed (Minor_words 6) (fun () ->
       Epoll.set epset sock1 Flags.in_));
   [%expect {| |}]
 ;;
@@ -262,7 +262,7 @@ let%expect_test "[Epoll.set] has allocation limits" =
 let%expect_test "[Epoll.find] does not allocate when not present" =
   with_epoll ~f:(fun epset ->
     let sock1 = make_socket () in
-    require_no_allocation [%here] (fun () -> ignore (Epoll.find epset sock1 : _ option)));
+    require_no_allocation (fun () -> ignore (Epoll.find epset sock1 : _ option)));
   [%expect {| |}]
 ;;
 
@@ -270,7 +270,7 @@ let%expect_test "[Epoll.find] has allocation limits when present" =
   with_epoll ~f:(fun epset ->
     let sock1 = make_socket () in
     Epoll.set epset sock1 Flags.in_;
-    require_allocation_does_not_exceed (Minor_words 2) [%here] (fun () ->
+    require_allocation_does_not_exceed (Minor_words 2) (fun () ->
       ignore (Epoll.find epset sock1 : _ option)));
   [%expect {| |}]
 ;;
@@ -278,9 +278,9 @@ let%expect_test "[Epoll.find] has allocation limits when present" =
 let%expect_test "[Epoll.remove] does not allocate" =
   with_epoll ~f:(fun epset ->
     let sock1 = make_socket () in
-    require_no_allocation [%here] (fun () -> ignore (Epoll.remove epset sock1 : unit));
+    require_no_allocation (fun () -> ignore (Epoll.remove epset sock1 : unit));
     Epoll.set epset sock1 Flags.in_;
-    require_no_allocation [%here] (fun () -> ignore (Epoll.remove epset sock1 : unit)));
+    require_no_allocation (fun () -> ignore (Epoll.remove epset sock1 : unit)));
   [%expect {| |}]
 ;;
 
@@ -299,7 +299,8 @@ let%expect_test "[Epoll.Expert.clear_ready]" =
       print_num_ready ();
       Epoll.Expert.clear_ready t;
       print_num_ready ();
-      [%expect {|
+      [%expect
+        {|
         (!num_ready 1)
         (!num_ready 0)
         |}])
@@ -386,7 +387,8 @@ let%test_module "getpriority and setpriority" =
         let priority = Linux_ext.Priority.of_int (index + 1) in
         setpriority ?pid:set_pid priority;
         print_priority ?pid:get_pid ());
-      [%expect {|
+      [%expect
+        {|
         1
         2
         3
@@ -482,10 +484,10 @@ let%test_unit "get_terminal_size" =
         (Filename_unix.temp_file "get_terminal_size" "")
         ~finally:Unix.unlink
         ~f:(fun fname ->
-        protectx
-          (Unix.openfile fname ~mode:[ Unix.O_RDONLY ] ~perm:0)
-          ~finally:Unix.close
-          ~f)
+          protectx
+            (Unix.openfile fname ~mode:[ Unix.O_RDONLY ] ~perm:0)
+            ~finally:Unix.close
+            ~f)
     in
     (match with_tmp_fd (fun fd -> f (`Fd fd)) with
      | exception Unix.Unix_error (ENOTTY, _, _) -> ()
@@ -664,26 +666,28 @@ let%test_unit "peer_credentials" =
       (Filename_unix.temp_file "linux_ext" "")
       ~finally:Unix.unlink
       ~f:(fun fname ->
-      (let fd = Unix.openfile fname ~mode:[ O_RDONLY ] in
-       try
-         ignore (peer_credentials fd : Peer_credentials.t);
-         failwith "peer credential on non socket should have raised"
-       with
-       | Unix.Unix_error (ENOTSOCK, _, _) -> ());
-      with_listening_server_unix_socket (fname ^ ".peercredsocket") ~f:(fun fname ->
-        let client_sock = Unix.socket ~domain:PF_UNIX ~kind:SOCK_STREAM ~protocol:0 () in
-        let rec connect count =
-          try Unix.connect client_sock ~addr:(ADDR_UNIX fname) with
-          | Unix_error (ECONNREFUSED, _, _) when count < 100 ->
-            (* the server might not have listened yet *)
-            ignore (Unix.nanosleep 0.1 : float);
-            connect (count + 1)
-        in
-        connect 0;
-        let p = peer_credentials client_sock in
-        [%test_eq: Pid.t] p.pid (Unix.getpid ());
-        [%test_eq: int] p.uid (Unix.getuid ());
-        [%test_eq: int] p.gid (Unix.getgid ())))
+        (let fd = Unix.openfile fname ~mode:[ O_RDONLY ] in
+         try
+           ignore (peer_credentials fd : Peer_credentials.t);
+           failwith "peer credential on non socket should have raised"
+         with
+         | Unix.Unix_error (ENOTSOCK, _, _) -> ());
+        with_listening_server_unix_socket (fname ^ ".peercredsocket") ~f:(fun fname ->
+          let client_sock =
+            Unix.socket ~domain:PF_UNIX ~kind:SOCK_STREAM ~protocol:0 ()
+          in
+          let rec connect count =
+            try Unix.connect client_sock ~addr:(ADDR_UNIX fname) with
+            | Unix_error (ECONNREFUSED, _, _) when count < 100 ->
+              (* the server might not have listened yet *)
+              ignore (Unix.nanosleep 0.1 : float);
+              connect (count + 1)
+          in
+          connect 0;
+          let p = peer_credentials client_sock in
+          [%test_eq: Pid.t] p.pid (Unix.getpid ());
+          [%test_eq: int] p.uid (Unix.getuid ());
+          [%test_eq: int] p.gid (Unix.getgid ())))
 ;;
 
 let%expect_test "cpu_list_of_string_exn" =
diff --git a/lock_file_blocking/src/dune b/lock_file_blocking/src/dune
index 24b2783..a83ff05 100644
--- a/lock_file_blocking/src/dune
+++ b/lock_file_blocking/src/dune
@@ -1,7 +1,8 @@
 (library
  (name lock_file_blocking)
  (public_name core_unix.lock_file_blocking)
- (libraries core filename_unix linux_ext sys_unix)
+ (libraries core_kernel.caml_unix core core_unix filename_unix signal_unix
+   sys_unix)
  (preprocessor_deps config.h)
  (preprocess
   (pps ppx_jane ppx_optcomp)))
diff --git a/lock_file_blocking/src/lock_file_blocking.ml b/lock_file_blocking/src/lock_file_blocking.ml
index 4c6ad27..cf9bfc6 100644
--- a/lock_file_blocking/src/lock_file_blocking.ml
+++ b/lock_file_blocking/src/lock_file_blocking.ml
@@ -3,6 +3,8 @@ module Unix = Core_unix
 
 [%%import "config.h"]
 
+open Shared
+
 (* We have reason to believe that lockf doesn't work properly on CIFS mounts.  The idea
    behind requiring both lockf and flock is to prevent programs taking locks on
    network filesystems where they may not be sound.
@@ -106,56 +108,6 @@ let create_exn ?message ?close_on_exec ?unlink_on_exit path =
       ()
 ;;
 
-let random = lazy (Random.State.make_self_init ())
-
-let default_max_retry_delay ~timeout =
-  let default_delay = Time_float.Span.of_int_ms 300 in
-  match timeout with
-  | None -> default_delay
-  | Some timeout -> Time_float.Span.min default_delay (Time_float.Span.( / ) timeout 3.)
-;;
-
-let wait_at_most max_delay random =
-  let delay = Random.State.float (Lazy.force random) (Time_float.Span.to_sec max_delay) in
-  ignore (Unix.nanosleep delay : float)
-;;
-
-(* no timeout specified = wait indefinitely *)
-let repeat_with_timeout ?max_retry_delay ?(random = random) ?timeout lockf path =
-  let max_retry_delay =
-    match max_retry_delay with
-    | Some delay -> delay
-    | None -> default_max_retry_delay ~timeout
-  in
-  match timeout with
-  | None ->
-    let rec loop () =
-      try lockf path with
-      | _ ->
-        wait_at_most max_retry_delay random;
-        loop ()
-    in
-    loop ()
-  | Some timeout ->
-    let start_time = Time_float.now () in
-    let rec loop () =
-      try lockf path with
-      | e ->
-        let since_start = Time_float.abs_diff start_time (Time_float.now ()) in
-        if Time_float.Span.(since_start > timeout)
-        then
-          failwithf
-            "Lock_file: '%s' timed out waiting for existing lock. Last error was %s"
-            path
-            (Exn.to_string e)
-            ()
-        else (
-          wait_at_most max_retry_delay random;
-          loop ())
-    in
-    loop ()
-;;
-
 (* default timeout is to wait indefinitely *)
 let blocking_create
   ?max_retry_delay
@@ -187,187 +139,12 @@ let is_locked path =
   | e -> raise e
 ;;
 
-let read_file_and_convert ~of_string path =
-  Option.try_with (fun () -> In_channel.read_all path |> String.strip |> of_string)
-;;
-
 let get_pid path =
   let of_string string = Int.of_string string |> Pid.of_int in
   read_file_and_convert ~of_string path
 ;;
 
-module Nfs = struct
-  let process_start_time pid =
-    (* Find the start time for a process, without requiring the [Procfs] library
-       -- start time is represented in USER_HZ units in /proc/<pid>/stat (confusingly
-       referred to as 'jiffies' in the man page); USER_HZ is almost certainly 100, for
-       mostly historical reasons, but just to be sure we'll ask sysconf.
-    *)
-    match Linux_ext.Sysinfo.sysinfo with
-    | Error _ -> None
-    | Ok sysinfo ->
-      let of_string stat =
-        (* [read_file_and_convert] will catch any exceptions raised here *)
-        let boot_time =
-          Time_float.sub (Time_float.now ()) (sysinfo ()).Linux_ext.Sysinfo.uptime
-        in
-        let jiffies =
-          let fields =
-            String.rsplit2_exn stat ~on:')' |> snd |> String.strip |> String.split ~on:' '
-          in
-          List.nth_exn fields 19 |> Float.of_string
-        in
-        let hz = Unix.sysconf Unix.CLK_TCK |> Option.value_exn |> Int64.to_float in
-        jiffies /. hz |> Time_float.Span.of_sec |> Time_float.add boot_time
-      in
-      read_file_and_convert (sprintf !"/proc/%{Pid}/stat" pid) ~of_string
-  ;;
-
-  module Info = struct
-    type t =
-      { host : string
-      ; pid : Pid.Stable.V1.t
-      ; message : string
-      ; start_time : Time_float.Stable.With_utc_sexp.V2.t option [@sexp.option]
-      }
-    [@@deriving sexp, fields ~getters]
-
-    let create ~message =
-      let pid = Unix.getpid () in
-      { host = Unix.gethostname (); pid; message; start_time = process_start_time pid }
-    ;;
-
-    let of_string string = Sexp.of_string string |> t_of_sexp
-    let of_file = read_file_and_convert ~of_string
-  end
-
-  let lock_path path = path ^ ".nfs_lock"
-
-  let get_hostname_and_pid path =
-    Option.map (Info.of_file path) ~f:(fun info -> Info.host info, Info.pid info)
-  ;;
-
-  let get_message path = Option.map (Info.of_file path) ~f:Info.message
-
-  let unlock_safely_exn ~unlock_myself path =
-    (* Make sure error messages contain a reference to "lock.nfs_lock", which is the
-       actually important file. *)
-    let lock_path = lock_path path in
-    let error s =
-      failwithf "Lock_file.Nfs.unlock_safely_exn: unable to unlock %s: %s" lock_path s ()
-    in
-    match Sys_unix.file_exists ~follow_symlinks:false lock_path with
-    | `Unknown -> error (sprintf "unable to read %s" lock_path)
-    | `No -> ()
-    | `Yes ->
-      (match Info.of_file lock_path with
-       | None -> error "unknown lock file format"
-       | Some info ->
-         let my_pid = Unix.getpid () in
-         let my_hostname = Unix.gethostname () in
-         let locking_hostname = Info.host info in
-         let locking_pid = Info.pid info in
-         if String.( <> ) my_hostname locking_hostname
-         then
-           error
-             (sprintf
-                "locked from %s, unlock attempted from %s"
-                locking_hostname
-                my_hostname)
-         else (
-           (* Check if the process is running: sends signal 0 to pid, which should work if
-              the process is running and is owned by the user running this code. If the
-              process is not owned by the user running this code we should fail to unlock
-              either earlier (unable to read the file) or later (unable to remove the
-              file). *)
-           let pid_start_matches_lock pid =
-             match Option.both (Info.start_time info) (process_start_time pid) with
-             | None -> true (* don't have both start times: fall back to old behaviour *)
-             | Some (lock_start, pid_start) ->
-               (* our method of calculating start time is open to some inaccuracy, so let's
-                  be generous and allow for up to 1s of difference (this would only allow
-                  for a collision if pids get reused within 1s, which seems unlikely) *)
-               let epsilon = Time_float.Span.of_sec 1. in
-               Time_float.Span.( < ) (Time_float.abs_diff lock_start pid_start) epsilon
-           in
-           let is_locked_by_me () =
-             Pid.equal locking_pid my_pid && pid_start_matches_lock my_pid
-           in
-           let locking_pid_exists () =
-             Signal_unix.can_send_to locking_pid && pid_start_matches_lock locking_pid
-           in
-           if (unlock_myself && is_locked_by_me ()) || not (locking_pid_exists ())
-           then (
-             (* We need to be able to recover from situation where [path] does not exist
-                for whatever reason, but [lock_path] is present. Error during unlink of
-                [path] are ignored to be able to cope with this situation and properly
-                clean up stale locks. *)
-             (try Unix.unlink path with
-              | Unix.Unix_error (ENOENT, _, _) -> ()
-              | e -> error (Exn.to_string e));
-             try Unix.unlink lock_path with
-             | e -> error (Exn.to_string e))
-           else
-             error
-               (sprintf
-                  "locking process (pid %i) still running on %s"
-                  (Pid.to_int locking_pid)
-                  locking_hostname)))
-  ;;
-
-  (* See mli for more information on the algorithm we use for locking over NFS.  Ensure
-     that you understand it before you make any changes here. *)
-  let create_exn ?(message = "") path =
-    try
-      unlock_safely_exn ~unlock_myself:false path;
-      let fd = Unix.openfile path ~mode:[ Unix.O_WRONLY; Unix.O_CREAT ] in
-      let cleanup = ref (fun () -> Unix.close fd) in
-      protect
-        ~finally:(fun () -> !cleanup ())
-        ~f:(fun () ->
-          Unix.link ~target:path ~link_name:(lock_path path) ();
-          Unix.ftruncate fd ~len:0L;
-          let info = Info.create ~message in
-          (* if this fprintf fails, empty lock file would be left behind, and
-             subsequent calls to [Lock_file.Nfs.create_exn] would be unable to
-             figure out that it is stale/corrupt and remove it. So we need to
-             remove it ourselves *)
-          try
-            let out_channel = Unix.out_channel_of_descr fd in
-            (cleanup := fun () -> Stdlib.close_out_noerr out_channel);
-            fprintf out_channel "%s\n%!" (Sexp.to_string_hum (Info.sexp_of_t info))
-          with
-          | Sys_error _ as err ->
-            Unix.unlink path;
-            Unix.unlink (lock_path path);
-            raise err);
-      at_exit (fun () ->
-        try unlock_safely_exn ~unlock_myself:true path with
-        | _ -> ())
-    with
-    | e ->
-      failwithf
-        "Lock_file.Nfs.create_exn: unable to lock '%s' - %s"
-        path
-        (Exn.to_string e)
-        ()
-  ;;
-
-  let create ?message path = Or_error.try_with (fun () -> create_exn ?message path)
-
-  (* default timeout is to wait indefinitely *)
-  let blocking_create ?timeout ?message path =
-    repeat_with_timeout ?timeout (fun path -> create_exn ?message path) path
-  ;;
-
-  let critical_section ?message path ~timeout ~f =
-    blocking_create ~timeout ?message path;
-    Exn.protect ~f ~finally:(fun () -> unlock_safely_exn ~unlock_myself:true path)
-  ;;
-
-  let unlock_exn path = unlock_safely_exn ~unlock_myself:true path
-  let unlock path = Or_error.try_with (fun () -> unlock_exn path)
-end
+module Nfs = Nfs_lock
 
 (* The reason this function is used is to make sure the file the path is pointing to
    remains stable across [chdir]. In fact we'd prefer for it to remain stable over
diff --git a/lock_file_blocking/src/lock_file_blocking.mli b/lock_file_blocking/src/lock_file_blocking.mli
index 2eec114..b45d4e7 100644
--- a/lock_file_blocking/src/lock_file_blocking.mli
+++ b/lock_file_blocking/src/lock_file_blocking.mli
@@ -63,100 +63,7 @@ val is_locked : string -> bool
     int. *)
 val get_pid : string -> Pid.t option
 
-(** An implementation-neutral NFS lock file scheme that relies on the atomicity of link
-    over NFS.  Rather than relying on a working traditional advisory lock system over NFS,
-    we create a hard link between the file given to the [create] call and a new file
-    <filename>.nfs_lock.  This link call is atomic (in that it succeeds or fails) across
-    all systems that have the same filesystem mounted.  The link file must be cleaned up
-    on program exit (normally accomplished by an [at_exit] handler, but see caveats
-    below).
-
-    There are a few caveats compared to local file locks:
-
-    - These calls require the locker to have write access to the directory containing the
-      file being locked.
-
-    - Unlike a normal flock call the lock may not be removed when the calling program
-      exits (in particular if it is killed with SIGKILL).
-
-    - NFS lock files are non-standard and difficult to reason about.  This implementation
-      strives to strike a balance between safety and utility in the common case:
-      {ul
-      {li one program per machine}
-      {li one shared user running the program}
-      }
-
-    Use cases outside of this may push on/break assumptions used for easy lock
-    cleanup/taking and may lead to double-taking the lock.  If you have such an odd use
-    case you should test it carefully/consider a different locking mechanism.
-
-    Specific known bugs:
-
-    - Safety bug: if there are two instances running on the same machine,
-      stale lock clean-up mechanism can remove a non-stale lock so the lock ends up
-      taken twice.
-
-    - Liveness bug: a process can write its hostname*pid information to the void
-      upon taking the lock, so you may end up with a broken (empty) lock file, which
-      needs manual clean-up afterwards.
-      (it seems that for this to happen another process needs to take and release the lock
-      in quick succession)
-*)
-module Nfs : sig
-  (** [create ?message path] tries to create and lock the file at [path] by creating a
-      hard link to [path].nfs_lock. The contents of [path] will be replaced with a sexp
-      containing the caller's hostname and pid, and the optional [message].
-
-      Efforts will be made to release this lock when the calling program exits. But there
-      is no guarantee that this will occur under some types of program crash. If the
-      program crashes without removing the lock file an attempt will be made to clean up
-      on restart by checking the hostname and pid stored in the lockfile.
-  *)
-  val create : ?message:string -> string -> unit Or_error.t
-
-  (** [create_exn ?message path] is like [create], but throws an exception when it fails
-      to obtain the lock. *)
-  val create_exn : ?message:string -> string -> unit
-
-  (** [blocking_create ?message path] is like [create], but sleeps for a short while
-      between lock attempts and does not return until it succeeds or [timeout] expires.
-      Timeout defaults to wait indefinitely. *)
-  val blocking_create : ?timeout:Time_float.Span.t -> ?message:string -> string -> unit
-
-  (** [critical_section ?message ~timeout path ~f] wraps function [f] (including
-      exceptions escaping it) by first locking (using {!blocking_create}) and then
-      unlocking the given lock file. *)
-  val critical_section
-    :  ?message:string
-    -> string
-    -> timeout:Time_float.Span.t
-    -> f:(unit -> 'a)
-    -> 'a
-
-  (** [get_hostname_and_pid path] reads the lock file at [path] and returns the hostname
-      and path in the file.  Returns [None] if the file cannot be read. *)
-  val get_hostname_and_pid : string -> (string * Pid.t) option
-
-  (** [get_message path] reads the lock file at [path] and returns the message in the
-      file.  Returns [None] if the file cannot be read. *)
-  val get_message : string -> string option
-
-  (** [unlock_exn path] unlocks [path] if [path] was locked from the same host and the pid
-      in the file is either the current pid or not the pid of a running process.
-
-      It will raise if for some reason the lock at the given path cannot be unlocked, for
-      example if the lock is taken by somebody else that is still alive on the same box,
-      or taken by a process on a different host, or if there are Unix permissions issues,
-      etc.
-
-      This function should be used only by programs that need to release their lock before
-      exiting. If releasing the lock can or should wait till the end of the running
-      process, do not call this function -- this library already takes care of releasing
-      at exit all the locks taken. *)
-  val unlock_exn : string -> unit
-
-  val unlock : string -> unit Or_error.t
-end
+module Nfs = Nfs_lock
 
 (** This is the dumbest lock imaginable: we [mkdir] to lock and [rmdir] to unlock.
     This gives you pretty good mutual exclusion, but it makes you vulnerable to
@@ -207,14 +114,15 @@ end
     Another difference is that implementation is simpler because it omits some of
     the features, such as
 
-    1. Unlinking on exit.
-    That seems unsafe. Consider the following scenario:
-    - both a and b create and open the file
-    - a locks, unlinks and unlocks it
-    - b locks and stays in critical section
-    - c finds that there is no file, creates a new one, locks it and enters
+    1. Unlinking on unlock.
+    That feature is unsafe. The unsafety comes from the fact that [open] and
+    [flock] are separated in time. Consider the following scenario:
+    - two processes [a] and [b] open the file
+    - [a] locks, unlinks and unlocks it (the fd stays open in [b])
+    - [b] locks, using the fd obtained earlier, and stays in critical section
+    - process [c] finds that there is no file, creates a new one, locks it and enters
       critical section
-      You end up with b and c in the critical section together!
+      You end up with [b] and [c] in the critical section together!
 
     2. Writing pid or message in the file.
     The file is shared between multiple processes so this feature seems hard to
diff --git a/lock_file_blocking/src/nfs_lock.ml b/lock_file_blocking/src/nfs_lock.ml
new file mode 100644
index 0000000..a918579
--- /dev/null
+++ b/lock_file_blocking/src/nfs_lock.ml
@@ -0,0 +1,416 @@
+open! Core
+module Unix = Core_unix
+open Shared
+
+let boot_time () =
+  read_file_and_convert "/proc/stat" ~of_string:(fun s ->
+    let lines = String.split_lines s in
+    match List.filter_map lines ~f:(String.chop_prefix ~prefix:"btime ") with
+    | [ btime ] ->
+      Int.of_string btime |> Time_ns.Span.of_int_sec |> Time_ns.of_span_since_epoch
+    | _ -> failwith "can't find btime in /proc/stat")
+;;
+
+let process_start_time pid =
+  (* Find the start time for a process, without requiring the [Procfs] library
+       -- start time is represented in USER_HZ units in /proc/<pid>/stat (confusingly
+       referred to as 'jiffies' in the man page); USER_HZ is almost certainly 100, for
+       mostly historical reasons, but just to be sure we'll ask sysconf.
+  *)
+  let%bind.Option boot_time = boot_time () in
+  let boot_time = Time_ns.to_time_float_round_nearest boot_time in
+  let of_string stat =
+    let jiffies =
+      let fields =
+        String.rsplit2_exn stat ~on:')' |> snd |> String.strip |> String.split ~on:' '
+      in
+      List.nth_exn fields 19 |> Float.of_string
+    in
+    let hz = Unix.sysconf Unix.CLK_TCK |> Option.value_exn |> Int64.to_float in
+    jiffies /. hz |> Time_float.Span.of_sec |> Time_float.add boot_time
+  in
+  read_file_and_convert (sprintf !"/proc/%{Pid}/stat" pid) ~of_string
+;;
+
+module Info = struct
+  module T = struct
+    type t =
+      { host : string
+      ; pid : Pid.Stable.V1.t
+      ; message : string
+      ; start_time : Time_float.Stable.With_utc_sexp.V2.t option [@sexp.option]
+      }
+    [@@deriving compare, sexp, fields ~getters]
+  end
+
+  include T
+  include Sexpable.To_stringable (T)
+
+  let create ~message =
+    let pid = Unix.getpid () in
+    { host = Unix.gethostname (); pid; message; start_time = process_start_time pid }
+  ;;
+
+  let of_file = read_file_and_convert ~of_string
+end
+
+let lock_path path = path ^ ".nfs_lock"
+
+let lock_path_permissive path =
+  if String.is_suffix ~suffix:".nfs_lock" path then path else lock_path path
+;;
+
+let get_hostname_and_pid path =
+  let lock_path = lock_path_permissive path in
+  Option.map (Info.of_file lock_path) ~f:(fun info -> Info.host info, Info.pid info)
+;;
+
+let get_message path =
+  let lock_path = lock_path_permissive path in
+  Option.map (Info.of_file lock_path) ~f:Info.message
+;;
+
+let unlink_if_exists path =
+  try Unix.unlink path with
+  | Unix.Unix_error ((ENOTDIR | ENOENT), _, _) -> ()
+;;
+
+(* Check if the process is running: sends signal 0 to pid, which should work if
+   the process is running and is owned by the user running this code. If the
+   process is not owned by the user running this code we should fail to unlock
+   either earlier (unable to read the file) or later (unable to remove the
+   file). *)
+let pid_start_matches_lock ~info =
+  match Option.both (Info.start_time info) (process_start_time (Info.pid info)) with
+  | None -> true (* don't have both start times: fall back to old behaviour *)
+  | Some (lock_start, pid_start) ->
+    (* our method of calculating start time is open to some inaccuracy, so let's
+       be generous and allow for up to 1s of difference (this would only allow
+       for a collision if pids get reused within 1s, which seems unlikely) *)
+    let epsilon = Time_float.Span.of_sec 1. in
+    Time_float.Span.( < ) (Time_float.abs_diff lock_start pid_start) epsilon
+;;
+
+let read_lock_file ~lock_path =
+  match Sys_unix.file_exists ~follow_symlinks:false lock_path with
+  | `Unknown -> `Error
+  | `No -> `Not_locked
+  | `Yes ->
+    (match Info.of_file lock_path with
+     | None ->
+       (* Used to report "unknown lock file format", but that can be confusing. *)
+       `Error
+     | Some info -> `Locked info)
+;;
+
+let with_openfile_exn file ~f =
+  (* opening the file for writing to make sure [flock] works regardless of
+     how the NFS client is configured (simulation of flock via lockf requires
+     write mode) *)
+  let fd = Unix.openfile ~mode:[ Unix.O_RDWR ] file in
+  Exn.protect ~finally:(fun () -> Unix.close fd) ~f:(fun () -> f fd)
+;;
+
+let with_flock_exn fd ~f =
+  if not (Unix.flock fd Unix.Flock_command.lock_exclusive)
+  then raise_s [%sexp "flock failed (held by another process)"];
+  Exn.protect
+    ~finally:(fun () ->
+      let _ : bool = Unix.flock fd Unix.Flock_command.unlock in
+      ())
+    ~f
+;;
+
+let unlink_lock_files path =
+  let lock_path = lock_path path in
+  (* We need to be able to recover from the situation where [path] does not exist
+     for whatever reason, but [lock_path] is present. We use [unlink_if_exists]
+     to be able to cope with this situation and properly clean up stale locks. *)
+  unlink_if_exists path;
+  Unix.unlink lock_path
+;;
+
+let do_if_locked_exn path ~error ~f =
+  let lock_path = lock_path path in
+  match read_lock_file ~lock_path with
+  | `Error -> error (sprintf "failed to parse info from lock file %s" lock_path)
+  | `Not_locked -> ()
+  | `Locked info -> f ~info
+;;
+
+(* Remove the lock if stale, fail if the lock is held by another process. *)
+let prepare_to_lock_exn path =
+  (* Make sure error messages contain a reference to "lock.nfs_lock", which is the
+     actually important file. *)
+  let lock_path = lock_path path in
+  let error s = failwithf "lock file %S: %s" lock_path s () in
+  do_if_locked_exn path ~error ~f:(fun ~info ->
+    let my_hostname = Unix.gethostname () in
+    let locking_hostname = Info.host info in
+    let locking_pid = Info.pid info in
+    if String.( <> ) my_hostname locking_hostname
+    then
+      error
+        (sprintf
+           "lock already held on %s, unlock attempted from %s"
+           locking_hostname
+           my_hostname)
+    else (
+      let locking_pid_exists () =
+        Signal_unix.can_send_to locking_pid && pid_start_matches_lock ~info
+      in
+      if locking_pid_exists ()
+      then
+        error
+          (sprintf
+             "locking process (pid %i) still running on %s"
+             (Pid.to_int locking_pid)
+             locking_hostname)
+      else (
+        let lock_file_still_there () =
+          [%compare.equal: Info.t option] (Info.of_file lock_path) (Some info)
+        in
+        match lock_file_still_there () with
+        | false ->
+          error
+            (sprintf
+               "lock was held by pid %i (but not anymore, please retry)"
+               (Pid.to_int locking_pid))
+        | true ->
+          (* We know the lock is held by a process that no longer exists.  We want to
+             clean it up, but we need to protect against many processes "cleaning up" the
+             same lock in parallel (thus removing each other's locks).
+
+             Since we know all the cleanup is done on the same box, we can use flock to
+             make sure a given file is cleaned up at most once.
+             (empirically, flock on NFS ensures mutual exclusion locally)
+
+             We try to detect if some other process also tried to clean this up at the
+             same time: If openfile or flock fails, or [lock_file_still_there ()] returns
+             false, indicating an ABA problem. The safest thing to do in that case is to
+             raise and rely on the outer retry loop (in [blocking_create] or in the
+             caller) to handle the new state. *)
+          with_openfile_exn lock_path ~f:(fun fd ->
+            with_flock_exn fd ~f:(fun () ->
+              if lock_file_still_there ()
+              then (
+                try unlink_lock_files path with
+                | e -> error (Exn.to_string e))
+              else
+                error
+                  (sprintf
+                     "lost the race trying to clean up after pid %i"
+                     (Pid.to_int locking_pid)))))))
+;;
+
+let is_my_own_info info =
+  String.equal (Unix.gethostname ()) (Info.host info)
+  && Pid.equal (Unix.getpid ()) (Info.pid info)
+  && pid_start_matches_lock ~info
+;;
+
+let unlock_self_exn path =
+  let error s =
+    failwithf "Lock_file.Nfs.unlock_self_exn: unable to unlock %s: %s" path s ()
+  in
+  (* We can't just assume that we're holding the lock here, we check it first
+     by reading the lock file. It helps to guard against the user error of double-unlock,
+     but more importantly our own [at_exit] handler can already do double-unlock,
+     since it runs unconditionally. *)
+  do_if_locked_exn path ~error ~f:(fun ~info ->
+    if not (is_my_own_info info)
+    then
+      error
+        (sprintf
+           "lock owned (stolen?) by a different process (pid %i running on %s)"
+           (Pid.to_int (Info.pid info))
+           (Info.host info))
+    else (
+      try unlink_lock_files path with
+      | e -> error (Exn.to_string e)))
+;;
+
+(* See mli for more information on the algorithm we use for locking over NFS.  Ensure
+     that you understand it before you make any changes here. *)
+let create_exn ?(message = "") path =
+  try
+    prepare_to_lock_exn path;
+    let fd = Unix.openfile path ~mode:[ Unix.O_WRONLY; Unix.O_CREAT ] in
+    let cleanup = ref (fun () -> Unix.close fd) in
+    protect
+      ~finally:(fun () -> !cleanup ())
+      ~f:(fun () ->
+        Unix.link ~target:path ~link_name:(lock_path path) ();
+        Unix.ftruncate fd ~len:0L;
+        let info = Info.create ~message in
+        (* if this fprintf fails, empty lock file would be left behind, and
+             subsequent calls to [Lock_file.Nfs.create_exn] would be unable to
+             figure out that it is stale/corrupt and remove it. So we need to
+             remove it ourselves *)
+        try
+          let out_channel = Unix.out_channel_of_descr fd in
+          (cleanup := fun () -> Stdlib.close_out_noerr out_channel);
+          fprintf out_channel "%s\n%!" (Sexp.to_string_hum (Info.sexp_of_t info))
+        with
+        | Sys_error _ as err ->
+          Unix.unlink path;
+          Unix.unlink (lock_path path);
+          raise err);
+    at_exit (fun () ->
+      try unlock_self_exn path with
+      | _ -> ())
+  with
+  | e ->
+    failwithf
+      "Lock_file.Nfs.create_exn: unable to lock '%s' - %s"
+      path
+      (Exn.to_string e)
+      ()
+;;
+
+let create ?message path = Or_error.try_with (fun () -> create_exn ?message path)
+let lock_attempt_suffix = ".lock-attempt"
+
+let attempt_path ~path ~info =
+  let md5_hash = Md5.to_hex (Md5.digest_string (Info.to_string info)) in
+  [%string "%{path}.%{md5_hash}%{lock_attempt_suffix}"]
+;;
+
+let is_possibly_attempt_file ~of_:path ~attempt_file_basename =
+  let path_basename = Filename.basename path in
+  let extracted_md5 =
+    let%bind.Option name =
+      String.chop_suffix attempt_file_basename ~suffix:lock_attempt_suffix
+    in
+    let%bind.Option hash = String.chop_prefix ~prefix:(path_basename ^ ".") name in
+    Option.try_with (fun () -> Md5.of_hex_exn hash)
+  in
+  Option.is_some extracted_md5
+;;
+
+let%expect_test "attempt parse back" =
+  let info = Info.create ~message:"" in
+  let path = "/path/to/my-lock" in
+  let path_basename = Filename.basename path in
+  let attempt_file = attempt_path ~path ~info in
+  let attempt_file_basename = Filename.basename attempt_file in
+  [%test_eq: bool]
+    (is_possibly_attempt_file ~of_:path_basename ~attempt_file_basename)
+    true;
+  [%test_eq: bool]
+    (is_possibly_attempt_file ~of_:"other-lock" ~attempt_file_basename)
+    false;
+  [%test_eq: bool]
+    (is_possibly_attempt_file
+       ~of_:path_basename
+       ~attempt_file_basename:(path_basename ^ ".notmd5" ^ lock_attempt_suffix))
+    false;
+  [%test_eq: bool]
+    (is_possibly_attempt_file
+       ~of_:path_basename
+       ~attempt_file_basename:
+         (String.substr_replace_all
+            attempt_file_basename
+            ~pattern:lock_attempt_suffix
+            ~with_:".not-lock-attempt"))
+    false
+;;
+
+let unlink_old_attempts path =
+  let dir, path_basename = Filename.split path in
+  let relevant_attempts =
+    match Sys_unix.readdir dir with
+    | exception _ -> [||]
+    | files ->
+      Array.filter files ~f:(fun attempt_file_basename ->
+        is_possibly_attempt_file ~of_:path_basename ~attempt_file_basename)
+  in
+  (* attempts are supposed to be extremely short-lived (created, then immediately
+     linked and removed), so cleaning up attempts that are more than 5 minutes old seems
+     fine *)
+  let now = Time_float.now () in
+  Array.filter_map relevant_attempts ~f:(fun file ->
+    let file = dir ^/ file in
+    match Core_unix.stat file with
+    | exception _ ->
+      (* maybe the file was removed? don't bother *)
+      None
+    | stat ->
+      let mtime = Time_float.of_span_since_epoch (Time_float.Span.of_sec stat.st_mtime) in
+      Some (Time_float.diff now mtime, file))
+  |> Array.to_list
+  |> List.sort ~compare:[%compare: Time_float.Span.t * string]
+  |> (fun l ->
+       (* keep 3 last attempts unconditionally in case it helps investigate something *)
+       List.drop l 3)
+  |> List.filter_map ~f:(fun (age, file) ->
+    if Time_float.Span.( > ) age (Time_float.Span.of_min 5.) then Some file else None)
+  |> List.iter ~f:(fun file -> unlink_if_exists file)
+;;
+
+let maybe_unlink_old_attempts path =
+  (* Cleaning up old attempts should almost never be needed, since the
+     attempt files are removed immediately by the process that creates
+     them. So we do this probabilistically to avoid always paying the readdir
+     overhead, which can be large if the directory contains lots of files.
+  *)
+  if am_running_test || Float.( < ) (Random.float 1.0) 0.05 then unlink_old_attempts path
+;;
+
+let create_v2_exn ?(message = "") path =
+  try
+    maybe_unlink_old_attempts path;
+    let info = Info.create ~message in
+    let attempt_path = attempt_path ~path ~info in
+    prepare_to_lock_exn path;
+    let lock_dir = Filename.dirname path in
+    if not (Sys_unix.is_directory_exn lock_dir)
+    then
+      (* if the directory doesn't exist, this makes the error message not mention the
+         non-deterministic attempt filename *)
+      failwithf "%s either does not exist or is not a directory" lock_dir ();
+    protect
+      ~finally:(fun () -> unlink_if_exists attempt_path)
+      ~f:(fun () ->
+        Out_channel.with_file ~fail_if_exists:true attempt_path ~f:(fun ch ->
+          Out_channel.output_string ch (Info.to_string info));
+        (* [link] will fail if the target path already exists, so if it succeeds then we
+           know that we must have succeeded in taking the lock. *)
+        Unix.link ~target:attempt_path ~link_name:(lock_path path) ());
+    (try
+       (* This file is useless, but we're still creating it for backwards compatibility.
+          Some tests check that it exists, and it's possible that some people have scripts
+          that read it, so it's easier to create it than to worry about the consequences
+          of dropping it.
+
+          Note that we intentionally do not use [Unix.link] here because that would make
+          it possible for [create_v1] to overwrite files created by [create_v2]. *)
+       Out_channel.write_all path ~data:(Info.to_string info)
+     with
+     | _ -> ());
+    at_exit (fun () ->
+      try unlock_self_exn path with
+      | _ -> ())
+  with
+  | e ->
+    failwithf
+      "Lock_file.Nfs.create_exn: unable to lock '%s' - %s"
+      path
+      (Exn.to_string e)
+      ()
+;;
+
+let create_v2 ?message path = Or_error.try_with (fun () -> create_v2_exn ?message path)
+
+(* default timeout is to wait indefinitely *)
+let blocking_create ?timeout ?message path =
+  repeat_with_timeout ?timeout (fun path -> create_exn ?message path) path
+;;
+
+let critical_section ?message path ~timeout ~f =
+  blocking_create ~timeout ?message path;
+  Exn.protect ~f ~finally:(fun () -> unlock_self_exn path)
+;;
+
+let unlock_exn path = unlock_self_exn path
+let unlock path = Or_error.try_with (fun () -> unlock_exn path)
diff --git a/lock_file_blocking/src/nfs_lock.mli b/lock_file_blocking/src/nfs_lock.mli
new file mode 100644
index 0000000..3fdf586
--- /dev/null
+++ b/lock_file_blocking/src/nfs_lock.mli
@@ -0,0 +1,108 @@
+open! Core
+
+(** An implementation-neutral NFS lock file scheme that relies on the atomicity of link
+    over NFS.  Rather than relying on a working traditional advisory lock system over NFS,
+    we create a hard link between the file given to the [create] call and a new file
+    <filename>.nfs_lock.  This link call is atomic (in that it succeeds or fails) across
+    all systems that have the same filesystem mounted.  The link file must be cleaned up
+    on program exit (normally accomplished by an [at_exit] handler, but see caveats
+    below).
+
+    There are a few caveats compared to local file locks:
+
+    - These calls require the locker to have write access to the directory containing the
+      file being locked.
+
+    - Unlike a normal flock call the lock may not be removed when the calling program
+      exits (in particular if it is killed with SIGKILL).
+
+    - NFS lock files are non-standard and difficult to reason about.  This implementation
+      strives to strike a balance between safety and utility in the common case:
+      {ul
+      {li one program per machine}
+      {li one shared user running the program}
+      }
+
+    Use cases outside of this may push on/break assumptions used for easy lock
+    cleanup/taking and may lead to double-taking the lock.  If you have such an odd use
+    case you should test it carefully/consider a different locking mechanism.
+
+    Specific known bugs:
+
+    - Safety bug: if a stale lock file is present, two instances on the same machine
+      racing to clean up that lock can both "succeed" so the lock ends up taken twice.
+
+    - Liveness bug  (fixed with create_v2):
+      a process can write its hostname*pid information to the void
+      upon taking the lock, so you may end up with a broken (empty) lock file, which
+      needs manual clean-up afterwards.
+      (it seems that for this to happen another process needs to take and release the lock
+      in quick succession)
+*)
+
+(** [create ?message path] tries to create and lock the file at [path] by creating a
+      hard link to [path].nfs_lock. The contents of [path] will be replaced with a sexp
+      containing the caller's hostname and pid, and the optional [message].
+
+      Efforts will be made to release this lock when the calling program exits. But there
+      is no guarantee that this will occur under some types of program crash. If the
+      program crashes without removing the lock file an attempt will be made to clean up
+      on restart by checking the hostname and pid stored in the lockfile.
+  *)
+val create : ?message:string -> string -> unit Or_error.t
+
+(** [create_v2_exn path] uses a slightly different locking scheme: instead of using
+    the original [path], we have every locking attempt create a new file
+    ....path.nfs_lock.attempts/<hash> to do the locking.
+
+    The scheme is expected to be backwards-compatible with [create_exn],
+    while avoiding some concurrency bugs the original scheme suffers from.
+*)
+val create_v2 : ?message:string -> string -> unit Or_error.t
+
+(** [create_exn ?message path] is like [create], but throws an exception when it fails
+      to obtain the lock. *)
+val create_exn : ?message:string -> string -> unit
+
+(** [create_v2_exn ?message path] is like [create_v2], but throws an exception when it
+    fails to obtain the lock. *)
+val create_v2_exn : ?message:string -> string -> unit
+
+(** [blocking_create ?message path] is like [create], but sleeps for a short while
+      between lock attempts and does not return until it succeeds or [timeout] expires.
+      Timeout defaults to wait indefinitely. *)
+val blocking_create : ?timeout:Time_float.Span.t -> ?message:string -> string -> unit
+
+(** [critical_section ?message ~timeout path ~f] wraps function [f] (including
+      exceptions escaping it) by first locking (using {!blocking_create}) and then
+      unlocking the given lock file. *)
+val critical_section
+  :  ?message:string
+  -> string
+  -> timeout:Time_float.Span.t
+  -> f:(unit -> 'a)
+  -> 'a
+
+(** [get_hostname_and_pid path] reads the lock file at [path] and returns the hostname
+      and path in the file.  Returns [None] if the file cannot be read. *)
+val get_hostname_and_pid : string -> (string * Pid.t) option
+
+(** [get_message path] reads the lock file at [path] and returns the message in the
+      file.  Returns [None] if the file cannot be read. *)
+val get_message : string -> string option
+
+(** [unlock_exn path] unlocks [path] if [path] was locked from the same host and the pid
+      in the file is either the current pid or not the pid of a running process.
+
+      It will raise if for some reason the lock at the given path cannot be unlocked, for
+      example if the lock is taken by somebody else that is still alive on the same box,
+      or taken by a process on a different host, or if there are Unix permissions issues,
+      etc.
+
+      This function should be used only by programs that need to release their lock before
+      exiting. If releasing the lock can or should wait till the end of the running
+      process, do not call this function -- this library already takes care of releasing
+      at exit all the locks taken. *)
+val unlock_exn : string -> unit
+
+val unlock : string -> unit Or_error.t
diff --git a/lock_file_blocking/src/shared.ml b/lock_file_blocking/src/shared.ml
new file mode 100644
index 0000000..013aa20
--- /dev/null
+++ b/lock_file_blocking/src/shared.ml
@@ -0,0 +1,56 @@
+open! Core
+module Unix = Core_unix
+
+let random = lazy (Random.State.make_self_init ())
+
+let read_file_and_convert ~of_string path =
+  Option.try_with (fun () -> In_channel.read_all path |> String.strip |> of_string)
+;;
+
+let default_max_retry_delay ~timeout =
+  let default_delay = Time_float.Span.of_int_ms 300 in
+  match timeout with
+  | None -> default_delay
+  | Some timeout -> Time_float.Span.min default_delay (Time_float.Span.( / ) timeout 3.)
+;;
+
+let wait_at_most max_delay random =
+  let delay = Random.State.float (Lazy.force random) (Time_float.Span.to_sec max_delay) in
+  ignore (Unix.nanosleep delay : float)
+;;
+
+(* no timeout specified = wait indefinitely *)
+let repeat_with_timeout ?max_retry_delay ?(random = random) ?timeout lockf path =
+  let max_retry_delay =
+    match max_retry_delay with
+    | Some delay -> delay
+    | None -> default_max_retry_delay ~timeout
+  in
+  match timeout with
+  | None ->
+    let rec loop () =
+      try lockf path with
+      | _ ->
+        wait_at_most max_retry_delay random;
+        loop ()
+    in
+    loop ()
+  | Some timeout ->
+    let start_time = Time_float.now () in
+    let rec loop () =
+      try lockf path with
+      | e ->
+        let since_start = Time_float.abs_diff start_time (Time_float.now ()) in
+        if Time_float.Span.(since_start > timeout)
+        then
+          failwithf
+            "Lock_file: '%s' timed out waiting for existing lock. Last error was %s"
+            path
+            (Exn.to_string e)
+            ()
+        else (
+          wait_at_most max_retry_delay random;
+          loop ())
+    in
+    loop ()
+;;
diff --git a/lock_file_blocking/src/shared.mli b/lock_file_blocking/src/shared.mli
new file mode 100644
index 0000000..18292a4
--- /dev/null
+++ b/lock_file_blocking/src/shared.mli
@@ -0,0 +1,12 @@
+open! Core
+
+val random : Random.State.t Lazy.t
+val read_file_and_convert : of_string:(string -> 'a) -> string -> 'a option
+
+val repeat_with_timeout
+  :  ?max_retry_delay:Core.Core_private.Span_float.t
+  -> ?random:Base.Random.State.t lazy_t
+  -> ?timeout:Core.Core_private.Span_float.t
+  -> (string -> 'a)
+  -> string
+  -> 'a
diff --git a/lock_file_blocking/test-bin/dune b/lock_file_blocking/test-bin/dune
index ed9076e..4079d9a 100644
--- a/lock_file_blocking/test-bin/dune
+++ b/lock_file_blocking/test-bin/dune
@@ -1,6 +1,6 @@
 (executables
  (modes byte exe)
  (names test_lock_file_blocking)
- (libraries command_unix core_unix lock_file_blocking signal_unix)
+ (libraries command_unix core core_unix lock_file_blocking signal_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/lock_file_blocking/test-bin/jbuild-ignore b/lock_file_blocking/test-bin/jbuild-ignore
new file mode 100644
index 0000000..363c98f
--- /dev/null
+++ b/lock_file_blocking/test-bin/jbuild-ignore
@@ -0,0 +1 @@
+test-lock-file
diff --git a/lock_file_blocking/test-bin/test_lock_file_blocking.ml b/lock_file_blocking/test-bin/test_lock_file_blocking.ml
index 732d963..aafed4d 100644
--- a/lock_file_blocking/test-bin/test_lock_file_blocking.ml
+++ b/lock_file_blocking/test-bin/test_lock_file_blocking.ml
@@ -6,32 +6,60 @@ module Unix = Core_unix
    where we're trying to unlock an empty [lockfile]. *)
 
 (* this is so that after safety violation everything stops *)
-let maybe_die () =
+let exit_if_safety_violation_observed () =
   match Unix.access "die" [ `Read ] with
   | Error _exn -> ()
-  | Ok () -> Signal_unix.send_exn Signal.kill (`Pid (Unix.getpid ()))
+  | Ok () -> exit 1
+;;
+
+let maybe_die_to_leave_behind_stale_lockfile () =
+  let stale_lockfile_probability = 0.1 in
+  if Float.(Random.float 1. < stale_lockfile_probability)
+  then Signal_unix.send_exn Signal.kill (`Pid (Unix.getpid ()))
+;;
+
+let delay t =
+  let t = Random.float_range 0.0 t in
+  let (_ : float) = Unix.nanosleep t in
+  ()
 ;;
 
 let nfs_critical_section path ~f =
   let rec obtain () =
-    maybe_die ();
+    exit_if_safety_violation_observed ();
     match Lock_file_blocking.Nfs.create path with
     | Error _e ->
-      ignore (Core_unix.nanosleep 0.0003);
+      delay 0.0003;
       obtain ()
     | Ok () -> ()
   in
   obtain ();
-  f ();
-  Lock_file_blocking.Nfs.unlock_exn path
+  let res = f () in
+  Lock_file_blocking.Nfs.unlock_exn path;
+  res
+;;
+
+let nfs_v2_critical_section path ~f =
+  let rec obtain () =
+    exit_if_safety_violation_observed ();
+    match Lock_file_blocking.Nfs.create_v2 path with
+    | Error _e ->
+      delay 0.0003;
+      obtain ()
+    | Ok () -> ()
+  in
+  obtain ();
+  let res = f () in
+  Lock_file_blocking.Nfs.unlock_exn path;
+  res
 ;;
 
 let critical_section (type a) ~lock ~unlock ~(f : unit -> a) : a =
   let rec obtain () =
-    maybe_die ();
+    exit_if_safety_violation_observed ();
     match lock () with
     | `Somebody_else_took_it ->
-      ignore (Core_unix.nanosleep 0.0003);
+      delay 0.0003;
       obtain ()
     | `We_took_it lock -> lock
   in
@@ -43,10 +71,10 @@ let critical_section (type a) ~lock ~unlock ~(f : unit -> a) : a =
    but close enough *)
 let local_critical_section path ~f =
   let rec obtain () =
-    maybe_die ();
+    exit_if_safety_violation_observed ();
     match Lock_file_blocking.create path with
     | false ->
-      ignore (Core_unix.nanosleep 0.0003);
+      delay 0.0003;
       obtain ()
     | true -> ()
   in
@@ -64,7 +92,8 @@ let mkdir_critical_section (type a) path ~(f : unit -> a) : a =
 let symlink_critical_section path ~f =
   critical_section
     ~lock:(fun () ->
-      match Lock_file_blocking.Symlink.lock_exn ~lock_path:path ~metadata:"blah-blah" with
+      let metadata = sprintf "pid %s" (Unix.getpid () |> Pid.to_string) in
+      match Lock_file_blocking.Symlink.lock_exn ~lock_path:path ~metadata with
       | `Somebody_else_took_it _metadata -> `Somebody_else_took_it
       | `We_took_it lock -> `We_took_it lock)
     ~unlock:Lock_file_blocking.Symlink.unlock_exn
@@ -80,6 +109,15 @@ let mkdir_or_symlink_critical_section (type a) path ~(f : unit -> a) : a =
   critical_section path ~f
 ;;
 
+let nfs_v1_or_v2_critical_section (type a) path ~(f : unit -> a) : a =
+  let critical_section =
+    match Random.bool () with
+    | false -> nfs_critical_section
+    | true -> nfs_v2_critical_section
+  in
+  critical_section path ~f
+;;
+
 let flock_critical_section path ~f =
   critical_section
     ~lock:(fun () -> Lock_file_blocking.Flock.lock_exn () ~lock_path:path)
@@ -90,6 +128,8 @@ let flock_critical_section path ~f =
 let critical_section ~which_lock path ~f =
   match which_lock with
   | `Nfs -> nfs_critical_section path ~f
+  | `Nfs_v2 -> nfs_v2_critical_section path ~f
+  | `Nfs_v1_or_v2 -> nfs_v1_or_v2_critical_section path ~f
   | `Local -> local_critical_section path ~f
   | `Mkdir_or_symlink -> mkdir_or_symlink_critical_section path ~f
   | `Symlink -> symlink_critical_section path ~f
@@ -97,28 +137,31 @@ let critical_section ~which_lock path ~f =
 ;;
 
 let save file contents =
-  let fd = Unix.openfile file ~mode:[ Unix.O_WRONLY; Unix.O_CREAT ] in
+  let fd = Unix.openfile file ~mode:[ O_WRONLY; O_CREAT ] in
   let out_channel = Unix.out_channel_of_descr fd in
   fprintf out_channel "%s\n%!" contents
 ;;
 
-let go ~which_lock () =
+let go ~which_lock ~test_stale_locks path =
   match Unix.fork () with
   | `In_the_child ->
+    Random.self_init ();
     let () =
-      critical_section ~which_lock "lockfile" ~f:(fun () ->
-        maybe_die ();
+      critical_section ~which_lock path ~f:(fun () ->
+        exit_if_safety_violation_observed ();
         let pid = Pid.to_string (Unix.getpid ()) in
         save pid pid;
         (match Unix.mkdir "zoo" with
          | exception exn ->
-           Unix.mkdir "die";
-           raise exn
+           (try Unix.mkdir "die" with
+            | _ -> ());
+           raise_s [%sexp "Safety violation!", (exn : exn)]
          | _ -> ());
-        ignore (Core_unix.nanosleep 0.002);
-        maybe_die ();
+        delay 0.002;
+        exit_if_safety_violation_observed ();
         Unix.rmdir "zoo";
-        Unix.unlink pid)
+        Unix.unlink pid;
+        if test_stale_locks then maybe_die_to_leave_behind_stale_lockfile ())
     in
     exit 0
   | `In_the_parent pid -> pid
@@ -127,20 +170,51 @@ let go ~which_lock () =
 let () =
   Command_unix.run
     (Command.basic
-       ~summary:
-         "This puts a lock file [lockfile] in the directory test-lock-file under heavy \
-          contention"
+       ~summary:"This puts a lock file at [path] under heavy contention"
        (let%map_open.Command which_lock =
           flag
-            ~doc:"Nfs|Local|Mkdir|Flock which lock protocol to use"
+            ~doc:"Nfs|Nfs_v2|Local|Mkdir|Flock which lock protocol to use"
             "which"
             (required
                (sexp_conv
-                  [%of_sexp: [ `Nfs | `Local | `Mkdir_or_symlink | `Symlink | `Flock ]]))
+                  [%of_sexp:
+                    [ `Nfs
+                    | `Nfs_v2
+                    | `Nfs_v1_or_v2
+                    | `Local
+                    | `Mkdir_or_symlink
+                    | `Symlink
+                    | `Flock
+                    ]]))
+        and path =
+          flag
+            ~doc:"FILE the path of the file to lock"
+            "path"
+            (optional_with_default "test-lock-file/lockfile" string)
+        and count =
+          flag
+            ~doc:"NUM number of concurrent processes trying to take the for lock"
+            "n"
+            (optional_with_default 200 int)
+        and test_stale_locks =
+          flag
+            ~doc:
+              "BOOL test what happens when stale lock files are introduced (processes \
+               killed with SIGKILL mid-critical-section). Defaults to false because some \
+               lock types deadlock in this scenario."
+            "stale-locks"
+            (optional_with_default false bool)
         in
         fun () ->
-          Unix.mkdir "test-lock-file";
-          Unix.chdir "test-lock-file";
-          let ps = List.init 2000 ~f:(fun _i -> go ~which_lock ()) in
-          List.iter ps ~f:Unix.waitpid_exn))
+          let dirname, basename = Filename.split path in
+          Unix.mkdir_p dirname;
+          Unix.chdir dirname;
+          let ps =
+            List.init count ~f:(fun _i -> go ~which_lock ~test_stale_locks basename)
+          in
+          List.iter ps ~f:(fun _pid ->
+            let _pid, status = Unix.wait `Any in
+            match status with
+            | Error (`Signal s) when Signal.equal Signal.kill s && test_stale_locks -> ()
+            | e -> Unix.Exit_or_signal.or_error e |> Or_error.ok_exn)))
 ;;
diff --git a/lock_file_blocking/test/dune b/lock_file_blocking/test/dune
index a258003..8a98b51 100644
--- a/lock_file_blocking/test/dune
+++ b/lock_file_blocking/test/dune
@@ -1,6 +1,6 @@
 (library
  (name lock_file_blocking_test)
- (libraries lock_file_blocking expect_test_helpers_core core core_unix
-   filename_unix)
+ (libraries sys_unix lock_file_blocking expect_test_helpers_core core
+   core_unix file_path filesystem_core filename_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/lock_file_blocking/test/test_lock_file_blocking.ml b/lock_file_blocking/test/test_lock_file_blocking.ml
index 9202b1d..d13df63 100644
--- a/lock_file_blocking/test/test_lock_file_blocking.ml
+++ b/lock_file_blocking/test/test_lock_file_blocking.ml
@@ -34,8 +34,8 @@ let%test_module "[Nfs]" =
   (module struct
     open! Nfs
 
-    let create_bool path =
-      match create path with
+    let create_bool ?message path =
+      match create ?message path with
       | Ok () -> true
       | Error _ -> false
     ;;
@@ -47,6 +47,134 @@ let%test_module "[Nfs]" =
     let () = unlock_exn path
     let%test _ = create_bool path
     let () = unlock_exn path
+
+    open Expect_test_helpers_core
+
+    let%expect_test "get lock info" =
+      let dir = Filename_unix.temp_dir "lock_file" "unit_test" in
+      let path = dir ^/ "lock" in
+      assert (create_bool ~message:"hello world" path);
+      let pid = get_hostname_and_pid path |> Option.value_exn |> snd in
+      require_equal (module Pid) pid (Unix.getpid ());
+      let msg = get_message path |> Option.value_exn in
+      require_equal (module String) msg "hello world";
+      unlock_exn path;
+      [%expect ""]
+    ;;
+  end)
+;;
+
+let%test_module "[Nfs-v2]" =
+  (module struct
+    open! Nfs
+
+    let%expect_test "locking and unlocking works" =
+      Filesystem_core.with_temp_dir (fun tmp_dir ->
+        let path = File_path.Absolute.to_string tmp_dir ^/ "lock" in
+        (* Taking the initial lock works. *)
+        create_v2 path |> ok_exn;
+        unlock_exn path;
+        (* Taking the lock again after the initial attempt was unlocked works. *)
+        create_v2 path |> ok_exn;
+        unlock_exn path)
+    ;;
+
+    let%expect_test "clean up in case old attempts gets left on disk" =
+      let test_lock_unlock ?(additional_files = []) attempt_states =
+        Filesystem_core.with_temp_dir (fun tmp_dir ->
+          let tmp_dir = File_path.Absolute.to_string tmp_dir in
+          let path = tmp_dir ^/ "lock" in
+          let create_attempt_file i state =
+            let attempt_file_path =
+              let suffix =
+                match state with
+                | `Fresh -> String.make 24 'f'
+                | `Old -> String.make 24 '0'
+              in
+              path ^ sprintf ".%08d%s.lock-attempt" i suffix
+            in
+            Out_channel.write_all attempt_file_path ~data:"doesn't matter";
+            match state with
+            | `Fresh -> ()
+            | `Old ->
+              Unix.utimes
+                attempt_file_path
+                (* apparently 0 is a special value that corresponds to "now",
+                   thus +1 here *)
+                ~modif:(Float.of_int (i + 1))
+                ~access:(Float.of_int (i + 1))
+          in
+          List.iteri attempt_states ~f:create_attempt_file;
+          List.iter additional_files ~f:(fun additional_file ->
+            let additional_file_path = tmp_dir ^/ additional_file in
+            Unix.openfile ~mode:[ O_WRONLY; O_CREAT ] additional_file_path |> Unix.close;
+            (* Always make additional files old to make sure that we don't accidentally
+               clean them up. *)
+            Unix.utimes additional_file_path ~modif:1. ~access:1.);
+          let ls () =
+            List.iter
+              (Sys_unix.ls_dir tmp_dir |> List.sort ~compare:String.compare)
+              ~f:print_endline
+          in
+          print_endline "Before lock and unlock:";
+          ls ();
+          create_v2 path |> ok_exn;
+          unlock_exn path;
+          print_endline "";
+          print_endline "After lock and unlock:";
+          ls ())
+      in
+      (* All fresh attempt lock files are kept. *)
+      test_lock_unlock (List.init 5 ~f:(fun i -> if i < 4 then `Fresh else `Old));
+      [%expect
+        {|
+        Before lock and unlock:
+        lock.00000000ffffffffffffffffffffffff.lock-attempt
+        lock.00000001ffffffffffffffffffffffff.lock-attempt
+        lock.00000002ffffffffffffffffffffffff.lock-attempt
+        lock.00000003ffffffffffffffffffffffff.lock-attempt
+        lock.00000004000000000000000000000000.lock-attempt
+
+        After lock and unlock:
+        lock.00000000ffffffffffffffffffffffff.lock-attempt
+        lock.00000001ffffffffffffffffffffffff.lock-attempt
+        lock.00000002ffffffffffffffffffffffff.lock-attempt
+        lock.00000003ffffffffffffffffffffffff.lock-attempt
+        |}];
+      (* Old attempt lock files are cleared, but we keep the last 3 around. Unrelated
+         files are not affected. *)
+      test_lock_unlock ~additional_files:[ "unrelated" ] (List.init 5 ~f:(Fn.const `Old));
+      [%expect
+        {|
+        Before lock and unlock:
+        lock.00000000000000000000000000000000.lock-attempt
+        lock.00000001000000000000000000000000.lock-attempt
+        lock.00000002000000000000000000000000.lock-attempt
+        lock.00000003000000000000000000000000.lock-attempt
+        lock.00000004000000000000000000000000.lock-attempt
+        unrelated
+
+        After lock and unlock:
+        lock.00000002000000000000000000000000.lock-attempt
+        lock.00000003000000000000000000000000.lock-attempt
+        lock.00000004000000000000000000000000.lock-attempt
+        unrelated
+        |}]
+    ;;
+
+    open Expect_test_helpers_core
+
+    let%expect_test "get lock info" =
+      Filesystem_core.with_temp_dir (fun dir ->
+        let path = File_path.Absolute.to_string dir ^/ "lock" in
+        create_v2 ~message:"hello world" path |> ok_exn;
+        let pid = get_hostname_and_pid path |> Option.value_exn |> snd in
+        require_equal (module Pid) pid (Unix.getpid ());
+        let msg = get_message path |> Option.value_exn in
+        require_equal (module String) msg "hello world";
+        unlock_exn path;
+        [%expect ""])
+    ;;
   end)
 ;;
 
diff --git a/nano_mutex/src/nano_mutex.ml b/nano_mutex/src/nano_mutex.ml
index 3e0c300..daf7057 100644
--- a/nano_mutex/src/nano_mutex.ml
+++ b/nano_mutex/src/nano_mutex.ml
@@ -37,9 +37,10 @@ end = struct
   let save_unused t = Thread_safe_queue.enqueue unused t
 
   let create () =
-    if Thread_safe_queue.length unused > 0
-    then Thread_safe_queue.dequeue_exn unused
-    else { mutex = Mutex.create (); condition = Condition.create () }
+    match Thread_safe_queue.dequeue unused with
+    | Thread_safe_queue.Dequeue_result.Empty ->
+      { mutex = Mutex.create (); condition = Condition.create () }
+    | Not_empty { elt } -> elt
   ;;
 
   let critical_section t ~f = Mutex.critical_section t.mutex ~f
@@ -55,13 +56,18 @@ module Thread_id_option : sig
   val is_none : t -> bool
   val is_some : t -> bool
 end = struct
-  type t = int [@@deriving equal, sexp_of]
+  type t = int [@@deriving sexp_of]
 
   let none = -1
   let[@inline always] is_none t = t = none
   let[@inline always] is_some t = t <> none
   let[@inline always] some int = int
   let sexp_of_t t = if t = none then [%sexp "None"] else [%sexp (t : t)]
+
+  (* The atomicity of some sections marked "BEGIN/END ATOMIC" later in this file require
+     [equal] to be implemented such that the OCaml compiler will not insert safepoints in
+     its prelude.  We write out the definition rather than deriving it for this reason. *)
+  let[@inline] equal (t1 : int) t2 = t1 = t2
 end
 
 (* We represent a nano mutex using an OCaml record.  The [id_of_thread_holding_lock] field
diff --git a/nano_mutex/test/dune b/nano_mutex/test/dune
index d78fd24..fac3234 100644
--- a/nano_mutex/test/dune
+++ b/nano_mutex/test/dune
@@ -1,5 +1,5 @@
 (library
  (name nano_mutex_test)
- (libraries core core_unix nano_mutex async_unix.thread_safe_ivar)
+ (libraries core core_thread core_unix nano_mutex async_unix.thread_safe_ivar)
  (preprocess
   (pps ppx_jane)))
diff --git a/ocaml_c_utils/src/dune b/ocaml_c_utils/src/dune
index a573205..bf4332a 100644
--- a/ocaml_c_utils/src/dune
+++ b/ocaml_c_utils/src/dune
@@ -2,7 +2,7 @@
  (foreign_stubs
   (language c)
   (names ocaml_c_utils_stubs)
-  (flags :standard -D_LARGEFILE64_SOURCE))
+  (flags :standard -fPIC -D_LARGEFILE64_SOURCE))
  (name ocaml_c_utils)
  (public_name core_unix.ocaml_c_utils)
  (libraries jane-street-headers)
diff --git a/ocaml_c_utils/src/ocaml_c_utils_stubs.c b/ocaml_c_utils/src/ocaml_c_utils_stubs.c
index 9f91411..f2a4617 100644
--- a/ocaml_c_utils/src/ocaml_c_utils_stubs.c
+++ b/ocaml_c_utils/src/ocaml_c_utils_stubs.c
@@ -1,6 +1,8 @@
 /* Various utility functions for C <-> Caml interoperability. */
 
 
+#undef Hide_upstream_size_macros
+
 #include <string.h>
 
 int strcmp_not_a_macro(const char* s1, const char* s2)
diff --git a/process_env/test/dune b/process_env/test/dune
index f29c23b..8fec527 100644
--- a/process_env/test/dune
+++ b/process_env/test/dune
@@ -1,5 +1,5 @@
 (library
  (name process_env_test)
- (libraries core process_env)
+ (libraries core core_unix process_env)
  (preprocess
   (pps ppx_jane)))
diff --git a/signal_unix/src/dune b/signal_unix/src/dune
index 44a50e1..62cdb25 100644
--- a/signal_unix/src/dune
+++ b/signal_unix/src/dune
@@ -4,6 +4,6 @@
   (names signal_unix_stubs))
  (name signal_unix)
  (public_name core_unix.signal_unix)
- (libraries core_kernel.caml_unix core)
+ (libraries core_kernel.caml_unix core unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/sys_unix/src/sys_unix.ml b/sys_unix/src/sys_unix.ml
index 40bce57..bf6114d 100644
--- a/sys_unix/src/sys_unix.ml
+++ b/sys_unix/src/sys_unix.ml
@@ -95,7 +95,7 @@ external executing_bytecode
   -> unit
   -> bool
   = "executing_bytecode" "not_executing_bytecode"
-  [@@noalloc]
+[@@noalloc]
 
 let execution_mode () =
   if executing_bytecode () () () () () () then `Bytecode else `Native
diff --git a/sys_unix/src/sys_unix.mli b/sys_unix/src/sys_unix.mli
index 870e6a7..b64f6fb 100644
--- a/sys_unix/src/sys_unix.mli
+++ b/sys_unix/src/sys_unix.mli
@@ -131,7 +131,7 @@ val execution_mode : unit -> [ `Bytecode | `Native ]
     files. Note that this can be different from [word_size] and [Nativeint.num_bits]. For
     example, Linux x86-64 should have [word_size = 64], but [c_int_size () = 32]. *)
 external c_int_size : unit -> int = "c_int_size"
-  [@@noalloc]
+[@@noalloc]
 
 (** Return the home directory, using the [HOME] environment variable if that is defined,
     and if not, using the effective user's information in the Unix password database. *)
diff --git a/sys_unix/src/sys_unix_stubs.c b/sys_unix/src/sys_unix_stubs.c
index ce12334..69d431b 100644
--- a/sys_unix/src/sys_unix_stubs.c
+++ b/sys_unix/src/sys_unix_stubs.c
@@ -6,8 +6,8 @@ CAMLprim value executing_bytecode(value *_vals, int *_nvals) {
   return Val_true;
 }
 
-CAMLprim value not_executing_bytecode(value _v1, value _v2, value _v3,
-                                      value _v4, value _v5, value _v6) {
+CAMLprim value not_executing_bytecode(value _v1, value _v2, value _v3, value _v4,
+                                      value _v5, value _v6) {
   ((void)_v1);
   ((void)_v2);
   ((void)_v3);
diff --git a/sys_unix/test/dune b/sys_unix/test/dune
index 8807e54..03f78ee 100644
--- a/sys_unix/test/dune
+++ b/sys_unix/test/dune
@@ -1,5 +1,5 @@
 (library
  (name sys_unix_test)
- (libraries sys_unix)
+ (libraries core sys_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/sys_unix/test/test_sys_unix.ml b/sys_unix/test/test_sys_unix.ml
index 212a974..17932ea 100644
--- a/sys_unix/test/test_sys_unix.ml
+++ b/sys_unix/test/test_sys_unix.ml
@@ -23,7 +23,8 @@ let%expect_test _ =
   print_s [%sexp (Sys.get_argv () : string array)];
   Sys_unix.override_argv old_sys_argv;
   print_s [%sexp ([%equal: string array] (Sys.get_argv ()) old_sys_argv : bool)];
-  [%expect {|
+  [%expect
+    {|
     (THIS IS A TEST)
     true
     |}]
diff --git a/syslog/src/syslog.mli b/syslog/src/syslog.mli
index 5e729f2..a44e1cd 100644
--- a/syslog/src/syslog.mli
+++ b/syslog/src/syslog.mli
@@ -12,7 +12,7 @@ module Open_option : sig
   type t =
     | PID (** Include PID with each message *)
     | CONS
-        (** Write directly to system console if there is an error
+    (** Write directly to system console if there is an error
                   while sending to system logger *)
     | ODELAY (** Delay opening of the connection until syslog is called *)
     | NDELAY (** No delay opening connection to syslog daemon *)
diff --git a/time_float_unix/bench-bin/dune b/time_float_unix/bench-bin/dune
index f9aa7fe..2439b77 100644
--- a/time_float_unix/bench-bin/dune
+++ b/time_float_unix/bench-bin/dune
@@ -1,6 +1,6 @@
 (executables
  (modes byte exe)
  (names zone_next_clock_shift)
- (libraries command_unix core_bench time_float_unix)
+ (libraries command_unix core core_bench time_float_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_float_unix/bench/bench_time.ml b/time_float_unix/bench/bench_time.ml
index 55c5d86..1754708 100644
--- a/time_float_unix/bench/bench_time.ml
+++ b/time_float_unix/bench/bench_time.ml
@@ -2,610 +2,18 @@ open! Core
 module Unix = Core_unix
 module Time = Time_float_unix
 
-module Constants = struct
-  (* We wrap all constants with [Sys.opaque_identity] so that callsites cannot specialize
-     code to their values. *)
-  let opaque = Sys.opaque_identity
-  let int_zero = opaque 0
-  let int32_zero = opaque 0l
-  let int63_zero = opaque Int63.zero
-  let float_pi = opaque Float.pi
-  let percent_half = opaque (Percent.of_mult 0.5)
-  let date = opaque (Date.create_exn ~y:2013 ~m:Oct ~d:07)
-  let hash_state = opaque (Hash.create ())
-  let utc = opaque Time.Zone.utc
-  let nyc = opaque (Time.Zone.find_exn "America/New_York")
-
-  (* We define some dates and times with different daylight savings properties for
-     purposes of benchmarking time zone logic. *)
-
-  let nyc_winter_date = opaque (Date.create_exn ~y:2013 ~m:Jan ~d:03)
-  let nyc_summer_date = opaque (Date.create_exn ~y:2014 ~m:Jul ~d:04)
-  let noon = opaque (Time.Ofday.create ~hr:12 ())
-  let nyc_transition_date = opaque (Date.create_exn ~y:2015 ~m:Nov ~d:01)
-  let nyc_transition_ofday = opaque (Time.Ofday.create ~hr:01 ~min:30 ())
-  let nyc_skip_date = opaque (Date.create_exn ~y:2015 ~m:Mar ~d:08)
-  let nyc_skip_ofday = opaque (Time.Ofday.create ~hr:02 ~min:30 ())
-  let nyc_winter_time = opaque (Time.of_date_ofday ~zone:nyc nyc_winter_date noon)
-  let nyc_summer_time = opaque (Time.of_date_ofday ~zone:nyc nyc_summer_date noon)
-
-  let nyc_transition_time =
-    opaque (Time.of_date_ofday ~zone:nyc nyc_transition_date nyc_transition_ofday)
-  ;;
-
-  let nyc_skip_time = opaque (Time.of_date_ofday ~zone:nyc nyc_skip_date nyc_skip_ofday)
-
-  let%test_module "daylight savings" =
-    (module struct
-      type precise =
-        Date.t
-        * Time.Ofday.t
-        * [ `Also_at of Time.t | `Also_skipped of Date.t * Time.Ofday.t | `Only ]
-      [@@deriving sexp_of]
-
-      let test_time time =
-        printf !"%{sexp: Time.t}\n" time;
-        printf !"%{sexp: precise}\n" (Time.to_date_ofday_precise ~zone:nyc time)
-      ;;
-
-      let%expect_test "winter" =
-        test_time nyc_winter_time;
-        [%expect
-          {|
-          (2013-01-03 12:00:00.000000-05:00)
-          (2013-01-03 12:00:00.000000 Only)
-          |}]
-      ;;
-
-      let%expect_test "summer" =
-        test_time nyc_summer_time;
-        [%expect
-          {|
-          (2014-07-04 12:00:00.000000-04:00)
-          (2014-07-04 12:00:00.000000 Only)
-          |}]
-      ;;
-
-      let%expect_test "transition" =
-        test_time nyc_transition_time;
-        [%expect
-          {|
-          (2015-11-01 01:30:00.000000-05:00)
-          (2015-11-01 01:30:00.000000 (Also_at (2015-11-01 01:30:00.000000-04:00)))
-          |}]
-      ;;
-
-      let%expect_test "skip" =
-        test_time nyc_skip_time;
-        [%expect
-          {|
-          (2015-03-08 03:30:00.000000-04:00)
-          (2015-03-08 03:30:00.000000 (Also_skipped (2015-03-08 02:30:00.000000)))
-          |}]
-      ;;
-    end)
-  ;;
-end
-
-open Constants
-
-(* Below this point we [open] the modules in [Time], alias their definitions, and
-   benchmark each function after its alias. This ensures we benchmark (or explicitly
-   ignore) every function in the public API. We make a few exceptions like submodules from
-   the [Identifiable] functor whose code is not in [Time] itself, but for individual
-   functions it's often as easy to write a benchmark as it is to write a comment
-   justifying the lack of benchmark, so we don't insist that every benchmark is obviously
-   valuable in order for it to be included. *)
-(* Many of these benchmarks duplicate the corresponding benchmarks in Core -- this is
-   intentional, because we want to ensure that whatever mechanism we use to share code
-   between them doesn't differentially slow one of them down. *)
+(* The signature ensures we match the signature of [Time_float_unix]. Things in
+   [Time_float] are already covered by core's benchmarks so we skip them here. *)
+include Time_float
 open Time
 
-module Span = struct
-  open Span
-  module Parts = Parts
-  module Map = Map
-  module Set = Set
-  module Table = Table
-  module Hash_set = Hash_set
-  module Hash_queue = Hash_queue
-  module Diff = Diff
-
-  type nonrec underlying = underlying
-  type nonrec t = t [@@deriving bin_io, quickcheck, sexp_grammar, typerep]
-  type nonrec comparator_witness = comparator_witness
-
-  let arg_type = arg_type
-  let comparator = comparator
-  let hashable = hashable
-  let pp = pp
-  let gen_incl = gen_incl
-  let gen_uniform_incl = gen_uniform_incl
-  let zero = opaque zero
-  let nanosecond = opaque nanosecond
-  let microsecond = opaque microsecond
-  let millisecond = opaque millisecond
-  let second = opaque second
-  let minute = opaque minute
-  let hour = opaque hour
-  let day = opaque day
-  let robust_comparison_tolerance = opaque robust_comparison_tolerance
-
-  module Span_constants = struct
-    let day_sexp = sexp_of_t day |> opaque
-    let day_string = to_string day |> opaque
-  end
-
-  open Span_constants
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare (<)" = compare zero day
-    let%bench "compare (>)" = compare day zero
-    let%bench "compare (=)" = compare zero zero
-    let equal = equal
-    let%bench "equal" = equal zero day
-    let min = min
-    let%bench "min" = min zero day
-    let max = max
-    let%bench "max" = max zero day
-    let ( = ) = ( = )
-    let%bench "(=)" = zero = day
-    let ( < ) = ( < )
-    let%bench "(<)" = zero < day
-    let ( > ) = ( > )
-    let%bench "(>)" = zero > day
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = zero <= day
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = zero >= day
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = zero <> day
-  end
-
-  let compare = compare
-  let%bench "compare (<)" = compare zero day
-  let%bench "compare (>)" = compare day zero
-  let%bench "compare (=)" = compare zero zero
-  let ascending = ascending
-  let%bench "ascending" = ascending zero day
-  let descending = descending
-  let%bench "descending" = descending zero day
-  let equal = equal
-  let%bench "equal" = equal zero day
-  let min = min
-  let%bench "min" = min zero day
-  let max = max
-  let%bench "max" = max zero day
-  let ( = ) = ( = )
-  let%bench "(=)" = zero = day
-  let ( < ) = ( < )
-  let%bench "(<)" = zero < day
-  let ( > ) = ( > )
-  let%bench "(>)" = zero > day
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = zero <= day
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = zero >= day
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = zero <> day
-  let between = between
-  let%bench "between" = between zero ~low:zero ~high:day
-  let clamp = clamp
-  let%bench "clamp" = clamp zero ~min:zero ~max:day
-  let clamp_exn = clamp_exn
-  let%bench "clamp_exn" = clamp_exn zero ~min:zero ~max:day
-  let validate_bound = validate_bound
-  let%bench "validate_bound" = validate_bound ~min:(Incl zero) ~max:(Incl day) zero
-  let validate_lbound = validate_lbound
-  let%bench "validate_lbound" = validate_lbound ~min:(Incl zero) zero
-  let validate_ubound = validate_ubound
-  let%bench "validate_ubound" = validate_ubound ~max:(Incl day) zero
-  let validate_positive = validate_positive
-  let%bench "validate_positive" = validate_positive zero
-  let validate_negative = validate_negative
-  let%bench "validate_negative" = validate_negative zero
-  let validate_non_positive = validate_non_positive
-  let%bench "validate_non_positive" = validate_non_positive zero
-  let validate_non_negative = validate_non_negative
-  let%bench "validate_non_negative" = validate_non_negative zero
-  let is_positive = is_positive
-  let%bench "is_positive" = is_positive zero
-  let is_negative = is_negative
-  let%bench "is_negative" = is_negative zero
-  let is_non_positive = is_non_positive
-  let%bench "is_non_positive" = is_non_positive zero
-  let is_non_negative = is_non_negative
-  let%bench "is_non_negative" = is_non_negative zero
-  let sign = sign
-  let%bench "sign" = sign zero
-  let hash = hash
-  let%bench "hash" = hash zero
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state zero
-  let robustly_compare = robustly_compare
-  let%bench "robustly_compare (<)" = robustly_compare zero day
-  let%bench "robustly_compare (>)" = robustly_compare day zero
-  let%bench "robustly_compare (=)" = robustly_compare zero zero
-  let ( =. ) = ( =. )
-  let%bench "(=.)" = zero =. day
-  let ( <. ) = ( <. )
-  let%bench "(<.)" = zero <. day
-  let ( >. ) = ( >. )
-  let%bench "(>.)" = zero >. day
-  let ( <=. ) = ( <=. )
-  let%bench "(<=.)" = zero <=. day
-  let ( >=. ) = ( >=. )
-  let%bench "(>=.)" = zero >=. day
-  let ( <>. ) = ( <>. )
-  let%bench "(<>.)" = zero <>. day
-  let create = create
-  let%bench "create" = create ~sign:Pos ~day:1 ~hr:1 ~min:1 ~sec:1 ~ms:1 ~us:1 ()
-  let to_parts = to_parts
-  let%bench "to_parts" = to_parts day
-  let of_ns = of_ns
-  let%bench "of_ns" = of_ns float_pi
-  let of_us = of_us
-  let%bench "of_us" = of_us float_pi
-  let of_ms = of_ms
-  let%bench "of_ms" = of_ms float_pi
-  let of_sec = of_sec
-  let%bench "of_sec" = of_sec float_pi
-  let of_min = of_min
-  let%bench "of_min" = of_min float_pi
-  let of_hr = of_hr
-  let%bench "of_hr" = of_hr float_pi
-  let of_day = of_day
-  let%bench "of_day" = of_day float_pi
-  let of_int_ns = of_int_ns
-  let%bench "of_int_ns" = of_int_ns int_zero
-  let of_int_us = of_int_us
-  let%bench "of_int_us" = of_int_us int_zero
-  let of_int_ms = of_int_ms
-  let%bench "of_int_ms" = of_int_ms int_zero
-  let of_int_sec = of_int_sec
-  let%bench "of_int_sec" = of_int_sec int_zero
-  let of_int_min = of_int_min
-  let%bench "of_int_min" = of_int_min int_zero
-  let of_int_hr = of_int_hr
-  let%bench "of_int_hr" = of_int_hr int_zero
-  let of_int_day = of_int_day
-  let%bench "of_int_day" = of_int_day int_zero
-  let of_int32_seconds = of_int32_seconds
-  let%bench "of_int32_seconds" = of_int32_seconds int32_zero
-  let of_int63_seconds = of_int63_seconds
-  let%bench "of_int63_seconds" = of_int63_seconds int63_zero
-  let to_ns = to_ns
-  let%bench "to_ns" = to_ns day
-  let to_us = to_us
-  let%bench "to_us" = to_us day
-  let to_ms = to_ms
-  let%bench "to_ms" = to_ms day
-  let to_sec = to_sec
-  let%bench "to_sec" = to_sec day
-  let to_min = to_min
-  let%bench "to_min" = to_min day
-  let to_hr = to_hr
-  let%bench "to_hr" = to_hr day
-  let to_day = to_day
-  let%bench "to_day" = to_day day
-  let to_int63_seconds_round_down_exn = to_int63_seconds_round_down_exn
-  let%bench "to_int63_seconds_round_down_exn" = to_int63_seconds_round_down_exn day
-  let to_proportional_float = to_proportional_float
-  let%bench "to_proportional_float" = to_proportional_float day
-  let ( + ) = ( + )
-  let%bench "(+)" = day + hour
-  let ( - ) = ( - )
-  let%bench "(-)" = day - hour
-  let abs = abs
-  let%bench "abs" = abs day
-  let neg = neg
-  let%bench "neg" = neg day
-  let scale = scale
-  let%bench "scale" = scale day float_pi
-  let ( / ) = ( / )
-  let%bench "(/)" = day / float_pi
-  let ( // ) = ( // )
-  let%bench "(//)" = day // hour
-  let next = next
-  let%bench "next" = next minute
-  let prev = prev
-  let%bench "prev" = prev minute
-  let to_unit_of_time = to_unit_of_time
-  let%bench "to_unit_of_time" = to_unit_of_time day
-  let of_unit_of_time = of_unit_of_time
-  let%bench "of_unit_of_time" = of_unit_of_time Day
-  let randomize = randomize
-  let%bench "randomize" = randomize day ~percent:percent_half
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t" = sexp_of_t day
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp" = t_of_sexp day_sexp
-  let to_string = to_string
-  let%bench "to_string" = to_string day
-  let of_string = of_string
-  let%bench "of_string" = of_string day_string
-  let to_short_string = to_short_string
-  let%bench "to_short_string" = to_short_string day
-  let to_string_hum = to_string_hum
-  let%bench "to_string_hum" = to_string_hum day
-end
-
-module Ofday = struct
-  open Ofday
-  module Map = Map
-  module Set = Set
-  module Table = Table
-  module Hash_set = Hash_set
-  module Hash_queue = Hash_queue
-  module Diff = Diff
-
-  type nonrec t = t [@@deriving bin_io, quickcheck, sexp_grammar, typerep]
-  type nonrec comparator_witness = comparator_witness
-
-  let arg_type = arg_type
-  let comparator = comparator
-  let hashable = hashable
-  let pp = pp
-  let gen_incl = gen_incl
-  let gen_uniform_incl = gen_uniform_incl
-  let start_of_day = opaque start_of_day
-  let start_of_next_day = opaque start_of_next_day
-  let approximate_end_of_day = opaque approximate_end_of_day
-
-  module Ofday_constants = struct
-    let example = create ~hr:13 ~min:29 ~sec:59 ~ms:654 ~us:321 () |> opaque
-    let example_sexp = sexp_of_t example |> opaque
-    let example_string = to_string example |> opaque
-  end
-
-  open Ofday_constants
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare (<)" = compare start_of_day example
-    let%bench "compare (>)" = compare example start_of_day
-    let%bench "compare (=)" = compare start_of_day start_of_day
-    let equal = equal
-    let%bench "equal" = equal start_of_day example
-    let min = min
-    let%bench "min" = min start_of_day example
-    let max = max
-    let%bench "max" = max start_of_day example
-    let ( = ) = ( = )
-    let%bench "(=)" = start_of_day = example
-    let ( < ) = ( < )
-    let%bench "(<)" = start_of_day < example
-    let ( > ) = ( > )
-    let%bench "(>)" = start_of_day > example
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = start_of_day <= example
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = start_of_day >= example
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = start_of_day <> example
-  end
-
-  let compare = compare
-  let%bench "compare (<)" = compare start_of_day example
-  let%bench "compare (>)" = compare example start_of_day
-  let%bench "compare (=)" = compare start_of_day start_of_day
-  let ascending = ascending
-  let%bench "ascending" = ascending start_of_day example
-  let descending = descending
-  let%bench "descending" = descending start_of_day example
-  let equal = equal
-  let%bench "equal" = equal start_of_day example
-  let min = min
-  let%bench "min" = min start_of_day example
-  let max = max
-  let%bench "max" = max start_of_day example
-  let ( = ) = ( = )
-  let%bench "(=)" = start_of_day = example
-  let ( < ) = ( < )
-  let%bench "(<)" = start_of_day < example
-  let ( > ) = ( > )
-  let%bench "(>)" = start_of_day > example
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = start_of_day <= example
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = start_of_day >= example
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = start_of_day <> example
-  let between = between
-  let%bench "between" = between start_of_day ~low:start_of_day ~high:example
-  let clamp = clamp
-  let%bench "clamp" = clamp start_of_day ~min:start_of_day ~max:example
-  let clamp_exn = clamp_exn
-  let%bench "clamp_exn" = clamp_exn start_of_day ~min:start_of_day ~max:example
-  let validate_bound = validate_bound
-
-  let%bench "validate_bound" =
-    validate_bound ~min:(Incl start_of_day) ~max:(Incl example) start_of_day
-  ;;
-
-  let validate_lbound = validate_lbound
-  let%bench "validate_lbound" = validate_lbound ~min:(Incl start_of_day) start_of_day
-  let validate_ubound = validate_ubound
-  let%bench "validate_ubound" = validate_ubound ~max:(Incl example) start_of_day
-  let hash = hash
-  let%bench "hash" = hash start_of_day
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state start_of_day
-  let robustly_compare = robustly_compare
-  let%bench "robustly_compare (<)" = robustly_compare start_of_day example
-  let%bench "robustly_compare (>)" = robustly_compare example start_of_day
-  let%bench "robustly_compare (=)" = robustly_compare start_of_day start_of_day
-  let ( =. ) = ( =. )
-  let%bench "(=.)" = start_of_day =. example
-  let ( <. ) = ( <. )
-  let%bench "(<.)" = start_of_day <. example
-  let ( >. ) = ( >. )
-  let%bench "(>.)" = start_of_day >. example
-  let ( <=. ) = ( <=. )
-  let%bench "(<=.)" = start_of_day <=. example
-  let ( >=. ) = ( >=. )
-  let%bench "(>=.)" = start_of_day >=. example
-  let ( <>. ) = ( <>. )
-  let%bench "(<>.)" = start_of_day <>. example
-  let create = create
-  let%bench "create" = create ~hr:13 ~min:29 ~sec:59 ~ms:654 ~us:321 ()
-  let to_parts = to_parts
-  let%bench "to_parts" = to_parts example
-  let to_span_since_start_of_day = to_span_since_start_of_day
-  let%bench "to_span_since_start_of_day" = to_span_since_start_of_day example
-  let of_span_since_start_of_day_exn = of_span_since_start_of_day_exn
-  let of_span_since_start_of_day = of_span_since_start_of_day_exn
-  let%bench "of_span_since_start_of_day_exn" = of_span_since_start_of_day_exn Span.hour
-  let of_span_since_start_of_day_unchecked = of_span_since_start_of_day_unchecked
-
-  let%bench "of_span_since_start_of_day_unchecked" =
-    of_span_since_start_of_day_unchecked Span.hour
-  ;;
-
-  let span_since_start_of_day_is_valid = span_since_start_of_day_is_valid
-
-  let%bench "span_since_start_of_day_is_valid" =
-    span_since_start_of_day_is_valid Span.hour
-  ;;
-
-  let add = add
-  let%bench "add" = add example Span.hour
-  let sub = sub
-  let%bench "sub" = sub example Span.hour
-  let next = next
-  let%bench "next" = next example
-  let prev = prev
-  let%bench "prev" = prev example
-  let diff = diff
-  let%bench "diff" = diff example start_of_day
-  let small_diff = small_diff
-  let%bench "small_diff" = small_diff example start_of_day
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t" = sexp_of_t example
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp" = t_of_sexp example_sexp
-  let to_string = to_string
-  let%bench "to_string" = to_string example
-  let of_string = of_string
-  let%bench "of_string" = of_string example_string
-  let to_string_trimmed = to_string_trimmed
-  let%bench "to_string_trimmed" = to_string_trimmed example
-  let to_sec_string = to_sec_string
-  let%bench "to_sec_string" = to_sec_string example
-  let to_millisecond_string = to_millisecond_string
-  let to_millisec_string = to_millisecond_string
-  let%bench "to_millisecond_string" = to_millisecond_string example
-  let of_string_iso8601_extended = of_string_iso8601_extended
-  let%bench "of_string_iso8601_extended" = of_string_iso8601_extended example_string
-  let now = now
-  let%bench "now" = now ~zone:utc
-
-  module Zoned = struct
-    open Zoned
-
-    type nonrec t = t [@@deriving bin_io]
-
-    let arg_type = arg_type
-    let pp = pp
-
-    module Ofday_zoned_constants = struct
-      let zero_utc = create start_of_day utc |> opaque
-
-      let example =
-        create Ofday_constants.example (Zone.find_exn "America/New_York") |> opaque
-      ;;
-
-      let example_sexp = sexp_of_t example |> opaque
-      let example_string = to_string example |> opaque
-    end
-
-    include Ofday_zoned_constants
-
-    module With_nonchronological_compare = struct
-      open With_nonchronological_compare
-
-      type nonrec t = t [@@deriving bin_io]
-
-      let compare = compare
-      let%bench "compare (<)" = compare zero_utc example
-      let%bench "compare (>)" = compare example zero_utc
-      let%bench "compare (=)" = compare zero_utc zero_utc
-      let equal = equal
-      let%bench "compare (=)" = equal example example
-      let%bench "compare (<>)" = equal zero_utc example
-      let hash = hash
-      let%bench "hash" = hash zero_utc
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t example
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp example_sexp
-    end
-
-    let hash = hash
-    let%bench "hash" = hash zero_utc
-    let hash_fold_t = hash_fold_t
-    let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-    let create = create
-    let%bench "create" = create Ofday_constants.example utc
-    let create_local = create_local
-    let%bench "create_local" = create_local Ofday_constants.example
-    let ofday = ofday
-    let%bench "ofday" = ofday example
-    let zone = zone
-    let%bench "zone" = zone example
-    let to_time = to_time
-    let%bench "to_time" = to_time example date
-    let sexp_of_t = sexp_of_t
-    let%bench "sexp_of_t" = sexp_of_t example
-    let t_of_sexp = t_of_sexp
-    let%bench "t_of_sexp" = t_of_sexp example_sexp
-    let to_string = to_string
-    let%bench "to_string" = to_string example
-    let of_string = of_string
-    let%bench "of_string" = of_string example_string
-    let to_string_trimmed = to_string_trimmed
-    let%bench "to_string_trimmed" = to_string_trimmed example
-  end
-end
-
-module Diff = Diff
-module Map = Map
-module Set = Set
-module Table = Table
-module Hash_set = Hash_set
-module Hash_queue = Hash_queue
-module Exposed_for_tests = Exposed_for_tests
-
-type nonrec underlying = underlying
-type nonrec t = t [@@deriving bin_io, quickcheck, sexp_grammar, typerep]
-type nonrec comparator_witness = comparator_witness
-
-let arg_type = arg_type
-let comparator = comparator
-let hashable = hashable
-let pp = pp
-let gen_incl = gen_incl
-let gen_uniform_incl = gen_uniform_incl
-let epoch = opaque epoch
-
 module Time_constants = struct
-  let example = of_date_ofday ~zone:utc date Ofday.Ofday_constants.example |> opaque
-  let example_sexp = sexp_of_t example |> opaque
-  let example_string = to_string example |> opaque
-  let fix_example_string = to_string_fix_proto `Utc example |> opaque
-  let example_filename_string = to_filename_string ~zone:utc example |> opaque
-  let example_localized_string = format example "%F %T" ~zone:utc |> opaque
-  let example_formatted = format example "%F %T%z" ~zone:utc |> opaque
-  let zone_for_sexp = get_sexp_zone () |> opaque
+  let opaque = Sys.opaque_identity
+  let date = opaque (Date.create_exn ~y:2013 ~m:Oct ~d:07)
+  let example_ofday = Ofday.create ~hr:13 ~min:29 ~sec:59 ~ms:654 ~us:321 () |> opaque
+  let example = of_date_ofday ~zone:Zone.utc date example_ofday |> opaque
+  let example_formatted = format example "%F %T%z" ~zone:Zone.utc |> opaque
   let epoch_tm = Unix.gmtime 0. |> opaque
-  let index_example = Zone.index nyc example |> opaque
 end
 
 open Time_constants
@@ -614,783 +22,9 @@ open Time_constants
 let pause = pause
 let interruptible_pause = interruptible_pause
 let pause_forever = pause_forever
-let hash = hash
-let%bench "hash" = hash epoch
-let hash_fold_t = hash_fold_t
-let%bench "hash_fold_t" = hash_fold_t hash_state epoch
-
-module Replace_polymorphic_compare = struct
-  open Replace_polymorphic_compare
-
-  let compare = compare
-  let%bench "compare (<)" = compare epoch example
-  let%bench "compare (>)" = compare example epoch
-  let%bench "compare (=)" = compare epoch epoch
-  let equal = equal
-  let%bench "equal" = equal epoch example
-  let min = min
-  let%bench "min" = min epoch example
-  let max = max
-  let%bench "max" = max epoch example
-  let ( = ) = ( = )
-  let%bench "(=)" = epoch = example
-  let ( < ) = ( < )
-  let%bench "(<)" = epoch < example
-  let ( > ) = ( > )
-  let%bench "(>)" = epoch > example
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = epoch <= example
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = epoch >= example
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = epoch <> example
-end
-
-let compare = compare
-let%bench "compare (<)" = compare epoch example
-let%bench "compare (>)" = compare example epoch
-let%bench "compare (=)" = compare epoch epoch
-let ascending = ascending
-let%bench "ascending" = ascending epoch example
-let descending = descending
-let%bench "descending" = descending epoch example
-let equal = equal
-let%bench "equal" = equal epoch example
-let min = min
-let%bench "min" = min epoch example
-let max = max
-let%bench "max" = max epoch example
-let ( = ) = ( = )
-let%bench "(=)" = epoch = example
-let ( < ) = ( < )
-let%bench "(<)" = epoch < example
-let ( > ) = ( > )
-let%bench "(>)" = epoch > example
-let ( <= ) = ( <= )
-let%bench "(<=)" = epoch <= example
-let ( >= ) = ( >= )
-let%bench "(>=)" = epoch >= example
-let ( <> ) = ( <> )
-let%bench "(<>)" = epoch <> example
-let between = between
-let%bench "between" = between epoch ~low:epoch ~high:example
-let clamp = clamp
-let%bench "clamp" = clamp epoch ~min:epoch ~max:example
-let clamp_exn = clamp_exn
-let%bench "clamp_exn" = clamp_exn epoch ~min:epoch ~max:example
-let validate_bound = validate_bound
-let%bench "validate_bound" = validate_bound ~min:(Incl epoch) ~max:(Incl example) epoch
-let validate_lbound = validate_lbound
-let%bench "validate_lbound" = validate_lbound ~min:(Incl epoch) epoch
-let validate_ubound = validate_ubound
-let%bench "validate_ubound" = validate_ubound ~max:(Incl example) epoch
-let robustly_compare = robustly_compare
-let%bench "robustly_compare (<)" = robustly_compare epoch example
-let%bench "robustly_compare (>)" = robustly_compare example epoch
-let%bench "robustly_compare (=)" = robustly_compare epoch epoch
-let ( =. ) = ( =. )
-let%bench "(=.)" = epoch =. example
-let ( <. ) = ( <. )
-let%bench "(<.)" = epoch <. example
-let ( >. ) = ( >. )
-let%bench "(>.)" = epoch >. example
-let ( <=. ) = ( <=. )
-let%bench "(<=.)" = epoch <=. example
-let ( >=. ) = ( >=. )
-let%bench "(>=.)" = epoch >=. example
-let ( <>. ) = ( <>. )
-let%bench "(<>.)" = epoch <>. example
-let next = next
-let%bench "next" = next epoch
-let prev = prev
-let%bench "prev" = prev epoch
-let to_span_since_epoch = to_span_since_epoch
-let%bench "to_span_since_epoch" = to_span_since_epoch epoch
-let of_span_since_epoch = of_span_since_epoch
-let%bench "of_span_since_epoch" = of_span_since_epoch Span.zero
-let now = now
-let%bench "now" = now ()
-let diff = diff
-let%bench "diff" = diff epoch example
-let abs_diff = abs_diff
-let%bench "abs_diff" = abs_diff epoch example
-let sub = sub
-let%bench "sub" = sub example Span.day
-let add = add
-let%bench "add" = add example Span.day
-let is_earlier = is_earlier
-let%bench "is_earlier" = is_earlier epoch ~than:example
-let is_later = is_later
-let%bench "is_later" = is_later epoch ~than:example
-
-(* Basically any function that uses zones (not just these) uses a zone cache too, so we're
-   benchmarking the "hot-cache" cases here. See bench_zone.ml for benchmarks that always
-   reset the cache first. *)
-let of_date_ofday = of_date_ofday
-let%bench "of_date_ofday (est)" = of_date_ofday ~zone:nyc nyc_winter_date noon
-let%bench "of_date_ofday (edt)" = of_date_ofday ~zone:nyc nyc_summer_date noon
-
-let%bench "of_date_ofday (e?t)" =
-  of_date_ofday ~zone:nyc nyc_transition_date nyc_transition_ofday
-;;
-
-let%bench "of_date_ofday (n/a)" = of_date_ofday ~zone:nyc nyc_skip_date nyc_skip_ofday
-let of_date_ofday_precise = of_date_ofday_precise
-
-let%bench "of_date_ofday_precise (est)" =
-  of_date_ofday_precise ~zone:nyc nyc_winter_date noon
-;;
-
-let%bench "of_date_ofday_precise (edt)" =
-  of_date_ofday_precise ~zone:nyc nyc_summer_date noon
-;;
-
-let%bench "of_date_ofday_precise (e?t)" =
-  of_date_ofday_precise ~zone:nyc nyc_transition_date nyc_transition_ofday
-;;
-
-let%bench "of_date_ofday_precise (n/a)" =
-  of_date_ofday_precise ~zone:nyc nyc_skip_date nyc_skip_ofday
-;;
-
-(* These benchmarks use the date cache (see [reset_date_cache]). There are benchmarks
-   that bypass the cache in bench_zone.ml. *)
-let to_date_ofday = to_date_ofday
-let%bench "to_date_ofday (est)" = to_date_ofday ~zone:nyc nyc_winter_time
-let%bench "to_date_ofday (edt)" = to_date_ofday ~zone:nyc nyc_summer_time
-let%bench "to_date_ofday (e?t)" = to_date_ofday ~zone:nyc nyc_transition_time
-
-(* The following three functions build on [to_date_ofday] so have the same caching
-   caveats. *)
-let to_date_ofday_precise = to_date_ofday_precise
-let%bench "to_date_ofday_precise (est)" = to_date_ofday_precise ~zone:nyc nyc_winter_time
-let%bench "to_date_ofday_precise (edt)" = to_date_ofday_precise ~zone:nyc nyc_summer_time
-
-let%bench "to_date_ofday_precise (e?t)" =
-  to_date_ofday_precise ~zone:nyc nyc_transition_time
-;;
-
-let to_date = to_date
-let%bench "to_date (est)" = to_date ~zone:nyc nyc_winter_time
-let%bench "to_date (edt)" = to_date ~zone:nyc nyc_summer_time
-let%bench "to_date (e?t)" = to_date ~zone:nyc nyc_transition_time
-let to_ofday = to_ofday
-let%bench "to_ofday (est)" = to_ofday ~zone:nyc nyc_winter_time
-let%bench "to_ofday (edt)" = to_ofday ~zone:nyc nyc_summer_time
-let%bench "to_ofday (e?t)" = to_ofday ~zone:nyc nyc_transition_time
-let of_date_ofday_zoned = of_date_ofday_zoned
-
-let%bench "of_date_ofday_zoned" =
-  of_date_ofday_zoned date Ofday.Zoned.Ofday_zoned_constants.example
-;;
-
-let to_date_ofday_zoned = to_date_ofday_zoned
-let%bench "to_date_ofday_zoned (est)" = to_date_ofday_zoned nyc_winter_time ~zone:nyc
-let to_ofday_zoned = to_ofday_zoned
-let%bench "to_ofday_zoned (est)" = to_ofday_zoned nyc_winter_time ~zone:nyc
-
-(* This function is only meant for use in benchmarks: slowing it down doesn't matter in
-   itself but seems important to know about for the interpretation of other benchmarks. *)
-let reset_date_cache = reset_date_cache
-let%bench "reset_date_cache" = reset_date_cache ()
-let convert = convert
-let%bench "convert" = convert ~from_tz:utc ~to_tz:utc date Ofday.Ofday_constants.example
-let utc_offset = utc_offset
-let%bench "utc_offset" = utc_offset example ~zone:utc
-let occurrence = occurrence
-
-let%bench "occurrence" =
-  occurrence `First_after_or_at example ~ofday:Ofday.start_of_day ~zone:utc
-;;
-
-let next_multiple = next_multiple
-
-let%bench "next_multiple" =
-  next_multiple ~base:epoch ~after:example ~interval:Span.hour ()
-;;
-
-let prev_multiple = prev_multiple
-
-let%bench "prev_multiple" =
-  prev_multiple ~base:epoch ~before:example ~interval:Span.hour ()
-;;
-
 let of_tm = of_tm
-let%bench "of_tm" = of_tm epoch_tm ~zone:utc
+let%bench "of_tm" = of_tm epoch_tm ~zone:Zone.utc
 let format = format
-let%bench "format" = format example "%F %T%z" ~zone:utc
+let%bench "format" = format example "%F %T%z" ~zone:Zone.utc
 let parse = parse
-let%bench "parse" = parse example_formatted ~fmt:"%F %T%z" ~zone:utc
-let set_sexp_zone = set_sexp_zone
-let%bench "set_sexp_zone" = set_sexp_zone zone_for_sexp
-let get_sexp_zone = get_sexp_zone
-let%bench "get_sexp_zone" = get_sexp_zone ()
-let to_string = to_string
-let%bench "to_string" = to_string example
-let to_string_utc = to_string_utc
-let%bench "to_string_utc" = to_string_utc example
-let of_string = of_string
-let%bench "of_string" = of_string example_string
-let of_string_with_utc_offset = of_string_with_utc_offset
-let%bench "of_string_with_utc_offset" = of_string_with_utc_offset example_string
-let to_filename_string = to_filename_string
-let%bench "to_filename_string" = to_filename_string ~zone:utc example
-let of_filename_string = of_filename_string
-let%bench "of_filename_string" = of_filename_string ~zone:utc example_filename_string
-let to_string_trimmed = to_string_trimmed
-let%bench "to_string_trimmed" = to_string_trimmed ~zone:utc example
-let to_sec_string = to_sec_string
-let%bench "to_sec_string" = to_sec_string ~zone:utc example
-let to_sec_string_with_zone = to_sec_string_with_zone
-let%bench "to_sec_string_with_zone" = to_sec_string_with_zone ~zone:utc example
-let of_localized_string = of_localized_string
-let%bench "of_localized_string" = of_localized_string ~zone:utc example_localized_string
-let of_string_gen = of_string_gen
-let%bench "of_string_gen" = of_string_gen ~if_no_timezone:`Local example_string
-let to_string_fix_proto = to_string_fix_proto
-let%bench "to_string_fix_proto" = to_string_fix_proto `Local example
-let of_string_fix_proto = of_string_fix_proto
-let%bench "of_string_fix_proto" = of_string_fix_proto `Local fix_example_string
-let to_string_abs = to_string_abs
-let%bench "to_string_abs" = to_string_abs ~zone:utc example
-let of_string_abs = of_string_abs
-let%bench "of_string_abs" = of_string_abs example_string
-let to_string_abs_trimmed = to_string_abs_trimmed
-let%bench "to_string_abs_trimmed" = to_string_abs_trimmed ~zone:utc example
-let to_string_abs_parts = to_string_abs_parts
-let%bench "to_string_abs_parts" = to_string_abs_parts ~zone:utc example
-let to_string_iso8601_basic = to_string_iso8601_basic
-let%bench "to_string_iso8601_basic" = to_string_iso8601_basic ~zone:utc example
-let sexp_of_t = sexp_of_t
-let%bench "sexp_of_t" = sexp_of_t example
-let t_of_sexp = t_of_sexp
-let%bench "t_of_sexp" = t_of_sexp example_sexp
-let sexp_of_t_abs = sexp_of_t_abs
-let%bench "sexp_of_t_abs" = sexp_of_t_abs ~zone:utc example
-let t_of_sexp_abs = t_of_sexp_abs
-let%bench "t_of_sexp_abs" = t_of_sexp_abs example_sexp
-
-module Date_and_ofday = struct
-  open Date_and_ofday
-
-  type nonrec t = t
-
-  module Date_and_ofday_constants = struct
-    let rel_epoch = of_absolute epoch ~offset_from_utc:Span.zero |> opaque
-
-    let rel_example =
-      of_absolute Time_constants.example ~offset_from_utc:Span.zero |> opaque
-    ;;
-
-    let nyc_rel_winter_time =
-      of_absolute nyc_winter_time ~offset_from_utc:Span.zero |> opaque
-    ;;
-
-    let nyc_rel_summer_time =
-      of_absolute nyc_summer_time ~offset_from_utc:Span.zero |> opaque
-    ;;
-
-    let nyc_rel_transition_time =
-      of_absolute nyc_transition_time ~offset_from_utc:Span.zero |> opaque
-    ;;
-  end
-
-  open Date_and_ofday_constants
-
-  let to_synthetic_span_since_epoch = to_synthetic_span_since_epoch
-  let%bench "to_synthetic_span_since_epoch" = to_synthetic_span_since_epoch rel_epoch
-  let of_synthetic_span_since_epoch = of_synthetic_span_since_epoch
-  let%bench "of_synthetic_span_since_epoch" = of_synthetic_span_since_epoch Span.zero
-  let of_date_ofday = of_date_ofday
-  let%bench "of_date_ofday" = of_date_ofday date Ofday.Ofday_constants.example
-  let of_absolute = of_absolute
-  let%bench "of_absolute" = of_absolute epoch ~offset_from_utc:Span.zero
-  let to_absolute = to_absolute
-  let%bench "to_absolute" = to_absolute rel_epoch ~offset_from_utc:Span.zero
-  let to_date_ofday = to_date_ofday
-  let%bench "to_date_ofday" = to_date_ofday rel_example
-  let to_date = to_date
-  let%bench "to_date" = to_date rel_example
-  let to_ofday = to_ofday
-  let%bench "to_ofday" = to_ofday rel_example
-end
-
-module Zone = struct
-  open Zone
-  module Map = Map
-  module Set = Set
-  module Table = Table
-  module Hash_set = Hash_set
-  module Hash_queue = Hash_queue
-  module Diff = Diff
-
-  type nonrec t = t [@@deriving bin_io, sexp_grammar]
-  type nonrec comparator_witness = comparator_witness
-
-  let arg_type = arg_type
-  let comparator = comparator
-  let hashable = hashable
-  let pp = pp
-
-  (* skip benchmark for file I/O functions *)
-  let init = init
-  let input_tz_file = input_tz_file
-  let utc = opaque utc
-  let local = opaque local
-  let likely_machine_zones = opaque likely_machine_zones
-
-  module Zone_constants = struct
-    let example = find_exn "America/New_York" |> opaque
-    let utc_sexp = sexp_of_t utc |> opaque
-    let utc_string = to_string utc |> opaque
-    let full_data_sexp_of_utc = Time.Stable.Zone.Full_data.V1.sexp_of_t utc |> opaque
-  end
-
-  open Zone_constants
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare (<)" = compare utc example
-    let%bench "compare (>)" = compare example utc
-    let%bench "compare (=)" = compare utc utc
-    let equal = equal
-    let%bench "equal" = equal utc example
-    let min = min
-    let%bench "min" = min utc example
-    let max = max
-    let%bench "max" = max utc example
-    let ( = ) = ( = )
-    let%bench "(=)" = utc = example
-    let ( < ) = ( < )
-    let%bench "(<)" = utc < example
-    let ( > ) = ( > )
-    let%bench "(>)" = utc > example
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = utc <= example
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = utc >= example
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = utc <> example
-  end
-
-  let compare = compare
-  let%bench "compare (<)" = compare utc example
-  let%bench "compare (>)" = compare example utc
-  let%bench "compare (=)" = compare utc utc
-  let ascending = ascending
-  let%bench "ascending" = ascending utc example
-  let descending = descending
-  let%bench "descending" = descending utc example
-  let equal = equal
-  let%bench "equal" = equal utc example
-  let min = min
-  let%bench "min" = min utc example
-  let max = max
-  let%bench "max" = max utc example
-  let ( = ) = ( = )
-  let%bench "(=)" = utc = example
-  let ( < ) = ( < )
-  let%bench "(<)" = utc < example
-  let ( > ) = ( > )
-  let%bench "(>)" = utc > example
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = utc <= example
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = utc >= example
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = utc <> example
-  let between = between
-  let%bench "between" = between utc ~low:utc ~high:example
-  let clamp = clamp
-  let%bench "clamp" = clamp utc ~min:utc ~max:example
-  let clamp_exn = clamp_exn
-  let%bench "clamp_exn" = clamp_exn utc ~min:utc ~max:utc
-  let validate_bound = validate_bound
-  let%bench "validate_bound" = validate_bound ~min:(Incl utc) ~max:(Incl utc) utc
-  let validate_lbound = validate_lbound
-  let%bench "validate_lbound" = validate_lbound ~min:(Incl utc) utc
-  let validate_ubound = validate_ubound
-  let%bench "validate_ubound" = validate_ubound ~max:(Incl example) utc
-  let hash = hash
-  let%bench "hash" = hash utc
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state utc
-  let name = name
-  let%bench "name" = name utc
-  let original_filename = original_filename
-  let%bench "original_filename" = original_filename utc
-  let of_utc_offset = of_utc_offset
-  let%bench "of_utc_offset" = of_utc_offset ~hours:1
-  let of_utc_offset_explicit_name = of_utc_offset_explicit_name
-
-  let%bench "of_utc_offset_explicit_name" =
-    of_utc_offset_explicit_name ~name:"UTC+1" ~hours:1
-  ;;
-
-  let digest = digest
-  let%bench "digest" = digest utc
-  let find = find
-  let%bench "find" = find "America/New_York"
-  let find_exn = find_exn
-  let%bench "find_exn" = find_exn "America/New_York"
-  let initialized_zones = initialized_zones
-  let%bench "initialized_zones" = initialized_zones ()
-  let abbreviation = abbreviation
-  let%bench "abbreviation (est)" = abbreviation nyc nyc_winter_time
-  let%bench "abbreviation (edt)" = abbreviation nyc nyc_summer_time
-  let%bench "abbreviation (e?t)" = abbreviation nyc nyc_transition_time
-  let date_and_ofday_of_absolute_time = date_and_ofday_of_absolute_time
-
-  let%bench "date_and_ofday_of_absolute_time est" =
-    date_and_ofday_of_absolute_time nyc nyc_winter_time
-  ;;
-
-  let%bench "date_and_ofday_of_absolute_time edt" =
-    date_and_ofday_of_absolute_time nyc nyc_summer_time
-  ;;
-
-  let%bench "date_and_ofday_of_absolute_time e?t" =
-    date_and_ofday_of_absolute_time nyc nyc_transition_time
-  ;;
-
-  let absolute_time_of_date_and_ofday = absolute_time_of_date_and_ofday
-
-  let%bench "absolute_time_of_date_and_ofday est" =
-    absolute_time_of_date_and_ofday
-      nyc
-      Date_and_ofday.Date_and_ofday_constants.nyc_rel_winter_time
-  ;;
-
-  let%bench "absolute_time_of_date_and_ofday edt" =
-    absolute_time_of_date_and_ofday
-      nyc
-      Date_and_ofday.Date_and_ofday_constants.nyc_rel_summer_time
-  ;;
-
-  let%bench "absolute_time_of_date_and_ofday e?t" =
-    absolute_time_of_date_and_ofday
-      nyc
-      Date_and_ofday.Date_and_ofday_constants.nyc_rel_transition_time
-  ;;
-
-  let prev_clock_shift = prev_clock_shift
-  let%bench "prev_clock_shift (est)" = prev_clock_shift nyc ~at_or_before:nyc_winter_time
-  let%bench "prev_clock_shift (edt)" = prev_clock_shift nyc ~at_or_before:nyc_summer_time
-
-  let%bench "prev_clock_shift (e?t)" =
-    prev_clock_shift nyc ~at_or_before:nyc_transition_time
-  ;;
-
-  let next_clock_shift = next_clock_shift
-
-  let%bench "next_clock_shift (est)" =
-    next_clock_shift nyc ~strictly_after:nyc_winter_time
-  ;;
-
-  let%bench "next_clock_shift (edt)" =
-    next_clock_shift nyc ~strictly_after:nyc_summer_time
-  ;;
-
-  let%bench "next_clock_shift (e?t)" =
-    next_clock_shift nyc ~strictly_after:nyc_transition_time
-  ;;
-
-  (* This function is only meant for use in benchmarks: slowing it down doesn't matter in
-     itself but seems important to know about for the interpretation of other benchmarks.
-  *)
-  let reset_transition_cache = reset_transition_cache
-  let%bench "reset_transition_cache" = reset_transition_cache nyc
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t" = sexp_of_t utc
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp" = t_of_sexp utc_sexp
-  let to_string = to_string
-  let%bench "to_string" = to_string utc
-  let of_string = of_string
-  let%bench "of_string" = of_string utc_string
-
-  module Index = Index
-
-  let index = index
-  let%bench "index" = index nyc Time_constants.example
-  let index_of_date_and_ofday = index_of_date_and_ofday
-
-  let%bench "index_of_date_and_ofday" =
-    index_of_date_and_ofday nyc Date_and_ofday.Date_and_ofday_constants.rel_example
-  ;;
-
-  let index_abbreviation_exn = index_abbreviation_exn
-  let%bench "index_abbreviation_exn" = index_abbreviation_exn nyc index_example
-  let index_offset_from_utc_exn = index_offset_from_utc_exn
-  let%bench "index_offset_from_utc_exn" = index_offset_from_utc_exn nyc index_example
-  let index_has_prev_clock_shift = index_has_prev_clock_shift
-  let%bench "index_has_prev_clock_shift" = index_has_prev_clock_shift nyc index_example
-  let index_prev_clock_shift_time_exn = index_prev_clock_shift_time_exn
-
-  let%bench "index_prev_clock_shift_time_exn" =
-    index_prev_clock_shift_time_exn nyc index_example
-  ;;
-
-  let index_prev_clock_shift_amount_exn = index_prev_clock_shift_amount_exn
-
-  let%bench "index_prev_clock_shift_amount_exn" =
-    index_prev_clock_shift_amount_exn nyc index_example
-  ;;
-
-  let index_has_next_clock_shift = index_has_next_clock_shift
-  let%bench "index_has_next_clock_shift" = index_has_next_clock_shift nyc index_example
-  let index_next_clock_shift_time_exn = index_next_clock_shift_time_exn
-
-  let%bench "index_next_clock_shift_time_exn" =
-    index_next_clock_shift_time_exn nyc index_example
-  ;;
-
-  let index_next_clock_shift_amount_exn = index_next_clock_shift_amount_exn
-
-  let%bench "index_next_clock_shift_amount_exn" =
-    index_next_clock_shift_amount_exn nyc index_example
-  ;;
-end
-
-module Stable = struct
-  module V1 = struct
-    open Stable.V1
-    module Diff = Diff
-    module Map = Map
-    module Set = Set
-
-    type nonrec t = t [@@deriving bin_io, hash, typerep, sexp_grammar, stable_witness]
-    type nonrec comparator_witness = comparator_witness
-
-    let comparator = comparator
-    let compare = compare
-    let%bench "compare (<)" = compare epoch example
-    let%bench "compare (>)" = compare example epoch
-    let%bench "compare (=)" = compare epoch epoch
-    let sexp_of_t = sexp_of_t
-    let%bench "sexp_of_t" = sexp_of_t example
-    let t_of_sexp = t_of_sexp
-    let%bench "t_of_sexp" = t_of_sexp example_sexp
-  end
-
-  module With_utc_sexp = struct
-    module V1 = struct
-      open Stable.With_utc_sexp.V1
-      module Map = Map
-      module Set = Set
-
-      type nonrec t = t [@@deriving bin_io]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare (<)" = compare epoch example
-      let%bench "compare (>)" = compare example epoch
-      let%bench "compare (=)" = compare epoch epoch
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t example
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp example_sexp
-    end
-
-    module V2 = struct
-      open Stable.With_utc_sexp.V2
-      module Map = Map
-      module Set = Set
-
-      type nonrec t = t [@@deriving bin_io, hash]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare (<)" = compare epoch example
-      let%bench "compare (>)" = compare example epoch
-      let%bench "compare (=)" = compare epoch epoch
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t example
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp example_sexp
-    end
-  end
-
-  module With_t_of_sexp_abs = struct
-    module V1 = struct
-      open Stable.With_t_of_sexp_abs.V1
-
-      type nonrec t = t [@@deriving bin_io]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare (<)" = compare epoch example
-      let%bench "compare (>)" = compare example epoch
-      let%bench "compare (=)" = compare epoch epoch
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t example
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp example_sexp
-    end
-  end
-
-  module Span = struct
-    module V1 = struct
-      open Span
-      open Time.Stable.Span.V1
-      open Span_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, stable_witness]
-
-      let compare = compare
-      let%bench "compare (<)" = compare zero day
-      let%bench "compare (>)" = compare day zero
-      let%bench "compare (=)" = compare zero zero
-      let equal = equal
-      let%bench "equal" = equal zero zero
-      let hash = hash
-      let%bench "hash" = hash zero
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t day
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp day_sexp
-    end
-
-    module V2 = struct
-      open Span
-      open Time.Stable.Span.V2
-      open Span_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, sexp_grammar, stable_witness]
-
-      let compare = compare
-      let%bench "compare (<)" = compare zero day
-      let%bench "compare (>)" = compare day zero
-      let%bench "compare (=)" = compare zero zero
-      let equal = equal
-      let%bench "equal" = equal zero zero
-      let hash = hash
-      let%bench "hash" = hash zero
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t day
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp day_sexp
-    end
-
-    module V3 = struct
-      open Span
-      open Time.Stable.Span.V3
-      open Span_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, typerep, sexp_grammar, stable_witness]
-
-      let compare = compare
-      let%bench "compare (<)" = compare zero day
-      let%bench "compare (>)" = compare day zero
-      let%bench "compare (=)" = compare zero zero
-      let equal = equal
-      let%bench "equal" = equal zero zero
-      let hash = hash
-      let%bench "hash" = hash zero
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t day
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp day_sexp
-    end
-  end
-
-  module Ofday = struct
-    module V1 = struct
-      open Ofday
-      open Time.Stable.Ofday.V1
-      open Ofday_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, stable_witness, sexp_grammar]
-
-      let compare = compare
-      let%bench "compare (<)" = compare start_of_day example
-      let%bench "compare (>)" = compare example start_of_day
-      let%bench "compare (=)" = compare start_of_day start_of_day
-      let hash = hash
-      let%bench "hash" = hash start_of_day
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state start_of_day
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t example
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp example_sexp
-    end
-
-    module Zoned = struct
-      module V1 = struct
-        open Ofday.Zoned
-        open Time.Stable.Ofday.Zoned.V1
-        open Ofday_zoned_constants
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-
-        let compare = compare
-        let%bench "compare (<)" = compare zero_utc example
-        let%bench "compare (>)" = compare example zero_utc
-        let%bench "compare (=)" = compare zero_utc zero_utc
-        let hash = hash
-        let%bench "hash" = hash zero_utc
-        let hash_fold_t = hash_fold_t
-        let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t" = sexp_of_t example
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp" = t_of_sexp example_sexp
-      end
-    end
-  end
-
-  module Zone = struct
-    module V1 = struct
-      open Zone
-      open Time.Stable.Zone.V1
-      open Zone_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, sexp_grammar, stable_witness]
-
-      let compare = compare
-      let%bench "compare" = compare utc utc
-      let hash = hash
-      let%bench "hash" = hash utc
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state utc
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t utc
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp utc_sexp
-    end
-
-    module Full_data = struct
-      module V1 = struct
-        open Zone
-        open Time.Stable.Zone.Full_data.V1
-        open Zone_constants
-
-        type nonrec t = t [@@deriving bin_io]
-
-        let compare = compare
-        let%bench "compare" = compare utc utc
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t" = sexp_of_t utc
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp" = t_of_sexp full_data_sexp_of_utc
-      end
-    end
-  end
-end
+let%bench "parse" = parse example_formatted ~fmt:"%F %T%z" ~zone:Zone.utc
diff --git a/time_float_unix/bench/dune b/time_float_unix/bench/dune
index cb7b6ca..aaf46f2 100644
--- a/time_float_unix/bench/dune
+++ b/time_float_unix/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name bench_time_unix)
- (libraries core time_ns_unix)
+ (libraries core core_unix time_float_unix time_ns_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_float_unix/src/dune b/time_float_unix/src/dune
index d70a6b8..62c0ef9 100644
--- a/time_float_unix/src/dune
+++ b/time_float_unix/src/dune
@@ -1,6 +1,7 @@
 (library
  (name time_float_unix)
  (public_name core_unix.time_float_unix)
- (libraries core core_unix timezone)
+ (libraries core core_unix ppx_diff.diffable sexplib
+   ppx_stable_witness.stable_witness)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_float_unix/src/time_float_unix.ml b/time_float_unix/src/time_float_unix.ml
index e329caf..82a3c3e 100644
--- a/time_float_unix/src/time_float_unix.ml
+++ b/time_float_unix/src/time_float_unix.ml
@@ -1,200 +1,66 @@
 open! Core
 open! Import
-module Time = Core.Time_float
-
-include (
-  Time :
-    (module type of struct
-      include Time
-    end
-    with module Map := Time.Map
-    with module Set := Time.Set
-   (* We disable deprecations because we need to elide deprecated
-                          submodules. *)
-   [@ocaml.warning "-3"]))
-
-module T = Time_functor.Make (Time) (Time)
-include Diffable.Atomic.Make (T)
-
-(* Previous versions rendered hash-based containers using float serialization rather than
-   time serialization, so when reading hash-based containers in we accept either
-   serialization. *)
-include Hashable.Make_binable (struct
-  type t = Time.t [@@deriving bin_io, compare, hash]
-
-  let sexp_of_t = T.sexp_of_t
-
-  let t_of_sexp sexp =
-    match Float.t_of_sexp sexp with
-    | float -> Time.of_span_since_epoch (Time.Span.of_sec float)
-    | exception _ -> T.t_of_sexp sexp
-  ;;
-end)
-
-module Span = struct
-  include Time.Span
-
-  let arg_type = T.Span.arg_type
-end
-
-module Ofday = struct
-  include Time.Ofday
-  module Zoned = T.Ofday.Zoned
-
-  let now = T.Ofday.now
-  let arg_type = T.Ofday.arg_type
-end
-
-module Zone = struct
-  include Time.Zone
-
-  include (
-    T.Zone :
-      module type of struct
-        include T.Zone
-      end
-      with module Index := T.Zone.Index
-      with type t := T.Zone.t)
-end
-
-module Stable = struct
-  module V1 = struct
-    (* There is no simple, pristine implementation of "stable time", and in fact
-       [Time.Stable.V1] has always called out to "unstable" string conversions.
-       For a complicated "stable" story like this, we rely on comprehensive tests
-       of stability; see [lib/core/test/src/test_time.ml]. *)
-    include T
-    include Diffable.Atomic.Make (T)
-
-    let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
-
-    module Map = struct
-      include Map
-
-      let stable_witness _ = Stable_witness.assert_stable
-    end
-
-    module Set = struct
-      include Set
-
-      let stable_witness = Stable_witness.assert_stable
-    end
-  end
-
-  module With_utc_sexp = struct
-    module V1 = struct
-      module C = struct
-        include (
-          V1 : module type of V1 with module Map := V1.Map and module Set := V1.Set)
-
-        let sexp_of_t t = sexp_of_t_abs t ~zone:Zone.utc
-      end
-
-      include C
-      module Map = Map.Make_binable_using_comparator (C)
-      module Set = Set.Make_binable_using_comparator (C)
-    end
-
-    module V2 = struct
-      module C = struct
-        include Time.Stable.With_utc_sexp.V2
-
-        type comparator_witness = T.comparator_witness
-
-        let comparator = T.comparator
-      end
-
-      include C
-      include Comparable.Stable.V1.Make (C)
-    end
-  end
-
-  module With_t_of_sexp_abs = struct
-    module V1 = struct
-      include (V1 : module type of V1 with module Map := V1.Map and module Set := V1.Set)
-
-      let t_of_sexp = t_of_sexp_abs
-    end
-  end
-
-  module Span = Time.Stable.Span
-
-  module Ofday = struct
-    include Time.Stable.Ofday
-
-    module Zoned = struct
-      module V1 = struct
-        open T.Ofday.Zoned
-
-        type nonrec t = t [@@deriving hash]
-
-        let compare = With_nonchronological_compare.compare
-
-        module Bin_repr = struct
-          type t =
-            { ofday : Time.Stable.Ofday.V1.t
-            ; zone : Timezone.Stable.V1.t
-            }
-          [@@deriving bin_io, stable_witness]
-        end
-
-        let to_binable t : Bin_repr.t = { ofday = ofday t; zone = zone t }
-        let of_binable (repr : Bin_repr.t) = create repr.ofday repr.zone
-
-        include
-          Binable.Stable.Of_binable.V1 [@alert "-legacy"]
-            (Bin_repr)
-            (struct
-              type nonrec t = t
-
-              let to_binable = to_binable
-              let of_binable = of_binable
-            end)
-
-        let stable_witness =
-          Stable_witness.of_serializable
-            [%stable_witness: Bin_repr.t]
-            of_binable
-            to_binable
-        ;;
-
-        let%expect_test _ =
-          print_endline [%bin_digest: t];
-          [%expect {| 490573c3397b4fe37e8ade0086fb4759 |}]
-        ;;
-
-        type sexp_repr = Time.Stable.Ofday.V1.t * Timezone.Stable.V1.t [@@deriving sexp]
-
-        let sexp_of_t t = [%sexp_of: sexp_repr] (ofday t, zone t)
-
-        let t_of_sexp sexp =
-          let ofday, zone = [%of_sexp: sexp_repr] sexp in
-          create ofday zone
-        ;;
-      end
-    end
-  end
-
-  module Zone = Timezone.Stable
-end
-
-include (
-  T :
-    module type of struct
-      include T
-    end
-    with module Table := T.Table
-    with module Hash_set := T.Hash_set
-    with module Hash_queue := T.Hash_queue
-    with module Span := T.Span
-    with module Ofday := T.Ofday
-    with module Replace_polymorphic_compare := T.Replace_polymorphic_compare
-    with module Date_and_ofday := T.Date_and_ofday
-    with module Zone := T.Zone
-    with type underlying := T.underlying
-    with type t := T.t
-    with type comparator_witness := T.comparator_witness)
-
-let to_string = T.to_string
-let of_string = T.of_string
-let of_string_gen = T.of_string_gen
+include Time_float
+
+let of_tm tm ~zone =
+  (* Explicitly ignoring isdst, wday, yday (they are redundant with the other fields
+       and the [zone] argument) *)
+  let { Unix.tm_year
+      ; tm_mon
+      ; tm_mday
+      ; tm_hour
+      ; tm_min
+      ; tm_sec
+      ; tm_isdst = _
+      ; tm_wday = _
+      ; tm_yday = _
+      }
+    =
+    tm
+  in
+  let date =
+    Date.create_exn ~y:(tm_year + 1900) ~m:(Month.of_int_exn (tm_mon + 1)) ~d:tm_mday
+  in
+  let ofday = Ofday.create ~hr:tm_hour ~min:tm_min ~sec:tm_sec () in
+  of_date_ofday ~zone date ofday
+;;
+
+let format t s ~zone =
+  let epoch_time =
+    Zone.date_and_ofday_of_absolute_time zone t
+    |> Date_and_ofday.to_synthetic_span_since_epoch
+    |> Span.to_sec
+  in
+  Unix.strftime (Unix.gmtime epoch_time) s
+;;
+
+let parse ?allow_trailing_input s ~fmt ~zone =
+  Unix.strptime ?allow_trailing_input ~fmt s |> of_tm ~zone
+;;
+
+let pause_for span =
+  let time_remaining =
+    (* If too large a float is passed in (Span.max_value for instance) then
+         nanosleep will return immediately, leading to an infinite and expensive
+         select loop.  This is handled by pausing for no longer than 100 days.
+    *)
+    let span = Span.min span (Span.scale Span.day 100.) in
+    Unix.nanosleep (Span.to_sec span)
+  in
+  if Float.( > ) time_remaining 0.0 then `Remaining (Span.of_sec time_remaining) else `Ok
+;;
+
+(** Pause and don't allow events to interrupt. *)
+let rec pause span =
+  match pause_for span with
+  | `Remaining span -> pause span
+  | `Ok -> ()
+;;
+
+(** Pause but allow events to interrupt. *)
+let interruptible_pause = pause_for
+
+let rec pause_forever () =
+  pause (Span.of_day 1.0);
+  pause_forever ()
+;;
diff --git a/time_float_unix/src/time_float_unix.mli b/time_float_unix/src/time_float_unix.mli
index 80e3871..a618c04 100644
--- a/time_float_unix/src/time_float_unix.mli
+++ b/time_float_unix/src/time_float_unix.mli
@@ -1,108 +1,70 @@
 open! Core
 open! Import
-module Time := Core.Time_float
-include Time_functor_intf.S with module Time0 := Time and module Time := Time
-include Diffable.S_atomic with type t := t
 
-module Stable : sig
-  module V1 : sig
-    type nonrec t = t [@@deriving hash, typerep, sexp_grammar]
-    type nonrec comparator_witness = comparator_witness
-
-    include
-      Stable_comparable.With_stable_witness.V1
-        with type t := t
-        with type comparator_witness := comparator_witness
-
-    include Diffable.S_atomic with type t := t
-  end
-
-  (** Provides a sexp representation that is independent of the time zone of the machine
-      writing it.
-      [V1.t_of_sexp] will be generous in what sexps it accepts, while [V2.t_of_sexp]
-      should not be expected to parse sexps not generated by [V2.sexp_of_t]
-  *)
-  module With_utc_sexp : sig
-    module V1 :
-      Stable_comparable.V1
-        with type t = t
-        with type comparator_witness = comparator_witness
-
-    module V2 : sig
-      type nonrec t = t [@@deriving hash]
-      type nonrec comparator_witness = comparator_witness
-
-      include
-        Stable_comparable.V1
-          with type t := t
-          with type comparator_witness := comparator_witness
-    end
-  end
-
-  (** Provides a sexp representation where all sexps must include a timezone (in contrast
-      to [V1] above, which will assume local timezone if it's not specified). When
-      serializing, it uses the local timezone.  Concretely, this is just [V1] but
-      [t_of_sexp] is replaced with [t_of_sexp_abs]. *)
-  module With_t_of_sexp_abs : sig
-    module V1 : sig
-      type nonrec t = t
-      type nonrec comparator_witness = comparator_witness
-
-      include Stable with type t := t with type comparator_witness := comparator_witness
-    end
-  end
-
-  module Span : sig
-    module V1 : sig
-      type t = Time.Stable.Span.V1.t [@@deriving hash, equal]
-
-      include Stable_without_comparator_with_witness with type t := t
-      include Diffable.S_atomic with type t := t
-    end
-
-    module V2 : sig
-      type t = Time.Stable.Span.V2.t [@@deriving hash, equal, sexp_grammar]
-
-      include Stable_without_comparator_with_witness with type t := t
-      include Diffable.S_atomic with type t := t
-    end
-
-    module V3 : sig
-      type t = Time.Stable.Span.V3.t [@@deriving hash, typerep, equal, sexp_grammar]
-
-      include Stable_without_comparator_with_witness with type t := t
-      include Diffable.S_atomic with type t := t
-    end
-  end
-
-  module Ofday : sig
-    module V1 : sig
-      type t = Time.Stable.Ofday.V1.t [@@deriving hash, sexp_grammar]
-
-      include Stable_without_comparator_with_witness with type t := t
-      include Diffable.S_atomic with type t := t
-    end
-
-    module Zoned : sig
-      module V1 : sig
-        (** This uses [With_nonchronological_compare.compare]. *)
-        type t = Ofday.Zoned.t [@@deriving hash]
-
-        include Stable_without_comparator_with_witness with type t := t
-      end
-    end
-  end
-
-  module Zone : sig
-    module V1 : sig
-      type t = Timezone.Stable.V1.t [@@deriving hash, sexp_grammar]
-
-      include Stable_without_comparator_with_witness with type t := t
-      include Diffable.S_atomic with type t := t
-    end
-
-    module Full_data : sig
-      module V1 : Stable_without_comparator with type t = Time.Stable.Zone.Full_data.V1.t
-    end
-  end
+include module type of struct
+  include Time_float
 end
+
+(** [of_tm] converts a [Unix.tm] (mirroring a [struct tm] from the C stdlib) into a
+    [Time.t].  Note that the [tm_wday], [tm_yday], and [tm_isdst] fields are ignored. *)
+val of_tm : Unix.tm -> zone:Zone.t -> t
+
+(** [pause span] sleeps for span time. *)
+val pause : Span.t -> unit
+
+(** [interruptible_pause span] sleeps for span time unless interrupted (e.g. by delivery
+    of a signal), in which case the remaining unslept portion of time is returned. *)
+val interruptible_pause : Span.t -> [ `Ok | `Remaining of Span.t ]
+
+(** [pause_forever] sleeps indefinitely. *)
+val pause_forever : unit -> never_returns
+
+(** [format t fmt] formats the given time according to fmt, which follows the formatting
+    rules given in 'man strftime'.  The time is output in the given timezone. Here are
+    some commonly used control codes:
+
+    {v
+      %Y - year (4 digits)
+      %y - year (2 digits)
+      %m - month
+      %d - day
+      %H - hour
+      %M - minute
+      %S - second
+    v}
+
+    a common choice would be: %Y-%m-%d %H:%M:%S
+
+    Although %Z and %z are interpreted as format strings, neither are correct in the
+    current implementation. %Z always refers to the local machine timezone, and does not
+    correctly detect whether DST is active. The effective local timezone can be
+    controlled by setting the "TZ" environment variable before calling [format]. %z
+    behaves unreliably and should be avoided.
+
+    Not all strftime control codes are standard; the supported subset will depend on the
+    C libraries linked into a given executable.
+*)
+val format : t -> string -> zone:Zone.t -> string
+
+(** [parse string ~fmt ~zone] parses [string], according to [fmt], which follows the
+    formatting rules given in 'man strptime'.  The time is assumed to be in the given
+    timezone.
+
+    {v
+      %Y - year (4 digits)
+      %y - year (2 digits)
+      %m - month
+      %d - day
+      %H - hour
+      %M - minute
+      %S - second
+    v}
+
+    Raise if [allow_trailing_input] is false and [fmt] does not consume all of the
+    input. *)
+val parse
+  :  ?allow_trailing_input:bool (** default = false *)
+  -> string
+  -> fmt:string
+  -> zone:Zone.t
+  -> t
diff --git a/time_float_unix/src/time_functor.ml b/time_float_unix/src/time_functor.ml
deleted file mode 100644
index 00050b3..0000000
--- a/time_float_unix/src/time_functor.ml
+++ /dev/null
@@ -1,372 +0,0 @@
-(**
-
-   Outside of Core Time appears to be a single module with a number of submodules:
-
-   - Time
-   - Span
-   - Ofday
-   - Zone
-
-   The reality under the covers isn't as simple for a three reasons:
-
-   - We want as much Time functionality available to Core as possible, and Core modules
-     shouldn't rely on Unix functions.  Some functions in Time require Unix, which creates
-     one split.
-
-   - We want some functionality to be functorized so that code can be shared
-     between Time and Time_ns.
-
-   - Time has internal circular dependencies.  For instance, Ofday.now relies on
-     Time.now, but Time also wants to expose Time.to_date_ofday, which relies on Ofday.
-     We use a stack of modules to break the cycle.
-
-   This leads to the following modules within Core:
-
-   Core.Span  - the core type of span
-   Core.Ofday - the core type of ofday, which is really a constrained span
-   Core.Date  - the core type of date
-   Core.Zone  - the base functor for creating a Zone type
-   Core.Time_float0 - contains the base Time.t type and lays out the basic
-   relationship between Time, Span, Ofday, and Zone
-   Core.Time_float  - ties Time, Span, Ofday, Zone, and Date together and provides
-   the higher level functions for them that don't rely on Unix
-   Core.Time    - re-exposes Time_float
-
-   Core.Zone_cache   - implements a caching layer between the Unix filesystem and Zones
-   Core.Core_date    - adds the Unix dependent functions to Date
-   Core.Core_time    - adds the Unix dependent functions to Time
-
-   Core          - renames the Core_{base} modules to {base} for ease of access in
-   modules outside of Core
-*)
-
-open! Core
-open! Import
-open! Int.Replace_polymorphic_compare
-include Time_functor_intf
-
-module Make
-  (Time0 : Time_float.S_kernel_without_zone)
-  (Time : Time_float.S_kernel with module Time := Time0) =
-struct
-  module Span = struct
-    include Time.Span
-
-    let arg_type = Core.Command.Arg_type.create of_string
-  end
-
-  module Zone = struct
-    include Time.Zone
-    include (Timezone : Timezone.Extend_zone with type t := t)
-
-    let arg_type = Core.Command.Arg_type.create of_string
-  end
-
-  module Ofday = struct
-    include Time.Ofday
-
-    let arg_type = Core.Command.Arg_type.create of_string
-    let now ~zone = Time.to_ofday ~zone (Time.now ())
-
-    module Zoned = struct
-      type t =
-        { ofday : Time.Ofday.t
-        ; zone : Zone.t
-        }
-      [@@deriving bin_io, fields ~getters, compare, equal, hash]
-
-      type sexp_repr = Time.Ofday.t * Zone.t [@@deriving sexp]
-
-      let sexp_of_t t = [%sexp_of: sexp_repr] (t.ofday, t.zone)
-
-      let t_of_sexp sexp =
-        let ofday, zone = [%of_sexp: sexp_repr] sexp in
-        { ofday; zone }
-      ;;
-
-      let to_time t date = Time.of_date_ofday ~zone:(zone t) date (ofday t)
-      let create ofday zone = { ofday; zone }
-      let create_local ofday = create ofday (Lazy.force Zone.local)
-
-      let of_string string : t =
-        match String.split string ~on:' ' with
-        | [ ofday; zone ] ->
-          { ofday = Time.Ofday.of_string ofday; zone = Zone.of_string zone }
-        | _ -> failwithf "Ofday.Zoned.of_string %s" string ()
-      ;;
-
-      let to_string (t : t) : string =
-        String.concat [ Time.Ofday.to_string t.ofday; " "; Zone.to_string t.zone ]
-      ;;
-
-      let to_string_trimmed (t : t) : string =
-        String.concat [ Time.Ofday.to_string_trimmed t.ofday; " "; Zone.to_string t.zone ]
-      ;;
-
-      let arg_type = Core.Command.Arg_type.create of_string
-
-      module With_nonchronological_compare = struct
-        type nonrec t = t [@@deriving bin_io, compare, equal, sexp, hash]
-      end
-
-      include Pretty_printer.Register (struct
-        type nonrec t = t
-
-        let to_string = to_string
-        let module_name = "Time_float_unix.Ofday.Zoned"
-      end)
-    end
-  end
-
-  include (
-    Time :
-      module type of Time
-        with module Zone := Time.Zone
-         and module Ofday := Time.Ofday
-         and module Span := Time.Span)
-
-  let of_tm tm ~zone =
-    (* Explicitly ignoring isdst, wday, yday (they are redundant with the other fields
-       and the [zone] argument) *)
-    let { Unix.tm_year
-        ; tm_mon
-        ; tm_mday
-        ; tm_hour
-        ; tm_min
-        ; tm_sec
-        ; tm_isdst = _
-        ; tm_wday = _
-        ; tm_yday = _
-        }
-      =
-      tm
-    in
-    let date =
-      Date.create_exn ~y:(tm_year + 1900) ~m:(Month.of_int_exn (tm_mon + 1)) ~d:tm_mday
-    in
-    let ofday = Ofday.create ~hr:tm_hour ~min:tm_min ~sec:tm_sec () in
-    of_date_ofday ~zone date ofday
-  ;;
-
-  let of_date_ofday_zoned date ofday_zoned = Ofday.Zoned.to_time ofday_zoned date
-
-  let to_date_ofday_zoned t ~zone =
-    let date, ofday = to_date_ofday t ~zone in
-    date, Ofday.Zoned.create ofday zone
-  ;;
-
-  let to_ofday_zoned t ~zone =
-    let ofday = to_ofday t ~zone in
-    Ofday.Zoned.create ofday zone
-  ;;
-
-  let of_string_fix_proto utc str =
-    try
-      let expect_length = 21 in
-      (* = 8 + 1 + 12 *)
-      let expect_dash = 8 in
-      if Char.( <> ) str.[expect_dash] '-'
-      then failwithf "no dash in position %d" expect_dash ();
-      let zone =
-        match utc with
-        | `Utc -> Zone.utc
-        | `Local -> Lazy.force Zone.local
-      in
-      if Int.( > ) (String.length str) expect_length then failwithf "input too long" ();
-      of_date_ofday
-        ~zone
-        (Date.of_string_iso8601_basic str ~pos:0)
-        (Ofday.of_string_iso8601_extended str ~pos:(expect_dash + 1))
-    with
-    | exn -> invalid_argf "Time.of_string_fix_proto %s: %s" str (Exn.to_string exn) ()
-  ;;
-
-  let to_string_fix_proto utc t =
-    let zone =
-      match utc with
-      | `Utc -> Zone.utc
-      | `Local -> Lazy.force Zone.local
-    in
-    let date, sec = to_date_ofday t ~zone in
-    Date.to_string_iso8601_basic date ^ "-" ^ Ofday.to_millisecond_string sec
-  ;;
-
-  let format t s ~zone =
-    let epoch_time =
-      Zone.date_and_ofday_of_absolute_time zone t
-      |> Date_and_ofday.to_synthetic_span_since_epoch
-      |> Span.to_sec
-    in
-    Unix.strftime (Unix.gmtime epoch_time) s
-  ;;
-
-  let parse ?allow_trailing_input s ~fmt ~zone =
-    Unix.strptime ?allow_trailing_input ~fmt s |> of_tm ~zone
-  ;;
-
-  let pause_for span =
-    let time_remaining =
-      (* If too large a float is passed in (Span.max_value for instance) then
-         nanosleep will return immediately, leading to an infinite and expensive
-         select loop.  This is handled by pausing for no longer than 100 days.
-      *)
-      let span = Span.min span (Span.scale Span.day 100.) in
-      Unix.nanosleep (Span.to_sec span)
-    in
-    if Float.( > ) time_remaining 0.0
-    then `Remaining (Span.of_sec time_remaining)
-    else `Ok
-  ;;
-
-  (** Pause and don't allow events to interrupt. *)
-  let rec pause span =
-    match pause_for span with
-    | `Remaining span -> pause span
-    | `Ok -> ()
-  ;;
-
-  (** Pause but allow events to interrupt. *)
-  let interruptible_pause = pause_for
-
-  let rec pause_forever () =
-    pause (Span.of_day 1.0);
-    pause_forever ()
-  ;;
-
-  let to_string t = to_string_abs t ~zone:(Lazy.force Zone.local)
-
-  let ensure_colon_in_offset offset =
-    if Char.( = ) offset.[1] ':' || Char.( = ) offset.[2] ':'
-    then offset
-    else (
-      let offset_length = String.length offset in
-      if Int.( < ) offset_length 3 || Int.( > ) offset_length 4
-      then failwithf "invalid offset %s" offset ()
-      else
-        String.concat
-          [ String.slice offset 0 (offset_length - 2)
-          ; ":"
-          ; String.slice offset (offset_length - 2) offset_length
-          ])
-  ;;
-
-  exception Time_string_not_absolute of string [@@deriving sexp]
-
-  let of_string_gen ~if_no_timezone s =
-    let default_zone () =
-      match if_no_timezone with
-      | `Fail -> raise (Time_string_not_absolute s)
-      | `Local -> Lazy.force Zone.local
-      | `Use_this_one zone -> zone
-    in
-    of_string_gen ~default_zone ~find_zone:Zone.find_exn s
-  ;;
-
-  let of_string_abs s = of_string_gen ~if_no_timezone:`Fail s
-  let of_string s = of_string_gen ~if_no_timezone:`Local s
-  let arg_type = Core.Command.Arg_type.create of_string_abs
-
-  include Pretty_printer.Register (struct
-    type nonrec t = t
-
-    let to_string = to_string
-    let module_name = "Time_float_unix"
-  end)
-
-  let sexp_zone = ref Zone.local
-  let get_sexp_zone () = Lazy.force !sexp_zone
-  let set_sexp_zone zone = sexp_zone := lazy zone
-
-  let t_of_sexp_gen ~if_no_timezone sexp =
-    try
-      match sexp with
-      | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday; Sexp.Atom tz ] ->
-        of_date_ofday
-          ~zone:(Zone.find_exn tz)
-          (Date.of_string date)
-          (Ofday.of_string ofday)
-      (* This is actually where the output of [sexp_of_t] is handled, since that's e.g.
-         (2015-07-06 09:09:44.787988+01:00). *)
-      | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday_and_possibly_zone ] ->
-        of_string_gen ~if_no_timezone (date ^ " " ^ ofday_and_possibly_zone)
-      | Sexp.Atom datetime -> of_string_gen ~if_no_timezone datetime
-      | _ -> of_sexp_error "Time.t_of_sexp" sexp
-    with
-    | Of_sexp_error _ as e -> raise e
-    | e -> of_sexp_error (sprintf "Time.t_of_sexp: %s" (Exn.to_string e)) sexp
-  ;;
-
-  let t_of_sexp sexp =
-    t_of_sexp_gen sexp ~if_no_timezone:(`Use_this_one (Lazy.force !sexp_zone))
-  ;;
-
-  let t_sexp_grammar : t Sexplib.Sexp_grammar.t =
-    { untyped =
-        Union
-          [ String
-          ; List (Cons (String, Cons (String, Empty)))
-          ; List (Cons (String, Cons (String, Cons (String, Empty))))
-          ]
-    }
-  ;;
-
-  let t_of_sexp_abs sexp = t_of_sexp_gen sexp ~if_no_timezone:`Fail
-
-  let sexp_of_t_abs t ~zone =
-    Sexp.List (List.map (Time.to_string_abs_parts ~zone t) ~f:(fun s -> Sexp.Atom s))
-  ;;
-
-  let sexp_of_t t = sexp_of_t_abs ~zone:(Lazy.force !sexp_zone) t
-
-  module type C =
-    Comparable.Map_and_set_binable
-      with type t := t
-       and type comparator_witness := comparator_witness
-
-  let make_comparable ?(sexp_of_t = sexp_of_t) ?(t_of_sexp = t_of_sexp) () : (module C) =
-    (module struct
-      module C = struct
-        type nonrec t = t [@@deriving bin_io]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let sexp_of_t = sexp_of_t
-        let t_of_sexp = t_of_sexp
-      end
-
-      include C
-      module Map = Map.Make_binable_using_comparator (C)
-      module Set = Set.Make_binable_using_comparator (C)
-    end)
-  ;;
-
-  (* In 108.06a and earlier, times in sexps of Maps and Sets were raw floats.  From
-     108.07 through 109.13, the output format remained raw as before, but both the raw
-     and pretty format were accepted as input.  From 109.14 on, the output format was
-     changed from raw to pretty, while continuing to accept both formats.  Once we
-     believe most programs are beyond 109.14, we will switch the input format to no
-     longer accept raw. *)
-  include
-    (val make_comparable () ~t_of_sexp:(fun sexp ->
-           match
-             Option.try_with (fun () ->
-               of_span_since_epoch (Span.of_sec (Float.t_of_sexp sexp)))
-           with
-           | Some t -> t
-           | None -> t_of_sexp sexp))
-
-  let%test _ =
-    Set.equal
-      (Set.of_list [ epoch ])
-      (Set.t_of_sexp
-         (Sexp.List [ Float.sexp_of_t (Span.to_sec (to_span_since_epoch epoch)) ]))
-  ;;
-
-  include Hashable.Make_binable (struct
-    type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
-  end)
-
-  module Exposed_for_tests = struct
-    let ensure_colon_in_offset = ensure_colon_in_offset
-  end
-end
diff --git a/time_float_unix/src/time_functor.mli b/time_float_unix/src/time_functor.mli
deleted file mode 100644
index d763d8a..0000000
--- a/time_float_unix/src/time_functor.mli
+++ /dev/null
@@ -1 +0,0 @@
-include Time_functor_intf.Time_functor (** @inline *)
diff --git a/time_float_unix/src/time_functor_intf.ml b/time_float_unix/src/time_functor_intf.ml
deleted file mode 100644
index e4d6bf9..0000000
--- a/time_float_unix/src/time_functor_intf.ml
+++ /dev/null
@@ -1,353 +0,0 @@
-(** A module for representing absolute points in time, independent of time zone.
-
-    Note that on 32bit architecture, most functions will raise when used on time
-    outside the range [1901-12-13 20:45:52 - 2038-01-19 03:14:07].
-*)
-
-open! Core
-open! Import
-
-module type S = sig
-  module Time0 : Time_float.S_kernel_without_zone
-  module Time : Time_float.S_kernel with module Time := Time0
-
-  module Span : sig
-    include module type of Time.Span
-
-    val arg_type : t Core.Command.Arg_type.t
-  end
-
-  module Zone : sig
-    include module type of struct
-      include Time.Zone
-    end [@ocaml.remove_aliases]
-
-    include Timezone.Extend_zone with type t := t
-
-    val arg_type : t Core.Command.Arg_type.t
-  end
-
-  module Ofday : sig
-    include module type of struct
-      include Time.Ofday
-    end [@ocaml.remove_aliases]
-
-    val arg_type : t Core.Command.Arg_type.t
-
-    module Zoned : sig
-      (** Sexps look like "(12:01 nyc)"
-
-          Two [t]'s may or may not correspond to the same times depending on which date
-          they're evaluated. *)
-      type t [@@deriving bin_io, sexp, hash]
-
-      include Pretty_printer.S with type t := t
-
-      (** Strings look like "12:01 nyc" *)
-      include Stringable with type t := t
-
-      (** Like [to_string] but uses [Time_float.Ofday.to_string_trimmed] to format the
-          ofday *)
-      val to_string_trimmed : t -> string
-
-      val arg_type : t Core.Command.Arg_type.t
-      val create : Time.Ofday.t -> Zone.t -> t
-      val create_local : Time.Ofday.t -> t
-      val ofday : t -> Time.Ofday.t
-      val zone : t -> Zone.t
-      val to_time : t -> Date.t -> Time.t
-
-      module With_nonchronological_compare : sig
-        (** It is possible to consistently compare [t]'s, but due to the complexities of
-            time zones and daylight savings, the resulting ordering is not chronological.
-            That is, [compare t1 t2 > 0] does not imply [t2] occurs after [t1] every day,
-            or any day. *)
-        type nonrec t = t [@@deriving bin_io, sexp, compare, equal, hash]
-      end
-    end
-
-    val now : zone:Zone.t -> t
-  end
-
-  (** A fully qualified point in time, independent of timezone. *)
-  type t = Time.t [@@deriving bin_io, compare, hash, sexp, sexp_grammar, typerep]
-
-  include
-    module type of Time
-      with type t := t
-       and module Zone := Time.Zone
-       and module Ofday := Time.Ofday
-       and module Span := Time.Span
-
-  val arg_type : t Core.Command.Arg_type.t
-
-  (** String conversions use the local timezone by default. Sexp conversions use
-      [get_sexp_zone ()] by default, which can be overridden by calling [set_sexp_zone].
-      These default time zones are used when writing a time, and when reading a time with
-      no explicit zone or UTC offset.
-
-      Sexps and strings display the date, ofday, and UTC offset of [t] relative to the
-      appropriate time zone. *)
-  include
-    Identifiable.S
-      with type t := t
-       and type comparator_witness := comparator_witness
-       and module Replace_polymorphic_compare := Replace_polymorphic_compare
-
-  val get_sexp_zone : unit -> Zone.t
-  val set_sexp_zone : Zone.t -> unit
-
-  include Robustly_comparable with type t := t
-
-  (** [of_tm] converts a [Unix.tm] (mirroring a [struct tm] from the C stdlib) into a
-      [Time.t].  Note that the [tm_wday], [tm_yday], and [tm_isdst] fields are ignored. *)
-  val of_tm : Unix.tm -> zone:Zone.t -> t
-
-  (** Conversion functions that involved Ofday.Zoned.t, exactly analogous to the
-      conversion functions that involve Ofday.t *)
-  val of_date_ofday_zoned : Date.t -> Ofday.Zoned.t -> t
-
-  val to_date_ofday_zoned : t -> zone:Time.Zone.t -> Date.t * Ofday.Zoned.t
-  val to_ofday_zoned : t -> zone:Time.Zone.t -> Ofday.Zoned.t
-  val to_string_fix_proto : [ `Utc | `Local ] -> t -> string
-  val of_string_fix_proto : [ `Utc | `Local ] -> string -> t
-
-  (** This is like [of_string] except that if the string doesn't specify the zone then it
-      raises rather than assume the local timezone. *)
-  val of_string_abs : string -> t
-
-  (** [of_string_gen ~if_no_timezone s] attempts to parse [s] to a [t].  If [s] doesn't
-      supply a time zone [if_no_timezone] is consulted. *)
-  val of_string_gen
-    :  if_no_timezone:[ `Fail | `Local | `Use_this_one of Zone.t ]
-    -> string
-    -> t
-
-  (** [t_of_sexp_abs sexp] as [t_of_sexp], but demands that [sexp] indicate the timezone
-      the time is expressed in. *)
-  val t_of_sexp_abs : Sexp.t -> t
-
-  val sexp_of_t_abs : t -> zone:Zone.t -> Sexp.t
-
-  (** {6 Miscellaneous} *)
-
-  (** [pause span] sleeps for span time. *)
-  val pause : Span.t -> unit
-
-  (** [interruptible_pause span] sleeps for span time unless interrupted (e.g. by delivery
-      of a signal), in which case the remaining unslept portion of time is returned. *)
-  val interruptible_pause : Span.t -> [ `Ok | `Remaining of Span.t ]
-
-  (** [pause_forever] sleeps indefinitely. *)
-  val pause_forever : unit -> never_returns
-
-  (** [format t fmt] formats the given time according to fmt, which follows the formatting
-      rules given in 'man strftime'.  The time is output in the given timezone. Here are
-      some commonly used control codes:
-
-      {v
-      %Y - year (4 digits)
-      %y - year (2 digits)
-      %m - month
-      %d - day
-      %H - hour
-      %M - minute
-      %S - second
-    v}
-
-      a common choice would be: %Y-%m-%d %H:%M:%S
-
-      Although %Z and %z are interpreted as format strings, neither are correct in the
-      current implementation. %Z always refers to the local machine timezone, and does not
-      correctly detect whether DST is active. The effective local timezone can be
-      controlled by setting the "TZ" environment variable before calling [format]. %z
-      behaves unreliably and should be avoided.
-
-      Not all strftime control codes are standard; the supported subset will depend on the
-      C libraries linked into a given executable.
-  *)
-  val format : t -> string -> zone:Zone.t -> string
-
-  (** [parse string ~fmt ~zone] parses [string], according to [fmt], which follows the
-      formatting rules given in 'man strptime'.  The time is assumed to be in the given
-      timezone.
-
-      {v
-      %Y - year (4 digits)
-      %y - year (2 digits)
-      %m - month
-      %d - day
-      %H - hour
-      %M - minute
-      %S - second
-    v}
-
-      Raise if [allow_trailing_input] is false and [fmt] does not consume all of the
-      input. *)
-  val parse
-    :  ?allow_trailing_input:bool (** default = false *)
-    -> string
-    -> fmt:string
-    -> zone:Zone.t
-    -> t
-
-  module Exposed_for_tests : sig
-    val ensure_colon_in_offset : string -> string
-  end
-end
-
-module type Time_functor = sig
-  module type S = S
-
-  module Make
-    (Time0 : Time_float.S_kernel_without_zone)
-    (Time : Time_float.S_kernel with module Time := Time0) :
-    S with module Time0 := Time0 and module Time := Time
-end
-
-(** {1 Notes on time}
-
-    This library replicates and extends the functionality of the standard Unix time
-    handling functions (currently exposed in the Unix module, and indirectly through the
-    Time module).
-
-    Things you should know before delving into the mess of time...
-
-    {2 Some general resources (summarized information also appears below) }
-
-    {v
-    general overview   - http://www.twinsun.com/tz/tz-link.htm
-    zone abbreviations - http://blogs.msdn.com/oldnewthing/archive/2008/03/07/8080060.aspx
-    leap seconds       - http://en.wikipedia.org/wiki/Leap_second
-    epoch time         - http://en.wikipedia.org/wiki/Unix_time
-    UTC/GMT time       - http://www.apparent-wind.com/gmt-explained.html
-    TAI time           - http://en.wikipedia.org/wiki/International_Atomic_Time
-    Almost every possible time measurement -
-      http://www.ucolick.org/~sla/leapsecs/timescales.html
-  v}
-
-    {2 Standards for measuring time }
-
-    - Epoch time/Unix time/Posix time: Defined as the number of seconds that have passed
-      since midnight, January 1st, 1970 GMT.  However, under epoch time, a day is always
-      86,400 seconds long, and a minute never contains more than 60 total seconds.  In other
-      words, epoch time does not take leap seconds into account properly.  What a POSIX
-      compliant system does during a leap second depends on the way in which its clock is
-      managed.  It either ignores it, replays the second, or causes a second to last longer
-      than a second (retards the second).  The important thing to remember is that however
-      the transition is managed, all days start on an evenly divisible multiple of 86,400.
-    - GMT/Greenwich Mean Time/Greenwich Civil Time: The time based on the movement of the
-      sun relative to the meridian through the Old Greenwich Observatory (0 degrees).  The
-      movement of the sun in this case is a "mean" movement of the sun to adjust for slight
-      eccentricities in the rotation of the earth, as well as for the effect of the tilt of
-      the earth on the visible speed of the sun across the sky at different times of the
-      year.  GMT is often used synonymously with the term UTC (see below), but may also be
-      used to refer to the time system described here, which differs from UTC (as of 2009)
-      by ~1 second.
-    - Standard Time: The time based on the adjusted (as in GMT) movement of the sun over a
-      point on the earth that is not Greenwich.  Colloquially, the time in a time zone
-      without accounting for any form of daylight savings time.
-    - Wall Clock Time: The time as it appears on a clock on the wall in a given time zone.
-      Essentially this is standard time with DST adjustments.
-    - TAI: International atomic time.  The time based on a weighted average of the time kept
-      by roughly 300 atomic clocks worldwide.  TAI is written using the same format as
-      normal solar (also called civil) times, but is not based on, or adjusted for the
-      apparent solar time.  Thus, as of 2009 TAI appears to be ahead of most other time
-      systems by ~34 seconds when written out in date/time form (2004-09-17T00:00:32 TAI is
-      2004-09-17T00:00:00 UTC)
-    - UTC/Universal Coordinated Time: Often taken as just another term for GMT, UTC is
-      actually TAI adjusted with leap seconds to keep it in line with apparent solar time.
-      Each UTC day is not an exact number of seconds long (unlike TAI or epoch time), and
-      every second is exactly one real second long (unlike GMT, which is based entirely on
-      the apparent motion of the sun, meaning that seconds under GMT slowly get longer as
-      the earth's rotation slows down).  Leap seconds are determined by the rotation of
-      the earth, which is carefully measured by the International Earth Rotation Service
-      in Paris, France using a combination of satellite and lunar laser ranging, very
-      long baseline interferometry, and Navstar Global Positioning System (GPS) stations.
-      This isn't important for using UTC, but is very cool.  UTC is not well defined before
-      about 1960.
-    - Windows File Time: The number of 100-nanosecond intervals that have elapsed since
-      12:00 A.M. January 1, 1601, UTC.  This is great because UTC has no meaning in 1601
-      (being based on atomic timekeeping technologies that didn't exist then), and also
-      because 1601 predates the development of even reasonably accurate clocks of any sort.
-      The reasoning behind the Windows epoch time choice is that "The Gregorian calendar
-      operates on a 400-year cycle, and 1601 is the first year of the cycle that was
-      active at the time Windows NT was being designed. In other words, it was chosen to
-      make the math come out nicely."
-      (http://blogs.msdn.com/oldnewthing/archive/2009/03/06/9461176.aspx)
-    - VBScript (this is my favorite):
-      http://blogs.msdn.com/ericlippert/archive/2003/09/16/eric-s-complete-guide-to-vt-date.aspx
-
-    All of these systems start to exhibit problems as you go further back in time, partly
-    because truly accurate timekeeping didn't make an appearance until roughly 1958, and
-    partly because different parts of the world didn't actually have well defined time zones
-    for a long time.  If you go back far enough, you run into the switch between the Julian
-    (old) and the Gregorian calendar, which happened at different times in history in
-    different places in the world.
-
-    {2 How does a system determine what time zone it is in? }
-
-    + Check to see if the TZ environment variable is set.  If it is, it can be set to one
-    of three forms, two of which are rarely, if ever used see:
-
-    http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html
-
-    for more information on the obscure forms.  The common form represents a relative path
-    from the base /usr/share/zoneinfo/posix, and is generally in the form of a continent
-    or country name paired with a city name (Europe/London, America/New_York).  This is
-    used to load the specified file from disk, which contains a time zone database in zic
-    format (man tzfile).
-
-    + If TZ is not set, the system will try to read the file located at /etc/localtime,
-    which must be a zic timezone database (and which is often just a symlink into
-    /usr/share/zoneinfo/posix).
-    + If /etc/localtime cannot be found, then the system is assumed to be in GMT.
-
-    It's worth noting that under this system there is no place on the system to go to get
-    the name of the file you are using (/etc/localtime may not be a link, and may just be a
-    copy, or its own database not represented in /usr/share/zoneinfo).  Additionally, the
-    names of the files in the system zoneinfo database follow an internal standard, and
-    there is no established standard for naming timezones.  So even if you were using one of
-    these files, and you did know its name, you cannot assume that that name matches any
-    timezone specified by any other system or description.
-
-    One common misconception about time zones is that the standard time zone abbreviations
-    can be used.  For instance, EST surely refers to Eastern Standard Time.  This is
-    unfortunately not true - CST can refer to China Central Time, Central Standard Time, or
-    Cuba Summer Time for instance - and time zone libraries that appear to correctly parse
-    times that use time zone abbreviations do so by using a heuristic that usually assumes
-    you mean a time in the US or Europe, in that order.  Time zones also sometimes use two
-    different abbreviations depending on whether the time in question is in standard time,
-    or daylight savings time.  These abbreviations are kept in the timezone databases, which
-    is how programs like date manage to output meaningful abbreviations. The only poorly
-    specified operation is reading in times with abbreviations.
-
-    This library contains a function that attempts to make an accurate determination of the
-    machine timezone by testing the md5 sum of the currently referenced timezone file
-    against all of the possible candidates in the system database.  It additionally makes
-    some adjustments to return the more common timezone names since some files in the
-    database are duplicated under several names.  It returns an option because of the
-    problems mentioned above.
-
-    {2 The problems with string time conversions }
-
-    There are two cases where string time conversions are problematic, both related to
-    daylight savings time.
-
-    In the case where time jumps forward one hour, there are possible representations of
-    times that never happened 2006-04-02T02:30:00 in the eastern U.S. never happened for
-    instance, because the clock jumped forward one hour directly from 2 to 3.  Unix time
-    zone libraries asked to convert one of these times will generally produce the epoch time
-    that represents the time 1/2 hour after 2 am, which when converted back to a string
-    representation will be T03:30:00.
-
-    The second case is when the clocks are set back one hour, which causes one hour of time
-    to happen twice.  Converting a string in this range without further specification into
-    an epoch time is indeterminate since it could be referring to either of two times.  Unix
-    libraries handle this by either allowing you to pass in a dst flag to the conversion
-    function to specify which time you mean, or by using a heuristic to guess which time you
-    meant.
-
-    The existence of both cases make a strong argument for serializing all times in UTC,
-    which doesn't suffer from these issues.
-*)
diff --git a/time_float_unix/test/dune b/time_float_unix/test/dune
index c48f5ee..61699f7 100644
--- a/time_float_unix/test/dune
+++ b/time_float_unix/test/dune
@@ -1,6 +1,6 @@
 (library
  (name time_unix_test)
- (libraries expect_test_helpers_core sexp_grammar_validation sys_unix
-   time_interface time_ns_unix)
+ (libraries core core_unix expect_test_helpers_core sexp_grammar_validation
+   sys_unix time_float_unix time_interface time_ns_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_float_unix/test/test_container_sexps.ml b/time_float_unix/test/test_container_sexps.ml
index e228cee..897e200 100644
--- a/time_float_unix/test/test_container_sexps.ml
+++ b/time_float_unix/test/test_container_sexps.ml
@@ -9,7 +9,6 @@ let%test_module _ =
   (module struct
     let%expect_test _ =
       print_and_check_container_sexps
-        [%here]
         (module Time)
         [ Time.epoch
         ; Time.of_string "1955-11-12 18:38:00-08:00"
@@ -43,7 +42,6 @@ let%test_module _ =
 
     let%expect_test _ =
       print_and_check_container_sexps
-        [%here]
         (module Time.Ofday)
         [ Time.Ofday.start_of_day
         ; Time.Ofday.of_string "12:00:00"
@@ -66,7 +64,6 @@ let%test_module _ =
 
     let%expect_test _ =
       print_and_check_container_sexps
-        [%here]
         (module Time.Span)
         [ Time.Span.zero
         ; Time.Span.nanosecond
@@ -103,7 +100,7 @@ let%test_module _ =
     ;;
 
     let%expect_test _ =
-      print_and_check_container_sexps [%here] (module Month) Month.all;
+      print_and_check_container_sexps (module Month) Month.all;
       [%expect
         {|
         (Set (Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec))
diff --git a/time_float_unix/test/test_time_transitions.ml b/time_float_unix/test/test_time_transitions.ml
index f467cd2..caa5786 100644
--- a/time_float_unix/test/test_time_transitions.ml
+++ b/time_float_unix/test/test_time_transitions.ml
@@ -152,7 +152,7 @@ let run (type zone ofday time) time_m title f examples =
 
 let test time_m f =
   let go title examples =
-    require_does_not_raise [%here] (fun () ->
+    require_does_not_raise (fun () ->
       run time_m title f examples;
       run time_m title f (examples |> List.rev))
   in
@@ -208,7 +208,6 @@ let%expect_test "Time.of_date_ofday" =
       match times with
       | `Once time | `Echo (time, _) | `Never (`Synthetic time) | `Twice (_, time) ->
         require_equal
-          [%here]
           ~message:title
           (module Time)
           (Time.of_date_ofday ~zone date ofday)
@@ -223,7 +222,6 @@ let%expect_test "Time_ns.of_date_ofday" =
       match times with
       | `Once time | `Echo (time, _) | `Never (`Synthetic time) | `Twice (_, time) ->
         require_equal
-          [%here]
           ~message:title
           (module Time_ns)
           (Time_ns.of_date_ofday ~zone date ofday)
@@ -236,7 +234,7 @@ let%expect_test "Time.to_date" =
     (module Time)
     (fun ~title ~zone ~date ~ofday:_ ~times ->
       let f time =
-        require_equal [%here] ~message:title (module Date) (Time.to_date ~zone time) date
+        require_equal ~message:title (module Date) (Time.to_date ~zone time) date
       in
       match times with
       | `Never (`Synthetic time) -> f time
@@ -253,12 +251,7 @@ let%expect_test "Time_ns.to_date" =
     (module Time_ns)
     (fun ~title ~zone ~date ~ofday:_ ~times ->
       let f time =
-        require_equal
-          [%here]
-          ~message:title
-          (module Date)
-          (Time_ns.to_date ~zone time)
-          date
+        require_equal ~message:title (module Date) (Time_ns.to_date ~zone time) date
       in
       match times with
       | `Never (`Synthetic time) -> f time
@@ -275,12 +268,7 @@ let%expect_test "Time.to_ofday" =
     (module Time)
     (fun ~title ~zone ~date:_ ~ofday ~times ->
       let f time =
-        require_equal
-          [%here]
-          ~message:title
-          (module Time.Ofday)
-          (Time.to_ofday ~zone time)
-          ofday
+        require_equal ~message:title (module Time.Ofday) (Time.to_ofday ~zone time) ofday
       in
       match times with
       | `Once time -> f time
@@ -291,7 +279,6 @@ let%expect_test "Time.to_ofday" =
       | `Never (`Synthetic synthetic_time) ->
         let synthetic_ofday = Time.to_ofday ~zone synthetic_time in
         require
-          [%here]
           (not (Time.Ofday.equal ofday synthetic_ofday))
           ~if_false_then_print_s:
             (lazy
@@ -308,7 +295,6 @@ let%expect_test "Time_ns.to_ofday" =
     (fun ~title ~zone ~date:_ ~ofday ~times ->
       let f time =
         require_equal
-          [%here]
           ~message:title
           (module Time_ns.Ofday)
           (Time_ns.to_ofday ~zone time)
@@ -323,7 +309,6 @@ let%expect_test "Time_ns.to_ofday" =
       | `Never (`Synthetic synthetic_time) ->
         let synthetic_ofday = Time_ns.to_ofday ~zone synthetic_time in
         require
-          [%here]
           (not (Time_ns.Ofday.equal ofday synthetic_ofday))
           ~if_false_then_print_s:
             (lazy
@@ -340,7 +325,6 @@ let%expect_test "Time.to_date_ofday" =
     (fun ~title ~zone ~date:_ ~ofday:_ ~times ->
       let f time =
         require_equal
-          [%here]
           ~message:title
           (module Date_and_ofday)
           (Time.to_date_ofday ~zone time)
@@ -362,7 +346,6 @@ let%expect_test "Time_ns.to_date_ofday" =
     (fun ~title ~zone ~date:_ ~ofday:_ ~times ->
       let f time =
         require_equal
-          [%here]
           ~message:title
           (module Date_and_ofday_ns)
           (Time_ns.to_date_ofday ~zone time)
@@ -383,7 +366,6 @@ let%expect_test "Time.of_date_ofday_precise" =
     (module Time)
     (fun ~title ~zone ~date ~ofday ~times ->
       require_equal
-        [%here]
         ~message:title
         (module Time_precise)
         (Time.of_date_ofday_precise ~zone date ofday)
@@ -404,34 +386,29 @@ let%expect_test "Time.to_date_ofday_precise" =
       match times with
       | `Once time ->
         require_equal
-          [%here]
           ~message:title
           (module Date_ofday_precise)
           (Time.to_date_ofday_precise ~zone time)
           (date, ofday, `Only)
       | `Echo (time, `Of other_ofday) ->
         require_equal
-          [%here]
           ~message:title
           (module Date_ofday_precise)
           (Time.to_date_ofday_precise ~zone time)
           (date, ofday, `Also_skipped (date, other_ofday))
       | `Never (`Synthetic time) ->
         require_equal
-          [%here]
           ~message:title
           (module Date_ofday_precise)
           (Time.to_date_ofday_precise ~zone time)
           (Time.to_date ~zone time, Time.to_ofday ~zone time, `Also_skipped (date, ofday))
       | `Twice (time1, time2) ->
         require_equal
-          [%here]
           ~message:title
           (module Date_ofday_precise)
           (Time.to_date_ofday_precise ~zone time1)
           (date, ofday, `Also_at time2);
         require_equal
-          [%here]
           ~message:title
           (module Date_ofday_precise)
           (Time.to_date_ofday_precise ~zone time2)
diff --git a/time_float_unix/test/test_time_unix.ml b/time_float_unix/test/test_time_unix.ml
index 44799d5..86b0115 100644
--- a/time_float_unix/test/test_time_unix.ml
+++ b/time_float_unix/test/test_time_unix.ml
@@ -467,22 +467,22 @@ let%expect_test "our gmtime matches Unix.gmtime" =
     ~trials:100_000
     ~examples:[ 0.; 100.; -100.; 86_400.; -86_400.; 90_000.; -90_000. ]
     ~f:(fun sec_since_epoch ->
-    let time = Time.of_span_since_epoch (Time.Span.of_sec sec_since_epoch) in
-    let my_date, my_ofday = gmtime time in
-    let unix_date, unix_ofday = unix_date_ofday sec_since_epoch in
-    let results = (my_date, my_ofday), (unix_date, unix_ofday) in
-    if not
-         (Tuple.T2.equal
-            ~eq1:Date.equal
-            ~eq2:Time.Ofday.equal
-            (fst results)
-            (snd results))
-    then
-      raise_s
-        [%message
-          "our gmtime doesn't match Unix.gmtime"
-            (sec_since_epoch : float)
-            (results : (Date.t * Time.Ofday.t) * (Date.t * Time.Ofday.t))])
+      let time = Time.of_span_since_epoch (Time.Span.of_sec sec_since_epoch) in
+      let my_date, my_ofday = gmtime time in
+      let unix_date, unix_ofday = unix_date_ofday sec_since_epoch in
+      let results = (my_date, my_ofday), (unix_date, unix_ofday) in
+      if not
+           (Tuple.T2.equal
+              ~eq1:Date.equal
+              ~eq2:Time.Ofday.equal
+              (fst results)
+              (snd results))
+      then
+        raise_s
+          [%message
+            "our gmtime doesn't match Unix.gmtime"
+              (sec_since_epoch : float)
+              (results : (Date.t * Time.Ofday.t) * (Date.t * Time.Ofday.t))])
 ;;
 
 (* we expose the private type of Timish things to help the compiler optimize things
@@ -499,7 +499,6 @@ let%expect_test "end-of-day constants" =
   let zones = List.map !Time.Zone.likely_machine_zones ~f:Time.Zone.find_exn in
   let test_round_trip zone date ofday ~expect =
     require_equal
-      [%here]
       (module Date)
       (Time.of_date_ofday ~zone date ofday |> Time.to_date ~zone)
       expect
@@ -595,22 +594,22 @@ let%test_module "Time.Stable" =
     end
 
     let test_stability (module M : S) =
-      require_does_not_raise [%here] (fun () ->
+      require_does_not_raise (fun () ->
         (* For the pre-written examples, test round-tripping, and also print out the
            converted values so we will see if they change. *)
-        print_and_check_stable_type [%here] (module M) M.examples;
+        print_and_check_stable_type (module M) M.examples;
         (* Test lots more pseudo-randomly generated examples for round-tripping. Do not
            print them out, as we don't want to read thousands of examples, so we won't
            know if their representation changes, but at least we will know they
            round-trip. *)
-        quickcheck [%here] M.quickcheck_generator ~sexp_of:M.sexp_of_t ~f:(fun example ->
-          require_does_not_raise [%here] (fun () ->
+        quickcheck M.quickcheck_generator ~sexp_of:M.sexp_of_t ~f:(fun example ->
+          require_does_not_raise (fun () ->
             let sexp = M.sexp_of_t example in
             let sexp_round_trip = M.t_of_sexp sexp in
-            require_compare_equal [%here] (module M) example sexp_round_trip;
+            require_compare_equal (module M) example sexp_round_trip;
             let string = Binable.to_string (module M) example in
             let binio_round_trip = Binable.of_string (module M) string in
-            require_compare_equal [%here] (module M) example binio_round_trip)))
+            require_compare_equal (module M) example binio_round_trip)))
     ;;
 
     module For_time = struct
@@ -624,7 +623,7 @@ let%test_module "Time.Stable" =
         (* We generate in units of microseconds because our current sexp representation is
            no more precise than that. *)
         |> Quickcheck.Generator.map ~f:(fun int64 ->
-             Time.of_span_since_epoch (Span.of_us (Int64.to_float int64)))
+          Time.of_span_since_epoch (Span.of_us (Int64.to_float int64)))
       ;;
     end
 
@@ -658,9 +657,9 @@ let%test_module "Time.Stable" =
              For_time.quickcheck_generator
              Int.quickcheck_generator)
         |> Quickcheck.Generator.filter_map ~f:(fun alist ->
-             match Time.Map.of_alist alist with
-             | `Ok map -> Some map
-             | `Duplicate_key _ -> None)
+          match Time.Map.of_alist alist with
+          | `Ok map -> Some map
+          | `Duplicate_key _ -> None)
       ;;
     end
 
@@ -794,7 +793,7 @@ let%test_module "Time.Stable" =
         |}];
       (* test that t_of_sexp accepts sexps qualified with time zones in two formats *)
       let test string =
-        require_does_not_raise [%here] (fun () ->
+        require_does_not_raise (fun () ->
           print_s
             [%sexp (Time.Stable.V1.t_of_sexp (Sexp.of_string string) : Time.Stable.V1.t)])
       in
@@ -2504,7 +2503,7 @@ let%test_module "Time.Stable" =
         {|
         (raised (
           Of_sexp_error
-          "Time.t_of_sexp: (time.ml.Make.Time_of_string \"2000-01-01 00:00:00.000000\"\n  (time_functor.ml.Make.Time_string_not_absolute\n    \"2000-01-01 00:00:00.000000\"))"
+          "Time.t_of_sexp: (time.ml.Make.Time_of_string \"2000-01-01 00:00:00.000000\"\n  (time_float.ml.T.Time_string_not_absolute \"2000-01-01 00:00:00.000000\"))"
           (invalid_sexp (2000-01-01 00:00:00.000000))))
         |}]
     ;;
@@ -2528,8 +2527,7 @@ let%test_module "Time.Stable.Span" =
 
     let%expect_test "V1" =
       print_and_check_stable_type
-        [%here]
-        (* V1 round-trips imprecisely in some cases, so we document them and note that
+      (* V1 round-trips imprecisely in some cases, so we document them and note that
            they are still reasonably close. *)
         ~cr:Comment
         (module Time.Stable.Span.V1)
@@ -2569,7 +2567,7 @@ let%test_module "Time.Stable.Span" =
     ;;
 
     let%expect_test "V2" =
-      print_and_check_stable_type [%here] (module Time.Stable.Span.V2) examples;
+      print_and_check_stable_type (module Time.Stable.Span.V2) examples;
       [%expect
         {|
         (bin_shape_digest 1fd923acb2dd9c5d401ad5b08b1d40cd)
@@ -2618,8 +2616,7 @@ let%test_module "Time.Stable.Ofday" =
 
     let%expect_test "V1" =
       print_and_check_stable_type
-        [%here]
-        (* V1 round-trips imprecisely in some cases, so we document them and note that
+      (* V1 round-trips imprecisely in some cases, so we document them and note that
            they are still reasonably close. *)
         ~cr:Comment
         (module Time.Stable.Ofday.V1)
@@ -2681,8 +2678,7 @@ let%test_module "Time.Stable.Ofday" =
 
     let%expect_test "Zoned.V1" =
       print_and_check_stable_type
-        [%here]
-        (* V1 round-trips imprecisely in some cases, so we document them and note that
+      (* V1 round-trips imprecisely in some cases, so we document them and note that
            they are still reasonably close. *)
         ~cr:Comment
         (module Time.Stable.Ofday.Zoned.V1)
@@ -2775,7 +2771,7 @@ let%test_module "Time.Stable.Zone" =
     ;;
 
     let%expect_test "V1" =
-      print_and_check_stable_type [%here] (module Time.Stable.Zone.V1) examples;
+      print_and_check_stable_type (module Time.Stable.Zone.V1) examples;
       [%expect
         {|
         (bin_shape_digest d9a8da25d5656b016fb4dbdc2e4197fb)
@@ -2806,7 +2802,6 @@ let%expect_test "Span.randomize" =
       if Span.( < ) rand lower_bound || Span.( > ) rand upper_bound
       then
         print_cr
-          [%here]
           [%message
             "out of bounds"
               (percent : Percent.t)
@@ -2886,22 +2881,26 @@ let%expect_test "times with implicit zones" =
   let test f = show_raise (fun () -> print_endline (Time.to_string (f ()))) in
   test (fun () ->
     Time.Stable.With_utc_sexp.V2.t_of_sexp (Sexp.of_string "(2013-10-07 09:30)"));
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 05:30:00.000000-04:00
     "did not raise"
     |}];
   test (fun () -> Time.Stable.V1.t_of_sexp (Sexp.of_string "(2013-10-07 09:30)"));
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000-04:00
     "did not raise"
     |}];
   test (fun () -> Time.t_of_sexp (Sexp.Atom "2013-10-07 09:30"));
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000-04:00
     "did not raise"
     |}];
   test (fun () -> Time.of_string "2013-10-07 09:30");
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000-04:00
     "did not raise"
     |}]
@@ -2911,12 +2910,12 @@ let%test_unit "ofday_zoned conversion consistency" =
   let quickcheck_generator =
     Int64.gen_uniform_incl (-10_000_000_000_000_000L) 10_000_000_000_000_000L
     |> Quickcheck.Generator.map ~f:(fun int64 ->
-         Time.of_span_since_epoch (Span.of_us (Int64.to_float int64)))
+      Time.of_span_since_epoch (Span.of_us (Int64.to_float int64)))
   in
   let utc = Zone.utc in
   let nyc = Zone.find_exn "America/New_York" in
   let hkg = Zone.find_exn "Asia/Hong_Kong" in
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     Quickcheck.test quickcheck_generator ~trials:100 ~f:(fun time ->
       let date_utc = Time.to_date time ~zone:utc in
       let date_nyc = Time.to_date time ~zone:nyc in
@@ -2951,7 +2950,7 @@ let%test_unit "ofday_zoned conversion consistency" =
 ;;
 
 let%expect_test "sexp grammar" =
-  require_ok [%here] (Sexp_grammar_validation.validate_grammar (module Time_float_unix));
+  require_ok (Sexp_grammar_validation.validate_grammar (module Time_float_unix));
   [%expect
     {|
     (Union
diff --git a/time_float_unix/test/test_time_unix_legacy.ml b/time_float_unix/test/test_time_unix_legacy.ml
index 3de25d6..fadbfc6 100644
--- a/time_float_unix/test/test_time_unix_legacy.ml
+++ b/time_float_unix/test/test_time_unix_legacy.ml
@@ -11,7 +11,7 @@ let zone = force Time.Zone.local
 
 let require_span_equal_ms_precision here s1 s2 =
   require_equal
-    here
+    ~here
     (module Int63)
     (Float.int63_round_nearest_exn (Time.Span.to_ms s1))
     (Float.int63_round_nearest_exn (Time.Span.to_ms s2))
@@ -29,7 +29,7 @@ let require_similar_time here time time' =
   let time' = Time.to_span_since_epoch time' |> Time.Span.to_sec in
   let delta = Float.abs (time -. time') in
   require
-    here
+    ~here
     (Float.( < ) delta 0.01)
     ~if_false_then_print_s:(lazy [%message (delta : float)])
 ;;
@@ -61,21 +61,21 @@ let%expect_test "t" =
     [%sexp
       (Float.iround_exn ~dir:`Nearest (Time.Span.to_us (Time.diff time4 time3)) : int)];
   [%expect {| 338 |}];
-  require [%here] (Time.( >= ) now2 now1);
+  require (Time.( >= ) now2 now1);
   let test_sexp_roundtrip time =
-    require_equal [%here] (module Time) (Time.t_of_sexp (Time.sexp_of_t time)) time
+    require_equal (module Time) (Time.t_of_sexp (Time.sexp_of_t time)) time
   in
   test_sexp_roundtrip time1;
   test_sexp_roundtrip time2;
   test_sexp_roundtrip time3;
   let date, ofday = Time.to_date_ofday time3 ~zone in
   print_s [%message (date : Date.t) (ofday : Time.Ofday.t)];
-  [%expect {|
+  [%expect
+    {|
     ((date  2005-05-25)
      (ofday 12:46:15.232000))
     |}];
   require_equal
-    [%here]
     (module Time.Ofday)
     (Time.Ofday.of_string "09:13")
     (Time.Ofday.of_string "0913");
@@ -197,7 +197,6 @@ let%test_module "compare with old implementation" =
           then loop (n + 1) (Date.add_days current_date 1)
           else
             print_cr
-              [%here]
               [%message
                 "Implementations do not match"
                   (n : int)
@@ -220,7 +219,6 @@ let%test_module "compare with old implementation" =
           then loop (n + 1) new_method
           else
             print_cr
-              [%here]
               [%message
                 "Implementations do not match"
                   (n : int)
@@ -306,7 +304,7 @@ let%expect_test "add_business_days_rounding_forward" =
     print_s
       [%sexp
         (Date.add_business_days_rounding_forward ~is_holiday (Date.of_string d1) n
-          : Date.t)]
+         : Date.t)]
   in
   test "2009-01-01" 1;
   [%expect {| 2009-01-05 |}];
@@ -335,7 +333,7 @@ let%expect_test "add_business_days_rounding_backward" =
     print_s
       [%sexp
         (Date.add_business_days_rounding_backward ~is_holiday (Date.of_string d1) n
-          : Date.t)]
+         : Date.t)]
   in
   test "2009-01-01" 1;
   [%expect {| 2009-01-02 |}];
@@ -377,13 +375,12 @@ let%expect_test "span_conv" =
     in
     let delta = Float.abs (of_span (to_span x) -. x) in
     require
-      [%here]
       (Float.( <= ) delta tolerance)
       ~if_false_then_print_s:(lazy [%message (delta : float)])
   in
   let test ?tolerance here of_span to_span =
     quickcheck_m
-      here
+      ~here
       (module struct
         type t = float [@@deriving quickcheck, sexp_of]
 
@@ -407,7 +404,7 @@ let%expect_test " date" =
   print_endline (Date.to_string d);
   [%expect {| 2004-04-15 |}];
   let test_alternative_string string =
-    require_equal [%here] (module Date) (Date.of_string string) d
+    require_equal (module Date) (Date.of_string string) d
   in
   test_alternative_string "2004-04-15";
   test_alternative_string "20040415";
@@ -427,7 +424,6 @@ let%expect_test "norollover" =
 
 let%expect_test "quickcheck tests of string roundtrip" =
   quickcheck_m
-    [%here]
     (module Time)
     ~f:(fun time ->
       require_similar_time [%here] time (Time.of_string (Time.to_string time));
@@ -441,7 +437,7 @@ let%expect_test "quickcheck tests of string roundtrip" =
 let%expect_test "to_string,of_string2" =
   let test_to_string_abs_roundtrip s =
     let t = Time.of_string s in
-    require_equal [%here] (module String) (Time.to_string_abs t ~zone) s
+    require_equal (module String) (Time.to_string_abs t ~zone) s
   in
   test_to_string_abs_roundtrip "2005-06-01 10:15:08.047123-04:00";
   test_to_string_abs_roundtrip "2006-06-16 04:37:07.082945-04:00"
@@ -449,7 +445,6 @@ let%expect_test "to_string,of_string2" =
 
 let%expect_test "of_string without colon, negative offset" =
   require_equal
-    [%here]
     (module Time)
     (Time.of_string_abs "2015-07-14 10:31:55.564871-04:00")
     (Time.of_string_abs "2015-07-14 10:31:55.564871-0400")
@@ -457,7 +452,6 @@ let%expect_test "of_string without colon, negative offset" =
 
 let%expect_test "of_string without colon, positive offset" =
   require_equal
-    [%here]
     (module Time)
     (Time.of_string_abs "2015-07-14 10:31:55.564871+04:00")
     (Time.of_string_abs "2015-07-14 10:31:55.564871+0400")
@@ -471,14 +465,14 @@ let%expect_test "of_string with leap second" =
       Time.Ofday.start_of_day
   in
   List.iter [ "2015-06-30 23:59:60Z"; "2015-06-30 23:59:60.500Z" ] ~f:(fun s ->
-    require_equal [%here] (module Time) (Time.of_string s) expected_time_at_leap_second)
+    require_equal (module Time) (Time.of_string s) expected_time_at_leap_second)
 ;;
 
 let%expect_test "to_filename_string,of_filename_string2" =
   let test s =
     let t = Time.of_filename_string s ~zone in
     let s_roundtrip = Time.to_filename_string t ~zone in
-    require_equal [%here] (module String) s s_roundtrip;
+    require_equal (module String) s s_roundtrip;
     print_s [%sexp (t : Time.t)]
   in
   test "2005-06-01_10-15-08.047983";
@@ -489,7 +483,7 @@ let%expect_test "daylight_saving_time" =
   let s = "2006-04-02 23:00:00.000000-04:00" in
   let time = Time.of_string s in
   let s_roundtrip = Time.to_string_abs ~zone time in
-  require_equal [%here] (module String) s s_roundtrip
+  require_equal (module String) s s_roundtrip
 ;;
 
 let%expect_test "weird_date_in_time" =
@@ -505,7 +499,7 @@ let%expect_test "weird_date_in_time" =
 
 let%expect_test "ofday_small_diff" =
   let require_same here x y =
-    require here (Float.( < ) (Float.abs (x -. y)) (sqrt Float.epsilon_float))
+    require ~here (Float.( < ) (Float.abs (x -. y)) (sqrt Float.epsilon_float))
   in
   let check (s1, s2, d) =
     let t1 = Time.Ofday.of_string s1 in
@@ -543,9 +537,9 @@ let%expect_test "occurrence_right_side" =
     List.map utimes ~f:(fun ut -> Time.occurrence `Last_before_or_at now ~zone ~ofday:ut)
   in
   List.iter after_times ~f:(fun t ->
-    require [%here] (Float.( >= ) (Time.Span.to_sec (Time.to_span_since_epoch t)) now_f));
+    require (Float.( >= ) (Time.Span.to_sec (Time.to_span_since_epoch t)) now_f));
   List.iter before_times ~f:(fun t ->
-    require [%here] (Float.( <= ) (Time.Span.to_sec (Time.to_span_since_epoch t)) now_f))
+    require (Float.( <= ) (Time.Span.to_sec (Time.to_span_since_epoch t)) now_f))
 ;;
 
 let%expect_test "occurrence_distance" =
@@ -570,12 +564,12 @@ let%expect_test "occurrence_distance" =
     let od = Time.Ofday.of_string od_s in
     let prediction = Time.of_string prediction_s in
     let real = Time.occurrence `First_after_or_at now ~zone ~ofday:od in
-    require_equal [%here] (module Float) (Time.Span.to_ms (Time.diff prediction real)) 0.);
+    require_equal (module Float) (Time.Span.to_ms (Time.diff prediction real)) 0.);
   List.iter before_times ~f:(fun (od_s, prediction_s) ->
     let od = Time.Ofday.of_string od_s in
     let prediction = Time.of_string prediction_s in
     let real = Time.occurrence `Last_before_or_at now ~zone ~ofday:od in
-    require_equal [%here] (module Float) (Time.Span.to_ms (Time.diff prediction real)) 0.)
+    require_equal (module Float) (Time.Span.to_ms (Time.diff prediction real)) 0.)
 ;;
 
 let%expect_test "diff" =
@@ -593,7 +587,7 @@ let roundtrip s =
   let t = Span.of_string s in
   (* we only test rountrip in one direction because the other direction does not hold!
      for example 1.34m comes back as 1m20.400000000000006s *)
-  require_equal [%here] (module Span) t (Time.Span.of_string (Time.Span.to_string t))
+  require_equal (module Span) t (Time.Span.of_string (Time.Span.to_string t))
 ;;
 
 let%expect_test "roundtrip span<->string" =
@@ -609,22 +603,18 @@ let%expect_test "roundtrip span<->string" =
 ;;
 
 let%expect_test "Span.of_string (nan)" =
-  require_does_raise [%here] (fun () -> Time.Span.of_string "nans");
+  require_does_raise (fun () -> Time.Span.of_string "nans");
   [%expect {| ("Time.Span.of_string: invalid span part magnitude" nans) |}]
 ;;
 
 let%expect_test "Span.of_string (inf)" =
-  require_does_raise [%here] (fun () -> Time.Span.of_string "infs");
+  require_does_raise (fun () -> Time.Span.of_string "infs");
   [%expect {| ("Time.Span.of_string: invalid span part magnitude" infs) |}]
 ;;
 
 let%expect_test "Span.of_string" =
   let test string secs =
-    require_equal
-      [%here]
-      (module Float)
-      (Time.Span.to_sec (Time.Span.of_string string))
-      secs
+    require_equal (module Float) (Time.Span.to_sec (Time.Span.of_string string)) secs
   in
   test "1ms" 0.001;
   test "95ms" 0.095;
@@ -637,7 +627,6 @@ let%expect_test "Span.of_string" =
 
 let%expect_test "Time.of_string_fix_proto" =
   require_equal
-    [%here]
     (module Time)
     (Time.of_string_fix_proto `Utc "20080603-13:55:35.577")
     (Time.of_span_since_epoch
diff --git a/time_float_unix/test/test_zone.ml b/time_float_unix/test/test_zone.ml
index 53dbc07..2f9690a 100644
--- a/time_float_unix/test/test_zone.ml
+++ b/time_float_unix/test/test_zone.ml
@@ -99,7 +99,6 @@ end
 
 let%expect_test "quickcheck string roundtrip" =
   quickcheck_m
-    [%here]
     (module struct
       type t =
         Time_string.t
@@ -126,18 +125,16 @@ let%expect_test "quickcheck string roundtrip" =
         base_string ^ suffix
       in
       require_equal
-        [%here]
         (module String)
         s_with_local_offset
         (Time.to_string_abs (Time.of_string s_with_local_offset) ~zone);
       let s2_time1 = Time.of_string s_with_random_offset in
       let s2_time2 = Time.of_string (Time.to_string_abs s2_time1 ~zone) in
-      require [%here] (Time.( =. ) s2_time1 s2_time2))
+      require (Time.( =. ) s2_time1 s2_time2))
 ;;
 
 let test_roundtrip_conversion (zone_name, zone) =
   quickcheck_m
-    [%here]
     (module Time)
     ~f:(fun time ->
       let time =
@@ -159,7 +156,6 @@ let test_roundtrip_conversion (zone_name, zone) =
         Time.of_date_ofday ~zone:(force Time.Zone.local) round_date round_ofday
       in
       require_equal
-        [%here]
         (module Time)
         time
         round_trip_time
@@ -191,7 +187,6 @@ let%expect_test "random test against Unix.localtime" =
   force load_some_other_time_zones;
   quickcheck_m
     ~config:{ Base_quickcheck.Test.default_config with test_count = 100 }
-    [%here]
     (module Tm)
     ~f:(fun tm ->
       (* Fill in [wday], [yday] fields *)
@@ -211,13 +206,8 @@ let%expect_test "random test against Unix.localtime" =
         let our_date, our_ofday =
           Time.to_date_ofday (Time.of_span_since_epoch (Time.Span.of_sec unix_time)) ~zone
         in
+        require_equal (module String) (Date.to_string our_date) localtime_date_string;
         require_equal
-          [%here]
-          (module String)
-          (Date.to_string our_date)
-          localtime_date_string;
-        require_equal
-          [%here]
           (module String)
           (Time.Ofday.to_string our_ofday)
           localtime_ofday_string))
diff --git a/time_ns_unix/bench/bench_time_ns_unix.ml b/time_ns_unix/bench/bench_time_ns_unix.ml
index 9e6df2e..9d796a7 100644
--- a/time_ns_unix/bench/bench_time_ns_unix.ml
+++ b/time_ns_unix/bench/bench_time_ns_unix.ml
@@ -1,2748 +1,21 @@
-(* This file contains benchmarks for nearly every function in [Core.Time_ns]. The code is
-   carefully laid out using patterns that make it easier to read and maintain such a
-   tedious, hand-written set of benchmarks.
-
-   To make sure we do not forget any functions, this module exports [module type of
-   Time_ns]. Internally, we avoid shorthands such as [include] so that we are forced to
-   define each function individually. We can then check that every [let] of a function is
-   followed by one or more inline benchmarks.
-
-   When functions are exported in more than one place, such as [Time_ns.compare] and
-   [Time_ns.Replace_polymorphic_compare.compare], we benchmark both separately. Artifacts
-   such as functor shadowing can affect inlining and cause different exports of the same
-   function to perform differently.
-
-   Within each submodule, we maintain [open]s so that names from the original module are
-   in scope. This shortens code, and also avoids accidentally referring to the wrong
-   version of a function.
-
-   In order to keep benchmarks meaningful, every benchmark is an application of the
-   function defined above to constants and/or variables. Every variable is a constant
-   defined above and wrapped with [Sys.opaque_identity] (shorthand as [opaque]) so that
-   the benchmark cannot be specialized.
-
-   When we define helpers, such as constant values, we put them in a separate submodule
-   and [open], but not [include], the module. That keeps helper definitions from ever
-   clashing with new bindings that might be added to [Time_ns].
-
-   There are some definitions we do not bother to benchmark in this file. Obviously,
-   constants and types cannot be benchmarked. For now we ignore benchmarking any [bin_io]
-   performance, although we may want to add benchmarks for that some day.  We also skip
-   benchmarking functor-produced modules like [*.Map] and [*.Table]. *)
 open! Core
-module Time = Time_float_unix
-module Time_ns = Time_ns_unix
+include Core.Time_ns
+open Time_ns_unix
 
 module Constants = struct
   let opaque = Sys.opaque_identity
-  let hash_state = opaque (Hash.create ())
-  let sign_neg = opaque Sign.Neg
-  let float_ten = opaque 10.
-  let int_ten = opaque 10
-  let int32_ten = opaque 10l
-  let int63_ten = opaque (Int63.of_int 10)
-  let percent_half = opaque (Percent.of_mult 0.5)
-  let non_ns_day = opaque Time.Span.day
-  let zone = opaque (Time.Zone.find_exn "America/New_York")
-  let nyc = zone
   let date = opaque (Date.create_exn ~y:2013 ~m:Oct ~d:07)
+  let example_ofday = Ofday.create ~hr:13 ~min:29 ~sec:59 ~ms:654 ~us:321 () |> opaque
+  let example = of_date_ofday ~zone:Zone.utc date example_ofday |> opaque
+  let example_formatted = format example "%F %T%z" ~zone:Zone.utc |> opaque
 end
 
 open Constants
-open Time_ns
-
-module Span = struct
-  open Span
-  module Map = Map
-  module Set = Set
-  module Table = Table
-  module Hash_set = Hash_set
-  module Hash_queue = Hash_queue
-  module O = O
-  module Diff = Diff
-
-  (* Nothing interesting to benchmark in [Parts]. *)
-  module Parts = Parts
-
-  (* Nothing interesting to benchmark in [Rounding_direction]. *)
-  module Rounding_direction = Rounding_direction
-
-  (* In [Core], there's no particularly good reason to use [Alternate_sexp]. *)
-  module Alternate_sexp = Alternate_sexp [@warning "-3"]
-
-  type nonrec t = t [@@deriving bin_io, quickcheck, sexp_grammar, typerep]
-  type nonrec underlying = underlying
-  type nonrec comparator_witness = comparator_witness
-
-  let arg_type = arg_type
-  let comparator = comparator
-  let hashable = hashable
-  let pp = pp
-  let gen_incl = gen_incl
-  let gen_uniform_incl = gen_uniform_incl
-  let zero = opaque zero
-  let min_value_representable = opaque min_value_representable
-  let max_value_representable = opaque max_value_representable
-  let min_value_for_1us_rounding = opaque min_value_for_1us_rounding
-  let max_value_for_1us_rounding = opaque max_value_for_1us_rounding
-  let min_value = opaque min_value_for_1us_rounding
-  let max_value = opaque max_value_for_1us_rounding
-  let nanosecond = opaque nanosecond
-  let microsecond = opaque microsecond
-  let millisecond = opaque millisecond
-  let second = opaque second
-  let minute = opaque minute
-  let hour = opaque hour
-  let day = opaque day
-  let robust_comparison_tolerance = opaque robust_comparison_tolerance
-
-  module Span_constants = struct
-    let kiloday = opaque (create ~day:1000 ())
-    let sexp_of_second = opaque (sexp_of_t second)
-    let string_of_nanosecond = opaque (to_string nanosecond)
-    let string_of_microsecond = opaque (to_string microsecond)
-    let string_of_millisecond = opaque (to_string millisecond)
-    let string_of_second = opaque (to_string second)
-    let string_of_minute = opaque (to_string minute)
-    let string_of_hour = opaque (to_string hour)
-    let string_of_day = opaque (to_string day)
-    let string_of_kiloday = opaque (to_string kiloday)
-    let pi_nanoseconds = opaque (of_ns Float.pi)
-    let pi_microseconds = opaque (of_us Float.pi)
-    let pi_milliseconds = opaque (of_ms Float.pi)
-    let pi_seconds = opaque (of_sec Float.pi)
-    let pi_minutes = opaque (of_min Float.pi)
-    let pi_hours = opaque (of_hr Float.pi)
-    let pi_days = opaque (of_day Float.pi)
-    let pi_kilodays = opaque (of_day (Float.pi *. 1000.))
-    let sexp_of_pi_nanoseconds = opaque (sexp_of_t pi_nanoseconds)
-    let sexp_of_pi_microseconds = opaque (sexp_of_t pi_microseconds)
-    let sexp_of_pi_milliseconds = opaque (sexp_of_t pi_milliseconds)
-    let sexp_of_pi_seconds = opaque (sexp_of_t pi_seconds)
-    let sexp_of_pi_minutes = opaque (sexp_of_t pi_minutes)
-    let sexp_of_pi_hours = opaque (sexp_of_t pi_hours)
-    let sexp_of_pi_days = opaque (sexp_of_t pi_days)
-    let sexp_of_pi_kilodays = opaque (sexp_of_t pi_kilodays)
-    let v1_sexp_of_second = opaque (Stable.V1.sexp_of_t second)
-    let v1_sexp_of_pi_nanoseconds = opaque (Stable.V1.sexp_of_t pi_nanoseconds)
-    let v1_sexp_of_pi_microseconds = opaque (Stable.V1.sexp_of_t pi_microseconds)
-    let v1_sexp_of_pi_milliseconds = opaque (Stable.V1.sexp_of_t pi_milliseconds)
-    let v1_sexp_of_pi_seconds = opaque (Stable.V1.sexp_of_t pi_seconds)
-    let v1_sexp_of_pi_minutes = opaque (Stable.V1.sexp_of_t pi_minutes)
-    let v1_sexp_of_pi_hours = opaque (Stable.V1.sexp_of_t pi_hours)
-    let v1_sexp_of_pi_days = opaque (Stable.V1.sexp_of_t pi_days)
-    let v1_sexp_of_pi_kilodays = opaque (Stable.V1.sexp_of_t pi_kilodays)
-    let string_of_pi_nanoseconds = opaque (to_string pi_nanoseconds)
-    let string_of_pi_microseconds = opaque (to_string pi_microseconds)
-    let string_of_pi_milliseconds = opaque (to_string pi_milliseconds)
-    let string_of_pi_seconds = opaque (to_string pi_seconds)
-    let string_of_pi_minutes = opaque (to_string pi_minutes)
-    let string_of_pi_hours = opaque (to_string pi_hours)
-    let string_of_pi_days = opaque (to_string pi_days)
-    let string_of_pi_kilodays = opaque (to_string pi_kilodays)
-    let string_of_decimal_pi_days = opaque (String.( ^ ) (Float.to_string Float.pi) "d")
-    let sexp_of_decimal_pi_days = opaque (Sexp.Atom string_of_decimal_pi_days)
-  end
-
-  open Span_constants
-
-  let hash = hash
-  let%bench "hash" = hash zero
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state zero
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-    let equal = equal
-    let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-    let min = min
-    let%bench "min" = min min_value_for_1us_rounding max_value_for_1us_rounding
-    let max = max
-    let%bench "max" = max min_value_for_1us_rounding max_value_for_1us_rounding
-    let ( = ) = ( = )
-    let%bench "(=)" = min_value_for_1us_rounding = max_value_for_1us_rounding
-    let ( < ) = ( < )
-    let%bench "(<)" = min_value_for_1us_rounding < max_value_for_1us_rounding
-    let ( > ) = ( > )
-    let%bench "(>)" = min_value_for_1us_rounding > max_value_for_1us_rounding
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = min_value_for_1us_rounding <> max_value_for_1us_rounding
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = min_value_for_1us_rounding <= max_value_for_1us_rounding
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = min_value_for_1us_rounding >= max_value_for_1us_rounding
-  end
-
-  let compare = compare
-  let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-  let ascending = ascending
-  let%bench "ascending" = ascending min_value_for_1us_rounding max_value_for_1us_rounding
-  let descending = descending
-
-  let%bench "descending" =
-    descending min_value_for_1us_rounding max_value_for_1us_rounding
-  ;;
-
-  let equal = equal
-  let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-  let min = min
-  let%bench "min" = min min_value_for_1us_rounding max_value_for_1us_rounding
-  let max = max
-  let%bench "max" = max min_value_for_1us_rounding max_value_for_1us_rounding
-  let ( = ) = ( = )
-  let%bench "(=)" = min_value_for_1us_rounding = max_value_for_1us_rounding
-  let ( < ) = ( < )
-  let%bench "(<)" = min_value_for_1us_rounding < max_value_for_1us_rounding
-  let ( > ) = ( > )
-  let%bench "(>)" = min_value_for_1us_rounding > max_value_for_1us_rounding
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = min_value_for_1us_rounding <> max_value_for_1us_rounding
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = min_value_for_1us_rounding <= max_value_for_1us_rounding
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = min_value_for_1us_rounding >= max_value_for_1us_rounding
-  let between = between
-
-  let%bench "between" =
-    between ~low:min_value_for_1us_rounding ~high:max_value_for_1us_rounding zero
-  ;;
-
-  let clamp_exn = clamp_exn
-
-  let%bench "clamp_exn" =
-    clamp_exn ~min:min_value_for_1us_rounding ~max:max_value_for_1us_rounding zero
-  ;;
-
-  let clamp = clamp
-
-  let%bench "clamp" =
-    clamp ~min:min_value_for_1us_rounding ~max:max_value_for_1us_rounding zero
-  ;;
-
-  let validate_ubound = validate_ubound
-
-  let%bench "validate_ubound (success)" =
-    (validate_ubound ~max:(Incl zero) zero : Validate.t)
-  ;;
-
-  let%bench "validate_ubound (failure)" =
-    (validate_ubound ~max:(Excl zero) zero : Validate.t)
-  ;;
-
-  let validate_lbound = validate_lbound
-
-  let%bench "validate_lbound (success)" =
-    (validate_lbound ~min:(Incl zero) zero : Validate.t)
-  ;;
-
-  let%bench "validate_lbound (failure)" =
-    (validate_lbound ~min:(Excl zero) zero : Validate.t)
-  ;;
-
-  let validate_bound = validate_bound
-
-  let%bench "validate_bound (success)" =
-    (validate_bound
-       ~min:(Excl min_value_for_1us_rounding)
-       ~max:(Excl max_value_for_1us_rounding)
-       zero
-      : Validate.t)
-  ;;
-
-  let%bench "validate_bound (failure)" =
-    (validate_bound
-       ~min:(Excl min_value_for_1us_rounding)
-       ~max:(Excl max_value_for_1us_rounding)
-       min_value_for_1us_rounding
-      : Validate.t)
-  ;;
-
-  let validate_positive = validate_positive
-
-  let%bench "validate_positive (success)" =
-    (validate_positive max_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let%bench "validate_positive (failure)" =
-    (validate_positive min_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let validate_negative = validate_negative
-
-  let%bench "validate_negative (success)" =
-    (validate_negative min_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let%bench "validate_negative (failure)" =
-    (validate_negative max_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let validate_non_positive = validate_non_positive
-
-  let%bench "validate_non_positive (success)" =
-    (validate_non_positive min_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let%bench "validate_non_positive (failure)" =
-    (validate_non_positive max_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let validate_non_negative = validate_non_negative
-
-  let%bench "validate_non_negative (success)" =
-    (validate_non_negative max_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let%bench "validate_non_negative (failure)" =
-    (validate_non_negative min_value_for_1us_rounding : Validate.t)
-  ;;
-
-  let is_positive = is_positive
-  let%bench "is_positive" = is_positive zero
-  let is_negative = is_negative
-  let%bench "is_negative" = is_negative zero
-  let is_non_positive = is_non_positive
-  let%bench "is_non_positive" = is_non_positive zero
-  let is_non_negative = is_non_negative
-  let%bench "is_non_negative" = is_non_negative zero
-  let sign = sign
-  let%bench "sign" = sign day
-  let robustly_compare = robustly_compare
-
-  let%bench "robustly_compare" =
-    robustly_compare min_value_for_1us_rounding max_value_for_1us_rounding
-  ;;
-
-  let ( =. ) = ( =. )
-  let%bench "(=.)" = min_value_for_1us_rounding =. max_value_for_1us_rounding
-  let ( <. ) = ( <. )
-  let%bench "(<.)" = min_value_for_1us_rounding <. max_value_for_1us_rounding
-  let ( >. ) = ( >. )
-  let%bench "(>.)" = min_value_for_1us_rounding >. max_value_for_1us_rounding
-  let ( <>. ) = ( <>. )
-  let%bench "(<>.)" = min_value_for_1us_rounding <>. max_value_for_1us_rounding
-  let ( <=. ) = ( <=. )
-  let%bench "(<=.)" = min_value_for_1us_rounding <=. max_value_for_1us_rounding
-  let ( >=. ) = ( >=. )
-  let%bench "(>=.)" = min_value_for_1us_rounding >=. max_value_for_1us_rounding
-  let to_span_float_round_nearest = to_span_float_round_nearest
-  let%bench "to_span_float_round_nearest" = to_span_float_round_nearest day
-  let of_span_float_round_nearest = of_span_float_round_nearest
-  let%bench "of_span_float_round_nearest" = of_span_float_round_nearest non_ns_day
-  let to_span = to_span_float_round_nearest_microsecond
-  let to_span_float_round_nearest_microsecond = to_span_float_round_nearest_microsecond
-
-  let%bench "to_span_float_round_nearest_microsecond" =
-    to_span_float_round_nearest_microsecond day
-  ;;
-
-  let of_span = of_span_float_round_nearest_microsecond
-  let of_span_float_round_nearest_microsecond = of_span_float_round_nearest_microsecond
-
-  let%bench "of_span_float_round_nearest_microsecond" =
-    of_span_float_round_nearest_microsecond non_ns_day
-  ;;
-
-  let of_ns = of_ns
-  let%bench "of_ns" = of_ns float_ten
-  let of_us = of_us
-  let%bench "of_us" = of_us float_ten
-  let of_ms = of_ms
-  let%bench "of_ms" = of_ms float_ten
-  let of_sec = of_sec
-  let%bench "of_sec" = of_sec float_ten
-  let of_min = of_min
-  let%bench "of_min" = of_min float_ten
-  let of_hr = of_hr
-  let%bench "of_hr" = of_hr float_ten
-  let of_day = of_day
-  let%bench "of_day" = of_day float_ten
-  let to_ns = to_ns
-  let%bench "to_ns" = to_ns zero
-  let to_us = to_us
-  let%bench "to_us" = to_us zero
-  let to_ms = to_ms
-  let%bench "to_ms" = to_ms zero
-  let to_sec = to_sec
-  let%bench "to_sec" = to_sec zero
-  let to_min = to_min
-  let%bench "to_min" = to_min zero
-  let to_hr = to_hr
-  let%bench "to_hr" = to_hr zero
-  let to_day = to_day
-  let%bench "to_day" = to_day zero
-  let to_us_approx = to_us_approx
-  let%bench "to_us_approx" = to_us_approx zero
-  let to_ms_approx = to_ms_approx
-  let%bench "to_ms_approx" = to_ms_approx zero
-  let to_sec_approx = to_sec_approx
-  let%bench "to_sec_approx" = to_sec_approx zero
-  let to_min_approx = to_min_approx
-  let%bench "to_min_approx" = to_min_approx zero
-  let to_hr_approx = to_hr_approx
-  let%bench "to_hr_approx" = to_hr_approx zero
-  let to_day_approx = to_day_approx
-  let%bench "to_day_approx" = to_day_approx zero
-  let of_int_ns = of_int_ns
-  let%bench "of_int_ns" = of_int_ns int_ten
-  let of_int_us = of_int_us
-  let%bench "of_int_us" = of_int_us int_ten
-  let of_int_ms = of_int_ms
-  let%bench "of_int_ms" = of_int_ms int_ten
-  let of_int_sec = of_int_sec
-  let%bench "of_int_sec" = of_int_sec int_ten
-  let of_int_min = of_int_min
-  let%bench "of_int_min" = of_int_min int_ten
-  let of_int_hr = of_int_hr
-  let%bench "of_int_hr" = of_int_hr int_ten
-  let of_int_day = of_int_day
-  let%bench "of_int_day" = of_int_day int_ten
-  let to_int_ns = to_int_ns
-  let%bench "to_int_ns" = to_int_ns second
-  let to_int_us = to_int_us
-  let%bench "to_int_us" = to_int_us second
-  let to_int_ms = to_int_ms
-  let%bench "to_int_ms" = to_int_ms second
-  let to_int_sec = to_int_sec
-  let%bench "to_int_sec" = to_int_sec second
-  let to_int63_ns = to_int63_ns
-  let%bench "to_int63_ns" = to_int63_ns second
-  let of_int63_ns = of_int63_ns
-  let%bench "of_int63_ns" = of_int63_ns int63_ten
-  let ( + ) = ( + )
-  let%bench "(+)" = day + hour
-  let ( - ) = ( - )
-  let%bench "(-)" = day - hour
-  let abs = abs
-  let%bench "abs" = abs min_value_for_1us_rounding
-  let neg = neg
-  let%bench "neg" = neg min_value_for_1us_rounding
-  let scale = scale
-  let%bench "scale" = scale day float_ten
-  let scale_int = scale_int
-  let%bench "scale_int" = scale_int day int_ten
-  let div = div
-  let%bench "div" = div day hour
-  let ( // ) = ( // )
-  let%bench "(//)" = day // hour
-  let ( / ) = ( / )
-  let%bench "(/)" = day / float_ten
-  let to_proportional_float = to_proportional_float
-  let%bench "to_proportional_float" = to_proportional_float day
-  let create = create
-
-  let%bench "create" =
-    create
-      ~sign:sign_neg
-      ~day:int_ten
-      ~hr:int_ten
-      ~min:int_ten
-      ~sec:int_ten
-      ~ms:int_ten
-      ~us:int_ten
-      ~ns:int_ten
-      ()
-  ;;
-
-  let to_parts = to_parts
-  let%bench "to_parts" = to_parts day
-  let to_unit_of_time = to_unit_of_time
-  let%bench "to_unit_of_time (ns)" = to_unit_of_time pi_nanoseconds
-  let%bench "to_unit_of_time (us)" = to_unit_of_time pi_microseconds
-  let%bench "to_unit_of_time (ms)" = to_unit_of_time pi_milliseconds
-  let%bench "to_unit_of_time (s)" = to_unit_of_time pi_seconds
-  let%bench "to_unit_of_time (m)" = to_unit_of_time pi_minutes
-  let%bench "to_unit_of_time (h)" = to_unit_of_time pi_hours
-  let%bench "to_unit_of_time (d)" = to_unit_of_time pi_days
-  let of_unit_of_time = of_unit_of_time
-  let%bench "of_unit_of_time (ns)" = of_unit_of_time Nanosecond
-  let%bench "of_unit_of_time (us)" = of_unit_of_time Microsecond
-  let%bench "of_unit_of_time (ms)" = of_unit_of_time Millisecond
-  let%bench "of_unit_of_time (s)" = of_unit_of_time Second
-  let%bench "of_unit_of_time (m)" = of_unit_of_time Minute
-  let%bench "of_unit_of_time (h)" = of_unit_of_time Hour
-  let%bench "of_unit_of_time (d)" = of_unit_of_time Day
-  let randomize = randomize
-  let%bench "randomize" = randomize pi_microseconds ~percent:percent_half
-  let random = random
-  let%bench "random" = random ()
-  let to_string_hum = to_string_hum
-  let%bench "to_string_hum (ns)" = to_string_hum pi_nanoseconds
-  let%bench "to_string_hum (us)" = to_string_hum pi_microseconds
-  let%bench "to_string_hum (ms)" = to_string_hum pi_milliseconds
-  let%bench "to_string_hum (s)" = to_string_hum pi_seconds
-  let%bench "to_string_hum (m)" = to_string_hum pi_minutes
-  let%bench "to_string_hum (h)" = to_string_hum pi_hours
-  let%bench "to_string_hum (d)" = to_string_hum pi_days
-  let%bench "to_string_hum (ns, .##)" = to_string_hum pi_nanoseconds ~decimals:2
-  let%bench "to_string_hum (us, .##)" = to_string_hum pi_microseconds ~decimals:2
-  let%bench "to_string_hum (ms, .##)" = to_string_hum pi_milliseconds ~decimals:2
-  let%bench "to_string_hum (s, .##)" = to_string_hum pi_seconds ~decimals:2
-  let%bench "to_string_hum (m, .##)" = to_string_hum pi_minutes ~decimals:2
-  let%bench "to_string_hum (h, .##)" = to_string_hum pi_hours ~decimals:2
-  let%bench "to_string_hum (d, .##)" = to_string_hum pi_days ~decimals:2
-  let%bench "to_string_hum (ns, just)" = to_string_hum pi_nanoseconds ~align_decimal:true
-  let%bench "to_string_hum (us, just)" = to_string_hum pi_microseconds ~align_decimal:true
-  let%bench "to_string_hum (ms, just)" = to_string_hum pi_milliseconds ~align_decimal:true
-  let%bench "to_string_hum (s, just)" = to_string_hum pi_seconds ~align_decimal:true
-  let%bench "to_string_hum (m, just)" = to_string_hum pi_minutes ~align_decimal:true
-  let%bench "to_string_hum (h, just)" = to_string_hum pi_hours ~align_decimal:true
-  let%bench "to_string_hum (d, just)" = to_string_hum pi_days ~align_decimal:true
-  let to_short_string = to_short_string
-  let%bench "to_short_string (ns)" = to_short_string nanosecond
-  let%bench "to_short_string (us)" = to_short_string microsecond
-  let%bench "to_short_string (ms)" = to_short_string millisecond
-  let%bench "to_short_string (s)" = to_short_string second
-  let%bench "to_short_string (m)" = to_short_string minute
-  let%bench "to_short_string (h)" = to_short_string hour
-  let%bench "to_short_string (d)" = to_short_string day
-  let%bench "to_short_string (kd)" = to_short_string kiloday
-  let%bench "to_short_string (ns+)" = to_short_string pi_nanoseconds
-  let%bench "to_short_string (us+)" = to_short_string pi_microseconds
-  let%bench "to_short_string (ms+)" = to_short_string pi_milliseconds
-  let%bench "to_short_string (s+)" = to_short_string pi_seconds
-  let%bench "to_short_string (m+)" = to_short_string pi_minutes
-  let%bench "to_short_string (h+)" = to_short_string pi_hours
-  let%bench "to_short_string (d+)" = to_short_string pi_days
-  let%bench "to_short_string (kd+)" = to_short_string pi_kilodays
-  let to_string = to_string
-  let%bench "to_string (ns)" = to_string nanosecond
-  let%bench "to_string (us)" = to_string microsecond
-  let%bench "to_string (ms)" = to_string millisecond
-  let%bench "to_string (s)" = to_string second
-  let%bench "to_string (m)" = to_string minute
-  let%bench "to_string (h)" = to_string hour
-  let%bench "to_string (d)" = to_string day
-  let%bench "to_string (kd)" = to_string kiloday
-  let%bench "to_string (ns+)" = to_string pi_nanoseconds
-  let%bench "to_string (us+)" = to_string pi_microseconds
-  let%bench "to_string (ms+)" = to_string pi_milliseconds
-  let%bench "to_string (s+)" = to_string pi_seconds
-  let%bench "to_string (m+)" = to_string pi_minutes
-  let%bench "to_string (h+)" = to_string pi_hours
-  let%bench "to_string (d+)" = to_string pi_days
-  let%bench "to_string (kd+)" = to_string pi_kilodays
-  let of_string = of_string
-  let%bench "of_string (ns)" = of_string string_of_nanosecond
-  let%bench "of_string (us)" = of_string string_of_microsecond
-  let%bench "of_string (ms)" = of_string string_of_millisecond
-  let%bench "of_string (s)" = of_string string_of_second
-  let%bench "of_string (m)" = of_string string_of_minute
-  let%bench "of_string (h)" = of_string string_of_hour
-  let%bench "of_string (d)" = of_string string_of_day
-  let%bench "of_string (kd)" = of_string string_of_kiloday
-  let%bench "of_string (ns+)" = of_string string_of_pi_nanoseconds
-  let%bench "of_string (us+)" = of_string string_of_pi_microseconds
-  let%bench "of_string (ms+)" = of_string string_of_pi_milliseconds
-  let%bench "of_string (s+)" = of_string string_of_pi_seconds
-  let%bench "of_string (m+)" = of_string string_of_pi_minutes
-  let%bench "of_string (h+)" = of_string string_of_pi_hours
-  let%bench "of_string (d+)" = of_string string_of_pi_days
-  let%bench "of_string (kd+)" = of_string string_of_pi_kilodays
-  let%bench "of_string (d.)" = of_string string_of_decimal_pi_days
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t (s)" = sexp_of_t second
-  let%bench "sexp_of_t (ns+)" = sexp_of_t pi_nanoseconds
-  let%bench "sexp_of_t (us+)" = sexp_of_t pi_microseconds
-  let%bench "sexp_of_t (ms+)" = sexp_of_t pi_milliseconds
-  let%bench "sexp_of_t (s+)" = sexp_of_t pi_seconds
-  let%bench "sexp_of_t (m+)" = sexp_of_t pi_minutes
-  let%bench "sexp_of_t (h+)" = sexp_of_t pi_hours
-  let%bench "sexp_of_t (d+)" = sexp_of_t pi_days
-  let%bench "sexp_of_t (kd+)" = sexp_of_t pi_kilodays
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp (s)" = t_of_sexp sexp_of_second
-  let%bench "t_of_sexp (ns+)" = t_of_sexp sexp_of_pi_nanoseconds
-  let%bench "t_of_sexp (us+)" = t_of_sexp sexp_of_pi_microseconds
-  let%bench "t_of_sexp (ms+)" = t_of_sexp sexp_of_pi_milliseconds
-  let%bench "t_of_sexp (s+)" = t_of_sexp sexp_of_pi_seconds
-  let%bench "t_of_sexp (m+)" = t_of_sexp sexp_of_pi_minutes
-  let%bench "t_of_sexp (h+)" = t_of_sexp sexp_of_pi_hours
-  let%bench "t_of_sexp (d+)" = t_of_sexp sexp_of_pi_days
-  let%bench "t_of_sexp (kd+)" = t_of_sexp sexp_of_pi_kilodays
-  let%bench "t_of_sexp (d.)" = t_of_sexp sexp_of_decimal_pi_days
-  let since_unix_epoch = since_unix_epoch
-  let%bench "since_unix_epoch" = since_unix_epoch ()
-  let prev = prev
-  let%bench "prev" = prev zero
-  let round_up = round_up
-  let%bench "round_up" = round_up minute ~to_multiple_of:day
-  let round_down = round_down
-  let%bench "round_down" = round_down minute ~to_multiple_of:day
-  let round_nearest = round_nearest
-  let%bench "round_nearest" = round_nearest minute ~to_multiple_of:day
-  let round_towards_zero = round_towards_zero
-  let%bench "round_towards_zero" = round_towards_zero minute ~to_multiple_of:day
-  let round = round
-  let%bench "round" = round minute ~dir:Nearest ~to_multiple_of:day
-  let next = next
-  let%bench "next" = next zero
-  let scale_int63 = scale_int63
-  let%bench "scale_int63" = scale_int63 minute int63_ten
-  let of_sec_with_microsecond_precision = of_sec_with_microsecond_precision
-
-  let%bench "of_sec_with_microsecond_precision" =
-    of_sec_with_microsecond_precision float_ten
-  ;;
-
-  let to_int63_seconds_round_down_exn = to_int63_seconds_round_down_exn
-  let%bench "to_int63_seconds_round_down_exn" = to_int63_seconds_round_down_exn minute
-  let of_int63_seconds = of_int63_seconds
-  let%bench "of_int63_seconds" = of_int63_seconds int63_ten
-  let of_int32_seconds = of_int32_seconds
-  let%bench "of_int32_seconds" = of_int32_seconds int32_ten
-
-  module Stable = struct
-    open Stable
-
-    module V1 = struct
-      open V1
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, hash, sexp_grammar, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-      let equal = equal
-      let%bench "equal" = equal zero zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (s)" = sexp_of_t second
-      let%bench "sexp_of_t (ns+)" = sexp_of_t pi_nanoseconds
-      let%bench "sexp_of_t (us+)" = sexp_of_t pi_microseconds
-      let%bench "sexp_of_t (ms+)" = sexp_of_t pi_milliseconds
-      let%bench "sexp_of_t (s+)" = sexp_of_t pi_seconds
-      let%bench "sexp_of_t (m+)" = sexp_of_t pi_minutes
-      let%bench "sexp_of_t (h+)" = sexp_of_t pi_hours
-      let%bench "sexp_of_t (d+)" = sexp_of_t pi_days
-      let%bench "sexp_of_t (kd+)" = sexp_of_t pi_kilodays
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (s)" = t_of_sexp v1_sexp_of_second
-      let%bench "t_of_sexp (ns+)" = t_of_sexp v1_sexp_of_pi_nanoseconds
-      let%bench "t_of_sexp (us+)" = t_of_sexp v1_sexp_of_pi_microseconds
-      let%bench "t_of_sexp (ms+)" = t_of_sexp v1_sexp_of_pi_milliseconds
-      let%bench "t_of_sexp (s+)" = t_of_sexp v1_sexp_of_pi_seconds
-      let%bench "t_of_sexp (m+)" = t_of_sexp v1_sexp_of_pi_minutes
-      let%bench "t_of_sexp (h+)" = t_of_sexp v1_sexp_of_pi_hours
-      let%bench "t_of_sexp (d+)" = t_of_sexp v1_sexp_of_pi_days
-      let%bench "t_of_sexp (kd+)" = t_of_sexp v1_sexp_of_pi_kilodays
-      let%bench "t_of_sexp (d.)" = t_of_sexp sexp_of_decimal_pi_days
-      let to_int63 = to_int63
-      let%bench "to_int63" = to_int63 day
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn" = of_int63_exn int63_ten
-    end
-
-    module V2 = struct
-      open V2
-      module Map = Map
-      module Set = Set
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, hash, sexp_grammar, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-      let equal = equal
-      let%bench "equal" = equal zero zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (s)" = sexp_of_t second
-      let%bench "sexp_of_t (kd+)" = sexp_of_t pi_kilodays
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (s)" = t_of_sexp sexp_of_second
-      let%bench "t_of_sexp (kd+)" = t_of_sexp sexp_of_pi_kilodays
-      let%bench "t_of_sexp (d.)" = t_of_sexp sexp_of_decimal_pi_days
-      let to_string = to_string
-      let%bench "to_string (s)" = to_string second
-      let%bench "to_string (kd+)" = to_string pi_kilodays
-      let of_string = of_string
-      let%bench "of_string (s)" = of_string string_of_second
-      let%bench "of_string (kd+)" = of_string string_of_pi_kilodays
-      let%bench "of_string (d.)" = of_string string_of_decimal_pi_days
-      let to_int63 = to_int63
-      let%bench "to_int63" = to_int63 day
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn" = of_int63_exn int63_ten
-    end
-  end
-
-  module Option = struct
-    open Option
-    module Map = Map
-    module Set = Set
-    module Table = Table
-    module Hash_set = Hash_set
-    module Hash_queue = Hash_queue
-    module Diff = Diff
-
-    type nonrec t = t [@@deriving bin_io, quickcheck, typerep]
-    type nonrec comparator_witness = comparator_witness
-
-    let comparator = comparator
-    let hashable = hashable
-    let pp = pp
-    let none = opaque none
-
-    module Span_option_constants = struct
-      let some_hour = opaque (some hour)
-      let some_day = opaque (some day)
-      let some_day_option = opaque (Some day)
-      let string_of_none = opaque (to_string none)
-      let string_of_some_day = opaque (to_string some_day)
-      let sexp_of_none = opaque (sexp_of_t none)
-      let sexp_of_some_day = opaque (sexp_of_t some_day)
-      let v1_sexp_of_none = opaque (Stable.V1.sexp_of_t none)
-      let v1_sexp_of_some_day = opaque (Stable.V1.sexp_of_t some_day)
-      let int63_of_none = opaque (Stable.V1.to_int63 none)
-      let int63_of_some_day = opaque (Stable.V1.to_int63 some_day)
-    end
-
-    open Span_option_constants
-
-    let hash = hash
-    let%bench "hash" = hash none
-    let hash_fold_t = hash_fold_t
-    let%bench "hash_fold_t" = hash_fold_t hash_state none
-
-    module Replace_polymorphic_compare = struct
-      open Replace_polymorphic_compare
-
-      let compare = compare
-      let%bench "compare" = compare none some_day
-      let equal = equal
-      let%bench "equal" = equal none some_day
-      let min = min
-      let%bench "min" = min none some_day
-      let max = max
-      let%bench "max" = max none some_day
-      let ( = ) = ( = )
-      let%bench "(=)" = none = some_day
-      let ( < ) = ( < )
-      let%bench "(<)" = none < some_day
-      let ( > ) = ( > )
-      let%bench "(>)" = none > some_day
-      let ( <> ) = ( <> )
-      let%bench "(<>)" = none <> some_day
-      let ( <= ) = ( <= )
-      let%bench "(<=)" = none <= some_day
-      let ( >= ) = ( >= )
-      let%bench "(>=)" = none >= some_day
-    end
-
-    let compare = compare
-    let%bench "compare" = compare none some_day
-    let ascending = ascending
-    let%bench "ascending" = ascending none some_day
-    let descending = descending
-    let%bench "descending" = descending none some_day
-    let equal = equal
-    let%bench "equal" = equal none some_day
-    let min = min
-    let%bench "min" = min none some_day
-    let max = max
-    let%bench "max" = max none some_day
-    let ( = ) = ( = )
-    let%bench "(=)" = none = some_day
-    let ( < ) = ( < )
-    let%bench "(<)" = none < some_day
-    let ( > ) = ( > )
-    let%bench "(>)" = none > some_day
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = none <> some_day
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = none <= some_day
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = none >= some_day
-    let between = between
-    let%bench "between" = between ~low:none ~high:some_day some_hour
-    let clamp_exn = clamp_exn
-    let%bench "clamp_exn" = clamp_exn ~min:none ~max:some_day some_hour
-    let clamp = clamp
-    let%bench "clamp" = clamp ~min:none ~max:some_day some_hour
-    let validate_ubound = validate_ubound
-
-    let%bench "validate_ubound (success)" =
-      (validate_ubound ~max:(Incl some_hour) some_hour : Validate.t)
-    ;;
-
-    let%bench "validate_ubound (failure)" =
-      (validate_ubound ~max:(Excl some_hour) some_hour : Validate.t)
-    ;;
-
-    let validate_lbound = validate_lbound
-
-    let%bench "validate_lbound (success)" =
-      (validate_lbound ~min:(Incl some_hour) some_hour : Validate.t)
-    ;;
-
-    let%bench "validate_lbound (failure)" =
-      (validate_lbound ~min:(Excl some_hour) some_hour : Validate.t)
-    ;;
-
-    let validate_bound = validate_bound
-
-    let%bench "validate_bound (success)" =
-      (validate_bound ~min:(Excl none) ~max:(Excl some_day) some_hour : Validate.t)
-    ;;
-
-    let%bench "validate_bound (failure)" =
-      (validate_bound ~min:(Excl none) ~max:(Excl some_day) none : Validate.t)
-    ;;
-
-    let some = some
-    let%bench "some" = some day
-    let is_none = is_none
-    let%bench "is_none" = is_none some_day
-    let is_some = is_some
-    let%bench "is_some" = is_some some_day
-    let value_exn = value_exn
-    let%bench "value_exn" = value_exn some_day
-    let unchecked_value = unchecked_value
-    let%bench "unchecked_value" = unchecked_value some_day
-    let value = value
-    let%bench "value (none)" = value none ~default:hour
-    let%bench "value (some)" = value some_day ~default:hour
-    let some_is_representable = some_is_representable
-    let%bench "some_is_representable" = some_is_representable day
-    let of_option = of_option
-    let%bench "of_option" = of_option some_day_option
-    let to_option = to_option
-    let%bench "to_option" = to_option some_day
-    let of_string = of_string
-    let%bench "of_string (none)" = of_string string_of_none
-    let%bench "of_string (some)" = of_string string_of_some_day
-    let to_string = to_string
-    let%bench "to_string (none)" = to_string none
-    let%bench "to_string (some)" = to_string some_day
-    let t_of_sexp = t_of_sexp
-    let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-    let%bench "t_of_sexp (some)" = t_of_sexp sexp_of_some_day
-    let sexp_of_t = sexp_of_t
-    let%bench "sexp_of_t (none)" = sexp_of_t none
-    let%bench "sexp_of_t (some)" = sexp_of_t some_day
-
-    module Optional_syntax = struct
-      open Optional_syntax
-
-      module Optional_syntax = struct
-        open Optional_syntax
-
-        let is_none = is_none
-        let%bench "is_none" = is_none some_day
-        let unsafe_value = unsafe_value
-        let%bench "unsafe_value" = unsafe_value some_day
-      end
-    end
-
-    module Stable = struct
-      open Stable
-
-      module V1 = struct
-        open V1
-        module Diff = Diff
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let compare = compare
-        let%bench "compare" = compare none some_day
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp (none)" = t_of_sexp v1_sexp_of_none
-        let%bench "t_of_sexp (some)" = t_of_sexp v1_sexp_of_some_day
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t (none)" = sexp_of_t none
-        let%bench "sexp_of_t (some)" = sexp_of_t some_day
-        let to_int63 = to_int63
-        let%bench "to_int63 (none)" = to_int63 none
-        let%bench "to_int63 (some)" = to_int63 some_day
-        let of_int63_exn = of_int63_exn
-        let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-        let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_day
-      end
-
-      module V2 = struct
-        open V2
-        module Diff = Diff
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let compare = compare
-        let%bench "compare" = compare none some_day
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-        let%bench "t_of_sexp (some)" = t_of_sexp sexp_of_some_day
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t (none)" = sexp_of_t none
-        let%bench "sexp_of_t (some)" = sexp_of_t some_day
-        let to_int63 = to_int63
-        let%bench "to_int63 (none)" = to_int63 none
-        let%bench "to_int63 (some)" = to_int63 some_day
-        let of_int63_exn = of_int63_exn
-        let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-        let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_day
-      end
-    end
-  end
-end
-
-module Ofday = struct
-  open Ofday
-  module Map = Map
-  module Set = Set
-  module Table = Table
-  module Hash_set = Hash_set
-  module Hash_queue = Hash_queue
-  module Diff = Diff
-
-  type nonrec underlying = underlying
-  type nonrec t = t [@@deriving bin_io, quickcheck, sexp_grammar, typerep]
-  type nonrec comparator_witness = comparator_witness
-
-  let arg_type = arg_type
-  let comparator = comparator
-  let hashable = hashable
-  let pp = pp
-  let gen_incl = gen_incl
-  let gen_uniform_incl = gen_uniform_incl
-  let start_of_day = opaque start_of_day
-  let approximate_end_of_day = opaque approximate_end_of_day
-  let start_of_next_day = opaque start_of_next_day
-
-  module Ofday_constants = struct
-    let example = create ~hr:13 ~min:29 ~sec:59 ~ms:654 ~us:321 () |> opaque
-
-    let morning =
-      opaque
-        (of_span_since_start_of_day_exn
-           (Span.create ~hr:09 ~min:30 ~sec:14 ~ms:123 ~us:456 ~ns:789 ()))
-    ;;
-
-    let noon = opaque (Time_ns.Ofday.create ~hr:12 ())
-
-    let evening =
-      opaque
-        (of_span_since_start_of_day_exn
-           (Span.create ~hr:18 ~min:29 ~sec:59 ~ms:987 ~us:654 ~ns:321 ()))
-    ;;
-
-    let dst_time_ns =
-      opaque (Time_ns.of_date_ofday ~zone (Date.of_string "2013-10-07") morning)
-    ;;
-
-    let no_dst_time_ns =
-      opaque (Time_ns.of_date_ofday ~zone (Date.of_string "2013-12-11") evening)
-    ;;
-
-    let start_of_day_ofday = opaque (to_ofday_float_round_nearest start_of_day)
-    let morning_ofday = opaque (to_ofday_float_round_nearest morning)
-    let evening_ofday = opaque (to_ofday_float_round_nearest evening)
-    let start_of_day_span = opaque (to_span_since_start_of_day start_of_day)
-    let morning_span = opaque (to_span_since_start_of_day morning)
-    let evening_span = opaque (to_span_since_start_of_day evening)
-    let sexp_of_start_of_day = opaque (sexp_of_t start_of_day)
-    let sexp_of_morning = opaque (sexp_of_t morning)
-    let sexp_of_evening = opaque (sexp_of_t evening)
-    let string_of_start_of_day = opaque (to_string start_of_day)
-    let string_of_morning = opaque (to_string morning)
-    let string_of_evening = opaque (to_string evening)
-    let int63_of_start_of_day = opaque (Stable.V1.to_int63 start_of_day)
-  end
-
-  open Ofday_constants
-
-  let hash = hash
-  let%bench "hash" = hash start_of_day
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state start_of_day
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare" = compare start_of_day evening
-    let equal = equal
-    let%bench "equal" = equal start_of_day evening
-    let min = min
-    let%bench "min" = min start_of_day evening
-    let max = max
-    let%bench "max" = max start_of_day evening
-    let ( = ) = ( = )
-    let%bench "(=)" = start_of_day = evening
-    let ( < ) = ( < )
-    let%bench "(<)" = start_of_day < evening
-    let ( > ) = ( > )
-    let%bench "(>)" = start_of_day > evening
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = start_of_day <> evening
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = start_of_day <= evening
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = start_of_day >= evening
-  end
-
-  let compare = compare
-  let%bench "compare" = compare start_of_day evening
-  let ascending = ascending
-  let%bench "ascending" = ascending start_of_day evening
-  let descending = descending
-  let%bench "descending" = descending start_of_day evening
-  let equal = equal
-  let%bench "equal" = equal start_of_day evening
-  let min = min
-  let%bench "min" = min start_of_day evening
-  let max = max
-  let%bench "max" = max start_of_day evening
-  let ( = ) = ( = )
-  let%bench "(=)" = start_of_day = evening
-  let ( < ) = ( < )
-  let%bench "(<)" = start_of_day < evening
-  let ( > ) = ( > )
-  let%bench "(>)" = start_of_day > evening
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = start_of_day <> evening
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = start_of_day <= evening
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = start_of_day >= evening
-  let between = between
-  let%bench "between" = between ~low:start_of_day ~high:evening morning
-  let clamp_exn = clamp_exn
-  let%bench "clamp_exn" = clamp_exn ~min:start_of_day ~max:evening morning
-  let clamp = clamp
-  let%bench "clamp" = clamp ~min:start_of_day ~max:evening morning
-  let validate_ubound = validate_ubound
-
-  let%bench "validate_ubound (success)" =
-    (validate_ubound ~max:(Incl morning) morning : Validate.t)
-  ;;
-
-  let%bench "validate_ubound (failure)" =
-    (validate_ubound ~max:(Excl morning) morning : Validate.t)
-  ;;
-
-  let validate_lbound = validate_lbound
-
-  let%bench "validate_lbound (success)" =
-    (validate_lbound ~min:(Incl morning) morning : Validate.t)
-  ;;
-
-  let%bench "validate_lbound (failure)" =
-    (validate_lbound ~min:(Excl morning) morning : Validate.t)
-  ;;
-
-  let validate_bound = validate_bound
-
-  let%bench "validate_bound (success)" =
-    (validate_bound ~min:(Excl start_of_day) ~max:(Excl evening) morning : Validate.t)
-  ;;
-
-  let%bench "validate_bound (failure)" =
-    (validate_bound ~min:(Excl start_of_day) ~max:(Excl evening) start_of_day
-      : Validate.t)
-  ;;
-
-  let add_exn = add_exn
-  let%bench "add_exn" = add_exn morning Span.hour
-  let sub_exn = sub_exn
-  let%bench "sub_exn" = sub_exn evening Span.hour
-  let add = add
-  let%bench "add" = add example Span.hour
-  let sub = sub
-  let%bench "sub" = sub example Span.hour
-  let next = next
-  let%bench "next" = next example
-  let prev = prev
-  let%bench "prev" = prev example
-  let diff = diff
-  let%bench "diff" = diff example start_of_day
-  let small_diff = small_diff
-  let%bench "small_diff" = small_diff example start_of_day
-  let robustly_compare = robustly_compare
-  let%bench "robustly_compare (<)" = robustly_compare start_of_day example
-  let%bench "robustly_compare (>)" = robustly_compare example start_of_day
-  let%bench "robustly_compare (=)" = robustly_compare start_of_day start_of_day
-  let ( =. ) = ( =. )
-  let%bench "(=.)" = start_of_day =. example
-  let ( <. ) = ( <. )
-  let%bench "(<.)" = start_of_day <. example
-  let ( >. ) = ( >. )
-  let%bench "(>.)" = start_of_day >. example
-  let ( <=. ) = ( <=. )
-  let%bench "(<=.)" = start_of_day <=. example
-  let ( >=. ) = ( >=. )
-  let%bench "(>=.)" = start_of_day >=. example
-  let ( <>. ) = ( <>. )
-  let%bench "(<>.)" = start_of_day <>. example
-  let create = create
-  let%bench "create" = create ~hr:12 ~min:34 ~sec:56 ~ms:123 ~us:456 ()
-  let to_parts = to_parts
-  let%bench "to_parts" = to_parts example
-  let every = every
-  let%bench "every" = every Span.hour ~start:start_of_day ~stop:example
-  let now = now
-  let%bench "now (utc)" = now ~zone:Zone.utc
-  let%bench "now (local)" = now ~zone
-  let of_ofday_float_round_nearest = of_ofday_float_round_nearest
-
-  let%bench "of_ofday_float_round_nearest (midnight)" =
-    of_ofday_float_round_nearest start_of_day_ofday
-  ;;
-
-  let%bench "of_ofday_float_round_nearest (morning)" =
-    of_ofday_float_round_nearest morning_ofday
-  ;;
-
-  let%bench "of_ofday_float_round_nearest (evening)" =
-    of_ofday_float_round_nearest evening_ofday
-  ;;
-
-  let to_ofday_float_round_nearest = to_ofday_float_round_nearest
-
-  let%bench "to_ofday_float_round_nearest (midnight)" =
-    to_ofday_float_round_nearest start_of_day
-  ;;
-
-  let%bench "to_ofday_float_round_nearest (morning)" =
-    to_ofday_float_round_nearest morning
-  ;;
-
-  let%bench "to_ofday_float_round_nearest (evening)" =
-    to_ofday_float_round_nearest evening
-  ;;
-
-  let of_ofday = of_ofday_float_round_nearest_microsecond
-  let of_ofday_float_round_nearest_microsecond = of_ofday_float_round_nearest_microsecond
-
-  let%bench "of_ofday_float_round_nearest_microsecond (midnight)" =
-    of_ofday_float_round_nearest_microsecond start_of_day_ofday
-  ;;
-
-  let%bench "of_ofday_float_round_nearest_microsecond (morning)" =
-    of_ofday_float_round_nearest_microsecond morning_ofday
-  ;;
-
-  let%bench "of_ofday_float_round_nearest_microsecond (evening)" =
-    of_ofday_float_round_nearest_microsecond evening_ofday
-  ;;
-
-  let to_ofday = to_ofday_float_round_nearest_microsecond
-  let to_ofday_float_round_nearest_microsecond = to_ofday_float_round_nearest_microsecond
-
-  let%bench "to_ofday_float_round_nearest_microsecond (midnight)" =
-    to_ofday_float_round_nearest_microsecond start_of_day
-  ;;
-
-  let%bench "to_ofday_float_round_nearest_microsecond (morning)" =
-    to_ofday_float_round_nearest_microsecond morning
-  ;;
-
-  let%bench "to_ofday_float_round_nearest_microsecond (evening)" =
-    to_ofday_float_round_nearest_microsecond evening
-  ;;
-
-  let of_span_since_start_of_day_exn = of_span_since_start_of_day_exn
-  let of_span_since_start_of_day = of_span_since_start_of_day_exn
-
-  let%bench "of_span_since_start_of_day_exn (midnight)" =
-    of_span_since_start_of_day_exn start_of_day_span
-  ;;
-
-  let%bench "of_span_since_start_of_day_exn (morning)" =
-    of_span_since_start_of_day_exn morning_span
-  ;;
-
-  let%bench "of_span_since_start_of_day_exn (evening)" =
-    of_span_since_start_of_day_exn evening_span
-  ;;
-
-  let of_span_since_start_of_day_unchecked = of_span_since_start_of_day_unchecked
-
-  let%bench "of_span_since_start_of_day_unchecked" =
-    of_span_since_start_of_day_unchecked start_of_day_span
-  ;;
-
-  let span_since_start_of_day_is_valid = span_since_start_of_day_is_valid
-
-  let%bench "span_since_start_of_day_is_valid" =
-    span_since_start_of_day_is_valid start_of_day_span
-  ;;
-
-  let to_span_since_start_of_day = to_span_since_start_of_day
-
-  let%bench "to_span_since_start_of_day (midnight)" =
-    to_span_since_start_of_day start_of_day
-  ;;
-
-  let%bench "to_span_since_start_of_day (morning)" = to_span_since_start_of_day morning
-  let%bench "to_span_since_start_of_day (evening)" = to_span_since_start_of_day evening
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t (midnight)" = sexp_of_t start_of_day
-  let%bench "sexp_of_t (morning)" = sexp_of_t morning
-  let%bench "sexp_of_t (evening)" = sexp_of_t evening
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp (midnight)" = t_of_sexp sexp_of_start_of_day
-  let%bench "t_of_sexp (morning)" = t_of_sexp sexp_of_morning
-  let%bench "t_of_sexp (evening)" = t_of_sexp sexp_of_evening
-  let to_string = to_string
-  let%bench "to_string (midnight)" = to_string start_of_day
-  let%bench "to_string (morning)" = to_string morning
-  let%bench "to_string (evening)" = to_string evening
-  let of_string = of_string
-  let%bench "of_string (midnight)" = of_string string_of_start_of_day
-  let%bench "of_string (morning)" = of_string string_of_morning
-  let%bench "of_string (evening)" = of_string string_of_evening
-  let to_string_trimmed = to_string_trimmed
-  let%bench "to_string_trimmed (midnight)" = to_string_trimmed start_of_day
-  let%bench "to_string_trimmed (morning)" = to_string_trimmed morning
-  let%bench "to_string_trimmed (evening)" = to_string_trimmed evening
-  let to_sec_string = to_sec_string
-  let%bench "to_sec_string (midnight)" = to_sec_string start_of_day
-  let%bench "to_sec_string (morning)" = to_sec_string morning
-  let%bench "to_sec_string (evening)" = to_sec_string evening
-  let to_millisecond_string = to_millisecond_string
-  let to_millisec_string = to_millisecond_string
-  let%bench "to_millisecond_string (midnight)" = to_millisecond_string start_of_day
-  let%bench "to_millisecond_string (morning)" = to_millisecond_string morning
-  let%bench "to_millisecond_string (evening)" = to_millisecond_string evening
-  let to_microsecond_string = to_microsecond_string
-  let%bench "to_microsecond_string (midnight)" = to_microsecond_string start_of_day
-  let%bench "to_microsecond_string (morning)" = to_microsecond_string morning
-  let%bench "to_microsecond_string (evening)" = to_microsecond_string evening
-  let of_string_iso8601_extended = of_string_iso8601_extended
-
-  let%bench "of_string_iso8601_extended (midnight)" =
-    of_string_iso8601_extended string_of_start_of_day
-  ;;
-
-  let%bench "of_string_iso8601_extended (morning)" =
-    of_string_iso8601_extended string_of_morning
-  ;;
-
-  let%bench "of_string_iso8601_extended (evening)" =
-    of_string_iso8601_extended string_of_evening
-  ;;
-
-  module Zoned = struct
-    open Zoned
-
-    type nonrec t = t [@@deriving bin_io]
-
-    let arg_type = arg_type
-    let pp = pp
-
-    module Ofday_zoned_constants = struct
-      let opaque = Sys.opaque_identity
-      let utc = opaque Time.Zone.utc
-      let date = opaque (Date.create_exn ~y:2013 ~m:Oct ~d:07)
-      let zero_utc = create start_of_day utc |> opaque
-
-      let example =
-        create Ofday_constants.example (Zone.find_exn "America/New_York") |> opaque
-      ;;
-
-      let example_sexp = sexp_of_t example |> opaque
-      let example_string = to_string example |> opaque
-    end
-
-    include Ofday_zoned_constants
-
-    module With_nonchronological_compare = struct
-      open With_nonchronological_compare
-
-      type nonrec t = t [@@deriving bin_io]
-
-      let compare = compare
-      let%bench "compare (<)" = compare zero_utc example
-      let%bench "compare (>)" = compare example zero_utc
-      let%bench "compare (=)" = compare zero_utc zero_utc
-      let equal = equal
-      let%bench "equal (=)" = equal example example
-      let%bench "equal (<>)" = equal zero_utc example
-      let hash = hash
-      let%bench "hash" = hash zero_utc
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t" = sexp_of_t example
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp" = t_of_sexp example_sexp
-    end
-
-    let hash = hash
-    let%bench "hash" = hash zero_utc
-    let hash_fold_t = hash_fold_t
-    let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-    let create = create
-    let%bench "create" = create Ofday_constants.example utc
-    let create_local = create_local
-    let%bench "create_local" = create_local Ofday_constants.example
-    let ofday = ofday
-    let%bench "ofday" = ofday example
-    let zone = zone
-    let%bench "zone" = zone example
-    let to_time_ns = to_time_ns
-    let%bench "to_time_ns" = to_time_ns example date
-    let sexp_of_t = sexp_of_t
-    let%bench "sexp_of_t" = sexp_of_t example
-    let t_of_sexp = t_of_sexp
-    let%bench "t_of_sexp" = t_of_sexp example_sexp
-    let to_string = to_string
-    let%bench "to_string" = to_string example
-    let of_string = of_string
-    let%bench "of_string" = of_string example_string
-
-    module Stable = struct
-      open Stable
-
-      module V1 = struct
-        open V1
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-
-        let compare = compare
-        let%bench "compare (<)" = compare zero_utc example
-        let%bench "compare (>)" = compare example zero_utc
-        let%bench "compare (=)" = compare zero_utc zero_utc
-        let hash = hash
-        let%bench "hash" = hash zero_utc
-        let hash_fold_t = hash_fold_t
-        let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t" = sexp_of_t example
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp" = t_of_sexp example_sexp
-      end
-    end
-  end
-
-  module Option = struct
-    open Option
-    module Diff = Diff
-    module Map = Map
-    module Set = Set
-    module Table = Table
-    module Hash_set = Hash_set
-    module Hash_queue = Hash_queue
-
-    type nonrec t = t [@@deriving bin_io, quickcheck, typerep]
-    type nonrec comparator_witness = comparator_witness
-
-    let comparator = comparator
-    let hashable = hashable
-    let pp = pp
-    let none = opaque none
-
-    module Ofday_option_constants = struct
-      let some_start_of_day = opaque (some start_of_day)
-      let some_morning = opaque (some morning)
-      let some_evening = opaque (some evening)
-      let some_start_of_day_option = opaque (Some start_of_day)
-      let sexp_of_none = opaque (sexp_of_t none)
-      let sexp_of_some_start_of_day = opaque (sexp_of_t some_start_of_day)
-      let string_of_none = opaque (to_string none)
-      let string_of_some_start_of_day = opaque (to_string some_start_of_day)
-      let int63_of_none = opaque (Stable.V1.to_int63 none)
-      let int63_of_some_start_of_day = opaque (Stable.V1.to_int63 some_start_of_day)
-    end
-
-    open Ofday_option_constants
-
-    let hash = hash
-    let%bench "hash" = hash some_start_of_day
-    let hash_fold_t = hash_fold_t
-    let%bench "hash_fold_t" = hash_fold_t hash_state some_start_of_day
-
-    module Replace_polymorphic_compare = struct
-      open Replace_polymorphic_compare
-
-      let compare = compare
-      let%bench "compare" = compare none some_start_of_day
-      let equal = equal
-      let%bench "equal" = equal none some_start_of_day
-      let min = min
-      let%bench "min" = min none some_start_of_day
-      let max = max
-      let%bench "max" = max none some_start_of_day
-      let ( = ) = ( = )
-      let%bench "(=)" = none = some_start_of_day
-      let ( < ) = ( < )
-      let%bench "(<)" = none < some_start_of_day
-      let ( > ) = ( > )
-      let%bench "(>)" = none > some_start_of_day
-      let ( <> ) = ( <> )
-      let%bench "(<>)" = none <> some_start_of_day
-      let ( <= ) = ( <= )
-      let%bench "(<=)" = none <= some_start_of_day
-      let ( >= ) = ( >= )
-      let%bench "(>=)" = none >= some_start_of_day
-    end
-
-    let compare = compare
-    let%bench "compare" = compare none some_start_of_day
-    let ascending = ascending
-    let%bench "ascending" = ascending none some_start_of_day
-    let descending = descending
-    let%bench "descending" = descending none some_start_of_day
-    let equal = equal
-    let%bench "equal" = equal none some_start_of_day
-    let min = min
-    let%bench "min" = min none some_start_of_day
-    let max = max
-    let%bench "max" = max none some_start_of_day
-    let ( = ) = ( = )
-    let%bench "(=)" = none = some_start_of_day
-    let ( < ) = ( < )
-    let%bench "(<)" = none < some_start_of_day
-    let ( > ) = ( > )
-    let%bench "(>)" = none > some_start_of_day
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = none <> some_start_of_day
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = none <= some_start_of_day
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = none >= some_start_of_day
-    let between = between
-    let%bench "between" = between ~low:none ~high:some_morning some_evening
-    let clamp_exn = clamp_exn
-    let%bench "clamp_exn" = clamp_exn ~min:none ~max:some_morning some_evening
-    let clamp = clamp
-    let%bench "clamp" = clamp ~min:none ~max:some_morning some_evening
-    let validate_ubound = validate_ubound
-
-    let%bench "validate_ubound (success)" =
-      (validate_ubound ~max:(Incl some_morning) some_morning : Validate.t)
-    ;;
-
-    let%bench "validate_ubound (failure)" =
-      (validate_ubound ~max:(Excl some_morning) some_morning : Validate.t)
-    ;;
-
-    let validate_lbound = validate_lbound
-
-    let%bench "validate_lbound (success)" =
-      (validate_lbound ~min:(Incl some_morning) some_morning : Validate.t)
-    ;;
-
-    let%bench "validate_lbound (failure)" =
-      (validate_lbound ~min:(Excl some_morning) some_morning : Validate.t)
-    ;;
-
-    let validate_bound = validate_bound
-
-    let%bench "validate_bound (success)" =
-      (validate_bound ~min:(Excl none) ~max:(Excl some_evening) some_morning : Validate.t)
-    ;;
-
-    let%bench "validate_bound (failure)" =
-      (validate_bound ~min:(Excl none) ~max:(Excl some_evening) none : Validate.t)
-    ;;
-
-    let some = some
-    let%bench "some" = some start_of_day
-    let is_none = is_none
-    let%bench "is_none" = is_none some_start_of_day
-    let is_some = is_some
-    let%bench "is_some" = is_some some_start_of_day
-    let value_exn = value_exn
-    let%bench "value_exn" = value_exn some_start_of_day
-    let unchecked_value = unchecked_value
-    let%bench "unchecked_value" = unchecked_value some_start_of_day
-    let value = value
-    let%bench "value (none)" = value none ~default:start_of_day
-    let%bench "value (some)" = value some_start_of_day ~default:start_of_day
-    let some_is_representable = some_is_representable
-    let%bench "some_is_representable" = some_is_representable start_of_day
-    let of_option = of_option
-    let%bench "of_option" = of_option some_start_of_day_option
-    let to_option = to_option
-    let%bench "to_option" = to_option some_start_of_day
-    let sexp_of_t = sexp_of_t
-    let%bench "sexp_of_t (none)" = sexp_of_t none
-    let%bench "sexp_of_t (some)" = sexp_of_t some_start_of_day
-    let t_of_sexp = t_of_sexp
-    let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-    let%bench "t_of_sexp (some)" = t_of_sexp sexp_of_some_start_of_day
-    let to_string = to_string
-    let%bench "to_string (none)" = to_string none
-    let%bench "to_string (some)" = to_string some_start_of_day
-    let of_string = of_string
-    let%bench "of_string (none)" = of_string string_of_none
-    let%bench "of_string (some)" = of_string string_of_some_start_of_day
-    let of_span_since_start_of_day = of_span_since_start_of_day
-
-    let%bench "of_span_since_start_of_day (midnight)" =
-      of_span_since_start_of_day start_of_day_span
-    ;;
-
-    let%bench "of_span_since_start_of_day (morning)" =
-      of_span_since_start_of_day morning_span
-    ;;
-
-    let%bench "of_span_since_start_of_day (evening)" =
-      of_span_since_start_of_day evening_span
-    ;;
 
-    let%bench "of_span_since_start_of_day (max_value)" =
-      of_span_since_start_of_day Span.max_value
-    ;;
-
-    let%bench "of_span_since_start_of_day (min_value)" =
-      of_span_since_start_of_day Span.min_value_for_1us_rounding
-    ;;
-
-    module Optional_syntax = struct
-      open Optional_syntax
-
-      module Optional_syntax = struct
-        open Optional_syntax
-
-        let is_none = is_none
-        let%bench "is_none" = is_none some_start_of_day
-        let unsafe_value = unsafe_value
-        let%bench "unsafe_value" = unsafe_value some_start_of_day
-      end
-    end
-
-    module Stable = struct
-      open Stable
-
-      module V1 = struct
-        open V1
-        module Diff = Diff
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let compare = compare
-        let%bench "compare" = compare none some_start_of_day
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t (none)" = sexp_of_t none
-        let%bench "sexp_of_t (some)" = sexp_of_t some_start_of_day
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-        let%bench "t_of_sexp (some)" = t_of_sexp sexp_of_some_start_of_day
-        let to_int63 = to_int63
-        let%bench "to_int63 (none)" = to_int63 none
-        let%bench "to_int63 (some)" = to_int63 some_start_of_day
-        let of_int63_exn = of_int63_exn
-        let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-        let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_start_of_day
-      end
-    end
-  end
-
-  module Stable = struct
-    open Stable
-
-    module V1 = struct
-      open V1
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, sexp_grammar, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let hash = hash
-      let%bench "hash" = hash start_of_day
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state start_of_day
-      let compare = compare
-      let%bench "compare" = compare start_of_day evening
-      let equal = equal
-      let%bench "equal" = equal start_of_day start_of_next_day
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (midnight)" = sexp_of_t start_of_day
-      let%bench "sexp_of_t (morning)" = sexp_of_t morning
-      let%bench "sexp_of_t (evening)" = sexp_of_t evening
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (midnight)" = t_of_sexp sexp_of_start_of_day
-      let%bench "t_of_sexp (morning)" = t_of_sexp sexp_of_morning
-      let%bench "t_of_sexp (evening)" = t_of_sexp sexp_of_evening
-      let to_int63 = to_int63
-      let%bench "to_int63" = to_int63 start_of_day
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn" = of_int63_exn int63_of_start_of_day
-    end
-  end
-end
-
-type nonrec t = t [@@deriving bin_io, quickcheck, sexp_grammar, typerep]
-type nonrec comparator_witness = comparator_witness
-
-let arg_type = arg_type
-let comparator = comparator
-let hashable = hashable
-let pp = pp
 let pause = pause
 let pause_forever = pause_forever
 let interruptible_pause = interruptible_pause
-let gen_incl = gen_incl
-let gen_uniform_incl = gen_uniform_incl
-
-module Diff = Diff
-module Map = Map
-module Set = Set
-module Table = Table
-module Hash_set = Hash_set
-module Hash_queue = Hash_queue
-module Zone = Time.Zone
-module O = O
-
-let epoch = opaque epoch
-let min_value_representable = opaque min_value_representable
-let max_value_representable = opaque max_value_representable
-let min_value_for_1us_rounding = opaque min_value_for_1us_rounding
-let max_value_for_1us_rounding = opaque max_value_for_1us_rounding
-let min_value = opaque min_value_for_1us_rounding
-let max_value = opaque max_value_for_1us_rounding
-
-module Time_constants = struct
-  let example = of_date_ofday ~zone:Zone.utc date Ofday.Ofday_constants.example |> opaque
-  let zone_for_sexp = get_sexp_zone () |> opaque
-  let example_sexp = sexp_of_t example |> opaque
-  let example_string = to_string example |> opaque
-  let example_localized_string = opaque (to_sec_string example ~zone:Zone.utc)
-  let example_formatted = format example "%F %T%z" ~zone:Zone.utc |> opaque
-  let dst_t = Ofday.Ofday_constants.dst_time_ns
-  let no_dst_t = Ofday.Ofday_constants.no_dst_time_ns
-  let epoch_time = opaque (to_time_float_round_nearest epoch)
-  let sexp_of_epoch = opaque (sexp_of_t epoch)
-  let sexp_of_dst_t = opaque (sexp_of_t dst_t)
-  let sexp_of_no_dst_t = opaque (sexp_of_t no_dst_t)
-  let string_of_epoch = opaque (to_string epoch)
-  let string_of_dst_t = opaque (to_string dst_t)
-  let string_of_no_dst_t = opaque (to_string no_dst_t)
-  let fix_utc_string_of_epoch = opaque (to_string_fix_proto `Utc epoch)
-  let fix_local_string_of_dst_t = opaque (to_string_fix_proto `Local dst_t)
-  let fix_local_string_of_no_dst_t = opaque (to_string_fix_proto `Local no_dst_t)
-  let abs_string_of_epoch = opaque (to_string_abs epoch ~zone:Zone.utc)
-  let abs_string_of_dst_t = opaque (to_string_abs dst_t ~zone)
-  let abs_string_of_no_dst_t = opaque (to_string_abs no_dst_t ~zone)
-  let filename_string_of_epoch = opaque (to_filename_string epoch ~zone:Zone.utc)
-  let filename_string_of_dst_t = opaque (to_filename_string dst_t ~zone)
-  let filename_string_of_no_dst_t = opaque (to_filename_string no_dst_t ~zone)
-  let int63_of_epoch = opaque (Stable.V1.to_int63 epoch)
-
-  (* We define some dates and times with different daylight savings properties for
-     purposes of benchmarking time zone logic. *)
-
-  let nyc_winter_date = opaque (Date.create_exn ~y:2013 ~m:Jan ~d:03)
-  let nyc_summer_date = opaque (Date.create_exn ~y:2014 ~m:Jul ~d:04)
-  let nyc_transition_date = opaque (Date.create_exn ~y:2015 ~m:Nov ~d:01)
-  let nyc_transition_ofday = opaque (Time_ns.Ofday.create ~hr:01 ~min:30 ())
-  let nyc_skip_date = opaque (Date.create_exn ~y:2015 ~m:Mar ~d:08)
-  let nyc_skip_ofday = opaque (Time_ns.Ofday.create ~hr:02 ~min:30 ())
-
-  let nyc_winter_time =
-    opaque (Time_ns.of_date_ofday ~zone:nyc nyc_winter_date Ofday.Ofday_constants.noon)
-  ;;
-
-  let nyc_summer_time =
-    opaque (Time_ns.of_date_ofday ~zone:nyc nyc_summer_date Ofday.Ofday_constants.noon)
-  ;;
-
-  let nyc_transition_time =
-    opaque (Time_ns.of_date_ofday ~zone:nyc nyc_transition_date nyc_transition_ofday)
-  ;;
-
-  let nyc_skip_time =
-    opaque (Time_ns.of_date_ofday ~zone:nyc nyc_skip_date nyc_skip_ofday)
-  ;;
-
-  let%test_module "daylight savings" =
-    (module struct
-      type precise =
-        Date.t
-        * Time_ns.Ofday.t
-        * [ `Also_at of Time_ns.t | `Also_skipped of Date.t * Time_ns.Ofday.t | `Only ]
-      [@@deriving sexp_of]
-
-      let test_time time =
-        printf !"%{sexp: Time_ns.t}\n" time;
-        printf !"%{sexp: precise}\n" (Time_ns.to_date_ofday_precise ~zone:nyc time)
-      ;;
-
-      let%expect_test "winter" =
-        test_time nyc_winter_time;
-        [%expect
-          {|
-          (2013-01-03 12:00:00.000000000-05:00)
-          (2013-01-03 12:00:00.000000000 Only)
-          |}]
-      ;;
-
-      let%expect_test "summer" =
-        test_time nyc_summer_time;
-        [%expect
-          {|
-          (2014-07-04 12:00:00.000000000-04:00)
-          (2014-07-04 12:00:00.000000000 Only)
-          |}]
-      ;;
-
-      let%expect_test "transition" =
-        test_time nyc_transition_time;
-        [%expect
-          {|
-          (2015-11-01 01:30:00.000000000-05:00)
-          (2015-11-01 01:30:00.000000000
-           (Also_at (2015-11-01 01:30:00.000000000-04:00)))
-          |}]
-      ;;
-
-      let%expect_test "skip" =
-        test_time nyc_skip_time;
-        [%expect
-          {|
-          (2015-03-08 03:30:00.000000000-04:00)
-          (2015-03-08 03:30:00.000000000
-           (Also_skipped (2015-03-08 02:30:00.000000000)))
-          |}]
-      ;;
-    end)
-  ;;
-end
-
-open Time_constants
-
-let hash = hash
-let%bench "hash" = hash epoch
-let hash_fold_t = hash_fold_t
-let%bench "hash_fold_t" = hash_fold_t hash_state epoch
-
-module Replace_polymorphic_compare = struct
-  open Replace_polymorphic_compare
-
-  let compare = compare
-  let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-  let equal = equal
-  let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-  let min = min
-  let%bench "min" = min min_value_for_1us_rounding max_value_for_1us_rounding
-  let max = max
-  let%bench "max" = max min_value_for_1us_rounding max_value_for_1us_rounding
-  let ( = ) = ( = )
-  let%bench "(=)" = min_value_for_1us_rounding = max_value_for_1us_rounding
-  let ( < ) = ( < )
-  let%bench "(<)" = min_value_for_1us_rounding < max_value_for_1us_rounding
-  let ( > ) = ( > )
-  let%bench "(>)" = min_value_for_1us_rounding > max_value_for_1us_rounding
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = min_value_for_1us_rounding <> max_value_for_1us_rounding
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = min_value_for_1us_rounding <= max_value_for_1us_rounding
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = min_value_for_1us_rounding >= max_value_for_1us_rounding
-end
-
-let compare = compare
-let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-let ascending = ascending
-let%bench "ascending" = ascending min_value_for_1us_rounding max_value_for_1us_rounding
-let descending = descending
-let%bench "descending" = descending min_value_for_1us_rounding max_value_for_1us_rounding
-let equal = equal
-let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-let min = min
-let%bench "min" = min min_value_for_1us_rounding max_value_for_1us_rounding
-let max = max
-let%bench "max" = max min_value_for_1us_rounding max_value_for_1us_rounding
-let ( = ) = ( = )
-let%bench "(=)" = min_value_for_1us_rounding = max_value_for_1us_rounding
-let ( < ) = ( < )
-let%bench "(<)" = min_value_for_1us_rounding < max_value_for_1us_rounding
-let ( > ) = ( > )
-let%bench "(>)" = min_value_for_1us_rounding > max_value_for_1us_rounding
-let ( <> ) = ( <> )
-let%bench "(<>)" = min_value_for_1us_rounding <> max_value_for_1us_rounding
-let ( <= ) = ( <= )
-let%bench "(<=)" = min_value_for_1us_rounding <= max_value_for_1us_rounding
-let ( >= ) = ( >= )
-let%bench "(>=)" = min_value_for_1us_rounding >= max_value_for_1us_rounding
-let is_earlier = is_earlier
-
-let%bench "is_earlier" =
-  is_earlier min_value_for_1us_rounding ~than:max_value_for_1us_rounding
-;;
-
-let is_later = is_later
-
-let%bench "is_later" =
-  is_later min_value_for_1us_rounding ~than:max_value_for_1us_rounding
-;;
-
-let between = between
-
-let%bench "between" =
-  between ~low:min_value_for_1us_rounding ~high:max_value_for_1us_rounding epoch
-;;
-
-let clamp_exn = clamp_exn
-
-let%bench "clamp_exn" =
-  clamp_exn ~min:min_value_for_1us_rounding ~max:max_value_for_1us_rounding epoch
-;;
-
-let clamp = clamp
-
-let%bench "clamp" =
-  clamp ~min:min_value_for_1us_rounding ~max:max_value_for_1us_rounding epoch
-;;
-
-let validate_ubound = validate_ubound
-
-let%bench "validate_ubound (success)" =
-  (validate_ubound ~max:(Incl epoch) epoch : Validate.t)
-;;
-
-let%bench "validate_ubound (failure)" =
-  (validate_ubound ~max:(Excl epoch) epoch : Validate.t)
-;;
-
-let validate_lbound = validate_lbound
-
-let%bench "validate_lbound (success)" =
-  (validate_lbound ~min:(Incl epoch) epoch : Validate.t)
-;;
-
-let%bench "validate_lbound (failure)" =
-  (validate_lbound ~min:(Excl epoch) epoch : Validate.t)
-;;
-
-let validate_bound = validate_bound
-
-let%bench "validate_bound (success)" =
-  (validate_bound
-     ~min:(Excl min_value_for_1us_rounding)
-     ~max:(Excl max_value_for_1us_rounding)
-     epoch
-    : Validate.t)
-;;
-
-let%bench "validate_bound (failure)" =
-  (validate_bound
-     ~min:(Excl min_value_for_1us_rounding)
-     ~max:(Excl max_value_for_1us_rounding)
-     min_value_for_1us_rounding
-    : Validate.t)
-;;
-
-let to_time_float_round_nearest = to_time_float_round_nearest
-let%bench "to_time_float_round_nearest" = to_time_float_round_nearest epoch
-let of_time_float_round_nearest = of_time_float_round_nearest
-let%bench "of_time_float_round_nearest" = of_time_float_round_nearest epoch_time
-let to_time = to_time_float_round_nearest_microsecond
-let to_time_float_round_nearest_microsecond = to_time_float_round_nearest_microsecond
-
-let%bench "to_time_float_round_nearest_microsecond" =
-  to_time_float_round_nearest_microsecond epoch
-;;
-
-let of_time = of_time_float_round_nearest_microsecond
-let of_time_float_round_nearest_microsecond = of_time_float_round_nearest_microsecond
-
-let%bench "of_time_float_round_nearest_microsecond" =
-  of_time_float_round_nearest_microsecond epoch_time
-;;
-
-let now = now
-let%bench "now" = now ()
-let add = add
-let%bench "add" = add epoch Span.day
-let sub = sub
-let%bench "sub" = sub epoch Span.day
-let add_saturating = add_saturating
-let%bench "add_saturating (ok)" = add epoch Span.day
-let%bench "add_saturating (saturates)" = add max_value_representable Span.day
-let sub_saturating = sub_saturating
-let%bench "sub_saturating (ok)" = sub epoch Span.day
-let%bench "sub_saturating (saturates)" = sub min_value_representable Span.day
-let next = next
-let%bench "next" = next example
-let prev = prev
-let%bench "prev" = prev example
-let diff = diff
-let%bench "diff" = diff dst_t no_dst_t
-let abs_diff = abs_diff
-let%bench "abs_diff" = abs_diff dst_t no_dst_t
-let to_span_since_epoch = to_span_since_epoch
-let%bench "to_span_since_epoch" = to_span_since_epoch max_value_for_1us_rounding
-let of_span_since_epoch = of_span_since_epoch
-let%bench "of_span_since_epoch" = of_span_since_epoch Span.day
-let to_int63_ns_since_epoch = to_int63_ns_since_epoch
-let%bench "to_int63_ns_since_epoch" = to_int63_ns_since_epoch max_value_for_1us_rounding
-let of_int63_ns_since_epoch = of_int63_ns_since_epoch
-let%bench "of_int63_ns_since_epoch" = of_int63_ns_since_epoch int63_ten
-let to_int_ns_since_epoch = to_int_ns_since_epoch
-let%bench "to_int_ns_since_epoch" = to_int_ns_since_epoch max_value_for_1us_rounding
-let of_int_ns_since_epoch = of_int_ns_since_epoch
-let%bench "of_int_ns_since_epoch" = of_int_ns_since_epoch int_ten
-
-(* Basically any function that uses zones (not just these) uses a zone cache too, so we're
-   benchmarking the "hot-cache" cases here. See bench_zone.ml for benchmarks that always
-   reset the cache first. *)
-let of_date_ofday = of_date_ofday
-
-let%bench "of_date_ofday (est)" =
-  of_date_ofday ~zone:nyc nyc_winter_date Ofday.Ofday_constants.noon
-;;
-
-let%bench "of_date_ofday (edt)" =
-  of_date_ofday ~zone:nyc nyc_summer_date Ofday.Ofday_constants.noon
-;;
-
-let%bench "of_date_ofday (e?t)" =
-  of_date_ofday ~zone:nyc nyc_transition_date nyc_transition_ofday
-;;
-
-let%bench "of_date_ofday (n/a)" = of_date_ofday ~zone:nyc nyc_skip_date nyc_skip_ofday
-let of_date_ofday_precise = of_date_ofday_precise
-
-let%bench "of_date_ofday_precise (est)" =
-  of_date_ofday_precise ~zone:nyc nyc_winter_date Ofday.Ofday_constants.noon
-;;
-
-let%bench "of_date_ofday_precise (edt)" =
-  of_date_ofday_precise ~zone:nyc nyc_summer_date Ofday.Ofday_constants.noon
-;;
-
-let%bench "of_date_ofday_precise (e?t)" =
-  of_date_ofday_precise ~zone:nyc nyc_transition_date nyc_transition_ofday
-;;
-
-let%bench "of_date_ofday_precise (n/a)" =
-  of_date_ofday_precise ~zone:nyc nyc_skip_date nyc_skip_ofday
-;;
-
-(* These benchmarks use the date cache (see [reset_date_cache]). There are benchmarks
-   that bypass the cache in bench_zone.ml. *)
-let to_date_ofday = to_date_ofday
-let%bench "to_date_ofday (est)" = to_date_ofday ~zone:nyc nyc_winter_time
-let%bench "to_date_ofday (edt)" = to_date_ofday ~zone:nyc nyc_summer_time
-let%bench "to_date_ofday (e?t)" = to_date_ofday ~zone:nyc nyc_transition_time
-
-(* The following three functions build on [to_date_ofday] so have the same caching
-   caveats. *)
-let to_date_ofday_precise = to_date_ofday_precise
-let%bench "to_date_ofday_precise (est)" = to_date_ofday_precise ~zone:nyc nyc_winter_time
-let%bench "to_date_ofday_precise (edt)" = to_date_ofday_precise ~zone:nyc nyc_summer_time
-
-let%bench "to_date_ofday_precise (e?t)" =
-  to_date_ofday_precise ~zone:nyc nyc_transition_time
-;;
-
-let to_date = to_date
-let%bench "to_date (utc)" = to_date epoch ~zone:Zone.utc
-let%bench "to_date (w/ dst)" = to_date dst_t ~zone
-let%bench "to_date (w/o dst)" = to_date no_dst_t ~zone
-let to_ofday = to_ofday
-let%bench "to_ofday (utc)" = to_ofday epoch ~zone:Zone.utc
-let%bench "to_ofday (w/ dst)" = to_ofday dst_t ~zone
-let%bench "to_ofday (w/o dst)" = to_ofday no_dst_t ~zone
-let of_date_ofday_zoned = of_date_ofday_zoned
-
-let%bench "of_date_ofday_zoned" =
-  of_date_ofday_zoned date Ofday.Zoned.Ofday_zoned_constants.example
-;;
-
-let to_date_ofday_zoned = to_date_ofday_zoned
-let%bench "to_date_ofday_zoned (est)" = to_date_ofday_zoned nyc_winter_time ~zone:nyc
-let to_ofday_zoned = to_ofday_zoned
-let%bench "to_ofday_zoned (est)" = to_ofday_zoned nyc_winter_time ~zone:nyc
-
-(* This function is only meant for use in benchmarks: slowing it down doesn't matter in
-   itself but seems important to know about for the interpretation of other benchmarks. *)
-let reset_date_cache = reset_date_cache
-let%bench "reset_date_cache" = reset_date_cache ()
-let convert = convert
-
-let%bench "convert" =
-  convert ~from_tz:Zone.utc ~to_tz:Zone.utc date Ofday.Ofday_constants.example
-;;
-
-let utc_offset = utc_offset
-let%bench "utc_offset" = utc_offset example ~zone:Zone.utc
-let next_multiple = next_multiple
-
-let%bench "next_multiple" =
-  next_multiple ~base:min_value_for_1us_rounding ~after:epoch ~interval:Span.minute ()
-;;
-
-let prev_multiple = prev_multiple
-
-let%bench "prev_multiple" =
-  prev_multiple ~base:min_value_for_1us_rounding ~before:epoch ~interval:Span.minute ()
-;;
-
-let round_up_to_us = round_up_to_us
-let%bench "round_up_to_us" = round_up_to_us min_value_for_1us_rounding
-let round_up_to_ms = round_up_to_ms
-let%bench "round_up_to_ms" = round_up_to_ms min_value_for_1us_rounding
-let round_up_to_sec = round_up_to_sec
-let%bench "round_up_to_sec" = round_up_to_sec min_value_for_1us_rounding
-let round_down_to_us = round_down_to_us
-let%bench "round_down_to_us" = round_down_to_us min_value_for_1us_rounding
-let round_down_to_ms = round_down_to_ms
-let%bench "round_down_to_ms" = round_down_to_ms min_value_for_1us_rounding
-let round_down_to_sec = round_down_to_sec
-let%bench "round_down_to_sec" = round_down_to_sec min_value_for_1us_rounding
-let occurrence = occurrence
-
-let%bench "occurrence" =
-  occurrence `First_after_or_at dst_t ~ofday:Ofday.start_of_day ~zone
-;;
-
-let set_sexp_zone = set_sexp_zone
-let%bench "set_sexp_zone" = set_sexp_zone zone_for_sexp
-let get_sexp_zone = get_sexp_zone
-let%bench "get_sexp_zone" = get_sexp_zone ()
-let random = random
-let%bench "random" = random ()
-let sexp_of_t = sexp_of_t
-let%bench "sexp_of_t (epoch)" = sexp_of_t epoch
-let%bench "sexp_of_t (w/ dst)" = sexp_of_t dst_t
-let%bench "sexp_of_t (w/o dst)" = sexp_of_t no_dst_t
-let t_of_sexp = t_of_sexp
-let%bench "t_of_sexp (epoch)" = t_of_sexp sexp_of_epoch
-let%bench "t_of_sexp (w/ dst)" = t_of_sexp sexp_of_dst_t
-let%bench "t_of_sexp (w/o dst)" = t_of_sexp sexp_of_no_dst_t
-let sexp_of_t_abs = sexp_of_t_abs
-let%bench "sexp_of_t_abs" = sexp_of_t_abs ~zone:Zone.utc example
-let t_of_sexp_abs = t_of_sexp_abs
-let%bench "t_of_sexp_abs" = t_of_sexp_abs example_sexp
-let to_string = to_string
-let%bench "to_string (epoch)" = to_string epoch
-let%bench "to_string (w/ dst)" = to_string dst_t
-let%bench "to_string (w/o dst)" = to_string no_dst_t
-let to_string_utc = to_string_utc
-let%bench "to_string_utc (epoch)" = to_string_utc epoch
-let%bench "to_string_utc (w/ dst)" = to_string_utc dst_t
-let%bench "to_string_utc (w/o dst)" = to_string_utc no_dst_t
-let of_string = of_string
-let%bench "of_string (epoch)" = of_string string_of_epoch
-let%bench "of_string (w/ dst)" = of_string string_of_dst_t
-let%bench "of_string (w/o dst)" = of_string string_of_no_dst_t
-let of_string_with_utc_offset = of_string_with_utc_offset
-let%bench "of_string_with_utc_offset (epoch)" = of_string_with_utc_offset string_of_epoch
-let%bench "of_string_with_utc_offset (w/ dst)" = of_string_with_utc_offset string_of_dst_t
-
-let%bench "of_string_with_utc_offset (w/o dst)" =
-  of_string_with_utc_offset string_of_no_dst_t
-;;
-
-let to_sec_string = to_sec_string
-let%bench "to_sec_string (utc)" = to_sec_string ~zone:Zone.utc epoch
-let%bench "to_sec_string (w/ dst)" = to_sec_string ~zone dst_t
-let%bench "to_sec_string (w/o dst)" = to_sec_string ~zone no_dst_t
-let to_sec_string_with_zone = to_sec_string_with_zone
-let%bench "to_sec_string_with_zone (utc)" = to_sec_string_with_zone ~zone:Zone.utc epoch
-let%bench "to_sec_string_with_zone (w/ dst)" = to_sec_string_with_zone ~zone dst_t
-let%bench "to_sec_string_with_zone (w/o dst)" = to_sec_string_with_zone ~zone no_dst_t
-let of_localized_string = of_localized_string
-
-let%bench "of_localized_string" =
-  of_localized_string ~zone:Zone.utc example_localized_string
-;;
-
-let of_string_gen = of_string_gen
-let%bench "of_string_gen" = of_string_gen ~if_no_timezone:`Local example_string
-let to_filename_string = to_filename_string
-let%bench "to_filename_string (utc)" = to_filename_string ~zone:Zone.utc epoch
-let%bench "to_filename_string (w/ dst)" = to_filename_string ~zone dst_t
-let%bench "to_filename_string (w/o dst)" = to_filename_string ~zone no_dst_t
-let of_filename_string = of_filename_string
-
-let%bench "of_filename_string (utc)" =
-  of_filename_string ~zone:Zone.utc filename_string_of_epoch
-;;
-
-let%bench "of_filename_string (w/ dst)" =
-  of_filename_string ~zone filename_string_of_dst_t
-;;
-
-let%bench "of_filename_string (w/o dst)" =
-  of_filename_string ~zone filename_string_of_no_dst_t
-;;
-
-let to_string_trimmed = to_string_trimmed
-let%bench "to_string_trimmed" = to_string_trimmed ~zone:Zone.utc example
-let to_string_abs = to_string_abs
-let%bench "to_string_abs (utc)" = to_string_abs ~zone:Zone.utc epoch
-let%bench "to_string_abs (w/ dst)" = to_string_abs ~zone dst_t
-let%bench "to_string_abs (w/o dst)" = to_string_abs ~zone no_dst_t
-let of_string_abs = of_string_abs
-let%bench "of_string_abs (utc)" = of_string_abs abs_string_of_epoch
-let%bench "of_string_abs (w/ dst)" = of_string_abs abs_string_of_dst_t
-let%bench "of_string_abs (w/o dst)" = of_string_abs abs_string_of_no_dst_t
-let to_string_abs_trimmed = to_string_abs_trimmed
-let%bench "to_string_abs_trimmed" = to_string_abs_trimmed ~zone:Zone.utc example
-let to_string_abs_parts = to_string_abs_parts
-let%bench "to_string_abs_parts" = to_string_abs_parts ~zone:Zone.utc example
-let to_string_iso8601_basic = to_string_iso8601_basic
-let%bench "to_string_iso8601_basic" = to_string_iso8601_basic ~zone:Zone.utc example
-let to_string_fix_proto = to_string_fix_proto
-let%bench "to_string_fix_proto (utc)" = to_string_fix_proto `Utc epoch
-let%bench "to_string_fix_proto (w/ dst)" = to_string_fix_proto `Local dst_t
-let%bench "to_string_fix_proto (w/o dst)" = to_string_fix_proto `Local no_dst_t
-let of_string_fix_proto = of_string_fix_proto
-let%bench "of_string_fix_proto (utc)" = of_string_fix_proto `Utc fix_utc_string_of_epoch
-
-let%bench "of_string_fix_proto (w/ dst)" =
-  of_string_fix_proto `Local fix_local_string_of_dst_t
-;;
-
-let%bench "of_string_fix_proto (w/o dst)" =
-  of_string_fix_proto `Local fix_local_string_of_no_dst_t
-;;
-
 let format = format
 let%bench "format" = format example "%F %T%z" ~zone:Zone.utc
 let parse = parse
 let%bench "parse" = parse example_formatted ~fmt:"%F %T%z" ~zone:Zone.utc
-
-module Utc = struct
-  open Utc
-
-  let to_date_and_span_since_start_of_day = to_date_and_span_since_start_of_day
-
-  let%bench "to_date_and_span_since_start_of_day" =
-    to_date_and_span_since_start_of_day epoch
-  ;;
-
-  let of_date_and_span_since_start_of_day = of_date_and_span_since_start_of_day
-
-  let%bench "of_date_and_span_since_start_of_day" =
-    of_date_and_span_since_start_of_day date Span.Span_constants.pi_hours
-  ;;
-end
-
-module Alternate_sexp = struct
-  open Alternate_sexp
-  module Set = Set
-  module Map = Map
-  module Diff = Diff
-
-  type nonrec t = t [@@deriving bin_io, sexp_grammar]
-  type nonrec comparator_witness = comparator_witness
-
-  let comparator = comparator
-
-  module Alternate_sexp_constants = struct
-    let sexp_of_epoch = opaque (sexp_of_t epoch)
-  end
-
-  open Alternate_sexp_constants
-
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t" = sexp_of_t epoch
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp" = t_of_sexp sexp_of_epoch
-  let hash = hash
-  let%bench "hash" = hash epoch
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state epoch
-  let compare = compare
-  let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-  let ascending = ascending
-  let%bench "ascending" = ascending min_value_for_1us_rounding max_value_for_1us_rounding
-  let descending = descending
-
-  let%bench "descending" =
-    descending min_value_for_1us_rounding max_value_for_1us_rounding
-  ;;
-
-  let equal = equal
-  let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-  let min = min
-  let%bench "min" = min min_value_for_1us_rounding max_value_for_1us_rounding
-  let max = max
-  let%bench "max" = max min_value_for_1us_rounding max_value_for_1us_rounding
-  let ( = ) = ( = )
-  let%bench "(=)" = min_value_for_1us_rounding = max_value_for_1us_rounding
-  let ( < ) = ( < )
-  let%bench "(<)" = min_value_for_1us_rounding < max_value_for_1us_rounding
-  let ( > ) = ( > )
-  let%bench "(>)" = min_value_for_1us_rounding > max_value_for_1us_rounding
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = min_value_for_1us_rounding <> max_value_for_1us_rounding
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = min_value_for_1us_rounding <= max_value_for_1us_rounding
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = min_value_for_1us_rounding >= max_value_for_1us_rounding
-  let between = between
-
-  let%bench "between" =
-    between ~low:min_value_for_1us_rounding ~high:max_value_for_1us_rounding epoch
-  ;;
-
-  let clamp_exn = clamp_exn
-
-  let%bench "clamp_exn" =
-    clamp_exn ~min:min_value_for_1us_rounding ~max:max_value_for_1us_rounding epoch
-  ;;
-
-  let clamp = clamp
-
-  let%bench "clamp" =
-    clamp ~min:min_value_for_1us_rounding ~max:max_value_for_1us_rounding epoch
-  ;;
-
-  let validate_ubound = validate_ubound
-
-  let%bench "validate_ubound (success)" =
-    (validate_ubound ~max:(Incl epoch) epoch : Validate.t)
-  ;;
-
-  let%bench "validate_ubound (failure)" =
-    (validate_ubound ~max:(Excl epoch) epoch : Validate.t)
-  ;;
-
-  let validate_lbound = validate_lbound
-
-  let%bench "validate_lbound (success)" =
-    (validate_lbound ~min:(Incl epoch) epoch : Validate.t)
-  ;;
-
-  let%bench "validate_lbound (failure)" =
-    (validate_lbound ~min:(Excl epoch) epoch : Validate.t)
-  ;;
-
-  let validate_bound = validate_bound
-
-  let%bench "validate_bound (success)" =
-    (validate_bound
-       ~min:(Excl min_value_for_1us_rounding)
-       ~max:(Excl max_value_for_1us_rounding)
-       epoch
-      : Validate.t)
-  ;;
-
-  let%bench "validate_bound (failure)" =
-    (validate_bound
-       ~min:(Excl min_value_for_1us_rounding)
-       ~max:(Excl max_value_for_1us_rounding)
-       min_value_for_1us_rounding
-      : Validate.t)
-  ;;
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-    let equal = equal
-    let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-    let min = min
-    let%bench "min" = min min_value_for_1us_rounding max_value_for_1us_rounding
-    let max = max
-    let%bench "max" = max min_value_for_1us_rounding max_value_for_1us_rounding
-    let ( = ) = ( = )
-    let%bench "(=)" = min_value_for_1us_rounding = max_value_for_1us_rounding
-    let ( < ) = ( < )
-    let%bench "(<)" = min_value_for_1us_rounding < max_value_for_1us_rounding
-    let ( > ) = ( > )
-    let%bench "(>)" = min_value_for_1us_rounding > max_value_for_1us_rounding
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = min_value_for_1us_rounding <> max_value_for_1us_rounding
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = min_value_for_1us_rounding <= max_value_for_1us_rounding
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = min_value_for_1us_rounding >= max_value_for_1us_rounding
-  end
-end
-
-module Option = struct
-  open Option
-  module Diff = Diff
-  module Map = Map
-  module Set = Set
-  module Table = Table
-  module Hash_set = Hash_set
-  module Hash_queue = Hash_queue
-
-  type nonrec t = t [@@deriving bin_io, quickcheck, typerep]
-  type nonrec comparator_witness = comparator_witness
-
-  let comparator = comparator
-  let hashable = hashable
-  let pp = pp
-  let none = opaque none
-
-  module Time_option_constants = struct
-    let some_epoch = opaque (some epoch)
-    let some_dst_t = opaque (some dst_t)
-    let some_no_dst_t = opaque (some no_dst_t)
-    let some_epoch_option = opaque (Some epoch)
-    let sexp_of_none = opaque (sexp_of_t none)
-    let sexp_of_some_dst_t = opaque (sexp_of_t some_dst_t)
-    let sexp_of_some_no_dst_t = opaque (sexp_of_t some_no_dst_t)
-    let string_of_none = opaque (to_string none)
-    let string_of_some_dst_t = opaque (to_string some_dst_t)
-    let string_of_some_no_dst_t = opaque (to_string some_no_dst_t)
-    let int63_of_none = opaque (Stable.V1.to_int63 none)
-    let int63_of_some_epoch = opaque (Stable.V1.to_int63 some_epoch)
-  end
-
-  open Time_option_constants
-
-  let hash = hash
-  let%bench "hash" = hash some_epoch
-  let hash_fold_t = hash_fold_t
-  let%bench "hash_fold_t" = hash_fold_t hash_state some_epoch
-
-  module Replace_polymorphic_compare = struct
-    open Replace_polymorphic_compare
-
-    let compare = compare
-    let%bench "compare" = compare none some_epoch
-    let equal = equal
-    let%bench "equal" = equal none some_epoch
-    let min = min
-    let%bench "min" = min none some_epoch
-    let max = max
-    let%bench "max" = max none some_epoch
-    let ( = ) = ( = )
-    let%bench "(=)" = none = some_epoch
-    let ( < ) = ( < )
-    let%bench "(<)" = none < some_epoch
-    let ( > ) = ( > )
-    let%bench "(>)" = none > some_epoch
-    let ( <> ) = ( <> )
-    let%bench "(<>)" = none <> some_epoch
-    let ( <= ) = ( <= )
-    let%bench "(<=)" = none <= some_epoch
-    let ( >= ) = ( >= )
-    let%bench "(>=)" = none >= some_epoch
-  end
-
-  let compare = compare
-  let%bench "compare" = compare none some_epoch
-  let ascending = ascending
-  let%bench "ascending" = ascending none some_epoch
-  let descending = descending
-  let%bench "descending" = descending none some_epoch
-  let equal = equal
-  let%bench "equal" = equal none some_epoch
-  let min = min
-  let%bench "min" = min none some_epoch
-  let max = max
-  let%bench "max" = max none some_epoch
-  let ( = ) = ( = )
-  let%bench "(=)" = none = some_epoch
-  let ( < ) = ( < )
-  let%bench "(<)" = none < some_epoch
-  let ( > ) = ( > )
-  let%bench "(>)" = none > some_epoch
-  let ( <> ) = ( <> )
-  let%bench "(<>)" = none <> some_epoch
-  let ( <= ) = ( <= )
-  let%bench "(<=)" = none <= some_epoch
-  let ( >= ) = ( >= )
-  let%bench "(>=)" = none >= some_epoch
-  let between = between
-  let%bench "between" = between ~low:none ~high:some_epoch some_dst_t
-  let clamp_exn = clamp_exn
-  let%bench "clamp_exn" = clamp_exn ~min:none ~max:some_epoch some_dst_t
-  let clamp = clamp
-  let%bench "clamp" = clamp ~min:none ~max:some_epoch some_dst_t
-  let validate_ubound = validate_ubound
-
-  let%bench "validate_ubound (success)" =
-    (validate_ubound ~max:(Incl some_epoch) some_epoch : Validate.t)
-  ;;
-
-  let%bench "validate_ubound (failure)" =
-    (validate_ubound ~max:(Excl some_epoch) some_epoch : Validate.t)
-  ;;
-
-  let validate_lbound = validate_lbound
-
-  let%bench "validate_lbound (success)" =
-    (validate_lbound ~min:(Incl some_epoch) some_epoch : Validate.t)
-  ;;
-
-  let%bench "validate_lbound (failure)" =
-    (validate_lbound ~min:(Excl some_epoch) some_epoch : Validate.t)
-  ;;
-
-  let validate_bound = validate_bound
-
-  let%bench "validate_bound (success)" =
-    (validate_bound ~min:(Excl none) ~max:(Excl some_dst_t) some_epoch : Validate.t)
-  ;;
-
-  let%bench "validate_bound (failure)" =
-    (validate_bound ~min:(Excl none) ~max:(Excl some_dst_t) none : Validate.t)
-  ;;
-
-  let some = some
-  let%bench "some" = some epoch
-  let is_none = is_none
-  let%bench "is_none" = is_none some_epoch
-  let is_some = is_some
-  let%bench "is_some" = is_some some_epoch
-  let value_exn = value_exn
-  let%bench "value_exn" = value_exn some_epoch
-  let unchecked_value = unchecked_value
-  let%bench "unchecked_value" = unchecked_value some_epoch
-  let value = value
-  let%bench "value (none)" = value none ~default:min_value_for_1us_rounding
-  let%bench "value (some)" = value some_epoch ~default:min_value_for_1us_rounding
-  let some_is_representable = some_is_representable
-  let%bench "some_is_representable" = some_is_representable epoch
-  let of_option = of_option
-  let%bench "of_option" = of_option some_epoch_option
-  let to_option = to_option
-  let%bench "to_option" = to_option some_epoch
-  let sexp_of_t = sexp_of_t
-  let%bench "sexp_of_t (none)" = sexp_of_t none
-  let%bench "sexp_of_t (w/ dst)" = sexp_of_t some_dst_t
-  let%bench "sexp_of_t (w/o dst)" = sexp_of_t some_no_dst_t
-  let t_of_sexp = t_of_sexp
-  let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-  let%bench "t_of_sexp (w/ dst)" = t_of_sexp sexp_of_some_dst_t
-  let%bench "t_of_sexp (w/o dst)" = t_of_sexp sexp_of_some_no_dst_t
-  let to_string = to_string
-  let%bench "to_string (none)" = to_string none
-  let%bench "to_string (w/ dst)" = to_string some_dst_t
-  let%bench "to_string (w/o dst)" = to_string some_no_dst_t
-  let of_string = of_string
-  let%bench "of_string (none)" = of_string string_of_none
-  let%bench "of_string (w/ dst)" = of_string string_of_some_dst_t
-  let%bench "of_string (w/o dst)" = of_string string_of_some_no_dst_t
-
-  module Optional_syntax = struct
-    open Optional_syntax
-
-    module Optional_syntax = struct
-      open Optional_syntax
-
-      let is_none = is_none
-      let%bench "is_none" = is_none some_epoch
-      let unsafe_value = unsafe_value
-      let%bench "unsafe_value" = unsafe_value some_epoch
-    end
-  end
-
-  module Stable = struct
-    open Stable
-
-    module V1 = struct
-      open V1
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare" = compare none some_epoch
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (none)" = sexp_of_t none
-      let%bench "sexp_of_t (w/ dst)" = sexp_of_t some_dst_t
-      let%bench "sexp_of_t (w/o dst)" = sexp_of_t some_no_dst_t
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-      let%bench "t_of_sexp (w/ dst)" = t_of_sexp sexp_of_some_dst_t
-      let%bench "t_of_sexp (w/o dst)" = t_of_sexp sexp_of_some_no_dst_t
-      let to_int63 = to_int63
-      let%bench "to_int63 (none)" = to_int63 none
-      let%bench "to_int63 (some)" = to_int63 some_epoch
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-      let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_epoch
-    end
-  end
-end
-
-module Stable = struct
-  module V1 = struct
-    open Stable.V1
-    module Map = Map
-    module Set = Set
-    module Diff = Diff
-
-    type nonrec t = t [@@deriving bin_io, stable_witness, hash]
-    type nonrec comparator_witness = comparator_witness
-
-    let comparator = comparator
-    let compare = compare
-    let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-    let equal = equal
-    let%bench "equal" = equal min_value_for_1us_rounding max_value_for_1us_rounding
-    let sexp_of_t = sexp_of_t
-    let%bench "sexp_of_t (w/ dst)" = sexp_of_t dst_t
-    let%bench "sexp_of_t (w/o dst)" = sexp_of_t no_dst_t
-    let t_of_sexp = t_of_sexp
-    let%bench "t_of_sexp (w/ dst)" = t_of_sexp sexp_of_dst_t
-    let%bench "t_of_sexp (w/o dst)" = t_of_sexp sexp_of_no_dst_t
-    let to_int63 = to_int63
-    let%bench "to_int63" = to_int63 epoch
-    let of_int63_exn = of_int63_exn
-    let%bench "of_int63_exn" = of_int63_exn int63_of_epoch
-  end
-
-  (* There's no particularly good reason to use [Alternate_sexp] from [Core.Time_ns]. *)
-  module Alternate_sexp = Time_ns.Stable.Alternate_sexp
-
-  (* Tested as part of [Timezone]. *)
-  module Zone = Timezone.Stable
-
-  module Option = struct
-    module V1 = struct
-      open Option
-      open Time_ns.Stable.Option.V1
-      open Time_option_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare" = compare none some_epoch
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (none)" = sexp_of_t none
-      let%bench "sexp_of_t (w/ dst)" = sexp_of_t some_dst_t
-      let%bench "sexp_of_t (w/o dst)" = sexp_of_t some_no_dst_t
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-      let%bench "t_of_sexp (w/ dst)" = t_of_sexp sexp_of_some_dst_t
-      let%bench "t_of_sexp (w/o dst)" = t_of_sexp sexp_of_some_no_dst_t
-      let to_int63 = to_int63
-      let%bench "to_int63 (none)" = to_int63 none
-      let%bench "to_int63 (some)" = to_int63 some_epoch
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-      let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_epoch
-    end
-  end
-
-  module Span = struct
-    module V1 = struct
-      open Span
-      open Time_ns.Stable.Span.V1
-      open Span_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, hash, sexp_grammar, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-      let equal = equal
-      let%bench "equal" = equal zero zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (s)" = sexp_of_t second
-      let%bench "sexp_of_t (ns+)" = sexp_of_t pi_nanoseconds
-      let%bench "sexp_of_t (us+)" = sexp_of_t pi_microseconds
-      let%bench "sexp_of_t (ms+)" = sexp_of_t pi_milliseconds
-      let%bench "sexp_of_t (s+)" = sexp_of_t pi_seconds
-      let%bench "sexp_of_t (m+)" = sexp_of_t pi_minutes
-      let%bench "sexp_of_t (h+)" = sexp_of_t pi_hours
-      let%bench "sexp_of_t (d+)" = sexp_of_t pi_days
-      let%bench "sexp_of_t (kd+)" = sexp_of_t pi_kilodays
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (s)" = t_of_sexp v1_sexp_of_second
-      let%bench "t_of_sexp (ns+)" = t_of_sexp v1_sexp_of_pi_nanoseconds
-      let%bench "t_of_sexp (us+)" = t_of_sexp v1_sexp_of_pi_microseconds
-      let%bench "t_of_sexp (ms+)" = t_of_sexp v1_sexp_of_pi_milliseconds
-      let%bench "t_of_sexp (s+)" = t_of_sexp v1_sexp_of_pi_seconds
-      let%bench "t_of_sexp (m+)" = t_of_sexp v1_sexp_of_pi_minutes
-      let%bench "t_of_sexp (h+)" = t_of_sexp v1_sexp_of_pi_hours
-      let%bench "t_of_sexp (d+)" = t_of_sexp v1_sexp_of_pi_days
-      let%bench "t_of_sexp (kd+)" = t_of_sexp v1_sexp_of_pi_kilodays
-      let%bench "t_of_sexp (d.)" = t_of_sexp sexp_of_decimal_pi_days
-      let to_int63 = to_int63
-      let%bench "to_int63" = to_int63 day
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn" = of_int63_exn int63_ten
-    end
-
-    module V2 = struct
-      open Span
-      open Time_ns.Stable.Span.V2
-      open Span_constants
-      module Map = Map
-      module Set = Set
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, hash, sexp_grammar, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let compare = compare
-      let%bench "compare" = compare min_value_for_1us_rounding max_value_for_1us_rounding
-      let equal = equal
-      let%bench "equal" = compare zero zero
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (s)" = sexp_of_t second
-      let%bench "sexp_of_t (kd+)" = sexp_of_t pi_kilodays
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (s)" = t_of_sexp sexp_of_second
-      let%bench "t_of_sexp (kd+)" = t_of_sexp sexp_of_pi_kilodays
-      let%bench "t_of_sexp (d.)" = t_of_sexp sexp_of_decimal_pi_days
-      let to_string = to_string
-      let%bench "to_string (s)" = to_string second
-      let%bench "to_string (kd+)" = to_string pi_kilodays
-      let of_string = of_string
-      let%bench "of_string (s)" = of_string string_of_second
-      let%bench "of_string (kd+)" = of_string string_of_pi_kilodays
-      let%bench "of_string (d.)" = of_string string_of_decimal_pi_days
-      let to_int63 = to_int63
-      let%bench "to_int63" = to_int63 day
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn" = of_int63_exn int63_ten
-    end
-
-    module Option = struct
-      module V1 = struct
-        open Span.Option
-        open Time_ns.Stable.Span.Option.V1
-        open Span_option_constants
-        module Diff = Diff
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let compare = compare
-        let%bench "compare" = compare none some_day
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp (none)" = t_of_sexp v1_sexp_of_none
-        let%bench "t_of_sexp (some)" = t_of_sexp v1_sexp_of_some_day
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t (none)" = sexp_of_t none
-        let%bench "sexp_of_t (some)" = sexp_of_t some_day
-        let to_int63 = to_int63
-        let%bench "to_int63 (none)" = to_int63 none
-        let%bench "to_int63 (some)" = to_int63 some_day
-        let of_int63_exn = of_int63_exn
-        let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-        let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_day
-      end
-
-      module V2 = struct
-        open Span.Option
-        open Time_ns.Stable.Span.Option.V2
-        open Span_option_constants
-        module Diff = Diff
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let compare = compare
-        let%bench "compare" = compare none some_day
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-        let%bench "t_of_sexp (some)" = t_of_sexp sexp_of_some_day
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t (none)" = sexp_of_t none
-        let%bench "sexp_of_t (some)" = sexp_of_t some_day
-        let to_int63 = to_int63
-        let%bench "to_int63 (none)" = to_int63 none
-        let%bench "to_int63 (some)" = to_int63 some_day
-        let of_int63_exn = of_int63_exn
-        let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-        let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_day
-      end
-    end
-  end
-
-  module Ofday = struct
-    module V1 = struct
-      open Ofday
-      open Time_ns.Stable.Ofday.V1
-      open Ofday_constants
-      module Diff = Diff
-
-      type nonrec t = t [@@deriving bin_io, sexp_grammar, stable_witness]
-      type nonrec comparator_witness = comparator_witness
-
-      let comparator = comparator
-      let hash = hash
-      let%bench "hash" = hash start_of_day
-      let hash_fold_t = hash_fold_t
-      let%bench "hash_fold_t" = hash_fold_t hash_state start_of_day
-      let compare = compare
-      let%bench "compare" = compare start_of_day evening
-      let equal = equal
-      let%bench "equal" = equal start_of_day start_of_next_day
-      let sexp_of_t = sexp_of_t
-      let%bench "sexp_of_t (midnight)" = sexp_of_t start_of_day
-      let%bench "sexp_of_t (morning)" = sexp_of_t morning
-      let%bench "sexp_of_t (evening)" = sexp_of_t evening
-      let t_of_sexp = t_of_sexp
-      let%bench "t_of_sexp (midnight)" = t_of_sexp sexp_of_start_of_day
-      let%bench "t_of_sexp (morning)" = t_of_sexp sexp_of_morning
-      let%bench "t_of_sexp (evening)" = t_of_sexp sexp_of_evening
-      let to_int63 = to_int63
-      let%bench "to_int63" = to_int63 start_of_day
-      let of_int63_exn = of_int63_exn
-      let%bench "of_int63_exn" = of_int63_exn int63_of_start_of_day
-    end
-
-    module Zoned = struct
-      module V1 = struct
-        open Ofday.Zoned
-        open Time_ns.Stable.Ofday.Zoned.V1
-        open Ofday_zoned_constants
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-
-        let compare = compare
-        let%bench "compare (<)" = compare zero_utc example
-        let%bench "compare (>)" = compare example zero_utc
-        let%bench "compare (=)" = compare zero_utc zero_utc
-        let hash = hash
-        let%bench "hash" = hash zero_utc
-        let hash_fold_t = hash_fold_t
-        let%bench "hash_fold_t" = hash_fold_t hash_state zero_utc
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t" = sexp_of_t example
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp" = t_of_sexp example_sexp
-      end
-    end
-
-    module Option = struct
-      module V1 = struct
-        open Ofday.Option
-        open Time_ns.Stable.Ofday.Option.V1
-        open Ofday_option_constants
-        module Diff = Diff
-
-        type nonrec t = t [@@deriving bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
-
-        let comparator = comparator
-        let compare = compare
-        let%bench "compare" = compare none some_start_of_day
-        let sexp_of_t = sexp_of_t
-        let%bench "sexp_of_t (none)" = sexp_of_t none
-        let%bench "sexp_of_t (some)" = sexp_of_t some_start_of_day
-        let t_of_sexp = t_of_sexp
-        let%bench "t_of_sexp (none)" = t_of_sexp sexp_of_none
-        let%bench "t_of_sexp (some)" = t_of_sexp sexp_of_some_start_of_day
-        let to_int63 = to_int63
-        let%bench "to_int63 (none)" = to_int63 none
-        let%bench "to_int63 (some)" = to_int63 some_start_of_day
-        let of_int63_exn = of_int63_exn
-        let%bench "of_int63_exn (none)" = of_int63_exn int63_of_none
-        let%bench "of_int63_exn (some)" = of_int63_exn int63_of_some_start_of_day
-      end
-    end
-  end
-end
diff --git a/time_ns_unix/bench/dune b/time_ns_unix/bench/dune
index 7190772..f88c37f 100644
--- a/time_ns_unix/bench/dune
+++ b/time_ns_unix/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name time_ns_unix_bench)
- (libraries time_ns_unix)
+ (libraries core time_ns_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_ns_unix/src/dune b/time_ns_unix/src/dune
index 0e71267..285b38a 100644
--- a/time_ns_unix/src/dune
+++ b/time_ns_unix/src/dune
@@ -1,6 +1,7 @@
 (library
  (name time_ns_unix)
  (public_name core_unix.time_ns_unix)
- (libraries core time_float_unix)
+ (libraries core core_unix ppx_diff.diffable sexplib
+   ppx_stable_witness.stable_witness)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_ns_unix/src/time_ns_unix.ml b/time_ns_unix/src/time_ns_unix.ml
index ef12b91..a08a21b 100644
--- a/time_ns_unix/src/time_ns_unix.ml
+++ b/time_ns_unix/src/time_ns_unix.ml
@@ -1,10 +1,6 @@
 open! Core
-open! Int.Replace_polymorphic_compare
 module Unix = Core_unix
-module Time = Time_float_unix
 include Time_ns
-module Zone = Time.Zone
-module Span = Time_ns.Span
 
 let nanosleep t = Span.of_sec (Unix.nanosleep (Span.to_sec t))
 
@@ -33,24 +29,6 @@ let rec pause_forever () =
   pause_forever ()
 ;;
 
-let to_string t = to_string_abs t ~zone:(Lazy.force Zone.local)
-
-exception Time_string_not_absolute of string [@@deriving sexp]
-
-let of_string_gen ~if_no_timezone s =
-  let default_zone () =
-    match if_no_timezone with
-    | `Fail -> raise (Time_string_not_absolute s)
-    | `Local -> Lazy.force Zone.local
-    | `Use_this_one zone -> zone
-  in
-  of_string_gen ~default_zone ~find_zone:Zone.find_exn s
-;;
-
-let of_string_abs s = of_string_gen ~if_no_timezone:`Fail s
-let of_string s = of_string_gen ~if_no_timezone:`Local s
-let arg_type = Core.Command.Arg_type.create of_string_abs
-
 let to_tm t ~zone : Unix.tm =
   let date, ofday = to_date_ofday t ~zone in
   let parts = Ofday.to_parts ofday in
@@ -98,432 +76,3 @@ let of_tm tm ~zone =
 let parse ?allow_trailing_input s ~fmt ~zone =
   Unix.strptime ?allow_trailing_input ~fmt s |> of_tm ~zone
 ;;
-
-(* Does not represent extra hours due to DST (daylight saving time) (because DST makes
-   adjustments in terms of wall clock time) or leap seconds (which aren't represented in
-   Unix linear time).  See {!Ofday}. *)
-module Ofday = struct
-  include Time_ns.Ofday
-
-  let arg_type = Core.Command.Arg_type.create of_string
-
-  let of_ofday_float_round_nearest_microsecond core =
-    of_span_since_start_of_day_exn
-      (Span.of_span_float_round_nearest_microsecond
-         (Time.Ofday.to_span_since_start_of_day core))
-  ;;
-
-  let of_ofday_float_round_nearest core =
-    of_span_since_start_of_day_exn
-      (Span.of_span_float_round_nearest (Time.Ofday.to_span_since_start_of_day core))
-  ;;
-
-  let of_time time ~zone = to_ofday time ~zone
-
-  let to_ofday_float_round_nearest_microsecond t =
-    Time.Ofday.of_span_since_start_of_day_exn
-      (Span.to_span_float_round_nearest_microsecond (to_span_since_start_of_day t))
-  ;;
-
-  let to_ofday_float_round_nearest t =
-    Time.Ofday.of_span_since_start_of_day_exn
-      (Span.to_span_float_round_nearest (to_span_since_start_of_day t))
-  ;;
-
-  let now ~zone = of_time (Time_ns.now ()) ~zone
-
-  (* Legacy conversions that round to the nearest microsecond *)
-  let to_ofday = to_ofday_float_round_nearest_microsecond
-  let of_ofday = of_ofday_float_round_nearest_microsecond
-
-  (* This module is in [Time_ns_unix] instead of [Core] because to sexp a [Zone.t], we
-     need to read a time zone database to work out DST transitions. We do not have a
-     portable way to do that, and currently only support the operation on Unix. *)
-  module Zoned = struct
-    type t =
-      { ofday : Time_ns.Ofday.t
-      ; zone : Zone.t
-      }
-    [@@deriving bin_io, fields ~getters, compare, equal, hash]
-
-    type sexp_repr = Time_ns.Ofday.t * Zone.t [@@deriving sexp]
-
-    let sexp_of_t t = [%sexp_of: sexp_repr] (t.ofday, t.zone)
-
-    let t_of_sexp sexp =
-      let ofday, zone = [%of_sexp: sexp_repr] sexp in
-      { ofday; zone }
-    ;;
-
-    let to_time_ns t date = of_date_ofday ~zone:(zone t) date (ofday t)
-    let create ofday zone = { ofday; zone }
-    let create_local ofday = create ofday (Lazy.force Zone.local)
-
-    let of_string string : t =
-      match String.split string ~on:' ' with
-      | [ ofday; zone ] ->
-        { ofday = Time_ns.Ofday.of_string ofday; zone = Zone.of_string zone }
-      | _ -> failwithf "Ofday.Zoned.of_string %s" string ()
-    ;;
-
-    let to_string (t : t) : string =
-      String.concat [ Time_ns.Ofday.to_string t.ofday; " "; Zone.to_string t.zone ]
-    ;;
-
-    let arg_type = Core.Command.Arg_type.create of_string
-
-    module With_nonchronological_compare = struct
-      type nonrec t = t [@@deriving bin_io, compare, equal, sexp, hash]
-    end
-
-    include Pretty_printer.Register (struct
-      type nonrec t = t
-
-      let to_string = to_string
-      let module_name = "Time_ns_unix.Ofday.Zoned"
-    end)
-
-    module Stable = struct
-      module V1 = struct
-        let compare = With_nonchronological_compare.compare
-
-        module Bin_repr = struct
-          type nonrec t = t =
-            { ofday : Time_ns.Stable.Ofday.V1.t
-            ; zone : Timezone.Stable.V1.t
-            }
-          [@@deriving bin_io, stable_witness]
-        end
-
-        include
-          Binable.Of_binable_without_uuid [@alert "-legacy"]
-            (Bin_repr)
-            (struct
-              type nonrec t = t
-
-              let to_binable t : Bin_repr.t = { ofday = ofday t; zone = zone t }
-              let of_binable (repr : Bin_repr.t) = create repr.ofday repr.zone
-            end)
-
-        type nonrec t = t [@@deriving hash]
-
-        let stable_witness : t Stable_witness.t = Bin_repr.stable_witness
-
-        type sexp_repr = Time_ns.Stable.Ofday.V1.t * Timezone.Stable.V1.t
-        [@@deriving sexp]
-
-        let sexp_of_t t = [%sexp_of: sexp_repr] (ofday t, zone t)
-
-        let t_of_sexp sexp =
-          let ofday, zone = [%of_sexp: sexp_repr] sexp in
-          create ofday zone
-        ;;
-      end
-    end
-  end
-
-  module Option = struct
-    type ofday = t [@@deriving sexp, compare]
-    type t = Span.Option.t [@@deriving bin_io, compare, equal, hash, typerep]
-
-    let none = Span.Option.none
-    let some t = Span.Option.some (to_span_since_start_of_day t)
-    let is_none = Span.Option.is_none
-    let is_some = Span.Option.is_some
-
-    let some_is_representable t =
-      Span.Option.some_is_representable (to_span_since_start_of_day t)
-    ;;
-
-    let value t ~default =
-      Bool.select
-        (is_none t)
-        default
-        (of_span_since_start_of_day_unchecked (Span.Option.unchecked_value t))
-    ;;
-
-    let of_span_since_start_of_day span =
-      if span_since_start_of_day_is_valid span then Span.Option.some span else none
-    ;;
-
-    let value_exn t =
-      if is_some t
-      then of_span_since_start_of_day_unchecked (Span.Option.unchecked_value t)
-      else raise_s [%message [%here] "Time_ns_unix.Ofday.Option.value_exn none"]
-    ;;
-
-    let unchecked_value t =
-      of_span_since_start_of_day_unchecked (Span.Option.unchecked_value t)
-    ;;
-
-    let of_option = function
-      | None -> none
-      | Some t -> some t
-    ;;
-
-    let to_option t = if is_none t then None else Some (value_exn t)
-
-    (* Can't use the quickcheck generator and shrinker inherited from [Span.Option]
-       because they may produce spans whose representation is larger than
-       [start_of_next_day] *)
-    let quickcheck_generator : t Quickcheck.Generator.t =
-      Quickcheck.Generator.map
-        ~f:of_option
-        (Core.Option.quickcheck_generator
-           (Quickcheck.Generator.filter
-              ~f:some_is_representable
-              Time_ns.Ofday.quickcheck_generator))
-    ;;
-
-    let quickcheck_shrinker : t Quickcheck.Shrinker.t =
-      Quickcheck.Shrinker.map
-        ~f:of_option
-        ~f_inverse:to_option
-        (Core.Option.quickcheck_shrinker
-           (Base_quickcheck.Shrinker.filter
-              ~f:some_is_representable
-              Time_ns.Ofday.quickcheck_shrinker))
-    ;;
-
-    let quickcheck_observer = Span.Option.quickcheck_observer
-
-    module Optional_syntax = struct
-      module Optional_syntax = struct
-        let is_none = is_none
-        let unsafe_value = unchecked_value
-      end
-    end
-
-    module Stable = struct
-      module V1 = struct
-        module T = struct
-          type nonrec t = t [@@deriving compare, equal, bin_io]
-
-          let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
-          let sexp_of_t t = [%sexp_of: Time_ns.Stable.Ofday.V1.t option] (to_option t)
-          let t_of_sexp s = of_option ([%of_sexp: Time_ns.Stable.Ofday.V1.t option] s)
-          let to_int63 t = Span.Option.Stable.V1.to_int63 t
-          let of_int63_exn t = Span.Option.Stable.V1.of_int63_exn t
-        end
-
-        include T
-        include Comparator.Stable.V1.Make (T)
-
-        include Diffable.Atomic.Make (struct
-          type nonrec t = t [@@deriving sexp, bin_io, equal]
-        end)
-      end
-    end
-
-    let sexp_of_t = Stable.V1.sexp_of_t
-    let t_of_sexp = Stable.V1.t_of_sexp
-
-    include Identifiable.Make (struct
-      type nonrec t = t [@@deriving sexp, compare, bin_io, hash]
-
-      let module_name = "Time_ns_unix.Ofday.Option"
-
-      include Sexpable.To_stringable (struct
-        type nonrec t = t [@@deriving sexp]
-      end)
-    end)
-
-    include (Span.Option : Core.Comparisons.S with type t := t)
-
-    include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving sexp, bin_io, equal]
-    end)
-  end
-end
-
-let get_sexp_zone = Time.get_sexp_zone
-let set_sexp_zone = Time.set_sexp_zone
-
-let t_of_sexp_gen ~if_no_timezone sexp =
-  try
-    match sexp with
-    | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday; Sexp.Atom tz ] ->
-      of_date_ofday ~zone:(Zone.find_exn tz) (Date.of_string date) (Ofday.of_string ofday)
-    (* This is actually where the output of [sexp_of_t] is handled, since that's e.g.
-       (2015-07-06 09:09:44.787988+01:00). *)
-    | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday_and_possibly_zone ] ->
-      of_string_gen ~if_no_timezone (date ^ " " ^ ofday_and_possibly_zone)
-    | Sexp.Atom datetime -> of_string_gen ~if_no_timezone datetime
-    | _ -> of_sexp_error "Time.t_of_sexp" sexp
-  with
-  | Of_sexp_error _ as e -> raise e
-  | e -> of_sexp_error (sprintf "Time.t_of_sexp: %s" (Exn.to_string e)) sexp
-;;
-
-let t_of_sexp sexp = t_of_sexp_gen sexp ~if_no_timezone:(`Use_this_one (get_sexp_zone ()))
-let t_of_sexp_abs sexp = t_of_sexp_gen sexp ~if_no_timezone:`Fail
-
-let t_sexp_grammar : t Sexplib.Sexp_grammar.t =
-  { untyped =
-      Union
-        [ String
-        ; List (Cons (String, Cons (String, Empty)))
-        ; List (Cons (String, Cons (String, Cons (String, Empty))))
-        ]
-  }
-;;
-
-let sexp_of_t_abs t ~zone =
-  Sexp.List (List.map (Time_ns.to_string_abs_parts ~zone t) ~f:(fun s -> Sexp.Atom s))
-;;
-
-let sexp_of_t t = sexp_of_t_abs ~zone:(get_sexp_zone ()) t
-let of_date_ofday_zoned date ofday_zoned = Ofday.Zoned.to_time_ns ofday_zoned date
-
-let to_date_ofday_zoned t ~zone =
-  let date, ofday = to_date_ofday t ~zone in
-  date, Ofday.Zoned.create ofday zone
-;;
-
-let to_ofday_zoned t ~zone =
-  let ofday = to_ofday t ~zone in
-  Ofday.Zoned.create ofday zone
-;;
-
-include Diffable.Atomic.Make (struct
-  type nonrec t = t [@@deriving bin_io, equal, sexp]
-end)
-
-module Stable0 = struct
-  module V1 = struct
-    module T0 = struct
-      (* We use the unstable serialization here, and rely on comprehensive tests of the
-         stable conversion to make sure we don't change it. *)
-      type nonrec t = t [@@deriving bin_io, compare, equal, hash, sexp]
-
-      let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
-      let of_int63_exn t = of_span_since_epoch (Span.of_int63_ns t)
-      let to_int63 t = to_int63_ns_since_epoch t
-    end
-
-    module T = struct
-      include T0
-      module Comparator = Comparator.Stable.V1.Make (T0)
-      include Comparator
-    end
-
-    include T
-    include Comparable.Stable.V1.With_stable_witness.Make (T)
-    include Diffable.Atomic.Make (T)
-  end
-end
-
-include Stable0.V1.Comparator
-
-module Option = struct
-  include Time_ns.Option
-
-  module Stable = struct
-    module V1 = struct
-      module T = struct
-        include Stable.V1
-
-        let sexp_of_t t = [%sexp_of: Stable0.V1.t option] (to_option t)
-        let t_of_sexp s = of_option ([%of_sexp: Stable0.V1.t option] s)
-      end
-
-      include T
-      include Comparator.Stable.V1.Make (T)
-
-      include Diffable.Atomic.Make (struct
-        include T
-
-        let equal = [%compare.equal: t]
-      end)
-    end
-  end
-
-  let sexp_of_t = Stable.V1.sexp_of_t
-  let t_of_sexp = Stable.V1.t_of_sexp
-
-  include Identifiable.Make (struct
-    type nonrec t = t [@@deriving sexp, compare, bin_io, hash]
-
-    let module_name = "Time_ns_unix.Option"
-
-    include Sexpable.To_stringable (struct
-      type nonrec t = t [@@deriving sexp]
-    end)
-  end)
-
-  (* bring back the efficient implementation of comparison operators *)
-  include (Time_ns.Option : Core.Comparisons.S with type t := t)
-
-  include Diffable.Atomic.Make (struct
-    type nonrec t = t [@@deriving bin_io, equal, sexp]
-  end)
-end
-
-(* Note: This is FIX standard millisecond precision. You should use
-   [Zero.Time_ns_with_fast_accurate_to_of_string] if you need nanosecond precision. *)
-let to_string_fix_proto zone t =
-  Time.to_string_fix_proto zone (to_time_float_round_nearest_microsecond t)
-;;
-
-let of_string_fix_proto zone s =
-  of_time_float_round_nearest_microsecond (Time.of_string_fix_proto zone s)
-;;
-
-include Identifiable.Make_using_comparator (struct
-  include Stable0.V1
-
-  let module_name = "Time_ns_unix"
-  let of_string, to_string = of_string, to_string
-end)
-
-(* bring back the efficient implementation of comparison operators *)
-include (Core.Time_ns : Core.Comparisons.S with type t := t)
-
-module Stable = struct
-  module Option = Option.Stable
-
-  module Span = struct
-    include Span.Stable
-    module Option = Span.Option.Stable
-  end
-
-  module Ofday = struct
-    include Time_ns.Stable.Ofday
-    module Zoned = Ofday.Zoned.Stable
-    module Option = Ofday.Option.Stable
-  end
-
-  module Zone = Timezone.Stable
-  include Stable0
-  module Alternate_sexp = Core.Time_ns.Stable.Alternate_sexp
-end
-
-(*
-   Dropping Time in favor of Time_ns is possible and has been discussed, but we have
-   chosen not to do so at this time for a few reasons:
-
-   - It's a lot of work.  All functions over Time, including the related
-     modules Date, Ofday, Zone, Span, Schedule have to be converted to Time_ns
-     space.  This is largely mechanical, but will create a lot of churn within
-     the modules and possibly externally where the floatiness of the Time world
-     leaks out.
-
-   - It's of limited utility compared to other things we could be working on.
-     Time math would be easier to understand and somewhat faster, but very few
-     modules/programs would benefit from faster time math.  Those that do can
-     use Time_ns already for the most part.
-
-   - Having Time_ns and a conversion function already gives the bulk of the
-     value to programs that want a fast, non-allocating version of [Time.now].
-     Indeed, many remaining unconverted functions
-
-   - We aren't certain about how the boundaries around Time_ns will affect the
-     external viability of Core.  Internally we don't think being limited to
-     a smaller time range is an issue, and really far off times are better
-     represented as (Date.t * Ofday.t), but it is still a restriction.  This
-     pushback is probably minimal and, if we could get over the work concerns,
-     could be eliminated.
-
-   - Converting between Time and Time_ns when you use libraries based on different ones
-     isn't so bad. (?)
-*)
diff --git a/time_ns_unix/src/time_ns_unix.mli b/time_ns_unix/src/time_ns_unix.mli
index 42a43ed..b90dc8e 100644
--- a/time_ns_unix/src/time_ns_unix.mli
+++ b/time_ns_unix/src/time_ns_unix.mli
@@ -1 +1,66 @@
-include Time_ns_unix_intf.Time_ns_unix (** @inline *)
+open! Core
+
+include module type of struct
+  include Time_ns
+end
+
+(** [pause span] sleeps for [span] time. *)
+val pause : Span.t -> unit
+
+(** [interruptible_pause span] sleeps for [span] time unless interrupted (e.g. by
+      delivery of a signal), in which case the remaining unslept portion of time is
+      returned. *)
+val interruptible_pause : Span.t -> [ `Ok | `Remaining of Span.t ]
+
+(** [pause_forever] sleeps indefinitely. *)
+val pause_forever : unit -> never_returns
+
+(** [format t fmt] formats the given time according to fmt, which follows the formatting
+      rules given in 'man strftime'.  The time is output in the given timezone. Here are
+      some commonly used control codes:
+
+      {v
+      %Y - year (4 digits)
+      %y - year (2 digits)
+      %m - month
+      %d - day
+      %H - hour
+      %M - minute
+      %S - second
+    v}
+
+      a common choice would be: %Y-%m-%d %H:%M:%S
+
+      Although %Z and %z are interpreted as format strings, neither are correct in the
+      current implementation. %Z always refers to the local machine timezone, and does not
+      correctly detect whether DST is active. The effective local timezone can be
+      controlled by setting the "TZ" environment variable before calling [format]. %z
+      behaves unreliably and should be avoided.
+
+      Not all strftime control codes are standard; the supported subset will depend on the
+      C libraries linked into a given executable.
+  *)
+val format : t -> string -> zone:Zone.t -> string
+
+(** [parse string ~fmt ~zone] parses [string], according to [fmt], which follows the
+      formatting rules given in 'man strptime'.  The time is assumed to be in the given
+      timezone.
+
+      {v
+      %Y - year (4 digits)
+      %y - year (2 digits)
+      %m - month
+      %d - day
+      %H - hour
+      %M - minute
+      %S - second
+    v}
+
+      Raise if [allow_trailing_input] is false and [fmt] does not consume all of the
+      input. *)
+val parse
+  :  ?allow_trailing_input:bool (** default = false *)
+  -> string
+  -> fmt:string
+  -> zone:Zone.t
+  -> t
diff --git a/time_ns_unix/src/time_ns_unix_intf.ml b/time_ns_unix/src/time_ns_unix_intf.ml
deleted file mode 100644
index 7a29809..0000000
--- a/time_ns_unix/src/time_ns_unix_intf.ml
+++ /dev/null
@@ -1,361 +0,0 @@
-open! Core
-module Time = Time_float_unix
-
-module type Option = sig
-  include Immediate_option.S_int63
-  include Identifiable with type t := t
-end
-
-module type Span = sig
-  include module type of struct
-      include Time_ns.Span
-    end [@ocaml.remove_aliases]
-    with module Private := Time_ns.Span.Private
-end
-
-module type Ofday = sig
-  include module type of struct
-    include Time_ns.Ofday
-  end
-
-  val arg_type : t Core.Command.Arg_type.t
-  val now : zone:Time.Zone.t -> t
-
-  val to_ofday : t -> Time.Ofday.t
-    [@@deprecated
-      "[since 2019-01] use [to_ofday_float_round_nearest] or \
-       [to_ofday_float_round_nearest_microsecond]"]
-
-  val of_ofday : Time.Ofday.t -> t
-    [@@deprecated
-      "[since 2019-01] use [of_ofday_float_round_nearest] or \
-       [of_ofday_float_round_nearest_microsecond]"]
-
-  val to_ofday_float_round_nearest : t -> Time.Ofday.t
-  val to_ofday_float_round_nearest_microsecond : t -> Time.Ofday.t
-  val of_ofday_float_round_nearest : Time.Ofday.t -> t
-  val of_ofday_float_round_nearest_microsecond : Time.Ofday.t -> t
-
-  module Zoned : sig
-    (** Sexps look like "(12:01 nyc)"
-
-        Two [t]'s may or may not correspond to the same times depending on which date
-        they're evaluated. *)
-    type t [@@deriving bin_io, sexp, hash]
-
-    include Pretty_printer.S with type t := t
-
-    (** Strings look like "12:01 nyc" *)
-    include Stringable with type t := t
-
-    val arg_type : t Core.Command.Arg_type.t
-    val create : Time_ns.Ofday.t -> Time.Zone.t -> t
-    val create_local : Time_ns.Ofday.t -> t
-    val ofday : t -> Time_ns.Ofday.t
-    val zone : t -> Time.Zone.t
-    val to_time_ns : t -> Date.t -> Time_ns.t
-
-    module With_nonchronological_compare : sig
-      (** It is possible to consistently compare [t]'s, but due to the complexities of
-          time zones and daylight savings, the resulting ordering is not chronological.
-          That is, [compare t1 t2 > 0] does not imply [t2] occurs after [t1] every day,
-          or any day. *)
-      type nonrec t = t [@@deriving bin_io, sexp, compare, equal, hash]
-    end
-
-    module Stable : sig
-      module V1 : sig
-        type nonrec t = t [@@deriving hash]
-
-        include Stable_without_comparator_with_witness with type t := t
-      end
-    end
-  end
-
-  module Option : sig
-    include Option with type value := t
-    include Quickcheck.S with type t := t
-    include Diffable.S_atomic with type t := t
-
-    module Stable : sig
-      module V1 : sig
-        include Stable_int63able_with_witness with type t = t
-        include Diffable.S_atomic with type t := t
-      end
-    end
-
-    (** Returns [some] if the given span is a valid time since start of day, and [none]
-        otherwise. *)
-    val of_span_since_start_of_day : Time_ns.Span.t -> t
-  end
-end
-
-(** An absolute point in time, more efficient and precise than the [float]-based {!Time},
-    but representing a narrower range of times.
-
-    This module represents absolute times with nanosecond precision, approximately between
-    the years 1823 and 2116 CE.
-
-    Some reasons you might prefer [Time_ns.t] over float-based [Time.t]:
-
-    - It has superior performance.
-
-    - It uses [int]s rather than [float]s internally, which makes certain things easier to
-      reason about, since [int]s respect a bunch of arithmetic identities that [float]s
-      don't, e.g., [x + (y + z) = (x + y) + z].
-
-    Some reasons you might prefer to use float-based [Time] instead of this module:
-
-    - Some libraries use [Time.t] values, often for historical reasons, so it may be
-      necessary to use [Time.t] with them.
-
-    - [Time_ns] silently ignores overflow.
-
-    Neither {!Time_ns_unix} nor {!Time_float_unix} are available in JavaScript, but both
-    {!Core.Time_ns} and {!Core.Time} are.
-
-    See {!Core.Time_ns} for additional low level documentation. *)
-module type Time_ns_unix = sig
-  include module type of struct
-      include Time_ns
-    end [@ocaml.remove_aliases]
-    with module Span := Time_ns.Span
-    with module Ofday := Time_ns.Ofday
-    with module Stable := Time_ns.Stable
-    with module Option := Time_ns.Option
-
-  module Span : Span
-
-  val arg_type : t Core.Command.Arg_type.t
-
-  (** [Option.t] is like [t option], except that the value is immediate.  This module
-      should mainly be used to avoid allocations. *)
-  module Option : sig
-    include Option with type t = Time_ns.Option.t with type value := t
-    include Quickcheck.S with type t := t
-    include Diffable.S_atomic with type t := t
-
-    module Stable : sig
-      module V1 : sig
-        include Stable_int63able_with_witness with type t = t
-        include Diffable.S_atomic with type t := t
-      end
-    end
-  end
-
-  (** See {!Time.Ofday}. *)
-  module Ofday : Ofday
-
-  (** String conversions use the local timezone by default. Sexp conversions use
-      [get_sexp_zone ()] by default, which can be overridden by calling [set_sexp_zone].
-      These default time zones are used when writing a time, and when reading a time with
-      no explicit zone or UTC offset.
-
-      Sexps and strings display the date, ofday, and UTC offset of [t] relative to the
-      appropriate time zone. *)
-  include Identifiable with type t := t
-
-  include Diffable.S_atomic with type t := t
-
-  include sig
-      type t [@@deriving sexp_grammar]
-    end
-    with type t := t
-
-  module Zone : module type of Time.Zone with type t = Time.Zone.t
-
-  (** These functions are identical to those in [Time] and get/set the same variable. *)
-
-  val get_sexp_zone : unit -> Zone.t
-  val set_sexp_zone : Zone.t -> unit
-
-  (** [t_of_sexp_abs sexp] as [t_of_sexp], but demands that [sexp] indicate the timezone
-      the time is expressed in. *)
-  val t_of_sexp_abs : Sexp.t -> t
-
-  val sexp_of_t_abs : t -> zone:Zone.t -> Sexp.t
-
-  (** Conversion functions that involved Ofday.Zoned.t, exactly analogous to the
-      conversion functions that involve Ofday.t *)
-  val of_date_ofday_zoned : Date.t -> Ofday.Zoned.t -> t
-
-  val to_date_ofday_zoned : t -> zone:Time.Zone.t -> Date.t * Ofday.Zoned.t
-  val to_ofday_zoned : t -> zone:Time.Zone.t -> Ofday.Zoned.t
-  val to_string_fix_proto : [ `Utc | `Local ] -> t -> string
-  val of_string_fix_proto : [ `Utc | `Local ] -> string -> t
-
-  (** This is like [of_string] except that if the string doesn't specify the zone then it
-      raises rather than assume the local timezone. *)
-  val of_string_abs : string -> t
-
-  (** [of_string_gen ~if_no_timezone s] attempts to parse [s] to a [t].  If [s] doesn't
-      supply a time zone [if_no_timezone] is consulted. *)
-  val of_string_gen
-    :  if_no_timezone:[ `Fail | `Local | `Use_this_one of Zone.t ]
-    -> string
-    -> t
-
-  (** [pause span] sleeps for [span] time. *)
-  val pause : Span.t -> unit
-
-  (** [interruptible_pause span] sleeps for [span] time unless interrupted (e.g. by
-      delivery of a signal), in which case the remaining unslept portion of time is
-      returned. *)
-  val interruptible_pause : Span.t -> [ `Ok | `Remaining of Span.t ]
-
-  (** [pause_forever] sleeps indefinitely. *)
-  val pause_forever : unit -> never_returns
-
-  (** [format t fmt] formats the given time according to fmt, which follows the formatting
-      rules given in 'man strftime'.  The time is output in the given timezone. Here are
-      some commonly used control codes:
-
-      {v
-      %Y - year (4 digits)
-      %y - year (2 digits)
-      %m - month
-      %d - day
-      %H - hour
-      %M - minute
-      %S - second
-    v}
-
-      a common choice would be: %Y-%m-%d %H:%M:%S
-
-      Although %Z and %z are interpreted as format strings, neither are correct in the
-      current implementation. %Z always refers to the local machine timezone, and does not
-      correctly detect whether DST is active. The effective local timezone can be
-      controlled by setting the "TZ" environment variable before calling [format]. %z
-      behaves unreliably and should be avoided.
-
-      Not all strftime control codes are standard; the supported subset will depend on the
-      C libraries linked into a given executable.
-  *)
-  val format : t -> string -> zone:Zone.t -> string
-
-  (** [parse string ~fmt ~zone] parses [string], according to [fmt], which follows the
-      formatting rules given in 'man strptime'.  The time is assumed to be in the given
-      timezone.
-
-      {v
-      %Y - year (4 digits)
-      %y - year (2 digits)
-      %m - month
-      %d - day
-      %H - hour
-      %M - minute
-      %S - second
-    v}
-
-      Raise if [allow_trailing_input] is false and [fmt] does not consume all of the
-      input. *)
-  val parse
-    :  ?allow_trailing_input:bool (** default = false *)
-    -> string
-    -> fmt:string
-    -> zone:Zone.t
-    -> t
-
-  module Stable : sig
-    module V1 : sig
-      type nonrec t = t [@@deriving equal, hash]
-
-      include
-        Stable_int63able_with_witness
-          with type t := t
-           and type comparator_witness = comparator_witness
-
-      include
-        Comparable.Stable.V1.With_stable_witness.S
-          with type comparable := t
-          with type comparator_witness := comparator_witness
-
-      include Diffable.S_atomic with type t := t
-    end
-
-    (** Provides a sexp representation that is independent of the time zone of the machine
-        writing it. *)
-    module Alternate_sexp : sig
-      module V1 : sig
-        include Stable_without_comparator with type t = t
-        include Diffable.S_atomic with type t := t
-      end
-    end
-
-    module Option : sig
-      module V1 : sig
-        include Stable_int63able_with_witness with type t = Option.t
-        include Diffable.S_atomic with type t := t
-      end
-    end
-
-    module Span : sig
-      module V1 : sig
-        type t = Span.t [@@deriving hash, equal, sexp_grammar]
-
-        include Stable_int63able_with_witness with type t := t
-        include Diffable.S_atomic with type t := t
-      end
-
-      module V2 : sig
-        type t = Span.t [@@deriving hash, equal, sexp_grammar]
-        type nonrec comparator_witness = Span.comparator_witness
-
-        include
-          Stable_int63able_with_witness
-            with type t := t
-            with type comparator_witness := comparator_witness
-
-        include
-          Comparable.Stable.V1.With_stable_witness.S
-            with type comparable := t
-            with type comparator_witness := comparator_witness
-
-        include Stringable.S with type t := t
-        include Diffable.S_atomic with type t := t
-      end
-
-      module Option : sig
-        module V1 : sig
-          include Stable_int63able_with_witness with type t = Span.Option.t
-          include Diffable.S_atomic with type t := t
-        end
-
-        module V2 : sig
-          include Stable_int63able_with_witness with type t = Span.Option.t
-          include Diffable.S_atomic with type t := t
-        end
-      end
-    end
-
-    module Ofday : sig
-      module V1 : sig
-        type t = Ofday.t [@@deriving equal, hash, sexp_grammar]
-
-        include
-          Stable_int63able_with_witness
-            with type t := Ofday.t
-             and type comparator_witness = Time_ns.Stable.Ofday.V1.comparator_witness
-
-        include Diffable.S_atomic with type t := t
-      end
-
-      module Zoned : sig
-        module V1 : sig
-          type nonrec t = Ofday.Zoned.t [@@deriving hash]
-
-          include Stable_without_comparator_with_witness with type t := t
-        end
-      end
-
-      module Option : sig
-        module V1 : sig
-          include Stable_int63able_with_witness with type t = Ofday.Option.t
-          include Diffable.S_atomic with type t := t
-        end
-      end
-    end
-
-    module Zone = Timezone.Stable
-  end
-end
diff --git a/time_ns_unix/test/dune b/time_ns_unix/test/dune
index 8a65beb..e533d90 100644
--- a/time_ns_unix/test/dune
+++ b/time_ns_unix/test/dune
@@ -1,6 +1,6 @@
 (library
  (name time_ns_unix_test)
- (libraries bignum.bigint expect_test_helpers_core sexp_grammar_validation
-   time_interface time_ns_unix)
+ (libraries bignum.bigint core expect_test_helpers_core
+   sexp_grammar_validation time_float_unix time_interface time_ns_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/time_ns_unix/test/test_time_ns_unix.ml b/time_ns_unix/test/test_time_ns_unix.ml
index 5a3c3e5..13f35b6 100644
--- a/time_ns_unix/test/test_time_ns_unix.ml
+++ b/time_ns_unix/test/test_time_ns_unix.ml
@@ -11,7 +11,7 @@ let%expect_test "zoned strings near min and max representable value" =
     let time_of_string = Time_ns.of_string string in
     let string_of_nanos = Time_ns.to_string_abs time_of_nanos ~zone in
     print_s [%message string_of_nanos];
-    require_equal [%here] (module Time_ns) time_of_nanos time_of_string
+    require_equal (module Time_ns) time_of_nanos time_of_string
   in
   (* We test [Int63.min_value] and [Int63.max_value] against strings that used to be
      generated by [Time_ns.to_string_abs] due to Int63 overflow. *)
@@ -22,10 +22,10 @@ let%expect_test "zoned strings near min and max representable value" =
 ;;
 
 let%expect_test "Time_ns.to_date_ofday" =
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     ignore
       (Time_ns.to_date_ofday Time_ns.max_value_for_1us_rounding ~zone:Time.Zone.utc
-        : Date.t * Time_ns.Ofday.t));
+       : Date.t * Time_ns.Ofday.t));
   [%expect {| |}]
 ;;
 
@@ -52,11 +52,7 @@ let%test_module "Core.Time_ns.Utc.to_date_and_span_since_start_of_day" =
     ;;
 
     let%expect_test "Utc.to_date_and_span_since_start_of_day vs Time_ns.to_date_ofday" =
-      quickcheck
-        [%here]
-        quickcheck_generator
-        ~sexp_of:Time_ns.sexp_of_t
-        ~f:(fun time_ns ->
+      quickcheck quickcheck_generator ~sexp_of:Time_ns.sexp_of_t ~f:(fun time_ns ->
         match Word_size.word_size with
         | W64 ->
           let kernel_date, kernel_span_since_start_of_day =
@@ -67,7 +63,6 @@ let%test_module "Core.Time_ns.Utc.to_date_and_span_since_start_of_day" =
           in
           let core_date, core_ofday = Time_ns.to_date_ofday time_ns ~zone:Time.Zone.utc in
           require_compare_equal
-            [%here]
             (module struct
               type t = Date.t * Time_ns.Ofday.t [@@deriving compare, sexp_of]
             end)
@@ -104,9 +99,9 @@ let span_examples =
 let span_option_examples =
   Time_ns.Span.Option.none
   :: List.filter_map span_examples ~f:(fun span ->
-       if Time_ns.Span.Option.some_is_representable span
-       then Some (Time_ns.Span.Option.some span)
-       else None)
+    if Time_ns.Span.Option.some_is_representable span
+    then Some (Time_ns.Span.Option.some span)
+    else None)
 ;;
 
 let ofday_examples =
@@ -136,7 +131,7 @@ let zoned_examples =
   List.map ofday_examples ~f:(fun example ->
     Time_ns.Ofday.Zoned.create example Time_ns.Zone.utc)
   @ List.map ofday_examples ~f:(fun example ->
-      Time_ns.Ofday.Zoned.create example zone_new_york)
+    Time_ns.Ofday.Zoned.create example zone_new_york)
 ;;
 
 let%test_module "Time_ns.Span.to_string,of_string" =
@@ -191,25 +186,19 @@ let%test_module "Time_ns.Span.to_string,of_string" =
       let test span =
         let string = Time_ns.Span.to_string span in
         let round_trip = Time_ns.Span.of_string string in
-        require_equal [%here] (module Time_ns.Span) span round_trip
+        require_equal (module Time_ns.Span) span round_trip
       in
-      quickcheck
-        [%here]
-        span_gen
-        ~sexp_of:Time_ns.Span.sexp_of_t
-        ~examples:span_examples
-        ~f:test;
+      quickcheck span_gen ~sexp_of:Time_ns.Span.sexp_of_t ~examples:span_examples ~f:test;
       [%expect {| |}]
     ;;
 
     let%expect_test ("of_string: no allocation" [@tags "64-bits-only"]) =
       let test string =
         ignore
-          (require_no_allocation [%here] (fun () -> Time_ns.Span.of_string string)
-            : Time_ns.Span.t)
+          (require_no_allocation (fun () -> Time_ns.Span.of_string string)
+           : Time_ns.Span.t)
       in
       quickcheck
-        [%here]
         (Quickcheck.Generator.map span_gen ~f:Time_ns.Span.to_string)
         ~sexp_of:String.sexp_of_t
         ~f:test
@@ -315,7 +304,7 @@ let%test_module "Time_ns.Span.to_string,of_string" =
     ;;
 
     let%expect_test "of_string: weird cases of underscore" =
-      let test here str = require_does_not_raise here (fun () -> print_nanos str) in
+      let test here str = require_does_not_raise ~here (fun () -> print_nanos str) in
       test [%here] "1s1s";
       test [%here] "1s1._s";
       test [%here] "1_s1_.s";
@@ -367,7 +356,7 @@ let%test_module "Time_ns.Span.to_string,of_string" =
         in
         incr num_equality_tests;
         require
-          here
+          ~here
           (if diff_ns = zero
            then (
              incr num_equaled_exactly;
@@ -462,12 +451,10 @@ let%test_module "Time_ns.Span.to_string,of_string" =
           Float.int63_round_nearest_exn (float /. ns_divisor)
         in
         require_equal
-          [%here]
           (module Int63)
           (Time_ns.Span.to_int63_ns (Time_ns.Span.of_string span_str))
           expected_ns_via_int_math;
         require_equal
-          [%here]
           (module Int63)
           (Time_ns.Span.to_int63_ns (Time_ns.Span.of_string span_str))
           expected_ns_via_float_math
@@ -476,7 +463,7 @@ let%test_module "Time_ns.Span.to_string,of_string" =
     ;;
 
     let%expect_test "way too big should overflow" =
-      let test str = require_does_raise [%here] (fun () -> print_nanos str) in
+      let test str = require_does_raise (fun () -> print_nanos str) in
       (* These should all definitely overflow *)
       test "123456789012345678901234567890.1234567890ns";
       test "-123456789012345678901234567890.1234567890ns";
@@ -1043,22 +1030,20 @@ let%test_module "Time_ns.Span.Option.Stable.V2" =
 
     let%expect_test "round-trip" =
       quickcheck
-        [%here]
         ~sexp_of:[%sexp_of: Time_ns.Span.Option.t]
         ~examples:span_option_examples
         Time_ns.Span.Option.quickcheck_generator
         ~f:(fun span ->
-        let rt = V.t_of_sexp (V.sexp_of_t span) in
-        require_equal [%here] (module Time_ns.Span.Option) span rt;
-        let rt = V.of_int63_exn (V.to_int63 span) in
-        require_equal [%here] (module Time_ns.Span.Option) span rt);
+          let rt = V.t_of_sexp (V.sexp_of_t span) in
+          require_equal (module Time_ns.Span.Option) span rt;
+          let rt = V.of_int63_exn (V.to_int63 span) in
+          require_equal (module Time_ns.Span.Option) span rt);
       [%expect {| |}]
     ;;
 
     let%expect_test "stability" =
       let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
       print_and_check_stable_int63able_type
-        [%here]
         (module V)
         [ make 0L
         ; make 1L
@@ -1138,7 +1123,6 @@ let%expect_test "Time_ns.Span.Option.Stable.V1" =
   let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
   (* stable checks for values that round-trip *)
   print_and_check_stable_int63able_type
-    [%here]
     (module V)
     [ make 0L
     ; make 1_000L
@@ -1179,11 +1163,7 @@ let%expect_test "Time_ns.Span.Option.Stable.V1" =
      (int63  1))
     |}];
   (* stable checks for values that do not precisely round-trip *)
-  print_and_check_stable_int63able_type
-    [%here]
-    (module V)
-    ~cr:Comment
-    [ make 11_275_440_000L ];
+  print_and_check_stable_int63able_type (module V) ~cr:Comment [ make 11_275_440_000L ];
   [%expect
     {|
     (bin_shape_digest 2b528f4b22f08e28876ffe0239315ac2)
@@ -1206,7 +1186,6 @@ let%expect_test "Time_ns.Stable.V1" =
   let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
   (* stable checks for values that round-trip *)
   print_and_check_stable_int63able_type
-    [%here]
     (module V)
     [ make 0L
     ; make 1_000L
@@ -1251,7 +1230,6 @@ let%expect_test "Time_ns.Option.Stable.V1" =
   let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
   (* stable checks for values that round-trip *)
   print_and_check_stable_int63able_type
-    [%here]
     (module V)
     [ make 0L
     ; make 1_000L
@@ -1303,7 +1281,6 @@ let%test_module "Time_ns.Stable.Ofday.V1" =
       let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
       (* stable checks for key values *)
       print_and_check_stable_int63able_type
-        [%here]
         (module V)
         [ make 0L
         ; make 1L
@@ -1384,9 +1361,9 @@ let%test_module "Time_ns.Stable.Ofday.V1" =
           (V.to_int63 Time_ns.Ofday.start_of_next_day)
         |> Core.Quickcheck.Generator.map ~f:V.of_int63_exn
       in
-      quickcheck [%here] generator ~sexp_of:V.sexp_of_t ~f:(fun ofday ->
-        require_compare_equal [%here] (module V) ofday (V.of_int63_exn (V.to_int63 ofday));
-        require_compare_equal [%here] (module V) ofday (V.t_of_sexp (V.sexp_of_t ofday)));
+      quickcheck generator ~sexp_of:V.sexp_of_t ~f:(fun ofday ->
+        require_compare_equal (module V) ofday (V.of_int63_exn (V.to_int63 ofday));
+        require_compare_equal (module V) ofday (V.t_of_sexp (V.sexp_of_t ofday)));
       [%expect {| |}]
     ;;
   end)
@@ -1400,7 +1377,6 @@ let%test_module "Time_ns.Ofday.Option.Stable.V1" =
       let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
       (* stable checks for key values *)
       print_and_check_stable_int63able_type
-        [%here]
         (module V)
         [ make 0L
         ; make 1L
@@ -1469,20 +1445,17 @@ let%test_module "Time_ns.Ofday.Option.Stable.V1" =
 
     let%expect_test "roundtrip quickcheck" =
       quickcheck
-        [%here]
         Time_ns.Ofday.Option.quickcheck_generator
         ~sexp_of:V.sexp_of_t
         ~f:(fun ofday_option ->
-        require_compare_equal
-          [%here]
-          (module V)
-          ofday_option
-          (V.of_int63_exn (V.to_int63 ofday_option));
-        require_compare_equal
-          [%here]
-          (module V)
-          ofday_option
-          (V.t_of_sexp (V.sexp_of_t ofday_option)));
+          require_compare_equal
+            (module V)
+            ofday_option
+            (V.of_int63_exn (V.to_int63 ofday_option));
+          require_compare_equal
+            (module V)
+            ofday_option
+            (V.t_of_sexp (V.sexp_of_t ofday_option)));
       [%expect {| |}]
     ;;
   end)
@@ -1508,7 +1481,7 @@ let%test_module "Time_ns.Span" =
 
     let%expect_test "to_span_float_round_nearest_microsecond +/-140y raises" =
       List.iter [ 1.; -1. ] ~f:(fun sign ->
-        require_does_raise [%here] (fun () ->
+        require_does_raise (fun () ->
           to_span_float_round_nearest_microsecond
             (Time_ns.Span.of_day (140. *. 366. *. sign))));
       [%expect
@@ -1526,7 +1499,7 @@ let%test_module "Time_ns.Span" =
 
     let%expect_test "of_span_float_round_nearest_microsecond +/-140y raises" =
       List.iter [ 1.; -1. ] ~f:(fun sign ->
-        require_does_raise [%here] ~hide_positions:true (fun () ->
+        require_does_raise ~hide_positions:true (fun () ->
           of_span_float_round_nearest_microsecond
             (Time.Span.of_day (140. *. 366. *. sign))));
       [%expect
@@ -1542,21 +1515,18 @@ let%test_module "Time_ns.Span" =
 
     let%expect_test "Span.to_string_hum" =
       let open Time_ns.Span in
-      require_equal [%here] (module String) (to_string_hum nanosecond) "1ns";
-      require_equal [%here] (module String) (to_string_hum day) "1d";
-      require_equal [%here] (module String) (to_string_hum ~decimals:6 day) "1d";
+      require_equal (module String) (to_string_hum nanosecond) "1ns";
+      require_equal (module String) (to_string_hum day) "1d";
+      require_equal (module String) (to_string_hum ~decimals:6 day) "1d";
       require_equal
-        [%here]
         (module String)
         (to_string_hum ~decimals:6 ~align_decimal:false day)
         "1d";
       require_equal
-        [%here]
         (module String)
         (to_string_hum ~decimals:6 ~align_decimal:true day)
         "1.000000d ";
       require_equal
-        [%here]
         (module String)
         (to_string_hum ~decimals:6 ~align_decimal:true ~unit_of_time:Day (hour + minute))
         "0.042361d ";
@@ -1616,7 +1586,6 @@ let%test_module "Time_ns.Span" =
         let round_trip = to_span_float_round_nearest span_ns in
         let precision = abs (round_trip - span) in
         require
-          [%here]
           (precision <= microsecond)
           ~if_false_then_print_s:
             (lazy
@@ -1682,7 +1651,6 @@ let%test_module "Time_ns.Span" =
         let round_trip = of_span_float_round_nearest span in
         let precision = abs (round_trip - span_ns) in
         require
-          [%here]
           (precision <= microsecond)
           ~if_false_then_print_s:
             (lazy
@@ -1697,7 +1665,6 @@ let%test_module "Time_ns.Span" =
 
     let%expect_test _ =
       require
-        [%here]
         (Time.Span.is_positive (to_span_float_round_nearest max_value_for_1us_rounding));
       (* make sure no overflow *)
       [%expect {| |}]
@@ -1710,7 +1677,7 @@ let%test_module "Time_ns.Span.Option" =
     open Time_ns.Span.Option
 
     let%expect_test "none is not a valid span" =
-      require_does_raise [%here] ~hide_positions:true (fun () ->
+      require_does_raise ~hide_positions:true (fun () ->
         some (Time_ns.Span.of_int63_ns (Time_ns.Span.Option.Stable.V1.to_int63 none)));
       [%expect
         {|
@@ -1742,27 +1709,26 @@ let%test_module "Time_ns" =
          [ min_time_value; Time.epoch; Time.now (); max_time_value ]
          (* a few units around *)
          |> List.concat_map ~f:(fun time ->
-              List.concat_map
-                Time.Span.
-                  [ microsecond; millisecond; second; minute; hour; day; scale day 365. ]
-                ~f:(fun unit ->
-                  List.map
-                    (List.map ~f:float (List.range (-3) 4))
-                    ~f:(fun s -> Time.add time (Time.Span.scale unit s)))))
+           List.concat_map
+             Time.Span.
+               [ microsecond; millisecond; second; minute; hour; day; scale day 365. ]
+             ~f:(fun unit ->
+               List.map
+                 (List.map ~f:float (List.range (-3) 4))
+                 ~f:(fun s -> Time.add time (Time.Span.scale unit s)))))
         (* a few randoms *)
         @ List.init 9 ~f:(fun _ ->
-            Time.add
-              Time.epoch
-              (Time.Span.of_us
-                 (min_us_since_epoch
-                  +. Random.float (max_us_since_epoch -. min_us_since_epoch))))
+          Time.add
+            Time.epoch
+            (Time.Span.of_us
+               (min_us_since_epoch
+                +. Random.float (max_us_since_epoch -. min_us_since_epoch))))
         (* nearest microsecond *)
         |> List.map ~f:(fun time ->
-             time_of_us_since_epoch
-               (Float.round_nearest Time.(Span.to_us (diff time epoch))))
+          time_of_us_since_epoch (Float.round_nearest Time.(Span.to_us (diff time epoch))))
         (* in range *)
         |> List.filter ~f:(fun time ->
-             Time.(time >= min_time_value && time <= max_time_value))
+          Time.(time >= min_time_value && time <= max_time_value))
       in
       List.iter times ~f:(fun expect ->
         List.iter
@@ -1775,7 +1741,6 @@ let%test_module "Time_ns" =
           ~f:(fun (precision, time) ->
             let diff = Span.abs (diff expect time) in
             require
-              [%here]
               (Span.( <= ) diff Span.microsecond)
               ~if_false_then_print_s:
                 (lazy
@@ -1798,29 +1763,27 @@ let%test_module "Time_ns" =
          [ min_value_for_1us_rounding; epoch; now (); max_value_for_1us_rounding ]
          (* a few units around *)
          |> List.concat_map ~f:(fun time ->
-              List.concat_map
-                Span.
-                  [ microsecond; millisecond; second; minute; hour; day; scale day 365. ]
-                ~f:(fun unit ->
-                  filter_map
-                    (List.map ~f:float (List.range (-3) 4))
-                    ~f:(fun s -> add time (Span.scale unit s)))))
+           List.concat_map
+             Span.[ microsecond; millisecond; second; minute; hour; day; scale day 365. ]
+             ~f:(fun unit ->
+               filter_map
+                 (List.map ~f:float (List.range (-3) 4))
+                 ~f:(fun s -> add time (Span.scale unit s)))))
         (* a few randoms *)
         @ List.init 9 ~f:(fun _ -> random ())
         (* nearest microsecond since epoch *)
         |> List.map ~f:(fun time ->
-             Time_ns.of_int63_ns_since_epoch
-               (let open Int63 in
-                (Time_ns.to_int63_ns_since_epoch time + of_int 500)
-                /% of_int 1000
-                * of_int 1000))
+          Time_ns.of_int63_ns_since_epoch
+            (let open Int63 in
+             (Time_ns.to_int63_ns_since_epoch time + of_int 500)
+             /% of_int 1000
+             * of_int 1000))
         (* in range *)
         |> List.filter ~f:(fun t ->
-             t >= min_value_for_1us_rounding && t <= max_value_for_1us_rounding)
+          t >= min_value_for_1us_rounding && t <= max_value_for_1us_rounding)
       in
       List.iter ts ~f:(fun expect ->
         require_equal
-          [%here]
           (module Time_ns)
           expect
           (of_time_float_round_nearest_microsecond
@@ -1829,7 +1792,6 @@ let%test_module "Time_ns" =
           of_time_float_round_nearest (to_time_float_round_nearest expect)
         in
         require
-          [%here]
           (Time_ns.Span.( <= )
              (Time_ns.abs_diff expect round_trip)
              Time_ns.Span.microsecond)
@@ -1840,7 +1802,7 @@ let%test_module "Time_ns" =
     ;;
 
     let%expect_test _ =
-      require_equal [%here] (module Time_ns) epoch (of_span_since_epoch Span.zero);
+      require_equal (module Time_ns) epoch (of_span_since_epoch Span.zero);
       [%expect {| |}]
     ;;
 
@@ -1850,7 +1812,6 @@ let%test_module "Time_ns" =
       List.iter times ~f:(fun time ->
         let res = to_time_float_round_nearest (of_time_float_round_nearest time) in
         require
-          [%here]
           (Time.( =. ) time res)
           ~if_false_then_print_s:
             (lazy [%message "too far apart" (time : Time.t) (res : Time.t)]));
@@ -1868,7 +1829,6 @@ let%test_module "Time_ns" =
           if Span.(abs discrepancy > of_ns 100.)
           then
             print_cr
-              [%here]
               [%message
                 "Failed on span since epoch"
                   (since_epoch : Span.t)
@@ -1886,7 +1846,6 @@ let%test_module "Time_ns" =
       if String.( <> ) ms_str expected
       then
         print_cr
-          [%here]
           [%message
             "Failed on Ofday.to_millisecond_string"
               ~got:(ms_str : string)
@@ -1897,17 +1856,14 @@ let%test_module "Time_ns" =
     let check ofday =
       let if_false_then_print_s = lazy [%message "check ofday" (ofday : Ofday.t)] in
       require
-        [%here]
         ~if_false_then_print_s
         Ofday.(ofday >= start_of_day && ofday < start_of_next_day);
       require_equal
-        [%here]
         (module Ofday)
         ~if_false_then_print_s
         ofday
         (Ofday.of_string (Ofday.to_string ofday));
       require_equal
-        [%here]
         (module Ofday)
         ~if_false_then_print_s
         ofday
@@ -1917,7 +1873,6 @@ let%test_module "Time_ns" =
       in
       let diff = Span.abs (Ofday.diff ofday of_ofday) in
       require
-        [%here]
         (Span.( < ) diff Span.microsecond)
         ~if_false_then_print_s:
           (lazy
@@ -1943,7 +1898,6 @@ let%test_module "Time_ns" =
         (* First make sure Time.to_ofday behaves as expected with these inputs. *)
         let time_ofday = Time.to_ofday (to_time_float_round_nearest time_ns) ~zone in
         require_equal
-          [%here]
           (module Time.Ofday)
           time_ofday
           (Time.Ofday.of_string expect)
@@ -1958,7 +1912,6 @@ let%test_module "Time_ns" =
         let ofday = to_ofday time_ns ~zone in
         check ofday;
         require_equal
-          [%here]
           (module Ofday)
           ofday
           (Ofday.of_string expect)
@@ -2092,7 +2045,7 @@ module _ = struct
     let test string =
       let t = of_string string in
       let round_trip x =
-        require_compare_equal [%here] (module With_nonchronological_compare) t x
+        require_compare_equal (module With_nonchronological_compare) t x
       in
       round_trip (of_string (to_string t));
       round_trip (t_of_sexp (sexp_of_t t))
@@ -2103,10 +2056,7 @@ module _ = struct
   ;;
 
   let%expect_test "Zoned.V1" =
-    print_and_check_stable_type
-      [%here]
-      (module Time_ns.Stable.Ofday.Zoned.V1)
-      zoned_examples;
+    print_and_check_stable_type (module Time_ns.Stable.Ofday.Zoned.V1) zoned_examples;
     [%expect
       {|
       (bin_shape_digest 116be3b907c3a1807e5fbf3e7677c018)
@@ -2168,7 +2118,6 @@ let%expect_test "end-of-day constants" =
   let zones = List.map !Time_ns.Zone.likely_machine_zones ~f:Time_ns.Zone.find_exn in
   let test_round_trip zone date ofday ~expect =
     require_equal
-      [%here]
       (module Date)
       (Time_ns.of_date_ofday ~zone date ofday |> Time_ns.to_date ~zone)
       expect
@@ -2200,20 +2149,20 @@ let%test_module "Time_ns.Option" =
         let roundtrip t = value_exn (some t)
 
         let%expect_test "epoch" =
-          require_equal [%here] (module Time_ns) (roundtrip Time_ns.epoch) Time_ns.epoch;
+          require_equal (module Time_ns) (roundtrip Time_ns.epoch) Time_ns.epoch;
           [%expect {| |}]
         ;;
 
         let%expect_test "now" =
           let t = Time_ns.now () in
-          require_equal [%here] (module Time_ns) (roundtrip t) t;
+          require_equal (module Time_ns) (roundtrip t) t;
           [%expect {| |}]
         ;;
       end)
     ;;
 
     let%expect_test "value_exn none" =
-      require_does_raise [%here] ~hide_positions:true (fun () -> value_exn none);
+      require_does_raise ~hide_positions:true (fun () -> value_exn none);
       [%expect {| (lib/core/src/time_ns.ml:LINE:COL "Time_ns.Option.value_exn none") |}]
     ;;
   end)
@@ -2229,7 +2178,6 @@ let%test_module "Time_ns.Ofday.Option" =
 
         let%expect_test "start_of_day" =
           require_equal
-            [%here]
             (module Time_ns.Ofday)
             (roundtrip Time_ns.Ofday.start_of_day)
             Time_ns.Ofday.start_of_day;
@@ -2239,19 +2187,16 @@ let%test_module "Time_ns.Ofday.Option" =
         let%expect_test "now" =
           (* Even though this depends on the local zone, it should always work. *)
           let t = Time_ns.Ofday.now ~zone:(force Time.Zone.local) in
-          require_equal [%here] (module Time_ns.Ofday) (roundtrip t) t;
+          require_equal (module Time_ns.Ofday) (roundtrip t) t;
           [%expect {| |}]
         ;;
       end)
     ;;
 
     let%expect_test "value_exn none" =
-      require_does_raise [%here] ~hide_positions:true (fun () -> value_exn none);
+      require_does_raise ~hide_positions:true (fun () -> value_exn none);
       [%expect
-        {|
-        (lib/time_ns_unix/src/time_ns_unix.ml:LINE:COL
-         "Time_ns_unix.Ofday.Option.value_exn none")
-        |}]
+        {| (lib/core/src/time_ns.ml:LINE:COL "Time_ns.Ofday.Option.value_exn none") |}]
     ;;
 
     let%expect_test "of_span_since_start_of_day" =
@@ -2260,13 +2205,15 @@ let%test_module "Time_ns.Ofday.Option" =
       in
       convert_and_print Time_ns.Span.min_value_representable;
       convert_and_print Time_ns.Span.min_value_for_1us_rounding;
-      [%expect {|
+      [%expect
+        {|
         ()
         ()
         |}];
       convert_and_print Time_ns.Span.max_value_representable;
       convert_and_print Time_ns.Span.max_value_for_1us_rounding;
-      [%expect {|
+      [%expect
+        {|
         ()
         ()
         |}];
@@ -2285,7 +2232,6 @@ let%test_module "Time_ns.Ofday.Option" =
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Time_ns)
     [ Time_ns.epoch
     ; Time_ns.of_string "1955-11-12 18:38:00-08:00"
@@ -2319,7 +2265,6 @@ let%expect_test _ =
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Time_ns.Option)
     [ Time_ns.Option.none
     ; Time_ns.Option.some Time_ns.epoch
@@ -2358,7 +2303,6 @@ let%expect_test _ =
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Time_ns.Span)
     [ Time_ns.Span.zero
     ; Time_ns.Span.of_string "101.5ms"
@@ -2384,7 +2328,6 @@ let%expect_test _ =
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Time_ns.Span.Option)
     [ Time_ns.Span.Option.none
     ; Time_ns.Span.Option.some Time_ns.Span.zero
@@ -2423,7 +2366,6 @@ let%expect_test _ =
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Time_ns.Ofday)
     [ Time_ns.Ofday.start_of_day
     ; Time_ns.Ofday.of_string "18:38:00"
@@ -2451,7 +2393,6 @@ let%expect_test _ =
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Time_ns.Ofday.Option)
     [ Time_ns.Ofday.Option.none
     ; Time_ns.Ofday.Option.some Time_ns.Ofday.start_of_day
@@ -2503,7 +2444,6 @@ let%expect_test "Span.randomize" =
       if Span.( < ) rand lower_bound || Span.( > ) rand upper_bound
       then
         print_cr
-          [%here]
           [%message
             "out of bounds"
               (percent : Percent.t)
@@ -2583,17 +2523,20 @@ let%expect_test "Span.to_short_string" =
 let%expect_test "times with implicit zones" =
   let test f = show_raise (fun () -> print_endline (Time_ns.to_string (f ()))) in
   test (fun () -> Time_ns.Stable.V1.t_of_sexp (Sexp.Atom "2013-10-07 09:30:00"));
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000000-04:00
     "did not raise"
     |}];
   test (fun () -> Time_ns.t_of_sexp (Sexp.Atom "2013-10-07 09:30:00"));
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000000-04:00
     "did not raise"
     |}];
   test (fun () -> Time_ns.of_string "2013-10-07 09:30:00");
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000000-04:00
     "did not raise"
     |}]
@@ -2603,12 +2546,12 @@ let%test_unit "ofday_zoned conversion consistency" =
   let quickcheck_generator =
     Int.gen_uniform_incl Int.min_value Int.max_value
     |> Quickcheck.Generator.map ~f:(fun int ->
-         Time_ns.of_span_since_epoch (Time_ns.Span.of_int_ns int))
+      Time_ns.of_span_since_epoch (Time_ns.Span.of_int_ns int))
   in
   let utc = Time.Zone.utc in
   let nyc = Time.Zone.find_exn "America/New_York" in
   let hkg = Time.Zone.find_exn "Asia/Hong_Kong" in
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     Quickcheck.test quickcheck_generator ~trials:100 ~f:(fun time ->
       let date_utc = Time_ns.to_date time ~zone:utc in
       let date_nyc = Time_ns.to_date time ~zone:nyc in
@@ -2643,7 +2586,7 @@ let%test_unit "ofday_zoned conversion consistency" =
 ;;
 
 let%expect_test "[Time_ns_unix.t_sexp_grammar]" =
-  require_ok [%here] (Sexp_grammar_validation.validate_grammar (module Time_ns_unix));
+  require_ok (Sexp_grammar_validation.validate_grammar (module Time_ns_unix));
   [%expect
     {|
     (Union
diff --git a/time_stamp_counter/src/time_stamp_counter.ml b/time_stamp_counter/src/time_stamp_counter.ml
index e3e9ed1..cf101e8 100644
--- a/time_stamp_counter/src/time_stamp_counter.ml
+++ b/time_stamp_counter/src/time_stamp_counter.ml
@@ -96,7 +96,7 @@ let zero = Int63.zero
 [%%ifdef JSC_ARCH_SIXTYFOUR]
 
 external rdtsc : unit -> (int64[@unboxed]) = "caml_rdtsc" "caml_rdtsc_unboxed"
-  [@@noalloc] [@@builtin]
+[@@noalloc] [@@builtin]
 
 (* noalloc on x86_64 only *)
 let[@inline] now () =
@@ -226,9 +226,9 @@ module Calibrator = struct
     t.tsc <- tsc;
     (* update ewma and regression. *)
     t.floats.ewma_time_tsc
-      <- ewma ~alpha ~old:t.floats.ewma_time_tsc ~add:(tsc_diff *. time_diff);
+    <- ewma ~alpha ~old:t.floats.ewma_time_tsc ~add:(tsc_diff *. time_diff);
     t.floats.ewma_tsc_square
-      <- ewma ~alpha ~old:t.floats.ewma_tsc_square ~add:(tsc_diff *. tsc_diff);
+    <- ewma ~alpha ~old:t.floats.ewma_tsc_square ~add:(tsc_diff *. tsc_diff);
     t.floats.ewma_tsc <- ewma ~alpha ~old:t.floats.ewma_tsc ~add:tsc_diff;
     t.floats.ewma_time <- ewma ~alpha ~old:t.floats.ewma_time ~add:time_diff;
     (* linear regression *)
@@ -251,19 +251,19 @@ module Calibrator = struct
         t.floats.sec_per_cycle +. (time_diff_est /. catchup_cycles)
       in
       t.floats.monotonic_sec_per_cycle
-        <- (if Float.is_positive time_diff_est
-            then
-              0.
-              +. (* performance hack: stops float boxing *)
-              Float.min
-                catchup_sec_per_cycle
-                (t.floats.sec_per_cycle *. (1. +. max_percent_change_from_real_slope))
-            else
-              0.
-              +. (* performance hack: stops float boxing *)
-              Float.max
-                catchup_sec_per_cycle
-                (t.floats.sec_per_cycle *. (1. -. max_percent_change_from_real_slope)));
+      <- (if Float.is_positive time_diff_est
+          then
+            0.
+            +. (* performance hack: stops float boxing *)
+            Float.min
+              catchup_sec_per_cycle
+              (t.floats.sec_per_cycle *. (1. +. max_percent_change_from_real_slope))
+          else
+            0.
+            +. (* performance hack: stops float boxing *)
+            Float.max
+              catchup_sec_per_cycle
+              (t.floats.sec_per_cycle *. (1. -. max_percent_change_from_real_slope)));
       (* Compute the number of cycles in the future at which monotonic estimated time
          equals estimated time, i.e. solve for [cycles] in:
 
@@ -275,13 +275,13 @@ module Calibrator = struct
          This value might get very small when the two slopes are about the same.  In such
          cases we just use the estimated slope always. *)
       t.monotonic_until_tsc
-        <- time_diff_est /. (t.floats.monotonic_sec_per_cycle -. t.floats.sec_per_cycle)
-           |> iround_up_and_add tsc ~if_iround_up_fails:Int63.zero);
+      <- time_diff_est /. (t.floats.monotonic_sec_per_cycle -. t.floats.sec_per_cycle)
+         |> iround_up_and_add tsc ~if_iround_up_fails:Int63.zero);
     (* Precompute values required for [tsc_to_nanos_since_epoch]. *)
     t.time_nanos <- Float.int63_round_nearest_exn (t.floats.time *. 1E9);
     t.floats.nanos_per_cycle <- t.floats.sec_per_cycle *. 1E9;
     t.monotonic_time_nanos
-      <- Float.int63_round_nearest_exn (t.floats.monotonic_time *. 1E9);
+    <- Float.int63_round_nearest_exn (t.floats.monotonic_time *. 1E9);
     t.floats.monotonic_nanos_per_cycle <- t.floats.monotonic_sec_per_cycle *. 1E9
   ;;
 
diff --git a/time_stamp_counter/src/time_stamp_counter.mli b/time_stamp_counter/src/time_stamp_counter.mli
index 02b50ea..20cc4cf 100644
--- a/time_stamp_counter/src/time_stamp_counter.mli
+++ b/time_stamp_counter/src/time_stamp_counter.mli
@@ -81,35 +81,35 @@ include Comparisons.S with type t := t
     argument, the internal instance is used when no calibrator is explicitly specified.
 *)
 module Calibrator : sig
-  type tsc
-  type t [@@deriving bin_io, sexp]
+    type tsc
+    type t [@@deriving bin_io, sexp]
 
-  (** [create ()] creates an uninitialized calibrator instance.  Creating a calibrator
+    (** [create ()] creates an uninitialized calibrator instance.  Creating a calibrator
       takes about 3ms.  One needs a recently calibrated [Calibrator.t] and the TSC value
       from the same machine to meaningfully convert the TSC value to a [Time.t]. *)
-  val create : unit -> t
+    val create : unit -> t
 
-  (** [calibrate t] updates [t] by measuring the current value of the TSC and
+    (** [calibrate t] updates [t] by measuring the current value of the TSC and
       [Time.now]. *)
-  val calibrate : t -> unit
+    val calibrate : t -> unit
 
-  (** Returns the estimated MHz of the CPU's time-stamp-counter based on the TSC and
+    (** Returns the estimated MHz of the CPU's time-stamp-counter based on the TSC and
       [Time.now ()].  This function is undefined on 32-bit machines. *)
-  val cpu_mhz : (t -> float) Or_error.t
+    val cpu_mhz : (t -> float) Or_error.t
 
-  (**/**)
+    (**/**)
 
-  (*_ See the Jane Street Style Guide for an explanation of [Private] submodules:
+    (*_ See the Jane Street Style Guide for an explanation of [Private] submodules:
 
     https://opensource.janestreet.com/standards/#private-submodules *)
-  module Private : sig
-    val create_using : tsc:tsc -> time:float -> samples:(tsc * float) list -> t
-    val calibrate_using : t -> tsc:tsc -> time:float -> am_initializing:bool -> unit
-    val initialize : t -> (tsc * float) list -> unit
-    val nanos_per_cycle : t -> float
+    module Private : sig
+      val create_using : tsc:tsc -> time:float -> samples:(tsc * float) list -> t
+      val calibrate_using : t -> tsc:tsc -> time:float -> am_initializing:bool -> unit
+      val initialize : t -> (tsc * float) list -> unit
+      val nanos_per_cycle : t -> float
+    end
   end
-end
-with type tsc := t
+  with type tsc := t
 
 (** [Span] indicates some integer number of cycles. *)
 module Span : sig
diff --git a/time_stamp_counter/src/time_stamp_counter_stubs.wat b/time_stamp_counter/src/time_stamp_counter_stubs.wat
new file mode 100644
index 0000000..ab028c7
--- /dev/null
+++ b/time_stamp_counter/src/time_stamp_counter_stubs.wat
@@ -0,0 +1,49 @@
+(module
+   (import "env" "caml_failwith" (func $caml_failwith (param (ref eq))))
+   (import "env" "caml_js_global"
+      (func $caml_js_global (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_get"
+      (func $caml_js_get (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_to_float"
+      (func $caml_js_to_float (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_meth_call"
+      (func $caml_js_meth_call
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "wrap" (func $wrap (param anyref) (result (ref eq))))
+   (import "env" "unwrap" (func $unwrap (param (ref eq)) (result anyref)))
+   (import "env" "caml_copy_int64"
+      (func $caml_copy_int64 (param i64) (result (ref eq))))
+
+   (type $block (array (mut (ref eq))))
+   (type $string (array (mut i8)))
+   (type $float (struct (field f64)))
+
+   (data $performance "performance")
+   (data $now "now")
+
+   (export "tsc_get" (func $caml_rdtsc))
+   (func $caml_rdtsc (export "caml_rdtsc") (param (ref eq)) (result (ref eq))
+      (call $caml_copy_int64
+         (i64.trunc_sat_f64_s
+            (f64.mul (f64.const 1000.)
+               (struct.get $float 0
+                  (ref.cast (ref $float)
+                     (call $caml_js_to_float
+                        (call $caml_js_meth_call
+                           (call $caml_js_get
+                              (call $caml_js_global (ref.i31 (i32.const 0)))
+                              (array.new_data $string $performance
+                                 (i32.const 0) (i32.const 11)))
+                           (array.new_data $string $now
+                              (i32.const 0) (i32.const 3))
+                           (array.new_fixed $block 1
+                              (ref.i31 (i32.const 0)))))))))))
+
+   (data $nanosleep_not_implemented "nanosleep is not supported in javascript")
+
+   (func (export "tsc_nanosleep") (param (ref eq)) (result (ref eq))
+      (call $caml_failwith
+         (array.new_data $string $nanosleep_not_implemented
+            (i32.const 0) (i32.const 40)))
+      (ref.i31 (i32.const 0)))
+)
diff --git a/time_stamp_counter/test/test_time_stamp_counter.ml b/time_stamp_counter/test/test_time_stamp_counter.ml
index fd39cd7..212b954 100644
--- a/time_stamp_counter/test/test_time_stamp_counter.ml
+++ b/time_stamp_counter/test/test_time_stamp_counter.ml
@@ -282,8 +282,7 @@ let%test_module _ =
     ;;
 
     let%expect_test "Test allocation" =
-      ignore
-        (Expect_test_helpers_core.require_no_allocation [%here] (fun () -> now ()) : t);
+      ignore (Expect_test_helpers_core.require_no_allocation (fun () -> now ()) : t);
       [%expect {| |}]
     ;;
 
diff --git a/unix_pseudo_terminal/test/testpty.ml b/unix_pseudo_terminal/test/testpty.ml
index a0c5a25..b15f8fa 100644
--- a/unix_pseudo_terminal/test/testpty.ml
+++ b/unix_pseudo_terminal/test/testpty.ml
@@ -11,7 +11,7 @@ let run_parent fdm fds =
     let _ = eprintf "%s%!" msg in
     let rlen = Unix.read Unix.stdin ~len:buflen ~buf in
     let s = if rlen < buflen then Bytes.subo buf ~len:rlen else buf in
-    let (_ : int) = Unix.write fdm ~buf:s in
+    let _ : int = Unix.write fdm ~buf:s in
     let rlen = Unix.read fdm ~len:buflen ~buf in
     let s =
       if rlen < buflen then Bytes.To_string.subo buf ~len:rlen else Bytes.to_string buf
diff --git a/uuid_unix/bench/dune b/uuid_unix/bench/dune
index 74e6e5e..9ce0acf 100644
--- a/uuid_unix/bench/dune
+++ b/uuid_unix/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name uuid_unix_bench)
- (libraries uuid_unix)
+ (libraries core core_kernel.uuid uuid_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/uuid_unix/test/dune b/uuid_unix/test/dune
index 1694229..d934981 100644
--- a/uuid_unix/test/dune
+++ b/uuid_unix/test/dune
@@ -1,5 +1,6 @@
 (library
  (name uuid_unix_test)
- (libraries core core_thread expect_test_helpers_core uuid_unix)
+ (libraries core core_thread expect_test_helpers_core core_kernel.uuid
+   uuid_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/uuid_unix/test/test_uuid.ml b/uuid_unix/test/test_uuid.ml
index 85f25fa..591d34b 100644
--- a/uuid_unix/test/test_uuid.ml
+++ b/uuid_unix/test/test_uuid.ml
@@ -53,25 +53,25 @@ module _ = struct
 end
 
 let%expect_test "[Unstable.t_of_sexp] validates its input" =
-  require_does_raise [%here] (fun () -> [%of_sexp: Unstable.t] [%sexp "not a uuid"]);
+  require_does_raise (fun () -> [%of_sexp: Unstable.t] [%sexp "not a uuid"]);
   [%expect
     {| (Of_sexp_error "not a uuid: not a valid UUID" (invalid_sexp "not a uuid")) |}]
 ;;
 
 let%expect_test "[Stable.V1.t_of_sexp] does not validate its input" =
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     ignore ([%of_sexp: Stable.V1.t] [%sexp "not a uuid"] : t));
   [%expect {| |}]
 ;;
 
 let%expect_test "[Unstable.t_of_sexp] on a valid input" =
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     ignore ([%of_sexp: Unstable.t] [%sexp "1f7f8c2e-d297-11ea-aafd-aa0000ef6338"] : t));
   [%expect {| |}]
 ;;
 
 let%expect_test "[Stable.V1.t_of_sexp] on a valid input" =
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     ignore ([%of_sexp: Stable.V1.t] [%sexp "1f7f8c2e-d297-11ea-aafd-aa0000ef6338"] : t));
   [%expect {| |}]
 ;;
