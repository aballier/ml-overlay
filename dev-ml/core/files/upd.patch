From 6d8a862aacdbce87eeca0ac3d942001d546d4845 Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Tue, 13 Aug 2024 20:53:44 +0100
Subject: [PATCH] v0.17~preview.129.36+325

---
 base_for_tests/src/test_binary_searchable.ml  |    62 +-
 base_for_tests/src/test_blit.ml               |    63 +-
 base_for_tests/src/test_blit_intf.ml          |    59 +-
 command/src/command.ml                        |   212 +-
 command/src/command_intf.ml                   |    61 +-
 command/src/dune                              |     2 +-
 command/src/shape.ml                          |     4 +-
 command/src/shape.mli                         |    12 +-
 core/bench-bin/array_queue.ml                 |    14 +-
 core/bench-bin/bench_map.ml                   |     2 +-
 core/bench-bin/hashtbl_bench.ml               |    10 +-
 .../replace_caml_modify_for_testing.mli       |     4 +-
 core/src/array.ml                             |    48 +-
 core/src/array.mli                            |    26 +-
 core/src/array_stubs.c                        |     3 +-
 core/src/bag_intf.ml                          |     2 +-
 core/src/bigbuffer.ml                         |     1 +
 core/src/bigstring.ml                         |    17 +-
 core/src/bigstring.mli                        |    30 +-
 core/src/bigstring_stubs.c                    |     3 +-
 core/src/bigsubstring.ml                      |    24 +-
 core/src/binable0.ml                          |   124 +-
 core/src/binable_intf.ml                      |    32 +-
 core/src/blang.ml                             |    92 +-
 core/src/bool.ml                              |     9 +-
 core/src/bool.mli                             |    11 +-
 core/src/bounded_index.ml                     |    42 +-
 core/src/bounded_index_intf.ml                |    10 +-
 core/src/byte_units.ml                        |    64 +-
 core/src/byte_units.mli                       |    24 +-
 core/src/bytes.ml                             |     8 +-
 core/src/bytes.mli                            |     4 +-
 core/src/char.mli                             |     6 +-
 core/src/command_internal.ml                  |    12 +-
 core/src/comparable.ml                        |   159 +-
 core/src/comparable_intf.ml                   |   145 +-
 core/src/core.ml                              |     2 +
 core/src/core_bin_prot.ml                     |     2 +-
 core/src/core_bin_prot.mli                    |     2 +-
 core/src/core_pervasives.mli                  |   198 +-
 core/src/core_sys.ml                          |    10 +-
 core/src/date0.ml                             |    40 +-
 core/src/date0_intf.ml                        |    60 +-
 core/src/date_intf.ml                         |     4 +-
 core/src/day_of_week.ml                       |     8 +-
 core/src/day_of_week_intf.ml                  |     4 +-
 core/src/deprecate_pipe_bang.mli              |     2 +-
 core/src/deque.ml                             |    76 +-
 core/src/deque.mli                            |     2 +-
 core/src/deriving_hash.ml                     |     9 +-
 core/src/deriving_hash_intf.ml                |     9 +-
 core/src/doubly_linked.ml                     |    58 +-
 core/src/doubly_linked_intf.ml                |     2 +-
 core/src/dune                                 |    10 +-
 core/src/either.ml                            |     7 +-
 core/src/either.mli                           |     2 +-
 core/src/error.mli                            |     2 +-
 core/src/fdeque.ml                            |    97 +-
 core/src/fdeque.mli                           |     2 +-
 core/src/filename.ml                          |    34 +-
 core/src/filename.mli                         |     4 +-
 core/src/float.ml                             |     8 +-
 core/src/float.mli                            |    14 +-
 core/src/fqueue.mli                           |     2 +-
 core/src/gc.ml                                |   214 +-
 core/src/gc.mli                               |   123 +-
 core/src/gc_stubs.c                           |     7 +-
 core/src/hash_queue.ml                        |    18 +-
 core/src/hash_queue_intf.ml                   |    16 +-
 core/src/hash_set.ml                          |   114 +-
 core/src/hash_set_intf.ml                     |    68 +-
 core/src/hashable.ml                          |   114 +-
 core/src/hashable_intf.ml                     |    66 +-
 core/src/hashtbl.ml                           |   192 +-
 core/src/hashtbl_intf.ml                      |    87 +-
 core/src/hexdump.ml                           |    16 +-
 core/src/host_and_port.ml                     |     8 +-
 core/src/host_and_port.mli                    |     6 +-
 core/src/identifiable.ml                      |    84 +-
 core/src/identifiable_intf.ml                 |    76 +-
 core/src/immediate_option_intf.ml             |    44 +-
 core/src/import.ml                            |    14 +-
 core/src/info.ml                              |    24 +-
 core/src/int.mli                              |     6 +-
 core/src/int63.ml                             |     4 +-
 core/src/int63.mli                            |     6 +-
 core/src/int_intf.ml                          |    12 +-
 core/src/interfaces.ml                        |     1 +
 core/src/linked_queue.ml                      |    44 +-
 core/src/linked_queue.mli                     |     2 +-
 core/src/list.mli                             |     8 +-
 core/src/list0.ml                             |     4 +-
 core/src/list0.mli                            |    12 +-
 core/src/make_stable.ml                       |   376 +-
 core/src/make_stable.mli                      |   392 +-
 core/src/make_substring.ml                    |     2 +-
 core/src/make_substring_intf.ml               |     6 +-
 core/src/map.ml                               |   258 +-
 core/src/map.mli                              |   100 +-
 core/src/map_intf.ml                          |   143 +-
 core/src/maybe_bound.ml                       |     6 +-
 core/src/maybe_bound.mli                      |     4 +-
 core/src/md5.ml                               |    39 +-
 core/src/md5.mli                              |    28 +-
 core/src/md5_stubs.c                          |     5 +-
 core/src/modes.ml                             |    35 +
 core/src/modes.mli                            |    27 +
 core/src/month.ml                             |    16 +-
 core/src/month_intf.ml                        |     4 +-
 core/src/ofday_float.ml                       |    66 +-
 core/src/ofday_float.mli                      |     2 +-
 core/src/ofday_helpers.ml                     |     2 +-
 core/src/ofday_intf.ml                        |     4 +-
 core/src/ofday_ns.ml                          |    44 +-
 core/src/ofday_ns.mli                         |     6 +-
 core/src/only_in_test.mli                     |     2 +-
 core/src/option.ml                            |     4 +-
 core/src/option_array.ml                      |    19 +-
 core/src/option_array.mli                     |     2 +-
 core/src/optional_syntax_intf.ml              |    11 +
 core/src/ordering.ml                          |     2 +-
 core/src/ordering.mli                         |     2 +-
 core/src/percent.ml                           |   129 +-
 core/src/percent.mli                          |    12 +-
 core/src/perms.ml                             |    53 +-
 core/src/perms.mli                            |    45 +-
 core/src/pid.ml                               |    20 +-
 core/src/pid.mli                              |     6 +-
 core/src/queue.ml                             |    68 +-
 core/src/queue.mli                            |     2 +-
 core/src/quickcheck.ml                        |    24 +-
 core/src/quickcheck_intf.ml                   |     8 +-
 core/src/quickcheckable.ml                    |    16 +-
 core/src/quickcheckable_intf.ml               |    16 +-
 core/src/ref.ml                               |    14 +-
 core/src/ref.mli                              |     2 +-
 core/src/result.mli                           |     9 +-
 core/src/runtime.wat                          |   234 +
 core/src/sequence.ml                          |    14 +-
 core/src/set.ml                               |   214 +-
 core/src/set.mli                              |    99 +-
 core/src/set_intf.ml                          |   126 +-
 core/src/set_once.ml                          |    17 +-
 core/src/set_once.mli                         |     6 +-
 core/src/sexp.ml                              |    17 +-
 core/src/sexp.mli                             |     5 +
 core/src/sexpable.ml                          |    55 +-
 core/src/sign.ml                              |     2 +-
 core/src/sign.mli                             |     2 +-
 core/src/sign_or_nan.ml                       |     2 +-
 core/src/sign_or_nan.mli                      |     2 +-
 core/src/signal.ml                            |    12 +-
 core/src/signal.mli                           |     8 +-
 core/src/source_code_position.mli             |     2 +-
 core/src/source_code_position0.ml             |    11 +-
 core/src/source_code_position0.mli            |     5 +-
 core/src/span_float.ml                        |   102 +-
 core/src/span_float.mli                       |     2 +
 core/src/span_ns.ml                           |   111 +-
 core/src/span_ns.mli                          |    10 +-
 core/src/stable.ml                            |    38 +-
 core/src/stable_comparable.ml                 |     8 +-
 core/src/stable_int63able.ml                  |     9 +
 core/src/stack.ml                             |    20 +-
 core/src/stack.mli                            |     1 +
 core/src/std_internal.ml                      |   453 +-
 core/src/string.ml                            |    70 +-
 core/src/string.mli                           |    36 +-
 core/src/string_id.ml                         |    94 +-
 core/src/string_id_intf.ml                    |    61 +-
 core/src/substring.ml                         |    24 +-
 core/src/substring_intf.ml                    |     2 +-
 .../temporal-polyfill/temporal-polyfill.js    | 20926 +++++++++-------
 core/src/time.ml                              |    13 +
 core/src/time0_intf.ml                        |    34 +-
 core/src/time_float.ml                        |   542 +-
 core/src/time_float.mli                       |   518 +-
 core/src/time_float0.ml                       |    18 +-
 core/src/time_float0.mli                      |    19 +-
 core/src/time_intf.ml                         |    13 +-
 core/src/time_ns.ml                           |   847 +-
 core/src/time_ns_intf.ml                      |   466 +-
 core/src/time_ns_stubs.c                      |     3 +-
 core/src/timezone.ml                          |   285 +
 core/src/timezone.mli                         |     1 +
 core/src/timezone_intf.ml                     |   120 +
 core/src/timezone_js_loader.ml                |    22 +-
 core/src/timezone_js_loader.mli               |     6 +
 core/src/timezone_js_loader_stubs.c           |    33 +-
 core/src/timezone_js_loader_stubs.wasm.js     |    46 +
 core/src/timezone_js_loader_stubs.wat         |   106 +
 core/src/timezone_runtime.js                  |    15 +
 core/src/tuple.ml                             |    48 +-
 core/src/tuple.mli                            |   193 +-
 core/src/tuple_intf.ml                        |   221 +
 core/src/type_immediacy.ml                    |    28 +-
 core/src/type_immediacy.mli                   |     4 +-
 core/src/uchar.ml                             |    20 +-
 core/src/uchar.mli                            |     4 +-
 core/src/uniform_array.ml                     |    10 +
 core/src/uniform_array.mli                    |     2 +-
 core/src/union_find.ml                        |     2 +-
 core/src/unique_id_intf.ml                    |     2 +-
 core/src/unit.ml                              |     5 +-
 core/src/unit.mli                             |     4 +-
 core/src/unit_of_time.ml                      |     2 +-
 core/src/unit_of_time.mli                     |     2 +-
 core/src/validated.ml                         |    63 +-
 core/src/validated_intf.ml                    |    92 +-
 core/src/zone.ml                              |    86 +-
 core/src/zone_intf.ml                         |    27 +-
 core/test-bin/src/test_uncaught_exception.ml  |     2 +-
 core/test/binable_and_sexpable_unit_tests.ml  |   242 +-
 core/test/bool_tests.ml                       |    12 +-
 core/test/core_gc_unit_tests.ml               |    12 +
 core/test/core_int63_unit_tests.ml            |     4 +-
 core/test/core_list_unit_tests.ml             |    48 +-
 core/test/core_map_unit_tests.ml              |   121 +-
 core/test/core_set_unit_tests.ml              |   174 +-
 core/test/core_string_unit_tests.ml           |     2 -
 core/test/digit_string_helpers_tests.ml       |    47 +-
 core/test/dune                                |     6 +-
 core/test/export_base_buffer.mlt              |    52 +-
 core/test/hashtbl_unit_tests.ml               |  4412 ++--
 core/test/hashtbl_unit_tests_intf.ml          |     8 +-
 core/test/info_unit_tests.ml                  |     1 -
 core/test/or_error_unit_tests.ml              |     2 +-
 core/test/quickcheck_unit_tests.ml            |    38 +-
 core/test/test_array.ml                       |     6 +-
 core/test/test_array_local.mlt                |     4 +-
 core/test/test_avltree.ml                     |    19 +-
 core/test/test_bag.ml                         |     8 +-
 core/test/test_bigstring.ml                   |    18 +-
 core/test/test_bigstring_safe_accessors.ml    |    12 +-
 core/test/test_bigstring_unsafe_accessors.ml  |     9 +-
 core/test/test_bigstring_unsafe_destroy.ml    |    10 +-
 core/test/test_binable.ml                     |     8 +-
 core/test/test_blang.ml                       |    57 +-
 core/test/test_bounded_index.ml               |    56 +-
 core/test/test_byte_units.ml                  |    47 +-
 core/test/test_char.ml                        |     6 +-
 core/test/test_container_module_types.ml      |    36 +-
 core/test/test_date.ml                        |    25 +-
 core/test/test_day_of_week.ml                 |    28 +-
 core/test/test_deque.ml                       |     6 +-
 core/test/test_doubly_linked.ml               |    96 +-
 core/test/test_doubly_linked_bisimulation.ml  |     6 +-
 core/test/test_fdeque.ml                      |    16 +-
 core/test/test_float.ml                       |    34 +-
 core/test/test_hash_queue.ml                  |    31 +-
 core/test/test_hexdump.ml                     |     2 +-
 core/test/test_host_and_port.ml               |     1 -
 core/test/test_identifiable.ml                |    10 +-
 core/test/test_map.ml                         |    24 +-
 core/test/test_map_interface.ml               |    26 +-
 core/test/test_maybe_bound.ml                 |     5 +-
 core/test/test_md5.ml                         |    48 +-
 core/test/test_memo.ml                        |     8 +-
 core/test/test_modes.ml                       |   104 +
 core/test/{test_zone.mli => test_modes.mli}   |     0
 core/test/test_month.ml                       |    50 +-
 core/test/test_nothing.ml                     |     4 +-
 core/test/test_option.ml                      |     2 +-
 core/test/test_percent.ml                     |    82 +-
 core/test/test_printf.ml                      |     2 +-
 core/test/test_queue.ml                       |    56 +-
 core/test/test_quickcheck_signature.ml        |     8 +-
 core/test/test_quickcheck_signature.mli       |     8 +-
 core/test/test_sequence.ml                    |     2 +-
 core/test/test_set_interface.ml               |    32 +-
 core/test/test_set_once.ml                    |    10 +-
 core/test/test_sexp.ml                        |    14 +-
 core/test/test_stable.ml                      |   145 +-
 core/test/test_staged.ml                      |    10 +
 core/test/test_staged.mli                     |     1 +
 core/test/test_string.ml                      |    13 +-
 core/test/test_string_id.ml                   |     3 +-
 core/test/test_substring.ml                   |    70 +-
 core/test/test_time.ml                        |   237 +-
 core/test/test_time_ns.ml                     |    77 +-
 core/test/test_timezone.ml                    |   656 +
 core/test/test_timezone.mli                   |     1 +
 core/test/test_timezone_full_data_protocol.ml |  1270 +
 .../test/test_timezone_full_data_protocol.mli |     1 +
 core/test/test_timezone_js_loader.ml          |    14 +-
 core/test/test_uchar.ml                       |     1 -
 core/test/test_union_find.ml                  |     2 +-
 core/test/test_unit.ml                        |    24 +-
 core/test/test_validate_bound.ml              |     3 +-
 core/test/test_validated.ml                   |    24 +-
 core/test/test_zone.ml                        |  1238 -
 core/test/type_immediacy_conv_unit_tests.ml   |    10 +-
 .../test/type_immediacy_witness_unit_tests.ml |    16 +-
 filename_base/src/filename_base.ml            |    16 +-
 filename_base/src/filename_base.mli           |     8 +-
 filename_base/test/test_filename.ml           |     9 +-
 heap_block/heap_block.ml                      |     2 +-
 heap_block/runtime.wat                        |    26 +
 univ_map/src/univ_map.ml                      |    24 +-
 univ_map/src/univ_map_intf.ml                 |    14 +-
 univ_map/test/dune                            |     2 +-
 univ_map/test/test_univ_map.ml                |    17 +-
 validate/src/validate.ml                      |     2 +-
 validate/src/validate.mli                     |     2 +-
 validate/test/test_validate.ml                |    12 +-
 306 files changed, 24310 insertions(+), 18076 deletions(-)
 create mode 100644 core/src/modes.ml
 create mode 100644 core/src/modes.mli
 create mode 100644 core/src/runtime.wat
 create mode 100644 core/src/timezone.ml
 create mode 100644 core/src/timezone.mli
 create mode 100644 core/src/timezone_intf.ml
 create mode 100644 core/src/timezone_js_loader_stubs.wasm.js
 create mode 100644 core/src/timezone_js_loader_stubs.wat
 create mode 100644 core/src/timezone_runtime.js
 create mode 100644 core/src/tuple_intf.ml
 create mode 100644 core/test/test_modes.ml
 rename core/test/{test_zone.mli => test_modes.mli} (100%)
 create mode 100644 core/test/test_staged.ml
 create mode 100644 core/test/test_staged.mli
 create mode 100644 core/test/test_timezone.ml
 create mode 100644 core/test/test_timezone.mli
 create mode 100644 core/test/test_timezone_full_data_protocol.ml
 create mode 100644 core/test/test_timezone_full_data_protocol.mli
 delete mode 100644 core/test/test_zone.ml
 create mode 100644 heap_block/runtime.wat

Index: core-0.17.1/base_for_tests/src/test_binary_searchable.ml
===================================================================
--- core-0.17.1.orig/base_for_tests/src/test_binary_searchable.ml
+++ core-0.17.1/base_for_tests/src/test_binary_searchable.ml
@@ -34,7 +34,8 @@ module Test_gen (M : Indexable_gen_and_f
       let b = For_test.big
 
       let binary_search ?pos ?len ~compare t how v =
-        binary_search ?pos ?len ~compare (For_test.of_array t) how v
+        let r = binary_search ?pos ?len ~compare (For_test.of_array t) how v in
+        [%globalize: int option] r [@nontail]
       ;;
 
       let ( = ) = Poly.equal
@@ -271,14 +272,17 @@ module Test_gen (M : Indexable_gen_and_f
                     failwiths "binary_search bug"
                     (exn, `length length, `search_key search_key, `pos pos, `len len)
                     <:sexp_of< exn * [ `length of int ] * [ `search_key of int ]
-                 * [ `pos of int ] * [ `len of int ] >>*)
+                   * [ `pos of int ] * [ `len of int ] >>*)
               done
             done
           done
         done
       ;;
 
-      let binary_search_segmented a = binary_search_segmented (For_test.of_array a)
+      let binary_search_segmented a ~segment_of which_target =
+        let r = binary_search_segmented (For_test.of_array a) ~segment_of which_target in
+        [%globalize: int option] r [@nontail]
+      ;;
 
       (*test for binary_search_segmented*)
       let%test _ =
@@ -306,41 +310,41 @@ module Test_gen (M : Indexable_gen_and_f
 end
 
 module Test (M : Binary_searchable_and_for_test) = Test_gen (struct
-  type 'a t = M.t
-  type 'a elt = M.elt
+    type 'a t = M.t
+    type 'a elt = M.elt
 
-  let binary_search = M.binary_search
-  let binary_search_segmented = M.binary_search_segmented
+    let binary_search = M.binary_search
+    let binary_search_segmented = M.binary_search_segmented
 
-  module For_test = M.For_test
-end)
+    module For_test = M.For_test
+  end)
 
 module Test1 (M : Binary_searchable1_and_for_test) = Test_gen (struct
-  type 'a t = 'a M.t
-  type 'a elt = 'a
+    type 'a t = 'a M.t
+    type 'a elt = 'a
 
-  let binary_search = M.binary_search
-  let binary_search_segmented = M.binary_search_segmented
+    let binary_search = M.binary_search
+    let binary_search_segmented = M.binary_search_segmented
 
-  module For_test = struct
-    let of_array = M.For_test.of_array
-    let compare = Bool.compare
-    let small = false
-    let big = true
-  end
-end)
+    module For_test = struct
+      let of_array = M.For_test.of_array
+      let compare = Bool.compare
+      let small = false
+      let big = true
+    end
+  end)
 
 module Make_and_test (M : Indexable_and_for_test) = struct
   module B = Binary_searchable.Make (M)
   include B
 
   include Test (struct
-    type t = M.t
-    type elt = M.elt
+      type t = M.t
+      type elt = M.elt
 
-    include B
-    module For_test = M.For_test
-  end)
+      include B
+      module For_test = M.For_test
+    end)
 end
 
 module Make1_and_test (M : Indexable1_and_for_test) = struct
@@ -348,9 +352,9 @@ module Make1_and_test (M : Indexable1_an
   include B
 
   include Test1 (struct
-    type 'a t = 'a M.t
+      type 'a t = 'a M.t
 
-    include B
-    module For_test = M.For_test
-  end)
+      include B
+      module For_test = M.For_test
+    end)
 end
Index: core-0.17.1/base_for_tests/src/test_blit.ml
===================================================================
--- core-0.17.1.orig/base_for_tests/src/test_blit.ml
+++ core-0.17.1/base_for_tests/src/test_blit.ml
@@ -48,8 +48,8 @@ module type For_tests_gen = sig
 end
 
 module Test_gen
-  (For_tests : For_tests_gen)
-  (Tested : S_gen
+    (For_tests : For_tests_gen)
+    (Tested : S_gen
               with type 'a src := 'a For_tests.Src.t
               with type 'a dst := 'a For_tests.Dst.t) =
 struct
@@ -153,8 +153,8 @@ struct
 end
 
 module Test1
-  (Sequence : Sequence1 with type 'a elt := 'a poly)
-  (Tested : S1 with type 'a t := 'a Sequence.t) =
+    (Sequence : Sequence1 with type 'a elt := 'a poly)
+    (Tested : S1 with type 'a t := 'a Sequence.t) =
   Test_gen
     (struct
       module Elt = struct
@@ -177,9 +177,9 @@ module Test1
     (Tested)
 
 module Test1_generic
-  (Elt : Elt1)
-  (Sequence : Sequence1 with type 'a elt := 'a Elt.t)
-  (Tested : S1 with type 'a t := 'a Sequence.t) =
+    (Elt : Elt1)
+    (Sequence : Sequence1 with type 'a elt := 'a Elt.t)
+    (Tested : S1 with type 'a t := 'a Sequence.t) =
   Test_gen
     (struct
       module Elt = Elt
@@ -204,9 +204,9 @@ module Elt_to_elt1 (Elt : Elt) = struct
 end
 
 module Test
-  (Elt : Elt)
-  (Sequence : Sequence with type elt := Elt.t)
-  (Tested : S with type t := Sequence.t) =
+    (Elt : Elt)
+    (Sequence : Sequence with type elt := Elt.t)
+    (Tested : S with type t := Sequence.t) =
   Test_gen
     (struct
       module Elt = Elt_to_elt1 (Elt)
@@ -233,10 +233,10 @@ module Test
     (Tested)
 
 module Test_distinct
-  (Elt : Elt)
-  (Src : Sequence with type elt := Elt.t)
-  (Dst : Sequence with type elt := Elt.t)
-  (Tested : S_distinct with type src := Src.t with type dst := Dst.t) =
+    (Elt : Elt)
+    (Src : Sequence with type elt := Elt.t)
+    (Dst : Sequence with type elt := Elt.t)
+    (Tested : S_distinct with type src := Src.t with type dst := Dst.t) =
   Test_gen
     (struct
       module Elt = Elt_to_elt1 (Elt)
@@ -269,11 +269,12 @@ module Test_distinct
     (Tested)
 
 module Make_and_test
-  (Elt : Elt) (Sequence : sig
-    include Sequence with type elt := Elt.t
+    (Elt : Elt)
+    (Sequence : sig
+       include Sequence with type elt := Elt.t
 
-    val unsafe_blit : (t, t) blit
-  end) =
+       val unsafe_blit : (t, t) blit
+     end) =
 struct
   module B = Make (Sequence)
   include Test (Elt) (Sequence) (B)
@@ -281,12 +282,13 @@ struct
 end
 
 module Make_distinct_and_test
-  (Elt : Elt)
-  (Src : Sequence with type elt := Elt.t) (Dst : sig
-    include Sequence with type elt := Elt.t
+    (Elt : Elt)
+    (Src : Sequence with type elt := Elt.t)
+    (Dst : sig
+       include Sequence with type elt := Elt.t
 
-    val unsafe_blit : (Src.t, t) blit
-  end) =
+       val unsafe_blit : (Src.t, t) blit
+     end) =
 struct
   module B = Make_distinct (Src) (Dst)
   include Test_distinct (Elt) (Src) (Dst) (B)
@@ -294,9 +296,9 @@ struct
 end
 
 module Make1_and_test (Sequence : sig
-  include Blit.Sequence1
-  include Sequence1 with type 'a t := 'a t with type 'a elt := 'a poly
-end) =
+    include Blit.Sequence1
+    include Sequence1 with type 'a t := 'a t with type 'a elt := 'a poly
+  end) =
 struct
   module B = Make1 (Sequence)
   include Test1 (Sequence) (B)
@@ -304,10 +306,11 @@ struct
 end
 
 module Make1_generic_and_test
-  (Elt : Elt1) (Sequence : sig
-    include Blit.Sequence1
-    include Sequence1 with type 'a t := 'a t with type 'a elt := 'a Elt.t
-  end) =
+    (Elt : Elt1)
+    (Sequence : sig
+       include Blit.Sequence1
+       include Sequence1 with type 'a t := 'a t with type 'a elt := 'a Elt.t
+     end) =
 struct
   module B = Make1_generic (Sequence)
   include Test1_generic (Elt) (Sequence) (B)
Index: core-0.17.1/base_for_tests/src/test_blit_intf.ml
===================================================================
--- core-0.17.1.orig/base_for_tests/src/test_blit_intf.ml
+++ core-0.17.1/base_for_tests/src/test_blit_intf.ml
@@ -57,49 +57,52 @@ module type Test_blit = sig
   module type Sequence1 = Sequence1
 
   module Test
-    (Elt : Elt)
-    (Sequence : Sequence with type elt := Elt.t)
-    (Tested : S with type t := Sequence.t) : sig end
+      (Elt : Elt)
+      (Sequence : Sequence with type elt := Elt.t)
+      (Tested : S with type t := Sequence.t) : sig end
 
   module Test_distinct
-    (Elt : Elt)
-    (Src : Sequence with type elt := Elt.t)
-    (Dst : Sequence with type elt := Elt.t)
-    (Tested : S_distinct with type src := Src.t with type dst := Dst.t) : sig end
+      (Elt : Elt)
+      (Src : Sequence with type elt := Elt.t)
+      (Dst : Sequence with type elt := Elt.t)
+      (Tested : S_distinct with type src := Src.t with type dst := Dst.t) : sig end
 
   module Test1
-    (Sequence : Sequence1 with type 'a elt := 'a poly)
-    (Tested : S1 with type 'a t := 'a Sequence.t) : sig end
+      (Sequence : Sequence1 with type 'a elt := 'a poly)
+      (Tested : S1 with type 'a t := 'a Sequence.t) : sig end
 
   module Test1_generic
-    (Elt : Elt1)
-    (Sequence : Sequence1 with type 'a elt := 'a Elt.t)
-    (Tested : S1 with type 'a t := 'a Sequence.t) : sig end
+      (Elt : Elt1)
+      (Sequence : Sequence1 with type 'a elt := 'a Elt.t)
+      (Tested : S1 with type 'a t := 'a Sequence.t) : sig end
 
   (** [Make_and_test] uses the [Blit.Make] functor and the [Test] functor. *)
   module Make_and_test
-    (Elt : Elt) (Sequence : sig
-      include Sequence with type elt := Elt.t
+      (Elt : Elt)
+      (Sequence : sig
+         include Sequence with type elt := Elt.t
 
-      val unsafe_blit : (t, t) blit
-    end) : S with type t := Sequence.t
+         val unsafe_blit : (t, t) blit
+       end) : S with type t := Sequence.t
 
   module Make_distinct_and_test
-    (Elt : Elt)
-    (Src : Sequence with type elt := Elt.t) (Dst : sig
-      include Sequence with type elt := Elt.t
+      (Elt : Elt)
+      (Src : Sequence with type elt := Elt.t)
+      (Dst : sig
+         include Sequence with type elt := Elt.t
 
-      val unsafe_blit : (Src.t, t) blit
-    end) : S_distinct with type src := Src.t with type dst := Dst.t
+         val unsafe_blit : (Src.t, t) blit
+       end) : S_distinct with type src := Src.t with type dst := Dst.t
 
   module Make1_and_test (Sequence : sig
-    include Blit.Sequence1
-    include Sequence1 with type 'a t := 'a t with type 'a elt := 'a poly
-  end) : S1 with type 'a t := 'a Sequence.t
-
-  module Make1_generic_and_test
-    (Elt : Elt1) (Sequence : sig
       include Blit.Sequence1
-      include Sequence1 with type 'a t := 'a t with type 'a elt := 'a Elt.t
+      include Sequence1 with type 'a t := 'a t with type 'a elt := 'a poly
     end) : S1 with type 'a t := 'a Sequence.t
+
+  module Make1_generic_and_test
+      (Elt : Elt1)
+      (Sequence : sig
+         include Blit.Sequence1
+         include Sequence1 with type 'a t := 'a t with type 'a elt := 'a Elt.t
+       end) : S1 with type 'a t := 'a Sequence.t
 end
Index: core-0.17.1/command/src/command.ml
===================================================================
--- core-0.17.1.orig/command/src/command.ml
+++ core-0.17.1/command/src/command.ml
@@ -3,6 +3,12 @@ open! Import
 include Command_intf
 module Shape = Shape
 
+let am_running_test =
+  match Ppx_inline_test_lib.testing with
+  | `Testing `Am_test_runner | `Testing `Am_child_of_test_runner -> true
+  | `Not_testing -> false
+;;
+
 (* in order to define expect tests, we want to raise rather than exit if the code is
    running in the test runner process *)
 let raise_instead_of_exit =
@@ -47,7 +53,7 @@ let help_screen_compare = Shape.Private.
  * expanded subcommand path
  * args passed to the base command
  * help text for the base command
- *)
+*)
 module Env = struct
   include Univ_map
 
@@ -106,12 +112,12 @@ end = struct
   let error ~has_arg err = { result = Error err; has_arg }
 
   include Applicative.Make (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let return = return_no_arg
-    let map = `Custom map
-    let apply = apply
-  end)
+      let return = return_no_arg
+      let map = `Custom map
+      let apply = apply
+    end)
 end
 
 module Auto_complete = struct
@@ -285,8 +291,8 @@ end = struct
             List.map alist ~f:(fun (k, (_ : 'a)) -> k, k)
             |> Map.of_alist_multi (module S)
             |> Map.filter ~f:(function
-                 | [] | [ _ ] -> false
-                 | _ :: _ :: _ -> true)
+              | [] | [ _ ] -> false
+              | _ :: _ :: _ -> true)
             |> Map.data
           in
           raise_s
@@ -589,8 +595,8 @@ module Flag = struct
           let { Doc.arg_doc; doc } = Doc.parse ~action ~doc in
           (wrap_if_optional t (Doc.concat ~name ~arg_doc), doc)
           :: List.map aliases ~f:(fun x ->
-               ( wrap_if_optional t (Doc.concat ~name:x ~arg_doc)
-               , sprintf "same as \"%s\"" name )))
+            ( wrap_if_optional t (Doc.concat ~name:x ~arg_doc)
+            , sprintf "same as \"%s\"" name )))
       ;;
     end
 
@@ -1461,8 +1467,7 @@ module Command_base = struct
   let path_key = Env.key_create "path"
   let args_key = Env.key_create "args"
   let help_key = Env.key_create "help"
-  let normalized_path = ref None
-  let normalized_args = ref None
+  let normalized_path_and_args = ref None
 
   let indent_by_2 str =
     String.split ~on:'\n' str
@@ -1634,8 +1639,7 @@ module Command_base = struct
             ~normalized_args:[]
             args
         in
-        normalized_path := Some path;
-        normalized_args := Some parsed_normalized_args;
+        normalized_path_and_args := Some (path, parsed_normalized_args);
         is_using_validate_parsing, main `Parse_args)
     with
     | Ok (`Only_validate_parsing true, (_thunk : _)) ->
@@ -1880,12 +1884,12 @@ module Command_base = struct
     ;;
 
     include Applicative.Make (struct
-      type nonrec 'a t = 'a t
+        type nonrec 'a t = 'a t
 
-      let return = return
-      let apply = apply
-      let map = `Custom map
-    end)
+        let return = return
+        let apply = apply
+        let map = `Custom map
+      end)
 
     let arg_names t =
       let flags = Flag.Internal.create (t.flags ()) in
@@ -2026,57 +2030,56 @@ module Command_base = struct
               acc
               (recover_from_missing_required_flags t)
               ~f:(fun acc { result = value; has_arg } ->
-              match has_arg with
-              | false -> acc
-              | true -> (name, value) :: acc))
+                match has_arg with
+                | false -> acc
+                | true -> (name, value) :: acc))
           |> map ~f:(fun value_list ->
-               let arg_counter = List.length value_list in
-               let missing_flag_error fmt =
-                 ksprintf
-                   (fun msg () -> Error (`Missing_required_flags (Error.of_string msg)))
-                   fmt
-               in
-               let more_than_one_error passed =
-                 die
-                   !"Cannot pass more than one of these: \n\
-                    \  %{Choice_name.list_to_string}"
-                   (List.map passed ~f:fst)
-                   ()
-               and success_list, error_list =
-                 List.partition_map value_list ~f:(function
-                   | name, Ok value -> First (name, value)
-                   | name, Error err -> Second (name, err))
-               in
-               match success_list with
-               | _ :: _ :: _ as passed -> more_than_one_error passed
-               | [ (_, (value : a)) ] ->
-                 if arg_counter > 1
-                 then more_than_one_error value_list
-                 else
-                   Ok
-                     (match if_nothing_chosen with
-                      | Default_to (_ : a) -> (value : b)
-                      | Raise -> (value : b)
-                      | Return_none -> (Some value : b))
-               | [] ->
-                 (match error_list with
-                  | [ (name, `Missing_required_flags err) ] ->
-                    Error
-                      (`Missing_required_flags
-                        (Error.of_string
-                           (sprintf
-                              "Not all flags in group \"%s\" are given: %s"
-                              (Choice_name.to_string name)
-                              (Error.to_string_hum err))))
-                  | _ ->
-                    (match if_nothing_chosen with
-                     | Default_to value -> Ok value
-                     | Return_none -> Ok None
-                     | Raise ->
-                       missing_flag_error
-                         !"Must pass one of these:\n  %{Choice_name.list_to_string}"
-                         (Map.keys ts)
-                         ())))
+            let arg_counter = List.length value_list in
+            let missing_flag_error fmt =
+              ksprintf
+                (fun msg () -> Error (`Missing_required_flags (Error.of_string msg)))
+                fmt
+            in
+            let more_than_one_error passed =
+              die
+                !"Cannot pass more than one of these: \n  %{Choice_name.list_to_string}"
+                (List.map passed ~f:fst)
+                ()
+            and success_list, error_list =
+              List.partition_map value_list ~f:(function
+                | name, Ok value -> First (name, value)
+                | name, Error err -> Second (name, err))
+            in
+            match success_list with
+            | _ :: _ :: _ as passed -> more_than_one_error passed
+            | [ (_, (value : a)) ] ->
+              if arg_counter > 1
+              then more_than_one_error value_list
+              else
+                Ok
+                  (match if_nothing_chosen with
+                   | Default_to (_ : a) -> (value : b)
+                   | Raise -> (value : b)
+                   | Return_none -> (Some value : b))
+            | [] ->
+              (match error_list with
+               | [ (name, `Missing_required_flags err) ] ->
+                 Error
+                   (`Missing_required_flags
+                     (Error.of_string
+                        (sprintf
+                           "Not all flags in group \"%s\" are given: %s"
+                           (Choice_name.to_string name)
+                           (Error.to_string_hum err))))
+               | _ ->
+                 (match if_nothing_chosen with
+                  | Default_to value -> Ok value
+                  | Return_none -> Ok None
+                  | Raise ->
+                    missing_flag_error
+                      !"Must pass one of these:\n  %{Choice_name.list_to_string}"
+                      (Map.keys ts)
+                      ())))
           |> introduce_missing_required_flags
       ;;
 
@@ -2151,7 +2154,7 @@ module Command_base = struct
             ~for_completion:(_ : bool)
             ~path:(_ : Path.t)
             ~verbose_on_parse_error:(_ : bool option)
-            -> result := Some (Error (Error.of_exn exn)));
+          -> result := Some (Error (Error.of_exn exn)));
       Option.value_exn ~here:[%here] !result
     ;;
   end
@@ -2226,12 +2229,12 @@ module Command_base = struct
       let flag_optional_with_default_doc = Param.flag_optional_with_default_doc
 
       include Applicative.Make (struct
-        type nonrec 'a t = 'a Param.t
+          type nonrec 'a t = 'a Param.t
 
-        let return = Param.return
-        let apply = apply
-        let map = `Custom map
-      end)
+          let return = Param.return
+          let apply = apply
+          let map = `Custom map
+        end)
 
       let pair = Param.both
     end
@@ -2622,13 +2625,13 @@ end
 let%test_module "Version_info" =
   (module struct
     module Version_info = Version_info (struct
-      let version_list = [ "hg://some/path_0xdeadbeef"; "ssh://a/path_8badf00d" ]
-      let reprint_build_info to_sexp = Sexp.to_string (to_sexp ())
+        let version_list = [ "hg://some/path_0xdeadbeef"; "ssh://a/path_8badf00d" ]
+        let reprint_build_info to_sexp = Sexp.to_string (to_sexp ())
 
-      module Time = struct
-        type t = unit [@@deriving sexp_of]
-      end
-    end)
+        module Time = struct
+          type t = unit [@@deriving sexp_of]
+        end
+      end)
 
     let%expect_test "print version where multiple repos are used" =
       Version_info.print_version ~version:Version_info.default_version;
@@ -2871,16 +2874,18 @@ struct
     ;;
 
     let of_external ~working_dir ~path_to_exe ~child_subcommand =
+      let env =
+        let help_sexp =
+          supported_versions |> Set.sexp_of_m__t (module Int) |> Sexp.to_string
+        in
+        `Extend [ Env_var.COMMAND_OUTPUT_HELP_SEXP, help_sexp ]
+      in
       let process_info =
         Unix.create_process_env
           ()
           ~prog:(abs_path ~dir:working_dir path_to_exe)
           ~args:child_subcommand
-          ~env:
-            (let help_sexp =
-               supported_versions |> Set.sexp_of_m__t (module Int) |> Sexp.to_string
-             in
-             `Extend [ COMMAND_OUTPUT_HELP_SEXP, help_sexp ])
+          ~env
       in
       Unix.close process_info.stdin;
       let stdout, stderr = read_stdout_and_stderr process_info in
@@ -2888,9 +2893,21 @@ struct
       (* Now we've killed all the processes and threads we made. *)
       match stdout |> Sexplib.Sexp.of_string |> Versioned.t_of_sexp |> of_versioned with
       | exception exn ->
+        let debug =
+          if am_running_test
+          then [%message "<debug info hidden in test>"]
+          else
+            [%message
+              ""
+                working_dir
+                path_to_exe
+                (child_subcommand : string list)
+                (env : [ `Extend of (Env_var.t * string) list ])]
+        in
         raise_s
           [%message
             "cannot parse command shape"
+              ~_:(debug : Sexp.t)
               ~_:(exn : exn)
               (stdout : string)
               (stderr : string)]
@@ -2967,11 +2984,11 @@ struct
         filtered_subcommands
         |> List.stable_sort ~compare:(fun a b -> help_screen_compare (fst a) (fst b))
         |> List.fold ~init:acc ~f:(fun acc (subcommand, shape) ->
-             let path = Path.append path ~subcommand in
-             let name = string_of_path path in
-             let doc = Shape.get_summary shape in
-             let acc = { Shape.Flag_info.name; doc; aliases = [] } :: acc in
-             if recursive then loop path acc shape else acc)
+          let path = Path.append path ~subcommand in
+          let name = string_of_path path in
+          let doc = Shape.get_summary shape in
+          let acc = { Shape.Flag_info.name; doc; aliases = [] } :: acc in
+          if recursive then loop path acc shape else acc)
       in
       match shape with
       | Exec (_, shape) ->
@@ -2986,9 +3003,9 @@ struct
           b.flags
           |> List.filter ~f:(fun fmt -> String.( <> ) fmt.name "[-help]")
           |> List.fold ~init:acc ~f:(fun acc fmt ->
-               let path = Path.append path ~subcommand:fmt.name in
-               let fmt = { fmt with name = string_of_path path } in
-               fmt :: acc)
+            let path = Path.append path ~subcommand:fmt.name in
+            let fmt = { fmt with name = string_of_path path } in
+            fmt :: acc)
         else acc
       | Lazy thunk -> loop path acc (Lazy.force thunk)
     in
@@ -3520,8 +3537,11 @@ let basic_or_error ~summary ?readme para
 ;;
 
 module For_telemetry = struct
-  let normalized_path () = Option.map !Command_base.normalized_path ~f:Path.parts
-  let normalized_args () = !Command_base.normalized_args
+  let normalized_path_and_args () =
+    match !Command_base.normalized_path_and_args with
+    | Some (path, args) -> `Ok (`Path (Path.parts path), `Args args)
+    | None -> `Not_initialized_through_command
+  ;;
 end
 
 module Private = struct
Index: core-0.17.1/command/src/command_intf.ml
===================================================================
--- core-0.17.1.orig/command/src/command_intf.ml
+++ core-0.17.1/command/src/command_intf.ml
@@ -574,26 +574,26 @@ module type Command = sig
   end
 
   module Let_syntax : sig
-    (** Substituted below. *)
-    type 'a t
-
-    val return : 'a -> 'a t
-
-    include Applicative.Applicative_infix with type 'a t := 'a t
-
-    module Let_syntax : sig
       (** Substituted below. *)
       type 'a t
 
       val return : 'a -> 'a t
-      val map : 'a t -> f:('a -> 'b) -> 'b t
-      val both : 'a t -> 'b t -> ('a * 'b) t
 
-      module Open_on_rhs = Param
+      include Applicative.Applicative_infix with type 'a t := 'a t
+
+      module Let_syntax : sig
+          (** Substituted below. *)
+          type 'a t
+
+          val return : 'a -> 'a t
+          val map : 'a t -> f:('a -> 'b) -> 'b t
+          val both : 'a t -> 'b t -> ('a * 'b) t
+
+          module Open_on_rhs = Param
+        end
+        with type 'a t := 'a Param.t
     end
     with type 'a t := 'a Param.t
-  end
-  with type 'a t := 'a Param.t
 
   (** The old interface for command-line specifications -- {b Do Not Use}.
 
@@ -610,13 +610,13 @@ module type Command = sig
 
     (** Superceded by [return], preserved for backwards compatibility. *)
     val const : 'a -> 'a Param.t
-      [@@deprecated
-        "[since 2018-10] use [Command.Param.return] instead of [Command.Spec.const]"]
+    [@@deprecated
+      "[since 2018-10] use [Command.Param.return] instead of [Command.Spec.const]"]
 
     (** Superceded by [both], preserved for backwards compatibility. *)
     val pair : 'a Param.t -> 'b Param.t -> ('a * 'b) Param.t
-      [@@deprecated
-        "[since 2018-10] use [Command.Param.both] instead of [Command.Spec.pair]"]
+    [@@deprecated
+      "[since 2018-10] use [Command.Param.both] instead of [Command.Spec.pair]"]
 
     (** {2 Command specifications} *)
 
@@ -805,7 +805,7 @@ module type Command = sig
     val flags_of_args_exn
       :  (Stdlib.Arg.key * Stdlib.Arg.spec * Stdlib.Arg.doc) list
       -> ('a, 'a) t
-      [@@deprecated "[since 2018-10] switch to Command.Param"]
+    [@@deprecated "[since 2018-10] switch to Command.Param"]
 
     (** A specification of some number of anonymous arguments. *)
     type 'a anons = 'a Anons.t
@@ -926,24 +926,17 @@ module type Command = sig
   val exit : int -> _
 
   module For_telemetry : sig
-    (** Returns the command and the list of subcommands. Arguments to the [Command.t] are
-        not included.
-
-        If a subcommand was specified as a unique prefix [normalized_path] will contain
-        the full subcommand name.
+    (** Returns the command and the list of subcommands, as well as a full list of
+        arguments.
 
-        If the entry point to the program was not through [Command] returns [None].
+        If a subcommand/flag was specified as a unique prefix, the return value will contain
+        the full subcommand/flag name.
     *)
-    val normalized_path : unit -> string list option
-
-    (** Returns the full list of arguments that were parsed by [Command].
-
-        If a flag name was specified as a unique prefix [normalized_args] will contain the
-        full flag name.
-
-        If the entry point to the program was not through [Command] returns [None].
-    *)
-    val normalized_args : unit -> string list option
+    val normalized_path_and_args
+      :  unit
+      -> [ `Not_initialized_through_command
+         | `Ok of [ `Path of string list ] * [ `Args of string list ]
+         ]
   end
 
   (** [Deprecated] should be used only by [Deprecated_command].  At some point
Index: core-0.17.1/command/src/dune
===================================================================
--- core-0.17.1.orig/command/src/dune
+++ core-0.17.1/command/src/dune
@@ -1,6 +1,6 @@
 (library
  (name command)
  (public_name core.command)
- (libraries base filename_base stdio univ_map)
+ (libraries base filename_base parsexp sexplib stdio univ_map)
  (preprocess
   (pps ppx_jane ppx_optcomp)))
Index: core-0.17.1/command/src/shape.ml
===================================================================
--- core-0.17.1.orig/command/src/shape.ml
+++ core-0.17.1/command/src/shape.ml
@@ -450,13 +450,13 @@ module Flag_info = struct
   let num_occurrences t =
     parse_name t
     |> Or_error.map ~f:(fun (num_occurrences, (_ : bool), (_ : string)) ->
-         num_occurrences)
+      num_occurrences)
   ;;
 
   let requires_arg t =
     parse_name t
     |> Or_error.map ~f:(fun ((_ : Num_occurrences.t), requires_arg, (_ : string)) ->
-         requires_arg)
+      requires_arg)
   ;;
 
   let help_screen_compare a b =
Index: core-0.17.1/command/src/shape.mli
===================================================================
--- core-0.17.1.orig/command/src/shape.mli
+++ core-0.17.1/command/src/shape.mli
@@ -21,7 +21,7 @@ module Anons : sig
 
   type t =
     | Usage of string
-        (** When exec'ing an older binary whose help sexp doesn't expose the grammar. *)
+    (** When exec'ing an older binary whose help sexp doesn't expose the grammar. *)
     | Grammar of Grammar.t
   [@@deriving compare, sexp_of]
 end
@@ -56,7 +56,7 @@ module Flag_info : sig
   val requires_arg : t -> bool Or_error.t
 
   val t_of_sexp : Sexp.t -> t
-    [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Flag_info]."]
+  [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Flag_info]."]
 end
 
 module Flag_help_display : sig
@@ -87,7 +87,7 @@ module Base_info : sig
   val get_usage : t -> string
 
   val t_of_sexp : Sexp.t -> t
-    [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Base_info]."]
+  [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Base_info]."]
 end
 
 module Group_info : sig
@@ -102,7 +102,7 @@ module Group_info : sig
   val map : 'a t -> f:('a -> 'b) -> 'b t
 
   val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
-    [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Group_info]."]
+  [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Group_info]."]
 end
 
 module Exec_info : sig
@@ -116,7 +116,7 @@ module Exec_info : sig
   [@@deriving compare, sexp_of]
 
   val t_of_sexp : Sexp.t -> t
-    [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Exec_info]."]
+  [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Exec_info]."]
 end
 
 (** Fully forced shapes are comparable and serializable. *)
@@ -130,7 +130,7 @@ module Fully_forced : sig
   val expanded_subcommands : t -> string list list
 
   val t_of_sexp : Sexp.t -> t
-    [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Fully_forced]."]
+  [@@deprecated "[since 2020-04] Use [Command.Stable.Shape.Fully_forced]."]
 end
 
 type t =
Index: core-0.17.1/core/bench-bin/array_queue.ml
===================================================================
--- core-0.17.1.orig/core/bench-bin/array_queue.ml
+++ core-0.17.1/core/bench-bin/array_queue.ml
@@ -83,13 +83,13 @@ let tests =
       ~name:"Linked_queue.enqueue + dequeue"
       ~args
       (fun num_elts ->
-      let t = Linked_queue.create () in
-      for _ = 1 to num_elts do
-        Linked_queue.enqueue t ()
-      done;
-      stage (fun () ->
-        Linked_queue.enqueue t ();
-        Linked_queue.dequeue_exn t))
+         let t = Linked_queue.create () in
+         for _ = 1 to num_elts do
+           Linked_queue.enqueue t ()
+         done;
+         stage (fun () ->
+           Linked_queue.enqueue t ();
+           Linked_queue.dequeue_exn t))
   ; Bench.Test.create_indexed ~name:"Deque.enqueue + dequeue" ~args (fun num_elts ->
       let t = Deque.create () in
       for _ = 1 to num_elts do
Index: core-0.17.1/core/bench-bin/bench_map.ml
===================================================================
--- core-0.17.1.orig/core/bench-bin/bench_map.ml
+++ core-0.17.1/core/bench-bin/bench_map.ml
@@ -70,7 +70,7 @@ let merge_test do_merge =
          | `Left a -> Some a
          | `Right a -> Some a
          | `Both (a, b) -> Some (a + b))
-        : _ Map.t)
+       : _ Map.t)
 ;;
 
 let gen_diff_test m ~number_of_diff ~diff =
Index: core-0.17.1/core/bench-bin/hashtbl_bench.ml
===================================================================
--- core-0.17.1.orig/core/bench-bin/hashtbl_bench.ml
+++ core-0.17.1/core/bench-bin/hashtbl_bench.ml
@@ -196,7 +196,7 @@ end = struct
         stage (fun () ->
           ignore
             (of_alist_report_all_dups alist
-              : [ `Ok of int t | `Duplicate_keys of key list ])))
+             : [ `Ok of int t | `Duplicate_keys of key list ])))
     ;;
 
     let of_alist_multi = Table.of_alist_multi
@@ -215,7 +215,7 @@ end = struct
         stage (fun () ->
           ignore
             (create_mapped alist ~get_key:fst ~get_data:snd
-              : [ `Ok of int t | `Duplicate_keys of key list ])))
+             : [ `Ok of int t | `Duplicate_keys of key list ])))
     ;;
 
     let create_with_key = Table.create_with_key
@@ -227,7 +227,7 @@ end = struct
         stage (fun () ->
           ignore
             (create_with_key data ~get_key:(Array.get key_array)
-              : [ `Ok of int t | `Duplicate_keys of key list ])))
+             : [ `Ok of int t | `Duplicate_keys of key list ])))
     ;;
 
     let create_with_key_exn = Table.create_with_key_exn
@@ -249,7 +249,7 @@ end = struct
         stage (fun () ->
           ignore
             (create_with_key_or_error data ~get_key:(Array.get key_array)
-              : int t Or_error.t)))
+             : int t Or_error.t)))
     ;;
 
     let group = Table.group
@@ -1177,7 +1177,7 @@ let benchmarks ~regex ~sizes =
   let module P = Bench_pooled (Config) in
   H.benchmarks @ P.benchmarks
   |> List.sort ~compare:(fun test1 test2 ->
-       String.compare (Bench.Test.name test1) (Bench.Test.name test2))
+    String.compare (Bench.Test.name test1) (Bench.Test.name test2))
 ;;
 
 module Top_level = struct
Index: core-0.17.1/core/replace_caml_modify_for_testing/replace_caml_modify_for_testing.mli
===================================================================
--- core-0.17.1.orig/core/replace_caml_modify_for_testing/replace_caml_modify_for_testing.mli
+++ core-0.17.1/core/replace_caml_modify_for_testing/replace_caml_modify_for_testing.mli
@@ -7,8 +7,8 @@
 (** [count ()] returns the number of times [caml_modify] has been called since the last
     call to {!reset}. *)
 external count : unit -> int = "replace_caml_modify_for_testing_count"
-  [@@noalloc]
+[@@noalloc]
 
 (** [reset ()] reset the counter to [0]. *)
 external reset : unit -> unit = "replace_caml_modify_for_testing_reset"
-  [@@noalloc]
+[@@noalloc]
Index: core-0.17.1/core/src/array.ml
===================================================================
--- core-0.17.1.orig/core/src/array.ml
+++ core-0.17.1/core/src/array.ml
@@ -6,9 +6,9 @@ module Core_sequence = Sequence
 
 include (
   Base.Array :
-    sig
-      type 'a t = 'a array [@@deriving sexp, compare ~localize, globalize, sexp_grammar]
-    end)
+  sig
+    type 'a t = 'a array [@@deriving compare ~localize, globalize, sexp, sexp_grammar]
+  end)
 
 type 'a t = 'a array [@@deriving bin_io ~localize, quickcheck, typerep]
 
@@ -20,7 +20,12 @@ module T = struct
   let normalize t i = Ordered_collection_common.normalize ~length_fun:length t i
 
   let slice t start stop =
-    Ordered_collection_common.slice ~length_fun:length ~sub_fun:sub t start stop
+    Ordered_collection_common.slice
+      ~length_fun:length
+      ~sub_fun:(fun t ~pos ~len -> sub t ~pos ~len)
+      t
+      start
+      stop
   ;;
 
   let nget t i = t.(normalize t i)
@@ -38,7 +43,7 @@ module T = struct
      the section entitled "Fast, Slow and Incorrect Array blits" of
      https://web.archive.org/web/20130220000229/http://janestreet.github.com/ocaml-perf-notes.html *)
   module Int = struct
-    type t_ = int array [@@deriving bin_io ~localize, compare, sexp]
+    type t_ = int array [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
     module Unsafe_blit = struct
       external unsafe_blit
@@ -49,7 +54,7 @@ module T = struct
         -> len:int
         -> unit
         = "core_array_unsafe_int_blit"
-        [@@noalloc]
+      [@@noalloc]
     end
 
     include
@@ -74,7 +79,7 @@ module T = struct
   end
 
   module Float = struct
-    type t_ = float array [@@deriving bin_io ~localize, compare, sexp]
+    type t_ = float array [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
     module Unsafe_blit = struct
       external unsafe_blit
@@ -85,7 +90,7 @@ module T = struct
         -> len:int
         -> unit
         = "core_array_unsafe_float_blit"
-        [@@noalloc]
+      [@@noalloc]
     end
 
     external get : (t_[@local_opt]) -> (int[@local_opt]) -> float = "%floatarray_safe_get"
@@ -137,7 +142,7 @@ module type Permissioned = sig
 
   include
     Indexed_container.S1_with_creators_permissions
-      with type ('a, 'perms) t := ('a, 'perms) t
+    with type ('a, 'perms) t := ('a, 'perms) t
 
   include Blit.S1_permissions with type ('a, 'perms) t := ('a, 'perms) t
   include Binary_searchable.S1_permissions with type ('a, 'perms) t := ('a, 'perms) t
@@ -345,6 +350,7 @@ module type Permissioned = sig
   val unzip : ('a * 'b, [> read ]) t -> ('a, [< _ perms ]) t * ('b, [< _ perms ]) t
   val sorted_copy : ('a, [> read ]) t -> compare:('a -> 'a -> int) -> ('a, [< _ perms ]) t
   val last : ('a, [> read ]) t -> 'a
+  val last_exn : ('a, [> read ]) t -> 'a
   val equal : ('a -> 'a -> bool) -> ('a, [> read ]) t -> ('a, [> read ]) t -> bool
   val equal__local : ('a -> 'a -> bool) -> ('a, [> read ]) t -> ('a, [> read ]) t -> bool
   val to_sequence : ('a, [> read ]) t -> 'a Sequence.t
@@ -352,10 +358,11 @@ module type Permissioned = sig
 end
 
 module Permissioned : sig
-  type ('a, -'perms) t [@@deriving bin_io ~localize, compare, sexp]
+  type ('a, -'perms) t [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
   module Int : sig
-    type nonrec -'perms t = (int, 'perms) t [@@deriving bin_io ~localize, compare, sexp]
+    type nonrec -'perms t = (int, 'perms) t
+    [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
     include Blit.S_permissions with type 'perms t := 'perms t
 
@@ -367,11 +374,12 @@ module Permissioned : sig
       -> len:int
       -> unit
       = "core_array_unsafe_int_blit"
-      [@@noalloc]
+    [@@noalloc]
   end
 
   module Float : sig
-    type nonrec -'perms t = (float, 'perms) t [@@deriving bin_io ~localize, compare, sexp]
+    type nonrec -'perms t = (float, 'perms) t
+    [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
     include Blit.S_permissions with type 'perms t := 'perms t
 
@@ -409,7 +417,7 @@ module Permissioned : sig
       -> len:int
       -> unit
       = "core_array_unsafe_float_blit"
-      [@@noalloc]
+    [@@noalloc]
   end
 
   val of_array_id : 'a array -> ('a, [< read_write ]) t
@@ -418,18 +426,19 @@ module Permissioned : sig
 
   include Permissioned with type ('a, 'perms) t := ('a, 'perms) t
 end = struct
-  type ('a, -'perms) t = 'a array [@@deriving bin_io ~localize, compare, sexp, typerep]
+  type ('a, -'perms) t = 'a array
+  [@@deriving bin_io ~localize, compare, sexp, sexp_grammar, typerep]
 
   module Int = struct
     include T.Int
 
-    type -'perms t = t_ [@@deriving bin_io ~localize, compare, sexp]
+    type -'perms t = t_ [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
   end
 
   module Float = struct
     include T.Float
 
-    type -'perms t = t_ [@@deriving bin_io ~localize, compare, sexp]
+    type -'perms t = t_ [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
   end
 
   let to_array_id = Fn.id
@@ -542,6 +551,7 @@ module type S = sig
   val unzip : ('a * 'b) t -> 'a t * 'b t
   val sorted_copy : 'a t -> compare:('a -> 'a -> int) -> 'a t
   val last : 'a t -> 'a
+  val last_exn : 'a t -> 'a
   val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
   val equal__local : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
   val to_sequence : 'a t -> 'a Core_sequence.t
@@ -556,13 +566,13 @@ let max_length = Sys.max_array_length
 module Int = struct
   include T.Int
 
-  type t = t_ [@@deriving bin_io ~localize, compare, sexp]
+  type t = t_ [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 end
 
 module Float = struct
   include T.Float
 
-  type t = t_ [@@deriving bin_io ~localize, compare, sexp]
+  type t = t_ [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 end
 
 module _ (M : S) : sig
Index: core-0.17.1/core/src/array.mli
===================================================================
--- core-0.17.1.orig/core/src/array.mli
+++ core-0.17.1/core/src/array.mli
@@ -27,7 +27,7 @@ include module type of struct
 *)
 
 module Int : sig
-  type nonrec t = int t [@@deriving bin_io ~localize, compare, sexp]
+  type nonrec t = int t [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
   include Blit.S with type t := t
 
@@ -39,11 +39,11 @@ module Int : sig
     -> len:int
     -> unit
     = "core_array_unsafe_int_blit"
-    [@@noalloc]
+  [@@noalloc]
 end
 
 module Float : sig
-  type nonrec t = float t [@@deriving bin_io ~localize, compare, sexp]
+  type nonrec t = float t [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
   include Blit.S with type t := t
 
@@ -55,7 +55,7 @@ module Float : sig
     -> len:int
     -> unit
     = "core_array_unsafe_float_blit"
-    [@@noalloc]
+  [@@noalloc]
 end
 
 (** [normalize array index] returns a new index into the array such that if the index is
@@ -84,10 +84,11 @@ module Permissioned : sig
       information about the length of an array can leak out even if you only have write
       permissions since you can catch out-of-bounds errors.
   *)
-  type ('a, -'perms) t [@@deriving bin_io ~localize, compare, sexp]
+  type ('a, -'perms) t [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
   module Int : sig
-    type nonrec -'perms t = (int, 'perms) t [@@deriving bin_io ~localize, compare, sexp]
+    type nonrec -'perms t = (int, 'perms) t
+    [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
     include Blit.S_permissions with type 'perms t := 'perms t
 
@@ -99,11 +100,12 @@ module Permissioned : sig
       -> len:int
       -> unit
       = "core_array_unsafe_int_blit"
-      [@@noalloc]
+    [@@noalloc]
   end
 
   module Float : sig
-    type nonrec -'perms t = (float, 'perms) t [@@deriving bin_io ~localize, compare, sexp]
+    type nonrec -'perms t = (float, 'perms) t
+    [@@deriving bin_io ~localize, compare, sexp, sexp_grammar]
 
     include Blit.S_permissions with type 'perms t := 'perms t
 
@@ -141,7 +143,7 @@ module Permissioned : sig
       -> len:int
       -> unit
       = "core_array_unsafe_float_blit"
-      [@@noalloc]
+    [@@noalloc]
   end
 
   (** [of_array_id] and [to_array_id] return the same underlying array.  On the other
@@ -176,7 +178,7 @@ module Permissioned : sig
 
   include
     Indexed_container.S1_with_creators_permissions
-      with type ('a, 'perms) t := ('a, 'perms) t
+    with type ('a, 'perms) t := ('a, 'perms) t
 
   include Blit.S1_permissions with type ('a, 'perms) t := ('a, 'perms) t
   include Binary_searchable.S1_permissions with type ('a, 'perms) t := ('a, 'perms) t
@@ -385,7 +387,11 @@ module Permissioned : sig
   val zip_exn : ('a, [> read ]) t -> ('b, [> read ]) t -> ('a * 'b, [< _ perms ]) t
   val unzip : ('a * 'b, [> read ]) t -> ('a, [< _ perms ]) t * ('b, [< _ perms ]) t
   val sorted_copy : ('a, [> read ]) t -> compare:('a -> 'a -> int) -> ('a, [< _ perms ]) t
+
   val last : ('a, [> read ]) t -> 'a
+  [@@deprecated "[since 2024-07] This was renamed to [last_exn]"]
+
+  val last_exn : ('a, [> read ]) t -> 'a
   val equal : ('a -> 'a -> bool) -> ('a, [> read ]) t -> ('a, [> read ]) t -> bool
   val to_sequence : ('a, [> read ]) t -> 'a Sequence.t
   val to_sequence_mutable : ('a, [> read ]) t -> 'a Sequence.t
Index: core-0.17.1/core/src/array_stubs.c
===================================================================
--- core-0.17.1.orig/core/src/array_stubs.c
+++ core-0.17.1/core/src/array_stubs.c
@@ -28,8 +28,7 @@ CAMLprim value core_array_unsafe_int_bli
      See [https://github.com/ocaml/ocaml/pull/11255].
    */
   memmove((value *)&Field(dst, Long_val(dst_pos)),
-          (value *)&Field(src, Long_val(src_pos)),
-          Long_val(len) * sizeof(value));
+          (value *)&Field(src, Long_val(src_pos)), Long_val(len) * sizeof(value));
 
   return Val_unit;
 }
Index: core-0.17.1/core/src/bag_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/bag_intf.ml
+++ core-0.17.1/core/src/bag_intf.ml
@@ -20,7 +20,7 @@ module type S = sig
     val value : 'a t -> 'a
   end
 
-  type 'a t [@@deriving sexp]
+  type 'a t [@@deriving sexp, sexp_grammar]
 
   (** Much of a bag's interface comes from the generic {!Base.Container} module. *)
   include Container.S1 with type 'a t := 'a t
Index: core-0.17.1/core/src/bigbuffer.ml
===================================================================
--- core-0.17.1.orig/core/src/bigbuffer.ml
+++ core-0.17.1/core/src/bigbuffer.ml
@@ -54,6 +54,7 @@ module To_bytes =
       include Bytes
 
       let create ~len = create len
+      let get t i = get t i
 
       let unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
         Bigstring.To_bytes.unsafe_blit ~src:src.bstr ~src_pos ~dst ~dst_pos ~len
Index: core-0.17.1/core/src/bigstring.ml
===================================================================
--- core-0.17.1.orig/core/src/bigstring.ml
+++ core-0.17.1/core/src/bigstring.ml
@@ -29,9 +29,16 @@ module Unstable = T
 
 let create size = create size
 
+external array1_sub
+  :  ('a, 'b, 'c) Array1.t
+  -> int
+  -> int
+  -> ('a, 'b, 'c) Array1.t
+  = "caml_ba_sub"
+
 let sub_shared ?(pos = 0) ?len (bstr : t) =
   let len = get_opt_len bstr ~pos len in
-  Array1.sub bstr pos len
+  array1_sub bstr pos len
 ;;
 
 (* Destruction *)
@@ -127,11 +134,11 @@ let write_bin_prot t ?pos (writer : _ Bi
 (* Hex dump *)
 
 include Hexdump.Of_indexable (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let length = length
-  let get = get
-end)
+    let length = length
+    let get = get
+  end)
 
 let rec last_nonmatch_plus_one ~buf ~min_pos ~pos ~char =
   let pos' = pos - 1 in
Index: core-0.17.1/core/src/bigstring.mli
===================================================================
--- core-0.17.1.orig/core/src/bigstring.mli
+++ core-0.17.1/core/src/bigstring.mli
@@ -22,11 +22,12 @@ include Hexdump.S with type t := t
     Content is undefined. *)
 val create : int -> t
 
-(** [sub_shared ?pos ?len bstr] @return the sub-bigstring in [bstr]
-    that starts at position [pos] and has length [len].  The sub-bigstring
-    shares the same memory region, i.e. modifying it will modify the
-    original bigstring.  Holding on to the sub-bigstring will also keep
-    the (usually bigger) original one around.
+(** [sub_shared ?pos ?len bstr]
+
+    @return the sub-bigstring in [bstr] that starts at position [pos] and has length
+    [len]. The sub-bigstring shares the same memory region, i.e. modifying it will modify
+    the original bigstring. Holding on to the sub-bigstring will also keep the (usually
+    bigger) original one around.
 
     @param pos default = 0
     @param len default = [Bigstring.length bstr - pos] *)
@@ -160,15 +161,26 @@ val set_head_padded_fixed_string
   -> unit
 
 module Unstable : sig
-  type nonrec t = t [@@deriving bin_io ~localize, compare, equal, sexp_of]
-  type nonrec t_frozen = t_frozen [@@deriving bin_io ~localize, compare, hash, sexp_of]
+  type nonrec t = t
+  [@@deriving bin_io ~localize, compare ~localize, equal ~localize, sexp_of]
+
+  type nonrec t_frozen = t_frozen
+  [@@deriving bin_io ~localize, compare ~localize, hash, sexp_of]
 end
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@deriving bin_io ~localize, stable_witness, compare, equal, sexp]
+    type nonrec t = t
+    [@@deriving
+      bin_io ~localize
+      , stable_witness
+      , compare ~localize
+      , equal ~localize
+      , sexp
+      , sexp_grammar]
 
     type nonrec t_frozen = t_frozen
-    [@@deriving bin_io ~localize, stable_witness, compare, hash, sexp]
+    [@@deriving
+      bin_io ~localize, stable_witness, compare ~localize, hash, sexp, sexp_grammar]
   end
 end
Index: core-0.17.1/core/src/bigstring_stubs.c
===================================================================
--- core-0.17.1.orig/core/src/bigstring_stubs.c
+++ core-0.17.1/core/src/bigstring_stubs.c
@@ -123,8 +123,7 @@ void core_bigstring_destroy(value v, int
   case CAML_BA_EXTERNAL:
     if ((flags & CORE_BIGSTRING_DESTROY_ALLOW_EXTERNAL) !=
         CORE_BIGSTRING_DESTROY_ALLOW_EXTERNAL)
-      caml_failwith(
-          "bigstring_destroy: bigstring is external or already deallocated");
+      caml_failwith("bigstring_destroy: bigstring is external or already deallocated");
     break;
   case CAML_BA_MANAGED:
     check_bigstring_proxy(b);
Index: core-0.17.1/core/src/bigsubstring.ml
===================================================================
--- core-0.17.1.orig/core/src/bigsubstring.ml
+++ core-0.17.1/core/src/bigsubstring.ml
@@ -1,18 +1,18 @@
 open! Import
 
 include Make_substring.F (struct
-  type t = Bigstring.t [@@deriving quickcheck]
+    type t = Bigstring.t [@@deriving quickcheck]
 
-  let create = Bigstring.create
-  let length = Bigstring.length
-  let get = Bigstring.get
+    let create = Bigstring.create
+    let length = Bigstring.length
+    let get t i = Bigstring.get t i
 
-  module Blit = Make_substring.Blit
+    module Blit = Make_substring.Blit
 
-  let blit = Blit.bigstring_bigstring
-  let blit_to_string = Blit.bigstring_bytes
-  let blit_to_bytes = Blit.bigstring_bytes
-  let blit_to_bigstring = Blit.bigstring_bigstring
-  let blit_from_string = Blit.string_bigstring
-  let blit_from_bigstring = Blit.bigstring_bigstring
-end)
+    let blit = Blit.bigstring_bigstring
+    let blit_to_string = Blit.bigstring_bytes
+    let blit_to_bytes = Blit.bigstring_bytes
+    let blit_to_bigstring = Blit.bigstring_bigstring
+    let blit_from_string = Blit.string_bigstring
+    let blit_from_bigstring = Blit.bigstring_bigstring
+  end)
Index: core-0.17.1/core/src/binable0.ml
===================================================================
--- core-0.17.1.orig/core/src/binable0.ml
+++ core-0.17.1/core/src/binable0.ml
@@ -5,77 +5,79 @@ module Shape = Bin_prot.Shape
 
 module Stable = struct
   module Of_binable = struct
-    module V1 (Binable : Minimal.S) (M : Conv_without_uuid with type binable := Binable.t) :
-      S with type t := M.t = Bin_prot.Utils.Make_binable_without_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+    module V1
+        (Binable : Minimal.S)
+        (M : Conv_without_uuid with type binable := Binable.t) : S with type t := M.t =
+    Bin_prot.Utils.Make_binable_without_uuid (struct
+        module Binable = Binable
+        include M
+      end)
     [@@alert "-legacy"]
 
     module V2 (Binable : Minimal.S) (M : Conv with type binable := Binable.t) :
       S with type t := M.t = Bin_prot.Utils.Make_binable_with_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
   end
 
   module Of_binable1 = struct
     module V1
-      (Binable : Minimal.S1)
-      (M : Conv1_without_uuid with type 'a binable := 'a Binable.t) :
+        (Binable : Minimal.S1)
+        (M : Conv1_without_uuid with type 'a binable := 'a Binable.t) :
       S1 with type 'a t := 'a M.t = Bin_prot.Utils.Make_binable1_without_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
     [@@alert "-legacy"]
 
     module V2 (Binable : Minimal.S1) (M : Conv1 with type 'a binable := 'a Binable.t) :
       S1 with type 'a t := 'a M.t = Bin_prot.Utils.Make_binable1_with_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
   end
 
   module Of_binable2 = struct
     module V1
-      (Binable : Minimal.S2)
-      (M : Conv2_without_uuid with type ('a, 'b) binable := ('a, 'b) Binable.t) :
+        (Binable : Minimal.S2)
+        (M : Conv2_without_uuid with type ('a, 'b) binable := ('a, 'b) Binable.t) :
       S2 with type ('a, 'b) t := ('a, 'b) M.t =
     Bin_prot.Utils.Make_binable2_without_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
     [@@alert "-legacy"]
 
     module V2
-      (Binable : Minimal.S2)
-      (M : Conv2 with type ('a, 'b) binable := ('a, 'b) Binable.t) :
+        (Binable : Minimal.S2)
+        (M : Conv2 with type ('a, 'b) binable := ('a, 'b) Binable.t) :
       S2 with type ('a, 'b) t := ('a, 'b) M.t =
     Bin_prot.Utils.Make_binable2_with_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
   end
 
   module Of_binable3 = struct
     module V1
-      (Binable : Minimal.S3)
-      (M : Conv3_without_uuid with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
+        (Binable : Minimal.S3)
+        (M : Conv3_without_uuid with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
       S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t =
     Bin_prot.Utils.Make_binable3_without_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
     [@@alert "-legacy"]
 
     module V2
-      (Binable : Minimal.S3)
-      (M : Conv3 with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
+        (Binable : Minimal.S3)
+        (M : Conv3 with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
       S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t =
     Bin_prot.Utils.Make_binable3_with_uuid (struct
-      module Binable = Binable
-      include M
-    end)
+        module Binable = Binable
+        include M
+      end)
   end
 
   module Of_sexpable = struct
@@ -113,43 +115,43 @@ module Stable = struct
 
   module Of_stringable = struct
     module V1 (M : Stringable.S) = Bin_prot.Utils.Make_binable_without_uuid (struct
-      module Binable = struct
-        type t = string [@@deriving bin_io]
-      end
-
-      type t = M.t
-
-      let to_binable = M.to_string
-
-      (* Wrap exception for improved diagnostics. *)
-      exception Of_binable of string * exn [@@deriving sexp]
-
-      let of_binable s =
-        try M.of_string s with
-        | x -> raise (Of_binable (s, x))
-      ;;
-    end)
+        module Binable = struct
+          type t = string [@@deriving bin_io]
+        end
+
+        type t = M.t
+
+        let to_binable = M.to_string
+
+        (* Wrap exception for improved diagnostics. *)
+        exception Of_binable of string * exn [@@deriving sexp]
+
+        let of_binable s =
+          try M.of_string s with
+          | x -> raise (Of_binable (s, x))
+        ;;
+      end)
     [@@alert "-legacy"]
 
     module V2 (M : Conv_stringable) = Bin_prot.Utils.Make_binable_with_uuid (struct
-      module Binable = struct
-        type t = string [@@deriving bin_io]
-      end
+        module Binable = struct
+          type t = string [@@deriving bin_io]
+        end
 
-      type t = M.t
+        type t = M.t
 
-      let to_binable = M.to_string
+        let to_binable = M.to_string
 
-      (* Wrap exception for improved diagnostics. *)
-      exception Of_binable of string * exn [@@deriving sexp]
+        (* Wrap exception for improved diagnostics. *)
+        exception Of_binable of string * exn [@@deriving sexp]
 
-      let of_binable s =
-        try M.of_string s with
-        | x -> raise (Of_binable (s, x))
-      ;;
+        let of_binable s =
+          try M.of_string s with
+          | x -> raise (Of_binable (s, x))
+        ;;
 
-      let caller_identity = M.caller_identity
-    end)
+        let caller_identity = M.caller_identity
+      end)
   end
 end
 
Index: core-0.17.1/core/src/binable_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/binable_intf.ml
+++ core-0.17.1/core/src/binable_intf.ml
@@ -109,43 +109,43 @@ module type Binable0 = sig
       to be the same as that for some other isomorphic type. *)
 
   module Of_binable_with_uuid
-    (Binable : Minimal.S)
-    (M : Conv with type binable := Binable.t) : S with type t := M.t
+      (Binable : Minimal.S)
+      (M : Conv with type binable := Binable.t) : S with type t := M.t
 
   module Of_binable1_with_uuid
-    (Binable : Minimal.S1)
-    (M : Conv1 with type 'a binable := 'a Binable.t) : S1 with type 'a t := 'a M.t
+      (Binable : Minimal.S1)
+      (M : Conv1 with type 'a binable := 'a Binable.t) : S1 with type 'a t := 'a M.t
 
   module Of_binable2_with_uuid
-    (Binable : Minimal.S2)
-    (M : Conv2 with type ('a, 'b) binable := ('a, 'b) Binable.t) :
+      (Binable : Minimal.S2)
+      (M : Conv2 with type ('a, 'b) binable := ('a, 'b) Binable.t) :
     S2 with type ('a, 'b) t := ('a, 'b) M.t
 
   module Of_binable3_with_uuid
-    (Binable : Minimal.S3)
-    (M : Conv3 with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
+      (Binable : Minimal.S3)
+      (M : Conv3 with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
     S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
 
   module Of_binable_without_uuid
-    (Binable : Minimal.S)
-    (M : Conv_without_uuid with type binable := Binable.t) : S with type t := M.t
+      (Binable : Minimal.S)
+      (M : Conv_without_uuid with type binable := Binable.t) : S with type t := M.t
   [@@alert legacy "Use [Of_binable_with_uuid] if possible."]
 
   module Of_binable1_without_uuid
-    (Binable : Minimal.S1)
-    (M : Conv1_without_uuid with type 'a binable := 'a Binable.t) :
+      (Binable : Minimal.S1)
+      (M : Conv1_without_uuid with type 'a binable := 'a Binable.t) :
     S1 with type 'a t := 'a M.t
   [@@alert legacy "Use [Of_binable1_with_uuid] if possible."]
 
   module Of_binable2_without_uuid
-    (Binable : Minimal.S2)
-    (M : Conv2_without_uuid with type ('a, 'b) binable := ('a, 'b) Binable.t) :
+      (Binable : Minimal.S2)
+      (M : Conv2_without_uuid with type ('a, 'b) binable := ('a, 'b) Binable.t) :
     S2 with type ('a, 'b) t := ('a, 'b) M.t
   [@@alert legacy "Use [Of_binable2_with_uuid] if possible."]
 
   module Of_binable3_without_uuid
-    (Binable : Minimal.S3)
-    (M : Conv3_without_uuid with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
+      (Binable : Minimal.S3)
+      (M : Conv3_without_uuid with type ('a, 'b, 'c) binable := ('a, 'b, 'c) Binable.t) :
     S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
   [@@alert legacy "Use [Of_binable3_with_uuid] if possible."]
 
Index: core-0.17.1/core/src/blang.ml
===================================================================
--- core-0.17.1.orig/core/src/blang.ml
+++ core-0.17.1/core/src/blang.ml
@@ -348,41 +348,41 @@ let values t =
 ;;
 
 module C = Container.Make (struct
-  type 'a t = 'a T.t
+    type 'a t = 'a T.t
 
-  let fold t ~init ~f =
-    let rec loop acc t pending =
-      match t with
-      | Base a -> next (f acc a) pending
-      | True | False -> next acc pending
-      | Not t -> loop acc t pending
-      | And (t1, t2) | Or (t1, t2) -> loop acc t1 (t2 :: pending)
-      | If (t1, t2, t3) -> loop acc t1 (t2 :: t3 :: pending)
-    and next acc = function
-      | [] -> acc
-      | t :: ts -> loop acc t ts
-    in
-    loop init t [] [@nontail]
-  ;;
-
-  (* Don't allocate *)
-  let rec iter t ~f =
-    match t with
-    | Base a -> f a
-    | True | False -> ()
-    | Not t -> iter t ~f
-    | And (t1, t2) | Or (t1, t2) ->
-      iter t1 ~f;
-      iter t2 ~f
-    | If (t1, t2, t3) ->
-      iter t1 ~f;
-      iter t2 ~f;
-      iter t3 ~f
-  ;;
+    let fold t ~init ~f =
+      let rec loop acc t pending =
+        match t with
+        | Base a -> next (f acc a) pending
+        | True | False -> next acc pending
+        | Not t -> loop acc t pending
+        | And (t1, t2) | Or (t1, t2) -> loop acc t1 (t2 :: pending)
+        | If (t1, t2, t3) -> loop acc t1 (t2 :: t3 :: pending)
+      and next acc = function
+        | [] -> acc
+        | t :: ts -> loop acc t ts
+      in
+      loop init t [] [@nontail]
+    ;;
 
-  let iter = `Custom iter
-  let length = `Define_using_fold
-end)
+    (* Don't allocate *)
+    let rec iter t ~f =
+      match t with
+      | Base a -> f a
+      | True | False -> ()
+      | Not t -> iter t ~f
+      | And (t1, t2) | Or (t1, t2) ->
+        iter t1 ~f;
+        iter t2 ~f
+      | If (t1, t2, t3) ->
+        iter t1 ~f;
+        iter t2 ~f;
+        iter t3 ~f
+    ;;
+
+    let iter = `Custom iter
+    let length = `Define_using_fold
+  end)
 
 let count = C.count
 let sum = C.sum
@@ -463,12 +463,12 @@ let eval_set ~universe:all set_of_base t
 ;;
 
 include Monad.Make (struct
-  type 'a t = 'a T.t
+    type 'a t = 'a T.t
 
-  let return = base
-  let bind = bind
-  let map = `Define_using_bind
-end)
+    let return = base
+    let bind = bind
+    let map = `Define_using_bind
+  end)
 
 module type Monadic = sig
   module M : Monad.S
@@ -489,22 +489,22 @@ module For_monad (M : Monad.S) : Monadic
     | And (a, b) ->
       bind a ~f
       >>= (function
-      | False -> M.return false_
-      | True -> bind b ~f
-      | a -> bind b ~f >>| fun b -> andalso a b)
+       | False -> M.return false_
+       | True -> bind b ~f
+       | a -> bind b ~f >>| fun b -> andalso a b)
     | Or (a, b) ->
       bind a ~f
       >>= (function
-      | True -> M.return true_
-      | False -> bind b ~f
-      | a -> bind b ~f >>| fun b -> orelse a b)
+       | True -> M.return true_
+       | False -> bind b ~f
+       | a -> bind b ~f >>| fun b -> orelse a b)
     | Not a -> bind a ~f >>| not_
     | If (a, b, c) ->
       bind a ~f
       >>= (function
-      | True -> bind b ~f
-      | False -> bind c ~f
-      | a -> bind b ~f >>= fun b -> bind c ~f >>| fun c -> if_ a b c)
+       | True -> bind b ~f
+       | False -> bind c ~f
+       | a -> bind b ~f >>= fun b -> bind c ~f >>| fun c -> if_ a b c)
   ;;
 
   let map t ~f = bind t ~f:(fun x -> f x >>| base)
Index: core-0.17.1/core/src/bool.ml
===================================================================
--- core-0.17.1.orig/core/src/bool.ml
+++ core-0.17.1/core/src/bool.ml
@@ -5,7 +5,8 @@ module Stable = struct
     module T = struct
       include Base.Bool
 
-      type t = bool [@@deriving compare, sexp, bin_io ~localize, stable_witness]
+      type t = bool
+      [@@deriving bin_io ~localize, compare, sexp, sexp_grammar, stable_witness]
     end
 
     include T
@@ -41,9 +42,9 @@ let of_string_hum =
       (let table = String.Caseless.Table.create () in
        [ false, [ "false"; "no"; "0" ]; true, [ "true"; "yes"; "1" ] ]
        |> List.iter ~f:(fun (bool, strings) ->
-            List.iter strings ~f:(fun string ->
-              Hashtbl.set table ~key:string ~data:bool;
-              Hashtbl.set table ~key:(String.prefix string 1) ~data:bool));
+         List.iter strings ~f:(fun string ->
+           Hashtbl.set table ~key:string ~data:bool;
+           Hashtbl.set table ~key:(String.prefix string 1) ~data:bool));
        table)
   in
   let raise_invalid input =
Index: core-0.17.1/core/src/bool.mli
===================================================================
--- core-0.17.1.orig/core/src/bool.mli
+++ core-0.17.1/core/src/bool.mli
@@ -6,8 +6,8 @@ include module type of Base.Bool with ty
 
 include
   Identifiable.S
-    with type t := t
-     and type comparator_witness := Base.Bool.comparator_witness
+  with type t := t
+   and type comparator_witness := Base.Bool.comparator_witness
 
 (**
    Human readable parsing. Accepted inputs are (case insensitive):
@@ -23,11 +23,12 @@ include Quickcheckable.S with type t :=
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@deriving bin_io ~localize, compare, equal, hash, sexp]
+    type nonrec t = t
+    [@@deriving bin_io ~localize, compare, equal, hash, sexp, sexp_grammar]
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-        with type comparator_witness = comparator_witness
+      with type t := t
+      with type comparator_witness = comparator_witness
   end
 end
Index: core-0.17.1/core/src/bounded_index.ml
===================================================================
--- core-0.17.1.orig/core/src/bounded_index.ml
+++ core-0.17.1/core/src/bounded_index.ml
@@ -4,8 +4,8 @@ open! Stable_internal
 module Stable = struct
   module V1 = struct
     module Make (M : sig
-      val label : string
-    end) =
+        val label : string
+      end) =
     struct
       type t =
         { index : int
@@ -44,15 +44,15 @@ module Stable = struct
           end)
 
       include Comparator.Stable.V1.Make (struct
-        type nonrec t = t [@@deriving sexp_of, compare]
-      end)
+          type nonrec t = t [@@deriving sexp_of, compare]
+        end)
 
       include Comparable.Stable.V1.With_stable_witness.Make (struct
-        type nonrec t = t [@@deriving sexp, compare, bin_io, stable_witness]
-        type nonrec comparator_witness = comparator_witness
+          type nonrec t = t [@@deriving sexp, compare, bin_io, stable_witness]
+          type nonrec comparator_witness = comparator_witness
 
-        let comparator = comparator
-      end)
+          let comparator = comparator
+        end)
     end
   end
 end
@@ -62,9 +62,9 @@ open! Std_internal
 module type S = Bounded_index_intf.S
 
 module Make (M : sig
-  val label : string
-  val module_name : string
-end) =
+    val label : string
+    val module_name : string
+  end) =
 struct
   module Stable = struct
     module V1 = Stable.V1.Make (M)
@@ -90,16 +90,16 @@ struct
   let num_indexes t = max_index t - min_index t + 1
 
   include Sexpable.To_stringable (struct
-    type nonrec t = t [@@deriving sexp]
-  end)
+      type nonrec t = t [@@deriving sexp]
+    end)
 
   include Identifiable.Make_using_comparator (struct
-    type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
-    type nonrec comparator_witness = comparator_witness
+      type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
+      type nonrec comparator_witness = comparator_witness
 
-    let comparator = comparator
-    let of_string = of_string
-    let to_string = to_string
-    let module_name = M.module_name
-  end)
+      let comparator = comparator
+      let of_string = of_string
+      let to_string = to_string
+      let module_name = M.module_name
+    end)
 end
Index: core-0.17.1/core/src/bounded_index_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/bounded_index_intf.ml
+++ core-0.17.1/core/src/bounded_index_intf.ml
@@ -34,8 +34,8 @@ module type S = sig
   module Stable : sig
     module V1 :
       Stable_comparable.With_stable_witness.V1
-        with type t = t
-        with type comparator_witness = comparator_witness
+      with type t = t
+      with type comparator_witness = comparator_witness
   end
 end
 
@@ -54,7 +54,7 @@ module type Bounded_index = sig
   module type S = S
 
   module Make (M : sig
-    val label : string
-    val module_name : string
-  end) : S
+      val label : string
+      val module_name : string
+    end) : S
 end
Index: core-0.17.1/core/src/byte_units.ml
===================================================================
--- core-0.17.1.orig/core/src/byte_units.ml
+++ core-0.17.1/core/src/byte_units.ml
@@ -147,33 +147,49 @@ module Stable = struct
   (* Share the common [of_sexp] code for [V1] and [V2]. *)
   module Of_sexp_v1_v2 : sig
     val t_of_sexp : Sexp.t -> t
+    val t_sexp_grammar : t Sexplib.Sexp_grammar.t
   end = struct
     let no_match () = failwith "Not a recognized [Byte_units.t] representation"
 
-    let of_value_sexp_and_unit_name val_sexp = function
-      | "Bytes" ->
-        (try of_bytes_int63 (Int63.t_of_sexp val_sexp) with
-         | _ -> of_bytes_float_exn (Float.t_of_sexp val_sexp))
-      | "Kilobytes" -> of_kilobytes (float_of_sexp val_sexp)
-      | "Megabytes" -> of_megabytes (float_of_sexp val_sexp)
-      | "Gigabytes" -> of_gigabytes (float_of_sexp val_sexp)
-      | "Terabytes" -> of_terabytes (float_of_sexp val_sexp)
-      | "Petabytes" -> of_petabytes (float_of_sexp val_sexp)
-      | "Exabytes" -> of_exabytes (float_of_sexp val_sexp)
-      | "Words" -> of_words_float_exn (float_of_sexp val_sexp)
-      | _ -> no_match ()
-    ;;
-
-    let t_of_sexp = function
-      | Sexp.Atom str -> of_string str
-      | Sexp.List [ Sexp.Atom unit_name; value ] ->
-        of_value_sexp_and_unit_name value unit_name
-      | _ -> no_match ()
-    ;;
-
-    let t_of_sexp sexp =
-      try t_of_sexp sexp with
-      | exn -> raise (Sexp.Of_sexp_error (exn, sexp))
+    let t_of_sexp, t_sexp_grammar =
+      Sexplib.Sexp_grammar.remember_to_update_these_together
+        ~t_of_sexp:(fun sexp ->
+          try
+            match sexp with
+            | Sexp.Atom str -> of_string str
+            | Sexp.List [ Sexp.Atom unit_name; val_sexp ] ->
+              (match unit_name with
+               | "Bytes" ->
+                 (try of_bytes_int63 (Int63.t_of_sexp val_sexp) with
+                  | _ -> of_bytes_float_exn (Float.t_of_sexp val_sexp))
+               | "Kilobytes" -> of_kilobytes (float_of_sexp val_sexp)
+               | "Megabytes" -> of_megabytes (float_of_sexp val_sexp)
+               | "Gigabytes" -> of_gigabytes (float_of_sexp val_sexp)
+               | "Terabytes" -> of_terabytes (float_of_sexp val_sexp)
+               | "Petabytes" -> of_petabytes (float_of_sexp val_sexp)
+               | "Exabytes" -> of_exabytes (float_of_sexp val_sexp)
+               | "Words" -> of_words_float_exn (float_of_sexp val_sexp)
+               | _ -> no_match ())
+            | _ -> no_match ()
+          with
+          | exn -> raise (Sexp.Of_sexp_error (exn, sexp)))
+        ~t_sexp_grammar:
+          { untyped =
+              Union
+                [ String
+                ; [%sexp_grammar:
+                    [ `Bytes of float
+                    | `Exabytes of float
+                    | `Gigabytes of float
+                    | `Kilobytes of float
+                    | `Megabytes of float
+                    | `Petabytes of float
+                    | `Terabytes of float
+                    | `Words of float
+                    ]]
+                    .untyped
+                ]
+          }
     ;;
   end
 
Index: core-0.17.1/core/src/byte_units.mli
===================================================================
--- core-0.17.1.orig/core/src/byte_units.mli
+++ core-0.17.1/core/src/byte_units.mli
@@ -19,8 +19,8 @@ open! Import
 type t [@@deriving sexp_of, typerep] [@@immediate64]
 
 val create : [ `Bytes | `Kilobytes | `Megabytes | `Gigabytes | `Words ] -> float -> t
-  [@@deprecated
-    "[since 2019-01] Use [of_bytes], [of_kilobytes], [of_megabytes], etc as appropriate."]
+[@@deprecated
+  "[since 2019-01] Use [of_bytes], [of_kilobytes], [of_megabytes], etc as appropriate."]
 
 include Comparable.S_plain with type t := t
 include Hashable.S_plain with type t := t
@@ -28,9 +28,9 @@ include Stringable.S with type t := t
 
 (** This is a deprecated alias for [of_bytes_float_exn]. *)
 val of_bytes : float -> t
-  [@@deprecated
-    "[since 2019-01] Use [of_bytes_int], [of_bytes_int63], [of_bytes_int64_exn] or \
-     [of_bytes_float_exn] as appropriate."]
+[@@deprecated
+  "[since 2019-01] Use [of_bytes_int], [of_bytes_int63], [of_bytes_int64_exn] or \
+   [of_bytes_float_exn] as appropriate."]
 
 val of_bytes_int : int -> t
 val of_bytes_int63 : Int63.t -> t
@@ -69,7 +69,7 @@ val of_exabytes : float -> t
 
 (** Do not use, consider using [of_words_int] instead. Alias for [of_words_float_exn]. *)
 val of_words : float -> t
-  [@@deprecated "[since 2019-01] Use [of_words_int] or [of_words_float_exn] instead."]
+[@@deprecated "[since 2019-01] Use [of_words_int] or [of_words_float_exn] instead."]
 
 (** create of [Byte_units] based on the number of machine words. *)
 val of_words_int : int -> t
@@ -87,7 +87,7 @@ val of_words_float_exn : float -> t
 val to_string_hum : t -> string
 
 val to_string_short : t -> string
-  [@@deprecated "[since 2020-06] Use [Short.to_string] instead."]
+[@@deprecated "[since 2020-06] Use [Short.to_string] instead."]
 
 module Short : sig
   type nonrec t = t [@@deriving sexp_of]
@@ -105,9 +105,9 @@ end
 
 (** This is a deprecated alias for [bytes_float]. *)
 val bytes : t -> float
-  [@@deprecated
-    "[since 2019-01] Use [bytes_int_exn], [bytes_int63], [bytes_int64] or [bytes_float] \
-     as appropriate."]
+[@@deprecated
+  "[since 2019-01] Use [bytes_int_exn], [bytes_int63], [bytes_int64] or [bytes_float] as \
+   appropriate."]
 
 (** This will raise if and only if the value of this [Byte_units.t] can not be represented
     as an int.
@@ -128,7 +128,7 @@ val exabytes : t -> float
 
 (** Do not use, consider using [words_int_exn] instead. Alias for [words_float] *)
 val words : t -> float
-  [@@deprecated "[since 2019-01] Use [words_int_exn] or [words_float] instead."]
+[@@deprecated "[since 2019-01] Use [words_int_exn] or [words_float] instead."]
 
 (** In JS and on 32-bit OCaml this will raise if and only if the number of bytes is outside
     of \[-2^32,2^32). *)
@@ -171,7 +171,7 @@ module Stable : sig
 
   (*_ new [Int63] based [bin_io] repr. *)
   module V2 : sig
-    type nonrec t = t [@@deriving equal, hash, typerep]
+    type nonrec t = t [@@deriving equal, hash, sexp_grammar, typerep]
 
     include Stable_module_types.With_stable_witness.S0_without_comparator with type t := t
   end
Index: core-0.17.1/core/src/bytes.ml
===================================================================
--- core-0.17.1.orig/core/src/bytes.ml
+++ core-0.17.1/core/src/bytes.ml
@@ -13,11 +13,11 @@ include Stable.V1
 include Comparable.Validate (Base.Bytes)
 
 include Hexdump.Of_indexable (struct
-  type t = bytes
+    type t = bytes
 
-  let length = length
-  let get = get
-end)
+    let length = length
+    let get t i = get t i
+  end)
 
 let gen' char_gen = String.gen' char_gen |> Quickcheck.Generator.map ~f:of_string
 
Index: core-0.17.1/core/src/bytes.mli
===================================================================
--- core-0.17.1.orig/core/src/bytes.mli
+++ core-0.17.1/core/src/bytes.mli
@@ -29,7 +29,7 @@ module Stable : sig
 
     include
       Stable_module_types.With_stable_witness.S0
-        with type t := t
-        with type comparator_witness := comparator_witness
+      with type t := t
+      with type comparator_witness := comparator_witness
   end
 end
Index: core-0.17.1/core/src/char.mli
===================================================================
--- core-0.17.1.orig/core/src/char.mli
+++ core-0.17.1/core/src/char.mli
@@ -20,7 +20,7 @@ include module type of struct
     [Caseless.Map], [Caseless.Table] lookup and [Caseless.Set] membership is
     case-insensitive. *)
 module Caseless : sig
-  type nonrec t = t [@@deriving bin_io ~localize, hash, sexp]
+  type nonrec t = t [@@deriving bin_io ~localize, hash, sexp, sexp_grammar]
 
   include Comparable.S_binable with type t := t
   include Hashable.S_binable with type t := t
@@ -50,7 +50,7 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
   end
 end
Index: core-0.17.1/core/src/command_internal.ml
===================================================================
--- core-0.17.1.orig/core/src/command_internal.ml
+++ core-0.17.1/core/src/command_internal.ml
@@ -17,9 +17,9 @@ end
 module Param = struct
   include (
     Param :
-      sig
-        include module type of Param with module Arg_type := Param.Arg_type
-      end)
+    sig
+      include module type of Param with module Arg_type := Param.Arg_type
+    end)
 
   module Arg_type = Arg_type
   include Arg_type.Export
@@ -28,9 +28,9 @@ end
 module Spec = struct
   include (
     Spec :
-      sig
-        include module type of Spec with module Arg_type := Spec.Arg_type
-      end)
+    sig
+      include module type of Spec with module Arg_type := Spec.Arg_type
+    end)
 
   module Arg_type = Arg_type
   include Arg_type.Export
Index: core-0.17.1/core/src/comparable.ml
===================================================================
--- core-0.17.1.orig/core/src/comparable.ml
+++ core-0.17.1/core/src/comparable.ml
@@ -4,8 +4,8 @@ module Infix = Base.Comparable.Infix
 module Comparisons = Base.Comparable.Comparisons
 
 module Validate (T : sig
-  type t [@@deriving compare, sexp_of]
-end) : Validate with type t := T.t = struct
+    type t [@@deriving compare, sexp_of]
+  end) : Validate with type t := T.t = struct
   module V = Validate
   open Maybe_bound
 
@@ -20,10 +20,10 @@ end) : Validate with type t := T.t = str
 end
 
 module Validate_with_zero (T : sig
-  type t [@@deriving compare, sexp_of]
+    type t [@@deriving compare, sexp_of]
 
-  val zero : t
-end) =
+    val zero : t
+  end) =
 struct
   module V = Validate (T)
   include V
@@ -39,20 +39,20 @@ struct
 end
 
 module With_zero (T : sig
-  type t [@@deriving compare, sexp_of]
+    type t [@@deriving compare, sexp_of]
 
-  val zero : t
-end) =
+    val zero : t
+  end) =
 struct
   include Validate_with_zero (T)
   include Base.Comparable.With_zero (T)
 end
 
 module Map_and_set_binable_using_comparator (T : sig
-  type t [@@deriving bin_io, compare, sexp]
+    type t [@@deriving bin_io, compare, sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include T
   module Map = Map.Make_binable_using_comparator (T)
@@ -60,16 +60,16 @@ struct
 end
 
 module Map_and_set_binable (T : sig
-  type t [@@deriving bin_io, compare, sexp]
-end) =
+    type t [@@deriving bin_io, compare, sexp]
+  end) =
 Map_and_set_binable_using_comparator (struct
-  include T
-  include Comparator.Make (T)
-end)
+    include T
+    include Comparator.Make (T)
+  end)
 
 module Poly (T : sig
-  type t [@@deriving sexp]
-end) =
+    type t [@@deriving sexp]
+  end) =
 struct
   module C = struct
     include T
@@ -84,19 +84,19 @@ struct
 end
 
 module Make_plain_using_comparator (T : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) : S_plain with type t := T.t and type comparator_witness = T.comparator_witness =
+    include Comparator.S with type t := t
+  end) : S_plain with type t := T.t and type comparator_witness = T.comparator_witness =
 struct
   include T
   module M = Base.Comparable.Make_using_comparator (T)
   include M
 
   include Validate (struct
-    include T
-    include M
-  end)
+      include T
+      include M
+    end)
 
   module Replace_polymorphic_compare : Comparisons with type t := t = M
   module Map = Map.Make_plain_using_comparator (T)
@@ -104,26 +104,26 @@ struct
 end
 
 module Make_plain (T : sig
-  type t [@@deriving compare, sexp_of]
-end) =
+    type t [@@deriving compare, sexp_of]
+  end) =
 Make_plain_using_comparator (struct
-  include T
-  include Comparator.Make (T)
-end)
+    include T
+    include Comparator.Make (T)
+  end)
 
 module Make_using_comparator (T : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) : S with type t := T.t and type comparator_witness = T.comparator_witness = struct
+    include Comparator.S with type t := t
+  end) : S with type t := T.t and type comparator_witness = T.comparator_witness = struct
   include T
   module M = Base.Comparable.Make_using_comparator (T)
   include M
 
   include Validate (struct
-    include T
-    include M
-  end)
+      include T
+      include M
+    end)
 
   module Replace_polymorphic_compare : Comparisons with type t := t = M
   module Map = Map.Make_using_comparator (T)
@@ -131,26 +131,26 @@ end) : S with type t := T.t and type com
 end
 
 module Make (T : sig
-  type t [@@deriving compare, sexp]
-end) : S with type t := T.t = Make_using_comparator (struct
-  include T
-  include Comparator.Make (T)
-end)
+    type t [@@deriving compare, sexp]
+  end) : S with type t := T.t = Make_using_comparator (struct
+    include T
+    include Comparator.Make (T)
+  end)
 
 module Make_binable_using_comparator (T : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include T
   module M = Base.Comparable.Make_using_comparator (T)
 
   include Validate (struct
-    include T
+      include T
 
-    let compare = T.comparator.compare
-  end)
+      let compare = T.comparator.compare
+    end)
 
   include M
   module Replace_polymorphic_compare : Comparisons with type t := t = M
@@ -159,19 +159,20 @@ struct
 end
 
 module Make_binable (T : sig
-  type t [@@deriving bin_io, compare, sexp]
-end) =
+    type t [@@deriving bin_io, compare, sexp]
+  end) =
 struct
   include Make_binable_using_comparator (struct
-    include T
-    include Comparator.Make (T)
-  end)
+      include T
+      include Comparator.Make (T)
+    end)
 end
 
 module Extend_plain
-  (M : Base.Comparable.S) (X : sig
-    type t = M.t [@@deriving sexp_of]
-  end) =
+    (M : Base.Comparable.S)
+    (X : sig
+       type t = M.t [@@deriving sexp_of]
+     end) =
 struct
   module T = struct
     include M
@@ -192,9 +193,10 @@ struct
 end
 
 module Extend
-  (M : Base.Comparable.S) (X : sig
-    type t = M.t [@@deriving sexp]
-  end) =
+    (M : Base.Comparable.S)
+    (X : sig
+       type t = M.t [@@deriving sexp]
+     end) =
 struct
   module T = struct
     include M
@@ -215,9 +217,10 @@ struct
 end
 
 module Extend_binable
-  (M : Base.Comparable.S) (X : sig
-    type t = M.t [@@deriving bin_io, sexp]
-  end) =
+    (M : Base.Comparable.S)
+    (X : sig
+       type t = M.t [@@deriving bin_io, sexp]
+     end) =
 struct
   module T = struct
     include M
@@ -237,18 +240,20 @@ struct
   module Set = Set.Make_binable_using_comparator (T)
 end
 
-module Inherit (C : sig
-  type t [@@deriving compare]
-end) (T : sig
-  type t [@@deriving sexp]
+module Inherit
+    (C : sig
+       type t [@@deriving compare]
+     end)
+    (T : sig
+       type t [@@deriving sexp]
 
-  val component : t -> C.t
-end) =
+       val component : t -> C.t
+     end) =
 Make (struct
-  type t = T.t [@@deriving sexp]
+    type t = T.t [@@deriving sexp]
 
-  let compare t t' = C.compare (T.component t) (T.component t')
-end)
+    let compare t t' = C.compare (T.component t) (T.component t')
+  end)
 
 include (Base.Comparable : With_compare)
 
@@ -260,13 +265,13 @@ module Stable = struct
 
       module Map :
         Map.Stable.V1.S
-          with type key := comparable
-          with type comparator_witness := comparator_witness
+        with type key := comparable
+        with type comparator_witness := comparator_witness
 
       module Set :
         Set.Stable.V1.S
-          with type elt := comparable
-          with type elt_comparator_witness := comparator_witness
+        with type elt := comparable
+        with type elt_comparator_witness := comparator_witness
     end
 
     module Make (X : Stable_module_types.S0) = struct
@@ -281,13 +286,13 @@ module Stable = struct
 
         module Map :
           Map.Stable.V1.With_stable_witness.S
-            with type key := comparable
-            with type comparator_witness := comparator_witness
+          with type key := comparable
+          with type comparator_witness := comparator_witness
 
         module Set :
           Set.Stable.V1.With_stable_witness.S
-            with type elt := comparable
-            with type elt_comparator_witness := comparator_witness
+          with type elt := comparable
+          with type elt_comparator_witness := comparator_witness
       end
 
       module Make (X : Stable_module_types.With_stable_witness.S0) = struct
Index: core-0.17.1/core/src/comparable_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/comparable_intf.ml
+++ core-0.17.1/core/src/comparable_intf.ml
@@ -1,7 +1,9 @@
 open! Import
 
 module type Infix = Base.Comparable.Infix
+module type Infix_with_zero_alloc = Base.Comparable.Infix_with_zero_alloc
 module type Comparisons = Base.Comparable.Comparisons
+module type Comparisons_with_zero_alloc = Base.Comparable.Comparisons_with_zero_alloc
 module type With_compare = Base.Comparable.With_compare
 
 module type Validate = sig
@@ -74,13 +76,13 @@ module type Map_and_set_binable = sig
 
   module Map :
     Map.S_binable
-      with type Key.t = t
-      with type Key.comparator_witness = comparator_witness
+    with type Key.t = t
+    with type Key.comparator_witness = comparator_witness
 
   module Set :
     Set.S_binable
-      with type Elt.t = t
-      with type Elt.comparator_witness = comparator_witness
+    with type Elt.t = t
+    with type Elt.comparator_witness = comparator_witness
 end
 
 module type S_binable = sig
@@ -88,8 +90,8 @@ module type S_binable = sig
 
   include
     Map_and_set_binable
-      with type t := t
-      with type comparator_witness := comparator_witness
+    with type t := t
+    with type comparator_witness := comparator_witness
 end
 
 module type Comparable = sig
@@ -140,8 +142,10 @@ module type Comparable = sig
   *)
 
   module type Infix = Infix
+  module type Infix_with_zero_alloc = Infix_with_zero_alloc
   module type Map_and_set_binable = Map_and_set_binable
   module type Comparisons = Comparisons
+  module type Comparisons_with_zero_alloc = Comparisons_with_zero_alloc
   module type S_plain = S_plain
   module type S = S
   module type S_binable = S_binable
@@ -154,13 +158,15 @@ module type Comparable = sig
   include With_compare
 
   (** Inherit comparability from a component. *)
-  module Inherit (C : sig
-    type t [@@deriving compare]
-  end) (T : sig
-    type t [@@deriving sexp]
+  module Inherit
+      (C : sig
+         type t [@@deriving compare]
+       end)
+      (T : sig
+         type t [@@deriving sexp]
 
-    val component : t -> C.t
-  end) : S with type t := T.t
+         val component : t -> C.t
+       end) : S with type t := T.t
 
   (** {2 Comparison-only Functors}
 
@@ -169,12 +175,12 @@ module type Comparable = sig
   *)
 
   module Infix (T : sig
-    type t [@@deriving compare]
-  end) : Infix with type t := T.t
+      type t [@@deriving compare]
+    end) : Infix with type t := T.t
 
   module Comparisons (T : sig
-    type t [@@deriving compare]
-  end) : Comparisons with type t := T.t
+      type t [@@deriving compare]
+    end) : Comparisons with type t := T.t
 
   (** {2 Make Functors}
 
@@ -189,83 +195,88 @@ module type Comparable = sig
   *)
 
   module Make_plain (T : sig
-    type t [@@deriving compare, sexp_of]
-  end) : S_plain with type t := T.t
+      type t [@@deriving compare, sexp_of]
+    end) : S_plain with type t := T.t
 
   module Make (T : sig
-    type t [@@deriving compare, sexp]
-  end) : S with type t := T.t
+      type t [@@deriving compare, sexp]
+    end) : S with type t := T.t
 
   module Make_plain_using_comparator (T : sig
-    type t [@@deriving sexp_of]
+      type t [@@deriving sexp_of]
 
-    include Comparator.S with type t := t
-  end) : S_plain with type t := T.t with type comparator_witness := T.comparator_witness
+      include Comparator.S with type t := t
+    end) : S_plain with type t := T.t with type comparator_witness := T.comparator_witness
 
   module Make_using_comparator (T : sig
-    type t [@@deriving sexp]
+      type t [@@deriving sexp]
 
-    include Comparator.S with type t := t
-  end) : S with type t := T.t with type comparator_witness := T.comparator_witness
+      include Comparator.S with type t := t
+    end) : S with type t := T.t with type comparator_witness := T.comparator_witness
 
   module Make_binable (T : sig
-    type t [@@deriving bin_io, compare, sexp]
-  end) : S_binable with type t := T.t
+      type t [@@deriving bin_io, compare, sexp]
+    end) : S_binable with type t := T.t
 
   module Make_binable_using_comparator (T : sig
-    type t [@@deriving bin_io, sexp]
+      type t [@@deriving bin_io, sexp]
 
-    include Comparator.S with type t := t
-  end) : S_binable with type t := T.t with type comparator_witness := T.comparator_witness
+      include Comparator.S with type t := t
+    end) :
+    S_binable with type t := T.t with type comparator_witness := T.comparator_witness
 
   module Extend_plain
-    (M : Base.Comparable.S) (X : sig
-      type t = M.t [@@deriving sexp_of]
-    end) : S_plain with type t := M.t with type comparator_witness := M.comparator_witness
+      (M : Base.Comparable.S)
+      (X : sig
+         type t = M.t [@@deriving sexp_of]
+       end) :
+    S_plain with type t := M.t with type comparator_witness := M.comparator_witness
 
   module Extend
-    (M : Base.Comparable.S) (X : sig
-      type t = M.t [@@deriving sexp]
-    end) : S with type t := M.t with type comparator_witness := M.comparator_witness
+      (M : Base.Comparable.S)
+      (X : sig
+         type t = M.t [@@deriving sexp]
+       end) : S with type t := M.t with type comparator_witness := M.comparator_witness
 
   module Extend_binable
-    (M : Base.Comparable.S) (X : sig
-      type t = M.t [@@deriving bin_io, sexp]
-    end) :
+      (M : Base.Comparable.S)
+      (X : sig
+         type t = M.t [@@deriving bin_io, sexp]
+       end) :
     S_binable with type t := M.t with type comparator_witness := M.comparator_witness
 
   module Map_and_set_binable (T : sig
-    type t [@@deriving bin_io, compare, sexp]
-  end) : Map_and_set_binable with type t := T.t
+      type t [@@deriving bin_io, compare, sexp]
+    end) : Map_and_set_binable with type t := T.t
 
   module Map_and_set_binable_using_comparator (T : sig
-    type t [@@deriving bin_io, compare, sexp]
+      type t [@@deriving bin_io, compare, sexp]
 
-    include Comparator.S with type t := t
-  end) :
+      include Comparator.S with type t := t
+    end) :
     Map_and_set_binable
-      with type t := T.t
-      with type comparator_witness := T.comparator_witness
+    with type t := T.t
+    with type comparator_witness := T.comparator_witness
 
   module Poly (T : sig
-    type t [@@deriving sexp]
-  end) : S with type t := T.t
+      type t [@@deriving sexp]
+    end) : S with type t := T.t
 
   module Validate (T : sig
-    type t [@@deriving compare, sexp_of]
-  end) : Validate with type t := T.t
+      type t [@@deriving compare, sexp_of]
+    end) : Validate with type t := T.t
 
   module Validate_with_zero (T : sig
-    type t [@@deriving compare, sexp_of]
+      type t [@@deriving compare, sexp_of]
 
-    val zero : t
-  end) : Validate_with_zero with type t := T.t
+      val zero : t
+    end) : Validate_with_zero with type t := T.t
 
   module With_zero (T : sig
-    type t [@@deriving compare, sexp_of]
+      type t [@@deriving compare, sexp_of]
 
-    val zero : t
-  end) : With_zero with type t := T.t
+      val zero : t
+    end) : With_zero with type t := T.t
 
   (** The following module types and functors may be used to define stable modules: *)
 
@@ -277,13 +288,13 @@ module type Comparable = sig
 
         module Map :
           Map.Stable.V1.S
-            with type key := comparable
-            with type comparator_witness := comparator_witness
+          with type key := comparable
+          with type comparator_witness := comparator_witness
 
         module Set :
           Set.Stable.V1.S
-            with type elt := comparable
-            with type elt_comparator_witness := comparator_witness
+          with type elt := comparable
+          with type elt_comparator_witness := comparator_witness
       end
 
       module Make (X : Stable_module_types.S0) :
@@ -296,19 +307,19 @@ module type Comparable = sig
 
           module Map :
             Map.Stable.V1.With_stable_witness.S
-              with type key := comparable
-              with type comparator_witness := comparator_witness
+            with type key := comparable
+            with type comparator_witness := comparator_witness
 
           module Set :
             Set.Stable.V1.With_stable_witness.S
-              with type elt := comparable
-              with type elt_comparator_witness := comparator_witness
+            with type elt := comparable
+            with type elt_comparator_witness := comparator_witness
         end
 
         module Make (X : Stable_module_types.With_stable_witness.S0) :
           S
-            with type comparable := X.t
-            with type comparator_witness := X.comparator_witness
+          with type comparable := X.t
+          with type comparator_witness := X.comparator_witness
       end
     end
   end
Index: core-0.17.1/core/src/core.ml
===================================================================
--- core-0.17.1.orig/core/src/core.ml
+++ core-0.17.1/core/src/core.ml
@@ -100,6 +100,7 @@ module Map_intf = Map_intf
 module Maybe_bound = Maybe_bound
 module Md5 = Md5
 module Memo = Memo
+module Modes = Modes
 module Monad = Monad
 module Month = Month
 
@@ -164,6 +165,7 @@ module Time = Time_float
 
 module Time_float = Time_float
 module Time_ns = Time_ns
+module Timezone = Timezone
 module Tuple = Tuple
 module Tuple2 = Tuple.T2
 module Tuple3 = Tuple.T3
Index: core-0.17.1/core/src/core_bin_prot.ml
===================================================================
--- core-0.17.1.orig/core/src/core_bin_prot.ml
+++ core-0.17.1/core/src/core_bin_prot.ml
@@ -33,7 +33,7 @@ end
 module Reader = struct
   type 'a t = 'a Bin_prot.Type_class.reader =
     { read : 'a Read.reader
-    ; vtag_read : (int -> 'a) Read.reader
+    ; vtag_read : 'a Read.vtag_reader
     }
 
   let of_bigstring t buf =
Index: core-0.17.1/core/src/core_bin_prot.mli
===================================================================
--- core-0.17.1.orig/core/src/core_bin_prot.mli
+++ core-0.17.1/core/src/core_bin_prot.mli
@@ -15,7 +15,7 @@ end
 module Reader : sig
   type 'a t = 'a Bin_prot.Type_class.reader =
     { read : 'a Read.reader
-    ; vtag_read : (int -> 'a) Read.reader
+    ; vtag_read : 'a Read.vtag_reader
     }
 
   val of_string : 'a t -> string -> 'a
Index: core-0.17.1/core/src/core_pervasives.mli
===================================================================
--- core-0.17.1.orig/core/src/core_pervasives.mli
+++ core-0.17.1/core/src/core_pervasives.mli
@@ -101,11 +101,11 @@ val max : 'a -> 'a -> 'a
     implementation-dependent; however, it is guaranteed that
     [e1 == e2] implies [compare e1 e2 = 0]. *)
 external ( == ) : ('a[@local_opt]) -> ('a[@local_opt]) -> bool = "%eq"
-  [@@deprecated "[since 2014-10] Use [phys_equal]"]
+[@@deprecated "[since 2014-10] Use [phys_equal]"]
 
 (** Negation of {!( == )}. *)
 external ( != ) : ('a[@local_opt]) -> ('a[@local_opt]) -> bool = "%noteq"
-  [@@deprecated "[since 2014-10] Use [phys_equal]"]
+[@@deprecated "[since 2014-10] Use [phys_equal]"]
 
 (** {6 Boolean operations} *)
 
@@ -248,11 +248,11 @@ val abs : int -> int
 
 (** The greatest representable integer. *)
 val max_int : int
-  [@@deprecated "[since 2014-10] Use [Int.max_value]"]
+[@@deprecated "[since 2014-10] Use [Int.max_value]"]
 
 (** The smallest representable integer. *)
 val min_int : int
-  [@@deprecated "[since 2014-10] Use [Int.min_value]"]
+[@@deprecated "[since 2014-10] Use [Int.min_value]"]
 
 (** {7 Bitwise operations} *)
 
@@ -337,70 +337,70 @@ external ( /. )
 
 (** Exponentiation. *)
 external ( ** ) : float -> float -> float = "caml_power_float" "pow"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 (** Square root. *)
 external sqrt : float -> float = "caml_sqrt_float" "sqrt"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 (** Exponential. *)
 external exp : float -> float = "caml_exp_float" "exp"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 (** Natural logarithm. *)
 external log : float -> float = "caml_log_float" "log"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 (** Base 10 logarithm. *)
 external log10 : float -> float = "caml_log10_float" "log10"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.log10]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.log10]"]
 
 (** [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results
     even if [x] is close to [0.0].
     @since 3.12.0
 *)
 external expm1 : float -> float = "caml_expm1_float" "caml_expm1"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.expm1]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.expm1]"]
 
 (** [log1p x] computes [log(1.0 +. x)] (natural logarithm),
     giving numerically-accurate results even if [x] is close to [0.0].
     @since 3.12.0
 *)
 external log1p : float -> float = "caml_log1p_float" "caml_log1p"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.log1p]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.log1p]"]
 
 (** Cosine.  Argument is in radians. *)
 external cos : float -> float = "caml_cos_float" "cos"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.cos]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.cos]"]
 
 (** Sine.  Argument is in radians. *)
 external sin : float -> float = "caml_sin_float" "sin"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.sin]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.sin]"]
 
 (** Tangent.  Argument is in radians. *)
 external tan : float -> float = "caml_tan_float" "tan"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.tan]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.tan]"]
 
 (** Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [0.0] and [pi]. *)
 external acos : float -> float = "caml_acos_float" "acos"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.acos]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.acos]"]
 
 (** Arc sine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 external asin : float -> float = "caml_asin_float" "asin"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.asin]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.asin]"]
 
 (** Arc tangent.
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 external atan : float -> float = "caml_atan_float" "atan"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.atan]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.atan]"]
 
 (** [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x]
     and [y] are used to determine the quadrant of the result.
     Result is in radians and is between [-pi] and [pi]. *)
 external atan2 : float -> float -> float = "caml_atan2_float" "atan2"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.atan2]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.atan2]"]
 
 (** [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length
     of the hypotenuse of a right-angled triangle with sides of length
@@ -408,19 +408,19 @@ external atan2 : float -> float -> float
     to origin.
     @since 4.00.0  *)
 external hypot : float -> float -> float = "caml_hypot_float" "caml_hypot"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.hypot]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.hypot]"]
 
 (** Hyperbolic cosine.  Argument is in radians. *)
 external cosh : float -> float = "caml_cosh_float" "cosh"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.cosh]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.cosh]"]
 
 (** Hyperbolic sine.  Argument is in radians. *)
 external sinh : float -> float = "caml_sinh_float" "sinh"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.sinh]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.sinh]"]
 
 (** Hyperbolic tangent.  Argument is in radians. *)
 external tanh : float -> float = "caml_tanh_float" "tanh"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.tanh]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.tanh]"]
 
 (** Hyperbolic arc cosine.  The argument must fall within the range
     [[1.0, inf]].
@@ -429,7 +429,7 @@ external tanh : float -> float = "caml_t
     @since 4.13.0
 *)
 external acosh : float -> float = "caml_acosh_float" "caml_acosh"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2022-11] Use [Float.acosh]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2022-11] Use [Float.acosh]"]
 
 (** Hyperbolic arc sine.  The argument and result range over the entire
     real line.
@@ -438,7 +438,7 @@ external acosh : float -> float = "caml_
     @since 4.13.0
 *)
 external asinh : float -> float = "caml_asinh_float" "caml_asinh"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2022-11] Use [Float.asinh]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2022-11] Use [Float.asinh]"]
 
 (** Hyperbolic arc tangent.  The argument must fall within the range
     [[-1.0, 1.0]].
@@ -447,24 +447,24 @@ external asinh : float -> float = "caml_
     @since 4.13.0
 *)
 external atanh : float -> float = "caml_atanh_float" "caml_atanh"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2022-11] Use [Float.atanh]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2022-11] Use [Float.atanh]"]
 
 (** Round above to an integer value.
     [ceil f] returns the least integer value greater than or equal to [f].
     The result is returned as a float. *)
 external ceil : float -> float = "caml_ceil_float" "ceil"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.round_up]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.round_up]"]
 
 (** Round below to an integer value.
     [floor f] returns the greatest integer value less than or
     equal to [f].
     The result is returned as a float. *)
 external floor : float -> float = "caml_floor_float" "floor"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.round_down]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.round_down]"]
 
 (** [abs_float f] returns the absolute value of [f]. *)
 external abs_float : float -> float = "%absfloat"
-  [@@deprecated "[since 2014-10] Use [Float.abs]"]
+[@@deprecated "[since 2014-10] Use [Float.abs]"]
 
 (** [copysign x y] returns a float whose absolute value is that of [x]
     and whose sign is that of [y].  If [x] is [nan], returns [nan].
@@ -472,13 +472,13 @@ external abs_float : float -> float = "%
     specified which.
     @since 4.00.0  *)
 external copysign : float -> float -> float = "caml_copysign_float" "caml_copysign"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.copysign]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2016-07] Use [Float.copysign]"]
 
 (** [mod_float a b] returns the remainder of [a] with respect to
     [b].  The returned value is [a -. n *. b], where [n]
     is the quotient [a /. b] rounded towards zero to an integer. *)
 external mod_float : float -> float -> float = "caml_fmod_float" "fmod"
-  [@@unboxed] [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.mod_float]"]
+[@@unboxed] [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.mod_float]"]
 
 (** [frexp f] returns the pair of the significant
     and the exponent of [f].  When [f] is zero, the
@@ -486,7 +486,7 @@ external mod_float : float -> float -> f
     zero.  When [f] is non-zero, they are defined by
     [f = x *. 2 ** n] and [0.5 <= x < 1.0]. *)
 external frexp : float -> float * int = "caml_frexp_float"
-  [@@deprecated "[since 2014-10] Use [Float.frexp]"]
+[@@deprecated "[since 2014-10] Use [Float.frexp]"]
 
 (** [ldexp x n] returns [x *. 2 ** n]. *)
 external ldexp
@@ -494,12 +494,12 @@ external ldexp
   -> (int[@untagged])
   -> (float[@unboxed])
   = "caml_ldexp_float" "caml_ldexp_float_unboxed"
-  [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.ldexp]"]
+[@@noalloc] [@@deprecated "[since 2014-10] Use [Float.ldexp]"]
 
 (** [modf f] returns the pair of the fractional and integral
     part of [f]. *)
 external modf : float -> float * float = "caml_modf_float"
-  [@@deprecated "[since 2014-10] Use [Float.modf]"]
+[@@deprecated "[since 2014-10] Use [Float.modf]"]
 
 (** Same as {!Caml.float_of_int}. *)
 external float : (int[@local_opt]) -> (float[@local_opt]) = "%floatofint"
@@ -509,7 +509,7 @@ external float_of_int : (int[@local_opt]
 
 (** Same as {!Caml.int_of_float}. *)
 external truncate : (float[@local_opt]) -> int = "%intoffloat"
-  [@@deprecated "[since 2014-10] Use [Float.iround_towards_zero_exn]"]
+[@@deprecated "[since 2014-10] Use [Float.iround_towards_zero_exn]"]
 
 (** Truncate the given floating-point number to an integer.
     The result is unspecified if the argument is [nan] or falls outside the
@@ -518,11 +518,11 @@ external int_of_float : (float[@local_op
 
 (** Positive infinity. *)
 val infinity : float
-  [@@deprecated "[since 2014-10] Use [Float.infinity]"]
+[@@deprecated "[since 2014-10] Use [Float.infinity]"]
 
 (** Negative infinity. *)
 val neg_infinity : float
-  [@@deprecated "[since 2014-10] Use [Float.neg_infinity]"]
+[@@deprecated "[since 2014-10] Use [Float.neg_infinity]"]
 
 (** A special floating-point value denoting the result of an
     undefined operation such as [0.0 /. 0.0].  Stands for
@@ -531,20 +531,20 @@ val neg_infinity : float
     [=], [<], [<=], [>] and [>=] return [false] and [<>] returns [true]
     if one or both of their arguments is [nan]. *)
 val nan : float
-  [@@deprecated "[since 2014-10] Use [Float.nan]"]
+[@@deprecated "[since 2014-10] Use [Float.nan]"]
 
 (** The largest positive finite value of type [float]. *)
 val max_float : float
-  [@@deprecated "[since 2014-10] Use [Float.max_value]"]
+[@@deprecated "[since 2014-10] Use [Float.max_value]"]
 
 (** The smallest positive, non-zero, non-denormalized value of type [float]. *)
 val min_float : float
-  [@@deprecated "[since 2014-10] Use [Float.min_value]"]
+[@@deprecated "[since 2014-10] Use [Float.min_value]"]
 
 (** The difference between [1.0] and the smallest exactly representable
     floating-point number greater than [1.0]. *)
 val epsilon_float : float
-  [@@deprecated "[since 2014-10] Use [Float.epsilon_float]"]
+[@@deprecated "[since 2014-10] Use [Float.epsilon_float]"]
 
 (** The five classes of floating-point numbers, as determined by
     the {!Caml.classify_float} function. *)
@@ -561,7 +561,7 @@ external classify_float
   :  (float[@unboxed])
   -> fpclass
   = "caml_classify_float" "caml_classify_float_unboxed"
-  [@@noalloc] [@@deprecated "[since 2014-10] Use [Float.classify]"]
+[@@noalloc] [@@deprecated "[since 2014-10] Use [Float.classify]"]
 
 (** {6 String operations}
 
@@ -652,7 +652,7 @@ external snd : ('a * 'b[@local_opt]) ->
 
 (** List concatenation. *)
 val ( @ ) : 'a list -> 'a list -> 'a list
-  [@@deprecated "[since 2014-10] Use [List.Infix]"]
+[@@deprecated "[since 2014-10] Use [List.Infix]"]
 
 (** {6 Input/output}
     Note: all input/output functions can raise [Sys_error] when the system
@@ -666,7 +666,7 @@ type out_channel = Stdlib.out_channel [@
 
 (** The standard input for the process. *)
 val stdin : Stdlib.in_channel
-  [@@deprecated "[since 2016-04] Use [In_channel.stdin]"]
+[@@deprecated "[since 2016-04] Use [In_channel.stdin]"]
 
 (** The standard output for the process. *)
 val stdout : Stdlib.out_channel
@@ -678,22 +678,22 @@ val stderr : Stdlib.out_channel
 
 (** Print a character on standard output. *)
 val print_char : char -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_char stdout]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_char stdout]"]
 
 (** Print a string on standard output. *)
 val print_string : string -> unit
 
 (** Print a byte sequence on standard output. *)
 val print_bytes : bytes -> unit
-  [@@deprecated "[since 2016-04] Core doesn't support [bytes] yet."]
+[@@deprecated "[since 2016-04] Core doesn't support [bytes] yet."]
 
 (** Print an integer, in decimal, on standard output. *)
 val print_int : int -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_string stdout]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_string stdout]"]
 
 (** Print a floating-point number, in decimal, on standard output. *)
 val print_float : float -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_string stdout]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_string stdout]"]
 
 (** Print a string, followed by a newline character, on
     standard output and flush standard output. *)
@@ -703,29 +703,29 @@ val print_endline : string -> unit
     standard output. This can be used to simulate line
     buffering of standard output. *)
 val print_newline : unit -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.newline stdout]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.newline stdout]"]
 
 (** {7 Output functions on standard error} *)
 
 (** Print a character on standard error. *)
 val prerr_char : char -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_char stderr]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_char stderr]"]
 
 (** Print a string on standard error. *)
 val prerr_string : string -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_string stderr]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_string stderr]"]
 
 (** Print a byte sequence on standard error. *)
 val prerr_bytes : bytes -> unit
-  [@@deprecated "[since 2016-04] Core doesn't support [bytes] yet"]
+[@@deprecated "[since 2016-04] Core doesn't support [bytes] yet"]
 
 (** Print an integer, in decimal, on standard error. *)
 val prerr_int : int -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_string stderr]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_string stderr]"]
 
 (** Print a floating-point number, in decimal, on standard error. *)
 val prerr_float : float -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_string stderr]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_string stderr]"]
 
 (** Print a string, followed by a newline character on standard
     error and flush standard error. *)
@@ -734,7 +734,7 @@ val prerr_endline : string -> unit
 (** Print a newline character on standard error, and flush
     standard error. *)
 val prerr_newline : unit -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.newline stderr]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.newline stderr]"]
 
 (** {7 Input functions on standard input} *)
 
@@ -742,25 +742,25 @@ val prerr_newline : unit -> unit
     until a newline character is encountered. Return the string of
     all characters read, without the newline character at the end. *)
 val read_line : unit -> string
-  [@@deprecated
-    "[since 2016-04] Use\n[Out_channel.(flush stdout); In_channel.(input_line_exn stdin)]"]
+[@@deprecated
+  "[since 2016-04] Use\n[Out_channel.(flush stdout); In_channel.(input_line_exn stdin)]"]
 
 (** Flush standard output, then read one line from standard input
     and convert it to an integer. Raise [Failure "int_of_string"]
     if the line read is not a valid representation of an integer. *)
 val read_int : unit -> int
-  [@@deprecated
-    "[since 2016-04] Use\n\
-     [Out_channel.(flush stdout); Int.of_string In_channel.(input_line_exn stdin)]"]
+[@@deprecated
+  "[since 2016-04] Use\n\
+   [Out_channel.(flush stdout); Int.of_string In_channel.(input_line_exn stdin)]"]
 
 (** Flush standard output, then read one line from standard input
     and convert it to a floating-point number.
     The result is unspecified if the line read is not a valid
     representation of a floating-point number. *)
 val read_float : unit -> float
-  [@@deprecated
-    "[since 2016-04] Use\n\
-     [Out_channel.(flush stdout); Float.of_string In_channel.(input_line_exn stdin)]"]
+[@@deprecated
+  "[since 2016-04] Use\n\
+   [Out_channel.(flush stdout); Float.of_string In_channel.(input_line_exn stdin)]"]
 
 (** {7 General output functions} *)
 
@@ -783,14 +783,14 @@ type open_flag = Stdlib.open_flag =
     file is truncated to zero length if it already exists. It
     is created if it does not already exists. *)
 val open_out : string -> Stdlib.out_channel
-  [@@deprecated "[since 2016-04] Use [Out_channel.create]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.create]"]
 
 (** Same as {!Caml.open_out}, but the file is opened in binary mode,
     so that no translation takes place during writes. On operating
     systems that do not distinguish between text mode and binary
     mode, this function behaves like {!Caml.open_out}. *)
 val open_out_bin : string -> Stdlib.out_channel
-  [@@deprecated "[since 2016-04] Use [Out_channel.create]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.create]"]
 
 (** [open_out_gen mode perm filename] opens the named file for writing,
     as described above. The extra argument [mode]
@@ -799,48 +799,48 @@ val open_out_bin : string -> Stdlib.out_
     {!Caml.open_out} and {!Caml.open_out_bin} are special
     cases of this function. *)
 val open_out_gen : Stdlib.open_flag list -> int -> string -> Stdlib.out_channel
-  [@@deprecated "[since 2016-04] Use [Out_channel.create]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.create]"]
 
 (** Flush the buffer associated with the given output channel,
     performing all pending writes on that channel.
     Interactive programs must be careful about flushing standard
     output and standard error at the right time. *)
 val flush : Stdlib.out_channel -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.flush]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.flush]"]
 
 (** Flush all open output channels; ignore errors. *)
 val flush_all : unit -> unit
-  [@@deprecated "[since 2016-04]"]
+[@@deprecated "[since 2016-04]"]
 
 (** Write the character on the given output channel. *)
 val output_char : Stdlib.out_channel -> char -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_char]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_char]"]
 
 (** Write the string on the given output channel. *)
 val output_string : Stdlib.out_channel -> string -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_string]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_string]"]
 
 (** Write the byte sequence on the given output channel. *)
 val output_bytes : Stdlib.out_channel -> bytes -> unit
-  [@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
+[@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
 
 (** [output oc buf pos len] writes [len] characters from byte sequence [buf],
     starting at offset [pos], to the given output channel [oc].
     Raise [Invalid_argument "output"] if [pos] and [len] do not
     designate a valid range of [buf]. *)
 val output : Stdlib.out_channel -> bytes -> int -> int -> unit
-  [@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
+[@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
 
 (** Same as [output] but take a string as argument instead of
     a byte sequence. *)
 val output_substring : Stdlib.out_channel -> string -> int -> int -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output]"]
 
 (** Write one 8-bit integer (as the single character with that code)
     on the given output channel. The given integer is taken modulo
     256. *)
 val output_byte : Stdlib.out_channel -> int -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_byte]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_byte]"]
 
 (** Write one integer in binary format (4 bytes, big-endian)
     on the given output channel.
@@ -849,7 +849,7 @@ val output_byte : Stdlib.out_channel ->
     {!Caml.input_binary_int} function. The format is compatible across
     all machines for a given version of OCaml. *)
 val output_binary_int : Stdlib.out_channel -> int -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_binary_int]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_binary_int]"]
 
 (** Write the representation of a structured value of any type
     to a channel. Circularities and sharing inside the value
@@ -858,26 +858,26 @@ val output_binary_int : Stdlib.out_chann
     {!Marshal} for more information. {!Caml.output_value} is equivalent
     to {!Marshal.to_channel} with an empty list of flags. *)
 val output_value : Stdlib.out_channel -> 'a -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.output_value]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.output_value]"]
 
 (** [seek_out chan pos] sets the current writing position to [pos]
     for channel [chan]. This works only for regular files. On
     files of other kinds (such as terminals, pipes and sockets),
     the behavior is unspecified. *)
 val seek_out : Stdlib.out_channel -> int -> unit
-  [@@deprecated "[since 2014-10] Use [Out_channel.seek]"]
+[@@deprecated "[since 2014-10] Use [Out_channel.seek]"]
 
 (** Return the current writing position for the given channel.  Does
     not work on channels opened with the [Open_append] flag (returns
     unspecified results). *)
 val pos_out : Stdlib.out_channel -> int
-  [@@deprecated "[since 2014-10] Use [Out_channel.pos]"]
+[@@deprecated "[since 2014-10] Use [Out_channel.pos]"]
 
 (** Return the size (number of characters) of the regular file
     on which the given channel is opened.  If the channel is opened
     on a file that is not a regular file, the result is meaningless. *)
 val out_channel_length : Stdlib.out_channel -> int
-  [@@deprecated "[since 2014-10] Use [Out_channel.length]"]
+[@@deprecated "[since 2014-10] Use [Out_channel.length]"]
 
 (** Close the given channel, flushing all buffered write operations.
     Output functions raise a [Sys_error] exception when they are
@@ -886,11 +886,11 @@ val out_channel_length : Stdlib.out_chan
     Note that [close_out] may raise [Sys_error] if the operating
     system signals an error when flushing or closing. *)
 val close_out : Stdlib.out_channel -> unit
-  [@@deprecated "[since 2014-10] Use [Out_channel.close]"]
+[@@deprecated "[since 2014-10] Use [Out_channel.close]"]
 
 (** Same as [close_out], but ignore all errors. *)
 val close_out_noerr : Stdlib.out_channel -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.close] and catch exceptions"]
+[@@deprecated "[since 2016-04] Use [Out_channel.close] and catch exceptions"]
 
 (** [set_binary_mode_out oc true] sets the channel [oc] to binary
     mode: no translations take place during output.
@@ -901,21 +901,21 @@ val close_out_noerr : Stdlib.out_channel
     This function has no effect under operating systems that
     do not distinguish between text mode and binary mode. *)
 val set_binary_mode_out : Stdlib.out_channel -> bool -> unit
-  [@@deprecated "[since 2016-04] Use [Out_channel.set_binary_mode]"]
+[@@deprecated "[since 2016-04] Use [Out_channel.set_binary_mode]"]
 
 (** {7 General input functions} *)
 
 (** Open the named file for reading, and return a new input channel
     on that file, positionned at the beginning of the file. *)
 val open_in : string -> Stdlib.in_channel
-  [@@deprecated "[since 2016-04] Use [In_channel.create]"]
+[@@deprecated "[since 2016-04] Use [In_channel.create]"]
 
 (** Same as {!Caml.open_in}, but the file is opened in binary mode,
     so that no translation takes place during reads. On operating
     systems that do not distinguish between text mode and binary
     mode, this function behaves like {!Caml.open_in}. *)
 val open_in_bin : string -> Stdlib.in_channel
-  [@@deprecated "[since 2016-04] Use [In_channel.create]"]
+[@@deprecated "[since 2016-04] Use [In_channel.create]"]
 
 (** [open_in_gen mode perm filename] opens the named file for reading,
     as described above. The extra arguments
@@ -923,12 +923,12 @@ val open_in_bin : string -> Stdlib.in_ch
     {!Caml.open_in} and {!Caml.open_in_bin} are special
     cases of this function. *)
 val open_in_gen : Stdlib.open_flag list -> int -> string -> Stdlib.in_channel
-  [@@deprecated "[since 2016-04] Use [In_channel.create]"]
+[@@deprecated "[since 2016-04] Use [In_channel.create]"]
 
 (** Read one character from the given input channel.
     Raise [End_of_file] if there are no more characters to read. *)
 val input_char : Stdlib.in_channel -> char
-  [@@deprecated "[since 2016-04] Use [In_channel.input_char]"]
+[@@deprecated "[since 2016-04] Use [In_channel.input_char]"]
 
 (** Read characters from the given input channel, until a
     newline character is encountered. Return the string of
@@ -936,7 +936,7 @@ val input_char : Stdlib.in_channel -> ch
     Raise [End_of_file] if the end of the file is reached
     at the beginning of line. *)
 val input_line : Stdlib.in_channel -> string
-  [@@deprecated "[since 2016-04] Use [In_channel.input_line]"]
+[@@deprecated "[since 2016-04] Use [In_channel.input_line]"]
 
 (** [input ic buf pos len] reads up to [len] characters from
     the given channel [ic], storing them in byte sequence [buf], starting at
@@ -954,7 +954,7 @@ val input_line : Stdlib.in_channel -> st
     Exception [Invalid_argument "input"] is raised if [pos] and [len]
     do not designate a valid range of [buf]. *)
 val input : Stdlib.in_channel -> bytes -> int -> int -> int
-  [@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
+[@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
 
 (** [really_input ic buf pos len] reads [len] characters from channel [ic],
     storing them in byte sequence [buf], starting at character number [pos].
@@ -963,27 +963,27 @@ val input : Stdlib.in_channel -> bytes -
     Raise [Invalid_argument "really_input"] if
     [pos] and [len] do not designate a valid range of [buf]. *)
 val really_input : Stdlib.in_channel -> bytes -> int -> int -> unit
-  [@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
+[@@deprecated "[since 2016-04] Core doesn't yet support bytes."]
 
 (** [really_input_string ic len] reads [len] characters from channel [ic]
     and returns them in a new string.
     Raise [End_of_file] if the end of file is reached before [len]
     characters have been read. *)
 val really_input_string : Stdlib.in_channel -> int -> string
-  [@@deprecated "[since 2016-04] Use [In_channel.really_input_exn ~pos:0]"]
+[@@deprecated "[since 2016-04] Use [In_channel.really_input_exn ~pos:0]"]
 
 (** Same as {!Caml.input_char}, but return the 8-bit integer representing
     the character.
     Raise [End_of_file] if an end of file was reached. *)
 val input_byte : Stdlib.in_channel -> int
-  [@@deprecated "[since 2016-04] Use [In_channel.input_byte]"]
+[@@deprecated "[since 2016-04] Use [In_channel.input_byte]"]
 
 (** Read an integer encoded in binary format (4 bytes, big-endian)
     from the given input channel. See {!Caml.output_binary_int}.
     Raise [End_of_file] if an end of file was reached while reading the
     integer. *)
 val input_binary_int : Stdlib.in_channel -> int
-  [@@deprecated "[since 2016-04] Use [In_channel.input_binary_int]"]
+[@@deprecated "[since 2016-04] Use [In_channel.input_binary_int]"]
 
 (** Read the representation of a structured value, as produced
     by {!Caml.output_value}, and return the corresponding value.
@@ -991,17 +991,17 @@ val input_binary_int : Stdlib.in_channel
     see the description of module {!Marshal} for more information,
     in particular concerning the lack of type safety. *)
 val input_value : Stdlib.in_channel -> 'a
-  [@@deprecated "[since 2016-04] Use [In_channel.unsafe_input_value]"]
+[@@deprecated "[since 2016-04] Use [In_channel.unsafe_input_value]"]
 
 (** [seek_in chan pos] sets the current reading position to [pos]
     for channel [chan]. This works only for regular files. On
     files of other kinds, the behavior is unspecified. *)
 val seek_in : Stdlib.in_channel -> int -> unit
-  [@@deprecated "[since 2014-10] Use [In_channel.seek]"]
+[@@deprecated "[since 2014-10] Use [In_channel.seek]"]
 
 (** Return the current reading position for the given channel. *)
 val pos_in : Stdlib.in_channel -> int
-  [@@deprecated "[since 2014-10] Use [In_channel.pos]"]
+[@@deprecated "[since 2014-10] Use [In_channel.pos]"]
 
 (** Return the size (number of characters) of the regular file
     on which the given channel is opened.  If the channel is opened
@@ -1010,18 +1010,18 @@ val pos_in : Stdlib.in_channel -> int
     translations that can be performed when reading from a channel
     opened in text mode. *)
 val in_channel_length : Stdlib.in_channel -> int
-  [@@deprecated "[since 2014-10] Use [In_channel.length]"]
+[@@deprecated "[since 2014-10] Use [In_channel.length]"]
 
 (** Close the given channel.  Input functions raise a [Sys_error]
     exception when they are applied to a closed input channel,
     except [close_in], which does nothing when applied to an already
     closed channel. *)
 val close_in : Stdlib.in_channel -> unit
-  [@@deprecated "[since 2014-10] Use [In_channel.close]"]
+[@@deprecated "[since 2014-10] Use [In_channel.close]"]
 
 (** Same as [close_in], but ignore all errors. *)
 val close_in_noerr : Stdlib.in_channel -> unit
-  [@@deprecated "[since 2016-04] Use [In_channel.close] and catch exceptions"]
+[@@deprecated "[since 2016-04] Use [In_channel.close] and catch exceptions"]
 
 (** [set_binary_mode_in ic true] sets the channel [ic] to binary
     mode: no translations take place during input.
@@ -1032,7 +1032,7 @@ val close_in_noerr : Stdlib.in_channel -
     This function has no effect under operating systems that
     do not distinguish between text mode and binary mode. *)
 val set_binary_mode_in : Stdlib.in_channel -> bool -> unit
-  [@@deprecated "[since 2016-04] Use [In_channel.set_binary_mode]"]
+[@@deprecated "[since 2016-04] Use [In_channel.set_binary_mode]"]
 
 (** {7 Operations on large files} *)
 
@@ -1209,6 +1209,6 @@ val at_exit : (unit -> unit) -> unit
 val valid_float_lexem : string -> string [@@deprecated "[since 2015-11] Do not use."]
 
 val unsafe_really_input : Stdlib.in_channel -> bytes -> int -> int -> unit
-  [@@deprecated "[since 2015-11] Do not use."]
+[@@deprecated "[since 2015-11] Do not use."]
 
 val do_at_exit : unit -> unit [@@deprecated "[since 2015-11] Do not use."]
Index: core-0.17.1/core/src/core_sys.ml
===================================================================
--- core-0.17.1.orig/core/src/core_sys.ml
+++ core-0.17.1/core/src/core_sys.ml
@@ -4,11 +4,11 @@ include Base.Sys
 let unix_quote x =
   if (not (String.is_empty x))
      && String.for_all x ~f:(function
-          | 'a' .. 'z'
-          | 'A' .. 'Z'
-          | '0' .. '9'
-          | '_' | '-' | ':' | '.' | '/' | ',' | '+' | '=' | '%' | '@' -> true
-          | _ -> false)
+       | 'a' .. 'z'
+       | 'A' .. 'Z'
+       | '0' .. '9'
+       | '_' | '-' | ':' | '.' | '/' | ',' | '+' | '=' | '%' | '@' -> true
+       | _ -> false)
   then (
     (* Shell keywords, as output by [compgen -k] for bash, [man dash] for dash, and [PATH=
        type -m '*' | grep reserved] for zsh, except for keywords that have special
Index: core-0.17.1/core/src/date0.ml
===================================================================
--- core-0.17.1.orig/core/src/date0.ml
+++ core-0.17.1/core/src/date0.ml
@@ -12,8 +12,8 @@ module Stable = struct
     module Without_comparable = struct
       module T : sig
         type t
-        [@@immediate]
         [@@deriving bin_io ~localize, compare, equal, hash, typerep, stable_witness]
+        [@@immediate]
 
         val create_exn : y:int -> m:Month.Stable.V1.t -> d:int -> t
         val year : t -> int
@@ -340,9 +340,9 @@ module C = Comparable.Make_binable_using
 include C
 
 include Diffable.Atomic.Make (struct
-  include Without_comparable
-  include C
-end)
+    include Without_comparable
+    include C
+  end)
 
 module O = struct
   include (C : Comparable.Infix with type t := t)
@@ -359,11 +359,11 @@ include (
     Hashable.S_binable with type t := t)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let module_name = "Core.Date"
-  let to_string = to_string
-end)
+    let module_name = "Core.Date"
+    let to_string = to_string
+  end)
 
 let unix_epoch = create_exn ~y:1970 ~m:Jan ~d:1
 
@@ -376,16 +376,16 @@ let unix_epoch = create_exn ~y:1970 ~m:J
    note: unit tests are in lib_test/time_test.ml
 *)
 module Days : sig
-  type date = t
-  type t [@@immediate]
+    type date = t
+    type t [@@immediate]
 
-  val of_date : date -> t
-  val to_date : t -> date
-  val diff : t -> t -> int
-  val add_days : t -> int -> t
-  val unix_epoch : t
-end
-with type date := t = struct
+    val of_date : date -> t
+    val to_date : t -> date
+    val diff : t -> t -> int
+    val add_days : t -> int -> t
+    val unix_epoch : t
+  end
+  with type date := t = struct
   open Int
 
   type t = int
@@ -684,6 +684,6 @@ module Option = struct
   ;;
 
   include Comparable.Make_plain (struct
-    type nonrec t = t [@@deriving compare, sexp_of]
-  end)
+      type nonrec t = t [@@deriving compare, sexp_of]
+    end)
 end
Index: core-0.17.1/core/src/date0_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/date0_intf.ml
+++ core-0.17.1/core/src/date0_intf.ml
@@ -2,7 +2,7 @@ open! Import
 open Std_internal
 
 module type Date0 = sig
-  type t [@@immediate] [@@deriving bin_io ~localize, hash, sexp, sexp_grammar, typerep]
+  type t [@@deriving bin_io ~localize, hash, sexp, sexp_grammar, typerep] [@@immediate]
 
   include Hashable_binable with type t := t
 
@@ -147,15 +147,15 @@ module type Date0 = sig
 
       See the caveat on [is_weekend] about varying weekend/weekday cycles. *)
   val add_weekdays : t -> int -> t
-    [@@deprecated
-      "[since 2019-12] use [add_weekdays_rounding_backward] or \
-       [add_weekdays_rounding_forward] as appropriate"]
+  [@@deprecated
+    "[since 2019-12] use [add_weekdays_rounding_backward] or \
+     [add_weekdays_rounding_forward] as appropriate"]
 
   val add_weekdays_rounding_in_direction_of_step : t -> int -> t
-    [@@alert
-      legacy
-        "use [add_weekdays_rounding_backward] or [add_weekdays_rounding_forward] as \
-         appropriate"]
+  [@@alert
+    legacy
+      "use [add_weekdays_rounding_backward] or [add_weekdays_rounding_forward] as \
+       appropriate"]
 
   (** [add_business_days t ~is_holiday n] returns a business day even when
       [n=0]. [add_business_days ~is_holiday:(fun _ -> false) ...] is the same as
@@ -167,19 +167,19 @@ module type Date0 = sig
       See the caveat on [is_weekend] about varying weekend/weekday cycles.
   *)
   val add_business_days : t -> is_holiday:(t -> bool) -> int -> t
-    [@@deprecated
-      "[since 2019-12] use [add_business_days_rounding_backward] or \
-       [add_business_days_rounding_forward] as appropriate"]
+  [@@deprecated
+    "[since 2019-12] use [add_business_days_rounding_backward] or \
+     [add_business_days_rounding_forward] as appropriate"]
 
   val add_business_days_rounding_in_direction_of_step
     :  t
     -> is_holiday:(t -> bool)
     -> int
     -> t
-    [@@alert
-      legacy
-        "use [add_business_days_rounding_backward] or \
-         [add_business_days_rounding_forward] as appropriate"]
+  [@@alert
+    legacy
+      "use [add_business_days_rounding_backward] or [add_business_days_rounding_forward] \
+       as appropriate"]
 
   (** [add_days_skipping t ~skip n] adds [n] days to [t], ignoring any date satisfying
       [skip], starting at the first date at or after [t] that does not satisfy [skip].
@@ -240,22 +240,22 @@ module type Date0 = sig
       where dates are manipulated more often than they are constructed or deconstructed;
       most clients should use the ordinary [t]. *)
   module Days : sig
-    type date = t
-    type t [@@immediate]
+      type date = t
+      type t [@@immediate]
 
-    val of_date : date -> t
-    val to_date : t -> date
-    val diff : t -> t -> int
-    val add_days : t -> int -> t
+      val of_date : date -> t
+      val to_date : t -> date
+      val diff : t -> t -> int
+      val add_days : t -> int -> t
 
-    (** The starting date of the UNIX epoch: 1970-01-01 *)
-    val unix_epoch : t
-  end
-  with type date := t
+      (** The starting date of the UNIX epoch: 1970-01-01 *)
+      val unix_epoch : t
+    end
+    with type date := t
 
   module Option : sig
     type value := t
-    type t [@@immediate] [@@deriving bin_io ~localize, hash, sexp, sexp_grammar]
+    type t [@@deriving bin_io ~localize, hash, sexp, sexp_grammar] [@@immediate]
 
     include Immediate_option_intf.S with type value := value and type t := t
     include Comparable.S_plain with type t := t
@@ -264,7 +264,7 @@ module type Date0 = sig
 
   module Stable : sig
     module V1 : sig
-      type nonrec t = t [@@immediate] [@@deriving equal, hash, sexp_grammar]
+      type nonrec t = t [@@deriving equal, hash, sexp_grammar] [@@immediate]
 
       (** [to_int] and [of_int_exn] convert to/from the underlying integer
           representation. *)
@@ -274,8 +274,8 @@ module type Date0 = sig
 
       include
         Stable_comparable.With_stable_witness.V1
-          with type t := t
-          with type comparator_witness = comparator_witness
+        with type t := t
+        with type comparator_witness = comparator_witness
 
       include Hashable.Stable.V1.With_stable_witness.S with type key := t
       include Diffable.S_atomic with type t := t
@@ -284,8 +284,8 @@ module type Date0 = sig
     module Option : sig
       module V1 : sig
         type nonrec t = Option.t
-        [@@immediate]
         [@@deriving bin_io ~localize, compare, equal, sexp, sexp_grammar, stable_witness]
+        [@@immediate]
 
         (** [to_int] and [of_int_exn] convert to/from the underlying integer
             representation. *)
Index: core-0.17.1/core/src/date_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/date_intf.ml
+++ core-0.17.1/core/src/date_intf.ml
@@ -3,8 +3,8 @@ module type Date = sig
 
   include module type of Date0 with type t := t (** @inline *)
 
-  val of_time : Time_float.t -> zone:Time_float.Zone.t -> t
-  val today : zone:Time_float.Zone.t -> t
+  val of_time : Time_float.t -> zone:Zone.t -> t
+  val today : zone:Zone.t -> t
 
   (** Deprecations *)
 
Index: core-0.17.1/core/src/day_of_week.ml
===================================================================
--- core-0.17.1.orig/core/src/day_of_week.ml
+++ core-0.17.1/core/src/day_of_week.ml
@@ -92,11 +92,11 @@ module Stable = struct
       (* this is in T rather than outside so that the later functor application to build maps
          uses this sexp representation *)
       include Sexpable.Stable.Of_stringable.V1 (struct
-        type nonrec t = t
+          type nonrec t = t
 
-        let of_string = of_string
-        let to_string = to_string
-      end)
+          let of_string = of_string
+          let to_string = to_string
+        end)
 
       let t_sexp_grammar =
         let open Sexplib0.Sexp_grammar in
Index: core-0.17.1/core/src/day_of_week_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/day_of_week_intf.ml
+++ core-0.17.1/core/src/day_of_week_intf.ml
@@ -58,8 +58,8 @@ module type Day_of_week = sig
 
       include
         Comparable.Stable.V1.With_stable_witness.S
-          with type comparable := t
-          with type comparator_witness := comparator_witness
+        with type comparable := t
+        with type comparator_witness := comparator_witness
 
       include Hashable.Stable.V1.With_stable_witness.S with type key := t
     end
Index: core-0.17.1/core/src/deprecate_pipe_bang.mli
===================================================================
--- core-0.17.1.orig/core/src/deprecate_pipe_bang.mli
+++ core-0.17.1/core/src/deprecate_pipe_bang.mli
@@ -1,2 +1,2 @@
 external ( |! ) : 'a -> (('a -> 'b)[@local_opt]) -> 'b = "%revapply"
-  [@@deprecated "[since 2016-07] Use [ |> ]"]
+[@@deprecated "[since 2016-07] Use [ |> ]"]
Index: core-0.17.1/core/src/deque.ml
===================================================================
--- core-0.17.1.orig/core/src/deque.ml
+++ core-0.17.1/core/src/deque.ml
@@ -204,12 +204,12 @@ let clear t =
    some functions ([length] minimally) silently without changing the semantics.  We get
    around that by importing things explicitly.  *)
 module C = Container.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let fold = fold
-  let iter = `Custom iter
-  let length = `Custom length
-end)
+    let fold = fold
+    let iter = `Custom iter
+    let length = `Custom length
+  end)
 
 let count = C.count
 let sum = C.sum
@@ -435,7 +435,7 @@ let to_array t =
       (fold t ~init:0 ~f:(fun i v ->
          arr.(i) <- v;
          i + 1)
-        : int);
+       : int);
     arr
 ;;
 
@@ -446,26 +446,26 @@ let of_array arr =
 ;;
 
 include Bin_prot.Utils.Make_iterable_binable1 (struct
-  type nonrec 'a t = 'a t
-  type 'a el = 'a [@@deriving bin_io]
+    type nonrec 'a t = 'a t
+    type 'a el = 'a [@@deriving bin_io]
 
-  let caller_identity =
-    Bin_prot.Shape.Uuid.of_string "34c1e9ca-4992-11e6-a686-8b4bd4f87796"
-  ;;
-
-  let module_name = Some "Core.Deque"
-  let length = length
-  let iter t ~f = iter t ~f
-
-  let init ~len ~next =
-    let t = create ~initial_length:len () in
-    for _i = 0 to len - 1 do
-      let x = next () in
-      enqueue_back t x
-    done;
-    t
-  ;;
-end)
+    let caller_identity =
+      Bin_prot.Shape.Uuid.of_string "34c1e9ca-4992-11e6-a686-8b4bd4f87796"
+    ;;
+
+    let module_name = Some "Core.Deque"
+    let length = length
+    let iter t ~f = iter t ~f
+
+    let init ~len ~next =
+      let t = create ~initial_length:len () in
+      for _i = 0 to len - 1 do
+        let x = next () in
+        enqueue_back t x
+      done;
+      t
+    ;;
+  end)
 
 let t_of_sexp f sexp = of_array (Array.t_of_sexp f sexp)
 let sexp_of_t f t = Array.sexp_of_t f (to_array t)
@@ -474,6 +474,16 @@ let t_sexp_grammar elt_grammar =
   Sexplib.Sexp_grammar.coerce (Array.t_sexp_grammar elt_grammar)
 ;;
 
+include
+  Quickcheckable.Of_quickcheckable1
+    (Array)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_array
+      let of_quickcheckable = of_array
+    end)
+
 (* re-expose these here under a different name to avoid internal confusion *)
 let back_index = apparent_back_index
 let front_index = apparent_front_index
@@ -489,15 +499,15 @@ let front_index_exn t =
 ;;
 
 module Binary_searchable = Test_binary_searchable.Make1_and_test (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let get t i = get t (front_index_exn t + i)
-  let length = length
+    let get t i = get t (front_index_exn t + i)
+    let length = length
 
-  module For_test = struct
-    let of_array = of_array
-  end
-end)
+    module For_test = struct
+      let of_array = of_array
+    end
+  end)
 
 (* The "stable" indices used in this module make the application of the
    [Binary_searchable] functor awkward.  We need to be sure to translate incoming
Index: core-0.17.1/core/src/deque.mli
===================================================================
--- core-0.17.1.orig/core/src/deque.mli
+++ core-0.17.1/core/src/deque.mli
@@ -12,7 +12,7 @@
 
 open! Import
 
-type 'a t [@@deriving bin_io, sexp, sexp_grammar]
+type 'a t [@@deriving bin_io, quickcheck, sexp, sexp_grammar]
 
 include Binary_searchable.S1 with type 'a t := 'a t
 include Container.S1 with type 'a t := 'a t
Index: core-0.17.1/core/src/deriving_hash.ml
===================================================================
--- core-0.17.1.orig/core/src/deriving_hash.ml
+++ core-0.17.1/core/src/deriving_hash.ml
@@ -2,11 +2,12 @@ open! Import
 include Deriving_hash_intf
 
 module Of_deriving_hash
-  (Repr : S) (M : sig
-    type t
+    (Repr : S)
+    (M : sig
+       type t
 
-    val to_repr : t -> Repr.t
-  end) =
+       val to_repr : t -> Repr.t
+     end) =
 struct
   let hash_fold_t state t = Repr.hash_fold_t state (M.to_repr t)
   let hash = Ppx_hash_lib.Std.Hash.of_fold hash_fold_t
Index: core-0.17.1/core/src/deriving_hash_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/deriving_hash_intf.ml
+++ core-0.17.1/core/src/deriving_hash_intf.ml
@@ -6,9 +6,10 @@ end
 
 module type Deriving_hash = sig
   module Of_deriving_hash
-    (Repr : S) (M : sig
-      type t
+      (Repr : S)
+      (M : sig
+         type t
 
-      val to_repr : t -> Repr.t
-    end) : S with type t := M.t
+         val to_repr : t -> Repr.t
+       end) : S with type t := M.t
 end
Index: core-0.17.1/core/src/doubly_linked.ml
===================================================================
--- core-0.17.1.orig/core/src/doubly_linked.ml
+++ core-0.17.1/core/src/doubly_linked.ml
@@ -336,14 +336,14 @@ let map t ~f =
       new_first
       first
       (fun f new_first first ->
-      let rec loop f acc first elt =
-        let acc = Elt.insert_after acc (f (Elt.value elt)) in
-        let next = Elt.next elt in
-        if not (phys_equal next first) then loop f acc first next
-      in
-      (* unroll and skip first elt *)
-      let next = Elt.next first in
-      if not (phys_equal next first) then loop f new_first first next);
+         let rec loop f acc first elt =
+           let acc = Elt.insert_after acc (f (Elt.value elt)) in
+           let next = Elt.next elt in
+           if not (phys_equal next first) then loop f acc first next
+         in
+         (* unroll and skip first elt *)
+         let next = Elt.next first in
+         if not (phys_equal next first) then loop f new_first first next);
     ref (Some new_first)
 ;;
 
@@ -358,14 +358,14 @@ let mapi t ~f =
       new_first
       first
       (fun f new_first first ->
-      let rec loop f i acc first elt =
-        let acc = Elt.insert_after acc (f i (Elt.value elt)) in
-        let next = Elt.next elt in
-        if not (phys_equal next first) then loop f (i + 1) acc first next
-      in
-      (* unroll and skip first elt *)
-      let next = Elt.next first in
-      if not (phys_equal next first) then loop f 1 new_first first next);
+         let rec loop f i acc first elt =
+           let acc = Elt.insert_after acc (f i (Elt.value elt)) in
+           let next = Elt.next elt in
+           if not (phys_equal next first) then loop f (i + 1) acc first next
+         in
+         (* unroll and skip first elt *)
+         let next = Elt.next first in
+         if not (phys_equal next first) then loop f 1 new_first first next);
     ref (Some new_first)
 ;;
 
@@ -481,16 +481,16 @@ let foldi t ~init ~f =
 ;;
 
 module C = Container.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let fold t ~init ~f =
-    let r = fold_elt_1 t ~init f ~f:(fun f acc elt -> f acc (Elt.value elt)) in
-    r
-  ;;
-
-  let iter = `Custom iter
-  let length = `Custom length
-end)
+    let fold t ~init ~f =
+      let r = fold_elt_1 t ~init f ~f:(fun f acc elt -> f acc (Elt.value elt)) in
+      r
+    ;;
+
+    let iter = `Custom iter
+    let length = `Custom length
+  end)
 
 let count = C.count
 let sum = C.sum
@@ -586,6 +586,16 @@ let compare compare_elt t1 t2 =
         loop compare_elt f1 f1 f2 f2))
 ;;
 
+include
+  Quickcheckable.Of_quickcheckable1
+    (List)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_list
+      let of_quickcheckable = of_list
+    end)
+
 exception Transfer_src_and_dst_are_same_list
 
 let transfer ~src ~dst =
Index: core-0.17.1/core/src/doubly_linked_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/doubly_linked_intf.ml
+++ core-0.17.1/core/src/doubly_linked_intf.ml
@@ -38,7 +38,7 @@ module type S = sig
     val sexp_of_t : ('a -> Base.Sexp.t) -> 'a t -> Base.Sexp.t
   end
 
-  type 'a t [@@deriving compare, sexp, sexp_grammar]
+  type 'a t [@@deriving compare, quickcheck, sexp, sexp_grammar]
 
   include Container.S1 with type 'a t := 'a t
   include Invariant.S1 with type 'a t := 'a t
Index: core-0.17.1/core/src/dune
===================================================================
--- core-0.17.1.orig/core/src/dune
+++ core-0.17.1/core/src/dune
@@ -14,9 +14,10 @@
  (public_name core)
  (install_c_headers time_ns_stubs)
  (libraries base base_bigstring base_for_tests base_quickcheck bin_prot
-   command fieldslib filename_base heap_block ppx_diff.diffable
-   jane-street-headers base.md5 ppx_assert.runtime-lib ppx_hash.runtime-lib
-   ppx_inline_test.runtime-lib sexplib splittable_random stdio time_now
+   command fieldslib filename_base heap_block bin_prot.shape
+   ppx_diff.diffable ppx_expect.config_types jane-street-headers base.md5
+   ppx_assert.runtime-lib ppx_hash.runtime-lib ppx_inline_test.runtime-lib
+   sexplib splittable_random ppx_stable_witness.stable_witness stdio time_now
    typerep univ_map validate variantslib)
  (ocamlopt_flags
   :standard
@@ -26,7 +27,8 @@
  (preprocessor_deps config.h gc_stubs.h)
  (js_of_ocaml
   (javascript_files strftime.js runtime.js
-    temporal-polyfill/temporal-polyfill.js timezone_js_loader_stubs.js)))
+    temporal-polyfill/temporal-polyfill.js timezone_js_loader_stubs.js
+    timezone_runtime.js)))
 
 (rule
  (targets gc_stubs.h)
Index: core-0.17.1/core/src/either.ml
===================================================================
--- core-0.17.1.orig/core/src/either.ml
+++ core-0.17.1/core/src/either.ml
@@ -3,7 +3,8 @@ module Stable = struct
     type ('f, 's) t = ('f, 's) Base.Either.t =
       | First of 'f
       | Second of 's
-    [@@deriving bin_io ~localize, compare, equal, hash, sexp, typerep, stable_witness]
+    [@@deriving
+      bin_io ~localize, compare, equal, hash, sexp, sexp_grammar, stable_witness, typerep]
 
     let map x ~f1 ~f2 =
       match x with
@@ -17,8 +18,8 @@ include Stable.V1
 include Base.Either
 
 include Comparator.Derived2 (struct
-  type nonrec ('a, 'b) t = ('a, 'b) t [@@deriving sexp_of, compare]
-end)
+    type nonrec ('a, 'b) t = ('a, 'b) t [@@deriving sexp_of, compare]
+  end)
 
 let quickcheck_generator = Base_quickcheck.Generator.either
 let quickcheck_observer = Base_quickcheck.Observer.either
Index: core-0.17.1/core/src/either.mli
===================================================================
--- core-0.17.1.orig/core/src/either.mli
+++ core-0.17.1/core/src/either.mli
@@ -19,7 +19,7 @@ module Stable : sig
     type nonrec ('f, 's) t = ('f, 's) t =
       | First of 'f
       | Second of 's
-    [@@deriving bin_io ~localize, equal]
+    [@@deriving bin_io ~localize, equal, sexp_grammar]
 
     include Stable_module_types.With_stable_witness.S2 with type ('f, 's) t := ('f, 's) t
   end
Index: core-0.17.1/core/src/error.mli
===================================================================
--- core-0.17.1.orig/core/src/error.mli
+++ core-0.17.1/core/src/error.mli
@@ -42,4 +42,4 @@ val failwithp
   -> 'a
   -> ('a -> Base.Sexp.t)
   -> _
-  [@@deprecated "[since 2020-03] Use [failwiths] instead."]
+[@@deprecated "[since 2020-03] Use [failwiths] instead."]
Index: core-0.17.1/core/src/fdeque.ml
===================================================================
--- core-0.17.1.orig/core/src/fdeque.ml
+++ core-0.17.1/core/src/fdeque.ml
@@ -208,8 +208,8 @@ module Arbitrary_order = struct
 end
 
 module Make_container (F : sig
-  val to_list : 'a t -> 'a list
-end) =
+    val to_list : 'a t -> 'a list
+  end) =
 struct
   let to_list = F.to_list
   let is_empty = is_empty
@@ -247,8 +247,8 @@ module Front_to_back = struct
   ;;
 
   include Make_container (struct
-    let to_list = to_list
-  end)
+      let to_list = to_list
+    end)
 end
 
 module Back_to_front = struct
@@ -268,8 +268,8 @@ module Back_to_front = struct
   ;;
 
   include Make_container (struct
-    let to_list = to_list
-  end)
+      let to_list = to_list
+    end)
 end
 
 include Front_to_back
@@ -277,20 +277,20 @@ include Front_to_back
 let singleton x = of_list [ x ]
 
 include Monad.Make (struct
-  type nonrec 'a t = 'a t
-
-  let bind t ~f =
-    fold t ~init:empty ~f:(fun t elt -> fold (f elt) ~init:t ~f:enqueue_back)
-  ;;
-
-  let return = singleton
+    type nonrec 'a t = 'a t
 
-  let map =
-    `Custom
-      (fun t ~f ->
-        { front = List.map t.front ~f; back = List.map t.back ~f; length = t.length })
-  ;;
-end)
+    let bind t ~f =
+      fold t ~init:empty ~f:(fun t elt -> fold (f elt) ~init:t ~f:enqueue_back)
+    ;;
+
+    let return = singleton
+
+    let map =
+      `Custom
+        (fun t ~f ->
+          { front = List.map t.front ~f; back = List.map t.back ~f; length = t.length })
+    ;;
+  end)
 
 let compare cmp t1 t2 = List.compare cmp (to_list t1) (to_list t2)
 let equal eq t1 t2 = List.equal eq (to_list t1) (to_list t2)
@@ -299,6 +299,16 @@ let hash_fold_t hash_fold_a state t =
   fold ~f:hash_fold_a ~init:([%hash_fold: int] state (length t)) t
 ;;
 
+include
+  Quickcheckable.Of_quickcheckable1
+    (List)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_list
+      let of_quickcheckable = of_list
+    end)
+
 module Stable = struct
   module V1 = struct
     type nonrec 'a t = 'a t
@@ -307,33 +317,38 @@ module Stable = struct
     let equal = equal
     let sexp_of_t sexp_of_elt t = [%sexp_of: elt list] (to_list t)
     let t_of_sexp elt_of_sexp sexp = of_list ([%of_sexp: elt list] sexp)
-    let t_sexp_grammar = List.t_sexp_grammar
+
+    let t_sexp_grammar : 'a Sexplib.Sexp_grammar.t -> 'a t Sexplib.Sexp_grammar.t =
+      fun a_sexp_grammar ->
+      Sexplib.Sexp_grammar.coerce (List.t_sexp_grammar a_sexp_grammar)
+    ;;
+
     let map = map
 
     include Bin_prot.Utils.Make_iterable_binable1 (struct
-      type nonrec 'a t = 'a t
-      type 'a el = 'a [@@deriving bin_io]
+        type nonrec 'a t = 'a t
+        type 'a el = 'a [@@deriving bin_io]
 
-      let caller_identity =
-        Bin_prot.Shape.Uuid.of_string "83f96982-4992-11e6-919d-fbddcfdca576"
-      ;;
-
-      let module_name = Some "Core.Fdeque"
-      let length = length
-      let iter t ~f = List.iter (to_list t) ~f
-
-      let init ~len ~next =
-        let rec loop next acc n =
-          if len = n
-          then acc
-          else (
-            assert (n = length acc);
-            let x = next () in
-            loop next (enqueue_back acc x) (n + 1))
-        in
-        loop next empty 0
-      ;;
-    end)
+        let caller_identity =
+          Bin_prot.Shape.Uuid.of_string "83f96982-4992-11e6-919d-fbddcfdca576"
+        ;;
+
+        let module_name = Some "Core.Fdeque"
+        let length = length
+        let iter t ~f = List.iter (to_list t) ~f
+
+        let init ~len ~next =
+          let rec loop next acc n =
+            if len = n
+            then acc
+            else (
+              assert (n = length acc);
+              let x = next () in
+              loop next (enqueue_back acc x) (n + 1))
+          in
+          loop next empty 0
+        ;;
+      end)
 
     (* The binary representation produced by Bin_prot.Utils.Make_iterable_binable1 is
        assumed to be stable (if the 'a is stable). *)
Index: core-0.17.1/core/src/fdeque.mli
===================================================================
--- core-0.17.1.orig/core/src/fdeque.mli
+++ core-0.17.1/core/src/fdeque.mli
@@ -7,7 +7,7 @@
 
 open! Import
 
-type 'a t [@@deriving bin_io, compare, equal, hash, sexp]
+type 'a t [@@deriving bin_io, compare, equal, hash, quickcheck, sexp, sexp_grammar]
 
 (** [Container] operations traverse deque elements front-to-back, like [Front_to_back]
     below. If you need faster traversal and don't care about the order, use
Index: core-0.17.1/core/src/filename.ml
===================================================================
--- core-0.17.1.orig/core/src/filename.ml
+++ core-0.17.1/core/src/filename.ml
@@ -2,20 +2,20 @@ module Stable = struct
   module V1 = struct
     include (
       String.Stable.V1 :
-        sig
-          type t = string
-          [@@deriving
-            bin_io ~localize, compare, equal, hash, sexp, sexp_grammar, stable_witness]
-
-          include
-            Comparable.Stable.V1.With_stable_witness.S
-              with type comparable := t
-              with type comparator_witness = String.Stable.V1.comparator_witness
+      sig
+        type t = string
+        [@@deriving
+          bin_io ~localize, compare, equal, hash, sexp, sexp_grammar, stable_witness]
+
+        include
+          Comparable.Stable.V1.With_stable_witness.S
+          with type comparable := t
+          with type comparator_witness = String.Stable.V1.comparator_witness
 
-          val comparator : (t, comparator_witness) Comparator.t
+        val comparator : (t, comparator_witness) Comparator.t
 
-          include Hashable.Stable.V1.With_stable_witness.S with type key := t
-        end)
+        include Hashable.Stable.V1.With_stable_witness.S with type key := t
+      end)
   end
 end
 
@@ -25,11 +25,11 @@ include Filename_base
 
 include (
   String :
-    sig
-      type t = string [@@deriving bin_io ~localize]
+  sig
+    type t = string [@@deriving bin_io ~localize]
 
-      include
-        Comparable.S with type t := t and type comparator_witness := comparator_witness
+    include
+      Comparable.S with type t := t and type comparator_witness := comparator_witness
 
-      include Hashable.S with type t := t
-    end)
+    include Hashable.S with type t := t
+  end)
Index: core-0.17.1/core/src/filename.mli
===================================================================
--- core-0.17.1.orig/core/src/filename.mli
+++ core-0.17.1/core/src/filename.mli
@@ -11,8 +11,8 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-        with type comparator_witness = comparator_witness
+      with type t := t
+      with type comparator_witness = comparator_witness
 
     include Hashable.Stable.V1.With_stable_witness.S with type key := t
   end
Index: core-0.17.1/core/src/float.ml
===================================================================
--- core-0.17.1.orig/core/src/float.ml
+++ core-0.17.1/core/src/float.ml
@@ -77,8 +77,8 @@ module Robust_compare = struct
   end
 
   module Make (T : sig
-    val robust_comparison_tolerance : float
-  end) : S = struct
+      val robust_comparison_tolerance : float
+    end) : S = struct
     (* We have test in the tree that rely on these functions not allocating, even without
        X_LIBRARY_INLING. The only way to ensure that these don't create temporary boxed
        floats without X_LIBRARY_INLING is for this code to see the float operations as
@@ -106,8 +106,8 @@ module Robust_compare = struct
 end
 
 module Robustly_comparable = Robust_compare.Make (struct
-  let robust_comparison_tolerance = 1E-7
-end)
+    let robust_comparison_tolerance = 1E-7
+  end)
 
 include Robustly_comparable
 
Index: core-0.17.1/core/src/float.mli
===================================================================
--- core-0.17.1.orig/core/src/float.mli
+++ core-0.17.1/core/src/float.mli
@@ -18,8 +18,8 @@ module Robust_compare : sig
   end
 
   module Make (T : sig
-    val robust_comparison_tolerance : float
-  end) : S
+      val robust_comparison_tolerance : float
+    end) : S
 end
 
 (** So-called "robust" comparisons, which include a small tolerance, so that float that
@@ -50,8 +50,8 @@ end
 
 include
   Identifiable.S
-    with type t := t
-     and type comparator_witness := Base.Float.comparator_witness
+  with type t := t
+   and type comparator_witness := Base.Float.comparator_witness
 
 include Comparable.Validate_with_zero with type t := t
 
@@ -78,7 +78,7 @@ include Quickcheckable.S with type t :=
   [Comparable.With_zero]. *)
 
 val sign : t -> Sign.t
-  [@@deprecated "[since 2016-01] Replace [sign] with [robust_sign] or [sign_exn]"]
+[@@deprecated "[since 2016-01] Replace [sign] with [robust_sign] or [sign_exn]"]
 
 (** (Formerly [sign]) Uses robust comparison (so sufficiently small numbers are mapped
     to [Zero]).  Also maps NaN to [Zero]. Using this function is weakly discouraged. *)
@@ -142,7 +142,7 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
   end
 end
Index: core-0.17.1/core/src/fqueue.mli
===================================================================
--- core-0.17.1.orig/core/src/fqueue.mli
+++ core-0.17.1/core/src/fqueue.mli
@@ -8,7 +8,7 @@
 
 open! Import
 
-type 'a t [@@deriving bin_io, compare, equal, hash, sexp]
+type 'a t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
 include Container.S1 with type 'a t := 'a t
 include Invariant.S1 with type 'a t := 'a t
Index: core-0.17.1/core/src/gc.ml
===================================================================
--- core-0.17.1.orig/core/src/gc.ml
+++ core-0.17.1/core/src/gc.ml
@@ -7,36 +7,12 @@ module Stable = struct
         | Next_fit
         | First_fit
         | Best_fit
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
   end
 
   module Stat = struct
-    [%%if ocaml_version < (4, 12, 0)]
-
     module V1 = struct
-      type t = Stdlib.Gc.stat =
-        { minor_words : float
-        ; promoted_words : float
-        ; major_words : float
-        ; minor_collections : int
-        ; major_collections : int
-        ; heap_words : int
-        ; heap_chunks : int
-        ; live_words : int
-        ; live_blocks : int
-        ; free_words : int
-        ; free_blocks : int
-        ; largest_free : int
-        ; fragments : int
-        ; compactions : int
-        ; top_heap_words : int
-        ; stack_size : int
-        }
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
-    end
-
-    module V2 = struct
       type t =
         { minor_words : float
         ; promoted_words : float
@@ -54,33 +30,8 @@ module Stable = struct
         ; compactions : int
         ; top_heap_words : int
         ; stack_size : int
-        ; forced_major_collections : int
         }
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
-    end
-
-    [%%else]
-
-    module V1 = struct
-      type t =
-        { minor_words : float
-        ; promoted_words : float
-        ; major_words : float
-        ; minor_collections : int
-        ; major_collections : int
-        ; heap_words : int
-        ; heap_chunks : int
-        ; live_words : int
-        ; live_blocks : int
-        ; free_words : int
-        ; free_blocks : int
-        ; largest_free : int
-        ; fragments : int
-        ; compactions : int
-        ; top_heap_words : int
-        ; stack_size : int
-        }
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module V2 = struct
@@ -103,36 +54,11 @@ module Stable = struct
         ; stack_size : int
         ; forced_major_collections : int
         }
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
-
-    [%%endif]
   end
 
   module Control = struct
-    [%%if ocaml_version < (5, 0, 0)]
-
-    module V1 = struct
-      [@@@ocaml.warning "-3"]
-
-      type t = Stdlib.Gc.control =
-        { mutable minor_heap_size : int
-        ; mutable major_heap_increment : int
-        ; mutable space_overhead : int
-        ; mutable verbose : int
-        ; mutable max_overhead : int
-        ; mutable stack_limit : int
-        ; mutable allocation_policy : int
-        ; window_size : int
-        ; custom_major_ratio : int
-        ; custom_minor_ratio : int
-        ; custom_minor_max_size : int
-        }
-      [@@deriving bin_io, compare, equal, sexp, stable_witness]
-    end
-
-    [%%else]
-
     module V1 = struct
       [@@@ocaml.warning "-3"]
 
@@ -149,10 +75,8 @@ module Stable = struct
         ; custom_minor_ratio : int
         ; custom_minor_max_size : int
         }
-      [@@deriving bin_io, compare, equal, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, sexp, sexp_grammar, stable_witness]
     end
-
-    [%%endif]
   end
 end
 
@@ -160,30 +84,6 @@ include Stdlib.Gc
 
 module Stat = struct
   module T = struct
-    [%%if ocaml_version < (4, 12, 0)]
-
-    type t = Stdlib.Gc.stat =
-      { minor_words : float
-      ; promoted_words : float
-      ; major_words : float
-      ; minor_collections : int
-      ; major_collections : int
-      ; heap_words : int
-      ; heap_chunks : int
-      ; live_words : int
-      ; live_blocks : int
-      ; free_words : int
-      ; free_blocks : int
-      ; largest_free : int
-      ; fragments : int
-      ; compactions : int
-      ; top_heap_words : int
-      ; stack_size : int
-      }
-    [@@deriving compare, hash, bin_io, sexp]
-
-    [%%else]
-
     type t = Stdlib.Gc.stat =
       { minor_words : float
       ; promoted_words : float
@@ -213,37 +113,11 @@ module Stat = struct
           ~fields
           ~iterators:(create, fold, iter, map, to_list)
           ~direct_iterators:to_list]
-
-    [%%endif]
   end
 
   include T
   include Comparable.Make_plain (T)
 
-  [%%if ocaml_version < (4, 12, 0)]
-
-  let combine first second ~float_f ~int_f =
-    { minor_words = float_f first.minor_words second.minor_words
-    ; promoted_words = float_f first.promoted_words second.promoted_words
-    ; major_words = float_f first.major_words second.major_words
-    ; minor_collections = int_f first.minor_collections second.minor_collections
-    ; major_collections = int_f first.major_collections second.major_collections
-    ; heap_words = int_f first.heap_words second.heap_words
-    ; heap_chunks = int_f first.heap_chunks second.heap_chunks
-    ; live_words = int_f first.live_words second.live_words
-    ; live_blocks = int_f first.live_blocks second.live_blocks
-    ; free_words = int_f first.free_words second.free_words
-    ; free_blocks = int_f first.free_blocks second.free_blocks
-    ; largest_free = int_f first.largest_free second.largest_free
-    ; fragments = int_f first.fragments second.fragments
-    ; compactions = int_f first.compactions second.compactions
-    ; top_heap_words = int_f first.top_heap_words second.top_heap_words
-    ; stack_size = int_f first.stack_size second.stack_size
-    }
-  ;;
-
-  [%%else]
-
   let combine first second ~float_f ~int_f =
     { minor_words = float_f first.minor_words second.minor_words
     ; promoted_words = float_f first.promoted_words second.promoted_words
@@ -266,37 +140,11 @@ module Stat = struct
     }
   ;;
 
-  [%%endif]
-
   let add = combine ~float_f:Float.( + ) ~int_f:Int.( + )
   let diff = combine ~float_f:Float.( - ) ~int_f:Int.( - )
 end
 
 module Control = struct
-  [%%if ocaml_version < (5, 0, 0)]
-
-  module T = struct
-    [@@@ocaml.warning "-3"]
-
-    type t = Stdlib.Gc.control =
-      { mutable minor_heap_size : int
-      ; mutable major_heap_increment : int
-      ; mutable space_overhead : int
-      ; mutable verbose : int
-      ; mutable max_overhead : int
-      ; mutable stack_limit : int
-      ; mutable allocation_policy : int
-      ; window_size : int
-      ; custom_major_ratio : int
-      ; custom_minor_ratio : int
-      ; custom_minor_max_size : int
-      }
-    [@@deriving
-      compare, sexp_of, fields ~getters ~setters ~fields ~iterators:(map, to_list)]
-  end
-
-  [%%else]
-
   module T = struct
     [@@@ocaml.warning "-3"]
 
@@ -317,8 +165,6 @@ module Control = struct
       compare, sexp_of, fields ~getters ~setters ~fields ~iterators:(map, to_list)]
   end
 
-  [%%endif]
-
   include T
   include Comparable.Make_plain (T)
 end
@@ -414,15 +260,6 @@ module Runtime4 = struct
 end
 
 [%%import "gc_stubs.h"]
-[%%if ocaml_version < (5, 0, 0)]
-
-external compactions : unit -> int = "core_gc_compactions" [@@noalloc]
-
-let heap_words = Runtime4.heap_words
-let heap_chunks = Runtime4.heap_chunks
-let top_heap_words = Runtime4.top_heap_words
-
-[%%else]
 
 module Runtime5 = struct
   let heap_words () = (quick_stat ()).heap_words
@@ -448,7 +285,6 @@ let heap_chunks = Runtime5.heap_chunks
 let top_heap_words = Runtime5.top_heap_words
 
 [%%endif]
-[%%endif]
 
 let stat_size_lazy =
   lazy (Obj.reachable_words (Obj.repr (Stdlib.Gc.quick_stat () : Stat.t)))
@@ -456,6 +292,7 @@ let stat_size_lazy =
 
 let stat_size () = Lazy.force stat_size_lazy
 let zero = Sys.opaque_identity (int_of_string "0")
+let compact_if_not_running_test () = if not am_running_test then compact ()
 
 (* The compiler won't optimize int_of_string away so it won't
    perform constant folding below. *)
@@ -486,8 +323,8 @@ module For_testing = struct
     measure_internal
       f
       ~on_result:(fun ~major_words_allocated ~minor_words_allocated value ->
-      ignore (Sys.opaque_identity value : a);
-      major_words_allocated == 0 && minor_words_allocated == 0) [@nontail]
+        ignore (Sys.opaque_identity value : a);
+        major_words_allocated == 0 && minor_words_allocated == 0) [@nontail]
   ;;
 
   let is_zero_alloc f = is_zero_alloc_local (fun () -> { g = f () }) [@nontail]
@@ -542,7 +379,15 @@ module For_testing = struct
     [@@deriving sexp_of, globalize]
   end
 
-  [%%if ocaml_version >= (4, 11, 0)]
+  [%%if OCAML_5_MINUS || ocaml_version >= (5, 2, 0)]
+
+  type memprof = Stdlib.Gc.Memprof.t
+
+  [%%else]
+
+  type memprof = unit
+
+  [%%endif]
 
   let measure_and_log_allocation_local (f : unit -> 'a) =
     let log : Allocation_log.t list ref = ref []
@@ -562,8 +407,8 @@ module For_testing = struct
         | Some p ->
           String.sub ~pos:0 ~len:p backtrace
           |> String.rstrip ~drop:(function
-               | '\n' -> false
-               | _ -> true)
+            | '\n' -> false
+            | _ -> true)
       in
       let info : Allocation_log.t =
         { size_in_words = info.n_samples; is_major; backtrace }
@@ -577,8 +422,8 @@ module For_testing = struct
       ; alloc_major = on_alloc ~is_major:true
       }
     in
-    match Stdlib.Gc.Memprof.start ~sampling_rate:1.0 tracker with
-    | _ ->
+    match Memprof.start ~sampling_rate:1.0 tracker with
+    | (_ : memprof) ->
       (* Exn.protect, manually inlined to guarantee no allocations *)
       let result =
         match f () with
@@ -587,11 +432,11 @@ module For_testing = struct
              delayed if they happened during C code and there has been no allocation since),
              so we explictly flush them *)
           run_memprof_callbacks ();
-          Stdlib.Gc.Memprof.stop ();
+          Memprof.stop ();
           x
         | exception e ->
           run_memprof_callbacks ();
-          Stdlib.Gc.Memprof.stop ();
+          Memprof.stop ();
           raise e
       in
       ( result
@@ -616,17 +461,6 @@ module For_testing = struct
     , [%globalize: Allocation_log.t list] log )
   ;;
 
-  [%%else]
-
-  let measure_and_log_allocation f =
-    let x, report = measure_allocation f in
-    x, report, []
-  ;;
-
-  let measure_and_log_allocation_local = measure_and_log_allocation
-
-  [%%endif]
-
   let[@cold] require_no_allocation_local_failed here allocation_report allocation_log =
     let allocation_report = [%globalize: Allocation_report.t] allocation_report in
     let allocation_log = [%globalize: Allocation_log.t list] allocation_log in
@@ -696,6 +530,10 @@ module Expert = struct
 
   let finalize_release = Stdlib.Gc.finalise_release
 
+  (* Sys.opaque_identity means accesses to the ref cannot be optimized out *)
+  let leaked_values : Obj.t list ref = Sys.opaque_identity (ref [])
+  let leak a = leaked_values := Obj.repr a :: !leaked_values
+
   module Alarm = struct
     type t = alarm
 
Index: core-0.17.1/core/src/gc.mli
===================================================================
--- core-0.17.1.orig/core/src/gc.mli
+++ core-0.17.1/core/src/gc.mli
@@ -24,98 +24,98 @@ module Stat : sig
 
   type t =
     { minor_words : float
-        (** Number of words allocated in the minor heap since
+    (** Number of words allocated in the minor heap since
         the program was started.  This number is accurate in
         byte-code programs, but only an approximation in programs
         compiled to native code. *)
     ; promoted_words : float
-        (** Number of words allocated in the minor heap that
+    (** Number of words allocated in the minor heap that
         survived a minor collection and were moved to the major heap
         since the program was started. *)
     ; major_words : float
-        (** Number of words allocated in the major heap, including
+    (** Number of words allocated in the major heap, including
         the promoted words, since the program was started. *)
     ; minor_collections : int
-        (** Number of minor collections since the program was started. *)
+    (** Number of minor collections since the program was started. *)
     ; major_collections : int
-        (** Number of major collection cycles completed since the program
+    (** Number of major collection cycles completed since the program
         was started. *)
     ; heap_words : int
-        (** Total size of the major heap, in words.
+    (** Total size of the major heap, in words.
         This metric is currently not available when using the OCaml 5 runtime: the field
         value is always [0]. *)
     ; heap_chunks : int
-        (** Number of contiguous pieces of memory that make up the major heap.
+    (** Number of contiguous pieces of memory that make up the major heap.
         This metric is currently not available when using the OCaml 5 runtime: the field
         value is always [0]. *)
     ; live_words : int
-        (** Number of words of live data in the major heap, including the header
+    (** Number of words of live data in the major heap, including the header
         words. *)
     ; live_blocks : int (** Number of live blocks in the major heap. *)
     ; free_words : int (** Number of words in the free list. *)
     ; free_blocks : int
-        (** Number of blocks in the free list.
+    (** Number of blocks in the free list.
         This metric is currently not available when using the OCaml 5 runtime: the field
         value is always [0]. *)
     ; largest_free : int
-        (** Size (in words) of the largest block in the free list.
+    (** Size (in words) of the largest block in the free list.
         This metric is currently not available when using the OCaml 5 runtime: the field
         value is always [0]. *)
     ; fragments : int
-        (** Number of wasted words due to fragmentation.  These are
+    (** Number of wasted words due to fragmentation.  These are
         1-words free blocks placed between two live blocks.  They
         are not available for allocation. *)
     ; compactions : int (** Number of heap compactions since the program was started. *)
     ; top_heap_words : int
-        (** Maximum size reached by the major heap, in words.
+    (** Maximum size reached by the major heap, in words.
         This metric is currently not available when using the OCaml 5 runtime: the field
         value is always [0]. *)
     ; stack_size : int
-        (** Current size of the stack, in words.
+    (** Current size of the stack, in words.
         This metric is currently not available when using the OCaml 5 runtime: the field
         value is always [0]. *)
     }
-  [@@deriving bin_io, sexp]
+  [@@deriving bin_io, sexp, sexp_grammar]
 
   [%%else]
 
   type t =
     { minor_words : float
-        (** Number of words allocated in the minor heap since
+    (** Number of words allocated in the minor heap since
         the program was started.  This number is accurate in
         byte-code programs, but only an approximation in programs
         compiled to native code. *)
     ; promoted_words : float
-        (** Number of words allocated in the minor heap that
+    (** Number of words allocated in the minor heap that
         survived a minor collection and were moved to the major heap
         since the program was started. *)
     ; major_words : float
-        (** Number of words allocated in the major heap, including
+    (** Number of words allocated in the major heap, including
         the promoted words, since the program was started. *)
     ; minor_collections : int
-        (** Number of minor collections since the program was started. *)
+    (** Number of minor collections since the program was started. *)
     ; major_collections : int
-        (** Number of major collection cycles completed since the program
+    (** Number of major collection cycles completed since the program
         was started. *)
     ; heap_words : int (** Total size of the major heap, in words. *)
     ; heap_chunks : int
-        (** Number of contiguous pieces of memory that make up the major heap. *)
+    (** Number of contiguous pieces of memory that make up the major heap. *)
     ; live_words : int
-        (** Number of words of live data in the major heap, including the header
+    (** Number of words of live data in the major heap, including the header
         words. *)
     ; live_blocks : int (** Number of live blocks in the major heap. *)
     ; free_words : int (** Number of words in the free list. *)
     ; free_blocks : int (** Number of blocks in the free list. *)
     ; largest_free : int (** Size (in words) of the largest block in the free list. *)
     ; fragments : int
-        (** Number of wasted words due to fragmentation.  These are
+    (** Number of wasted words due to fragmentation.  These are
         1-words free blocks placed between two live blocks.  They
         are not available for allocation. *)
     ; compactions : int (** Number of heap compactions since the program was started. *)
     ; top_heap_words : int (** Maximum size reached by the major heap, in words. *)
     ; stack_size : int (** Current size of the stack, in words. *)
     ; forced_major_collections : int
-        (** Number of forced full major collection cycles completed since the program
+    (** Number of forced full major collection cycles completed since the program
         was started. *)
     }
   [@@deriving
@@ -154,13 +154,13 @@ module Control : sig
 
   type t =
     { mutable minor_heap_size : int
-        (** The size (in words) of the minor heap.  Changing this parameter will
+    (** The size (in words) of the minor heap.  Changing this parameter will
         trigger a minor collection.
 
         Default: 262144 words / 1MB (32bit) / 2MB (64bit).
     *)
     ; mutable major_heap_increment : int
-        (** How much to add to the major heap when increasing it. If this
+    (** How much to add to the major heap when increasing it. If this
         number is less than or equal to 1000, it is a percentage of
         the current heap size (i.e. setting it to 100 will double the heap
         size at each increase). If it is more than 1000, it is a fixed
@@ -169,7 +169,7 @@ module Control : sig
         Default: 15%.
     *)
     ; mutable space_overhead : int
-        (** The major GC speed is computed from this parameter.
+    (** The major GC speed is computed from this parameter.
         This is the memory that will be "wasted" because the GC does not
         immediately collect unreachable blocks.  It is expressed as a
         percentage of the memory used for live data.
@@ -178,7 +178,7 @@ module Control : sig
 
         Default: 80. *)
     ; mutable verbose : int
-        (** This value controls the GC messages on standard error output.
+    (** This value controls the GC messages on standard error output.
         It is a sum of some of the following flags, to print messages
         on the corresponding events:
         - [0x001] Start of major GC cycle.
@@ -194,7 +194,7 @@ module Control : sig
 
         Default: 0. *)
     ; mutable max_overhead : int
-        (** Heap compaction is triggered when the estimated amount
+    (** Heap compaction is triggered when the estimated amount
         of "wasted" memory is more than [max_overhead] percent of the
         amount of live data.  If [max_overhead] is set to 0, heap
         compaction is triggered at the end of each major GC cycle
@@ -203,13 +203,13 @@ module Control : sig
 
         Default: 500. *)
     ; mutable stack_limit : int
-        (** The maximum size of the stack (in words).  This is only
+    (** The maximum size of the stack (in words).  This is only
         relevant to the byte-code runtime, as the native code runtime
         uses the operating system's stack.
 
         Default: 1048576 words / 4MB (32bit) / 8MB (64bit). *)
     ; mutable allocation_policy : int
-        (** The policy used for allocating in the heap.  Possible
+    (** The policy used for allocating in the heap.  Possible
         values are 0 and 1.  0 is the next-fit policy, which is
         quite fast but can result in fragmentation.  1 is the
         first-fit policy, which can be slower in some cases but
@@ -217,13 +217,14 @@ module Control : sig
 
         Default: 0. *)
     ; window_size : int
-        (** The size of the window used by the major GC for smoothing
+    (** The size of the window used by the major GC for smoothing
         out variations in its workload. This is an integer between
         1 and 50.
 
-        Default: 1. @since 4.03.0 *)
+        Default: 1.
+        @since 4.03.0 *)
     ; custom_major_ratio : int
-        (** Target ratio of floating garbage to major heap size for
+    (** Target ratio of floating garbage to major heap size for
         out-of-heap memory held by custom values located in the major
         heap. The GC speed is adjusted to try to use this much memory
         for dead values that are not yet collected. Expressed as a
@@ -235,7 +236,7 @@ module Control : sig
         Default: 44.
         @since 4.08.0 *)
     ; custom_minor_ratio : int
-        (** Bound on floating garbage for out-of-heap memory held by
+    (** Bound on floating garbage for out-of-heap memory held by
         custom values in the minor heap. A minor GC is triggered when
         this much memory is held by custom values located in the minor
         heap. Expressed as a percentage of minor heap size.
@@ -244,7 +245,7 @@ module Control : sig
         Default: 100.
         @since 4.08.0 *)
     ; custom_minor_max_size : int
-        (** Maximum amount of out-of-heap memory for each custom value
+    (** Maximum amount of out-of-heap memory for each custom value
         allocated in the minor heap. When a custom value is allocated
         on the minor heap and holds more than this many bytes, only
         this value is counted against [custom_minor_ratio] and the
@@ -260,7 +261,7 @@ module Control : sig
 
   type t =
     { minor_heap_size : int
-        (** The size (in words) of the minor heap.  Changing
+    (** The size (in words) of the minor heap.  Changing
         this parameter will trigger a minor collection.
 
         Under the OCaml 5 runtime: the total size of the minor heap used by the program
@@ -269,7 +270,7 @@ module Control : sig
         Default: 262144 words / 1MB (32bit) / 2MB (64bit).
     *)
     ; major_heap_increment : int
-        (** How much to add to the major heap when increasing it. If this
+    (** How much to add to the major heap when increasing it. If this
         number is less than or equal to 1000, it is a percentage of
         the current heap size (i.e. setting it to 100 will double the heap
         size at each increase). If it is more than 1000, it is a fixed
@@ -277,7 +278,7 @@ module Control : sig
         Default: 15%.
     *)
     ; space_overhead : int
-        (** The major GC speed is computed from this parameter.
+    (** The major GC speed is computed from this parameter.
         This is the memory that will be "wasted" because the GC does not
         immediately collect unreachable blocks.  It is expressed as a
         percentage of the memory used for live data.
@@ -286,7 +287,7 @@ module Control : sig
         Default: 80 for the OCaml 4 runtime, 120 for the OCaml 5 runtime
         (the latter subject to change). *)
     ; verbose : int
-        (** This value controls the GC messages on standard error output.
+    (** This value controls the GC messages on standard error output.
         It is a sum of some of the following flags, to print messages
         on the corresponding events:
         - [0x001] Start of major GC cycle.
@@ -302,7 +303,7 @@ module Control : sig
         - [0x400] Output GC statistics at program exit (OCaml 5 runtime only).
           Default: 0. *)
     ; max_overhead : int
-        (** Heap compaction is triggered when the estimated amount
+    (** Heap compaction is triggered when the estimated amount
         of "wasted" memory is more than [max_overhead] percent of the
         amount of live data.  If [max_overhead] is set to 0, heap
         compaction is triggered at the end of each major GC cycle
@@ -310,24 +311,25 @@ module Control : sig
         If [max_overhead >= 1000000], compaction is never triggered.
         Default: 500. *)
     ; stack_limit : int
-        (** The maximum size of the stack (in words).  This is only
+    (** The maximum size of the stack (in words).  This is only
         relevant to the byte-code runtime, as the native code runtime
         uses the operating system's stack.
         Default: 1048576 words / 4MB (32bit) / 8MB (64bit). *)
     ; allocation_policy : int
-        (** The policy used for allocating in the heap.  Possible
+    (** The policy used for allocating in the heap.  Possible
         values are 0 and 1.  0 is the next-fit policy, which is
         quite fast but can result in fragmentation.  1 is the
         first-fit policy, which can be slower in some cases but
         can be better for programs with fragmentation problems.
         Default: 0. *)
     ; window_size : int
-        (** The size of the window used by the major GC for smoothing
+    (** The size of the window used by the major GC for smoothing
         out variations in its workload. This is an integer between
         1 and 50.
-        Default: 1. @since 4.03.0 *)
+        Default: 1.
+        @since 4.03.0 *)
     ; custom_major_ratio : int
-        (** Target ratio of floating garbage to major heap size for
+    (** Target ratio of floating garbage to major heap size for
         out-of-heap memory held by custom values located in the major
         heap. The GC speed is adjusted to try to use this much memory
         for dead values that are not yet collected. Expressed as a
@@ -339,7 +341,7 @@ module Control : sig
         Default: 44.
         @since 4.08.0 *)
     ; custom_minor_ratio : int
-        (** Bound on floating garbage for out-of-heap memory held by
+    (** Bound on floating garbage for out-of-heap memory held by
         custom values in the minor heap. A minor GC is triggered when
         this much memory is held by custom values located in the minor
         heap. Expressed as a percentage of minor heap size.
@@ -348,7 +350,7 @@ module Control : sig
         Default: 100.
         @since 4.08.0 *)
     ; custom_minor_max_size : int
-        (** Maximum amount of out-of-heap memory for each custom value
+    (** Maximum amount of out-of-heap memory for each custom value
         allocated in the minor heap. When a custom value is allocated
         on the minor heap and holds more than this many bytes, only
         this value is counted against [custom_minor_ratio] and the
@@ -475,6 +477,11 @@ external full_major : unit -> unit = "ca
     compaction is a lengthy operation. *)
 external compact : unit -> unit = "caml_gc_compaction"
 
+(** [compact_if_not_running_test ()] is useful for speeding up tests. Lots of applications
+    have [compact ()] calls which are useful for cleaning up garbage created as part of
+    initialization, but unconditionally compacting in tests can be particularly slow. *)
+val compact_if_not_running_test : unit -> unit
+
 (** Print the current values of the memory management counters (in
     human-readable form) into the channel argument. *)
 val print_stat : out_channel -> unit
@@ -668,6 +675,13 @@ module Expert : sig
       or not the current finalizer finishes. *)
   val finalize_release : unit -> unit
 
+  (** Ensure that a value never becomes unreachable and is thus never deallocated. Useful
+      if the value has a finalizer attached and that finalizer must never run, perhaps
+      because it checks for a condition that we know will not be true. For example, if the
+      value returned by [Foreign.dynamic_funptr] cannot safely be [free]d, then its
+      finalizer will always raise a fatal error. *)
+  val leak : 'a -> unit
+
   (** A GC alarm calls a user function at the end of each major GC cycle. *)
   module Alarm : sig
     type t [@@deriving sexp_of]
@@ -692,22 +706,24 @@ module Stable : sig
 
     module V1 : sig
       type nonrec t = Stat.t
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module V2 : sig
-      type nonrec t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      type nonrec t
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     [%%else]
 
     module V1 : sig
-      type nonrec t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      type nonrec t
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module V2 : sig
       type nonrec t = Stat.t
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     [%%endif]
@@ -716,13 +732,14 @@ module Stable : sig
   module Allocation_policy : sig
     module V1 : sig
       type nonrec t = Allocation_policy.t
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
   end
 
   module Control : sig
     module V1 : sig
-      type nonrec t = Control.t [@@deriving bin_io, compare, equal, sexp, stable_witness]
+      type nonrec t = Control.t
+      [@@deriving bin_io, compare, equal, sexp, sexp_grammar, stable_witness]
     end
   end
 end
Index: core-0.17.1/core/src/gc_stubs.c
===================================================================
--- core-0.17.1.orig/core/src/gc_stubs.c
+++ core-0.17.1/core/src/gc_stubs.c
@@ -22,13 +22,10 @@
 #endif
 
 static intnat minor_words(void) {
-  return (intnat)(caml_stat_minor_words +
-                  (double)(caml_young_end - caml_young_ptr));
+  return (intnat)(caml_stat_minor_words + (double)(caml_young_end - caml_young_ptr));
 }
 
-static intnat promoted_words(void) {
-  return ((intnat)caml_stat_promoted_words);
-}
+static intnat promoted_words(void) { return ((intnat)caml_stat_promoted_words); }
 
 CAMLprim value core_gc_minor_words(value unit) {
   (void)unit;
Index: core-0.17.1/core/src/hash_queue.ml
===================================================================
--- core-0.17.1.orig/core/src/hash_queue.ml
+++ core-0.17.1/core/src/hash_queue.ml
@@ -7,8 +7,8 @@ module type S_backend = S_backend
 module Make_backend (Table : Hashtbl_intf.Hashtbl) : S_backend = struct
   module type Backend =
     S1
-      with type 'key create_arg := 'key Hashtbl.Hashable.t
-      with type 'key create_key := 'key
+    with type 'key create_arg := 'key Hashtbl.Hashable.t
+    with type 'key create_key := 'key
 
   module Backend : Backend = struct
     module Key_value = struct
@@ -47,7 +47,7 @@ module Make_backend (Table : Hashtbl_int
       (* Look at each element in the queue, checking:
        *   - every element in the queue is in the hash table
        *   - there are no duplicate keys
-       *)
+      *)
       let keys = Table.create ~size:(Table.length t.table) (Table.hashable_s t.table) in
       Doubly_linked.iter t.queue ~f:(fun kv ->
         let key = kv.key in
@@ -390,10 +390,10 @@ module Make_backend (Table : Hashtbl_int
   module type S = S0 with type ('key, 'data) hash_queue := ('key, 'data) Backend.t
 
   module Make_with_hashable (T : sig
-    module Key : Key
+      module Key : Key
 
-    val hashable : Key.t Hashtbl.Hashable.t
-  end) : S with type key = T.Key.t = struct
+      val hashable : Key.t Hashtbl.Hashable.t
+    end) : S with type key = T.Key.t = struct
     include (Backend : Backend with type ('k, 'd) t := ('k, 'd) Backend.t)
 
     type key = T.Key.t
@@ -404,10 +404,10 @@ module Make_backend (Table : Hashtbl_int
   end
 
   module Make (Key : Key) : S with type key = Key.t = Make_with_hashable (struct
-    module Key = Key
+      module Key = Key
 
-    let hashable = Table.Hashable.of_key (module Key)
-  end)
+      let hashable = Table.Hashable.of_key (module Key)
+    end)
 
   include Backend
 end
Index: core-0.17.1/core/src/hash_queue_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/hash_queue_intf.ml
+++ core-0.17.1/core/src/hash_queue_intf.ml
@@ -208,9 +208,9 @@ module type S0 = sig
 
   include
     S1
-      with type 'key create_key := key
-      with type 'key create_arg := unit
-      with type ('key, 'data) t := ('key, 'data) hash_queue
+    with type 'key create_key := key
+    with type 'key create_arg := unit
+    with type ('key, 'data) t := ('key, 'data) hash_queue
 
   type 'data t = (key, 'data) hash_queue [@@deriving sexp_of]
 end
@@ -218,18 +218,18 @@ end
 module type S_backend = sig
   include
     S1
-      with type 'key create_arg := 'key Hashtbl.Hashable.t
-      with type 'key create_key := 'key
+    with type 'key create_arg := 'key Hashtbl.Hashable.t
+    with type 'key create_key := 'key
 
   module type S = S0 with type ('key, 'data) hash_queue := ('key, 'data) t
 
   module Make (Key : Key) : S with type key = Key.t
 
   module Make_with_hashable (T : sig
-    module Key : Key
+      module Key : Key
 
-    val hashable : Key.t Hashtbl.Hashable.t
-  end) : S with type key = T.Key.t
+      val hashable : Key.t Hashtbl.Hashable.t
+    end) : S with type key = T.Key.t
 end
 
 (** A hash-queue is a combination of a queue and a hashtable that
Index: core-0.17.1/core/src/hash_set.ml
===================================================================
--- core-0.17.1.orig/core/src/hash_set.ml
+++ core-0.17.1/core/src/hash_set.ml
@@ -12,10 +12,10 @@ module type Elt_binable = Hashtbl.Key_bi
 module type Elt_stable = Hashtbl.Key_stable
 
 module Make_plain_with_hashable (T : sig
-  module Elt : Elt_plain
+    module Elt : Elt_plain
 
-  val hashable : Elt.t Hashtbl.Hashable.t
-end) =
+    val hashable : Elt.t Hashtbl.Hashable.t
+  end) =
 struct
   type elt = T.Elt.t
   type nonrec t = elt t
@@ -23,61 +23,61 @@ struct
   let equal = equal
 
   include Creators (struct
-    type 'a t = T.Elt.t
+      type 'a t = T.Elt.t
 
-    let hashable = T.hashable
-  end)
+      let hashable = T.hashable
+    end)
 
   let sexp_of_t t = Poly.sexp_of_t T.Elt.sexp_of_t t
 
   module Provide_of_sexp
-    (X : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := elt) =
+      (X : sig
+             type t [@@deriving of_sexp]
+           end
+           with type t := elt) =
   struct
     let t_of_sexp sexp = t_of_sexp X.t_of_sexp sexp
   end
 
   module Provide_bin_io
-    (X : sig
-      type t [@@deriving bin_io]
-    end
-    with type t := elt) =
+      (X : sig
+             type t [@@deriving bin_io]
+           end
+           with type t := elt) =
   Bin_prot.Utils.Make_iterable_binable (struct
-    module Elt = struct
-      include T.Elt
-      include X
-    end
-
-    type nonrec t = t
-    type el = Elt.t [@@deriving bin_io]
-
-    let _ = bin_el
-
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "ad381672-4992-11e6-9e36-b76dc8cd466f"
-    ;;
-
-    let module_name = Some "Core.Hash_set"
-    let length = length
-    let iter = iter
-
-    let init ~len ~next =
-      let t = create ~size:len () in
-      for _i = 0 to len - 1 do
-        let v = next () in
-        add t v
-      done;
-      t
-    ;;
-  end)
+      module Elt = struct
+        include T.Elt
+        include X
+      end
+
+      type nonrec t = t
+      type el = Elt.t [@@deriving bin_io]
+
+      let _ = bin_el
+
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "ad381672-4992-11e6-9e36-b76dc8cd466f"
+      ;;
+
+      let module_name = Some "Core.Hash_set"
+      let length = length
+      let iter = iter
+
+      let init ~len ~next =
+        let t = create ~size:len () in
+        for _i = 0 to len - 1 do
+          let v = next () in
+          add t v
+        done;
+        t
+      ;;
+    end)
 
   module Provide_stable_witness
-    (X : sig
-      type t [@@deriving stable_witness]
-    end
-    with type t := elt) =
+      (X : sig
+             type t [@@deriving stable_witness]
+           end
+           with type t := elt) =
   struct
     (* The binary representation of hash_set is used in the stable modules below, so it's
        assumed to be stable (if the elt is stable) . *)
@@ -89,40 +89,40 @@ struct
 end
 
 module Make_with_hashable (T : sig
-  module Elt : Elt
+    module Elt : Elt
 
-  val hashable : Elt.t Hashtbl.Hashable.t
-end) =
+    val hashable : Elt.t Hashtbl.Hashable.t
+  end) =
 struct
   include Make_plain_with_hashable (T)
   include Provide_of_sexp (T.Elt)
 end
 
 module Make_binable_with_hashable (T : sig
-  module Elt : Elt_binable
+    module Elt : Elt_binable
 
-  val hashable : Elt.t Hashtbl.Hashable.t
-end) =
+    val hashable : Elt.t Hashtbl.Hashable.t
+  end) =
 struct
   include Make_with_hashable (T)
   include Provide_bin_io (T.Elt)
 end
 
 module Make_stable_with_hashable (T : sig
-  module Elt : Elt_stable
+    module Elt : Elt_stable
 
-  val hashable : Elt.t Hashtbl.Hashable.t
-end) =
+    val hashable : Elt.t Hashtbl.Hashable.t
+  end) =
 struct
   include Make_binable_with_hashable (T)
   include Provide_stable_witness (T.Elt)
 end
 
 module Make_plain (Elt : Elt_plain) = Make_plain_with_hashable (struct
-  module Elt = Elt
+    module Elt = Elt
 
-  let hashable = Hashtbl.Hashable.of_key (module Elt)
-end)
+    let hashable = Hashtbl.Hashable.of_key (module Elt)
+  end)
 
 module Make (Elt : Elt) = struct
   include Make_plain (Elt)
Index: core-0.17.1/core/src/hash_set_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/hash_set_intf.ml
+++ core-0.17.1/core/src/hash_set_intf.ml
@@ -33,28 +33,28 @@ module type S_plain = sig
 
   include
     Creators_generic
-      with type 'a t := t
-      with type 'a elt := elt
-      with type ('a, 'z) create_options :=
-        ('a, 'z) create_options_without_first_class_module
+    with type 'a t := t
+    with type 'a elt := elt
+    with type ('a, 'z) create_options :=
+      ('a, 'z) create_options_without_first_class_module
 
   module Provide_of_sexp
-    (X : sig
+      (X : sig
+             type t [@@deriving of_sexp]
+           end
+           with type t := elt) : sig
       type t [@@deriving of_sexp]
     end
-    with type t := elt) : sig
-    type t [@@deriving of_sexp]
-  end
-  with type t := t
+    with type t := t
 
   module Provide_bin_io
-    (X : sig
+      (X : sig
+             type t [@@deriving bin_io]
+           end
+           with type t := elt) : sig
       type t [@@deriving bin_io]
     end
-    with type t := elt) : sig
-    type t [@@deriving bin_io]
-  end
-  with type t := t
+    with type t := t
 end
 
 module type S = sig
@@ -105,10 +105,10 @@ module type Hash_set = sig
   module Using_hashable : sig
     include
       Creators_generic
-        with type 'a t := 'a t
-        with type 'a elt = 'a
-        with type ('key, 'z) create_options :=
-          ('key, 'z) create_options_with_hashable_required
+      with type 'a t := 'a t
+      with type 'a elt = 'a
+      with type ('key, 'z) create_options :=
+        ('key, 'z) create_options_with_hashable_required
   end
 
   (** A hash set that uses polymorphic comparison. *)
@@ -117,10 +117,10 @@ module type Hash_set = sig
 
     include
       Creators_generic
-        with type 'a t := 'a t
-        with type 'a elt = 'a
-        with type ('key, 'z) create_options :=
-          ('key, 'z) create_options_without_first_class_module
+      with type 'a t := 'a t
+      with type 'a elt = 'a
+      with type ('key, 'z) create_options :=
+        ('key, 'z) create_options_without_first_class_module
 
     include Accessors with type 'a t := 'a t with type 'a elt := 'a elt
   end
@@ -131,28 +131,28 @@ module type Hash_set = sig
   module Make_stable (Elt : Elt_stable) : S_stable with type elt = Elt.t
 
   module Make_plain_with_hashable (T : sig
-    module Elt : Elt_plain
+      module Elt : Elt_plain
 
-    val hashable : Elt.t Hashtbl.Hashable.t
-  end) : S_plain with type elt = T.Elt.t
+      val hashable : Elt.t Hashtbl.Hashable.t
+    end) : S_plain with type elt = T.Elt.t
 
   module Make_with_hashable (T : sig
-    module Elt : Elt
+      module Elt : Elt
 
-    val hashable : Elt.t Hashtbl.Hashable.t
-  end) : S with type elt = T.Elt.t
+      val hashable : Elt.t Hashtbl.Hashable.t
+    end) : S with type elt = T.Elt.t
 
   module Make_binable_with_hashable (T : sig
-    module Elt : Elt_binable
+      module Elt : Elt_binable
 
-    val hashable : Elt.t Hashtbl.Hashable.t
-  end) : S_binable with type elt = T.Elt.t
+      val hashable : Elt.t Hashtbl.Hashable.t
+    end) : S_binable with type elt = T.Elt.t
 
   module Make_stable_with_hashable (T : sig
-    module Elt : Elt_stable
+      module Elt : Elt_stable
 
-    val hashable : Elt.t Hashtbl.Hashable.t
-  end) : S_stable with type elt = T.Elt.t
+      val hashable : Elt.t Hashtbl.Hashable.t
+    end) : S_stable with type elt = T.Elt.t
 
   include For_deriving with type 'a t := 'a t
 end
Index: core-0.17.1/core/src/hashable.ml
===================================================================
--- core-0.17.1.orig/core/src/hashable.ml
+++ core-0.17.1/core/src/hashable.ml
@@ -4,10 +4,10 @@ open! Import
 include Hashable_intf
 
 module Make_plain (T : sig
-  type t [@@deriving hash]
+    type t [@@deriving hash]
 
-  include Hashtbl.Key_plain with type t := t
-end) : S_plain with type t := T.t = struct
+    include Hashtbl.Key_plain with type t := t
+  end) : S_plain with type t := T.t = struct
   include T
   module Table = Hashtbl.Make_plain (T)
   module Hash_set = Hash_set.Make_plain (T)
@@ -18,16 +18,16 @@ end
 
 module Make_plain_and_derive_hash_fold_t (T : Hashtbl.Key_plain) :
   S_plain with type t := T.t = Make_plain (struct
-  include T
+    include T
 
-  let hash_fold_t state t = hash_fold_int state (hash t)
-end)
+    let hash_fold_t state t = hash_fold_int state (hash t)
+  end)
 
 module Make (T : sig
-  type t [@@deriving hash]
+    type t [@@deriving hash]
 
-  include Hashtbl.Key with type t := t
-end) : S with type t := T.t = struct
+    include Hashtbl.Key with type t := t
+  end) : S with type t := T.t = struct
   include T
   module Table = Hashtbl.Make (T)
   module Hash_set = Hash_set.Make (T)
@@ -37,16 +37,16 @@ end) : S with type t := T.t = struct
 end
 
 module Make_and_derive_hash_fold_t (T : Hashtbl.Key) : S with type t := T.t = Make (struct
-  include T
+    include T
 
-  let hash_fold_t state t = hash_fold_int state (hash t)
-end)
+    let hash_fold_t state t = hash_fold_int state (hash t)
+  end)
 
 module Make_binable (T : sig
-  type t [@@deriving hash]
+    type t [@@deriving hash]
 
-  include Hashtbl.Key_binable with type t := t
-end) : S_binable with type t := T.t = struct
+    include Hashtbl.Key_binable with type t := t
+  end) : S_binable with type t := T.t = struct
   module Table = Hashtbl.Make_binable (T)
   module Hash_set = Hash_set.Make_binable (T)
   module Hash_queue = Hash_queue.Make (T)
@@ -56,22 +56,22 @@ end) : S_binable with type t := T.t = st
 end
 
 module Make_plain_with_hashable (T : sig
-  module Key : sig
-    type t [@@deriving hash]
+    module Key : sig
+      type t [@@deriving hash]
 
-    include Hashtbl.Key_plain with type t := t
-  end
+      include Hashtbl.Key_plain with type t := t
+    end
 
-  val hashable : Key.t Hashtbl_intf.Hashable.t
-end) : S_plain with type t := T.Key.t = struct
+    val hashable : Key.t Hashtbl_intf.Hashable.t
+  end) : S_plain with type t := T.Key.t = struct
   include T.Key
   module Table = Hashtbl.Make_plain_with_hashable (T)
 
   module Hash_set = Hash_set.Make_plain_with_hashable (struct
-    module Elt = T.Key
+      module Elt = T.Key
 
-    let hashable = T.hashable
-  end)
+      let hashable = T.hashable
+    end)
 
   module Hash_queue = Hash_queue.Make_with_hashable (T)
 
@@ -79,22 +79,22 @@ end) : S_plain with type t := T.Key.t =
 end
 
 module Make_with_hashable (T : sig
-  module Key : sig
-    type t [@@deriving hash]
+    module Key : sig
+      type t [@@deriving hash]
 
-    include Hashtbl.Key with type t := t
-  end
+      include Hashtbl.Key with type t := t
+    end
 
-  val hashable : Key.t Hashtbl_intf.Hashable.t
-end) : S with type t := T.Key.t = struct
+    val hashable : Key.t Hashtbl_intf.Hashable.t
+  end) : S with type t := T.Key.t = struct
   include T.Key
   module Table = Hashtbl.Make_with_hashable (T)
 
   module Hash_set = Hash_set.Make_with_hashable (struct
-    module Elt = T.Key
+      module Elt = T.Key
 
-    let hashable = T.hashable
-  end)
+      let hashable = T.hashable
+    end)
 
   module Hash_queue = Hash_queue.Make_with_hashable (T)
 
@@ -102,21 +102,21 @@ end) : S with type t := T.Key.t = struct
 end
 
 module Make_binable_with_hashable (T : sig
-  module Key : sig
-    type t [@@deriving hash]
+    module Key : sig
+      type t [@@deriving hash]
 
-    include Hashtbl.Key_binable with type t := t
-  end
+      include Hashtbl.Key_binable with type t := t
+    end
 
-  val hashable : Key.t Hashtbl_intf.Hashable.t
-end) : S_binable with type t := T.Key.t = struct
+    val hashable : Key.t Hashtbl_intf.Hashable.t
+  end) : S_binable with type t := T.Key.t = struct
   module Table = Hashtbl.Make_binable_with_hashable (T)
 
   module Hash_set = Hash_set.Make_binable_with_hashable (struct
-    module Elt = T.Key
+      module Elt = T.Key
 
-    let hashable = T.hashable
-  end)
+      let hashable = T.hashable
+    end)
 
   module Hash_queue = Hash_queue.Make_with_hashable (T)
   include T.Key
@@ -126,10 +126,10 @@ end
 
 module Make_binable_and_derive_hash_fold_t (T : Hashtbl.Key_binable) :
   S_binable with type t := T.t = Make_binable (struct
-  include T
+    include T
 
-  let hash_fold_t state t = hash_fold_int state (hash t)
-end)
+    let hash_fold_t state t = hash_fold_int state (hash t)
+  end)
 
 module Stable = struct
   module V1 = struct
@@ -155,17 +155,17 @@ module Stable = struct
     end
 
     module Make_with_hashable (T : sig
-      module Key : Hashtbl.Key_binable
+        module Key : Hashtbl.Key_binable
 
-      val hashable : Key.t Hashtbl_intf.Hashable.t
-    end) : S with type key := T.Key.t = struct
+        val hashable : Key.t Hashtbl_intf.Hashable.t
+      end) : S with type key := T.Key.t = struct
       module Table = Hashtbl.Make_binable_with_hashable (T)
 
       module Hash_set = Hash_set.Make_binable_with_hashable (struct
-        module Elt = T.Key
+          module Elt = T.Key
 
-        let hashable = T.hashable
-      end)
+          let hashable = T.hashable
+        end)
 
       let hashable = T.hashable
     end
@@ -193,17 +193,17 @@ module Stable = struct
       end
 
       module Make_with_hashable (T : sig
-        module Key : Hashtbl.Key_stable
+          module Key : Hashtbl.Key_stable
 
-        val hashable : Key.t Hashtbl_intf.Hashable.t
-      end) : S with type key := T.Key.t = struct
+          val hashable : Key.t Hashtbl_intf.Hashable.t
+        end) : S with type key := T.Key.t = struct
         module Table = Hashtbl.Make_stable_with_hashable (T)
 
         module Hash_set = Hash_set.Make_stable_with_hashable (struct
-          module Elt = T.Key
+            module Elt = T.Key
 
-          let hashable = T.hashable
-        end)
+            let hashable = T.hashable
+          end)
 
         let hashable = T.hashable
       end
Index: core-0.17.1/core/src/hashable_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/hashable_intf.ml
+++ core-0.17.1/core/src/hashable_intf.ml
@@ -37,57 +37,57 @@ module type Hashable = sig
   module type S_plain = S_plain
 
   module Make_plain (T : sig
-    type t [@@deriving hash]
+      type t [@@deriving hash]
 
-    include Hashtbl.Key_plain with type t := t
-  end) : S_plain with type t := T.t
+      include Hashtbl.Key_plain with type t := t
+    end) : S_plain with type t := T.t
 
   module Make_plain_and_derive_hash_fold_t (T : Hashtbl.Key_plain) :
     S_plain with type t := T.t
 
   module Make (T : sig
-    type t [@@deriving hash]
+      type t [@@deriving hash]
 
-    include Hashtbl.Key with type t := t
-  end) : S with type t := T.t
+      include Hashtbl.Key with type t := t
+    end) : S with type t := T.t
 
   module Make_and_derive_hash_fold_t (T : Hashtbl.Key) : S with type t := T.t
 
   module Make_binable (T : sig
-    type t [@@deriving hash]
+      type t [@@deriving hash]
 
-    include Hashtbl.Key_binable with type t := t
-  end) : S_binable with type t := T.t
+      include Hashtbl.Key_binable with type t := t
+    end) : S_binable with type t := T.t
 
   module Make_plain_with_hashable (T : sig
-    module Key : sig
-      type t [@@deriving hash]
+      module Key : sig
+        type t [@@deriving hash]
 
-      include Hashtbl.Key_plain with type t := t
-    end
+        include Hashtbl.Key_plain with type t := t
+      end
 
-    val hashable : Key.t Hashtbl.Hashable.t
-  end) : S_plain with type t := T.Key.t
+      val hashable : Key.t Hashtbl.Hashable.t
+    end) : S_plain with type t := T.Key.t
 
   module Make_with_hashable (T : sig
-    module Key : sig
-      type t [@@deriving hash]
+      module Key : sig
+        type t [@@deriving hash]
 
-      include Hashtbl.Key with type t := t
-    end
+        include Hashtbl.Key with type t := t
+      end
 
-    val hashable : Key.t Hashtbl.Hashable.t
-  end) : S with type t := T.Key.t
+      val hashable : Key.t Hashtbl.Hashable.t
+    end) : S with type t := T.Key.t
 
   module Make_binable_with_hashable (T : sig
-    module Key : sig
-      type t [@@deriving hash]
+      module Key : sig
+        type t [@@deriving hash]
 
-      include Hashtbl.Key_binable with type t := t
-    end
+        include Hashtbl.Key_binable with type t := t
+      end
 
-    val hashable : Key.t Hashtbl.Hashable.t
-  end) : S_binable with type t := T.Key.t
+      val hashable : Key.t Hashtbl.Hashable.t
+    end) : S_binable with type t := T.Key.t
 
   module Make_binable_and_derive_hash_fold_t (T : Hashtbl.Key_binable) :
     S_binable with type t := T.t
@@ -111,10 +111,10 @@ module type Hashable = sig
       module Make (Key : Hashtbl.Key_binable) : S with type key := Key.t
 
       module Make_with_hashable (T : sig
-        module Key : Hashtbl.Key_binable
+          module Key : Hashtbl.Key_binable
 
-        val hashable : Key.t Hashtbl.Hashable.t
-      end) : S with type key := T.Key.t
+          val hashable : Key.t Hashtbl.Hashable.t
+        end) : S with type key := T.Key.t
 
       module With_stable_witness : sig
         module type S = sig
@@ -134,10 +134,10 @@ module type Hashable = sig
         module Make (Key : Hashtbl.Key_stable) : S with type key := Key.t
 
         module Make_with_hashable (T : sig
-          module Key : Hashtbl.Key_stable
+            module Key : Hashtbl.Key_stable
 
-          val hashable : Key.t Hashtbl.Hashable.t
-        end) : S with type key := T.Key.t
+            val hashable : Key.t Hashtbl.Hashable.t
+          end) : S with type key := T.Key.t
       end
     end
   end
Index: core-0.17.1/core/src/hashtbl.ml
===================================================================
--- core-0.17.1.orig/core/src/hashtbl.ml
+++ core-0.17.1/core/src/hashtbl.ml
@@ -10,11 +10,11 @@ module Creators = Hashtbl.Creators
 
 include (
   Hashtbl :
-    sig
-      type ('a, 'b) t = ('a, 'b) Hashtbl.t [@@deriving sexp_of]
+  sig
+    type ('a, 'b) t = ('a, 'b) Hashtbl.t [@@deriving sexp_of]
 
-      include Base.Hashtbl.S_without_submodules with type ('a, 'b) t := ('a, 'b) t
-    end)
+    include Base.Hashtbl.S_without_submodules with type ('a, 'b) t := ('a, 'b) t
+  end)
 
 let validate ~name f t = Validate.alist ~name f (to_alist t)
 
@@ -99,35 +99,77 @@ module Poly = struct
   let validate = validate
 
   include Bin_prot.Utils.Make_iterable_binable2 (struct
-    type nonrec ('a, 'b) t = ('a, 'b) t
-    type ('a, 'b) el = 'a * 'b [@@deriving bin_io]
+      type nonrec ('a, 'b) t = ('a, 'b) t
+      type ('a, 'b) el = 'a * 'b [@@deriving bin_io]
+
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "8f3e445c-4992-11e6-a279-3703be311e7b"
+      ;;
+
+      let module_name = Some "Core.Hashtbl"
+      let length = length
+
+      let[@inline always] iter t ~f =
+        iteri t ~f:(fun ~key ~data -> f (key, data)) [@nontail]
+      ;;
+
+      let init ~len ~next =
+        let t = create ~size:len () in
+        for _i = 0 to len - 1 do
+          let key, data = next () in
+          match find t key with
+          | None -> set t ~key ~data
+          | Some _ -> failwith "Core_hashtbl.bin_read_t_: duplicate key"
+        done;
+        t
+      ;;
+    end)
+end
+
+module Provide_bin_io (Key : sig
+    type t [@@deriving bin_io]
+
+    include Key_plain with type t := t
+  end) =
+Bin_prot.Utils.Make_iterable_binable1 (struct
+    module Key = Key
+
+    type nonrec 'v t = (Key.t, 'v) t
+    type 'v el = Key.t * 'v [@@deriving bin_io]
 
     let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "8f3e445c-4992-11e6-a279-3703be311e7b"
+      Bin_prot.Shape.Uuid.of_string "8fabab0a-4992-11e6-8cca-9ba2c4686d9e"
     ;;
 
     let module_name = Some "Core.Hashtbl"
     let length = length
-    let iter t ~f = iteri t ~f:(fun ~key ~data -> f (key, data))
+
+    let[@inline always] iter t ~f =
+      iteri t ~f:(fun ~key ~data -> f (key, data)) [@nontail]
+    ;;
 
     let init ~len ~next =
-      let t = create ~size:len () in
+      let t = create ~size:len (module Key) in
       for _i = 0 to len - 1 do
         let key, data = next () in
         match find t key with
         | None -> set t ~key ~data
-        | Some _ -> failwith "Core_hashtbl.bin_read_t_: duplicate key"
+        | Some _ ->
+          failwiths
+            ~here:[%here]
+            "Hashtbl.bin_read_t: duplicate key"
+            key
+            [%sexp_of: Key.t]
       done;
       t
     ;;
   end)
-end
 
 module Make_plain_with_hashable (T : sig
-  module Key : Key_plain
+    module Key : Key_plain
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   let hashable = T.hashable
 
@@ -137,74 +179,45 @@ struct
   type 'a key_ = T.Key.t
 
   include Creators (struct
-    type 'a t = T.Key.t
+      type 'a t = T.Key.t
 
-    let hashable = hashable
-  end)
+      let hashable = hashable
+    end)
 
   include (
     Hashtbl :
-      sig
-        include Invariant.S2 with type ('a, 'b) t := ('a, 'b) hashtbl
-      end)
+    sig
+      include Invariant.S2 with type ('a, 'b) t := ('a, 'b) hashtbl
+    end)
 
   let equal = Hashtbl.equal
   let invariant invariant_key t = invariant ignore invariant_key t
   let sexp_of_t sexp_of_v t = Poly.sexp_of_t T.Key.sexp_of_t sexp_of_v t
 
   module Provide_of_sexp
-    (Key : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := key) =
+      (Key : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := key) =
   struct
     let t_of_sexp v_of_sexp sexp = t_of_sexp Key.t_of_sexp v_of_sexp sexp
   end
 
   module Provide_bin_io
-    (Key' : sig
-      type t [@@deriving bin_io]
-    end
-    with type t := key) =
-  Bin_prot.Utils.Make_iterable_binable1 (struct
-    module Key = struct
+      (Key' : sig
+                type t [@@deriving bin_io]
+              end
+              with type t := T.Key.t) =
+  Provide_bin_io (struct
       include T.Key
       include Key'
-    end
-
-    type nonrec 'a t = 'a t
-    type 'a el = Key.t * 'a [@@deriving bin_io]
-
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "8fabab0a-4992-11e6-8cca-9ba2c4686d9e"
-    ;;
-
-    let module_name = Some "Core.Hashtbl"
-    let length = length
-    let iter t ~f = iteri t ~f:(fun ~key ~data -> f (key, data))
-
-    let init ~len ~next =
-      let t = create ~size:len () in
-      for _i = 0 to len - 1 do
-        let key, data = next () in
-        match find t key with
-        | None -> set t ~key ~data
-        | Some _ ->
-          failwiths
-            ~here:[%here]
-            "Hashtbl.bin_read_t: duplicate key"
-            key
-            [%sexp_of: Key.t]
-      done;
-      t
-    ;;
-  end)
+    end)
 
   module Provide_stable_witness
-    (Key' : sig
-      type t [@@deriving stable_witness]
-    end
-    with type t := key) =
+      (Key' : sig
+                type t [@@deriving stable_witness]
+              end
+              with type t := key) =
   struct
     (* The binary representation of hashtbl is relied on by stable modules
        (e.g. Hashtable.Stable) and is therefore assumed to be stable.  So, if the key and
@@ -220,42 +233,42 @@ struct
 end
 
 module Make_with_hashable (T : sig
-  module Key : Key
+    module Key : Key
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   include Make_plain_with_hashable (T)
   include Provide_of_sexp (T.Key)
 end
 
 module Make_binable_with_hashable (T : sig
-  module Key : Key_binable
+    module Key : Key_binable
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   include Make_with_hashable (T)
   include Provide_bin_io (T.Key)
 end
 
 module Make_stable_with_hashable (T : sig
-  module Key : Key_stable
+    module Key : Key_stable
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   include Make_binable_with_hashable (T)
   include Provide_stable_witness (T.Key)
 end
 
 module Make_plain (Key : Key_plain) = Make_plain_with_hashable (struct
-  module Key = Key
+    module Key = Key
 
-  let hashable =
-    { Hashable.hash = Key.hash; compare = Key.compare; sexp_of_t = Key.sexp_of_t }
-  ;;
-end)
+    let hashable =
+      { Hashable.hash = Key.hash; compare = Key.compare; sexp_of_t = Key.sexp_of_t }
+    ;;
+  end)
 
 module Make (Key : Key) = struct
   include Make_plain (Key)
@@ -310,6 +323,31 @@ module For_deriving : For_deriving with
          ~f:(of_alist_option (module Key))
          ~f_inverse:to_alist
   ;;
+
+  let bin_shape_m__t (type t) (module Key : Key_binable with type t = t) =
+    let module M = Provide_bin_io (Key) in
+    M.bin_shape_t
+  ;;
+
+  let bin_size_m__t (type t) (module Key : Key_binable with type t = t) =
+    let module M = Provide_bin_io (Key) in
+    M.bin_size_t
+  ;;
+
+  let bin_write_m__t (type t) (module Key : Key_binable with type t = t) =
+    let module M = Provide_bin_io (Key) in
+    M.bin_write_t
+  ;;
+
+  let bin_read_m__t (type t) (module Key : Key_binable with type t = t) =
+    let module M = Provide_bin_io (Key) in
+    M.bin_read_t
+  ;;
+
+  let __bin_read_m__t__ (type t) (module Key : Key_binable with type t = t) =
+    let module M = Provide_bin_io (Key) in
+    M.__bin_read_t__
+  ;;
 end
 
 include For_deriving
Index: core-0.17.1/core/src/hashtbl_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/hashtbl_intf.ml
+++ core-0.17.1/core/src/hashtbl_intf.ml
@@ -164,6 +164,31 @@ module type For_deriving = sig
     :  (module M_quickcheck with type t = 'k)
     -> 'v Quickcheck.Shrinker.t
     -> ('k, 'v) t Quickcheck.Shrinker.t
+
+  val bin_shape_m__t
+    :  (module Key_binable with type t = 'k)
+    -> Bin_prot.Shape.t
+    -> Bin_prot.Shape.t
+
+  val bin_size_m__t
+    :  (module Key_binable with type t = 'k)
+    -> 'v Bin_prot.Size.sizer
+    -> ('k, 'v) t Bin_prot.Size.sizer
+
+  val bin_write_m__t
+    :  (module Key_binable with type t = 'k)
+    -> 'v Bin_prot.Write.writer
+    -> ('k, 'v) t Bin_prot.Write.writer
+
+  val bin_read_m__t
+    :  (module Key_binable with type t = 'k)
+    -> 'v Bin_prot.Read.reader
+    -> ('k, 'v) t Bin_prot.Read.reader
+
+  val __bin_read_m__t__
+    :  (module Key_binable with type t = 'k)
+    -> 'v Bin_prot.Read.reader
+    -> ('k, 'v) t Bin_prot.Read.vtag_reader
 end
 
 module type S_plain = sig
@@ -179,28 +204,28 @@ module type S_plain = sig
 
   include
     Creators
-      with type ('a, 'b) t := ('a, 'b) t_
-      with type 'a key := 'a key_
-      with type ('key, 'data, 'z) create_options :=
-        ('key, 'data, 'z) create_options_without_hashable
+    with type ('a, 'b) t := ('a, 'b) t_
+    with type 'a key := 'a key_
+    with type ('key, 'data, 'z) create_options :=
+      ('key, 'data, 'z) create_options_without_hashable
 
   module Provide_of_sexp
-    (Key : sig
-      type t [@@deriving of_sexp]
+      (Key : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := key) : sig
+      type _ t [@@deriving of_sexp]
     end
-    with type t := key) : sig
-    type _ t [@@deriving of_sexp]
-  end
-  with type 'a t := 'a t
+    with type 'a t := 'a t
 
   module Provide_bin_io
-    (Key : sig
-      type t [@@deriving bin_io]
+      (Key : sig
+               type t [@@deriving bin_io]
+             end
+             with type t := key) : sig
+      type 'a t [@@deriving bin_io]
     end
-    with type t := key) : sig
-    type 'a t [@@deriving bin_io]
-  end
-  with type 'a t := 'a t
+    with type 'a t := 'a t
 end
 
 module type S = sig
@@ -231,9 +256,9 @@ module type Hashtbl = sig
   module Using_hashable : sig
     include
       Creators
-        with type ('a, 'b) t := ('a, 'b) t
-        with type 'a key := 'a key
-        with type ('a, 'b, 'z) create_options := ('a, 'b, 'z) create_options_with_hashable
+      with type ('a, 'b) t := ('a, 'b) t
+      with type 'a key := 'a key
+      with type ('a, 'b, 'z) create_options := ('a, 'b, 'z) create_options_with_hashable
   end
 
   module Poly : sig
@@ -262,28 +287,28 @@ module type Hashtbl = sig
   module Make_stable (Key : Key_stable) : S_stable with type key = Key.t
 
   module Make_plain_with_hashable (T : sig
-    module Key : Key_plain
+      module Key : Key_plain
 
-    val hashable : Key.t Hashable.t
-  end) : S_plain with type key = T.Key.t
+      val hashable : Key.t Hashable.t
+    end) : S_plain with type key = T.Key.t
 
   module Make_with_hashable (T : sig
-    module Key : Key
+      module Key : Key
 
-    val hashable : Key.t Hashable.t
-  end) : S with type key = T.Key.t
+      val hashable : Key.t Hashable.t
+    end) : S with type key = T.Key.t
 
   module Make_binable_with_hashable (T : sig
-    module Key : Key_binable
+      module Key : Key_binable
 
-    val hashable : Key.t Hashable.t
-  end) : S_binable with type key = T.Key.t
+      val hashable : Key.t Hashable.t
+    end) : S_binable with type key = T.Key.t
 
   module Make_stable_with_hashable (T : sig
-    module Key : Key_stable
+      module Key : Key_stable
 
-    val hashable : Key.t Hashable.t
-  end) : S_stable with type key = T.Key.t
+      val hashable : Key.t Hashable.t
+    end) : S_stable with type key = T.Key.t
 
   module M (K : T.T) : sig
     type nonrec 'v t = (K.t, 'v) t
Index: core-0.17.1/core/src/hexdump.ml
===================================================================
--- core-0.17.1.orig/core/src/hexdump.ml
+++ core-0.17.1/core/src/hexdump.ml
@@ -116,11 +116,11 @@ end
 
 module Of_indexable1 (T : Indexable1) = struct
   module M = Of_indexable2 (struct
-    type ('a, _) t = 'a T.t
+      type ('a, _) t = 'a T.t
 
-    let length = T.length
-    let get = T.get
-  end)
+      let length = T.length
+      let get = T.get
+    end)
 
   module Hexdump = struct
     include T
@@ -139,11 +139,11 @@ end
 
 module Of_indexable (T : Indexable) = struct
   module M = Of_indexable1 (struct
-    type _ t = T.t
+      type _ t = T.t
 
-    let length = T.length
-    let get = T.get
-  end)
+      let length = T.length
+      let get = T.get
+    end)
 
   module Hexdump = struct
     include T
Index: core-0.17.1/core/src/host_and_port.ml
===================================================================
--- core-0.17.1.orig/core/src/host_and_port.ml
+++ core-0.17.1/core/src/host_and_port.ml
@@ -123,11 +123,11 @@ module Latest = struct
   include T
 
   include Pretty_printer.Register (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    let to_string = to_string
-    let module_name = "Core.Host_and_port"
-  end)
+      let to_string = to_string
+      let module_name = "Core.Host_and_port"
+    end)
 
   include (Hashable.Make_binable (T) : Hashable.S_binable with type t := t)
   include Comparable.Make_binable_using_comparator (T)
Index: core-0.17.1/core/src/host_and_port.mli
===================================================================
--- core-0.17.1.orig/core/src/host_and_port.mli
+++ core-0.17.1/core/src/host_and_port.mli
@@ -17,7 +17,7 @@ include Identifiable with type t := t
 include Sexplib.Sexp_grammar.S with type t := t
 
 module Hide_port_in_test : sig
-  include Identifiable with type t := t and type comparator_witness = comparator_witness
+  include Identifiable with type t = t and type comparator_witness = comparator_witness
 end
 
 module Stable : sig
@@ -29,8 +29,8 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
   end
 end
 
Index: core-0.17.1/core/src/identifiable.ml
===================================================================
--- core-0.17.1.orig/core/src/identifiable.ml
+++ core-0.17.1/core/src/identifiable.ml
@@ -3,12 +3,12 @@ include Identifiable_intf
 module Binable = Binable0
 
 module Make_plain (T : sig
-  type t [@@deriving compare, hash, sexp_of]
+    type t [@@deriving compare, hash, sexp_of]
 
-  include Stringable.S with type t := t
+    include Stringable.S with type t := t
 
-  val module_name : string
-end) =
+    val module_name : string
+  end) =
 struct
   include T
   include Comparable.Make_plain (T)
@@ -17,12 +17,12 @@ struct
 end
 
 module Make (T : sig
-  type t [@@deriving bin_io, compare, hash, sexp]
+    type t [@@deriving bin_io, compare, hash, sexp]
 
-  include Stringable.S with type t := t
+    include Stringable.S with type t := t
 
-  val module_name : string
-end) =
+    val module_name : string
+  end) =
 struct
   include T
   include Comparable.Make_binable (T)
@@ -31,39 +31,39 @@ struct
 end
 
 module Make_with_sexp_grammar (T : sig
-  type t [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
+    type t [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
 
-  include Stringable.S with type t := t
+    include Stringable.S with type t := t
 
-  val module_name : string
-end) =
+    val module_name : string
+  end) =
 struct
   include T
   include Make (T)
 end
 
 module Make_and_derive_hash_fold_t (T : sig
-  type t [@@deriving bin_io, compare, sexp]
+    type t [@@deriving bin_io, compare, sexp]
 
-  include Stringable.S with type t := t
+    include Stringable.S with type t := t
 
-  val hash : t -> int
-  val module_name : string
-end) =
+    val hash : t -> int
+    val module_name : string
+  end) =
 Make (struct
-  include T
+    include T
 
-  let hash_fold_t state t = hash_fold_int state (hash t)
-end)
+    let hash_fold_t state t = hash_fold_int state (hash t)
+  end)
 
 module Make_using_comparator (T : sig
-  type t [@@deriving bin_io, compare, hash, sexp]
+    type t [@@deriving bin_io, compare, hash, sexp]
 
-  include Comparator.S with type t := t
-  include Stringable.S with type t := t
+    include Comparator.S with type t := t
+    include Stringable.S with type t := t
 
-  val module_name : string
-end) =
+    val module_name : string
+  end) =
 struct
   include T
   include Comparable.Make_binable_using_comparator (T)
@@ -72,13 +72,13 @@ struct
 end
 
 module Make_plain_using_comparator (T : sig
-  type t [@@deriving compare, hash, sexp_of]
+    type t [@@deriving compare, hash, sexp_of]
 
-  include Comparator.S with type t := t
-  include Stringable.S with type t := t
+    include Comparator.S with type t := t
+    include Stringable.S with type t := t
 
-  val module_name : string
-end) =
+    val module_name : string
+  end) =
 struct
   include T
   include Comparable.Make_plain_using_comparator (T)
@@ -87,19 +87,19 @@ struct
 end
 
 module Make_using_comparator_and_derive_hash_fold_t (T : sig
-  type t [@@deriving bin_io, compare, sexp]
+    type t [@@deriving bin_io, compare, sexp]
 
-  include Comparator.S with type t := t
-  include Stringable.S with type t := t
+    include Comparator.S with type t := t
+    include Stringable.S with type t := t
 
-  val hash : t -> int
-  val module_name : string
-end) =
+    val hash : t -> int
+    val module_name : string
+  end) =
 Make_using_comparator (struct
-  include T
+    include T
 
-  let hash_fold_t state t = hash_fold_int state (hash t)
-end)
+    let hash_fold_t state t = hash_fold_int state (hash t)
+  end)
 
 module Extend (M : Base.Identifiable.S) (B : Binable0.S with type t = M.t) = struct
   module T = struct
@@ -111,8 +111,8 @@ module Extend (M : Base.Identifiable.S)
   include Comparable.Extend_binable (M) (T)
 
   include Hashable.Make_binable_with_hashable (struct
-    module Key = T
+      module Key = T
 
-    let hashable = M.hashable
-  end)
+      let hashable = M.hashable
+    end)
 end
Index: core-0.17.1/core/src/identifiable_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/identifiable_intf.ml
+++ core-0.17.1/core/src/identifiable_intf.ml
@@ -45,13 +45,13 @@ module type Identifiable = sig
   module type S_sexp_grammar = S_sexp_grammar
 
   module Make_plain (M : sig
-    type t [@@deriving compare, hash, sexp_of]
+      type t [@@deriving compare, hash, sexp_of]
 
-    include Stringable.S with type t := t
+      include Stringable.S with type t := t
 
-    (** for registering the pretty printer *)
-    val module_name : string
-  end) : S_plain with type t := M.t
+      (** for registering the pretty printer *)
+      val module_name : string
+    end) : S_plain with type t := M.t
 
   (** Used for making an Identifiable module. Here's an example:
 
@@ -68,62 +68,62 @@ module type Identifiable = sig
       ]}
   *)
   module Make (M : sig
-    type t [@@deriving bin_io, compare, hash, sexp]
+      type t [@@deriving bin_io, compare, hash, sexp]
 
-    include Stringable.S with type t := t
+      include Stringable.S with type t := t
 
-    (** for registering the pretty printer *)
-    val module_name : string
-  end) : S with type t := M.t
+      (** for registering the pretty printer *)
+      val module_name : string
+    end) : S with type t := M.t
 
   module Make_with_sexp_grammar (M : sig
-    type t [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
+      type t [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
 
-    include Stringable.S with type t := t
+      include Stringable.S with type t := t
 
-    (** for registering the pretty printer *)
-    val module_name : string
-  end) : S_sexp_grammar with type t := M.t
+      (** for registering the pretty printer *)
+      val module_name : string
+    end) : S_sexp_grammar with type t := M.t
 
   module Make_and_derive_hash_fold_t (M : sig
-    type t [@@deriving bin_io, compare, sexp]
+      type t [@@deriving bin_io, compare, sexp]
 
-    include Stringable.S with type t := t
+      include Stringable.S with type t := t
 
-    val hash : t -> int
+      val hash : t -> int
 
-    (** for registering the pretty printer *)
-    val module_name : string
-  end) : S with type t := M.t
+      (** for registering the pretty printer *)
+      val module_name : string
+    end) : S with type t := M.t
 
   module Make_using_comparator (M : sig
-    type t [@@deriving bin_io, compare, hash, sexp]
+      type t [@@deriving bin_io, compare, hash, sexp]
 
-    include Comparator.S with type t := t
-    include Stringable.S with type t := t
+      include Comparator.S with type t := t
+      include Stringable.S with type t := t
 
-    val module_name : string
-  end) : S with type t := M.t with type comparator_witness := M.comparator_witness
+      val module_name : string
+    end) : S with type t := M.t with type comparator_witness := M.comparator_witness
 
   module Make_plain_using_comparator (M : sig
-    type t [@@deriving compare, hash, sexp_of]
+      type t [@@deriving compare, hash, sexp_of]
 
-    include Comparator.S with type t := t
-    include Stringable.S with type t := t
+      include Comparator.S with type t := t
+      include Stringable.S with type t := t
 
-    (** for registering the pretty printer *)
-    val module_name : string
-  end) : S_plain with type t := M.t with type comparator_witness := M.comparator_witness
+      (** for registering the pretty printer *)
+      val module_name : string
+    end) : S_plain with type t := M.t with type comparator_witness := M.comparator_witness
 
   module Make_using_comparator_and_derive_hash_fold_t (M : sig
-    type t [@@deriving bin_io, compare, sexp]
+      type t [@@deriving bin_io, compare, sexp]
 
-    include Comparator.S with type t := t
-    include Stringable.S with type t := t
+      include Comparator.S with type t := t
+      include Stringable.S with type t := t
 
-    val hash : t -> int
-    val module_name : string
-  end) : S with type t := M.t with type comparator_witness := M.comparator_witness
+      val hash : t -> int
+      val module_name : string
+    end) : S with type t := M.t with type comparator_witness := M.comparator_witness
 
   module Extend (M : Base.Identifiable.S) (B : Binable0.S with type t = M.t) :
     S with type t := M.t with type comparator_witness := M.comparator_witness
Index: core-0.17.1/core/src/immediate_option_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/immediate_option_intf.ml
+++ core-0.17.1/core/src/immediate_option_intf.ml
@@ -59,6 +59,25 @@ module type S_without_immediate = sig
   include S_without_immediate_plain with type t := t
 end
 
+module type S_without_immediate_zero_alloc = sig
+  type value
+  type t [@@deriving compare, hash, sexp_of, typerep]
+
+  val none : t
+  val some : value -> t [@@zero_alloc]
+  val some_is_representable : value -> bool [@@zero_alloc]
+  val is_none : t -> bool [@@zero_alloc]
+  val is_some : t -> bool [@@zero_alloc]
+  val value : t -> default:value -> value [@@zero_alloc]
+  val value_exn : t -> value [@@zero_alloc]
+  val unchecked_value : t -> value [@@zero_alloc]
+  val to_option : t -> value option
+  val of_option : value option -> t [@@zero_alloc]
+
+  module Optional_syntax :
+    Optional_syntax.S_zero_alloc with type t := t with type value := value
+end
+
 module type S_plain = sig
   type t [@@immediate]
 
@@ -71,31 +90,46 @@ module type S = sig
   include S_without_immediate with type t := t
 end
 
+module type S_zero_alloc = sig
+  type t [@@immediate]
+
+  include S_without_immediate_zero_alloc with type t := t
+end
+
+module type S_int63_plain = sig
+  type t [@@immediate64]
+
+  include S_without_immediate_plain with type t := t
+end
+
 module type S_int63 = sig
   type t [@@immediate64]
 
   include S_without_immediate with type t := t
 end
 
-module type S_int63_plain = sig
+module type S_int63_zero_alloc = sig
   type t [@@immediate64]
 
-  include S_without_immediate_plain with type t := t
+  include S_without_immediate_zero_alloc with type t := t
 end
 
 module type Immediate_option = sig
   (** Always immediate. *)
-  module type S = S
 
+  module type S = S
   module type S_plain = S_plain
+  module type S_zero_alloc = S_zero_alloc
 
   (** Immediate only on 64-bit machines. *)
-  module type S_int63 = S_int63
 
+  module type S_int63 = S_int63
   module type S_int63_plain = S_int63_plain
+  module type S_int63_zero_alloc = S_int63_zero_alloc
 
   (** Never immediate. *)
-  module type S_without_immediate = S_without_immediate
 
+  module type S_without_immediate = S_without_immediate
   module type S_without_immediate_plain = S_without_immediate_plain
+  module type S_without_immediate_zero_alloc = S_without_immediate_zero_alloc
 end
Index: core-0.17.1/core/src/import.ml
===================================================================
--- core-0.17.1.orig/core/src/import.ml
+++ core-0.17.1/core/src/import.ml
@@ -64,13 +64,13 @@ include From_sexplib
    other ppx's treat [sexp_opaque] correctly, by ignoring it and processing the underlying
    type. *)
 include (
-  struct
-    type 'a sexp_opaque = 'a [@@deriving bin_io, compare, hash, typerep]
-  end :
-    sig
-      type 'a sexp_opaque [@@deriving bin_io, compare, hash, typerep]
-    end
-    with type 'a sexp_opaque := 'a)
+struct
+  type 'a sexp_opaque = 'a [@@deriving bin_io, compare, hash, typerep]
+end :
+  sig
+    type 'a sexp_opaque [@@deriving bin_io, compare, hash, typerep]
+  end
+  with type 'a sexp_opaque := 'a)
 
 include (
   Typerep_lib.Std :
Index: core-0.17.1/core/src/info.ml
===================================================================
--- core-0.17.1.orig/core/src/info.ml
+++ core-0.17.1/core/src/info.ml
@@ -14,16 +14,16 @@ module Sexp = struct
   include Sexplib.Sexp
 
   include (
-    struct
-      type t = Base.Sexp.t =
-        | Atom of string
-        | List of t list
-      [@@deriving bin_io, compare, hash, stable_witness]
-    end :
-      sig
-        type t [@@deriving bin_io, compare, hash, stable_witness]
-      end
-      with type t := t)
+  struct
+    type t = Base.Sexp.t =
+      | Atom of string
+      | List of t list
+    [@@deriving bin_io, compare, hash, stable_witness]
+  end :
+    sig
+      type t [@@deriving bin_io, compare, hash, stable_witness]
+    end
+    with type t := t)
 end
 
 module Binable_exn = struct
@@ -124,8 +124,8 @@ module Extend (Info : Base.Info.S) = str
       ;;
 
       include Diffable.Atomic.Make (struct
-        type nonrec t = t [@@deriving sexp, bin_io, equal]
-      end)
+          type nonrec t = t [@@deriving sexp, bin_io, equal]
+        end)
     end
 
     module V1 = struct
Index: core-0.17.1/core/src/int.mli
===================================================================
--- core-0.17.1.orig/core/src/int.mli
+++ core-0.17.1/core/src/int.mli
@@ -2,7 +2,7 @@
 
 include
   Base.Int.Int_without_module_types
-    with type comparator_witness = Base.Int.comparator_witness
+  with type comparator_witness = Base.Int.comparator_witness
 (** @inline *)
 
 (** Note that [int] is already stable by itself, since as a primitive type it is an
@@ -12,8 +12,8 @@ include
 
 include
   Int_intf.Extension_with_stable
-    with type t := t
-     and type comparator_witness := comparator_witness
+  with type t := t
+   and type comparator_witness := comparator_witness
 
 include sig
   type nonrec t = t [@@deriving bin_io ~localize]
Index: core-0.17.1/core/src/int63.ml
===================================================================
--- core-0.17.1.orig/core/src/int63.ml
+++ core-0.17.1/core/src/int63.ml
@@ -39,8 +39,8 @@ module Stable = struct
       include (
         Base.Int63 :
           Base.Comparable.S
-            with type t := t
-            with type comparator_witness = Base.Int63.comparator_witness)
+          with type t := t
+          with type comparator_witness = Base.Int63.comparator_witness)
 
       (* This serialization is stable, since it either delegates to [int] or
          [Int63_emul]. *)
Index: core-0.17.1/core/src/int63.mli
===================================================================
--- core-0.17.1.orig/core/src/int63.mli
+++ core-0.17.1/core/src/int63.mli
@@ -15,11 +15,11 @@ include
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@immediate64] [@@deriving equal, hash, sexp_grammar]
+    type nonrec t = t [@@deriving equal, hash, sexp_grammar] [@@immediate64]
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
   end
 end
Index: core-0.17.1/core/src/int_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/int_intf.ml
+++ core-0.17.1/core/src/int_intf.ml
@@ -14,10 +14,9 @@ module type Binaryable = sig
   type t
 
   module Binary : sig
-    type nonrec t = t [@@deriving bin_io, sexp_of, compare ~localize, hash, typerep]
+    type nonrec t = t [@@deriving bin_io, typerep]
 
-    val to_string : t -> string
-    val to_string_hum : ?delimiter:char -> t -> string
+    include Base.Int.To_string_format with type t := t
   end
 
   (*_ Ensure that this module is an extension of [Base.Int.Binary]. *)
@@ -28,12 +27,9 @@ module type Hexable = sig
   type t
 
   module Hex : sig
-    type nonrec t = t
-    [@@deriving bin_io, sexp, sexp_grammar, compare ~localize, hash, typerep]
+    type nonrec t = t [@@deriving bin_io, typerep]
 
-    include Base.Stringable.S with type t := t
-
-    val to_string_hum : ?delimiter:char -> t -> string
+    include Base.Int.String_format with type t := t
   end
 
   (*_ Ensure that this module is an extension of [Base.Int.Hexable]. *)
Index: core-0.17.1/core/src/interfaces.ml
===================================================================
--- core-0.17.1.orig/core/src/interfaces.ml
+++ core-0.17.1/core/src/interfaces.ml
@@ -18,6 +18,7 @@ module type Robustly_comparable = Robust
 module type Sexpable = Sexpable.S
 module type Stable = Stable_module_types.S0
 module type Stable_int63able = Stable_int63able.S
+module type Stable_int63able_without_comparator = Stable_int63able.Without_comparator.S
 module type Stable_without_comparator = Stable_module_types.S0_without_comparator
 module type Stable1 = Stable_module_types.S1
 module type Stable2 = Stable_module_types.S2
Index: core-0.17.1/core/src/linked_queue.ml
===================================================================
--- core-0.17.1.orig/core/src/linked_queue.ml
+++ core-0.17.1/core/src/linked_queue.ml
@@ -3,25 +3,35 @@ module Queue = Base.Linked_queue
 include Queue
 
 include Bin_prot.Utils.Make_iterable_binable1 (struct
-  type 'a t = 'a Queue.t
-  type 'a el = 'a [@@deriving bin_io]
+    type 'a t = 'a Queue.t
+    type 'a el = 'a [@@deriving bin_io]
 
-  let caller_identity =
-    Bin_prot.Shape.Uuid.of_string "800df9a0-4992-11e6-881d-ffe1a5c8aced"
-  ;;
-
-  let module_name = Some "Core.Linked_queue"
-  let length = length
-  let iter = iter
+    let caller_identity =
+      Bin_prot.Shape.Uuid.of_string "800df9a0-4992-11e6-881d-ffe1a5c8aced"
+    ;;
 
-  (* Bin_prot reads the elements in the same order they were written out, as determined
+    let module_name = Some "Core.Linked_queue"
+    let length = length
+    let iter = iter
+
+    (* Bin_prot reads the elements in the same order they were written out, as determined
        by [iter].  So, we can ignore the index and just enqueue each element as it is read
        in. *)
-  let init ~len ~next =
-    let t = create () in
-    for _ = 1 to len do
-      enqueue t (next ())
-    done;
-    t
-  ;;
-end)
+    let init ~len ~next =
+      let t = create () in
+      for _ = 1 to len do
+        enqueue t (next ())
+      done;
+      t
+    ;;
+  end)
+
+include
+  Quickcheckable.Of_quickcheckable1
+    (List)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_list
+      let of_quickcheckable = of_list
+    end)
Index: core-0.17.1/core/src/linked_queue.mli
===================================================================
--- core-0.17.1.orig/core/src/linked_queue.mli
+++ core-0.17.1/core/src/linked_queue.mli
@@ -4,7 +4,7 @@
 
     See also {!Core.Queue}, which has different performance characteristics. *)
 
-type 'a t = 'a Base.Linked_queue.t [@@deriving bin_io]
+type 'a t = 'a Base.Linked_queue.t [@@deriving bin_io, quickcheck]
 
 (** @inline *)
 include module type of struct
Index: core-0.17.1/core/src/list.mli
===================================================================
--- core-0.17.1.orig/core/src/list.mli
+++ core-0.17.1/core/src/list.mli
@@ -15,9 +15,9 @@ module Assoc : sig
   type ('a, 'b) t = ('a, 'b) Base.List.Assoc.t [@@deriving bin_io ~localize]
 
   val compare : [%compare: 'a] -> [%compare: 'b] -> [%compare: ('a, 'b) t]
-    [@@deprecated
-      "[since 2016-06] This does not respect the equivalence class promised by List.Assoc.\n\
-       Use List.compare directly if that's what you want."]
+  [@@deprecated
+    "[since 2016-06] This does not respect the equivalence class promised by List.Assoc.\n\
+     Use List.compare directly if that's what you want."]
 
   include module type of struct
       include Base.List.Assoc
@@ -35,7 +35,7 @@ end
     function and lets you avoid the functor instantiation when you already have such a
     module on hand. *)
 val stable_dedup_staged : compare:('a -> 'a -> int) -> ('a list -> 'a list) Staged.t
-  [@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
+[@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
 
 (** Only raised in [exn_if_dup] below. *)
 exception
Index: core-0.17.1/core/src/list0.ml
===================================================================
--- core-0.17.1.orig/core/src/list0.ml
+++ core-0.17.1/core/src/list0.ml
@@ -17,8 +17,8 @@ let to_string ~f t =
 ;;
 
 include Comparator.Derived (struct
-  type nonrec 'a t = 'a t [@@deriving sexp_of, compare]
-end)
+    type nonrec 'a t = 'a t [@@deriving sexp_of, compare]
+  end)
 
 let quickcheck_generator = Base_quickcheck.Generator.list
 let gen_non_empty = Base_quickcheck.Generator.list_non_empty
Index: core-0.17.1/core/src/list0.mli
===================================================================
--- core-0.17.1.orig/core/src/list0.mli
+++ core-0.17.1/core/src/list0.mli
@@ -10,9 +10,9 @@ include Comparator.Derived with type 'a
 include Quickcheckable.S1 with type 'a t := 'a t
 
 val stable_witness : 'a Stable_witness.t -> 'a t Stable_witness.t
-  [@@alert
-    for_internal_use_only
-      "[Core.List0.stable_witness] is only exported for use in [Core.List.Stable]"]
+[@@alert
+  for_internal_use_only
+    "[Core.List0.stable_witness] is only exported for use in [Core.List.Stable]"]
 
 val to_string : f:('a -> string) -> 'a t -> string
 val gen_non_empty : 'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
@@ -28,7 +28,7 @@ module Assoc : sig
   type ('a, 'b) t = ('a, 'b) Base.List.Assoc.t [@@deriving bin_io ~localize]
 
   val compare : ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
-    [@@deprecated
-      "[since 2016-06] This does not respect the equivalence class promised by \
-       List.Assoc. Use List.compare directly if that's what you want."]
+  [@@deprecated
+    "[since 2016-06] This does not respect the equivalence class promised by List.Assoc. \
+     Use List.compare directly if that's what you want."]
 end
Index: core-0.17.1/core/src/make_stable.ml
===================================================================
--- core-0.17.1.orig/core/src/make_stable.ml
+++ core-0.17.1/core/src/make_stable.ml
@@ -4,14 +4,16 @@ module Comparator = Comparator.Stable
 module Sexpable = Sexpable.Stable
 
 module Of_stable_format = struct
-  module V1 (Stable_format : sig
-    type t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type t [@@deriving compare]
-
-    val to_stable_format : t -> Stable_format.t
-    val of_stable_format : Stable_format.t -> t
-  end) : S0 with type t = M.t = struct
+  module V1
+      (Stable_format : sig
+         type t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type t [@@deriving compare]
+
+         val to_stable_format : t -> Stable_format.t
+         val of_stable_format : Stable_format.t -> t
+       end) : S0 with type t = M.t = struct
     module T1 = struct
       module T2 = struct
         include M
@@ -31,15 +33,17 @@ module Of_stable_format = struct
     include Comparator.V1.Make (T1)
   end
 
-  module V2 (Stable_format : sig
-    type t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type t [@@deriving compare]
-
-    val to_stable_format : t -> Stable_format.t
-    val of_stable_format : Stable_format.t -> t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S0 with type t = M.t = struct
+  module V2
+      (Stable_format : sig
+         type t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type t [@@deriving compare]
+
+         val to_stable_format : t -> Stable_format.t
+         val of_stable_format : Stable_format.t -> t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S0 with type t = M.t = struct
     module T1 = struct
       module T2 = struct
         include M
@@ -61,15 +65,17 @@ module Of_stable_format = struct
 end
 
 module Of_stable_format1 = struct
-  module V1 (Stable_format : sig
-    type 'a t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type 'a t [@@deriving compare]
-
-    val map : 'a t -> f:('a -> 'b) -> 'b t
-    val to_stable_format : 'a t -> 'a Stable_format.t
-    val of_stable_format : 'a Stable_format.t -> 'a t
-  end) : S1 with type 'a t = 'a M.t = struct
+  module V1
+      (Stable_format : sig
+         type 'a t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type 'a t [@@deriving compare]
+
+         val map : 'a t -> f:('a -> 'b) -> 'b t
+         val to_stable_format : 'a t -> 'a Stable_format.t
+         val of_stable_format : 'a Stable_format.t -> 'a t
+       end) : S1 with type 'a t = 'a M.t = struct
     module T = struct
       include M
 
@@ -84,16 +90,18 @@ module Of_stable_format1 = struct
     include Binable.Of_binable1.V1 [@alert "-legacy"] (Stable_format) (T)
   end
 
-  module V2 (Stable_format : sig
-    type 'a t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type 'a t [@@deriving compare]
-
-    val map : 'a t -> f:('a -> 'b) -> 'b t
-    val to_stable_format : 'a t -> 'a Stable_format.t
-    val of_stable_format : 'a Stable_format.t -> 'a t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S1 with type 'a t = 'a M.t = struct
+  module V2
+      (Stable_format : sig
+         type 'a t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type 'a t [@@deriving compare]
+
+         val map : 'a t -> f:('a -> 'b) -> 'b t
+         val to_stable_format : 'a t -> 'a Stable_format.t
+         val of_stable_format : 'a Stable_format.t -> 'a t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S1 with type 'a t = 'a M.t = struct
     module T = struct
       include M
 
@@ -110,15 +118,17 @@ module Of_stable_format1 = struct
 end
 
 module Of_stable_format2 = struct
-  module V1 (Stable_format : sig
-    type ('a1, 'a2) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2) t [@@deriving compare]
-
-    val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-    val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-    val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-  end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
+  module V1
+      (Stable_format : sig
+         type ('a1, 'a2) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2) t [@@deriving compare]
+
+         val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+         val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+         val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+       end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
     module T = struct
       include M
 
@@ -133,16 +143,18 @@ module Of_stable_format2 = struct
     include Binable.Of_binable2.V1 [@alert "-legacy"] (Stable_format) (T)
   end
 
-  module V2 (Stable_format : sig
-    type ('a1, 'a2) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2) t [@@deriving compare]
-
-    val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-    val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-    val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
+  module V2
+      (Stable_format : sig
+         type ('a1, 'a2) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2) t [@@deriving compare]
+
+         val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+         val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+         val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
     module T = struct
       include M
 
@@ -159,21 +171,23 @@ module Of_stable_format2 = struct
 end
 
 module Of_stable_format3 = struct
-  module V1 (Stable_format : sig
-    type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-    val map
-      :  ('a1, 'a2, 'a3) t
-      -> f1:('a1 -> 'b1)
-      -> f2:('a2 -> 'b2)
-      -> f3:('a3 -> 'b3)
-      -> ('b1, 'b2, 'b3) t
-
-    val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-    val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-  end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t = struct
+  module V1
+      (Stable_format : sig
+         type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+         val map
+           :  ('a1, 'a2, 'a3) t
+           -> f1:('a1 -> 'b1)
+           -> f2:('a2 -> 'b2)
+           -> f3:('a3 -> 'b3)
+           -> ('b1, 'b2, 'b3) t
+
+         val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+         val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+       end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t = struct
     module T = struct
       include M
 
@@ -188,22 +202,24 @@ module Of_stable_format3 = struct
     include Binable.Of_binable3.V1 [@alert "-legacy"] (Stable_format) (T)
   end
 
-  module V2 (Stable_format : sig
-    type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-    val map
-      :  ('a1, 'a2, 'a3) t
-      -> f1:('a1 -> 'b1)
-      -> f2:('a2 -> 'b2)
-      -> f3:('a3 -> 'b3)
-      -> ('b1, 'b2, 'b3) t
-
-    val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-    val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t = struct
+  module V2
+      (Stable_format : sig
+         type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+         val map
+           :  ('a1, 'a2, 'a3) t
+           -> f1:('a1 -> 'b1)
+           -> f2:('a2 -> 'b2)
+           -> f3:('a3 -> 'b3)
+           -> ('b1, 'b2, 'b3) t
+
+         val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+         val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t = struct
     module T = struct
       include M
 
@@ -221,14 +237,16 @@ end
 
 module With_stable_witness = struct
   module Of_stable_format = struct
-    module V1 (Stable_format : sig
-      type t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type t [@@deriving compare]
-
-      val to_stable_format : t -> Stable_format.t
-      val of_stable_format : Stable_format.t -> t
-    end) : With_stable_witness.S0 with type t = M.t = struct
+    module V1
+        (Stable_format : sig
+           type t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type t [@@deriving compare]
+
+           val to_stable_format : t -> Stable_format.t
+           val of_stable_format : Stable_format.t -> t
+         end) : With_stable_witness.S0 with type t = M.t = struct
       include Of_stable_format.V1 (Stable_format) (M)
 
       let stable_witness =
@@ -239,15 +257,17 @@ module With_stable_witness = struct
       ;;
     end
 
-    module V2 (Stable_format : sig
-      type t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type t [@@deriving compare]
-
-      val to_stable_format : t -> Stable_format.t
-      val of_stable_format : Stable_format.t -> t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S0 with type t = M.t = struct
+    module V2
+        (Stable_format : sig
+           type t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type t [@@deriving compare]
+
+           val to_stable_format : t -> Stable_format.t
+           val of_stable_format : Stable_format.t -> t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S0 with type t = M.t = struct
       include Of_stable_format.V2 (Stable_format) (M)
 
       let stable_witness =
@@ -260,15 +280,17 @@ module With_stable_witness = struct
   end
 
   module Of_stable_format1 = struct
-    module V1 (Stable_format : sig
-      type 'a t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type 'a t [@@deriving compare]
-
-      val map : 'a t -> f:('a -> 'b) -> 'b t
-      val to_stable_format : 'a t -> 'a Stable_format.t
-      val of_stable_format : 'a Stable_format.t -> 'a t
-    end) : With_stable_witness.S1 with type 'a t = 'a M.t = struct
+    module V1
+        (Stable_format : sig
+           type 'a t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type 'a t [@@deriving compare]
+
+           val map : 'a t -> f:('a -> 'b) -> 'b t
+           val to_stable_format : 'a t -> 'a Stable_format.t
+           val of_stable_format : 'a Stable_format.t -> 'a t
+         end) : With_stable_witness.S1 with type 'a t = 'a M.t = struct
       include Of_stable_format1.V1 (Stable_format) (M)
 
       let stable_witness (type a) : a Stable_witness.t -> a M.t Stable_witness.t =
@@ -282,16 +304,18 @@ module With_stable_witness = struct
       ;;
     end
 
-    module V2 (Stable_format : sig
-      type 'a t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type 'a t [@@deriving compare]
-
-      val map : 'a t -> f:('a -> 'b) -> 'b t
-      val to_stable_format : 'a t -> 'a Stable_format.t
-      val of_stable_format : 'a Stable_format.t -> 'a t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S1 with type 'a t = 'a M.t = struct
+    module V2
+        (Stable_format : sig
+           type 'a t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type 'a t [@@deriving compare]
+
+           val map : 'a t -> f:('a -> 'b) -> 'b t
+           val to_stable_format : 'a t -> 'a Stable_format.t
+           val of_stable_format : 'a Stable_format.t -> 'a t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S1 with type 'a t = 'a M.t = struct
       include Of_stable_format1.V2 (Stable_format) (M)
 
       let stable_witness (type a) : a Stable_witness.t -> a M.t Stable_witness.t =
@@ -307,15 +331,17 @@ module With_stable_witness = struct
   end
 
   module Of_stable_format2 = struct
-    module V1 (Stable_format : sig
-      type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2) t [@@deriving compare]
-
-      val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-      val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-      val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-    end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
+    module V1
+        (Stable_format : sig
+           type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2) t [@@deriving compare]
+
+           val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+           val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+           val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+         end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
       include Of_stable_format2.V1 (Stable_format) (M)
 
       let stable_witness witness =
@@ -328,16 +354,18 @@ module With_stable_witness = struct
       ;;
     end
 
-    module V2 (Stable_format : sig
-      type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2) t [@@deriving compare]
-
-      val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-      val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-      val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
+    module V2
+        (Stable_format : sig
+           type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2) t [@@deriving compare]
+
+           val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+           val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+           val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t = struct
       include Of_stable_format2.V2 (Stable_format) (M)
 
       let stable_witness witness =
@@ -352,21 +380,23 @@ module With_stable_witness = struct
   end
 
   module Of_stable_format3 = struct
-    module V1 (Stable_format : sig
-      type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-      val map
-        :  ('a1, 'a2, 'a3) t
-        -> f1:('a1 -> 'b1)
-        -> f2:('a2 -> 'b2)
-        -> f3:('a3 -> 'b3)
-        -> ('b1, 'b2, 'b3) t
-
-      val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-      val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-    end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t =
+    module V1
+        (Stable_format : sig
+           type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+           val map
+             :  ('a1, 'a2, 'a3) t
+             -> f1:('a1 -> 'b1)
+             -> f2:('a2 -> 'b2)
+             -> f3:('a3 -> 'b3)
+             -> ('b1, 'b2, 'b3) t
+
+           val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+           val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+         end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t =
     struct
       include Of_stable_format3.V1 (Stable_format) (M)
 
@@ -380,22 +410,24 @@ module With_stable_witness = struct
       ;;
     end
 
-    module V2 (Stable_format : sig
-      type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-      val map
-        :  ('a1, 'a2, 'a3) t
-        -> f1:('a1 -> 'b1)
-        -> f2:('a2 -> 'b2)
-        -> f3:('a3 -> 'b3)
-        -> ('b1, 'b2, 'b3) t
-
-      val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-      val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t =
+    module V2
+        (Stable_format : sig
+           type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+           val map
+             :  ('a1, 'a2, 'a3) t
+             -> f1:('a1 -> 'b1)
+             -> f2:('a2 -> 'b2)
+             -> f3:('a3 -> 'b3)
+             -> ('b1, 'b2, 'b3) t
+
+           val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+           val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t =
     struct
       include Of_stable_format3.V2 (Stable_format) (M)
 
Index: core-0.17.1/core/src/make_stable.mli
===================================================================
--- core-0.17.1.orig/core/src/make_stable.mli
+++ core-0.17.1/core/src/make_stable.mli
@@ -2,207 +2,239 @@ open! Import
 open Stable_module_types
 
 module Of_stable_format : sig
-  module V1 (Stable_format : sig
-    type t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type t [@@deriving compare]
-
-    val to_stable_format : t -> Stable_format.t
-    val of_stable_format : Stable_format.t -> t
-  end) : S0 with type t = M.t
-
-  module V2 (Stable_format : sig
-    type t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type t [@@deriving compare]
-
-    val to_stable_format : t -> Stable_format.t
-    val of_stable_format : Stable_format.t -> t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S0 with type t = M.t
+  module V1
+      (Stable_format : sig
+         type t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type t [@@deriving compare]
+
+         val to_stable_format : t -> Stable_format.t
+         val of_stable_format : Stable_format.t -> t
+       end) : S0 with type t = M.t
+
+  module V2
+      (Stable_format : sig
+         type t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type t [@@deriving compare]
+
+         val to_stable_format : t -> Stable_format.t
+         val of_stable_format : Stable_format.t -> t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S0 with type t = M.t
 end
 
 module Of_stable_format1 : sig
-  module V1 (Stable_format : sig
-    type 'a t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type 'a t [@@deriving compare]
-
-    val map : 'a t -> f:('a -> 'b) -> 'b t
-    val to_stable_format : 'a t -> 'a Stable_format.t
-    val of_stable_format : 'a Stable_format.t -> 'a t
-  end) : S1 with type 'a t = 'a M.t
-
-  module V2 (Stable_format : sig
-    type 'a t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type 'a t [@@deriving compare]
-
-    val map : 'a t -> f:('a -> 'b) -> 'b t
-    val to_stable_format : 'a t -> 'a Stable_format.t
-    val of_stable_format : 'a Stable_format.t -> 'a t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S1 with type 'a t = 'a M.t
+  module V1
+      (Stable_format : sig
+         type 'a t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type 'a t [@@deriving compare]
+
+         val map : 'a t -> f:('a -> 'b) -> 'b t
+         val to_stable_format : 'a t -> 'a Stable_format.t
+         val of_stable_format : 'a Stable_format.t -> 'a t
+       end) : S1 with type 'a t = 'a M.t
+
+  module V2
+      (Stable_format : sig
+         type 'a t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type 'a t [@@deriving compare]
+
+         val map : 'a t -> f:('a -> 'b) -> 'b t
+         val to_stable_format : 'a t -> 'a Stable_format.t
+         val of_stable_format : 'a Stable_format.t -> 'a t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S1 with type 'a t = 'a M.t
 end
 
 module Of_stable_format2 : sig
-  module V1 (Stable_format : sig
-    type ('a1, 'a2) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2) t [@@deriving compare]
-
-    val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-    val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-    val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-  end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
-
-  module V2 (Stable_format : sig
-    type ('a1, 'a2) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2) t [@@deriving compare]
-
-    val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-    val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-    val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
+  module V1
+      (Stable_format : sig
+         type ('a1, 'a2) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2) t [@@deriving compare]
+
+         val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+         val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+         val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+       end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
+
+  module V2
+      (Stable_format : sig
+         type ('a1, 'a2) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2) t [@@deriving compare]
+
+         val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+         val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+         val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
 end
 
 module Of_stable_format3 : sig
-  module V1 (Stable_format : sig
-    type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-    val map
-      :  ('a1, 'a2, 'a3) t
-      -> f1:('a1 -> 'b1)
-      -> f2:('a2 -> 'b2)
-      -> f3:('a3 -> 'b3)
-      -> ('b1, 'b2, 'b3) t
-
-    val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-    val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-  end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
-
-  module V2 (Stable_format : sig
-    type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
-  end) (M : sig
-    type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-    val map
-      :  ('a1, 'a2, 'a3) t
-      -> f1:('a1 -> 'b1)
-      -> f2:('a2 -> 'b2)
-      -> f3:('a3 -> 'b3)
-      -> ('b1, 'b2, 'b3) t
-
-    val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-    val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-    val caller_identity : Bin_shape.Uuid.t
-  end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
+  module V1
+      (Stable_format : sig
+         type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+         val map
+           :  ('a1, 'a2, 'a3) t
+           -> f1:('a1 -> 'b1)
+           -> f2:('a2 -> 'b2)
+           -> f3:('a3 -> 'b3)
+           -> ('b1, 'b2, 'b3) t
+
+         val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+         val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+       end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
+
+  module V2
+      (Stable_format : sig
+         type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp]
+       end)
+      (M : sig
+         type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+         val map
+           :  ('a1, 'a2, 'a3) t
+           -> f1:('a1 -> 'b1)
+           -> f2:('a2 -> 'b2)
+           -> f3:('a3 -> 'b3)
+           -> ('b1, 'b2, 'b3) t
+
+         val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+         val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+         val caller_identity : Bin_shape.Uuid.t
+       end) : S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
 end
 
 module With_stable_witness : sig
   module Of_stable_format : sig
-    module V1 (Stable_format : sig
-      type t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type t [@@deriving compare]
-
-      val to_stable_format : t -> Stable_format.t
-      val of_stable_format : Stable_format.t -> t
-    end) : With_stable_witness.S0 with type t = M.t
-
-    module V2 (Stable_format : sig
-      type t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type t [@@deriving compare]
-
-      val to_stable_format : t -> Stable_format.t
-      val of_stable_format : Stable_format.t -> t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S0 with type t = M.t
+    module V1
+        (Stable_format : sig
+           type t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type t [@@deriving compare]
+
+           val to_stable_format : t -> Stable_format.t
+           val of_stable_format : Stable_format.t -> t
+         end) : With_stable_witness.S0 with type t = M.t
+
+    module V2
+        (Stable_format : sig
+           type t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type t [@@deriving compare]
+
+           val to_stable_format : t -> Stable_format.t
+           val of_stable_format : Stable_format.t -> t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S0 with type t = M.t
   end
 
   module Of_stable_format1 : sig
-    module V1 (Stable_format : sig
-      type 'a t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type 'a t [@@deriving compare]
-
-      val map : 'a t -> f:('a -> 'b) -> 'b t
-      val to_stable_format : 'a t -> 'a Stable_format.t
-      val of_stable_format : 'a Stable_format.t -> 'a t
-    end) : With_stable_witness.S1 with type 'a t = 'a M.t
-
-    module V2 (Stable_format : sig
-      type 'a t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type 'a t [@@deriving compare]
-
-      val map : 'a t -> f:('a -> 'b) -> 'b t
-      val to_stable_format : 'a t -> 'a Stable_format.t
-      val of_stable_format : 'a Stable_format.t -> 'a t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S1 with type 'a t = 'a M.t
+    module V1
+        (Stable_format : sig
+           type 'a t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type 'a t [@@deriving compare]
+
+           val map : 'a t -> f:('a -> 'b) -> 'b t
+           val to_stable_format : 'a t -> 'a Stable_format.t
+           val of_stable_format : 'a Stable_format.t -> 'a t
+         end) : With_stable_witness.S1 with type 'a t = 'a M.t
+
+    module V2
+        (Stable_format : sig
+           type 'a t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type 'a t [@@deriving compare]
+
+           val map : 'a t -> f:('a -> 'b) -> 'b t
+           val to_stable_format : 'a t -> 'a Stable_format.t
+           val of_stable_format : 'a Stable_format.t -> 'a t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S1 with type 'a t = 'a M.t
   end
 
   module Of_stable_format2 : sig
-    module V1 (Stable_format : sig
-      type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2) t [@@deriving compare]
-
-      val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-      val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-      val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-    end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
-
-    module V2 (Stable_format : sig
-      type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2) t [@@deriving compare]
-
-      val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
-      val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
-      val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
+    module V1
+        (Stable_format : sig
+           type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2) t [@@deriving compare]
+
+           val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+           val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+           val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+         end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
+
+    module V2
+        (Stable_format : sig
+           type ('a1, 'a2) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2) t [@@deriving compare]
+
+           val map : ('a1, 'a2) t -> f1:('a1 -> 'b1) -> f2:('a2 -> 'b2) -> ('b1, 'b2) t
+           val to_stable_format : ('a1, 'a2) t -> ('a1, 'a2) Stable_format.t
+           val of_stable_format : ('a1, 'a2) Stable_format.t -> ('a1, 'a2) t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S2 with type ('a1, 'a2) t = ('a1, 'a2) M.t
   end
 
   module Of_stable_format3 : sig
-    module V1 (Stable_format : sig
-      type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-      val map
-        :  ('a1, 'a2, 'a3) t
-        -> f1:('a1 -> 'b1)
-        -> f2:('a2 -> 'b2)
-        -> f3:('a3 -> 'b3)
-        -> ('b1, 'b2, 'b3) t
-
-      val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-      val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-    end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
-
-    module V2 (Stable_format : sig
-      type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
-    end) (M : sig
-      type ('a1, 'a2, 'a3) t [@@deriving compare]
-
-      val map
-        :  ('a1, 'a2, 'a3) t
-        -> f1:('a1 -> 'b1)
-        -> f2:('a2 -> 'b2)
-        -> f3:('a3 -> 'b3)
-        -> ('b1, 'b2, 'b3) t
-
-      val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
-      val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
-      val caller_identity : Bin_shape.Uuid.t
-    end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
+    module V1
+        (Stable_format : sig
+           type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+           val map
+             :  ('a1, 'a2, 'a3) t
+             -> f1:('a1 -> 'b1)
+             -> f2:('a2 -> 'b2)
+             -> f3:('a3 -> 'b3)
+             -> ('b1, 'b2, 'b3) t
+
+           val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+           val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+         end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
+
+    module V2
+        (Stable_format : sig
+           type ('a1, 'a2, 'a3) t [@@deriving bin_io, sexp, stable_witness]
+         end)
+        (M : sig
+           type ('a1, 'a2, 'a3) t [@@deriving compare]
+
+           val map
+             :  ('a1, 'a2, 'a3) t
+             -> f1:('a1 -> 'b1)
+             -> f2:('a2 -> 'b2)
+             -> f3:('a3 -> 'b3)
+             -> ('b1, 'b2, 'b3) t
+
+           val to_stable_format : ('a1, 'a2, 'a3) t -> ('a1, 'a2, 'a3) Stable_format.t
+           val of_stable_format : ('a1, 'a2, 'a3) Stable_format.t -> ('a1, 'a2, 'a3) t
+           val caller_identity : Bin_shape.Uuid.t
+         end) : With_stable_witness.S3 with type ('a1, 'a2, 'a3) t = ('a1, 'a2, 'a3) M.t
   end
 end
Index: core-0.17.1/core/src/make_substring.ml
===================================================================
--- core-0.17.1.orig/core/src/make_substring.ml
+++ core-0.17.1/core/src/make_substring.ml
@@ -251,7 +251,7 @@ module F (Underlying : Base) : S with ty
       (List.fold ts ~init:0 ~f:(fun dst_pos t ->
          blit_dst t ~dst ~dst_pos;
          dst_pos + length t)
-        : int);
+       : int);
     dst
   ;;
 
Index: core-0.17.1/core/src/make_substring_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/make_substring_intf.ml
+++ core-0.17.1/core/src/make_substring_intf.ml
@@ -12,7 +12,7 @@ module type Base = sig
   val blit_from_bigstring : (bigstring, t) Blit.blito
 
   val blit_to_string : (t, bytes) Blit.blito
-    [@@deprecated "[since 2017-10] use [blit_to_bytes] instead"]
+  [@@deprecated "[since 2017-10] use [blit_to_bytes] instead"]
 
   val get : t -> int -> char
 end
@@ -29,10 +29,10 @@ module type Make_substring = sig
     type ('src, 'dst) t = ('src, 'dst) Blit.blito
 
     val string_string : (string, bytes) t
-      [@@deprecated "[since 2017-10] use [string_bytes] instead"]
+    [@@deprecated "[since 2017-10] use [string_bytes] instead"]
 
     val bigstring_string : (bigstring, bytes) t
-      [@@deprecated "[since 2017-10] use [bigstring_bytes] instead"]
+    [@@deprecated "[since 2017-10] use [bigstring_bytes] instead"]
 
     val string_bytes : (string, bytes) t
     val bytes_bytes : (bytes, bytes) t
Index: core-0.17.1/core/src/map.ml
===================================================================
--- core-0.17.1.orig/core/src/map.ml
+++ core-0.17.1/core/src/map.ml
@@ -110,19 +110,31 @@ module Accessors = struct
   include (
     Map.Using_comparator :
       Map.Accessors_generic
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-        with type ('a, 'b, 'c) t := ('a, 'b, 'c) Map.t
-        with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
-        with type 'k key := 'k
-        with type 'c cmp := 'c)
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) Map.t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
+      with type 'k key := 'k
+      with type 'c cmp := 'c)
 
   let validate ~name f t = Validate.alist ~name f (to_alist t)
   let validatei ~name f t = Validate.list ~name:(Fn.compose name fst) f (to_alist t)
   let quickcheck_observer k v = quickcheck_observer k v
-  let quickcheck_shrinker k v = quickcheck_shrinker k v
   let key_set t = Using_comparator.key_set t ~comparator:(Using_comparator.comparator t)
 end
 
+module Transformers = struct
+  include (
+    Map.Using_comparator :
+      Map.Transformers_generic
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) Map.t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
+      with type 'k key := 'k
+      with type 'c cmp := 'c)
+
+  let quickcheck_shrinker k v = quickcheck_shrinker k v
+end
+
 let key_set t = Using_comparator.key_set ~comparator:(Using_comparator.comparator t) t
 let of_key_set = Using_comparator.of_key_set
 let hash_fold_direct = Using_comparator.hash_fold_direct
@@ -133,37 +145,33 @@ type 'k key = 'k
 type 'c cmp = 'c
 
 include (
-  struct
-    include Map
+struct
+  include Map
 
-    let validate ~name f t = Validate.alist ~name f (to_alist t)
-    let validatei ~name f t = Validate.list ~name:(Fn.compose name fst) f (to_alist t)
-    let of_tree m = Map.Using_comparator.of_tree ~comparator:(to_comparator m)
-    let to_tree = Map.Using_comparator.to_tree
-  end :
-    sig
-      type ('a, 'b, 'c) t = ('a, 'b, 'c) Map.t
+  let validate ~name f t = Validate.alist ~name f (to_alist t)
+  let validatei ~name f t = Validate.list ~name:(Fn.compose name fst) f (to_alist t)
+  let of_tree m = Map.Using_comparator.of_tree ~comparator:(to_comparator m)
+  let to_tree = Map.Using_comparator.to_tree
+end :
+sig
+  type ('a, 'b, 'c) t = ('a, 'b, 'c) Map.t
 
-      include
-        Map.Creators_and_accessors_generic
-          with type ('a, 'b, 'c) create_options :=
-            ('a, 'b, 'c) Map.With_first_class_module.t
-          with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Map.Without_comparator.t
-          with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-          with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
-          with type 'k key := 'k key
-          with type 'c cmp := 'c cmp
-
-      val validate
-        :  name:('k -> string)
-        -> 'v Validate.check
-        -> ('k, 'v, _) t Validate.check
-
-      val validatei
-        :  name:('k key -> string)
-        -> ('k key * 'v) Validate.check
-        -> ('k, 'v, _) t Validate.check
-    end)
+  include
+    Map.Creators_and_accessors_and_transformers_generic
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Map.With_first_class_module.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Map.Without_comparator.t
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
+    with type 'k key := 'k key
+    with type 'c cmp := 'c cmp
+
+  val validate : name:('k -> string) -> 'v Validate.check -> ('k, 'v, _) t Validate.check
+
+  val validatei
+    :  name:('k key -> string)
+    -> ('k key * 'v) Validate.check
+    -> ('k, 'v, _) t Validate.check
+end)
 
 module Empty_without_value_restriction = Using_comparator.Empty_without_value_restriction
 
@@ -191,12 +199,12 @@ module Creators (Key : Comparator.S1) :
 
   include
     Creators_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t_
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
-      with type 'a key := 'a Key.t
-      with type 'a cmp := Key.comparator_witness
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t_
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a Key.t
+    with type 'a cmp := Key.comparator_witness
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
 end = struct
   let comparator = Key.comparator
 
@@ -449,10 +457,10 @@ module Make_tree_S1 (Key : Comparator.S1
 end
 
 module Make_tree_plain (Key : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   module Key_S1 = Comparator.S_to_S1 (Key)
   include Make_tree_S1 (Key_S1)
@@ -462,20 +470,20 @@ struct
   let sexp_of_t sexp_of_v t = sexp_of_t Key.sexp_of_t sexp_of_v [%sexp_of: _] t
 
   module Provide_of_sexp
-    (X : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := Key.t) =
+      (X : sig
+             type t [@@deriving of_sexp]
+           end
+           with type t := Key.t) =
   struct
     let t_of_sexp v_of_sexp sexp = t_of_sexp X.t_of_sexp v_of_sexp sexp
   end
 end
 
 module Make_tree (Key : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include Make_tree_plain (Key)
   include Provide_of_sexp (Key)
@@ -501,6 +509,7 @@ module Poly = struct
   type comparator_witness = Comparator.Poly.comparator_witness
 
   include Accessors
+  include Transformers
 
   let compare _ cmpv t1 t2 = compare_direct cmpv t1 t2
 
@@ -513,23 +522,29 @@ module Poly = struct
   ;;
 
   include Bin_prot.Utils.Make_iterable_binable2 (struct
-    type nonrec ('a, 'b) t = ('a, 'b) t
-    type ('a, 'b) el = 'a * 'b [@@deriving bin_io]
+      type nonrec ('a, 'b) t = ('a, 'b) t
+      type ('a, 'b) el = 'a * 'b [@@deriving bin_io]
 
-    let _ = bin_el
+      let _ = bin_el
 
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "b7d7b1a0-4992-11e6-8a32-bbb221fa025c"
-    ;;
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "b7d7b1a0-4992-11e6-8a32-bbb221fa025c"
+      ;;
 
-    let module_name = Some "Core.Map"
-    let length = length
-    let iter t ~f = iteri t ~f:(fun ~key ~data -> f (key, data))
+      let module_name = Some "Core.Map"
+      let length = length
 
-    let init ~len ~next =
-      init_for_bin_prot ~len ~f:(fun _ -> next ()) ~comparator:Comparator.Poly.comparator
-    ;;
-  end)
+      let[@inline always] iter t ~f =
+        iteri t ~f:(fun ~key ~data -> f (key, data)) [@nontail]
+      ;;
+
+      let init ~len ~next =
+        init_for_bin_prot
+          ~len
+          ~f:(fun _ -> next ())
+          ~comparator:Comparator.Poly.comparator
+      ;;
+    end)
 
   module Tree = struct
     include Make_tree_S1 (Comparator.Poly)
@@ -557,31 +572,34 @@ module type S_binable = S_binable
 module Key_bin_io = Key_bin_io
 
 module Provide_bin_io (Key : Key_bin_io.S) = Bin_prot.Utils.Make_iterable_binable1 (struct
-  module Key = Key
+    module Key = Key
 
-  type nonrec 'v t = (Key.t, 'v, Key.comparator_witness) t
-  type 'v el = Key.t * 'v [@@deriving bin_io]
+    type nonrec 'v t = (Key.t, 'v, Key.comparator_witness) t
+    type 'v el = Key.t * 'v [@@deriving bin_io]
 
-  let _ = bin_el
+    let _ = bin_el
 
-  let caller_identity =
-    Bin_prot.Shape.Uuid.of_string "dfb300f8-4992-11e6-9c15-73a2ac6b815c"
-  ;;
+    let caller_identity =
+      Bin_prot.Shape.Uuid.of_string "dfb300f8-4992-11e6-9c15-73a2ac6b815c"
+    ;;
 
-  let module_name = Some "Core.Map"
-  let length = length
-  let iter t ~f = iteri t ~f:(fun ~key ~data -> f (key, data))
+    let module_name = Some "Core.Map"
+    let length = length
 
-  let init ~len ~next =
-    init_for_bin_prot ~len ~f:(fun _ -> next ()) ~comparator:Key.comparator
-  ;;
-end)
+    let[@inline always] iter t ~f =
+      iteri t ~f:(fun ~key ~data -> f (key, data)) [@nontail]
+    ;;
+
+    let init ~len ~next =
+      init_for_bin_prot ~len ~f:(fun _ -> next ()) ~comparator:Key.comparator
+    ;;
+  end)
 
 module Provide_stable_witness (Key : sig
-  type t [@@deriving stable_witness]
+    type t [@@deriving stable_witness]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   (* The binary representation of map is used in the stable modules below, so it's
      assumed to be stable (if the key and data are stable) . *)
@@ -594,10 +612,10 @@ struct
 end
 
 module Make_plain_using_comparator (Key : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   module Key = Key
   module Key_S1 = Comparator.S_to_S1 (Key)
@@ -608,6 +626,7 @@ struct
   type 'v t = (key, 'v, Key.comparator_witness) map
 
   include Accessors
+  include Transformers
 
   let compare cmpv t1 t2 = compare_direct cmpv t1 t2
 
@@ -625,10 +644,10 @@ struct
   end
 
   module Provide_of_sexp
-    (Key : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := Key.t) =
+      (Key : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := Key.t) =
   struct
     let t_of_sexp v_of_sexp sexp = t_of_sexp Key.t_of_sexp v_of_sexp sexp
 
@@ -648,36 +667,36 @@ struct
   end
 
   module Provide_bin_io
-    (Key' : sig
-      type t [@@deriving bin_io]
-    end
-    with type t := Key.t) =
+      (Key' : sig
+                type t [@@deriving bin_io]
+              end
+              with type t := Key.t) =
   Provide_bin_io (struct
-    include Key
-    include Key'
-  end)
+      include Key
+      include Key'
+    end)
 
   module Provide_stable_witness
-    (Key' : sig
-      type t [@@deriving stable_witness]
-    end
-    with type t := Key.t) =
+      (Key' : sig
+                type t [@@deriving stable_witness]
+              end
+              with type t := Key.t) =
   Provide_stable_witness (struct
-    include Key
-    include Key'
-  end)
+      include Key
+      include Key'
+    end)
 end
 
 module Make_plain (Key : Key_plain) = Make_plain_using_comparator (struct
-  include Key
-  include Comparator.Make (Key)
-end)
+    include Key
+    include Comparator.Make (Key)
+  end)
 
 module Make_using_comparator (Key_sexp : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include Make_plain_using_comparator (Key_sexp)
   module Key = Key_sexp
@@ -690,15 +709,15 @@ struct
 end
 
 module Make (Key : Key) = Make_using_comparator (struct
-  include Key
-  include Comparator.Make (Key)
-end)
+    include Key
+    include Comparator.Make (Key)
+  end)
 
 module Make_binable_using_comparator (Key_bin_sexp : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include Make_using_comparator (Key_bin_sexp)
   module Key = Key_bin_sexp
@@ -713,9 +732,9 @@ struct
 end
 
 module Make_binable (Key : Key_binable) = Make_binable_using_comparator (struct
-  include Key
-  include Comparator.Make (Key)
-end)
+    include Key
+    include Comparator.Make (Key)
+  end)
 
 module For_deriving = struct
   module M = Map.M
@@ -836,9 +855,8 @@ module Stable = struct
 
       include
         Diffable.S1
-          with type 'a t := 'a t
-           and type ('a, 'a_diff) Diff.t =
-            (key, 'a, 'a_diff) Diffable.Map_diff.Stable.V1.t
+        with type 'a t := 'a t
+         and type ('a, 'a_diff) Diff.t = (key, 'a, 'a_diff) Diffable.Map_diff.Stable.V1.t
     end
 
     include For_deriving
Index: core-0.17.1/core/src/map.mli
===================================================================
--- core-0.17.1.orig/core/src/map.mli
+++ core-0.17.1/core/src/map.mli
@@ -145,12 +145,12 @@ module Tree : sig
 
   include
     Creators_and_accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) t
-      with type 'cmp cmp := 'cmp
-      with type 'key key := 'key
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) t
+    with type 'cmp cmp := 'cmp
+    with type 'key key := 'key
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
 end
 
 val to_tree : ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) Tree.t
@@ -979,46 +979,48 @@ val quickcheck_shrinker
 module Using_comparator : sig
   include
     Creators_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
-      with type 'k key := 'k
-      with type 'c cmp := 'c
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
+    with type 'k key := 'k
+    with type 'c cmp := 'c
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
 end
 
 module Poly : sig
-  type ('a, +'b, 'c) map
+    type ('a, +'b, 'c) map
 
-  module Tree : sig
-    type comparator_witness = Comparator.Poly.comparator_witness
-    type ('k, +'v) t = ('k, 'v, comparator_witness) Tree.t [@@deriving sexp, sexp_grammar]
+    module Tree : sig
+      type comparator_witness = Comparator.Poly.comparator_witness
 
-    include
-      Creators_and_accessors_generic
+      type ('k, +'v) t = ('k, 'v, comparator_witness) Tree.t
+      [@@deriving sexp, sexp_grammar]
+
+      include
+        Creators_and_accessors_generic
         with type ('a, 'b, 'c) t := ('a, 'b) t
         with type ('a, 'b, 'c) tree := ('a, 'b) t
         with type 'k key := 'k
         with type 'c cmp := comparator_witness
         with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
         with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-  end
+    end
 
-  type comparator_witness = Comparator.Poly.comparator_witness
+    type comparator_witness = Comparator.Poly.comparator_witness
 
-  type ('a, +'b) t = ('a, 'b, comparator_witness) map
-  [@@deriving bin_io, sexp, sexp_grammar, compare]
+    type ('a, +'b) t = ('a, 'b, comparator_witness) map
+    [@@deriving bin_io, sexp, sexp_grammar, compare]
 
-  include
-    Creators_and_accessors_generic
+    include
+      Creators_and_accessors_generic
       with type ('a, 'b, 'c) t := ('a, 'b) t
       with type ('a, 'b, 'c) tree := ('a, 'b) Tree.t
       with type 'k key := 'k
       with type 'c cmp := comparator_witness
       with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
       with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-end
-with type ('a, 'b, 'c) map = ('a, 'b, 'c) t
+  end
+  with type ('a, 'b, 'c) map = ('a, 'b, 'c) t
 
 module type Key_plain = Key_plain
 module type Key = Key
@@ -1030,47 +1032,48 @@ module type S_binable = S_binable
 module Make_plain (Key : Key_plain) : S_plain with type Key.t = Key.t
 
 module Make_plain_using_comparator (Key : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) :
+    include Comparator.S with type t := t
+  end) :
   S_plain
-    with type Key.t = Key.t
-    with type Key.comparator_witness = Key.comparator_witness
+  with type Key.t = Key.t
+  with type Key.comparator_witness = Key.comparator_witness
 
 module Make (Key : Key) : S with type Key.t = Key.t
 
 module Make_using_comparator (Key : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) : S with type Key.t = Key.t with type Key.comparator_witness = Key.comparator_witness
+    include Comparator.S with type t := t
+  end) :
+  S with type Key.t = Key.t with type Key.comparator_witness = Key.comparator_witness
 
 module Make_binable (Key : Key_binable) : S_binable with type Key.t = Key.t
 
 module Make_binable_using_comparator (Key : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  include Comparator.S with type t := t
-end) :
+    include Comparator.S with type t := t
+  end) :
   S_binable
-    with type Key.t = Key.t
-    with type Key.comparator_witness = Key.comparator_witness
+  with type Key.t = Key.t
+  with type Key.comparator_witness = Key.comparator_witness
 
 module Key_bin_io = Key_bin_io
 include For_deriving with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
 
 module Make_tree_plain (Key : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) : Make_S_plain_tree(Key).S
+    include Comparator.S with type t := t
+  end) : Make_S_plain_tree(Key).S
 
 module Make_tree (Key : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) : sig
+    include Comparator.S with type t := t
+  end) : sig
   include Make_S_plain_tree(Key).S
   include Sexpable.S1 with type 'a t := 'a t
 end
@@ -1089,9 +1092,8 @@ module Stable : sig
 
       include
         Diffable.S1
-          with type 'a t := 'a t
-           and type ('a, 'a_diff) Diff.t =
-            (key, 'a, 'a_diff) Diffable.Map_diff.Stable.V1.t
+        with type 'a t := 'a t
+         and type ('a, 'a_diff) Diff.t = (key, 'a, 'a_diff) Diffable.Map_diff.Stable.V1.t
     end
 
     include For_deriving with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
@@ -1115,6 +1117,6 @@ module Stable : sig
   module Symmetric_diff_element : sig
     module V1 :
       Stable_module_types.With_stable_witness.S2
-        with type ('a, 'b) t = ('a, 'b) Symmetric_diff_element.t
+      with type ('a, 'b) t = ('a, 'b) Symmetric_diff_element.t
   end
 end
Index: core-0.17.1/core/src/map_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/map_intf.ml
+++ core-0.17.1/core/src/map_intf.ml
@@ -70,14 +70,18 @@ module type Accessors_generic = sig
     :  'k key Quickcheck.Observer.t
     -> 'v Quickcheck.Observer.t
     -> ('k, 'v, 'cmp) t Quickcheck.Observer.t
+end
+
+module type Transformers_generic = sig
+  include Map.Transformers_generic
 
   val quickcheck_shrinker
     : ( 'k
-      , 'cmp
-      , 'k key Quickcheck.Shrinker.t
-        -> 'v Quickcheck.Shrinker.t
-        -> ('k, 'v, 'cmp) t Quickcheck.Shrinker.t )
-      access_options
+        , 'cmp
+        , 'k key Quickcheck.Shrinker.t
+          -> 'v Quickcheck.Shrinker.t
+          -> ('k, 'v, 'cmp) t Quickcheck.Shrinker.t )
+        access_options
 end
 
 module type Creators_generic = sig
@@ -91,11 +95,11 @@ module type Creators_generic = sig
 
   val quickcheck_generator
     : ( 'k
-      , 'cmp
-      , 'k key Quickcheck.Generator.t
-        -> 'v Quickcheck.Generator.t
-        -> ('k, 'v, 'cmp) t Quickcheck.Generator.t )
-      create_options
+        , 'cmp
+        , 'k key Quickcheck.Generator.t
+          -> 'v Quickcheck.Generator.t
+          -> ('k, 'v, 'cmp) t Quickcheck.Generator.t )
+        create_options
 end
 
 module type Creators_and_accessors_generic = sig
@@ -108,20 +112,28 @@ module type Creators_and_accessors_gener
 
   include
     Creators_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
-      with type 'a key := 'a key
-      with type 'a cmp := 'a cmp
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a key
+    with type 'a cmp := 'a cmp
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+
+  include
+    Transformers_generic
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a key
+    with type 'a cmp := 'a cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
 
   include
     Accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
-      with type 'a key := 'a key
-      with type 'a cmp := 'a cmp
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a key
+    with type 'a cmp := 'a cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
 end
 
 module Make_S_plain_tree (Key : Comparator.S) = struct
@@ -130,21 +142,21 @@ module Make_S_plain_tree (Key : Comparat
 
     include
       Creators_and_accessors_generic
-        with type ('a, 'b, 'c) t := 'b t
-        with type ('a, 'b, 'c) tree := 'b t
-        with type 'a key := Key.t
-        with type 'a cmp := Key.comparator_witness
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b, 'c) t := 'b t
+      with type ('a, 'b, 'c) tree := 'b t
+      with type 'a key := Key.t
+      with type 'a cmp := Key.comparator_witness
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
 
     module Provide_of_sexp
-      (K : sig
-        type t [@@deriving of_sexp]
+        (K : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := Key.t) : sig
+        type _ t [@@deriving of_sexp]
       end
-      with type t := Key.t) : sig
-      type _ t [@@deriving of_sexp]
-    end
-    with type 'a t := 'a t
+      with type 'a t := 'a t
   end
 end
 
@@ -160,20 +172,20 @@ module type S_plain = sig
 
   include
     Creators_generic
-      with type ('a, 'b, 'c) t := 'b t
-      with type ('a, 'b, 'c) tree := (Key.t, 'b, Key.comparator_witness) Tree.t
-      with type 'k key := Key.t
-      with type 'c cmp := Key.comparator_witness
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) t := 'b t
+    with type ('a, 'b, 'c) tree := (Key.t, 'b, Key.comparator_witness) Tree.t
+    with type 'k key := Key.t
+    with type 'c cmp := Key.comparator_witness
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
 
   module Diff : sig
     type ('a, 'a_diff) t = (Key.t, 'a, 'a_diff) Diffable.Map_diff.t [@@deriving sexp_of]
 
     include
       Diffable.Diff.S1_plain
-        with type 'a derived_on = (Key.t, 'a, Key.comparator_witness) Map.t
-         and type ('a, 'a_diff) t := ('a, 'a_diff) t
+      with type 'a derived_on = (Key.t, 'a, Key.comparator_witness) Map.t
+       and type ('a, 'a_diff) t := ('a, 'a_diff) t
   end
 
   include Diffable.S1_plain with type 'a t := 'a t and module Diff := Diff
@@ -181,24 +193,25 @@ module type S_plain = sig
   val map : 'a t -> f:('a -> 'b) -> 'b t
 
   module Provide_of_sexp
-    (Key : sig
-      type t [@@deriving of_sexp]
+      (Key : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := Key.t) : sig
+      type _ t [@@deriving of_sexp]
     end
-    with type t := Key.t) : sig
-    type _ t [@@deriving of_sexp]
-  end
-  with type 'a t := 'a t
+    with type 'a t := 'a t
 
   module Provide_bin_io
-    (Key : sig
-      type t [@@deriving bin_io]
+      (Key : sig
+               type t [@@deriving bin_io]
+             end
+             with type t := Key.t) : Binable.S1 with type 'a t := 'a t
+
+  module Provide_hash
+      (Key : Hasher.S with type t := Key.t) : sig
+      type 'a t [@@deriving hash]
     end
-    with type t := Key.t) : Binable.S1 with type 'a t := 'a t
-
-  module Provide_hash (Key : Hasher.S with type t := Key.t) : sig
-    type 'a t [@@deriving hash]
-  end
-  with type 'a t := 'a t
+    with type 'a t := 'a t
 
   val quickcheck_observer
     :  Key.t Quickcheck.Observer.t
@@ -207,11 +220,11 @@ module type S_plain = sig
 
   val quickcheck_shrinker
     : ( 'k
-      , 'cmp
-      , Key.t Quickcheck.Shrinker.t
-        -> 'v Quickcheck.Shrinker.t
-        -> 'v t Quickcheck.Shrinker.t )
-      Without_comparator.t
+        , 'cmp
+        , Key.t Quickcheck.Shrinker.t
+          -> 'v Quickcheck.Shrinker.t
+          -> 'v t Quickcheck.Shrinker.t )
+        Without_comparator.t
 end
 
 module type S = sig
@@ -226,8 +239,8 @@ module type S = sig
 
     include
       Diffable.Diff.S1_plain
-        with type ('a, 'a_diff) t := ('a, 'a_diff) t
-         and type 'a derived_on = (Key.t, 'a, Key.comparator_witness) Map.t
+      with type ('a, 'a_diff) t := ('a, 'a_diff) t
+       and type 'a derived_on = (Key.t, 'a, Key.comparator_witness) Map.t
   end
 
   include S_plain with module Key := Key and module Diff := Diff
@@ -247,8 +260,8 @@ module type S_binable = sig
 
     include
       Diffable.Diff.S1_plain
-        with type ('a, 'a_diff) t := ('a, 'a_diff) t
-         and type 'a derived_on = (Key.t, 'a, Key.comparator_witness) Map.t
+      with type ('a, 'a_diff) t := ('a, 'a_diff) t
+       and type 'a derived_on = (Key.t, 'a, Key.comparator_witness) Map.t
   end
 
   include S with module Key := Key and module Diff := Diff
@@ -284,7 +297,7 @@ module type For_deriving = sig
   val __bin_read_m__t__
     :  ('a, 'c) Key_bin_io.t
     -> 'b Bin_prot.Read.reader
-    -> (int -> ('a, 'b, 'c) t) Bin_prot.Read.reader
+    -> ('a, 'b, 'c) t Bin_prot.Read.vtag_reader
 
   (** The following [quickcheck*] functions support deriving quickcheck on base-style maps,
       e.g.:
Index: core-0.17.1/core/src/maybe_bound.ml
===================================================================
--- core-0.17.1.orig/core/src/maybe_bound.ml
+++ core-0.17.1/core/src/maybe_bound.ml
@@ -24,7 +24,7 @@ type 'a t = 'a Stable.V1.t =
   | Incl of 'a
   | Excl of 'a
   | Unbounded
-[@@deriving bin_io ~localize, compare, equal, hash, quickcheck, sexp]
+[@@deriving bin_io ~localize, compare, equal, hash, quickcheck, sexp, sexp_grammar]
 
 let compare_one_sided ~side compare_a t1 t2 =
   match t1, t2 with
@@ -58,13 +58,13 @@ let compare_one_sided ~side compare_a t1
 ;;
 
 module As_lower_bound = struct
-  type nonrec 'a t = 'a t [@@deriving bin_io, equal, hash, sexp]
+  type nonrec 'a t = 'a t [@@deriving bin_io, equal, hash, sexp, sexp_grammar]
 
   let compare compare_a t1 t2 = compare_one_sided ~side:`Lower compare_a t1 t2
 end
 
 module As_upper_bound = struct
-  type nonrec 'a t = 'a t [@@deriving bin_io, equal, hash, sexp]
+  type nonrec 'a t = 'a t [@@deriving bin_io, equal, hash, sexp, sexp_grammar]
 
   let compare compare_a t1 t2 = compare_one_sided ~side:`Upper compare_a t1 t2
 end
Index: core-0.17.1/core/src/maybe_bound.mli
===================================================================
--- core-0.17.1.orig/core/src/maybe_bound.mli
+++ core-0.17.1/core/src/maybe_bound.mli
@@ -22,7 +22,7 @@ include module type of struct
       Unbounded < ... < Incl 13 < Excl 13 < Incl 14 < Excl 14 < ...
     ]} *)
 module As_lower_bound : sig
-  type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, hash, sexp]
+  type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 (** Compares [t] values as upper bounds, where [Unbounded] is highest, [Incl x > Excl x],
@@ -34,7 +34,7 @@ end
       ... < Excl 13 < Incl 13 < Excl 14 < Incl 14 < ... < Unbounded
     ]} *)
 module As_upper_bound : sig
-  type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, hash, sexp]
+  type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 module Stable : sig
Index: core-0.17.1/core/src/md5.ml
===================================================================
--- core-0.17.1.orig/core/src/md5.ml
+++ core-0.17.1/core/src/md5.ml
@@ -5,6 +5,21 @@ module T = struct
   let sexp_of_t t = t |> to_hex |> String.sexp_of_t
   let t_of_sexp s = s |> String.t_of_sexp |> of_hex_exn
   let t_sexp_grammar = Sexplib.Sexp_grammar.coerce String.t_sexp_grammar
+
+  include struct
+    open Base_quickcheck
+
+    let quickcheck_generator =
+      Generator.string_with_length_of
+        ~length:16
+        (Generator.union
+           [ Generator.char_uniform_inclusive Char.min_value Char.max_value ])
+      |> Generator.map ~f:of_binary_exn
+    ;;
+
+    let quickcheck_observer = Observer.unmap String.quickcheck_observer ~f:to_binary
+    let quickcheck_shrinker = Shrinker.atomic
+  end
 end
 
 let hash_fold_t accum t = String.hash_fold_t accum (T.to_binary t)
@@ -13,7 +28,7 @@ let hash t = String.hash (T.to_binary t)
 module As_binary_string = struct
   module Stable = struct
     module V1 = struct
-      type t = T.t [@@deriving compare, equal]
+      type t = T.t [@@deriving compare, equal, quickcheck]
 
       let hash_fold_t = hash_fold_t
       let hash = hash
@@ -24,13 +39,13 @@ module As_binary_string = struct
       let of_binable = T.of_binary_exn
 
       include Bin_prot.Utils.Make_binable_without_uuid [@alert "-legacy"] (struct
-        module Binable = String.Stable.V1
+          module Binable = String.Stable.V1
 
-        type t = Bin_prot.Md5.t
+          type t = Bin_prot.Md5.t
 
-        let to_binable = to_binable
-        let of_binable = of_binable
-      end)
+          let to_binable = to_binable
+          let of_binable = of_binable
+        end)
 
       let stable_witness : t Stable_witness.t =
         Stable_witness.of_serializable
@@ -48,7 +63,7 @@ end
 
 module Stable = struct
   module V1 = struct
-    type t = T.t [@@deriving compare, equal, sexp, sexp_grammar]
+    type t = T.t [@@deriving compare, equal, quickcheck, sexp, sexp_grammar]
 
     let hash_fold_t = hash_fold_t
     let hash = hash
@@ -56,13 +71,13 @@ module Stable = struct
     let of_binable = Fn.id
 
     include Bin_prot.Utils.Make_binable_without_uuid [@alert "-legacy"] (struct
-      module Binable = Bin_prot.Md5.Stable.V1
+        module Binable = Bin_prot.Md5.Stable.V1
 
-      type t = Bin_prot.Md5.t
+        type t = Bin_prot.Md5.t
 
-      let to_binable = to_binable
-      let of_binable = of_binable
-    end)
+        let to_binable = to_binable
+        let of_binable = of_binable
+      end)
 
     let stable_witness : t Stable_witness.t =
       Stable_witness.of_serializable
Index: core-0.17.1/core/src/md5.mli
===================================================================
--- core-0.17.1.orig/core/src/md5.mli
+++ core-0.17.1/core/src/md5.mli
@@ -23,7 +23,7 @@ module As_binary_string : sig
     end
   end
 
-  type t = Stable.V1.t [@@deriving bin_io, sexp, sexp_grammar, hash]
+  type t = Stable.V1.t [@@deriving bin_io, quickcheck, sexp, sexp_grammar, hash]
 
   include Comparable with type t := t
   include Binable with type t := t
@@ -34,7 +34,7 @@ end
 
     Note that any 16-byte string can be converted to this type, so a value of type [t] is
     not an evidence of someone having found an input corresponding to this output. *)
-type t = Stable.V1.t [@@deriving bin_io, sexp, sexp_grammar, hash]
+type t = Stable.V1.t [@@deriving bin_io, quickcheck, sexp, sexp_grammar, hash]
 
 include Comparable with type t := t
 include Binable with type t := t
@@ -93,28 +93,28 @@ val string : string -> t [@@ocaml.deprec
 val bytes : bytes -> t [@@ocaml.deprecated "[since 2017-07] use [Md5.digest_bytes]."]
 
 val subbytes : bytes -> int -> int -> t
-  [@@ocaml.deprecated "[since 2017-07] use [Md5.digest_subbytes]."]
+[@@ocaml.deprecated "[since 2017-07] use [Md5.digest_subbytes]."]
 
 val from_hex : string -> t [@@ocaml.deprecated "[since 2017-07] use [of_hex_exn]."]
 
 val file : string -> t
-  [@@ocaml.deprecated
-    "[since 2017-07] blocking functions should be avoided. Use [file_blocking] if you \
-     really want this."]
+[@@ocaml.deprecated
+  "[since 2017-07] blocking functions should be avoided. Use [file_blocking] if you \
+   really want this."]
 
 val channel : in_channel -> int -> t
-  [@@ocaml.deprecated
-    "[since 2017-07] blocking functions should be avoided. Use [channel_blocking] if you \
-     really want this."]
+[@@ocaml.deprecated
+  "[since 2017-07] blocking functions should be avoided. Use [channel_blocking] if you \
+   really want this."]
 
 val output : out_channel -> t -> unit
-  [@@ocaml.deprecated
-    "[since 2017-07] Use [to_binary] together with [Out_channel.output_string]"]
+[@@ocaml.deprecated
+  "[since 2017-07] Use [to_binary] together with [Out_channel.output_string]"]
 
 val input : in_channel -> t
-  [@@ocaml.deprecated
-    "[since 2017-07] blocking functions should be avoided. Use [input_blocking] if you \
-     really want this."]
+[@@ocaml.deprecated
+  "[since 2017-07] blocking functions should be avoided. Use [input_blocking] if you \
+   really want this."]
 
 (** [digest_bin_prot w x] digests the serialization of [x] by [w].
     It is a cheap way (in dev time) to compute the digest of an ocaml value, for a
Index: core-0.17.1/core/src/md5_stubs.c
===================================================================
--- core-0.17.1.orig/core/src/md5_stubs.c
+++ core-0.17.1/core/src/md5_stubs.c
@@ -11,7 +11,7 @@
 #endif
 
 #if __GNUC__ < 8
-#ifndef _MSC_VER
+#if !defined(_MSC_VER) && !defined(__llvm__)
 #pragma GCC diagnostic ignored "-pedantic"
 #endif
 #endif
@@ -62,8 +62,7 @@ CAMLprim value core_md5_fd(value fd) {
 */
 #define MD5_CUTOFF (THREAD_IO_CUTOFF / 50)
 
-CAMLprim value core_md5_digest_subbigstring(value buf, value ofs, value vlen,
-                                            value res) {
+CAMLprim value core_md5_digest_subbigstring(value buf, value ofs, value vlen, value res) {
   CAMLparam2(buf, res);
   struct MD5Context ctx;
   unsigned char *data = (unsigned char *)Caml_ba_data_val(buf) + Long_val(ofs);
Index: core-0.17.1/core/src/modes.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/modes.ml
@@ -0,0 +1,35 @@
+module Stable = struct
+  module Global = struct
+    module V1 = struct
+      type 'a t = 'a Base.Modes.Global.t = { global : 'a }
+      [@@unboxed] [@@deriving quickcheck, stable_witness, typerep]
+
+      let compare = Base.Modes.Global.compare
+      let t_of_sexp = Base.Modes.Global.t_of_sexp
+      let sexp_of_t = Base.Modes.Global.sexp_of_t
+      let map t ~f = Base.Modes.Global.map t ~f
+
+      (* Implement bin-io without adding a UUID. Wrapping with a modality should not
+         change the bin-shape. *)
+      include
+        Binable0.Stable.Of_binable1.V1 [@alert "-legacy"]
+          (struct
+            type 'a t = 'a [@@deriving bin_io]
+          end)
+          (struct
+            type 'a t = 'a Base.Modes.Global.t
+
+            let to_binable = Base.Modes.Global.unwrap
+            let of_binable = Base.Modes.Global.wrap
+          end)
+    end
+  end
+end
+
+open! Base
+include Modes
+
+module Global = struct
+  include Stable.Global.V1
+  include Global
+end
Index: core-0.17.1/core/src/modes.mli
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/modes.mli
@@ -0,0 +1,27 @@
+open! Base
+
+module Global : sig
+  include module type of struct
+    include Modes.Global
+  end
+
+  include sig
+      type 'a t [@@deriving bin_io, quickcheck, typerep]
+    end
+    with type 'a t := 'a t
+end
+
+include module type of struct
+    include Modes
+  end [@remove_aliases]
+  with module Global := Global
+
+module Stable : sig
+  module Global : sig
+    module V1 : sig
+      type 'a t = 'a Global.t
+
+      include Stable_module_types.With_stable_witness.S1 with type 'a t := 'a t
+    end
+  end
+end
Index: core-0.17.1/core/src/month.ml
===================================================================
--- core-0.17.1.orig/core/src/month.ml
+++ core-0.17.1/core/src/month.ml
@@ -96,20 +96,20 @@ include (
     Hashable.S_binable with type t := t)
 
 include Comparable.Make_binable_using_comparator (struct
-  include T
+    include T
 
-  (* In 108.06a and earlier, months in sexps of Maps and Sets were raw ints.  From 108.07
+    (* In 108.06a and earlier, months in sexps of Maps and Sets were raw ints.  From 108.07
        through 109.13, the output format remained raw as before, but both the raw and
        pretty format were accepted as input.  From 109.14 on, the output format was
        changed from raw to pretty, while continuing to accept both formats.  Once we believe
        most programs are beyond 109.14, we will switch the input format to no longer accept
        raw. *)
-  let t_of_sexp sexp =
-    match Option.try_with (fun () -> Int.t_of_sexp sexp) with
-    | Some i -> of_int_exn (i + 1)
-    | None -> T.t_of_sexp sexp
-  ;;
-end)
+    let t_of_sexp sexp =
+      match Option.try_with (fun () -> Int.t_of_sexp sexp) with
+      | Some i -> of_int_exn (i + 1)
+      | None -> T.t_of_sexp sexp
+    ;;
+  end)
 
 (* Replace the overriden sexp converters from [Comparable.Make_binable] with the ordinary
    symbolic converters. *)
Index: core-0.17.1/core/src/month_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/month_intf.ml
+++ core-0.17.1/core/src/month_intf.ml
@@ -75,8 +75,8 @@ module type Month = sig
 
       include
         Stable_module_types.With_stable_witness.S0
-          with type comparator_witness = comparator_witness
-           and type t := t
+        with type comparator_witness = comparator_witness
+         and type t := t
     end
   end
 end
Index: core-0.17.1/core/src/ofday_float.ml
===================================================================
--- core-0.17.1.orig/core/src/ofday_float.ml
+++ core-0.17.1/core/src/ofday_float.ml
@@ -33,23 +33,23 @@ module Stable = struct
       type underlying = Float.t
 
       include (
-        struct
-          include Float
+      struct
+        include Float
 
-          let sign = sign_exn
+        let sign = sign_exn
 
-          let stable_witness : t Stable_witness.t =
-            Stable_witness.Export.stable_witness_float
-          ;;
-        end :
-          sig
-            type t = underlying [@@deriving bin_io, hash, typerep, stable_witness]
-
-            include Comparable.S_common with type t := t
-            include Comparable.With_zero with type t := t
-            include Robustly_comparable with type t := t
-            include Floatable with type t := t
-          end)
+        let stable_witness : t Stable_witness.t =
+          Stable_witness.Export.stable_witness_float
+        ;;
+      end :
+      sig
+        type t = underlying [@@deriving bin_io, hash, typerep, stable_witness]
+
+        include Comparable.S_common with type t := t
+        include Comparable.With_zero with type t := t
+        include Robustly_comparable with type t := t
+        include Floatable with type t := t
+      end)
 
       (* IF THIS REPRESENTATION EVER CHANGES, ENSURE THAT EITHER
          (1) all values serialize the same way in both representations, or
@@ -58,8 +58,8 @@ module Stable = struct
       (* due to precision limitations in float we can't expect better than microsecond
          precision *)
       include Float.Robust_compare.Make (struct
-        let robust_comparison_tolerance = 1E-6
-      end)
+          let robust_comparison_tolerance = 1E-6
+        end)
 
       let to_span_since_start_of_day t = Span.of_sec t
 
@@ -213,11 +213,11 @@ module Stable = struct
     let to_string t = to_string_gen ~drop_ms:false ~drop_us:false ~trim:false t
 
     include Pretty_printer.Register (struct
-      type nonrec t = t
+        type nonrec t = t
 
-      let to_string = to_string
-      let module_name = "Core.Time.Ofday"
-    end)
+        let to_string = to_string
+        let module_name = "Core.Time_float.Ofday"
+      end)
 
     let create_from_parsed string ~hr ~min ~sec ~subsec_pos ~subsec_len =
       let subsec =
@@ -254,8 +254,8 @@ module Stable = struct
     ;;
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, equal, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, equal, sexp]
+      end)
   end
 end
 
@@ -280,17 +280,17 @@ let quickcheck_observer =
 let quickcheck_shrinker = Quickcheck.Shrinker.empty ()
 
 include Hashable.Make_binable (struct
-  type nonrec t = t [@@deriving bin_io, compare, hash, sexp_of]
+    type nonrec t = t [@@deriving bin_io, compare, hash, sexp_of]
 
-  (* Previous versions rendered hash-based containers using float serialization rather
+    (* Previous versions rendered hash-based containers using float serialization rather
        than time serialization, so when reading hash-based containers in we accept either
        serialization. *)
-  let t_of_sexp sexp =
-    match Float.t_of_sexp sexp with
-    | float -> of_float float
-    | exception _ -> t_of_sexp sexp
-  ;;
-end)
+    let t_of_sexp sexp =
+      match Float.t_of_sexp sexp with
+      | float -> of_float float
+      | exception _ -> t_of_sexp sexp
+    ;;
+  end)
 
 module C = struct
   type t = T.t [@@deriving bin_io]
Index: core-0.17.1/core/src/ofday_float.mli
===================================================================
--- core-0.17.1.orig/core/src/ofday_float.mli
+++ core-0.17.1/core/src/ofday_float.mli
@@ -4,6 +4,6 @@ include Ofday_intf.S with type underlyin
 module Stable : sig
   module V1 : sig
     type nonrec t = t
-    [@@deriving bin_io, compare, hash, sexp, sexp_grammar, stable_witness, diff]
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness, diff]
   end
 end
Index: core-0.17.1/core/src/ofday_helpers.ml
===================================================================
--- core-0.17.1.orig/core/src/ofday_helpers.ml
+++ core-0.17.1/core/src/ofday_helpers.ml
@@ -6,7 +6,7 @@ let suffixes char =
   let sprintf = Printf.sprintf in
   [ sprintf "%c" char; sprintf "%cM" char; sprintf "%c.M" char; sprintf "%c.M." char ]
   |> List.concat_map ~f:(fun suffix ->
-       [ String.lowercase suffix; String.uppercase suffix ])
+    [ String.lowercase suffix; String.uppercase suffix ])
 ;;
 
 let am_suffixes = lazy (suffixes 'A')
Index: core-0.17.1/core/src/ofday_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/ofday_intf.ml
+++ core-0.17.1/core/src/ofday_intf.ml
@@ -83,7 +83,7 @@ module type S = sig
   val of_span_since_start_of_day_exn : Span.t -> t
 
   val of_span_since_start_of_day : Span.t -> t
-    [@@deprecated "[since 2018-04] use [of_span_since_start_of_day_exn] instead"]
+  [@@deprecated "[since 2018-04] use [of_span_since_start_of_day_exn] instead"]
 
   (** Reports whether a span represents a valid time since the start of the day, i.e.
       whether [of_span_since_start_of_day_exn span] would succeed. *)
@@ -132,5 +132,5 @@ module type S = sig
   val to_millisecond_string : t -> string
 
   val to_millisec_string : t -> string
-    [@@deprecated "[since 2018-04] use [to_millisecond_string] instead"]
+  [@@deprecated "[since 2018-04] use [to_millisecond_string] instead"]
 end
Index: core-0.17.1/core/src/ofday_ns.ml
===================================================================
--- core-0.17.1.orig/core/src/ofday_ns.ml
+++ core-0.17.1/core/src/ofday_ns.ml
@@ -36,8 +36,8 @@ let of_span_since_start_of_day_exn span
 ;;
 
 let of_span_since_start_of_day_opt span = if is_invalid span then None else Some span
-let add_exn t span = of_span_since_start_of_day_exn (Span.( + ) t span)
-let sub_exn t span = of_span_since_start_of_day_exn (Span.( - ) t span)
+let[@zero_alloc] add_exn t span = of_span_since_start_of_day_exn (Span.( + ) t span)
+let[@zero_alloc] sub_exn t span = of_span_since_start_of_day_exn (Span.( - ) t span)
 let add t span = of_span_since_start_of_day_opt (Span.( + ) t span)
 let sub t span = of_span_since_start_of_day_opt (Span.( - ) t span)
 let next t = of_span_since_start_of_day_opt (Span.next t)
@@ -60,13 +60,14 @@ module Stable = struct
   module Zoned = struct end
 
   module V1 = struct
-    type t = Span.Stable.V2.t [@@deriving bin_io, compare, equal, hash, stable_witness]
+    type t = Span.Stable.V2.t
+    [@@deriving bin_io, compare, equal, hash, stable_witness, typerep]
 
     include (
       Span.Stable.V2 :
         Comparator.S
-          with type t := t
-           and type comparator_witness = Span.Stable.V2.comparator_witness)
+        with type t := t
+         and type comparator_witness = Span.Stable.V2.comparator_witness)
 
     let to_string_with_unit =
       let ( / ) = Int63.( / ) in
@@ -197,34 +198,34 @@ module Stable = struct
     let of_int63_exn t = of_span_since_start_of_day_exn (Span_ns.Stable.V2.of_int63_exn t)
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, equal, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, equal, sexp]
+      end)
   end
 end
 
 include (
   Stable.V1 :
     Comparator.S
-      with type t := t
-       and type comparator_witness = Stable.V1.comparator_witness)
+    with type t := t
+     and type comparator_witness = Stable.V1.comparator_witness)
 
 include Identifiable.Make_using_comparator (struct
-  type t = Stable.V1.t [@@deriving bin_io, compare, hash, sexp]
+    type t = Stable.V1.t [@@deriving bin_io, compare, hash, sexp]
 
-  include (
-    Stable.V1 :
-      Comparator.S
+    include (
+      Stable.V1 :
+        Comparator.S
         with type t := t
          and type comparator_witness = Stable.V1.comparator_witness)
 
-  include (Stable.V1 : Stringable.S with type t := t)
+    include (Stable.V1 : Stringable.S with type t := t)
 
-  let module_name = "Core.Time_ns.Ofday"
-end)
+    let module_name = "Core.Time_ns.Ofday"
+  end)
 
 include Diffable.Atomic.Make (Stable.V1)
 
-let t_sexp_grammar = Sexplib.Sexp_grammar.coerce Stable.V1.t_sexp_grammar
+let t_sexp_grammar = Stable.V1.t_sexp_grammar
 let to_microsecond_string t = Stable.V1.to_string_with_unit t ~unit:`Microsecond
 let to_millisecond_string t = Stable.V1.to_string_with_unit t ~unit:`Millisecond
 let to_sec_string t = Stable.V1.to_string_with_unit t ~unit:`Second
@@ -322,12 +323,3 @@ include (Span : Comparisons.S with type
 (* deprecated bindings *)
 let of_span_since_start_of_day = of_span_since_start_of_day_exn
 let to_millisec_string = to_millisecond_string
-let arg_type = `Use_Time_ns_unix
-let now = `Use_Time_ns_unix
-let of_ofday_float_round_nearest = `Use_Time_ns_unix
-let of_ofday_float_round_nearest_microsecond = `Use_Time_ns_unix
-let to_ofday_float_round_nearest = `Use_Time_ns_unix
-let to_ofday_float_round_nearest_microsecond = `Use_Time_ns_unix
-
-module Option = struct end
-module Zoned = struct end
Index: core-0.17.1/core/src/ofday_ns.mli
===================================================================
--- core-0.17.1.orig/core/src/ofday_ns.mli
+++ core-0.17.1/core/src/ofday_ns.mli
@@ -3,12 +3,12 @@ include Time_ns_intf.Ofday with module S
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@deriving equal, hash, sexp_grammar]
+    type nonrec t = t [@@deriving equal, hash, sexp_grammar, typerep]
 
     include
       Stable_int63able.With_stable_witness.S
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
 
     include Diffable.S_atomic with type t := t
   end
Index: core-0.17.1/core/src/only_in_test.mli
===================================================================
--- core-0.17.1.orig/core/src/only_in_test.mli
+++ core-0.17.1/core/src/only_in_test.mli
@@ -35,7 +35,7 @@
 
 open! Import
 
-type 'a t
+type +'a t
 
 include Monad.S with type 'a t := 'a t
 
Index: core-0.17.1/core/src/option.ml
===================================================================
--- core-0.17.1.orig/core/src/option.ml
+++ core-0.17.1/core/src/option.ml
@@ -4,8 +4,8 @@ include Base.Option
 type 'a t = 'a option [@@deriving bin_io ~localize, typerep, stable_witness]
 
 include Comparator.Derived (struct
-  type nonrec 'a t = 'a t [@@deriving sexp_of, compare]
-end)
+    type nonrec 'a t = 'a t [@@deriving sexp_of, compare]
+  end)
 
 let validate ~none ~some t =
   let module V = Validate in
Index: core-0.17.1/core/src/option_array.ml
===================================================================
--- core-0.17.1.orig/core/src/option_array.ml
+++ core-0.17.1/core/src/option_array.ml
@@ -1,14 +1,27 @@
 open! Import
+open! Base_quickcheck.Export
 include Base.Option_array
 
+module Array_of_options = struct
+  type 'a t = 'a option array [@@deriving sexp, bin_io, quickcheck]
+end
+
 include
   Binable.Of_binable1_without_uuid [@alert "-legacy"]
-    (struct
-      type 'a t = 'a option array [@@deriving sexp, bin_io]
-    end)
+    (Array_of_options)
     (struct
       type nonrec 'a t = 'a t
 
       let to_binable = to_array
       let of_binable = of_array
     end)
+
+include
+  Quickcheckable.Of_quickcheckable1
+    (Array_of_options)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_array
+      let of_quickcheckable = of_array
+    end)
Index: core-0.17.1/core/src/option_array.mli
===================================================================
--- core-0.17.1.orig/core/src/option_array.mli
+++ core-0.17.1/core/src/option_array.mli
@@ -3,7 +3,7 @@
 
 open! Import
 
-type 'a t = 'a Base.Option_array.t [@@deriving bin_io, sexp]
+type 'a t = 'a Base.Option_array.t [@@deriving bin_io, quickcheck, sexp, sexp_grammar]
 
 include module type of struct
     include Base.Option_array
Index: core-0.17.1/core/src/optional_syntax_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/optional_syntax_intf.ml
+++ core-0.17.1/core/src/optional_syntax_intf.ml
@@ -10,6 +10,16 @@ module type S = sig
   end
 end
 
+module type S_zero_alloc = sig
+  type t
+  type value
+
+  module Optional_syntax : sig
+    val is_none : t -> bool [@@zero_alloc]
+    val unsafe_value : t -> value [@@zero_alloc]
+  end
+end
+
 module type S1 = sig
   type 'a t
   type 'a value
@@ -82,6 +92,7 @@ module type Optional_syntax = sig
       For more details on the syntax extension, see [ppx/ppx_optional/README.md]. *)
 
   module type S = S
+  module type S_zero_alloc = S_zero_alloc
   module type S1 = S1
   module type S2 = S2
 end
Index: core-0.17.1/core/src/ordering.ml
===================================================================
--- core-0.17.1.orig/core/src/ordering.ml
+++ core-0.17.1/core/src/ordering.ml
@@ -4,7 +4,7 @@ type t = Base.Ordering.t =
   | Less
   | Equal
   | Greater
-[@@deriving bin_io, compare, hash, sexp]
+[@@deriving bin_io, compare, hash, sexp, sexp_grammar]
 
 module type Base_mask = module type of Base.Ordering with type t := t
 
Index: core-0.17.1/core/src/ordering.mli
===================================================================
--- core-0.17.1.orig/core/src/ordering.mli
+++ core-0.17.1/core/src/ordering.mli
@@ -8,6 +8,6 @@ type t = Base.Ordering.t =
   | Less
   | Equal
   | Greater
-[@@deriving bin_io, compare, hash, sexp]
+[@@deriving bin_io, compare, hash, sexp, sexp_grammar]
 
 include module type of Base.Ordering with type t := t (** @inline *)
Index: core-0.17.1/core/src/percent.ml
===================================================================
--- core-0.17.1.orig/core/src/percent.ml
+++ core-0.17.1/core/src/percent.ml
@@ -139,15 +139,15 @@ module Stable = struct
         ; "1.47651E+10"
         ]
         ~f:(fun s ->
-        printf "== %s ==\n" s;
-        let x = Float.of_string s in
-        List.iter [ -40; -10; -2; -1; 0; 1; 2; 10; 40 ] ~f:(fun by ->
-          let s1 = shift_decimal_point s ~by in
-          printf "%s\n" s1;
-          let x1 = Float.of_string s1 in
-          let x2 = x *. (10. ** float by) in
-          assert (Float.(x1 = x2 || abs ((x1 - x2) / x1) < 1e-6) : bool));
-        printf "--------------------------------------------------\n");
+          printf "== %s ==\n" s;
+          let x = Float.of_string s in
+          List.iter [ -40; -10; -2; -1; 0; 1; 2; 10; 40 ] ~f:(fun by ->
+            let s1 = shift_decimal_point s ~by in
+            printf "%s\n" s1;
+            let x1 = Float.of_string s1 in
+            let x2 = x *. (10. ** float by) in
+            assert (Float.(x1 = x2 || abs ((x1 - x2) / x1) < 1e-6) : bool));
+          printf "--------------------------------------------------\n");
       (* Note "-0.000e13" is not adjusted *)
       [%expect
         {|
@@ -337,12 +337,12 @@ module Stable = struct
     ;;
 
     include Comparable.Make_binable (struct
-      type nonrec t = t [@@deriving bin_io, compare, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, compare, sexp]
+      end)
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, equal, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, equal, sexp]
+      end)
 
     module Always_percentage = struct
       type nonrec t = t [@@deriving sexp, bin_io]
@@ -492,15 +492,15 @@ module Stable = struct
     ;;
 
     include Comparable.Make_binable_using_comparator (struct
-      type nonrec t = t [@@deriving bin_io, compare, sexp]
-      type comparator_witness = V3.comparator_witness
+        type nonrec t = t [@@deriving bin_io, compare, sexp]
+        type comparator_witness = V3.comparator_witness
 
-      let comparator = V3.comparator
-    end)
+        let comparator = V3.comparator
+      end)
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, sexp, equal]
-    end)
+        type nonrec t = t [@@deriving bin_io, sexp, equal]
+      end)
 
     type comparator_witness = V3.comparator_witness
   end
@@ -512,25 +512,25 @@ module Stable = struct
       let bin_shape_t = Float.bin_shape_t
 
       include Comparable.Make_binable_using_comparator (struct
-        type nonrec t = t [@@deriving compare, sexp_of, bin_io]
-        type comparator_witness = V3.comparator_witness
+          type nonrec t = t [@@deriving compare, sexp_of, bin_io]
+          type comparator_witness = V3.comparator_witness
 
-        let comparator = V3.comparator
+          let comparator = V3.comparator
 
-        (* Previous versions rendered comparable-based containers using float
+          (* Previous versions rendered comparable-based containers using float
              serialization rather than percent serialization, so when reading
              comparable-based containers in we accept either serialization.
           *)
-        let t_of_sexp sexp =
-          match Float.t_of_sexp sexp with
-          | float -> float
-          | exception _ -> t_of_sexp sexp
-        ;;
-      end)
+          let t_of_sexp sexp =
+            match Float.t_of_sexp sexp with
+            | float -> float
+            | exception _ -> t_of_sexp sexp
+          ;;
+        end)
 
       include Diffable.Atomic.Make (struct
-        type nonrec t = t [@@deriving bin_io, equal, sexp]
-      end)
+          type nonrec t = t [@@deriving bin_io, equal, sexp]
+        end)
     end
 
     include Bin_shape_same_as_float
@@ -565,7 +565,8 @@ module Stable = struct
     end
 
     module V3 = struct
-      type t = V3.t [@@deriving bin_io, compare, equal, hash, typerep, stable_witness]
+      type t = V3.t
+      [@@deriving bin_io, compare, equal, globalize, hash, stable_witness, typerep]
 
       let bin_shape_t =
         Bin_prot.Shape.basetype
@@ -581,7 +582,7 @@ module Stable = struct
     end
 
     module V2 = struct
-      type t = V2.t [@@deriving bin_io, compare, hash, typerep, stable_witness]
+      type t = V2.t [@@deriving bin_io, compare, globalize, hash, stable_witness, typerep]
 
       let bin_shape_t =
         Bin_prot.Shape.basetype
@@ -614,6 +615,18 @@ module Option = struct
   module Stable = Stable.Option
   include Stable.V1.Bin_shape_same_as_float
 
+  include
+    Quickcheckable.Of_quickcheckable
+      (struct
+        type t = float option [@@deriving quickcheck]
+      end)
+      (struct
+        type nonrec t = t
+
+        let to_quickcheckable = to_option
+        let of_quickcheckable = of_option
+      end)
+
   module Optional_syntax = struct
     module Optional_syntax = struct
       let is_none = is_none
@@ -627,34 +640,34 @@ let apply t f = t *. f
 let scale t f = t *. f
 
 include (
-  struct
-    include Float
+struct
+  include Float
 
-    let one_hundred_percent = 1.
-    let ( // ) x y = of_mult x /. of_mult y
-  end :
-    sig
-      val zero : t
-      val one_hundred_percent : t
-      val ( * ) : t -> t -> t
-      val ( + ) : t -> t -> t
-      val ( - ) : t -> t -> t
-      val ( / ) : t -> t -> t
-      val ( // ) : t -> t -> float
-      val abs : t -> t
-      val neg : t -> t
-      val is_nan : t -> bool
-      val is_inf : t -> bool
-      val sign_exn : t -> Sign.t
+  let one_hundred_percent = 1.
+  let ( // ) x y = of_mult x /. of_mult y
+end :
+sig
+  val zero : t
+  val one_hundred_percent : t
+  val ( * ) : t -> t -> t
+  val ( + ) : t -> t -> t
+  val ( - ) : t -> t -> t
+  val ( / ) : t -> t -> t
+  val ( // ) : t -> t -> float
+  val abs : t -> t
+  val neg : t -> t
+  val is_nan : t -> bool
+  val is_inf : t -> bool
+  val sign_exn : t -> Sign.t
 
-      include Robustly_comparable with type t := t
-    end)
+  include Robustly_comparable with type t := t
+end)
 
 include Comparable.With_zero (struct
-  include Stable.V1.Bin_shape_same_as_float
+    include Stable.V1.Bin_shape_same_as_float
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 let validate = Float.validate_ordinary
 let of_string_allow_nan_and_inf s = Stringable.of_string_allow_nan_and_inf s
Index: core-0.17.1/core/src/percent.mli
===================================================================
--- core-0.17.1.orig/core/src/percent.mli
+++ core-0.17.1/core/src/percent.mli
@@ -41,7 +41,7 @@ include Quickcheckable.S with type t :=
 (** The value [nan] cannot be represented as an [Option.t] *)
 module Option : sig
   type value := t
-  type t = private float [@@deriving bin_io, sexp_grammar]
+  type t = private float [@@deriving bin_io, globalize, quickcheck, sexp_grammar]
 
   include Immediate_option.S_without_immediate with type value := value and type t := t
 
@@ -322,8 +322,8 @@ module Stable : sig
 
     include
       Comparable_binable
-        with type t := t
-         and type comparator_witness := comparator_witness
+      with type t := t
+       and type comparator_witness := comparator_witness
 
     val to_string : t -> string
     val of_string : string -> t
@@ -345,12 +345,14 @@ module Stable : sig
     module V1 : sig
       (** See comment for [Stable.V1.Bin_shape_same_as_float]. *)
       module Bin_shape_same_as_float : sig
-        type t = Option.t [@@deriving bin_io, compare, hash, sexp, stable_witness]
+        type t = Option.t
+        [@@deriving bin_io, compare, hash, sexp, sexp_grammar, stable_witness]
       end
     end
 
     module V2 : sig
-      type t = Option.t [@@deriving bin_io, compare, hash, sexp, stable_witness]
+      type t = Option.t
+      [@@deriving bin_io, compare, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module V3 : sig
Index: core-0.17.1/core/src/perms.ml
===================================================================
--- core-0.17.1.orig/core/src/perms.ml
+++ core-0.17.1/core/src/perms.ml
@@ -6,25 +6,26 @@ module Binable = Binable0
    exceptions. *)
 module Types = struct
   module Nobody = struct
-    type t [@@deriving bin_io, compare, equal, hash, sexp]
+    type t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Nobody"
   end
 
   module Me = struct
-    type t [@@deriving bin_io, compare, equal, hash, sexp]
+    type t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Me"
   end
 
   module Read = struct
-    type t = [ `Read ] [@@deriving bin_io, compare, equal, hash, sexp]
+    type t = [ `Read ] [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Read"
   end
 
   module Write = struct
-    type t = [ `Who_can_write of Me.t ] [@@deriving bin_io, compare, equal, hash, sexp]
+    type t = [ `Who_can_write of Me.t ]
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Write"
   end
@@ -34,7 +35,7 @@ module Types = struct
       [ Read.t
       | `Who_can_write of Nobody.t
       ]
-    [@@deriving bin_io, compare, equal, hash, sexp]
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Immutable"
   end
@@ -44,7 +45,7 @@ module Types = struct
       [ Read.t
       | Write.t
       ]
-    [@@deriving bin_io, compare, equal, hash, sexp]
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Read_write"
   end
@@ -54,7 +55,7 @@ module Types = struct
       [ Read.t
       | `Who_can_write of 'a
       ]
-    [@@deriving bin_io, compare, equal, hash, sexp]
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
     let name = "Upper_bound"
   end
@@ -71,8 +72,8 @@ end
 
 (* Override all bin_io, sexp, compare functions to raise exceptions *)
 module Only_used_as_phantom_type1 (Name : sig
-  val name : string
-end) : Sexpable_binable_comparable = struct
+    val name : string
+  end) : Sexpable_binable_comparable = struct
   type 'a t = 'a
 
   let sexp_of_t _ _ = failwithf "Unexpectedly called [%s.sexp_of_t]" Name.name ()
@@ -103,16 +104,17 @@ end) : Sexpable_binable_comparable = str
 end
 
 module Only_used_as_phantom_type0 (T : sig
-  type t [@@deriving bin_io, compare, equal, hash, sexp]
+    type t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
-  val name : string
-end) : sig
+    val name : string
+  end) : sig
   type t = T.t
-  [@@deriving bin_io, compare, equal, globalize, hash, sexp_poly, stable_witness]
+  [@@deriving
+    bin_io, compare, equal, globalize, hash, sexp_poly, sexp_grammar, stable_witness]
 end = struct
   module M = Only_used_as_phantom_type1 (T)
 
-  type t = T.t M.t [@@deriving bin_io, equal, compare, hash, sexp]
+  type t = T.t M.t [@@deriving bin_io, equal, compare, hash, sexp, sexp_grammar]
 
   let __t_of_sexp__ = t_of_sexp
   let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
@@ -128,14 +130,17 @@ module Stable = struct
     module Read_write = Only_used_as_phantom_type0 (Types.Read_write)
     module Immutable = Only_used_as_phantom_type0 (Types.Immutable)
 
-    type nobody = Nobody.t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
-    type me = Me.t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+    type nobody = Nobody.t
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
+
+    type me = Me.t
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
 
     module Upper_bound = struct
       module M = Only_used_as_phantom_type1 (Types.Upper_bound)
 
       type 'a t = 'a Types.Upper_bound.t M.t
-      [@@deriving bin_io, compare, equal, hash, sexp]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
       let stable_witness _ = Stable_witness.assert_stable
       let __t_of_sexp__ = t_of_sexp
@@ -148,19 +153,23 @@ module Stable = struct
 
   module Export = struct
     type read = V1.Read.t
-    [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+    [@@deriving
+      bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
 
     type write = V1.Write.t
-    [@@deriving compare, equal, hash, globalize, sexp, stable_witness]
+    [@@deriving compare, equal, hash, globalize, sexp, sexp_grammar, stable_witness]
 
     type immutable = V1.Immutable.t
-    [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+    [@@deriving
+      bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
 
     type read_write = V1.Read_write.t
-    [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+    [@@deriving
+      bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
 
     type 'a perms = 'a V1.Upper_bound.t
-    [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+    [@@deriving
+      bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
   end
 end
 
Index: core-0.17.1/core/src/perms.mli
===================================================================
--- core-0.17.1.orig/core/src/perms.mli
+++ core-0.17.1/core/src/perms.mli
@@ -111,16 +111,17 @@ open! Import
 
 (** Every type in this module besides the following two represent permission sets; these
     two represent who is allowed to write in the [Write.t] and [Immutable.t] types. *)
-type nobody [@@deriving bin_io, compare, equal, hash, sexp]
+type nobody [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
-type me [@@deriving bin_io, compare, equal, hash, sexp]
+type me [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 
 module Read : sig
-  type t = [ `Read ] [@@deriving bin_io, compare, equal, hash, sexp]
+  type t = [ `Read ] [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 module Write : sig
-  type t = [ `Who_can_write of me ] [@@deriving bin_io, compare, equal, hash, sexp]
+  type t = [ `Who_can_write of me ]
+  [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 module Immutable : sig
@@ -128,7 +129,7 @@ module Immutable : sig
     [ Read.t
     | `Who_can_write of nobody
     ]
-  [@@deriving bin_io, compare, equal, hash, sexp]
+  [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 module Read_write : sig
@@ -136,7 +137,7 @@ module Read_write : sig
     [ Read.t
     | Write.t
     ]
-  [@@deriving bin_io, compare, equal, hash, sexp]
+  [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 module Upper_bound : sig
@@ -144,55 +145,61 @@ module Upper_bound : sig
     [ Read.t
     | `Who_can_write of 'a
     ]
-  [@@deriving bin_io, compare, equal, hash, sexp]
+  [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
 end
 
 module Export : sig
   type read = Read.t
-  [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness, equal]
+  [@@deriving
+    bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness, equal]
 
   (** We don't expose [bin_io] for [write] due to a naming conflict with the functions
       exported by [bin_io] for [read_write].  If you want [bin_io] for [write], use
       [Write.t]. *)
-  type write = Write.t [@@deriving compare, equal, hash, globalize, sexp, stable_witness]
+  type write = Write.t
+  [@@deriving compare, equal, hash, globalize, sexp, sexp_grammar, stable_witness]
 
   type immutable = Immutable.t
-  [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+  [@@deriving bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
 
   type read_write = Read_write.t
-  [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+  [@@deriving bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
 
   type 'a perms = 'a Upper_bound.t
-  [@@deriving bin_io, compare, equal, globalize, hash, sexp, stable_witness]
+  [@@deriving bin_io, compare, equal, globalize, hash, sexp, sexp_grammar, stable_witness]
 end
 
 module Stable : sig
   module V1 : sig
     type nonrec nobody = nobody
-    [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
 
-    type nonrec me = me [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+    type nonrec me = me
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
 
     module Read : sig
-      type t = Read.t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      type t = Read.t
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module Write : sig
-      type t = Write.t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      type t = Write.t
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module Immutable : sig
-      type t = Immutable.t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      type t = Immutable.t
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module Read_write : sig
       type t = Read_write.t
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
 
     module Upper_bound : sig
       type 'a t = 'a Upper_bound.t
-      [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
     end
   end
 
Index: core-0.17.1/core/src/pid.ml
===================================================================
--- core-0.17.1.orig/core/src/pid.ml
+++ core-0.17.1/core/src/pid.ml
@@ -17,6 +17,10 @@ module Stable = struct
             let of_sexpable = ensure
           end)
 
+      let t_sexp_grammar : t Sexplib.Sexp_grammar.t =
+        Sexplib.Sexp_grammar.coerce Int.Stable.V1.t_sexp_grammar
+      ;;
+
       include
         Binable.Stable.Of_binable.V1 [@alert "-legacy"]
           (Int.Stable.V1)
@@ -59,11 +63,11 @@ include
     end)
 
 include Identifiable.Make_using_comparator (struct
-  type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
-  type nonrec comparator_witness = comparator_witness
+    type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
+    type nonrec comparator_witness = comparator_witness
 
-  let comparator = comparator
-  let of_string = of_string
-  let to_string = to_string
-  let module_name = "Core.Pid"
-end)
+    let comparator = comparator
+    let of_string = of_string
+    let to_string = to_string
+    let module_name = "Core.Pid"
+  end)
Index: core-0.17.1/core/src/pid.mli
===================================================================
--- core-0.17.1.orig/core/src/pid.mli
+++ core-0.17.1/core/src/pid.mli
@@ -2,7 +2,7 @@
 
 open! Import
 
-type t [@@deriving bin_io, hash, sexp, quickcheck] [@@immediate]
+type t [@@deriving bin_io, hash, sexp, sexp_grammar, quickcheck] [@@immediate]
 
 include Identifiable.S with type t := t
 
@@ -18,7 +18,7 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
   end
 end
Index: core-0.17.1/core/src/queue.ml
===================================================================
--- core-0.17.1.orig/core/src/queue.ml
+++ core-0.17.1/core/src/queue.ml
@@ -2,28 +2,38 @@ open! Import
 include Base.Queue
 
 include Test_binary_searchable.Make1_and_test (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let get = get
-  let length = length
+    let get = get
+    let length = length
 
-  module For_test = struct
-    let of_array a =
-      let r = create () in
-      (* We enqueue everything twice, and dequeue it once to ensure:
+    module For_test = struct
+      let of_array a =
+        let r = create () in
+        (* We enqueue everything twice, and dequeue it once to ensure:
            - that the queue has the same content as the array.
            - that it has, in most cases, an interesting internal structure*)
-      for i = 0 to Array.length a - 1 do
-        enqueue r a.(i)
-      done;
-      for i = 0 to Array.length a - 1 do
-        ignore (dequeue_exn r : bool);
-        enqueue r a.(i)
-      done;
-      r
-    ;;
-  end
-end)
+        for i = 0 to Array.length a - 1 do
+          enqueue r a.(i)
+        done;
+        for i = 0 to Array.length a - 1 do
+          ignore (dequeue_exn r : bool);
+          enqueue r a.(i)
+        done;
+        r
+      ;;
+    end
+  end)
+
+include
+  Quickcheckable.Of_quickcheckable1
+    (List)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_list
+      let of_quickcheckable = of_list
+    end)
 
 module Serialization_v1 = struct
   let sexp_of_t = sexp_of_t
@@ -31,18 +41,18 @@ module Serialization_v1 = struct
   let t_sexp_grammar = t_sexp_grammar
 
   include Bin_prot.Utils.Make_iterable_binable1 (struct
-    type nonrec 'a t = 'a t
-    type 'a el = 'a [@@deriving bin_io]
-
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "b4c84254-4992-11e6-9ba7-734e154027bd"
-    ;;
+      type nonrec 'a t = 'a t
+      type 'a el = 'a [@@deriving bin_io]
 
-    let module_name = Some "Core.Queue"
-    let length = length
-    let iter = iter
-    let init ~len ~next = init len ~f:(fun _ -> next ())
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "b4c84254-4992-11e6-9ba7-734e154027bd"
+      ;;
+
+      let module_name = Some "Core.Queue"
+      let length = length
+      let iter = iter
+      let init ~len ~next = init len ~f:(fun _ -> next ())
+    end)
 
   let stable_witness (_ : 'a Stable_witness.t) : 'a t Stable_witness.t =
     (* Serialization_v1 defines a stable serialization *)
@@ -54,7 +64,7 @@ include Serialization_v1
 
 module Stable = struct
   module V1 = struct
-    type nonrec 'a t = 'a t [@@deriving compare, equal]
+    type nonrec 'a t = 'a t [@@deriving compare, equal, quickcheck]
 
     include Serialization_v1
 
Index: core-0.17.1/core/src/queue.mli
===================================================================
--- core-0.17.1.orig/core/src/queue.mli
+++ core-0.17.1/core/src/queue.mli
@@ -2,7 +2,7 @@
 
 open! Import
 
-type 'a t = 'a Base.Queue.t [@@deriving sexp_of, bin_io]
+type 'a t = 'a Base.Queue.t [@@deriving sexp_of, bin_io, quickcheck]
 
 (** {2 The interface from Base} *)
 
Index: core-0.17.1/core/src/quickcheck.ml
===================================================================
--- core-0.17.1.orig/core/src/quickcheck.ml
+++ core-0.17.1/core/src/quickcheck.ml
@@ -344,18 +344,18 @@ module Configure (Config : Quickcheck_co
 end
 
 include Configure (struct
-  let default_seed = `Deterministic "an arbitrary but deterministic string"
+    let default_seed = `Deterministic "an arbitrary but deterministic string"
 
-  let default_trial_count =
-    match Word_size.word_size with
-    | W64 -> 10_000
-    | W32 -> 1_000
-  ;;
+    let default_trial_count =
+      match Word_size.word_size with
+      | W64 -> 10_000
+      | W32 -> 1_000
+    ;;
 
-  let default_can_generate_trial_count = 10_000
-  let default_shrink_attempts = `Limit 1000
-  let default_sizes = Sequence.cycle_list_exn (List.range 0 30 ~stop:`inclusive)
-end)
+    let default_can_generate_trial_count = 10_000
+    let default_shrink_attempts = `Limit 1000
+    let default_sizes = Sequence.cycle_list_exn (List.range 0 30 ~stop:`inclusive)
+  end)
 
 module type S = S
 module type S1 = S1
Index: core-0.17.1/core/src/quickcheck_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/quickcheck_intf.ml
+++ core-0.17.1/core/src/quickcheck_intf.ml
@@ -632,13 +632,13 @@ module type Syntax = sig
 
   module Open_on_rhs :
     Generator
-      with type 'a t := 'a Generator.t
-       and module Let_syntax := Generator.Let_syntax
+    with type 'a t := 'a Generator.t
+     and module Let_syntax := Generator.Let_syntax
 
   include
     Monad.Syntax
-      with type 'a t := 'a Generator.t
-       and module Let_syntax.Let_syntax.Open_on_rhs = Open_on_rhs
+    with type 'a t := 'a Generator.t
+     and module Let_syntax.Let_syntax.Open_on_rhs = Open_on_rhs
 end
 
 module type Quickcheck = sig
Index: core-0.17.1/core/src/quickcheckable.ml
===================================================================
--- core-0.17.1.orig/core/src/quickcheckable.ml
+++ core-0.17.1/core/src/quickcheckable.ml
@@ -11,8 +11,8 @@ module type S2 = Quickcheck.S2
 module type S_int = Quickcheck.S_int
 
 module Of_quickcheckable
-  (Quickcheckable : S)
-  (Conv : Conv with type quickcheckable := Quickcheckable.t) : S with type t := Conv.t =
+    (Quickcheckable : S)
+    (Conv : Conv with type quickcheckable := Quickcheckable.t) : S with type t := Conv.t =
 struct
   let quickcheck_generator =
     Quickcheck.Generator.map Quickcheckable.quickcheck_generator ~f:Conv.of_quickcheckable
@@ -31,8 +31,8 @@ struct
 end
 
 module Of_quickcheckable1
-  (Quickcheckable : S1)
-  (Conv : Conv1 with type 'a quickcheckable := 'a Quickcheckable.t) :
+    (Quickcheckable : S1)
+    (Conv : Conv1 with type 'a quickcheckable := 'a Quickcheckable.t) :
   S1 with type 'a t := 'a Conv.t = struct
   let quickcheck_generator generate_a =
     Quickcheck.Generator.map
@@ -55,8 +55,8 @@ module Of_quickcheckable1
 end
 
 module Of_quickcheckable_filtered
-  (Quickcheckable : S)
-  (Conv : Conv_filtered with type quickcheckable := Quickcheckable.t) :
+    (Quickcheckable : S)
+    (Conv : Conv_filtered with type quickcheckable := Quickcheckable.t) :
   S with type t := Conv.t = struct
   let quickcheck_generator =
     Quickcheck.Generator.filter_map
@@ -77,8 +77,8 @@ module Of_quickcheckable_filtered
 end
 
 module Of_quickcheckable_filtered1
-  (Quickcheckable : S1)
-  (Conv : Conv_filtered1 with type 'a quickcheckable := 'a Quickcheckable.t) :
+    (Quickcheckable : S1)
+    (Conv : Conv_filtered1 with type 'a quickcheckable := 'a Quickcheckable.t) :
   S1 with type 'a t := 'a Conv.t = struct
   let quickcheck_generator generate_a =
     Quickcheck.Generator.filter_map
Index: core-0.17.1/core/src/quickcheckable_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/quickcheckable_intf.ml
+++ core-0.17.1/core/src/quickcheckable_intf.ml
@@ -44,21 +44,21 @@ module type Quickcheckable = sig
   module type S_int = Quickcheck.S_int
 
   module Of_quickcheckable
-    (Quickcheckable : S)
-    (Conv : Conv with type quickcheckable := Quickcheckable.t) : S with type t := Conv.t
+      (Quickcheckable : S)
+      (Conv : Conv with type quickcheckable := Quickcheckable.t) : S with type t := Conv.t
 
   module Of_quickcheckable1
-    (Quickcheckable : S1)
-    (Conv : Conv1 with type 'a quickcheckable := 'a Quickcheckable.t) :
+      (Quickcheckable : S1)
+      (Conv : Conv1 with type 'a quickcheckable := 'a Quickcheckable.t) :
     S1 with type 'a t := 'a Conv.t
 
   module Of_quickcheckable_filtered
-    (Quickcheckable : S)
-    (Conv : Conv_filtered with type quickcheckable := Quickcheckable.t) :
+      (Quickcheckable : S)
+      (Conv : Conv_filtered with type quickcheckable := Quickcheckable.t) :
     S with type t := Conv.t
 
   module Of_quickcheckable_filtered1
-    (Quickcheckable : S1)
-    (Conv : Conv_filtered1 with type 'a quickcheckable := 'a Quickcheckable.t) :
+      (Quickcheckable : S1)
+      (Conv : Conv_filtered1 with type 'a quickcheckable := 'a Quickcheckable.t) :
     S1 with type 'a t := 'a Conv.t
 end
Index: core-0.17.1/core/src/ref.ml
===================================================================
--- core-0.17.1.orig/core/src/ref.ml
+++ core-0.17.1/core/src/ref.ml
@@ -5,13 +5,13 @@ module T = struct
   include Base.Ref
 
   include (
-    struct
+  struct
+    type 'a t = 'a ref [@@deriving bin_io ~localize, quickcheck, typerep]
+  end :
+    sig
       type 'a t = 'a ref [@@deriving bin_io ~localize, quickcheck, typerep]
-    end :
-      sig
-        type 'a t = 'a ref [@@deriving bin_io ~localize, quickcheck, typerep]
-      end
-      with type 'a t := 'a t)
+    end
+    with type 'a t := 'a t)
 end
 
 include T
@@ -19,7 +19,7 @@ include T
 module Permissioned = struct
   include T
 
-  type ('a, -'perms) t = 'a T.t [@@deriving bin_io ~localize, sexp]
+  type ('a, -'perms) t = 'a T.t [@@deriving bin_io ~localize, sexp, sexp_grammar]
 
   let read_only = Fn.id
   let of_ref = Fn.id
Index: core-0.17.1/core/src/ref.mli
===================================================================
--- core-0.17.1.orig/core/src/ref.mli
+++ core-0.17.1/core/src/ref.mli
@@ -13,7 +13,7 @@ include module type of struct
   with type 'a t := 'a t
 
 module Permissioned : sig
-  type (!'a, -'perms) t [@@deriving sexp, bin_io ~localize]
+  type (!'a, -'perms) t [@@deriving sexp, sexp_grammar, bin_io ~localize]
 
   val create : 'a -> ('a, [< _ perms ]) t
   val read_only : ('a, [> read ]) t -> ('a, read) t
Index: core-0.17.1/core/src/result.mli
===================================================================
--- core-0.17.1.orig/core/src/result.mli
+++ core-0.17.1/core/src/result.mli
@@ -5,7 +5,8 @@ open! Import
 type ('a, 'b) t = ('a, 'b) Base.Result.t =
   | Ok of 'a
   | Error of 'b
-[@@deriving bin_io ~localize, compare, equal, globalize, hash, typerep, sexp, diff]
+[@@deriving
+  bin_io ~localize, compare, diff, equal, globalize, hash, sexp, sexp_grammar, typerep]
 
 include module type of Base.Result with type ('a, 'b) t := ('a, 'b) t (** @inline *)
 
@@ -21,9 +22,9 @@ module Stable : sig
 
     include
       Diffable.S2
-        with type ('ok, 'err) t := ('ok, 'err) t
-         and type ('ok, 'err, 'ok_diff, 'err_diff) Diff.t =
-          ('ok, 'err, 'ok_diff, 'err_diff) Diff.t
+      with type ('ok, 'err) t := ('ok, 'err) t
+       and type ('ok, 'err, 'ok_diff, 'err_diff) Diff.t =
+        ('ok, 'err, 'ok_diff, 'err_diff) Diff.t
   end
 
   (** We export the unit test arg rather than instantiate the functor inside result.ml in
Index: core-0.17.1/core/src/runtime.wat
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/runtime.wat
@@ -0,0 +1,234 @@
+(module
+   (import "env" "caml_array_blit"
+      (func $caml_array_blit
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq))
+         (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_floatarray_blit"
+      (func $caml_floatarray_blit
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq))
+         (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_global"
+      (func $caml_js_global (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_get"
+      (func $caml_js_get (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_new"
+      (func $caml_js_new (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_fun_call"
+      (func $caml_js_fun_call
+         (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_from_array"
+      (func $caml_js_from_array (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_js_from_float"
+      (func $caml_js_from_float (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_pure_js_expr"
+      (func $caml_pure_js_expr (param (ref eq)) (result (ref eq))))
+   (import "env" "wrap" (func $wrap (param anyref) (result (ref eq))))
+   (import "env" "caml_string_of_jsstring"
+      (func $caml_string_of_jsstring (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_jsstring_of_string"
+      (func $caml_jsstring_of_string (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_md5_chan"
+      (func $caml_md5_chan (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_ml_open_descriptor_in"
+      (func $caml_ml_open_descriptor_in (param (ref eq)) (result (ref eq))))
+   (import "env" "ocaml_exception" (tag $ocaml_exception (param (ref eq))))
+   (import "env" "caml_create_bytes"
+      (func $caml_create_bytes (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_blit_string"
+      (func $caml_blit_string
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq))
+         (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_md5_string"
+      (func $caml_md5_string
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_bigstring_blit_ba_to_bytes"
+      (func $bigstring_blit_bigstring_bytes_stub
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq))
+         (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_invalid_argument"
+      (func $caml_invalid_argument (param (ref eq))))
+   (import "env" "caml_ba_alloc"
+      (func $caml_ba_alloc
+         (param i32) (param i32) (param i32) (param (ref extern))
+         (param (ref $int_array))
+         (result (ref eq))))
+   (import "env" "caml_ba_get_kind"
+      (func $caml_ba_get_kind (param (ref eq)) (result i32)))
+   (import "env" "caml_ba_get_layout"
+      (func $caml_ba_get_layout (param (ref eq)) (result i32)))
+   (import "env" "caml_ba_create_buffer"
+      (func $caml_ba_create_buffer
+         (param i32) (param i32) (result (ref extern))))
+   (import "env" "caml_ba_get_data"
+      (func $caml_ba_get_data (param (ref eq)) (result (ref extern))))
+   (import "env" "caml_ba_set_data"
+      (func $caml_ba_set_data (param (ref eq)) (param (ref extern))))
+   (import "env" "caml_ba_get_dim"
+      (func $caml_ba_get_dim (param (ref eq)) (result (ref $int_array))))
+   (import "env" "caml_ba_sub"
+       (func $caml_ba_sub
+          (param (ref eq)) (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_ba_blit"
+       (func $caml_ba_blit (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_ba_dim_1"
+       (func $caml_ba_dim_1 (param (ref eq)) (result (ref eq))))
+
+   (export "core_array_unsafe_int_blit" (func $caml_array_blit))
+   (export "core_array_unsafe_float_blit" (func $caml_floatarray_blit))
+
+   (type $block (array (mut (ref eq))))
+   (type $string (array (mut i8)))
+   (type $float (struct (field f64)))
+
+   (data $Date "Date")
+   (data $strftime "strftime")
+
+   (func (export "core_time_ns_format")
+      (param $time (ref eq)) (param $format (ref eq)) (result (ref eq))
+      (local $d (ref eq))
+      (local.set $d
+         (call $caml_js_new
+            (call $caml_js_get
+               (call $caml_js_global (ref.i31 (i32.const 0)))
+               (array.new_data $string $Date (i32.const 0) (i32.const 4)))
+            (call $caml_js_from_array
+               (array.new_fixed $block 2 (ref.i31 (i32.const 0))
+                  (call $caml_js_from_float
+                     (struct.new $float
+                        (f64.mul
+                           (struct.get $float 0
+                              (ref.cast (ref $float) (local.get $time)))
+                           (f64.const 1000.))))))))
+      (return_call $caml_string_of_jsstring
+         (call $caml_js_fun_call
+            (call $caml_js_get
+               (call $caml_js_global (ref.i31 (i32.const 0)))
+               (array.new_data $string $strftime (i32.const 0) (i32.const 8)))
+            (array.new_fixed $block 3 (ref.i31 (i32.const 0))
+               (call $caml_jsstring_of_string (local.get $format))
+               (local.get $d)))))
+
+   (func (export "core_gc_compactions") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_heap_chunks") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_heap_words") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_major_collections") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_major_plus_minor_words")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_major_words") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_minor_collections") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_minor_words") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_promoted_words") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_top_heap_words") (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_gc_run_memprof_callbacks")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "core_md5_fd") (param $fd (ref eq)) (result (ref eq))
+      (local $ic (ref eq))
+      (local $s (ref eq))
+      (local.set $ic (call $caml_ml_open_descriptor_in (local.get $fd)))
+      (local.set $s
+         (call $caml_md5_chan (local.get $ic) (ref.i31 (i32.const -1))))
+      (return (local.get $s)))
+
+   (func (export "core_md5_digest_subbigstring")
+      (param $buf (ref eq)) (param $ofs (ref eq)) (param $len (ref eq))
+      (param $res (ref eq)) (result (ref eq))
+      (local $bytes (ref eq))
+      (local $res2 (ref eq))
+      (local.set $bytes (call $caml_create_bytes (local.get $len)))
+      (drop
+         (call $bigstring_blit_bigstring_bytes_stub
+            (local.get $buf) (local.get $ofs) (local.get $bytes)
+            (ref.i31 (i32.const 0)) (local.get $len)))
+      (local.set $res2
+         (call $caml_md5_string
+            (local.get $bytes) (ref.i31 (i32.const 0)) (local.get $len)))
+      (drop
+         (call $caml_blit_string
+           (local.get $res2) (ref.i31 (i32.const 0))
+           (local.get $res) (ref.i31 (i32.const 0))
+           (ref.i31 (i32.const 16))))
+     (ref.i31 (i32.const 0)))
+
+   (type $int_array (array (mut i32)))
+
+   (data $bigstring_destroy_already_deallocated
+      "bigstring_destroy: bigstring is already deallocated")
+
+   (func $bigstring_destroy_stub (export "bigstring_destroy_stub")
+      (param $v (ref eq)) (result (ref eq))
+      (if (ref.test (ref i31)
+            (extern.internalize (call $caml_ba_get_data (local.get $v))))
+         (then
+            (call $caml_invalid_argument
+               (array.new_data $string $bigstring_destroy_already_deallocated
+                  (i32.const 0) (i32.const 51)))))
+      (call $caml_ba_set_data (local.get $v)
+         (extern.externalize (ref.i31 (i32.const 0))))
+      (array.set $int_array (call $caml_ba_get_dim (local.get $v)) (i32.const 0)
+         (i32.const 0))
+      (ref.i31 (i32.const 0)))
+
+   (data $bigstring_realloc_already_deallocated
+      "bigstring_realloc: bigstring is already deallocated")
+
+   (func (export "bigstring_realloc")
+      (param $bigstring (ref eq)) (param $vsize (ref eq))
+      (result (ref eq))
+      (local $new_bigstring (ref eq))
+      (local $size i32) (local $old_size i32)
+      (local $new_data (ref extern))
+      (local.set $size (i31.get_u (ref.cast (ref i31) (local.get $vsize))))
+      (if (ref.test (ref i31)
+            (extern.internalize
+               (call $caml_ba_get_data (local.get $bigstring))))
+         (then
+            (call $caml_invalid_argument
+               (array.new_data $string $bigstring_realloc_already_deallocated
+                  (i32.const 0) (i32.const 51)))))
+      (local.set $new_data
+         (call $caml_ba_create_buffer
+            (call $caml_ba_get_kind (local.get $bigstring))
+            (local.get $size)))
+      (local.set $new_bigstring
+         (call $caml_ba_alloc
+            (call $caml_ba_get_kind (local.get $bigstring))
+            (call $caml_ba_get_layout (local.get $bigstring))
+            (i32.const 1)
+            (local.get $new_data)
+            (array.new_fixed $int_array 1 (local.get $size))))
+      (local.set $old_size
+         (i31.get_u
+            (ref.cast (ref i31) (call $caml_ba_dim_1 (local.get $bigstring)))))
+      (if (i32.lt_u (local.get $old_size) (local.get $size))
+         (then
+            (local.set $size (local.get $old_size))))
+      (drop (call $caml_ba_blit
+         (call $caml_ba_sub (local.get $bigstring)
+            (ref.i31 (i32.const 0)) (ref.i31 (local.get $size)))
+         (call $caml_ba_sub (local.get $new_bigstring)
+            (ref.i31 (i32.const 0)) (ref.i31 (local.get $size)))))
+      (drop (call $bigstring_destroy_stub (local.get $bigstring)))
+      (local.get $new_bigstring))
+)
Index: core-0.17.1/core/src/sequence.ml
===================================================================
--- core-0.17.1.orig/core/src/sequence.ml
+++ core-0.17.1/core/src/sequence.ml
@@ -2,15 +2,15 @@ open! Import
 include Base.Sequence
 
 include Bin_prot.Utils.Make_binable1_without_uuid [@alert "-legacy"] (struct
-  module Binable = struct
-    type 'a t = 'a list [@@deriving bin_io]
-  end
+    module Binable = struct
+      type 'a t = 'a list [@@deriving bin_io]
+    end
 
-  type 'a t = 'a Base.Sequence.t
+    type 'a t = 'a Base.Sequence.t
 
-  let of_binable = Base.Sequence.of_list
-  let to_binable = Base.Sequence.to_list
-end)
+    let of_binable = Base.Sequence.of_list
+    let to_binable = Base.Sequence.to_list
+  end)
 
 module Step = struct
   include Step
Index: core-0.17.1/core/src/set.ml
===================================================================
--- core-0.17.1.orig/core/src/set.ml
+++ core-0.17.1/core/src/set.ml
@@ -59,39 +59,38 @@ module Accessors = struct
   include (
     Set.Using_comparator :
       Set.Accessors_generic
-        with type ('a, 'b) t := ('a, 'b) Set.t
-        with type ('a, 'b) tree := ('a, 'b) Tree.t
-        with type 'c cmp := 'c
-        with type 'a elt := 'a
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t)
+      with type ('a, 'b) t := ('a, 'b) Set.t
+      with type ('a, 'b) tree := ('a, 'b) Tree.t
+      with type 'c cmp := 'c
+      with type 'a elt := 'a
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t)
 end
 
 type 'a cmp = 'a
 type 'a elt = 'a
 
 include (
-  struct
-    include Set
+struct
+  include Set
 
-    let of_tree m = Set.Using_comparator.of_tree ~comparator:(to_comparator m)
-    let to_tree = Set.Using_comparator.to_tree
-    let sexp_of_t = Set.Using_comparator.sexp_of_t
-  end :
-    sig
-      type ('a, 'b) t = ('a, 'b) Set.t [@@deriving sexp_of]
-
-      include
-        Set.Creators_and_accessors_generic
-          with type ('a, 'b, 'c) create_options :=
-            ('a, 'b, 'c) Set.With_first_class_module.t
-          with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Set.Without_comparator.t
-          with type ('a, 'b) t := ('a, 'b) t
-          with type ('a, 'b) set := ('a, 'b) t
-          with type ('a, 'b) tree := ('a, 'b) Tree.t
-          with type 'a cmp := 'a cmp
-          with type 'a elt := 'a elt
-          with module Named = Set.Named
-    end)
+  let of_tree m = Set.Using_comparator.of_tree ~comparator:(to_comparator m)
+  let to_tree = Set.Using_comparator.to_tree
+  let sexp_of_t = Set.Using_comparator.sexp_of_t
+end :
+sig
+  type ('a, 'b) t = ('a, 'b) Set.t [@@deriving sexp_of]
+
+  include
+    Set.Creators_and_accessors_and_transformers_generic
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Set.With_first_class_module.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Set.Without_comparator.t
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) set := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) Tree.t
+    with type 'a cmp := 'a cmp
+    with type 'a elt := 'a elt
+    with module Named = Set.Named
+end)
 
 let compare _ _ t1 t2 = compare_direct t1 t2
 
@@ -137,12 +136,12 @@ module Creators (Elt : Comparator.S1) :
 
   include
     Creators_generic
-      with type ('a, 'b) t := ('a, 'b) t_
-      with type ('a, 'b) set := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) tree
-      with type 'a elt := 'a elt_
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-      with type 'a cmp := 'a cmp_
+    with type ('a, 'b) t := ('a, 'b) t_
+    with type ('a, 'b) set := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt_
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+    with type 'a cmp := 'a cmp_
 end = struct
   open Using_comparator
 
@@ -211,10 +210,10 @@ module Make_tree_S1 (Elt : Comparator.S1
 end
 
 module Make_tree_plain (Elt : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   module Elt_S1 = Comparator.S_to_S1 (Elt)
   include Make_tree_S1 (Elt_S1)
@@ -225,10 +224,10 @@ struct
   let sexp_of_t t = Tree.sexp_of_t Elt.sexp_of_t [%sexp_of: _] t
 
   module Provide_of_sexp
-    (X : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := Elt.t) =
+      (X : sig
+             type t [@@deriving of_sexp]
+           end
+           with type t := Elt.t) =
   struct
     let t_of_sexp sexp =
       Tree.t_of_sexp_direct X.t_of_sexp sexp ~comparator:Elt_S1.comparator
@@ -237,10 +236,10 @@ struct
 end
 
 module Make_tree (Elt : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include Make_tree_plain (Elt)
   include Provide_of_sexp (Elt)
@@ -276,23 +275,26 @@ module Poly = struct
   ;;
 
   include Bin_prot.Utils.Make_iterable_binable1 (struct
-    type nonrec 'a t = 'a t
-    type 'a el = 'a [@@deriving bin_io]
-
-    let _ = bin_el
-
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "88bcc478-4992-11e6-a95d-ff4831acf410"
-    ;;
+      type nonrec 'a t = 'a t
+      type 'a el = 'a [@@deriving bin_io]
 
-    let module_name = Some "Core.Set"
-    let length = length
-    let iter t ~f = iter ~f:(fun key -> f key) t
+      let _ = bin_el
 
-    let init ~len ~next =
-      init_for_bin_prot ~len ~f:(fun _ -> next ()) ~comparator:Comparator.Poly.comparator
-    ;;
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "88bcc478-4992-11e6-a95d-ff4831acf410"
+      ;;
+
+      let module_name = Some "Core.Set"
+      let length = length
+      let[@inline always] iter t ~f = iter ~f:(fun key -> f key) t [@nontail]
+
+      let init ~len ~next =
+        init_for_bin_prot
+          ~len
+          ~f:(fun _ -> next ())
+          ~comparator:Comparator.Poly.comparator
+      ;;
+    end)
 
   module Tree = struct
     include Make_tree_S1 (Comparator.Poly)
@@ -316,29 +318,29 @@ module type S_binable = S_binable
 module Elt_bin_io = Elt_bin_io
 
 module Provide_bin_io (Elt : Elt_bin_io.S) = Bin_prot.Utils.Make_iterable_binable (struct
-  type nonrec t = (Elt.t, Elt.comparator_witness) t
-  type el = Elt.t [@@deriving bin_io]
+    type nonrec t = (Elt.t, Elt.comparator_witness) t
+    type el = Elt.t [@@deriving bin_io]
 
-  let _ = bin_el
+    let _ = bin_el
 
-  let caller_identity =
-    Bin_prot.Shape.Uuid.of_string "8989278e-4992-11e6-8f4a-6b89776b1e53"
-  ;;
+    let caller_identity =
+      Bin_prot.Shape.Uuid.of_string "8989278e-4992-11e6-8f4a-6b89776b1e53"
+    ;;
 
-  let module_name = Some "Core.Set"
-  let length = length
-  let iter t ~f = iter ~f:(fun key -> f key) t
+    let module_name = Some "Core.Set"
+    let length = length
+    let[@inline always] iter t ~f = iter ~f:(fun key -> f key) t [@nontail]
 
-  let init ~len ~next =
-    init_for_bin_prot ~len ~f:(fun _ -> next ()) ~comparator:Elt.comparator
-  ;;
-end)
+    let init ~len ~next =
+      init_for_bin_prot ~len ~f:(fun _ -> next ()) ~comparator:Elt.comparator
+    ;;
+  end)
 
 module Provide_stable_witness (Elt : sig
-  type t [@@deriving stable_witness]
+    type t [@@deriving stable_witness]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   (* The binary representation of set is used in the stable modules below, so it's
      assumed to be stable (if the elt is stable). *)
@@ -349,10 +351,10 @@ struct
 end
 
 module Make_plain_using_comparator (Elt : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   module Elt = Elt
   module Elt_S1 = Comparator.S_to_S1 (Elt)
@@ -376,10 +378,10 @@ struct
   end
 
   module Provide_of_sexp
-    (Elt : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := Elt.t) =
+      (Elt : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := Elt.t) =
   struct
     let t_of_sexp sexp = t_of_sexp Elt.t_of_sexp sexp
 
@@ -400,39 +402,39 @@ struct
   end
 
   module Provide_bin_io
-    (Elt' : sig
-      type t [@@deriving bin_io]
-    end
-    with type t := Elt.t) =
+      (Elt' : sig
+                type t [@@deriving bin_io]
+              end
+              with type t := Elt.t) =
   Provide_bin_io (struct
-    include Elt
-    include Elt'
-  end)
+      include Elt
+      include Elt'
+    end)
 
   module Provide_stable_witness
-    (Elt' : sig
-      type t [@@deriving stable_witness]
-    end
-    with type t := Elt.t) =
+      (Elt' : sig
+                type t [@@deriving stable_witness]
+              end
+              with type t := Elt.t) =
   Provide_stable_witness (struct
-    include Elt
-    include Elt'
-  end)
+      include Elt
+      include Elt'
+    end)
 
   let quickcheck_observer = quickcheck_observer
   let quickcheck_shrinker = quickcheck_shrinker
 end
 
 module Make_plain (Elt : Elt_plain) = Make_plain_using_comparator (struct
-  include Elt
-  include Comparator.Make (Elt)
-end)
+    include Elt
+    include Comparator.Make (Elt)
+  end)
 
 module Make_using_comparator (Elt_sexp : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include Make_plain_using_comparator (Elt_sexp)
   module Elt = Elt_sexp
@@ -440,15 +442,15 @@ struct
 end
 
 module Make (Elt : Elt) = Make_using_comparator (struct
-  include Elt
-  include Comparator.Make (Elt)
-end)
+    include Elt
+    include Comparator.Make (Elt)
+  end)
 
 module Make_binable_using_comparator (Elt_bin_sexp : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  include Comparator.S with type t := t
-end) =
+    include Comparator.S with type t := t
+  end) =
 struct
   include Make_using_comparator (Elt_bin_sexp)
   module Elt = Elt_bin_sexp
@@ -462,9 +464,9 @@ struct
 end
 
 module Make_binable (Elt : Elt_binable) = Make_binable_using_comparator (struct
-  include Elt
-  include Comparator.Make (Elt)
-end)
+    include Elt
+    include Comparator.Make (Elt)
+  end)
 
 module For_deriving = struct
   module M = Set.M
Index: core-0.17.1/core/src/set.mli
===================================================================
--- core-0.17.1.orig/core/src/set.mli
+++ core-0.17.1/core/src/set.mli
@@ -23,25 +23,25 @@ module Tree : sig
 
   include
     Creators_and_accessors_generic
-      with type ('a, 'b) set := ('a, 'b) t
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) t
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
-      with type 'a elt := 'a
-      with type 'c cmp := 'c
-      with module Named := Named
+    with type ('a, 'b) set := ('a, 'b) t
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) t
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
+    with type 'a elt := 'a
+    with type 'c cmp := 'c
+    with module Named := Named
 end
 
 module Using_comparator : sig
   include
     Creators_generic
-      with type ('a, 'b) set := ('a, 'b) t
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) Tree.t
-      with type 'a elt := 'a
-      with type 'c cmp := 'c
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+    with type ('a, 'b) set := ('a, 'b) t
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) Tree.t
+    with type 'a elt := 'a
+    with type 'c cmp := 'c
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
 end
 
 (** Tests internal invariants of the set data structure.  Returns true on success. *)
@@ -244,7 +244,7 @@ val of_increasing_iterator_unchecked
     of polymorphic comparison by instantiating the functor at a different implementation
     of [Comparator] and using the resulting [stable_dedup_list]. *)
 val stable_dedup_list : ('a, _) Comparator.Module.t -> 'a list -> 'a list
-  [@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
+[@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
 
 (** [map c t ~f] returns a new set created by applying [f] to every element in [t]. The
     returned set is based on the provided [c]. [O(n log n)]. *)
@@ -470,35 +470,35 @@ val quickcheck_shrinker
 *)
 
 module Poly : sig
-  type ('a, 'b) set
+    type ('a, 'b) set
 
-  module Tree : sig
-    type 'elt t = ('elt, Comparator.Poly.comparator_witness) Tree.t
-    [@@deriving sexp, sexp_grammar]
+    module Tree : sig
+      type 'elt t = ('elt, Comparator.Poly.comparator_witness) Tree.t
+      [@@deriving sexp, sexp_grammar]
 
-    include
-      Creators_generic
+      include
+        Creators_generic
         with type ('a, 'b) set := ('a, 'b) Tree.t
         with type ('elt, 'cmp) t := 'elt t
         with type ('elt, 'cmp) tree := 'elt t
         with type 'c cmp := Comparator.Poly.comparator_witness
         with type 'a elt := 'a
         with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-  end
+    end
 
-  type 'elt t = ('elt, Comparator.Poly.comparator_witness) set
-  [@@deriving bin_io, compare, sexp, sexp_grammar]
+    type 'elt t = ('elt, Comparator.Poly.comparator_witness) set
+    [@@deriving bin_io, compare, sexp, sexp_grammar]
 
-  include
-    Creators_generic
+    include
+      Creators_generic
       with type ('a, 'b) set := ('a, 'b) set
       with type ('elt, 'cmp) t := 'elt t
       with type ('elt, 'cmp) tree := 'elt Tree.t
       with type 'c cmp := Comparator.Poly.comparator_witness
       with type 'a elt := 'a
       with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-end
-with type ('a, 'b) set := ('a, 'b) t
+  end
+  with type ('a, 'b) set := ('a, 'b) t
 
 (** {2 Signatures and functors for building [Set] modules}  *)
 
@@ -530,47 +530,48 @@ module Make (Elt : Elt) : S with type El
 module Make_binable (Elt : Elt_binable) : S_binable with type Elt.t = Elt.t
 
 module Make_plain_using_comparator (Elt : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) :
+    include Comparator.S with type t := t
+  end) :
   S_plain
-    with type Elt.t = Elt.t
-    with type Elt.comparator_witness = Elt.comparator_witness
+  with type Elt.t = Elt.t
+  with type Elt.comparator_witness = Elt.comparator_witness
 
 (** [Make_using_comparator] builds a set from an element type that has a comparator.
 
     [Make_binable_using_comparator] is similar, except the element and set types support
     [bin_io]. *)
 module Make_using_comparator (Elt : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) : S with type Elt.t = Elt.t with type Elt.comparator_witness = Elt.comparator_witness
+    include Comparator.S with type t := t
+  end) :
+  S with type Elt.t = Elt.t with type Elt.comparator_witness = Elt.comparator_witness
 
 module Make_binable_using_comparator (Elt : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  include Comparator.S with type t := t
-end) :
+    include Comparator.S with type t := t
+  end) :
   S_binable
-    with type Elt.t = Elt.t
-    with type Elt.comparator_witness = Elt.comparator_witness
+  with type Elt.t = Elt.t
+  with type Elt.comparator_witness = Elt.comparator_witness
 
 module Elt_bin_io = Elt_bin_io
 include For_deriving with type ('a, 'b) t := ('a, 'b) t
 
 module Make_tree_plain (Elt : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Comparator.S with type t := t
-end) : Make_S_plain_tree(Elt).S
+    include Comparator.S with type t := t
+  end) : Make_S_plain_tree(Elt).S
 
 module Make_tree (Elt : sig
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Comparator.S with type t := t
-end) : sig
+    include Comparator.S with type t := t
+  end) : sig
   include Make_S_plain_tree(Elt).S
   include Sexpable.S with type t := t
 end
@@ -606,8 +607,8 @@ module Stable : sig
 
       module Make (Elt : Stable_module_types.With_stable_witness.S0) :
         S
-          with type elt := Elt.t
-          with type elt_comparator_witness := Elt.comparator_witness
+        with type elt := Elt.t
+        with type elt_comparator_witness := Elt.comparator_witness
     end
   end
 end
Index: core-0.17.1/core/src/set_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/set_intf.ml
+++ core-0.17.1/core/src/set_intf.ml
@@ -54,10 +54,7 @@ module type For_deriving = sig
   val bin_size_m__t : ('a, 'b) Elt_bin_io.t -> ('a, 'b) t Bin_prot.Size.sizer
   val bin_write_m__t : ('a, 'b) Elt_bin_io.t -> ('a, 'b) t Bin_prot.Write.writer
   val bin_read_m__t : ('a, 'b) Elt_bin_io.t -> ('a, 'b) t Bin_prot.Read.reader
-
-  val __bin_read_m__t__
-    :  ('a, 'b) Elt_bin_io.t
-    -> (int -> ('a, 'b) t) Bin_prot.Read.reader
+  val __bin_read_m__t__ : ('a, 'b) Elt_bin_io.t -> ('a, 'b) t Bin_prot.Read.vtag_reader
 
   (** The following [quickcheck*] functions support deriving quickcheck on base-style
       sets, e.g.:
@@ -120,19 +117,23 @@ module type Accessors_generic = sig
 
   val to_map
     : ( 'a
-      , 'cmp
-      , ('a, 'cmp) t -> f:('a elt -> 'b) -> ('a elt, 'b, 'cmp cmp) Base.Map.t )
-      access_options
+        , 'cmp
+        , ('a, 'cmp) t -> f:('a elt -> 'b) -> ('a elt, 'b, 'cmp cmp) Base.Map.t )
+        access_options
 
   val quickcheck_observer
     :  'a elt Quickcheck.Observer.t
     -> ('a, 'cmp) t Quickcheck.Observer.t
+end
+
+module type Transformers_generic = sig
+  include Set.Transformers_generic
 
   val quickcheck_shrinker
     : ( 'a
-      , 'cmp
-      , 'a elt Quickcheck.Shrinker.t -> ('a, 'cmp) t Quickcheck.Shrinker.t )
-      access_options
+        , 'cmp
+        , 'a elt Quickcheck.Shrinker.t -> ('a, 'cmp) t Quickcheck.Shrinker.t )
+        access_options
 end
 
 module type Creators_generic = sig
@@ -146,9 +147,9 @@ module type Creators_generic = sig
 
   val quickcheck_generator
     : ( 'a
-      , 'cmp
-      , 'a elt Quickcheck.Generator.t -> ('a, 'cmp) t Quickcheck.Generator.t )
-      create_options
+        , 'cmp
+        , 'a elt Quickcheck.Generator.t -> ('a, 'cmp) t Quickcheck.Generator.t )
+        create_options
 end
 
 module type Creators_and_accessors_generic = sig
@@ -156,20 +157,30 @@ module type Creators_and_accessors_gener
   type ('elt, 'cmp) tree
   type 'elt elt
   type 'cmp cmp
+  type ('elt, 'cmp, 'fn) access_options
 
   include
     Accessors_generic
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) tree
-      with type 'a elt := 'a elt
-      with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt
+    with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+
+  include
+    Transformers_generic
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt
+    with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
 
   include
     Creators_generic
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) tree
-      with type 'a elt := 'a elt
-      with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt
+    with type 'cmp cmp := 'cmp cmp
 end
 
 module Make_S_plain_tree (Elt : Comparator.S) = struct
@@ -178,21 +189,21 @@ module Make_S_plain_tree (Elt : Comparat
 
     include
       Creators_generic
-        with type ('a, 'b) set := ('a, 'b) Tree.t
-        with type ('a, 'b) t := t
-        with type ('a, 'b) tree := t
-        with type 'a elt := Elt.t
-        with type 'c cmp := Elt.comparator_witness
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b) set := ('a, 'b) Tree.t
+      with type ('a, 'b) t := t
+      with type ('a, 'b) tree := t
+      with type 'a elt := Elt.t
+      with type 'c cmp := Elt.comparator_witness
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
 
     module Provide_of_sexp
-      (Elt : sig
+        (Elt : sig
+                 type t [@@deriving of_sexp]
+               end
+               with type t := Elt.t) : sig
         type t [@@deriving of_sexp]
       end
-      with type t := Elt.t) : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := t
+      with type t := t
   end
 end
 
@@ -210,40 +221,41 @@ module type S_plain = sig
 
     include
       Diffable.Diff.S_plain
-        with type t := t
-         and type derived_on = (Elt.t, Elt.comparator_witness) Base.Set.t
+      with type t := t
+       and type derived_on = (Elt.t, Elt.comparator_witness) Base.Set.t
   end
 
   include Diffable.S_plain with type t := t and module Diff := Diff
 
   include
     Creators_generic
-      with type ('a, 'b) set := ('a, 'b) Set.t
-      with type ('a, 'b) t := t
-      with type ('a, 'b) tree := (Elt.t, Elt.comparator_witness) Tree.t
-      with type 'a elt := Elt.t
-      with type 'c cmp := Elt.comparator_witness
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b) set := ('a, 'b) Set.t
+    with type ('a, 'b) t := t
+    with type ('a, 'b) tree := (Elt.t, Elt.comparator_witness) Tree.t
+    with type 'a elt := Elt.t
+    with type 'c cmp := Elt.comparator_witness
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
 
   module Provide_of_sexp
-    (Elt : sig
+      (Elt : sig
+               type t [@@deriving of_sexp]
+             end
+             with type t := Elt.t) : sig
       type t [@@deriving of_sexp]
     end
-    with type t := Elt.t) : sig
-    type t [@@deriving of_sexp]
-  end
-  with type t := t
+    with type t := t
 
   module Provide_bin_io
-    (Elt : sig
-      type t [@@deriving bin_io]
+      (Elt : sig
+               type t [@@deriving bin_io]
+             end
+             with type t := Elt.t) : Binable.S with type t := t
+
+  module Provide_hash
+      (Elt : Hasher.S with type t := Elt.t) : sig
+      type t [@@deriving hash]
     end
-    with type t := Elt.t) : Binable.S with type t := t
-
-  module Provide_hash (Elt : Hasher.S with type t := Elt.t) : sig
-    type t [@@deriving hash]
-  end
-  with type t := t
+    with type t := t
 
   val quickcheck_observer : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
   val quickcheck_shrinker : Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
@@ -261,8 +273,8 @@ module type S = sig
 
     include
       Diffable.Diff.S_plain
-        with type t := t
-         and type derived_on = (Elt.t, Elt.comparator_witness) Base.Set.t
+      with type t := t
+       and type derived_on = (Elt.t, Elt.comparator_witness) Base.Set.t
   end
 
   include S_plain with module Elt := Elt and module Diff := Diff
@@ -281,8 +293,8 @@ module type S_binable = sig
 
     include
       Diffable.Diff.S_plain
-        with type t := t
-         and type derived_on = (Elt.t, Elt.comparator_witness) Base.Set.t
+      with type t := t
+       and type derived_on = (Elt.t, Elt.comparator_witness) Base.Set.t
   end
 
   include S with module Elt := Elt and module Diff := Diff
Index: core-0.17.1/core/src/set_once.ml
===================================================================
--- core-0.17.1.orig/core/src/set_once.ml
+++ core-0.17.1/core/src/set_once.ml
@@ -12,7 +12,7 @@ module Stable = struct
 
   module V1 = struct
     module Format = struct
-      type 'a t = 'a option ref [@@deriving bin_io, sexp]
+      type 'a t = 'a option ref [@@deriving bin_io, sexp, sexp_grammar]
     end
 
     include T
@@ -39,6 +39,11 @@ module Stable = struct
           let of_sexpable = of_format
           let to_sexpable = to_format
         end)
+
+    let t_sexp_grammar : 'a Sexplib.Sexp_grammar.t -> 'a t Sexplib.Sexp_grammar.t =
+      fun a_sexp_grammar ->
+      Sexplib.Sexp_grammar.coerce (Format.t_sexp_grammar a_sexp_grammar)
+    ;;
   end
 end
 
@@ -103,3 +108,13 @@ module Optional_syntax = struct
     let unsafe_value t = get_exn t [%here]
   end
 end
+
+include
+  Quickcheckable.Of_quickcheckable1
+    (Option)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable { value; set_at = _ } = value
+      let of_quickcheckable value = { value; set_at = [%here] }
+    end)
Index: core-0.17.1/core/src/set_once.mli
===================================================================
--- core-0.17.1.orig/core/src/set_once.mli
+++ core-0.17.1/core/src/set_once.mli
@@ -7,7 +7,7 @@
 
 open! Import
 
-type 'a t [@@deriving compare, equal, sexp_of]
+type 'a t [@@deriving compare, equal, quickcheck, sexp_of]
 
 (** Passes when unset. *)
 include Invariant.S1 with type 'a t := 'a t
@@ -30,11 +30,11 @@ module Optional_syntax :
   Optional_syntax.S1 with type 'a t := 'a t with type 'a value := 'a identity
 
 module Unstable : sig
-  type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, sexp]
+  type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, sexp, sexp_grammar]
 end
 
 module Stable : sig
   module V1 : sig
-    type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, sexp]
+    type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, sexp, sexp_grammar]
   end
 end
Index: core-0.17.1/core/src/sexp.ml
===================================================================
--- core-0.17.1.orig/core/src/sexp.ml
+++ core-0.17.1/core/src/sexp.ml
@@ -2,16 +2,17 @@ open! Import
 
 module Stable = struct
   module V1 = struct
-    include struct
-      (* inherit previously derived values, rather than re-deriving from the type *)
-      type t = Base.Sexp.t
-      [@@deriving compare ~localize, equal ~localize, globalize, hash]
+    module T = struct
+      include Base.Sexp
+
+      type t = Base.Sexp.t =
+        | Atom of string
+        | List of t list
+      [@@deriving bin_io, stable_witness]
     end
 
-    type t = Base.Sexp.t =
-      | Atom of string
-      | List of t list
-    [@@deriving bin_io, stable_witness]
+    include T
+    include Comparable.Stable.V1.With_stable_witness.Make (T)
 
     let t_sexp_grammar = Sexplib.Sexp.t_sexp_grammar
     let t_of_sexp = Sexplib.Sexp.t_of_sexp
Index: core-0.17.1/core/src/sexp.mli
===================================================================
--- core-0.17.1.orig/core/src/sexp.mli
+++ core-0.17.1/core/src/sexp.mli
@@ -106,5 +106,10 @@ module Stable : sig
       | List of t list
     [@@deriving
       sexp, bin_io, hash, compare ~localize, equal ~localize, sexp_grammar, stable_witness]
+
+    include
+      Stable_comparable.With_stable_witness.V1
+      with type t := t
+      with type comparator_witness := comparator_witness
   end
 end
Index: core-0.17.1/core/src/sexpable.ml
===================================================================
--- core-0.17.1.orig/core/src/sexpable.ml
+++ core-0.17.1/core/src/sexpable.ml
@@ -4,12 +4,13 @@ include Base.Sexpable
 module Stable = struct
   module Of_sexpable = struct
     module V1
-      (Sexpable : S) (M : sig
-        type t
-
-        val to_sexpable : t -> Sexpable.t
-        val of_sexpable : Sexpable.t -> t
-      end) : S with type t := M.t = struct
+        (Sexpable : S)
+        (M : sig
+           type t
+
+           val to_sexpable : t -> Sexpable.t
+           val of_sexpable : Sexpable.t -> t
+         end) : S with type t := M.t = struct
       let t_of_sexp sexp =
         let s = Sexpable.t_of_sexp sexp in
         try M.of_sexpable s with
@@ -22,12 +23,13 @@ module Stable = struct
 
   module Of_sexpable1 = struct
     module V1
-      (Sexpable : S1) (M : sig
-        type 'a t
-
-        val to_sexpable : 'a t -> 'a Sexpable.t
-        val of_sexpable : 'a Sexpable.t -> 'a t
-      end) : S1 with type 'a t := 'a M.t = struct
+        (Sexpable : S1)
+        (M : sig
+           type 'a t
+
+           val to_sexpable : 'a t -> 'a Sexpable.t
+           val of_sexpable : 'a Sexpable.t -> 'a t
+         end) : S1 with type 'a t := 'a M.t = struct
       let t_of_sexp a_of_sexp sexp =
         let s = Sexpable.t_of_sexp a_of_sexp sexp in
         try M.of_sexpable s with
@@ -40,12 +42,13 @@ module Stable = struct
 
   module Of_sexpable2 = struct
     module V1
-      (Sexpable : S2) (M : sig
-        type ('a, 'b) t
-
-        val to_sexpable : ('a, 'b) t -> ('a, 'b) Sexpable.t
-        val of_sexpable : ('a, 'b) Sexpable.t -> ('a, 'b) t
-      end) : S2 with type ('a, 'b) t := ('a, 'b) M.t = struct
+        (Sexpable : S2)
+        (M : sig
+           type ('a, 'b) t
+
+           val to_sexpable : ('a, 'b) t -> ('a, 'b) Sexpable.t
+           val of_sexpable : ('a, 'b) Sexpable.t -> ('a, 'b) t
+         end) : S2 with type ('a, 'b) t := ('a, 'b) M.t = struct
       let t_of_sexp a_of_sexp b_of_sexp sexp =
         let s = Sexpable.t_of_sexp a_of_sexp b_of_sexp sexp in
         try M.of_sexpable s with
@@ -60,12 +63,13 @@ module Stable = struct
 
   module Of_sexpable3 = struct
     module V1
-      (Sexpable : S3) (M : sig
-        type ('a, 'b, 'c) t
-
-        val to_sexpable : ('a, 'b, 'c) t -> ('a, 'b, 'c) Sexpable.t
-        val of_sexpable : ('a, 'b, 'c) Sexpable.t -> ('a, 'b, 'c) t
-      end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t = struct
+        (Sexpable : S3)
+        (M : sig
+           type ('a, 'b, 'c) t
+
+           val to_sexpable : ('a, 'b, 'c) t -> ('a, 'b, 'c) Sexpable.t
+           val of_sexpable : ('a, 'b, 'c) Sexpable.t -> ('a, 'b, 'c) t
+         end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t = struct
       let t_of_sexp a_of_sexp b_of_sexp c_of_sexp sexp =
         let s = Sexpable.t_of_sexp a_of_sexp b_of_sexp c_of_sexp sexp in
         try M.of_sexpable s with
@@ -79,12 +83,13 @@ module Stable = struct
   end
 
   module Of_stringable = struct
-    module V1 (M : Stringable.S) : sig
-      type t [@@deriving sexp_grammar]
+    module V1
+        (M : Stringable.S) : sig
+        type t [@@deriving sexp_grammar]
 
-      include S with type t := t
-    end
-    with type t := M.t = struct
+        include S with type t := t
+      end
+      with type t := M.t = struct
       let t_of_sexp sexp =
         match sexp with
         | Sexplib.Sexp.Atom s ->
Index: core-0.17.1/core/src/sign.ml
===================================================================
--- core-0.17.1.orig/core/src/sign.ml
+++ core-0.17.1/core/src/sign.ml
@@ -7,7 +7,7 @@ module Stable = struct
       | Neg
       | Zero
       | Pos
-    [@@deriving sexp, bin_io, compare, hash, typerep, enumerate]
+    [@@deriving sexp, sexp_grammar, bin_io, compare, hash, typerep, enumerate]
   end
 end
 
Index: core-0.17.1/core/src/sign.mli
===================================================================
--- core-0.17.1.orig/core/src/sign.mli
+++ core-0.17.1/core/src/sign.mli
@@ -19,6 +19,6 @@ module Stable : sig
       | Neg
       | Zero
       | Pos
-    [@@deriving bin_io, compare, hash, sexp]
+    [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
   end
 end
Index: core-0.17.1/core/src/sign_or_nan.ml
===================================================================
--- core-0.17.1.orig/core/src/sign_or_nan.ml
+++ core-0.17.1/core/src/sign_or_nan.ml
@@ -8,7 +8,7 @@ module Stable = struct
       | Zero
       | Pos
       | Nan
-    [@@deriving sexp, bin_io, compare, hash, typerep, enumerate]
+    [@@deriving sexp, sexp_grammar, bin_io, compare, hash, typerep, enumerate]
   end
 end
 
Index: core-0.17.1/core/src/sign_or_nan.mli
===================================================================
--- core-0.17.1.orig/core/src/sign_or_nan.mli
+++ core-0.17.1/core/src/sign_or_nan.mli
@@ -21,6 +21,6 @@ module Stable : sig
       | Zero
       | Pos
       | Nan
-    [@@deriving bin_io, compare, hash, sexp]
+    [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
   end
 end
Index: core-0.17.1/core/src/signal.ml
===================================================================
--- core-0.17.1.orig/core/src/signal.ml
+++ core-0.17.1/core/src/signal.ml
@@ -2,12 +2,12 @@ open! Import
 
 include (
   Int :
-    sig
-      type t = int [@@deriving bin_io]
+  sig
+    type t = int [@@deriving bin_io]
 
-      include Comparable.S with type t := t
-      include Hashable.S with type t := t
-    end)
+    include Comparable.S with type t := t
+    include Hashable.S with type t := t
+  end)
 
 let of_caml_int t = t
 let to_caml_int t = t
@@ -19,7 +19,7 @@ type sys_behavior =
   | `Stop (** Stop the process *)
   | `Terminate (** Terminate the process *)
   ]
-[@@deriving sexp]
+[@@deriving sexp, sexp_grammar]
 
 let equal (t : t) t' = t = t'
 
Index: core-0.17.1/core/src/signal.mli
===================================================================
--- core-0.17.1.orig/core/src/signal.mli
+++ core-0.17.1/core/src/signal.mli
@@ -29,7 +29,7 @@ type sys_behavior =
   | `Stop (** Stop (suspend) the process *)
   | `Terminate (** Terminate the process *)
   ]
-[@@deriving sexp]
+[@@deriving sexp, sexp_grammar]
 
 (**
    Queries the default system behavior for a signal.
@@ -141,21 +141,21 @@ type sigprocmask_command = [ `Use_Signal
 val can_send_to : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 
 val of_system_int : [ `Use_Signal_unix ]
-  [@@deprecated "[since 2021-04] Use [Signal_unix]"]
+[@@deprecated "[since 2021-04] Use [Signal_unix]"]
 
 val send : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 val send_exn : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 val send_i : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 
 val sexp_of_pid_spec : [ `Use_Signal_unix ]
-  [@@deprecated "[since 2021-04] Use [Signal_unix]"]
+[@@deprecated "[since 2021-04] Use [Signal_unix]"]
 
 val sigpending : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 val sigprocmask : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 val sigsuspend : [ `Use_Signal_unix ] [@@deprecated "[since 2021-04] Use [Signal_unix]"]
 
 val to_system_int : [ `Use_Signal_unix ]
-  [@@deprecated "[since 2021-04] Use [Signal_unix]"]
+[@@deprecated "[since 2021-04] Use [Signal_unix]"]
 
 (** The [Expert] module contains functions that novice users should avoid, due to their
     complexity.
Index: core-0.17.1/core/src/source_code_position.mli
===================================================================
--- core-0.17.1.orig/core/src/source_code_position.mli
+++ core-0.17.1/core/src/source_code_position.mli
@@ -11,7 +11,7 @@ type t = Base.Source_code_position.t =
   ; pos_bol : int
   ; pos_cnum : int
   }
-[@@deriving fields ~getters]
+[@@deriving fields ~getters, globalize]
 
 include Comparable.S with type t := t and type comparator_witness := comparator_witness
 include Hashable.S with type t := t
Index: core-0.17.1/core/src/source_code_position0.ml
===================================================================
--- core-0.17.1.orig/core/src/source_code_position0.ml
+++ core-0.17.1/core/src/source_code_position0.ml
@@ -10,7 +10,16 @@ module Stable = struct
       ; pos_bol : int
       ; pos_cnum : int
       }
-    [@@deriving bin_io, compare, equal, fields ~getters, hash, sexp, stable_witness]
+    [@@deriving
+      bin_io
+      , compare
+      , equal
+      , fields ~getters
+      , globalize
+      , hash
+      , sexp
+      , sexp_grammar
+      , stable_witness]
   end
 end
 
Index: core-0.17.1/core/src/source_code_position0.mli
===================================================================
--- core-0.17.1.orig/core/src/source_code_position0.mli
+++ core-0.17.1/core/src/source_code_position0.mli
@@ -10,11 +10,12 @@ type t = Base.Source_code_position.t =
   ; pos_bol : int
   ; pos_cnum : int
   }
-[@@deriving bin_io, compare, fields ~getters, hash, sexp]
+[@@deriving bin_io, compare, fields ~getters, globalize, hash, sexp, sexp_grammar]
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@deriving bin_io, compare, equal, hash, sexp, stable_witness]
+    type nonrec t = t
+    [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
 
     include Comparator.Stable.V1.S with type t := t
   end
Index: core-0.17.1/core/src/span_float.ml
===================================================================
--- core-0.17.1.orig/core/src/span_float.ml
+++ core-0.17.1/core/src/span_float.ml
@@ -56,6 +56,11 @@ module Stable = struct
       val to_parts : t -> Parts.t
       val next : t -> t
       val prev : t -> t
+
+      module Private : sig
+        val to_parts_default : underlying -> Parts.t
+        val to_parts_31 : underlying -> Parts.t
+      end
     end = struct
       type underlying = float [@@deriving hash, stable_witness]
       type t = underlying [@@deriving hash, stable_witness]
@@ -67,18 +72,18 @@ module Stable = struct
          (1) all values serialize the same way in both representations, or
          (2) you add a new Time.Span version to stable.ml *)
       include (
-        struct
-          include Float
+      struct
+        include Float
 
-          let sign = sign_exn
-        end :
-          Like_a_float with type t := t)
+        let sign = sign_exn
+      end :
+        Like_a_float with type t := t)
 
       (* due to precision limitations in float we can't expect better than microsecond
          precision *)
       include Float.Robust_compare.Make (struct
-        let robust_comparison_tolerance = 1E-6
-      end)
+          let robust_comparison_tolerance = 1E-6
+        end)
 
       (* this prevents any worry about having these very common names redefined below and
          makes their usage within this module safer.  Constant is included at the very
@@ -98,7 +103,7 @@ module Stable = struct
         let day = of_float (24. *. 60. *. 60.)
       end
 
-      let to_parts t : Parts.t =
+      let to_parts_default t : Parts.t =
         let sign = Float.sign_exn t in
         let t = abs t in
         let integral = Float.round_down t in
@@ -121,6 +126,42 @@ module Stable = struct
         let ms = milliseconds in
         { sign; hr; min; sec; ms; us; ns }
       ;;
+
+      (* jevouillon: [Float.iround_down_exn integral] overflows when
+         integers are 31 bits, so we provide an alternative definition
+         below. *)
+      let to_parts_31 t : Parts.t =
+        let sign = Float.sign_exn t in
+        let t = abs t in
+        let integral = Float.round_down t in
+        let fractional = t -. integral in
+        let seconds = Float.int63_round_down_exn integral in
+        let nanoseconds = Float.iround_nearest_exn (fractional *. 1E9) in
+        let seconds, nanoseconds =
+          if Int.equal nanoseconds 1_000_000_000
+          then Int63.succ seconds, 0
+          else seconds, nanoseconds
+        in
+        let sec = Int63.(to_int_exn (rem seconds (of_int 60))) in
+        let minutes = Int63.(seconds / of_int 60) in
+        let min = Int63.(to_int_exn (rem minutes (of_int 60))) in
+        let hr = Int63.(to_int_exn (minutes / of_int 60)) in
+        let ns = nanoseconds mod 1000 in
+        let microseconds = nanoseconds / 1000 in
+        let us = microseconds mod 1000 in
+        let milliseconds = microseconds / 1000 in
+        let ms = milliseconds in
+        { sign; hr; min; sec; ms; us; ns }
+      ;;
+
+      let to_parts =
+        if Int.(Sys.int_size_in_bits > 31) then to_parts_default else to_parts_31
+      ;;
+
+      module Private = struct
+        let to_parts_default = to_parts_default
+        let to_parts_31 = to_parts_31
+      end
     end
 
     let ( / ) t f = T.of_float ((t : T.t :> float) /. f)
@@ -313,8 +354,8 @@ module Stable = struct
     let t_sexp_grammar = Sexplib.Sexp_grammar.coerce String.t_sexp_grammar
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, equal, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, equal, sexp]
+      end)
   end
 
   module V2 = struct
@@ -322,10 +363,11 @@ module Stable = struct
 
     let t_of_sexp sexp = t_of_sexp_v1_v2 sexp ~is_v2:true
     let sexp_of_t t = sexp_of_t_v1_v2 t ~is_v2:true
+    let t_sexp_grammar = Sexplib.Sexp_grammar.coerce String.t_sexp_grammar
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, equal, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, equal, sexp]
+      end)
   end
 
   module V3 = struct
@@ -713,8 +755,8 @@ module Stable = struct
     let t_sexp_grammar = Sexplib.Sexp_grammar.coerce String.t_sexp_grammar
 
     include Diffable.Atomic.Make (struct
-      type nonrec t = t [@@deriving bin_io, equal, sexp]
-    end)
+        type nonrec t = t [@@deriving bin_io, equal, sexp]
+      end)
   end
 end
 
@@ -773,24 +815,24 @@ let quickcheck_generator =
 ;;
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = "Core.Time.Span"
-end)
+    let to_string = to_string
+    let module_name = "Core.Time_float.Span"
+  end)
 
 include Hashable.Make_binable (struct
-  type nonrec t = t [@@deriving bin_io, compare, hash, sexp_of]
+    type nonrec t = t [@@deriving bin_io, compare, hash, sexp_of]
 
-  (* Previous versions rendered hash-based containers using float serialization rather
+    (* Previous versions rendered hash-based containers using float serialization rather
        than time serialization, so when reading hash-based containers in we accept either
        serialization. *)
-  let t_of_sexp sexp =
-    match Float.t_of_sexp sexp with
-    | float -> of_float float
-    | exception _ -> t_of_sexp sexp
-  ;;
-end)
+    let t_of_sexp sexp =
+      match Float.t_of_sexp sexp with
+      | float -> of_float float
+      | exception _ -> t_of_sexp sexp
+    ;;
+  end)
 
 module C = struct
   type t = T.t [@@deriving bin_io]
@@ -817,12 +859,14 @@ module Map = Map.Make_binable_using_comp
 module Set = Set.Make_binable_using_comparator (C)
 
 include Comparable.With_zero (struct
-  type nonrec t = t [@@deriving compare, sexp_of]
+    type nonrec t = t [@@deriving compare, sexp_of]
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 module Private = struct
+  include Private
+
   let suffix_of_unit_of_time = suffix_of_unit_of_time
   let parse_suffix = Stable.V3.Of_string.parse_suffix
 end
Index: core-0.17.1/core/src/span_float.mli
===================================================================
--- core-0.17.1.orig/core/src/span_float.mli
+++ core-0.17.1/core/src/span_float.mli
@@ -32,4 +32,6 @@ end
 module Private : sig
   val parse_suffix : string -> index:int -> Unit_of_time.t
   val suffix_of_unit_of_time : Unit_of_time.t -> string
+  val to_parts_default : float -> Parts.t
+  val to_parts_31 : float -> Parts.t
 end
Index: core-0.17.1/core/src/span_ns.ml
===================================================================
--- core-0.17.1.orig/core/src/span_ns.ml
+++ core-0.17.1/core/src/span_ns.ml
@@ -112,12 +112,12 @@ let of_parts { Parts.sign; hr; min; sec;
 
 let of_ns f = round_nearest_ns f
 let of_int63_ns i = i
-let of_int_us i = Int63.(of_int i * microsecond)
-let of_int_ms i = Int63.(of_int i * millisecond)
-let of_int_sec i = Int63.(of_int i * second)
-let of_int_min i = Int63.(of_int i * minute)
-let of_int_hr i = Int63.(of_int i * hour)
-let of_int_day i = Int63.(of_int i * day)
+let[@zero_alloc] of_int_us i = Int63.(of_int i * microsecond)
+let[@zero_alloc] of_int_ms i = Int63.(of_int i * millisecond)
+let[@zero_alloc] of_int_sec i = Int63.(of_int i * second)
+let[@zero_alloc] of_int_min i = Int63.(of_int i * minute)
+let[@zero_alloc] of_int_hr i = Int63.(of_int i * hour)
+let[@zero_alloc] of_int_day i = Int63.(of_int i * day)
 let of_us f = round_nearest_ns (f *. float_microsecond)
 let of_ms f = round_nearest_ns (f *. float_millisecond)
 let[@inline] of_sec f = round_nearest_ns (f *. float_second)
@@ -146,25 +146,26 @@ let[@inline] to_sec_approx t = float t *
 let[@inline] to_min_approx t = float t *. ns_per_min
 let[@inline] to_hr_approx t = float t *. ns_per_hr
 let[@inline] to_day_approx t = float t *. ns_per_day
-let to_int_us t = Int63.(to_int_exn (t / microsecond))
-let to_int_ms t = Int63.(to_int_exn (t / millisecond))
-let to_int_sec t = Int63.(to_int_exn (t / second))
-let to_int63_seconds_round_down_exn t = t /% second
-let of_int_ns i = of_int63_ns (Int63.of_int i)
+let[@zero_alloc] to_int_us t = Int63.(to_int_exn (t / microsecond))
+let[@zero_alloc] to_int_ms t = Int63.(to_int_exn (t / millisecond))
+let[@zero_alloc] to_int_sec t = Int63.(to_int_exn (t / second))
+let[@zero_alloc] to_int63_seconds_round_down_exn t = t /% second
+let[@zero_alloc] of_int_ns i = of_int63_ns (Int63.of_int i)
 
 let to_int_ns =
   if arch_sixtyfour
-  then fun t -> Int63.to_int_exn (to_int63_ns t)
+  then fun [@zero_alloc] t -> Int63.to_int_exn (to_int63_ns t)
   else fun _ -> failwith "Time_ns.Span.to_int_ns: unsupported on 32bit machines"
 ;;
 
+let[@zero_alloc] to_int_ns t = to_int_ns t
 let ( + ) t u = Int63.( + ) t u
 let ( - ) t u = Int63.( - ) t u
 let abs = Int63.abs
 let neg = Int63.neg
 let scale t f = round_nearest_ns (float t *. f)
 let scale_int63 t i = Int63.( * ) t i
-let scale_int t i = scale_int63 t (Int63.of_int i)
+let[@zero_alloc] scale_int t i = scale_int63 t (Int63.of_int i)
 let div = Int63.( /% )
 let ( / ) t f = round_nearest_ns (float t /. f)
 let ( // ) = Int63.( // )
@@ -216,7 +217,7 @@ let round t ~dir ~to_multiple_of =
 module Stable0 = struct
   module V1 = struct
     module T = struct
-      type nonrec t = t [@@deriving bin_io, compare, hash, equal]
+      type nonrec t = t [@@deriving bin_io, compare, equal, hash, typerep]
 
       let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
 
@@ -244,7 +245,7 @@ module Stable0 = struct
   module V2 = struct
     module T = struct
       module T0 = struct
-        type nonrec t = t [@@deriving bin_io, compare, hash, equal]
+        type nonrec t = t [@@deriving bin_io, compare, equal, hash, typerep]
 
         let stable_witness : t Stable_witness.t = Int63.Stable.V1.stable_witness
         let of_int63_exn t = of_int63_ns t
@@ -729,10 +730,10 @@ module Alternate_sexp = struct
 end
 
 include Comparable.With_zero (struct
-  type nonrec t = t [@@deriving compare, sexp]
+    type nonrec t = t [@@deriving compare, sexp]
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 (* Functions required by [Robustly_comparable]: allows for [robust_comparison_tolerance]
    granularity.
@@ -776,7 +777,9 @@ let to_string_hum
   prefix ^ suffix
 ;;
 
-let since_unix_epoch () = Time_now.nanoseconds_since_unix_epoch () |> of_int63_ns
+let[@zero_alloc] since_unix_epoch () =
+  Time_now.nanoseconds_since_unix_epoch () |> of_int63_ns
+;;
 
 let random ?state () =
   Int63.random ?state (max_value_for_1us_rounding + Int63.one)
@@ -796,28 +799,28 @@ let gen_incl = Int63.gen_incl
 let gen_uniform_incl = Int63.gen_uniform_incl
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = module_name
-end)
+    let to_string = to_string
+    let module_name = module_name
+  end)
 
 include Hashable.Make_binable (struct
-  type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
-end)
+    type nonrec t = t [@@deriving bin_io, compare, hash, sexp]
+  end)
 
 type comparator_witness = Stable.V2.comparator_witness
 
 include Comparable.Make_binable_using_comparator (struct
-  type nonrec t = t [@@deriving bin_io, compare, sexp]
-  type nonrec comparator_witness = comparator_witness
+    type nonrec t = t [@@deriving bin_io, compare, sexp]
+    type nonrec comparator_witness = comparator_witness
 
-  let comparator = Stable.V2.comparator
-end)
+    let comparator = Stable.V2.comparator
+  end)
 
 include Diffable.Atomic.Make (struct
-  type nonrec t = t [@@deriving bin_io, sexp, equal]
-end)
+    type nonrec t = t [@@deriving bin_io, sexp, equal]
+  end)
 
 (* re-include [Replace_polymorphic_compare] and its comparisons to shadow the
    un-inlineable ones from [Comparable] *)
@@ -874,19 +877,19 @@ let min_value_representable = of_int63_n
 let max_value_representable = of_int63_ns Int63.max_value
 
 module O = struct
-  let ( / ) = ( / )
+  let[@zero_alloc] ( / ) t1 t2 = t1 / t2
   let ( // ) = ( // )
-  let ( + ) = ( + )
-  let ( - ) = ( - )
+  let[@zero_alloc] ( + ) t1 t2 = t1 + t2
+  let[@zero_alloc] ( - ) t1 t2 = t1 - t2
   let ( >= ) = ( >= )
   let ( <= ) = ( <= )
   let ( = ) = ( = )
   let ( > ) = ( > )
   let ( < ) = ( < )
   let ( <> ) = ( <> )
-  let ( ~- ) = neg
-  let ( *. ) = scale
-  let ( * ) = scale_int
+  let[@zero_alloc] ( ~- ) t = neg t
+  let[@zero_alloc] ( *. ) t x = scale t x
+  let[@zero_alloc] ( * ) t x = scale_int t x
 end
 
 module Private = struct
@@ -906,28 +909,28 @@ module Option = struct
   (* nanoseconds or none *)
 
   let none = Int63.min_value
-  let is_none t = Int63.(t = none)
-  let is_some t = Int63.(t <> none)
-  let some_is_representable span = is_some (to_int63_ns span)
+  let[@zero_alloc] is_none t = Int63.(t = none)
+  let[@zero_alloc] is_some t = Int63.(t <> none)
+  let[@zero_alloc] some_is_representable span = is_some (to_int63_ns span)
 
   let[@cold] raise_some_error span =
     raise_s [%message [%here] "Span.Option.some value not representable" (span : span)]
   ;;
 
-  let some span =
+  let[@zero_alloc] some span =
     if some_is_representable span then to_int63_ns span else raise_some_error span
   ;;
 
-  let unchecked_value t = of_int63_ns t
-  let value t ~default = Bool.select (is_none t) default (unchecked_value t)
+  let[@zero_alloc] unchecked_value t = of_int63_ns t
+  let[@zero_alloc] value t ~default = Bool.select (is_none t) default (unchecked_value t)
 
-  let value_exn t =
+  let[@zero_alloc] value_exn t =
     if is_some t
     then unchecked_value t
     else raise_s [%message [%here] "Span.Option.value_exn none"]
   ;;
 
-  let of_option = function
+  let[@zero_alloc] of_option = function
     | None -> none
     | Some t -> some t
   ;;
@@ -969,8 +972,8 @@ module Option = struct
 
   module Optional_syntax = struct
     module Optional_syntax = struct
-      let is_none = is_none
-      let unsafe_value = unchecked_value
+      let[@zero_alloc] is_none t = is_none t
+      let[@zero_alloc] unsafe_value t = unchecked_value t
     end
   end
 
@@ -1050,18 +1053,18 @@ module Option = struct
   let t_of_sexp = Stable.V2.t_of_sexp
 
   include Identifiable.Make (struct
-    type nonrec t = t [@@deriving sexp, compare, bin_io, hash]
+      type nonrec t = t [@@deriving sexp, compare, bin_io, hash]
 
-    let module_name = "Core.Time_ns.Span.Option"
+      let module_name = "Core.Time_ns.Span.Option"
 
-    include Sexpable.To_stringable (struct
-      type nonrec t = t [@@deriving sexp]
+      include Sexpable.To_stringable (struct
+          type nonrec t = t [@@deriving sexp]
+        end)
     end)
-  end)
 
   include Diffable.Atomic.Make (struct
-    type nonrec t = t [@@deriving bin_io, sexp, equal]
-  end)
+      type nonrec t = t [@@deriving bin_io, sexp, equal]
+    end)
 
   include (Int63 : Comparisons.S with type t := t)
 end
Index: core-0.17.1/core/src/span_ns.mli
===================================================================
--- core-0.17.1.orig/core/src/span_ns.mli
+++ core-0.17.1/core/src/span_ns.mli
@@ -22,18 +22,18 @@ module Stable : sig
   end
 
   module V2 : sig
-    type nonrec t = t [@@deriving hash, equal, sexp_grammar, stable_witness]
+    type nonrec t = t [@@deriving hash, equal, sexp_grammar, stable_witness, typerep]
     type nonrec comparator_witness = comparator_witness
 
     include
       Stable_int63able.With_stable_witness.S
-        with type t := t
-        with type comparator_witness := comparator_witness
+      with type t := t
+      with type comparator_witness := comparator_witness
 
     include
       Comparable.Stable.V1.With_stable_witness.S
-        with type comparable := t
-        with type comparator_witness := comparator_witness
+      with type comparable := t
+      with type comparator_witness := comparator_witness
 
     include Stringable.S with type t := t
     include Diffable.S_atomic with type t := t
Index: core-0.17.1/core/src/stable.ml
===================================================================
--- core-0.17.1.orig/core/src/stable.ml
+++ core-0.17.1/core/src/stable.ml
@@ -1,25 +1,29 @@
-module Unit_test = Stable_unit_test.Make
+(* module types *)
 
 module type Stable = Stable_module_types.S0
-module type Stable_without_comparator = Stable_module_types.S0_without_comparator
 module type Stable1 = Stable_module_types.S1
+module type Stable1_with_witness = Stable_module_types.With_stable_witness.S1
 module type Stable2 = Stable_module_types.S2
+module type Stable2_with_witness = Stable_module_types.With_stable_witness.S2
 module type Stable3 = Stable_module_types.S3
+module type Stable3_with_witness = Stable_module_types.With_stable_witness.S3
 module type Stable4 = Stable_module_types.S4
-module type Stable_with_witness = Stable_module_types.With_stable_witness.S0
+module type Stable4_with_witness = Stable_module_types.With_stable_witness.S4
+module type Stable_int63able_without_comparator = Stable_int63able.Without_comparator.S
 module type Stable_int63able_with_witness = Stable_int63able.With_stable_witness.S
+module type Stable_with_witness = Stable_module_types.With_stable_witness.S0
+module type Stable_without_comparator = Stable_module_types.S0_without_comparator
 
 module type Stable_without_comparator_with_witness =
   Stable_module_types.With_stable_witness.S0_without_comparator
 
-module type Stable1_with_witness = Stable_module_types.With_stable_witness.S1
-module type Stable2_with_witness = Stable_module_types.With_stable_witness.S2
-module type Stable3_with_witness = Stable_module_types.With_stable_witness.S3
-module type Stable4_with_witness = Stable_module_types.With_stable_witness.S4
+(* stable helpers *)
 
+module Unit_test = Stable_unit_test.Make
 module Make_stable = Make_stable
-include Stable_internal
-module Hashable = Hashable.Stable
+
+(* aliases for stable submodules *)
+
 module Bigstring = Bigstring.Stable
 module Binable = Binable.Stable
 module Blang = Blang.Stable
@@ -31,7 +35,6 @@ module Comparable = Comparable.Stable
 module Comparator = Comparator.Stable
 module Date = Date.Stable
 module Day_of_week = Day_of_week.Stable
-module Md5 = Md5.Stable
 module Either = Either.Stable
 module Error = Error.Stable
 module Fdeque = Fdeque.Stable
@@ -40,6 +43,7 @@ module Float = Float.Stable
 module Float_with_finite_only_serialization = Float_with_finite_only_serialization.Stable
 module Fqueue = Fqueue.Stable
 module Gc = Gc.Stable
+module Hashable = Hashable.Stable
 module Host_and_port = Host_and_port.Stable
 module Info = Info.Stable
 module Int = Int.Stable
@@ -48,6 +52,8 @@ module Lazy = Lazy.Stable
 module List = List.Stable
 module Map = Map.Stable
 module Maybe_bound = Maybe_bound.Stable
+module Md5 = Md5.Stable
+module Modes = Modes.Stable
 module Month = Month.Stable
 module Nothing = Nothing.Stable
 module Option = Option.Stable
@@ -63,15 +69,15 @@ module Sexpable = Sexpable.Stable
 module Source_code_position = Source_code_position.Stable
 module String = String.Stable
 module String_id = String_id.Stable
-module Time_ns = Time_ns.Stable
-
-module Time = Time_float.Stable
-[@@deprecated "[since 2021-11] Use [Time_float] or [Time_float_unix] instead"]
-
 module Time_float = Time_float.Stable
+module Time_ns = Time_ns.Stable
+module Timezone = Timezone.Stable
 module Uchar = Uchar.Stable
 module Unit = Unit.Stable
-module Unix = struct end [@@deprecated "[since 2021-02] Use [Core_unix.Stable]"]
+
+(* derivers for builtin types *)
+
+include Stable_internal
 include Perms.Export
 include Ppx_compare_lib.Builtin
 include Base.Exported_for_specific_uses.Globalize
Index: core-0.17.1/core/src/stable_comparable.ml
===================================================================
--- core-0.17.1.orig/core/src/stable_comparable.ml
+++ core-0.17.1/core/src/stable_comparable.ml
@@ -3,8 +3,8 @@ module type V1 = sig
 
   include
     Comparable.Stable.V1.S
-      with type comparable := t
-      with type comparator_witness := comparator_witness
+    with type comparable := t
+    with type comparator_witness := comparator_witness
 end
 
 module With_stable_witness = struct
@@ -13,7 +13,7 @@ module With_stable_witness = struct
 
     include
       Comparable.Stable.V1.With_stable_witness.S
-        with type comparable := t
-        with type comparator_witness := comparator_witness
+      with type comparable := t
+      with type comparator_witness := comparator_witness
   end
 end
Index: core-0.17.1/core/src/stable_int63able.ml
===================================================================
--- core-0.17.1.orig/core/src/stable_int63able.ml
+++ core-0.17.1/core/src/stable_int63able.ml
@@ -12,6 +12,15 @@ module type S = sig
   val of_int63_exn : Int63.t -> t
 end
 
+module Without_comparator = struct
+  module type S = sig
+    include Stable_module_types.S0_without_comparator
+
+    val to_int63 : t -> Int63.t
+    val of_int63_exn : Int63.t -> t
+  end
+end
+
 module With_stable_witness = struct
   module type S = sig
     include Stable_module_types.With_stable_witness.S0
Index: core-0.17.1/core/src/stack.ml
===================================================================
--- core-0.17.1.orig/core/src/stack.ml
+++ core-0.17.1/core/src/stack.ml
@@ -1,10 +1,20 @@
 include Base.Stack
 
 include Bin_prot.Utils.Make_binable1_without_uuid [@alert "-legacy"] (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  module Binable = List
+    module Binable = List
 
-  let to_binable = to_list
-  let of_binable = of_list
-end)
+    let to_binable = to_list
+    let of_binable = of_list
+  end)
+
+include
+  Quickcheckable.Of_quickcheckable1
+    (List)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_list
+      let of_quickcheckable = of_list
+    end)
Index: core-0.17.1/core/src/stack.mli
===================================================================
--- core-0.17.1.orig/core/src/stack.mli
+++ core-0.17.1/core/src/stack.mli
@@ -5,3 +5,4 @@ include module type of struct
 end
 
 include Binable.S1 with type 'a t := 'a t
+include Quickcheckable.S1 with type 'a t := 'a t
Index: core-0.17.1/core/src/std_internal.ml
===================================================================
--- core-0.17.1.orig/core/src/std_internal.ml
+++ core-0.17.1/core/src/std_internal.ml
@@ -14,6 +14,7 @@ include From_sexplib
 include Interfaces
 include List.Infix
 include Never_returns
+include Modes.Export
 include Ordering.Export
 include Perms.Export
 include Result.Export
@@ -68,8 +69,10 @@ let round = Float.round
 let ( **. ) = Base.( **. )
 let ( %. ) = Base.( %. )
 let sprintf = Printf.sprintf
-let stage = Staged.stage
-let unstage = Staged.unstage
+
+external stage : ('a[@local_opt]) -> ('a Staged.t[@local_opt]) = "%identity"
+external unstage : ('a Staged.t[@local_opt]) -> ('a[@local_opt]) = "%identity"
+
 let with_return = With_return.with_return
 let with_return_option = With_return.with_return_option
 
@@ -79,10 +82,191 @@ let with_return_option = With_return.wit
 include Typerep_lib.Std_internal
 
 include (
-  struct
-    (* [deriving hash] is missing for [array], [bytes], and [ref] since these types are
+struct
+  (* [deriving hash] is missing for [array], [bytes], and [ref] since these types are
      mutable. *)
-    type 'a array = 'a Array.t
+  type 'a array = 'a Array.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type bool = Bool.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type char = Char.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type float = Float.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type int = Int.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type int32 = Int32.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type int64 = Int64.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type 'a lazy_t = 'a Lazy.t
+  [@@deriving bin_io ~localize, compare ~localize, hash, sexp, sexp_grammar, typerep]
+
+  type 'a list = 'a List.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , hash
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type nativeint = Nativeint.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , hash
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type 'a option = 'a Option.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , hash
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type ('ok, 'err) result = ('ok, 'err) Result.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , hash
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type string = String.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , hash
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type bytes = Bytes.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type 'a ref = 'a Ref.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  type unit = Unit.t
+  [@@deriving
+    bin_io ~localize
+    , compare ~localize
+    , equal ~localize
+    , globalize
+    , hash
+    , sexp
+    , sexp_grammar
+    , typerep]
+
+  (* Bin_prot has optimized functions for float arrays *)
+  include struct
+    type float_array = float array [@@deriving bin_io ~localize]
+  end [@alert "-deprecated"]
+
+  include (
+  struct
+    type float_array = Float.t array
+    [@@deriving compare ~localize, sexp, sexp_grammar, typerep]
+  end :
+    sig
+      type float_array [@@deriving compare ~localize, sexp, sexp_grammar, typerep]
+    end
+    with type float_array := float_array)
+end :
+  sig
+    type 'a array
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -92,87 +276,87 @@ include (
       , sexp_grammar
       , typerep]
 
-    type bool = Bool.t
+    type bool
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type char = Char.t
+    type char
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type float = Float.t
+    type float
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type int = Int.t
+    type int
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type int32 = Int32.t
+    type int32
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type int64 = Int64.t
+    type int64
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type 'a lazy_t = 'a Lazy.t
+    type 'a lazy_t
     [@@deriving bin_io ~localize, compare ~localize, hash, sexp, sexp_grammar, typerep]
 
-    type 'a list = 'a List.t
+    type 'a list
     [@@deriving
       bin_io ~localize
       , compare ~localize
-      , hash
       , equal ~localize
       , globalize
+      , hash
       , sexp
       , sexp_grammar
       , typerep]
 
-    type nativeint = Nativeint.t
+    type nativeint
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -183,7 +367,7 @@ include (
       , sexp_grammar
       , typerep]
 
-    type 'a option = 'a Option.t
+    type 'a option
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -194,7 +378,7 @@ include (
       , sexp_grammar
       , typerep]
 
-    type ('ok, 'err) result = ('ok, 'err) Result.t
+    type ('ok, 'err) result
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -205,7 +389,7 @@ include (
       , sexp_grammar
       , typerep]
 
-    type string = String.t
+    type string
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -216,7 +400,7 @@ include (
       , sexp_grammar
       , typerep]
 
-    type bytes = Bytes.t
+    type bytes
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -226,7 +410,7 @@ include (
       , sexp_grammar
       , typerep]
 
-    type 'a ref = 'a Ref.t
+    type 'a ref
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -236,7 +420,7 @@ include (
       , sexp_grammar
       , typerep]
 
-    type unit = Unit.t
+    type unit
     [@@deriving
       bin_io ~localize
       , compare ~localize
@@ -246,203 +430,22 @@ include (
       , sexp
       , sexp_grammar
       , typerep]
-
-    (* Bin_prot has optimized functions for float arrays *)
-    include struct
-      type float_array = float array [@@deriving bin_io ~localize]
-    end [@alert "-deprecated"]
-
-    include (
-      struct
-        type float_array = Float.t array
-        [@@deriving compare ~localize, sexp, sexp_grammar, typerep]
-      end :
-        sig
-          type float_array [@@deriving compare ~localize, sexp, sexp_grammar, typerep]
-        end
-        with type float_array := float_array)
-  end :
-    sig
-      type 'a array
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type bool
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type char
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type float
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type int
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type int32
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type int64
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type 'a lazy_t
-      [@@deriving bin_io ~localize, compare ~localize, hash, sexp, sexp_grammar, typerep]
-
-      type 'a list
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type nativeint
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type 'a option
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type ('ok, 'err) result
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type string
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type bytes
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type 'a ref
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , sexp
-        , sexp_grammar
-        , typerep]
-
-      type unit
-      [@@deriving
-        bin_io ~localize
-        , compare ~localize
-        , equal ~localize
-        , globalize
-        , hash
-        , sexp
-        , sexp_grammar
-        , typerep]
-    end
-    with type 'a array := 'a array
-    with type bool := bool
-    with type char := char
-    with type float := float
-    with type int := int
-    with type int32 := int32
-    with type int64 := int64
-    with type 'a list := 'a list
-    with type nativeint := nativeint
-    with type 'a option := 'a option
-    with type ('ok, 'err) result := ('ok, 'err) result
-    with type string := string
-    with type bytes := bytes
-    with type 'a lazy_t := 'a lazy_t
-    with type 'a ref := 'a ref
-    with type unit := unit)
+  end
+  with type 'a array := 'a array
+  with type bool := bool
+  with type char := char
+  with type float := float
+  with type int := int
+  with type int32 := int32
+  with type int64 := int64
+  with type 'a list := 'a list
+  with type nativeint := nativeint
+  with type 'a option := 'a option
+  with type ('ok, 'err) result := ('ok, 'err) result
+  with type string := string
+  with type bytes := bytes
+  with type 'a lazy_t := 'a lazy_t
+  with type 'a ref := 'a ref
+  with type unit := unit)
 
 let sexp_of_exn = Exn.sexp_of_t
Index: core-0.17.1/core/src/string.ml
===================================================================
--- core-0.17.1.orig/core/src/string.ml
+++ core-0.17.1/core/src/string.ml
@@ -23,12 +23,12 @@ module Stable = struct
   end
 
   module Make_utf (Utf : sig
-    type t [@@deriving sexp_grammar]
+      type t [@@deriving sexp_grammar]
 
-    include Base.Identifiable.S with type t := t
+      include Base.Identifiable.S with type t := t
 
-    val caller_identity : Bin_shape.Uuid.t
-  end) =
+      val caller_identity : Bin_shape.Uuid.t
+    end) =
   struct
     module V1 = struct
       module T = struct
@@ -57,44 +57,44 @@ module Stable = struct
   end
 
   module Utf8 = Make_utf (struct
-    include Utf8
+      include Utf8
 
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "5bc29e13-1c6f-4b6d-b431-3befb256ebda"
-    ;;
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "5bc29e13-1c6f-4b6d-b431-3befb256ebda"
+      ;;
+    end)
 
   module Utf16le = Make_utf (struct
-    include Utf16le
+      include Utf16le
 
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "7a4f8cac-8fff-11ee-bd11-aaa233d0b6a7"
-    ;;
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "7a4f8cac-8fff-11ee-bd11-aaa233d0b6a7"
+      ;;
+    end)
 
   module Utf16be = Make_utf (struct
-    include Utf16be
+      include Utf16be
 
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "7c3a50ce-8fff-11ee-94c6-aaa233d0b6a7"
-    ;;
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "7c3a50ce-8fff-11ee-94c6-aaa233d0b6a7"
+      ;;
+    end)
 
   module Utf32le = Make_utf (struct
-    include Utf32le
+      include Utf32le
 
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "961d2214-9252-11ee-9f77-aaa233d0b6a7"
-    ;;
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "961d2214-9252-11ee-9f77-aaa233d0b6a7"
+      ;;
+    end)
 
   module Utf32be = Make_utf (struct
-    include Utf32be
+      include Utf32be
 
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "9fcbae5c-9252-11ee-9f34-aaa233d0b6a7"
-    ;;
-  end)
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "9fcbae5c-9252-11ee-9f34-aaa233d0b6a7"
+      ;;
+    end)
 end
 
 module Caseless = struct
@@ -125,15 +125,15 @@ include
 include Comparable.Validate (Base.String)
 
 include Diffable.Atomic.Make (struct
-  type nonrec t = t [@@deriving sexp, bin_io, equal]
-end)
+    type nonrec t = t [@@deriving sexp, bin_io, equal]
+  end)
 
 include Hexdump.Of_indexable (struct
-  type t = string
+    type t = string
 
-  let length = length
-  let get = get
-end)
+    let length = length
+    let get = get
+  end)
 
 let quickcheck_generator = Base_quickcheck.Generator.string
 let quickcheck_observer = Base_quickcheck.Observer.string
Index: core-0.17.1/core/src/string.mli
===================================================================
--- core-0.17.1.orig/core/src/string.mli
+++ core-0.17.1/core/src/string.mli
@@ -83,13 +83,13 @@ module Utf16be :
 
 module Utf32le :
   Utf
-    with type t = Base.String.Utf32le.t
-     and type comparator_witness = Base.String.Utf32le.comparator_witness
+  with type t = Base.String.Utf32le.t
+   and type comparator_witness = Base.String.Utf32le.comparator_witness
 
 module Utf32be :
   Utf
-    with type t = Base.String.Utf32be.t
-     and type comparator_witness = Base.String.Utf32be.comparator_witness
+  with type t = Base.String.Utf32be.t
+   and type comparator_witness = Base.String.Utf32be.comparator_witness
 
 (** Note that [string] is already stable by itself, since as a primitive type it is an
     integral part of the sexp / bin_io protocol. [String.Stable] exists only to introduce
@@ -104,8 +104,8 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-        with type comparator_witness := comparator_witness
+      with type t := t
+      with type comparator_witness := comparator_witness
 
     include Hashable.Stable.V1.With_stable_witness.S with type key := t
   end
@@ -115,8 +115,8 @@ module Stable : sig
 
     include
       Identifiable_without_binio
-        with type t := t
-         and type comparator_witness = comparator_witness
+      with type t := t
+       and type comparator_witness = comparator_witness
   end
 
   module Utf8 : sig
@@ -125,8 +125,8 @@ module Stable : sig
 
       include
         Identifiable_without_binio
-          with type t := t
-           and type comparator_witness = Utf8.comparator_witness
+        with type t := t
+         and type comparator_witness = Utf8.comparator_witness
     end
   end
 
@@ -136,8 +136,8 @@ module Stable : sig
 
       include
         Identifiable_without_binio
-          with type t := t
-           and type comparator_witness = Utf16le.comparator_witness
+        with type t := t
+         and type comparator_witness = Utf16le.comparator_witness
     end
   end
 
@@ -147,8 +147,8 @@ module Stable : sig
 
       include
         Identifiable_without_binio
-          with type t := t
-           and type comparator_witness = Utf16be.comparator_witness
+        with type t := t
+         and type comparator_witness = Utf16be.comparator_witness
     end
   end
 
@@ -158,8 +158,8 @@ module Stable : sig
 
       include
         Identifiable_without_binio
-          with type t := t
-           and type comparator_witness = Utf32le.comparator_witness
+        with type t := t
+         and type comparator_witness = Utf32le.comparator_witness
     end
   end
 
@@ -169,8 +169,8 @@ module Stable : sig
 
       include
         Identifiable_without_binio
-          with type t := t
-           and type comparator_witness = Utf32be.comparator_witness
+        with type t := t
+         and type comparator_witness = Utf32be.comparator_witness
     end
   end
 end
Index: core-0.17.1/core/src/string_id.ml
===================================================================
--- core-0.17.1.orig/core/src/string_id.ml
+++ core-0.17.1/core/src/string_id.ml
@@ -2,13 +2,14 @@ open! Import
 open Std_internal
 include String_id_intf
 
-module Make_with_validate_without_pretty_printer_with_bin_shape (M : sig
-  val module_name : string
-  val validate : string -> unit Or_error.t
-  val include_default_validation : bool
-  val caller_identity : Bin_prot.Shape.Uuid.t option
-end)
-() =
+module Make_with_validate_without_pretty_printer_with_bin_shape
+    (M : sig
+       val module_name : string
+       val validate : string -> unit Or_error.t
+       val include_default_validation : bool
+       val caller_identity : Bin_prot.Shape.Uuid.t option
+     end)
+    () =
 struct
   module Stable = struct
     module V1 = struct
@@ -104,12 +105,13 @@ struct
   let arg_type = Command.Arg_type.create of_string
 end
 
-module Make_with_validate_without_pretty_printer (M : sig
-  val module_name : string
-  val validate : string -> unit Or_error.t
-  val include_default_validation : bool
-end)
-() =
+module Make_with_validate_without_pretty_printer
+    (M : sig
+       val module_name : string
+       val validate : string -> unit Or_error.t
+       val include_default_validation : bool
+     end)
+    () =
 struct
   include
     Make_with_validate_without_pretty_printer_with_bin_shape
@@ -121,10 +123,11 @@ struct
       ()
 end
 
-module Make_without_pretty_printer (M : sig
-  val module_name : string
-end)
-() =
+module Make_without_pretty_printer
+    (M : sig
+       val module_name : string
+     end)
+    () =
 struct
   include
     Make_with_validate_without_pretty_printer
@@ -136,43 +139,46 @@ struct
       ()
 end
 
-module Make_with_validate (M : sig
-  val module_name : string
-  val validate : string -> unit Or_error.t
-  val include_default_validation : bool
-end)
-() =
+module Make_with_validate
+    (M : sig
+       val module_name : string
+       val validate : string -> unit Or_error.t
+       val include_default_validation : bool
+     end)
+    () =
 struct
   include Make_with_validate_without_pretty_printer (M) ()
 
   include Pretty_printer.Register (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    let module_name = M.module_name
-    let to_string = to_string
-  end)
+      let module_name = M.module_name
+      let to_string = to_string
+    end)
 end
 
-module Make (M : sig
-  val module_name : string
-end)
-() =
+module Make
+    (M : sig
+       val module_name : string
+     end)
+    () =
 struct
   include Make_without_pretty_printer (M) ()
 
   include Pretty_printer.Register (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    let module_name = M.module_name
-    let to_string = to_string
-  end)
+      let module_name = M.module_name
+      let to_string = to_string
+    end)
 end
 
-module Make_with_distinct_bin_shape (M : sig
-  val module_name : string
-  val caller_identity : Bin_prot.Shape.Uuid.t
-end)
-() =
+module Make_with_distinct_bin_shape
+    (M : sig
+       val module_name : string
+       val caller_identity : Bin_prot.Shape.Uuid.t
+     end)
+    () =
 struct
   include
     Make_with_validate_without_pretty_printer_with_bin_shape
@@ -185,11 +191,11 @@ struct
       ()
 
   include Pretty_printer.Register (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    let module_name = M.module_name
-    let to_string = to_string
-  end)
+      let module_name = M.module_name
+      let to_string = to_string
+    end)
 end
 
 include
Index: core-0.17.1/core/src/string_id_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/string_id_intf.ml
+++ core-0.17.1/core/src/string_id_intf.ml
@@ -21,8 +21,8 @@ module type S = sig
 
       include
         Stable_comparable.With_stable_witness.V1
-          with type t := t
-          with type comparator_witness = comparator_witness
+        with type t := t
+        with type comparator_witness = comparator_witness
 
       include Hashable.Stable.V1.With_stable_witness.S with type key := t
       include Diffable.S_atomic with type t := t
@@ -54,19 +54,21 @@ module type String_id = sig
 
       The resulting [quickcheck_generator] generates non-empty strings containing only
       printable characters, and no whitespace at the edges. *)
-  module Make (M : sig
-    val module_name : string
-  end)
-  () : S_with_extras
+  module Make
+      (M : sig
+         val module_name : string
+       end)
+      () : S_with_extras
 
   (** Like [Make], but lets you specify a [caller_identity] to ensure that the bin-shape
       is distinct, which helps catch serialization bugs where identifiers with different
       meanings get confused with each other. *)
-  module Make_with_distinct_bin_shape (M : sig
-    val module_name : string
-    val caller_identity : Bin_prot.Shape.Uuid.t
-  end)
-  () : S_with_extras
+  module Make_with_distinct_bin_shape
+      (M : sig
+         val module_name : string
+         val caller_identity : Bin_prot.Shape.Uuid.t
+       end)
+      () : S_with_extras
 
   (** [Make_with_validate] is like [Make], but modifies [of_string]/[of_sexp]/[bin_read_t]
       to raise if [validate] returns an error.  Before using this functor
@@ -79,36 +81,39 @@ module type String_id = sig
       trying to generate a satisfying string. In these cases, the client should shadow
       [quickcheck_generator] with a generator that constructs valid strings more directly.
   *)
-  module Make_with_validate (M : sig
-    val module_name : string
-    val validate : string -> unit Or_error.t
+  module Make_with_validate
+      (M : sig
+         val module_name : string
+         val validate : string -> unit Or_error.t
 
-    (** By default, String_id performs some validation of its own in addition to calling
+         (** By default, String_id performs some validation of its own in addition to calling
              [validate], namely:
 
              - The string cannot be empty;
              - The string may not have whitespace at the beginning or the end.
 
              You can turn this validation off using this flag. *)
-    val include_default_validation : bool
-  end)
-  () : S_with_extras
+         val include_default_validation : bool
+       end)
+      () : S_with_extras
 
   (** This does what [Make] does without registering a pretty printer.  Use this when the
       module that is made is not exposed in mli.  Registering a pretty printer without
       exposing it causes an error in utop. *)
-  module Make_without_pretty_printer (M : sig
-    val module_name : string
-  end)
-  () : S_with_extras
+  module Make_without_pretty_printer
+      (M : sig
+         val module_name : string
+       end)
+      () : S_with_extras
 
   (** See [Make_with_validate] and [Make_without_pretty_printer] *)
-  module Make_with_validate_without_pretty_printer (M : sig
-    val module_name : string
-    val validate : string -> unit Or_error.t
-    val include_default_validation : bool
-  end)
-  () : S_with_extras
+  module Make_with_validate_without_pretty_printer
+      (M : sig
+         val module_name : string
+         val validate : string -> unit Or_error.t
+         val include_default_validation : bool
+       end)
+      () : S_with_extras
 
   module String_without_validation_without_pretty_printer : S with type t = string
 end
Index: core-0.17.1/core/src/substring.ml
===================================================================
--- core-0.17.1.orig/core/src/substring.ml
+++ core-0.17.1/core/src/substring.ml
@@ -3,18 +3,18 @@ open! Import
 module type S = Make_substring.S
 
 include Make_substring.F (struct
-  type t = Bytes.t [@@deriving quickcheck]
+    type t = Bytes.t [@@deriving quickcheck]
 
-  let create = Bytes.create
-  let length = Bytes.length
-  let get = Bytes.get
+    let create = Bytes.create
+    let length = Bytes.length
+    let get t i = Bytes.get t i
 
-  module Blit = Make_substring.Blit
+    module Blit = Make_substring.Blit
 
-  let blit = Blit.bytes_bytes
-  let blit_to_string = Blit.bytes_bytes
-  let blit_to_bytes = Blit.bytes_bytes
-  let blit_to_bigstring = Blit.bytes_bigstring
-  let blit_from_string = Blit.string_bytes
-  let blit_from_bigstring = Blit.bigstring_bytes
-end)
+    let blit = Blit.bytes_bytes
+    let blit_to_string = Blit.bytes_bytes
+    let blit_to_bytes = Blit.bytes_bytes
+    let blit_to_bigstring = Blit.bytes_bigstring
+    let blit_from_string = Blit.string_bytes
+    let blit_from_bigstring = Blit.bigstring_bytes
+  end)
Index: core-0.17.1/core/src/substring_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/substring_intf.ml
+++ core-0.17.1/core/src/substring_intf.ml
@@ -64,7 +64,7 @@ module type S = sig
   val of_string : string -> t [@@deprecated "[since 2017-11] use [create] instead"]
 
   val of_bigstring : Bigstring.t -> t
-    [@@deprecated "[since 2017-11] use [create] instead"]
+  [@@deprecated "[since 2017-11] use [create] instead"]
 
   (** {2 Prefixes and suffixes}
 
Index: core-0.17.1/core/src/temporal-polyfill/temporal-polyfill.js
===================================================================
--- core-0.17.1.orig/core/src/temporal-polyfill/temporal-polyfill.js
+++ core-0.17.1/core/src/temporal-polyfill/temporal-polyfill.js
@@ -1,8917 +1,12161 @@
-function _iterableToArrayLimit(r, l) {
-  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
-  if (null != t) {
-    var e,
-      n,
-      i,
-      u,
-      a = [],
-      f = !0,
-      o = !1;
-    try {
-      if (i = (t = t.call(r)).next, 0 === l) {
-        if (Object(t) !== t) return;
-        f = !1;
-      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
-    } catch (r) {
-      o = !0, n = r;
-    } finally {
-      try {
-        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
-      } finally {
-        if (o) throw n;
-      }
-    }
-    return a;
-  }
-}
-function ownKeys(e, r) {
-  var t = Object.keys(e);
-  if (Object.getOwnPropertySymbols) {
-    var o = Object.getOwnPropertySymbols(e);
-    r && (o = o.filter(function (r) {
-      return Object.getOwnPropertyDescriptor(e, r).enumerable;
-    })), t.push.apply(t, o);
-  }
-  return t;
-}
-function _objectSpread2(e) {
-  for (var r = 1; r < arguments.length; r++) {
-    var t = null != arguments[r] ? arguments[r] : {};
-    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
-      _defineProperty(e, r, t[r]);
-    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
-      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
-    });
-  }
-  return e;
-}
-function _toPrimitive(t, r) {
-  if ("object" != typeof t || !t) return t;
-  var e = t[Symbol.toPrimitive];
-  if (void 0 !== e) {
-    var i = e.call(t, r || "default");
-    if ("object" != typeof i) return i;
-    throw new TypeError("@@toPrimitive must return a primitive value.");
-  }
-  return ("string" === r ? String : Number)(t);
-}
-function _toPropertyKey(t) {
-  var i = _toPrimitive(t, "string");
-  return "symbol" == typeof i ? i : String(i);
-}
-function _typeof(o) {
-  "@babel/helpers - typeof";
-
-  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
-    return typeof o;
-  } : function (o) {
-    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
-  }, _typeof(o);
-}
-function _classCallCheck(instance, Constructor) {
-  if (!(instance instanceof Constructor)) {
-    throw new TypeError("Cannot call a class as a function");
-  }
-}
-function _defineProperties(target, props) {
-  for (var i = 0; i < props.length; i++) {
-    var descriptor = props[i];
-    descriptor.enumerable = descriptor.enumerable || false;
-    descriptor.configurable = true;
-    if ("value" in descriptor) descriptor.writable = true;
-    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
-  }
-}
-function _createClass(Constructor, protoProps, staticProps) {
-  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
-  if (staticProps) _defineProperties(Constructor, staticProps);
-  Object.defineProperty(Constructor, "prototype", {
-    writable: false
-  });
-  return Constructor;
-}
-function _defineProperty(obj, key, value) {
-  key = _toPropertyKey(key);
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-function _inherits(subClass, superClass) {
-  if (typeof superClass !== "function" && superClass !== null) {
-    throw new TypeError("Super expression must either be null or a function");
-  }
-  subClass.prototype = Object.create(superClass && superClass.prototype, {
-    constructor: {
-      value: subClass,
-      writable: true,
-      configurable: true
-    }
-  });
-  Object.defineProperty(subClass, "prototype", {
-    writable: false
-  });
-  if (superClass) _setPrototypeOf(subClass, superClass);
-}
-function _getPrototypeOf(o) {
-  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
-    return o.__proto__ || Object.getPrototypeOf(o);
-  };
-  return _getPrototypeOf(o);
-}
-function _setPrototypeOf(o, p) {
-  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
-    o.__proto__ = p;
-    return o;
-  };
-  return _setPrototypeOf(o, p);
-}
-function _isNativeReflectConstruct() {
-  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
-  if (Reflect.construct.sham) return false;
-  if (typeof Proxy === "function") return true;
-  try {
-    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
-    return true;
-  } catch (e) {
-    return false;
-  }
-}
-function _assertThisInitialized(self) {
-  if (self === void 0) {
-    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-  }
-  return self;
-}
-function _possibleConstructorReturn(self, call) {
-  if (call && (typeof call === "object" || typeof call === "function")) {
-    return call;
-  } else if (call !== void 0) {
-    throw new TypeError("Derived constructors may only return object or undefined");
-  }
-  return _assertThisInitialized(self);
-}
-function _createSuper(Derived) {
-  var hasNativeReflectConstruct = _isNativeReflectConstruct();
-  return function _createSuperInternal() {
-    var Super = _getPrototypeOf(Derived),
-      result;
-    if (hasNativeReflectConstruct) {
-      var NewTarget = _getPrototypeOf(this).constructor;
-      result = Reflect.construct(Super, arguments, NewTarget);
-    } else {
-      result = Super.apply(this, arguments);
-    }
-    return _possibleConstructorReturn(this, result);
-  };
-}
-function _superPropBase(object, property) {
-  while (!Object.prototype.hasOwnProperty.call(object, property)) {
-    object = _getPrototypeOf(object);
-    if (object === null) break;
-  }
-  return object;
+function _callSuper(t, o, e){
+ return o = _getPrototypeOf(o),
+        _possibleConstructorReturn
+         (t,
+          _isNativeReflectConstruct()
+           ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor)
+           : o.apply(t, e));
+}
+function _isNativeReflectConstruct(){
+ try{
+  var
+   t =
+     !
+     Boolean.prototype.valueOf.call
+      (Reflect.construct(Boolean, [], function(){}));
+ }
+ catch(t){}
+ return (_isNativeReflectConstruct = function(){return ! ! t;})();
+}
+function _iterableToArrayLimit(r, l){
+ var
+  t =
+    null == r
+     ? null
+     : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
+ if(null != t){
+  var e, n, i, u, a = [], f = ! 0, o = ! 1;
+  try{
+   if(i = (t = t.call(r)).next, 0 === l){if(Object(t) !== t) return; f = ! 1;
+   }
+   else
+    for
+    (;
+     ! (f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l);
+     f = ! 0)
+     ;
+  }
+  catch(r){o = ! 0, n = r;}
+  finally{
+   try{
+    if(! f && null != t.return && (u = t.return(), Object(u) !== u)) return;
+   }
+   finally{if(o) throw n;}
+  }
+  return a;
+ }
+}
+function ownKeys(e, r){
+ var t = Object.keys(e);
+ if(Object.getOwnPropertySymbols){
+  var o = Object.getOwnPropertySymbols(e);
+  r
+  &&
+   (o =
+    o.filter
+     (function(r){return Object.getOwnPropertyDescriptor(e, r).enumerable;})),
+  t.push.apply(t, o);
+ }
+ return t;
+}
+function _objectSpread2(e){
+ for(var r = 1; r < arguments.length; r++){
+  var t = null != arguments[r] ? arguments[r] : {};
+  r % 2
+   ? ownKeys
+      (Object(t), ! 0).forEach
+     (function(r){_defineProperty(e, r, t[r]);})
+   : Object.getOwnPropertyDescriptors
+     ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
+     : ownKeys
+        (Object(t)).forEach
+       (function(r){
+         Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
+        });
+ }
+ return e;
 }
-function _get() {
-  if (typeof Reflect !== "undefined" && Reflect.get) {
-    _get = Reflect.get.bind();
-  } else {
-    _get = function _get(target, property, receiver) {
-      var base = _superPropBase(target, property);
-      if (!base) return;
-      var desc = Object.getOwnPropertyDescriptor(base, property);
-      if (desc.get) {
-        return desc.get.call(arguments.length < 3 ? target : receiver);
-      }
-      return desc.value;
+function _toPrimitive(t, r){
+ if("object" != typeof t || ! t) return t;
+ var e = t[Symbol.toPrimitive];
+ if(void 0 !== e){
+  var i = e.call(t, r || "default");
+  if("object" != typeof i) return i;
+  throw new TypeError("@@toPrimitive must return a primitive value.");
+ }
+ return ("string" === r ? String : Number)(t);
+}
+function _toPropertyKey(t){
+ var i = _toPrimitive(t, "string");
+ return "symbol" == typeof i ? i : i + "";
+}
+function _typeof(o){
+ "@babel/helpers - typeof";
+ return _typeof =
+         "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
+          ? function(o){return typeof o;}
+          : function
+           (o){
+            return o && "function" == typeof Symbol
+                    && o.constructor === Symbol
+                    && o !== Symbol.prototype
+                    ? "symbol"
+                    : typeof o;
+           },
+        _typeof(o);
+}
+function _classCallCheck(instance, Constructor){
+ if(! (instance instanceof Constructor)){
+  throw new TypeError("Cannot call a class as a function");
+ }
+}
+function _defineProperties(target, props){
+ for(var i = 0; i < props.length; i++){
+  var descriptor = props[i];
+  descriptor.enumerable = descriptor.enumerable || false;
+  descriptor.configurable = true;
+  if("value" in descriptor) descriptor.writable = true;
+  Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
+ }
+}
+function _createClass(Constructor, protoProps, staticProps){
+ if(protoProps) _defineProperties(Constructor.prototype, protoProps);
+ if(staticProps) _defineProperties(Constructor, staticProps);
+ Object.defineProperty(Constructor, "prototype", {writable: false});
+ return Constructor;
+}
+function _defineProperty(obj, key, value){
+ key = _toPropertyKey(key);
+ if(key in obj){
+  Object.defineProperty
+   (obj,
+    key,
+    {value: value, enumerable: true, configurable: true, writable: true});
+ }
+ else{obj[key] = value;}
+ return obj;
+}
+function _inherits(subClass, superClass){
+ if(typeof superClass !== "function" && superClass !== null){
+  throw new TypeError("Super expression must either be null or a function");
+ }
+ subClass.prototype =
+  Object.create
+   (superClass && superClass.prototype,
+    {constructor: {value: subClass, writable: true, configurable: true}});
+ Object.defineProperty(subClass, "prototype", {writable: false});
+ if(superClass) _setPrototypeOf(subClass, superClass);
+}
+function _getPrototypeOf(o){
+ _getPrototypeOf =
+  Object.setPrototypeOf
+   ? Object.getPrototypeOf.bind()
+   : function
+    _getPrototypeOf
+    (o){
+     return o.__proto__ || Object.getPrototypeOf(o);
     };
-  }
-  return _get.apply(this, arguments);
-}
-function _slicedToArray(arr, i) {
-  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
+ return _getPrototypeOf(o);
 }
-function _toConsumableArray(arr) {
-  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
+function _setPrototypeOf(o, p){
+ _setPrototypeOf =
+  Object.setPrototypeOf
+   ? Object.setPrototypeOf.bind()
+   : function _setPrototypeOf(o, p){o.__proto__ = p; return o;};
+ return _setPrototypeOf(o, p);
+}
+function _assertThisInitialized(self){
+ if(self === void 0){
+  throw new
+         ReferenceError
+         ("this hasn't been initialised - super() hasn't been called");
+ }
+ return self;
+}
+function _possibleConstructorReturn(self, call){
+ if(call && (typeof call === "object" || typeof call === "function")){return call;}
+ else if(call !== void 0){
+  throw new
+         TypeError
+         ("Derived constructors may only return object or undefined");
+ }
+ return _assertThisInitialized(self);
+}
+function _superPropBase(object, property){
+ while(! Object.prototype.hasOwnProperty.call(object, property)){object = _getPrototypeOf(object); if(object === null) break;}
+ return object;
+}
+function _get(){
+ if(typeof Reflect !== "undefined" && Reflect.get){_get = Reflect.get.bind();}
+ else{
+  _get =
+   function _get(target, property, receiver){
+    var base = _superPropBase(target, property);
+    if(! base) return;
+    var desc = Object.getOwnPropertyDescriptor(base, property);
+    if(desc.get){
+     return desc.get.call(arguments.length < 3 ? target : receiver);
+    }
+    return desc.value;
+   };
+ }
+ return _get.apply(this, arguments);
+}
+function _slicedToArray(arr, i){
+ return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i)
+        || _unsupportedIterableToArray(arr, i)
+        || _nonIterableRest();
+}
+function _toConsumableArray(arr){
+ return _arrayWithoutHoles(arr) || _iterableToArray(arr)
+        || _unsupportedIterableToArray(arr)
+        || _nonIterableSpread();
+}
+function _arrayWithoutHoles(arr){
+ if(Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+function _arrayWithHoles(arr){if(Array.isArray(arr)) return arr;}
+function _iterableToArray(iter){
+ if
+  (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null
+   || iter["@@iterator"] != null)
+  return Array.from(iter);
+}
+function _unsupportedIterableToArray(o, minLen){
+ if(! o) return;
+ if(typeof o === "string") return _arrayLikeToArray(o, minLen);
+ var n = Object.prototype.toString.call(o).slice(8, - 1);
+ if(n === "Object" && o.constructor) n = o.constructor.name;
+ if(n === "Map" || n === "Set") return Array.from(o);
+ if(n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+  return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len){
+ if(len == null || len > arr.length) len = arr.length;
+ for(var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+ return arr2;
+}
+function _nonIterableSpread(){
+ throw new
+        TypeError
+        ("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+}
+function _nonIterableRest(){
+ throw new
+        TypeError
+        ("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+}
+function _createForOfIteratorHelper(o, allowArrayLike){
+ var
+  it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
+ if(! it){
+  if
+   (Array.isArray(o) || (it = _unsupportedIterableToArray(o))
+    || allowArrayLike && o && typeof o.length === "number"){
+   if(it) o = it;
+   var i = 0;
+   var F = function(){};
+   return {s: F,
+           n:
+           function(){
+            if(i >= o.length) return {done: true};
+            return {done: false, value: o[i++]};
+           },
+           e: function(e){throw e;},
+           f: F};
+  }
+  throw new
+         TypeError
+         ("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+ }
+ var normalCompletion = true, didErr = false, err;
+ return {s: function(){it = it.call(o);},
+         n:
+         function(){
+          var step = it.next();
+          normalCompletion = step.done;
+          return step;
+         },
+         e: function(e){didErr = true; err = e;},
+         f:
+         function(){
+          try{if(! normalCompletion && it.return != null) it.return();}
+          finally{if(didErr) throw err;}
+         }};
 }
-function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
-}
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-function _iterableToArray(iter) {
-  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
-}
-function _unsupportedIterableToArray(o, minLen) {
-  if (!o) return;
-  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
-  var n = Object.prototype.toString.call(o).slice(8, -1);
-  if (n === "Object" && o.constructor) n = o.constructor.name;
-  if (n === "Map" || n === "Set") return Array.from(o);
-  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
-}
-function _arrayLikeToArray(arr, len) {
-  if (len == null || len > arr.length) len = arr.length;
-  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
-  return arr2;
-}
-function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
-}
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
-}
-function _createForOfIteratorHelper(o, allowArrayLike) {
-  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
-  if (!it) {
-    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
-      if (it) o = it;
-      var i = 0;
-      var F = function () {};
-      return {
-        s: F,
-        n: function () {
-          if (i >= o.length) return {
-            done: true
-          };
-          return {
-            done: false,
-            value: o[i++]
-          };
-        },
-        e: function (e) {
-          throw e;
-        },
-        f: F
-      };
-    }
-    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
-  }
-  var normalCompletion = true,
-    didErr = false,
-    err;
-  return {
-    s: function () {
-      it = it.call(o);
-    },
-    n: function () {
-      var step = it.next();
-      normalCompletion = step.done;
-      return step;
-    },
-    e: function (e) {
-      didErr = true;
-      err = e;
-    },
-    f: function () {
-      try {
-        if (!normalCompletion && it.return != null) it.return();
-      } finally {
-        if (didErr) throw err;
-      }
-    }
-  };
-}
-
 var t = {};
-function MakeIntrinsicClass(e, t) {
-  Object.defineProperty(e.prototype, Symbol.toStringTag, {
-    value: t,
-    writable: !1,
-    enumerable: !1,
-    configurable: !0
-  });
-  var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(e)),
-    _step;
-  try {
-    for (_iterator.s(); !(_step = _iterator.n()).done;) {
-      var _t = _step.value;
-      var _r = Object.getOwnPropertyDescriptor(e, _t);
-      _r.configurable && _r.enumerable && (_r.enumerable = !1, Object.defineProperty(e, _t, _r));
-    }
-  } catch (err) {
-    _iterator.e(err);
-  } finally {
-    _iterator.f();
-  }
-  var _iterator2 = _createForOfIteratorHelper(Object.getOwnPropertyNames(e.prototype)),
-    _step2;
-  try {
-    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
-      var _t2 = _step2.value;
-      var _r2 = Object.getOwnPropertyDescriptor(e.prototype, _t2);
-      _r2.configurable && _r2.enumerable && (_r2.enumerable = !1, Object.defineProperty(e.prototype, _t2, _r2));
-    }
-  } catch (err) {
-    _iterator2.e(err);
-  } finally {
-    _iterator2.f();
-  }
-  DefineIntrinsic(t, e), DefineIntrinsic("".concat(t, ".prototype"), e.prototype);
-}
-function DefineIntrinsic(e, r) {
-  var o = "%".concat(e, "%");
-  if (void 0 !== t[o]) throw new Error("intrinsic ".concat(e, " already exists"));
-  t[o] = r;
-}
-function GetIntrinsic(e) {
-  return t[e];
+function MakeIntrinsicClass(e, t){
+ Object.defineProperty
+  (e.prototype,
+   Symbol.toStringTag,
+   {value: t, writable: ! 1, enumerable: ! 1, configurable: ! 0});
+ var
+  _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(e)),
+  _step;
+ try{
+  for(_iterator.s(); ! (_step = _iterator.n()).done;){
+   var _t = _step.value;
+   var _r = Object.getOwnPropertyDescriptor(e, _t);
+   _r.configurable && _r.enumerable
+   && (_r.enumerable = ! 1, Object.defineProperty(e, _t, _r));
+  }
+ }
+ catch(err){_iterator.e(err);}
+ finally{_iterator.f();}
+ var
+  _iterator2 =
+    _createForOfIteratorHelper(Object.getOwnPropertyNames(e.prototype)),
+  _step2;
+ try{
+  for(_iterator2.s(); ! (_step2 = _iterator2.n()).done;){
+   var _t2 = _step2.value;
+   var _r2 = Object.getOwnPropertyDescriptor(e.prototype, _t2);
+   _r2.configurable && _r2.enumerable
+   && (_r2.enumerable = ! 1, Object.defineProperty(e.prototype, _t2, _r2));
+  }
+ }
+ catch(err){_iterator2.e(err);}
+ finally{_iterator2.f();}
+ DefineIntrinsic(t, e),
+ DefineIntrinsic("".concat(t, ".prototype"), e.prototype);
+}
+function DefineIntrinsic(e, r){
+ var o = "%".concat(e, "%");
+ if(void 0 !== t[o])
+  throw new Error("intrinsic ".concat(e, " already exists"));
+ t[o] = r;
 }
+function GetIntrinsic(e){return t[e];}
 var r, o;
-var n = "slot-epochNanoSeconds",
-  a = "slot-timezone-identifier",
-  i = "slot-year",
-  s = "slot-month",
-  l = "slot-day",
-  d = "slot-hour",
-  m = "slot-minute",
-  c = "slot-second",
-  h = "slot-millisecond",
-  u = "slot-microsecond",
-  T = "slot-nanosecond",
-  p = "slot-calendar",
-  f = "slot-date-brand",
-  y = "slot-year-month-brand",
-  I = "slot-month-day-brand",
-  S = "slot-cached-instant",
-  g = "slot-time-zone",
-  w = "slot-years",
-  D = "slot-months",
-  G = "slot-weeks",
-  v = "slot-days",
-  C = "slot-hours",
-  O = "slot-minutes",
-  b = "slot-seconds",
-  E = "slot-milliseconds",
-  M = "slot-microseconds",
-  R = "slot-nanoseconds",
-  F = "slot-calendar-identifier",
-  Y = new WeakMap();
+var
+ n = "slot-epochNanoSeconds",
+ a = "slot-timezone-identifier",
+ i = "slot-year",
+ s = "slot-month",
+ l = "slot-day",
+ d = "slot-hour",
+ m = "slot-minute",
+ c = "slot-second",
+ h = "slot-millisecond",
+ u = "slot-microsecond",
+ T = "slot-nanosecond",
+ p = "slot-calendar",
+ f = "slot-date-brand",
+ y = "slot-year-month-brand",
+ I = "slot-month-day-brand",
+ S = "slot-cached-instant",
+ g = "slot-time-zone",
+ w = "slot-years",
+ D = "slot-months",
+ G = "slot-weeks",
+ v = "slot-days",
+ C = "slot-hours",
+ O = "slot-minutes",
+ b = "slot-seconds",
+ E = "slot-milliseconds",
+ M = "slot-microseconds",
+ R = "slot-nanoseconds",
+ F = "slot-calendar-identifier",
+ Y = new WeakMap();
 var P = Symbol["for"]("@@Temporal__GetSlots");
-(r = globalThis)[P] || (r[P] = function _GetSlots(e) {
-  return Y.get(e);
-});
+(r = globalThis)[P] || (r[P] = function _GetSlots(e){return Y.get(e);});
 var Z = globalThis[P];
 var B = Symbol["for"]("@@Temporal__CreateSlots");
-(o = globalThis)[B] || (o[B] = function _CreateSlots(e) {
-  Y.set(e, Object.create(null));
-});
+(o = globalThis)[B]
+|| (o[B] = function _CreateSlots(e){Y.set(e, Object.create(null));});
 var N = globalThis[B];
-function HasSlot(e) {
-  if (!e || "object" != _typeof(e)) return !1;
-  var r = Z(e);
-  for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
-    t[_key - 1] = arguments[_key];
-  }
-  return !!r && t.every(function (e) {
-    return e in r;
-  });
-}
-function GetSlot(e, t) {
-  var _Z;
-  var r = (_Z = Z(e)) === null || _Z === void 0 ? void 0 : _Z[t];
-  if (void 0 === r) throw new TypeError("Missing internal slot ".concat(t));
-  return r;
-}
-function SetSlot(e, t, r) {
-  var o = Z(e);
-  if (void 0 === o) throw new TypeError("Missing slots for the given container");
-  if (o[t]) throw new TypeError("".concat(t, " already has set"));
-  o[t] = r;
-}
-var j = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,
-  $ = new RegExp("(?:" + ["(?:".concat(j.source, ")(?:\\/(?:").concat(j.source, "))*"), "Etc/GMT(?:0|[-+]\\d{1,2})", "GMT[-+]?0", "EST5EDT", "CST6CDT", "MST7MDT", "PST8PDT", /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join("|") + ")"),
-  k = /(?:[+\u2212-]\d{6}|\d{4})/,
-  U = /(?:0[1-9]|1[0-2])/,
-  A = /(?:0[1-9]|[12]\d|3[01])/,
-  L = new RegExp("(".concat(k.source, ")(?:-(").concat(U.source, ")-(").concat(A.source, ")|(").concat(U.source, ")(").concat(A.source, "))")),
-  x = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,
-  W = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,
-  q = new RegExp("([zZ])|".concat(W.source, "?")),
-  H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g,
-  V = new RegExp(["^".concat(L.source), "(?:(?:T|\\s+)".concat(x.source, "(?:").concat(q.source, ")?)?"), "(?:\\[!?(".concat($.source, ")\\])?"), "((?:".concat(H.source, ")*)$")].join(""), "i"),
-  z = new RegExp(["^T?".concat(x.source), "(?:".concat(q.source, ")?"), "(?:\\[!?".concat($.source, "\\])?"), "((?:".concat(H.source, ")*)$")].join(""), "i"),
-  _ = new RegExp("^(".concat(k.source, ")-?(").concat(U.source, ")(?:\\[!?").concat($.source, "\\])?((?:").concat(H.source, ")*)$")),
-  J = new RegExp("^(?:--)?(".concat(U.source, ")-?(").concat(A.source, ")(?:\\[!?").concat($.source, "\\])?((?:").concat(H.source, ")*)$")),
-  K = /(\d+)(?:[.,](\d{1,9}))?/,
-  X = new RegExp("(?:".concat(K.source, "H)?(?:").concat(K.source, "M)?(?:").concat(K.source, "S)?")),
-  Q = new RegExp("^([+\u2212-])?P".concat(/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source, "(?:T(?!$)").concat(X.source, ")?$"), "i"),
-  ee = Array.prototype.includes,
-  te = Array.prototype.push,
-  re = globalThis.Intl.DateTimeFormat,
-  oe = Math.min,
-  ne = Math.max,
-  ae = Math.abs,
-  ie = Math.floor,
-  se = Math.sign,
-  le = Math.trunc,
-  de = Number.isNaN,
-  me = Number.isFinite,
-  ce = Number,
-  he = String,
-  ue = Number.MAX_SAFE_INTEGER,
-  Te = Object.create,
-  pe = Object.getOwnPropertyDescriptor,
-  fe = Reflect.apply,
-  ye = Reflect.ownKeys,
-  Ie = 0n,
-  Se = 1n,
-  ge = 60n,
-  we = 24n,
-  De = 1000n,
-  Ge = 1000000n,
-  ve = 1000000000n,
-  Ce = BigInt(-1),
-  Oe = 3600n * ve,
-  be = ge * ve,
-  Ee = Oe * we,
-  Me = BigInt(-86400) * 100000000000000000n,
-  Re = 86400n * 100000000000000000n,
-  Fe = -271821,
-  Ye = 275760,
-  Pe = BigInt(-388152) * 10000000000000n,
-  Ze = Ee * 3660n,
-  Be = Ee * 366n,
-  Ne = Ee * 14n,
-  je = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
-function isZero(t) {
-  return t === Ie;
-}
-function GetMethod(e, t) {
-  var r = e[t];
-  if (void 0 !== r) return r;
-}
-function Call(e, t, r) {
-  var o = arguments.length > 2 ? r : [];
-  return fe(e, t, o);
-}
-function IsObject(e) {
-  return "object" == _typeof(e) && null !== e || "function" == typeof e;
-}
-function ToNumber(e) {
-  if ("bigint" == typeof e) throw new TypeError("Cannot convert BigInt to number");
-  return ce(e);
-}
-function ToIntegerOrInfinity(e) {
-  var t = ToNumber(e);
-  if (de(t) || 0 === t) return 0;
-  if (!me(t)) return t;
-  var r = ie(ae(t));
-  return 0 === r ? 0 : se(t) * r;
-}
-function IsIntegralNumber(e) {
-  if ("number" != typeof e || de(e) || !me(e)) return !1;
-  var t = ae(e);
-  return ie(t) === t;
-}
-function ToString(e) {
-  if ("symbol" == _typeof(e)) throw new TypeError("Cannot convert a Symbol value to a String");
-  return he(e);
-}
-function ToIntegerWithTruncation(e) {
-  var t = ToNumber(e);
-  if (0 === t) return 0;
-  if (de(t) || !me(t)) throw new RangeError("invalid number value");
-  var r = le(t);
-  return 0 === r ? 0 : r;
-}
-function ToPositiveIntegerWithTruncation(e, t) {
-  var r = ToIntegerWithTruncation(e);
-  if (r <= 0) {
-    if (void 0 !== t) throw new RangeError("property '".concat(t, "' cannot be a a number less than one"));
-    throw new RangeError("Cannot convert a number less than one to a positive integer");
-  }
-  return r;
-}
-function ToIntegerIfIntegral(e) {
-  var t = ToNumber(e);
-  if (!me(t)) throw new RangeError("infinity is out of range");
-  if (!IsIntegralNumber(t)) throw new RangeError("unsupported fractional value ".concat(e));
-  return 0 === t ? 0 : t;
-}
-function divmod(t, r) {
-  return {
-    quotient: t / r,
-    remainder: t % r
-  };
-}
-function isNegativeJSBI(t) {
-  return t < Ie;
-}
-function signJSBI(e) {
-  return isZero(e) ? 0 : isNegativeJSBI(e) ? -1 : 1;
-}
-function abs(t) {
-  return t < Ie ? t * Ce : t;
-}
-var $e = new Map([["year", ToIntegerWithTruncation], ["month", ToPositiveIntegerWithTruncation], ["monthCode", ToString], ["day", ToPositiveIntegerWithTruncation], ["hour", ToIntegerWithTruncation], ["minute", ToIntegerWithTruncation], ["second", ToIntegerWithTruncation], ["millisecond", ToIntegerWithTruncation], ["microsecond", ToIntegerWithTruncation], ["nanosecond", ToIntegerWithTruncation], ["years", ToIntegerIfIntegral], ["months", ToIntegerIfIntegral], ["weeks", ToIntegerIfIntegral], ["days", ToIntegerIfIntegral], ["hours", ToIntegerIfIntegral], ["minutes", ToIntegerIfIntegral], ["seconds", ToIntegerIfIntegral], ["milliseconds", ToIntegerIfIntegral], ["microseconds", ToIntegerIfIntegral], ["nanoseconds", ToIntegerIfIntegral], ["era", ToString], ["eraYear", ToIntegerOrInfinity], ["offset", ToString]]),
-  ke = new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]),
-  Ue = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]],
-  Ae = new Map(Ue.map(function (e) {
-    return [e[0], e[1]];
-  })),
-  Le = new Map(Ue.map(function (_ref) {
-    var _ref2 = _slicedToArray(_ref, 2),
-      e = _ref2[0],
-      t = _ref2[1];
-    return [t, e];
-  })),
-  xe = Ue.map(function (_ref3) {
-    var _ref4 = _slicedToArray(_ref3, 2),
-      e = _ref4[1];
-    return e;
-  }),
-  We = Array.from(Ae.keys()).sort(),
-  qe = new Map();
-function getIntlDateTimeFormatEnUsForTimeZone(e) {
-  var t = qe.get(e);
-  return void 0 === t && (t = new re("en-us", {
-    timeZone: he(e),
-    hour12: !1,
-    era: "short",
-    year: "numeric",
-    month: "numeric",
-    day: "numeric",
-    hour: "numeric",
-    minute: "numeric",
-    second: "numeric"
-  }), qe.set(e, t)), t;
-}
-function ToObject(e) {
-  if (null == e) throw new TypeError("Expected object not ".concat(e));
-  return Object(e);
-}
-function CopyDataProperties(e, t, r, o) {
-  if (null == t) return;
-  var n = ye(t);
-  var _iterator3 = _createForOfIteratorHelper(n),
-    _step3;
-  try {
-    var _loop = function _loop() {
+function HasSlot(e){
+ if(! e || "object" != _typeof(e)) return ! 1;
+ var r = Z(e);
+ for
+ (var
+   _len = arguments.length,
+   t = new Array(_len > 1 ? _len - 1 : 0),
+   _key = 1;
+  _key < _len;
+  _key++){t[_key - 1] = arguments[_key];}
+ return ! ! r && t.every(function(e){return e in r;});
+}
+function GetSlot(e, t){
+ var _Z;
+ var r = (_Z = Z(e)) === null || _Z === void 0 ? void 0 : _Z[t];
+ if(void 0 === r) throw new TypeError("Missing internal slot ".concat(t));
+ return r;
+}
+function SetSlot(e, t, r){
+ var o = Z(e);
+ if(void 0 === o)
+  throw new TypeError("Missing slots for the given container");
+ if(o[t]) throw new TypeError("".concat(t, " already has set"));
+ o[t] = r;
+}
+var
+ j =
+   /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,
+ $ =
+   new
+    RegExp
+    ("(?:"
+     +
+      ["(?:".concat(j.source, ")(?:\\/(?:").concat(j.source, "))*"),
+        "Etc/GMT(?:0|[-+]\\d{1,2})",
+        "GMT[-+]?0",
+        "EST5EDT",
+        "CST6CDT",
+        "MST7MDT",
+        "PST8PDT",
+        /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join
+       ("|")
+     + ")"),
+ k = /(?:[+\u2212-]\d{6}|\d{4})/,
+ U = /(?:0[1-9]|1[0-2])/,
+ A = /(?:0[1-9]|[12]\d|3[01])/,
+ L =
+   new
+    RegExp
+    ("(".concat(k.source, ")(?:-(").concat(U.source, ")-(").concat
+        (A.source, ")|(").concat
+       (U.source, ")(").concat
+      (A.source, "))")),
+ x =
+   /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,
+ W =
+   /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,
+ q = new RegExp("([zZ])|".concat(W.source, "?")),
+ H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g,
+ V =
+   new
+    RegExp
+    (["^".concat(L.source),
+       "(?:(?:T|\\s+)".concat(x.source, "(?:").concat(q.source, ")?)?"),
+       "(?:\\[!?(".concat($.source, ")\\])?"),
+       "((?:".concat(H.source, ")*)$")].join
+      (""),
+     "i"),
+ z =
+   new
+    RegExp
+    (["^T?".concat(x.source),
+       "(?:".concat(q.source, ")?"),
+       "(?:\\[!?".concat($.source, "\\])?"),
+       "((?:".concat(H.source, ")*)$")].join
+      (""),
+     "i"),
+ _ =
+   new
+    RegExp
+    ("^(".concat(k.source, ")-?(").concat(U.source, ")(?:\\[!?").concat
+       ($.source, "\\])?((?:").concat
+      (H.source, ")*)$")),
+ J =
+   new
+    RegExp
+    ("^(?:--)?(".concat(U.source, ")-?(").concat(A.source, ")(?:\\[!?").concat
+       ($.source, "\\])?((?:").concat
+      (H.source, ")*)$")),
+ K = /(\d+)(?:[.,](\d{1,9}))?/,
+ X =
+   new
+    RegExp
+    ("(?:".concat(K.source, "H)?(?:").concat(K.source, "M)?(?:").concat
+      (K.source, "S)?")),
+ Q =
+   new
+    RegExp
+    ("^([+\u2212-])?P".concat
+       (/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source, "(?:T(?!$)").concat
+      (X.source, ")?$"),
+     "i"),
+ ee = Array.prototype.includes,
+ te = Array.prototype.push,
+ re = globalThis.Intl.DateTimeFormat,
+ oe = Math.min,
+ ne = Math.max,
+ ae = Math.abs,
+ ie = Math.floor,
+ se = Math.sign,
+ le = Math.trunc,
+ de = Number.isNaN,
+ me = Number.isFinite,
+ ce = Number,
+ he = String,
+ ue = Number.MAX_SAFE_INTEGER,
+ Te = Object.create,
+ pe = Object.getOwnPropertyDescriptor,
+ fe = Reflect.apply,
+ ye = Reflect.ownKeys,
+ Ie = BigInt("0"),
+ Se = BigInt("1"),
+ ge = BigInt("60"),
+ we = BigInt("24"),
+ De = BigInt("1000"),
+ Ge = BigInt("1000000"),
+ ve = BigInt("1000000000"),
+ Ce = BigInt(- 1),
+ Oe = BigInt("3600") * ve,
+ be = ge * ve,
+ Ee = Oe * we,
+ Me = BigInt(- 86400) * BigInt("100000000000000000"),
+ Re = BigInt("86400") * BigInt("100000000000000000"),
+ Fe = - 271821,
+ Ye = 275760,
+ Pe = BigInt(- 388152) * BigInt("10000000000000"),
+ Ze = Ee * BigInt("3660"),
+ Be = Ee * BigInt("366"),
+ Ne = Ee * BigInt("14"),
+ je =
+   ["iso8601",
+    "hebrew",
+    "islamic",
+    "islamic-umalqura",
+    "islamic-tbla",
+    "islamic-civil",
+    "islamic-rgsa",
+    "islamicc",
+    "persian",
+    "ethiopic",
+    "ethioaa",
+    "coptic",
+    "chinese",
+    "dangi",
+    "roc",
+    "indian",
+    "buddhist",
+    "japanese",
+    "gregory"];
+function isZero(t){return t === Ie;}
+function GetMethod(e, t){var r = e[t]; if(void 0 !== r) return r;}
+function Call(e, t, r){
+ var o = arguments.length > 2 ? r : [];
+ return fe(e, t, o);
+}
+function IsObject(e){
+ return "object" == _typeof(e) && null !== e || "function" == typeof e;
+}
+function ToNumber(e){
+ if("bigint" == typeof e)
+  throw new TypeError("Cannot convert BigInt to number");
+ return ce(e);
+}
+function ToIntegerOrInfinity(e){
+ var t = ToNumber(e);
+ if(de(t) || 0 === t) return 0;
+ if(! me(t)) return t;
+ var r = ie(ae(t));
+ return 0 === r ? 0 : se(t) * r;
+}
+function IsIntegralNumber(e){
+ if("number" != typeof e || de(e) || ! me(e)) return ! 1;
+ var t = ae(e);
+ return ie(t) === t;
+}
+function ToString(e){
+ if("symbol" == _typeof(e))
+  throw new TypeError("Cannot convert a Symbol value to a String");
+ return he(e);
+}
+function ToIntegerWithTruncation(e){
+ var t = ToNumber(e);
+ if(0 === t) return 0;
+ if(de(t) || ! me(t)) throw new RangeError("invalid number value");
+ var r = le(t);
+ return 0 === r ? 0 : r;
+}
+function ToPositiveIntegerWithTruncation(e, t){
+ var r = ToIntegerWithTruncation(e);
+ if(r <= 0){
+  if(void 0 !== t)
+   throw new
+          RangeError
+          ("property '".concat(t, "' cannot be a a number less than one"));
+  throw new
+         RangeError
+         ("Cannot convert a number less than one to a positive integer");
+ }
+ return r;
+}
+function ToIntegerIfIntegral(e){
+ var t = ToNumber(e);
+ if(! me(t)) throw new RangeError("infinity is out of range");
+ if(! IsIntegralNumber(t))
+  throw new RangeError("unsupported fractional value ".concat(e));
+ return 0 === t ? 0 : t;
+}
+function divmod(t, r){return {quotient: t / r, remainder: t % r};}
+function isNegativeJSBI(t){return t < Ie;}
+function signJSBI(e){return isZero(e) ? 0 : isNegativeJSBI(e) ? - 1 : 1;}
+function abs(t){return t < Ie ? t * Ce : t;}
+var
+ $e =
+   new
+    Map
+    ([["year", ToIntegerWithTruncation],
+      ["month", ToPositiveIntegerWithTruncation],
+      ["monthCode", ToString],
+      ["day", ToPositiveIntegerWithTruncation],
+      ["hour", ToIntegerWithTruncation],
+      ["minute", ToIntegerWithTruncation],
+      ["second", ToIntegerWithTruncation],
+      ["millisecond", ToIntegerWithTruncation],
+      ["microsecond", ToIntegerWithTruncation],
+      ["nanosecond", ToIntegerWithTruncation],
+      ["years", ToIntegerIfIntegral],
+      ["months", ToIntegerIfIntegral],
+      ["weeks", ToIntegerIfIntegral],
+      ["days", ToIntegerIfIntegral],
+      ["hours", ToIntegerIfIntegral],
+      ["minutes", ToIntegerIfIntegral],
+      ["seconds", ToIntegerIfIntegral],
+      ["milliseconds", ToIntegerIfIntegral],
+      ["microseconds", ToIntegerIfIntegral],
+      ["nanoseconds", ToIntegerIfIntegral],
+      ["era", ToString],
+      ["eraYear", ToIntegerOrInfinity],
+      ["offset", ToString]]),
+ ke =
+   new
+    Map
+    ([["hour", 0],
+      ["minute", 0],
+      ["second", 0],
+      ["millisecond", 0],
+      ["microsecond", 0],
+      ["nanosecond", 0]]),
+ Ue =
+   [["years", "year", "date"],
+    ["months", "month", "date"],
+    ["weeks", "week", "date"],
+    ["days", "day", "date"],
+    ["hours", "hour", "time"],
+    ["minutes", "minute", "time"],
+    ["seconds", "second", "time"],
+    ["milliseconds", "millisecond", "time"],
+    ["microseconds", "microsecond", "time"],
+    ["nanoseconds", "nanosecond", "time"]],
+ Ae = new Map(Ue.map(function(e){return [e[0], e[1]];})),
+ Le =
+   new
+    Map
+    (Ue.map
+      (function(_ref){
+        var _ref2 = _slicedToArray(_ref, 2), e = _ref2[0], t = _ref2[1];
+        return [t, e];
+       })),
+ xe =
+   Ue.map
+    (function(_ref3){
+      var _ref4 = _slicedToArray(_ref3, 2), e = _ref4[1];
+      return e;
+     }),
+ We = Array.from(Ae.keys()).sort(),
+ qe = new Map();
+function getIntlDateTimeFormatEnUsForTimeZone(e){
+ var t = qe.get(e);
+ return void 0 === t
+        &&
+         (t =
+           new
+            re
+            ("en-us",
+             {timeZone: he(e),
+              hour12: ! 1,
+              era: "short",
+              year: "numeric",
+              month: "numeric",
+              day: "numeric",
+              hour: "numeric",
+              minute: "numeric",
+              second: "numeric"}),
+          qe.set(e, t)),
+        t;
+}
+function ToObject(e){
+ if(null == e) throw new TypeError("Expected object not ".concat(e));
+ return Object(e);
+}
+function CopyDataProperties(e, t, r, o){
+ if(null == t) return;
+ var n = ye(t);
+ var _iterator3 = _createForOfIteratorHelper(n), _step3;
+ try{
+  var
+   _loop =
+     function _loop(){
       var a = _step3.value;
-      if (!r.some(function (e) {
-        return Object.is(e, a);
-      }) && Object.prototype.propertyIsEnumerable.call(t, a)) {
-        var _r3 = t[a];
-        if (o && o.some(function (e) {
-          return Object.is(e, _r3);
-        })) return 1; // continue
-        e[a] = _r3;
+      if
+       (!
+        r.some(function(e){return Object.is(e, a);})
+        && Object.prototype.propertyIsEnumerable.call(t, a)){
+       var _r3 = t[a];
+       if(o && o.some(function(e){return Object.is(e, _r3);})) return 1;
+       e[a] = _r3;
+      }
+     };
+  for(_iterator3.s(); ! (_step3 = _iterator3.n()).done;){if(_loop()) continue;}
+ }
+ catch(err){_iterator3.e(err);}
+ finally{_iterator3.f();}
+}
+function IsTemporalInstant(e){return HasSlot(e, n) && ! HasSlot(e, g, p);}
+function IsTemporalTimeZone(e){return HasSlot(e, a);}
+function IsTemporalCalendar(e){return HasSlot(e, F);}
+function IsTemporalDuration(e){return HasSlot(e, w, D, v, C, O, b, E, M, R);}
+function IsTemporalDate(e){return HasSlot(e, f);}
+function IsTemporalTime(e){
+ return HasSlot(e, d, m, c, h, u, T) && ! HasSlot(e, i, s, l);
+}
+function IsTemporalDateTime(e){return HasSlot(e, i, s, l, d, m, c, h, u, T);}
+function IsTemporalYearMonth(e){return HasSlot(e, y);}
+function IsTemporalMonthDay(e){return HasSlot(e, I);}
+function IsTemporalZonedDateTime(e){return HasSlot(e, n, g, p);}
+function RejectTemporalLikeObject(e){
+ if(HasSlot(e, p) || HasSlot(e, g))
+  throw new
+         TypeError
+         ("with() does not support a calendar or timeZone property");
+ if(IsTemporalTime(e))
+  throw new
+         TypeError
+         ("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
+ if(void 0 !== e.calendar)
+  throw new TypeError("with() does not support a calendar property");
+ if(void 0 !== e.timeZone)
+  throw new TypeError("with() does not support a timeZone property");
+}
+function ParseTemporalTimeZone(e){
+ var
+  _ParseTemporalTimeZon =
+    function ParseTemporalTimeZoneString(e){
+      if(new RegExp("^".concat($.source, "$"), "i").test(e))
+       return {ianaName: e};
+      try{
+       var _t3 = ParseISODateTime(e);
+       if(_t3.z || _t3.offset || _t3.ianaName) return _t3;
       }
-    };
-    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
-      if (_loop()) continue;
-    }
-  } catch (err) {
-    _iterator3.e(err);
-  } finally {
-    _iterator3.f();
-  }
-}
-function IsTemporalInstant(e) {
-  return HasSlot(e, n) && !HasSlot(e, g, p);
-}
-function IsTemporalTimeZone(e) {
-  return HasSlot(e, a);
-}
-function IsTemporalCalendar(e) {
-  return HasSlot(e, F);
-}
-function IsTemporalDuration(e) {
-  return HasSlot(e, w, D, v, C, O, b, E, M, R);
-}
-function IsTemporalDate(e) {
-  return HasSlot(e, f);
-}
-function IsTemporalTime(e) {
-  return HasSlot(e, d, m, c, h, u, T) && !HasSlot(e, i, s, l);
-}
-function IsTemporalDateTime(e) {
-  return HasSlot(e, i, s, l, d, m, c, h, u, T);
-}
-function IsTemporalYearMonth(e) {
-  return HasSlot(e, y);
-}
-function IsTemporalMonthDay(e) {
-  return HasSlot(e, I);
-}
-function IsTemporalZonedDateTime(e) {
-  return HasSlot(e, n, g, p);
-}
-function RejectTemporalLikeObject(e) {
-  if (HasSlot(e, p) || HasSlot(e, g)) throw new TypeError("with() does not support a calendar or timeZone property");
-  if (IsTemporalTime(e)) throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
-  if (void 0 !== e.calendar) throw new TypeError("with() does not support a calendar property");
-  if (void 0 !== e.timeZone) throw new TypeError("with() does not support a timeZone property");
-}
-function ParseTemporalTimeZone(e) {
-  var _ParseTemporalTimeZon = function ParseTemporalTimeZoneString(e) {
-      if (new RegExp("^".concat($.source, "$"), "i").test(e)) return {
-        ianaName: e
-      };
-      try {
-        var _t3 = ParseISODateTime(e);
-        if (_t3.z || _t3.offset || _t3.ianaName) return _t3;
-      } catch (_unused) {}
+      catch(_unused){}
       throw new RangeError("Invalid time zone: ".concat(e));
-    }(e),
-    t = _ParseTemporalTimeZon.ianaName,
-    r = _ParseTemporalTimeZon.offset,
-    o = _ParseTemporalTimeZon.z;
-  if (t) return GetCanonicalTimeZoneIdentifier(t);
-  if (o) return "UTC";
-  return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r));
-}
-function MaybeFormatCalendarAnnotation(e, t) {
-  return "never" === t ? "" : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e), t);
-}
-function FormatCalendarAnnotation(e, t) {
-  if ("never" === t) return "";
-  if ("auto" === t && "iso8601" === e) return "";
-  return "[".concat("critical" === t ? "!" : "", "u-ca=").concat(e, "]");
-}
-function ParseISODateTime(e) {
-  var t = V.exec(e);
-  if (!t) throw new RangeError("invalid ISO 8601 string: ".concat(e));
-  var r = t[1];
-  if ("−" === r[0] && (r = "-".concat(r.slice(1))), "-000000" === r) throw new RangeError("invalid ISO 8601 string: ".concat(e));
-  var o = ToIntegerOrInfinity(r),
-    n = ToIntegerOrInfinity(t[2] || t[4]),
-    a = ToIntegerOrInfinity(t[3] || t[5]),
-    i = ToIntegerOrInfinity(t[6]),
-    s = void 0 !== t[6],
-    l = ToIntegerOrInfinity(t[7] || t[10]);
-  var d = ToIntegerOrInfinity(t[8] || t[11]);
-  60 === d && (d = 59);
-  var m = (t[9] || t[12]) + "000000000",
-    c = ToIntegerOrInfinity(m.slice(0, 3)),
-    h = ToIntegerOrInfinity(m.slice(3, 6)),
-    u = ToIntegerOrInfinity(m.slice(6, 9));
-  var T,
-    p = !1;
-  if (t[13]) T = void 0, p = !0;else if (t[14] && t[15]) {
-    var _e2 = "-" === t[14] || "−" === t[14] ? "-" : "+",
-      _r4 = t[15] || "00",
-      _o = t[16] || "00",
-      _n = t[17] || "00";
-    var _a = t[18] || "0";
-    if (T = "".concat(_e2).concat(_r4, ":").concat(_o), +_a) {
-      for (; _a.endsWith("0");) _a = _a.slice(0, -1);
-      T += ":".concat(_n, ".").concat(_a);
-    } else +_n && (T += ":".concat(_n));
-    "-00:00" === T && (T = "+00:00");
-  }
-  var f = t[19],
-    y = t[20];
-  var I;
-  var _iterator4 = _createForOfIteratorHelper(y.matchAll(H)),
-    _step4;
-  try {
-    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
-      var _step4$value = _slicedToArray(_step4.value, 4),
-        _e3 = _step4$value[1],
-        _t4 = _step4$value[2],
-        _r5 = _step4$value[3];
-      if ("u-ca" === _t4) void 0 === I && (I = _r5);else if ("!" === _e3) throw new RangeError("Unrecognized annotation: !".concat(_t4, "=").concat(_r5));
-    }
-  } catch (err) {
-    _iterator4.e(err);
-  } finally {
-    _iterator4.f();
-  }
-  return RejectDateTime(o, n, a, i, l, d, c, h, u), {
-    year: o,
-    month: n,
-    day: a,
-    hasTime: s,
-    hour: i,
-    minute: l,
-    second: d,
-    millisecond: c,
-    microsecond: h,
-    nanosecond: u,
-    ianaName: f,
-    offset: T,
-    z: p,
-    calendar: I
-  };
-}
-function ParseTemporalYearMonthString(e) {
-  var t = _.exec(e);
-  var r, o, n, a;
-  if (t) {
-    var _a2 = t[1];
-    if ("−" === _a2[0] && (_a2 = "-".concat(_a2.slice(1))), "-000000" === _a2) throw new RangeError("invalid ISO 8601 string: ".concat(e));
-    r = ToIntegerOrInfinity(_a2), o = ToIntegerOrInfinity(t[2]);
-    var _i = t[3];
-    var _iterator5 = _createForOfIteratorHelper(_i.matchAll(H)),
-      _step5;
-    try {
-      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
-        var _step5$value = _slicedToArray(_step5.value, 4),
-          _e4 = _step5$value[1],
-          _t5 = _step5$value[2],
-          _r6 = _step5$value[3];
-        if ("u-ca" === _t5) void 0 === n && (n = _r6);else if ("!" === _e4) throw new RangeError("Unrecognized annotation: !".concat(_t5, "=").concat(_r6));
-      }
-    } catch (err) {
-      _iterator5.e(err);
-    } finally {
-      _iterator5.f();
-    }
-    if (void 0 !== n && "iso8601" !== n) throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
-  } else {
-    var _ParseISODateTime;
-    var _t6;
-    if ((_ParseISODateTime = ParseISODateTime(e), r = _ParseISODateTime.year, o = _ParseISODateTime.month, n = _ParseISODateTime.calendar, a = _ParseISODateTime.day, _t6 = _ParseISODateTime.z), _t6) throw new RangeError("Z designator not supported for PlainYearMonth");
-  }
-  return {
-    year: r,
-    month: o,
-    calendar: n,
-    referenceISODay: a
-  };
-}
-function ParseTemporalMonthDayString(e) {
-  var t = J.exec(e);
-  var r, o, n, a;
-  if (t) {
-    r = ToIntegerOrInfinity(t[1]), o = ToIntegerOrInfinity(t[2]);
-    var _e5 = t[3];
-    var _iterator6 = _createForOfIteratorHelper(_e5.matchAll(H)),
-      _step6;
-    try {
-      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
-        var _step6$value = _slicedToArray(_step6.value, 4),
-          _t7 = _step6$value[1],
-          _r7 = _step6$value[2],
-          _o2 = _step6$value[3];
-        if ("u-ca" === _r7) void 0 === n && (n = _o2);else if ("!" === _t7) throw new RangeError("Unrecognized annotation: !".concat(_r7, "=").concat(_o2));
-      }
-    } catch (err) {
-      _iterator6.e(err);
-    } finally {
-      _iterator6.f();
-    }
-    if (void 0 !== n && "iso8601" !== n) throw new RangeError("MM-DD format is only valid with iso8601 calendar");
-  } else {
-    var _ParseISODateTime2;
-    var _t8;
-    if ((_ParseISODateTime2 = ParseISODateTime(e), r = _ParseISODateTime2.month, o = _ParseISODateTime2.day, n = _ParseISODateTime2.calendar, a = _ParseISODateTime2.year, _t8 = _ParseISODateTime2.z), _t8) throw new RangeError("Z designator not supported for PlainMonthDay");
-  }
-  return {
-    month: r,
-    day: o,
-    calendar: n,
-    referenceISOYear: a
-  };
-}
-function ParseTemporalInstant(e) {
-  var _ParseTemporalInstant = function ParseTemporalInstantString(e) {
+     }
+     (e),
+  t = _ParseTemporalTimeZon.ianaName,
+  r = _ParseTemporalTimeZon.offset,
+  o = _ParseTemporalTimeZon.z;
+ if(t) return GetCanonicalTimeZoneIdentifier(t);
+ if(o) return "UTC";
+ return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r));
+}
+function MaybeFormatCalendarAnnotation(e, t){
+ return "never" === t
+         ? ""
+         : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e), t);
+}
+function FormatCalendarAnnotation(e, t){
+ if("never" === t) return "";
+ if("auto" === t && "iso8601" === e) return "";
+ return "[".concat("critical" === t ? "!" : "", "u-ca=").concat(e, "]");
+}
+function ParseISODateTime(e){
+ var t = V.exec(e);
+ if(! t) throw new RangeError("invalid ISO 8601 string: ".concat(e));
+ var r = t[1];
+ if("−" === r[0] && (r = "-".concat(r.slice(1))), "-000000" === r)
+  throw new RangeError("invalid ISO 8601 string: ".concat(e));
+ var
+  o = ToIntegerOrInfinity(r),
+  n = ToIntegerOrInfinity(t[2] || t[4]),
+  a = ToIntegerOrInfinity(t[3] || t[5]),
+  i = ToIntegerOrInfinity(t[6]),
+  s = void 0 !== t[6],
+  l = ToIntegerOrInfinity(t[7] || t[10]);
+ var d = ToIntegerOrInfinity(t[8] || t[11]);
+ 60 === d && (d = 59);
+ var
+  m = (t[9] || t[12]) + "000000000",
+  c = ToIntegerOrInfinity(m.slice(0, 3)),
+  h = ToIntegerOrInfinity(m.slice(3, 6)),
+  u = ToIntegerOrInfinity(m.slice(6, 9));
+ var T, p = ! 1;
+ if(t[13])
+  T = void 0, p = ! 0;
+ else if(t[14] && t[15]){
+  var
+   _e2 = "-" === t[14] || "−" === t[14] ? "-" : "+",
+   _r4 = t[15] || "00",
+   _o = t[16] || "00",
+   _n = t[17] || "00";
+  var _a = t[18] || "0";
+  if(T = "".concat(_e2).concat(_r4, ":").concat(_o), + _a){
+   for(; _a.endsWith("0");) _a = _a.slice(0, - 1);
+   T += ":".concat(_n, ".").concat(_a);
+  }
+  else
+   + _n && (T += ":".concat(_n));
+  "-00:00" === T && (T = "+00:00");
+ }
+ var f = t[19], y = t[20];
+ var I;
+ var _iterator4 = _createForOfIteratorHelper(y.matchAll(H)), _step4;
+ try{
+  for(_iterator4.s(); ! (_step4 = _iterator4.n()).done;){
+   var
+    _step4$value = _slicedToArray(_step4.value, 4),
+    _e3 = _step4$value[1],
+    _t4 = _step4$value[2],
+    _r5 = _step4$value[3];
+   if("u-ca" === _t4)
+    void 0 === I && (I = _r5);
+   else if("!" === _e3)
+    throw new
+           RangeError
+           ("Unrecognized annotation: !".concat(_t4, "=").concat(_r5));
+  }
+ }
+ catch(err){_iterator4.e(err);}
+ finally{_iterator4.f();}
+ return RejectDateTime(o, n, a, i, l, d, c, h, u),
+        {year: o,
+         month: n,
+         day: a,
+         hasTime: s,
+         hour: i,
+         minute: l,
+         second: d,
+         millisecond: c,
+         microsecond: h,
+         nanosecond: u,
+         ianaName: f,
+         offset: T,
+         z: p,
+         calendar: I};
+}
+function ParseTemporalYearMonthString(e){
+ var t = _.exec(e);
+ var r, o, n, a;
+ if(t){
+  var _a2 = t[1];
+  if("−" === _a2[0] && (_a2 = "-".concat(_a2.slice(1))), "-000000" === _a2)
+   throw new RangeError("invalid ISO 8601 string: ".concat(e));
+  r = ToIntegerOrInfinity(_a2), o = ToIntegerOrInfinity(t[2]);
+  var _i = t[3];
+  var _iterator5 = _createForOfIteratorHelper(_i.matchAll(H)), _step5;
+  try{
+   for(_iterator5.s(); ! (_step5 = _iterator5.n()).done;){
+    var
+     _step5$value = _slicedToArray(_step5.value, 4),
+     _e4 = _step5$value[1],
+     _t5 = _step5$value[2],
+     _r6 = _step5$value[3];
+    if("u-ca" === _t5)
+     void 0 === n && (n = _r6);
+    else if("!" === _e4)
+     throw new
+            RangeError
+            ("Unrecognized annotation: !".concat(_t5, "=").concat(_r6));
+   }
+  }
+  catch(err){_iterator5.e(err);}
+  finally{_iterator5.f();}
+  if(void 0 !== n && "iso8601" !== n)
+   throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
+ }
+ else{
+  var _ParseISODateTime;
+  var _t6;
+  if
+   (_ParseISODateTime = ParseISODateTime(e),
+    r = _ParseISODateTime.year,
+    o = _ParseISODateTime.month,
+    n = _ParseISODateTime.calendar,
+    a = _ParseISODateTime.day,
+    _t6 = _ParseISODateTime.z,
+    _t6)
+   throw new RangeError("Z designator not supported for PlainYearMonth");
+ }
+ return {year: r, month: o, calendar: n, referenceISODay: a};
+}
+function ParseTemporalMonthDayString(e){
+ var t = J.exec(e);
+ var r, o, n, a;
+ if(t){
+  r = ToIntegerOrInfinity(t[1]), o = ToIntegerOrInfinity(t[2]);
+  var _e5 = t[3];
+  var _iterator6 = _createForOfIteratorHelper(_e5.matchAll(H)), _step6;
+  try{
+   for(_iterator6.s(); ! (_step6 = _iterator6.n()).done;){
+    var
+     _step6$value = _slicedToArray(_step6.value, 4),
+     _t7 = _step6$value[1],
+     _r7 = _step6$value[2],
+     _o2 = _step6$value[3];
+    if("u-ca" === _r7)
+     void 0 === n && (n = _o2);
+    else if("!" === _t7)
+     throw new
+            RangeError
+            ("Unrecognized annotation: !".concat(_r7, "=").concat(_o2));
+   }
+  }
+  catch(err){_iterator6.e(err);}
+  finally{_iterator6.f();}
+  if(void 0 !== n && "iso8601" !== n)
+   throw new RangeError("MM-DD format is only valid with iso8601 calendar");
+ }
+ else{
+  var _ParseISODateTime2;
+  var _t8;
+  if
+   (_ParseISODateTime2 = ParseISODateTime(e),
+    r = _ParseISODateTime2.month,
+    o = _ParseISODateTime2.day,
+    n = _ParseISODateTime2.calendar,
+    a = _ParseISODateTime2.year,
+    _t8 = _ParseISODateTime2.z,
+    _t8)
+   throw new RangeError("Z designator not supported for PlainMonthDay");
+ }
+ return {month: r, day: o, calendar: n, referenceISOYear: a};
+}
+function ParseTemporalInstant(e){
+ var
+  _ParseTemporalInstant =
+    function ParseTemporalInstantString(e){
       var t = ParseISODateTime(e);
-      if (!t.z && !t.offset) throw new RangeError("Temporal.Instant requires a time zone offset");
+      if(! t.z && ! t.offset)
+       throw new RangeError("Temporal.Instant requires a time zone offset");
       return t;
-    }(e),
-    t = _ParseTemporalInstant.year,
-    r = _ParseTemporalInstant.month,
-    o = _ParseTemporalInstant.day,
-    n = _ParseTemporalInstant.hour,
-    a = _ParseTemporalInstant.minute,
-    i = _ParseTemporalInstant.second,
-    s = _ParseTemporalInstant.millisecond,
-    l = _ParseTemporalInstant.microsecond,
-    d = _ParseTemporalInstant.nanosecond,
-    m = _ParseTemporalInstant.offset,
-    c = _ParseTemporalInstant.z;
-  if (!c && !m) throw new RangeError("Temporal.Instant requires a time zone offset");
-  var h = c ? 0 : ParseTimeZoneOffsetString(m);
-  var _BalanceISODateTime = BalanceISODateTime(t, r, o, n, a, i, s, l, d - h);
-  t = _BalanceISODateTime.year;
-  r = _BalanceISODateTime.month;
-  o = _BalanceISODateTime.day;
-  n = _BalanceISODateTime.hour;
-  a = _BalanceISODateTime.minute;
-  i = _BalanceISODateTime.second;
-  s = _BalanceISODateTime.millisecond;
-  l = _BalanceISODateTime.microsecond;
-  d = _BalanceISODateTime.nanosecond;
-  var u = GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d);
-  if (null === u) throw new RangeError("DateTime outside of supported range");
-  return u;
-}
-function RegulateISODate(e, t, r, o) {
-  var n = e,
-    a = t,
-    i = r;
-  switch (o) {
-    case "reject":
-      RejectISODate(n, a, i);
-      break;
-    case "constrain":
-      var _ConstrainISODate = ConstrainISODate(n, a, i);
-      n = _ConstrainISODate.year;
-      a = _ConstrainISODate.month;
-      i = _ConstrainISODate.day;
-  }
-  return {
-    year: n,
-    month: a,
-    day: i
-  };
-}
-function RegulateTime(e, t, r, o, n, a, i) {
-  var s = e,
-    l = t,
-    d = r,
-    m = o,
-    c = n,
-    h = a;
-  switch (i) {
-    case "reject":
-      RejectTime(s, l, d, m, c, h);
-      break;
-    case "constrain":
-      var _ConstrainTime = function ConstrainTime(e, t, r, o, n, a) {
-        var i = ConstrainToRange(e, 0, 23),
+     }
+     (e),
+  t = _ParseTemporalInstant.year,
+  r = _ParseTemporalInstant.month,
+  o = _ParseTemporalInstant.day,
+  n = _ParseTemporalInstant.hour,
+  a = _ParseTemporalInstant.minute,
+  i = _ParseTemporalInstant.second,
+  s = _ParseTemporalInstant.millisecond,
+  l = _ParseTemporalInstant.microsecond,
+  d = _ParseTemporalInstant.nanosecond,
+  m = _ParseTemporalInstant.offset,
+  c = _ParseTemporalInstant.z;
+ if(! c && ! m)
+  throw new RangeError("Temporal.Instant requires a time zone offset");
+ var h = c ? 0 : ParseTimeZoneOffsetString(m);
+ var _BalanceISODateTime = BalanceISODateTime(t, r, o, n, a, i, s, l, d - h);
+ t = _BalanceISODateTime.year;
+ r = _BalanceISODateTime.month;
+ o = _BalanceISODateTime.day;
+ n = _BalanceISODateTime.hour;
+ a = _BalanceISODateTime.minute;
+ i = _BalanceISODateTime.second;
+ s = _BalanceISODateTime.millisecond;
+ l = _BalanceISODateTime.microsecond;
+ d = _BalanceISODateTime.nanosecond;
+ var u = GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d);
+ if(null === u) throw new RangeError("DateTime outside of supported range");
+ return u;
+}
+function RegulateISODate(e, t, r, o){
+ var n = e, a = t, i = r;
+ switch(o){
+   case "reject":
+    RejectISODate(n, a, i); break;
+   case "constrain":
+    var _ConstrainISODate = ConstrainISODate(n, a, i);
+    n = _ConstrainISODate.year;
+    a = _ConstrainISODate.month;
+    i = _ConstrainISODate.day;
+ }
+ return {year: n, month: a, day: i};
+}
+function RegulateTime(e, t, r, o, n, a, i){
+ var s = e, l = t, d = r, m = o, c = n, h = a;
+ switch(i){
+   case "reject":
+    RejectTime(s, l, d, m, c, h); break;
+   case "constrain":
+    var
+     _ConstrainTime =
+       function ConstrainTime(e, t, r, o, n, a){
+         var
+          i = ConstrainToRange(e, 0, 23),
           s = ConstrainToRange(t, 0, 59),
           l = ConstrainToRange(r, 0, 59),
           d = ConstrainToRange(o, 0, 999),
           m = ConstrainToRange(n, 0, 999),
           c = ConstrainToRange(a, 0, 999);
-        return {
-          hour: i,
-          minute: s,
-          second: l,
-          millisecond: d,
-          microsecond: m,
-          nanosecond: c
-        };
-      }(s, l, d, m, c, h);
-      s = _ConstrainTime.hour;
-      l = _ConstrainTime.minute;
-      d = _ConstrainTime.second;
-      m = _ConstrainTime.millisecond;
-      c = _ConstrainTime.microsecond;
-      h = _ConstrainTime.nanosecond;
-  }
-  return {
-    hour: s,
-    minute: l,
-    second: d,
-    millisecond: m,
-    microsecond: c,
-    nanosecond: h
-  };
-}
-function ToTemporalDurationRecord(e) {
-  if (!IsObject(e)) return function ParseTemporalDurationString(e) {
-    var t = Q.exec(e);
-    if (!t) throw new RangeError("invalid duration: ".concat(e));
-    if (t.slice(2).every(function (e) {
-      return void 0 === e;
-    })) throw new RangeError("invalid duration: ".concat(e));
-    var r = "-" === t[1] || "−" === t[1] ? -1 : 1,
-      o = void 0 === t[2] ? 0 : ToIntegerWithTruncation(t[2]) * r,
-      n = void 0 === t[3] ? 0 : ToIntegerWithTruncation(t[3]) * r,
-      a = void 0 === t[4] ? 0 : ToIntegerWithTruncation(t[4]) * r,
-      i = void 0 === t[5] ? 0 : ToIntegerWithTruncation(t[5]) * r,
-      s = void 0 === t[6] ? 0 : ToIntegerWithTruncation(t[6]) * r,
-      l = t[7],
-      d = t[8],
-      m = t[9],
-      c = t[10],
-      h = t[11];
-    var u = 0,
-      T = 0,
-      p = 0;
-    if (void 0 !== l) {
-      var _ref5, _ref6;
-      if ((_ref5 = (_ref6 = d !== null && d !== void 0 ? d : m) !== null && _ref6 !== void 0 ? _ref6 : c) !== null && _ref5 !== void 0 ? _ref5 : h) throw new RangeError("only the smallest unit can be fractional");
-      p = 3600 * ToIntegerOrInfinity((l + "000000000").slice(0, 9)) * r;
-    } else if (u = void 0 === d ? 0 : ToIntegerWithTruncation(d) * r, void 0 !== m) {
-      if (c !== null && c !== void 0 ? c : h) throw new RangeError("only the smallest unit can be fractional");
-      p = 60 * ToIntegerOrInfinity((m + "000000000").slice(0, 9)) * r;
-    } else T = void 0 === c ? 0 : ToIntegerWithTruncation(c) * r, void 0 !== h && (p = ToIntegerOrInfinity((h + "000000000").slice(0, 9)) * r);
-    var f = p % 1e3,
-      y = le(p / 1e3) % 1e3,
-      I = le(p / 1e6) % 1e3;
-    return T += le(p / 1e9) % 60, u += le(p / 6e10), RejectDuration(o, n, a, i, s, u, T, I, y, f), {
-      years: o,
-      months: n,
-      weeks: a,
-      days: i,
-      hours: s,
-      minutes: u,
-      seconds: T,
-      milliseconds: I,
-      microseconds: y,
-      nanoseconds: f
-    };
-  }(ToString(e));
-  if (IsTemporalDuration(e)) return {
-    years: GetSlot(e, w),
-    months: GetSlot(e, D),
-    weeks: GetSlot(e, G),
-    days: GetSlot(e, v),
-    hours: GetSlot(e, C),
-    minutes: GetSlot(e, O),
-    seconds: GetSlot(e, b),
-    milliseconds: GetSlot(e, E),
-    microseconds: GetSlot(e, M),
-    nanoseconds: GetSlot(e, R)
-  };
-  var t = {
-    years: 0,
-    months: 0,
-    weeks: 0,
-    days: 0,
-    hours: 0,
-    minutes: 0,
-    seconds: 0,
-    milliseconds: 0,
-    microseconds: 0,
-    nanoseconds: 0
-  };
-  var r = function ToTemporalPartialDurationRecord(e) {
-    if (!IsObject(e)) throw new TypeError("invalid duration-like");
-    var t = {
-      years: void 0,
-      months: void 0,
-      weeks: void 0,
-      days: void 0,
-      hours: void 0,
-      minutes: void 0,
-      seconds: void 0,
-      milliseconds: void 0,
-      microseconds: void 0,
-      nanoseconds: void 0
-    };
-    var r = !1;
-    var _iterator7 = _createForOfIteratorHelper(We),
-      _step7;
-    try {
-      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
+         return {hour: i,
+                 minute: s,
+                 second: l,
+                 millisecond: d,
+                 microsecond: m,
+                 nanosecond: c};
+        }
+        (s, l, d, m, c, h);
+    s = _ConstrainTime.hour;
+    l = _ConstrainTime.minute;
+    d = _ConstrainTime.second;
+    m = _ConstrainTime.millisecond;
+    c = _ConstrainTime.microsecond;
+    h = _ConstrainTime.nanosecond;
+ }
+ return {hour: s,
+         minute: l,
+         second: d,
+         millisecond: m,
+         microsecond: c,
+         nanosecond: h};
+}
+function ToTemporalDurationRecord(e){
+ if(! IsObject(e))
+  return function ParseTemporalDurationString(e){
+           var t = Q.exec(e);
+           if(! t) throw new RangeError("invalid duration: ".concat(e));
+           if(t.slice(2).every(function(e){return void 0 === e;}))
+            throw new RangeError("invalid duration: ".concat(e));
+           var
+            r = "-" === t[1] || "−" === t[1] ? - 1 : 1,
+            o = void 0 === t[2] ? 0 : ToIntegerWithTruncation(t[2]) * r,
+            n = void 0 === t[3] ? 0 : ToIntegerWithTruncation(t[3]) * r,
+            a = void 0 === t[4] ? 0 : ToIntegerWithTruncation(t[4]) * r,
+            i = void 0 === t[5] ? 0 : ToIntegerWithTruncation(t[5]) * r,
+            s = void 0 === t[6] ? 0 : ToIntegerWithTruncation(t[6]) * r,
+            l = t[7],
+            d = t[8],
+            m = t[9],
+            c = t[10],
+            h = t[11];
+           var u = 0, T = 0, p = 0;
+           if(void 0 !== l){
+            var _ref5, _ref6;
+            if
+             ((_ref5 =
+                (_ref6 = d !== null && d !== void 0 ? d : m) !== null
+                 && _ref6 !== void 0
+                 ? _ref6
+                 : c)
+               !== null
+               && _ref5 !== void 0
+               ? _ref5
+               : h)
+             throw new RangeError("only the smallest unit can be fractional");
+            p = 3600 * ToIntegerOrInfinity((l + "000000000").slice(0, 9)) * r;
+           }
+           else if
+            (u = void 0 === d ? 0 : ToIntegerWithTruncation(d) * r,
+             void 0 !== m){
+            if(c !== null && c !== void 0 ? c : h)
+             throw new RangeError("only the smallest unit can be fractional");
+            p = 60 * ToIntegerOrInfinity((m + "000000000").slice(0, 9)) * r;
+           }
+           else
+            T = void 0 === c ? 0 : ToIntegerWithTruncation(c) * r,
+            void 0 !== h
+            && (p = ToIntegerOrInfinity((h + "000000000").slice(0, 9)) * r);
+           var f = p % 1e3, y = le(p / 1e3) % 1e3, I = le(p / 1e6) % 1e3;
+           return T += le(p / 1e9) % 60,
+                  u += le(p / 6e10),
+                  RejectDuration(o, n, a, i, s, u, T, I, y, f),
+                  {years: o,
+                   months: n,
+                   weeks: a,
+                   days: i,
+                   hours: s,
+                   minutes: u,
+                   seconds: T,
+                   milliseconds: I,
+                   microseconds: y,
+                   nanoseconds: f};
+          }
+          (ToString(e));
+ if(IsTemporalDuration(e))
+  return {years: GetSlot(e, w),
+          months: GetSlot(e, D),
+          weeks: GetSlot(e, G),
+          days: GetSlot(e, v),
+          hours: GetSlot(e, C),
+          minutes: GetSlot(e, O),
+          seconds: GetSlot(e, b),
+          milliseconds: GetSlot(e, E),
+          microseconds: GetSlot(e, M),
+          nanoseconds: GetSlot(e, R)};
+ var
+  t =
+    {years: 0,
+     months: 0,
+     weeks: 0,
+     days: 0,
+     hours: 0,
+     minutes: 0,
+     seconds: 0,
+     milliseconds: 0,
+     microseconds: 0,
+     nanoseconds: 0};
+ var
+  r =
+    function ToTemporalPartialDurationRecord(e){
+      if(! IsObject(e)) throw new TypeError("invalid duration-like");
+      var
+       t =
+         {years: void 0,
+          months: void 0,
+          weeks: void 0,
+          days: void 0,
+          hours: void 0,
+          minutes: void 0,
+          seconds: void 0,
+          milliseconds: void 0,
+          microseconds: void 0,
+          nanoseconds: void 0};
+      var r = ! 1;
+      var _iterator7 = _createForOfIteratorHelper(We), _step7;
+      try{
+       for(_iterator7.s(); ! (_step7 = _iterator7.n()).done;){
         var _o3 = _step7.value;
         var _n2 = e[_o3];
-        void 0 !== _n2 && (r = !0, t[_o3] = ToIntegerIfIntegral(_n2));
+        void 0 !== _n2 && (r = ! 0, t[_o3] = ToIntegerIfIntegral(_n2));
+       }
       }
-    } catch (err) {
-      _iterator7.e(err);
-    } finally {
-      _iterator7.f();
-    }
-    if (!r) throw new TypeError("invalid duration-like");
-    return t;
-  }(e);
-  var _iterator8 = _createForOfIteratorHelper(We),
-    _step8;
-  try {
-    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
-      var _e6 = _step8.value;
-      var _o4 = r[_e6];
-      void 0 !== _o4 && (t[_e6] = _o4);
-    }
-  } catch (err) {
-    _iterator8.e(err);
-  } finally {
-    _iterator8.f();
-  }
-  var o = t.years,
-    n = t.months,
-    a = t.weeks,
-    i = t.days,
-    s = t.hours,
-    l = t.minutes,
-    d = t.seconds,
-    m = t.milliseconds,
-    c = t.microseconds,
-    h = t.nanoseconds;
-  return RejectDuration(o, n, a, i, s, l, d, m, c, h), {
-    years: o,
-    months: n,
-    weeks: a,
-    days: i,
-    hours: s,
-    minutes: l,
-    seconds: d,
-    milliseconds: m,
-    microseconds: c,
-    nanoseconds: h
-  };
-}
-function ToTemporalOverflow(e) {
-  return void 0 === e ? "constrain" : GetOption(e, "overflow", ["constrain", "reject"], "constrain");
-}
-function ToTemporalDisambiguation(e) {
-  return void 0 === e ? "compatible" : GetOption(e, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
-}
-function ToTemporalRoundingMode(e, t) {
-  return GetOption(e, "roundingMode", ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"], t);
-}
-function ToTemporalOffset(e, t) {
-  return void 0 === e ? t : GetOption(e, "offset", ["prefer", "use", "ignore", "reject"], t);
-}
-function ToCalendarNameOption(e) {
-  return GetOption(e, "calendarName", ["auto", "always", "never", "critical"], "auto");
-}
-function ToTemporalRoundingIncrement(e) {
-  var t = e.roundingIncrement;
-  if (void 0 === t) return 1;
-  if (t = ToNumber(t), !me(t)) throw new RangeError("roundingIncrement must be finite");
-  var r = le(t);
-  if (r < 1 || r > 1e9) throw new RangeError("roundingIncrement must be at least 1 and at most 1e9, not ".concat(t));
-  return r;
-}
-function ValidateTemporalRoundingIncrement(e, t, r) {
-  var o = r ? t : t - 1;
-  if (e > o) throw new RangeError("roundingIncrement must be at least 1 and less than ".concat(o, ", not ").concat(e));
-  if (t % e != 0) throw new RangeError("Rounding increment must divide evenly into ".concat(t));
-}
-function ToFractionalSecondDigits(e) {
-  var t = e.fractionalSecondDigits;
-  if (void 0 === t) return "auto";
-  if ("number" != typeof t) {
-    if ("auto" !== ToString(t)) throw new RangeError("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat(t));
-    return "auto";
-  }
-  var r = ie(t);
-  if (!me(r) || r < 0 || r > 9) throw new RangeError("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat(t));
-  return r;
-}
-function ToSecondsStringPrecisionRecord(e, t) {
-  switch (e) {
-    case "minute":
-      return {
-        precision: "minute",
-        unit: "minute",
-        increment: 1
-      };
-    case "second":
-      return {
-        precision: 0,
-        unit: "second",
-        increment: 1
-      };
-    case "millisecond":
-      return {
-        precision: 3,
-        unit: "millisecond",
-        increment: 1
-      };
-    case "microsecond":
-      return {
-        precision: 6,
-        unit: "microsecond",
-        increment: 1
-      };
-    case "nanosecond":
-      return {
-        precision: 9,
-        unit: "nanosecond",
-        increment: 1
-      };
-  }
-  switch (t) {
-    case "auto":
-      return {
-        precision: t,
-        unit: "nanosecond",
-        increment: 1
-      };
-    case 0:
-      return {
-        precision: t,
-        unit: "second",
-        increment: 1
-      };
-    case 1:
-    case 2:
-    case 3:
-      return {
-        precision: t,
-        unit: "millisecond",
-        increment: Math.pow(10, 3 - t)
-      };
-    case 4:
-    case 5:
-    case 6:
-      return {
-        precision: t,
-        unit: "microsecond",
-        increment: Math.pow(10, 6 - t)
-      };
-    case 7:
-    case 8:
-    case 9:
-      return {
-        precision: t,
-        unit: "nanosecond",
-        increment: Math.pow(10, 9 - t)
-      };
-    default:
-      throw new RangeError("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat(t));
-  }
+      catch(err){_iterator7.e(err);}
+      finally{_iterator7.f();}
+      if(! r) throw new TypeError("invalid duration-like");
+      return t;
+     }
+     (e);
+ var _iterator8 = _createForOfIteratorHelper(We), _step8;
+ try{
+  for(_iterator8.s(); ! (_step8 = _iterator8.n()).done;){
+   var _e6 = _step8.value;
+   var _o4 = r[_e6];
+   void 0 !== _o4 && (t[_e6] = _o4);
+  }
+ }
+ catch(err){_iterator8.e(err);}
+ finally{_iterator8.f();}
+ var
+  o = t.years,
+  n = t.months,
+  a = t.weeks,
+  i = t.days,
+  s = t.hours,
+  l = t.minutes,
+  d = t.seconds,
+  m = t.milliseconds,
+  c = t.microseconds,
+  h = t.nanoseconds;
+ return RejectDuration(o, n, a, i, s, l, d, m, c, h),
+        {years: o,
+         months: n,
+         weeks: a,
+         days: i,
+         hours: s,
+         minutes: l,
+         seconds: d,
+         milliseconds: m,
+         microseconds: c,
+         nanoseconds: h};
+}
+function ToTemporalOverflow(e){
+ return void 0 === e
+         ? "constrain"
+         : GetOption(e, "overflow", ["constrain", "reject"], "constrain");
+}
+function ToTemporalDisambiguation(e){
+ return void 0 === e
+         ? "compatible"
+         : GetOption
+           (e,
+            "disambiguation",
+            ["compatible", "earlier", "later", "reject"],
+            "compatible");
+}
+function ToTemporalRoundingMode(e, t){
+ return GetOption
+         (e,
+          "roundingMode",
+          ["ceil",
+           "floor",
+           "expand",
+           "trunc",
+           "halfCeil",
+           "halfFloor",
+           "halfExpand",
+           "halfTrunc",
+           "halfEven"],
+          t);
+}
+function ToTemporalOffset(e, t){
+ return void 0 === e
+         ? t
+         : GetOption(e, "offset", ["prefer", "use", "ignore", "reject"], t);
+}
+function ToCalendarNameOption(e){
+ return GetOption
+         (e, "calendarName", ["auto", "always", "never", "critical"], "auto");
+}
+function ToTemporalRoundingIncrement(e){
+ var t = e.roundingIncrement;
+ if(void 0 === t) return 1;
+ if(t = ToNumber(t), ! me(t))
+  throw new RangeError("roundingIncrement must be finite");
+ var r = le(t);
+ if(r < 1 || r > 1e9)
+  throw new
+         RangeError
+         ("roundingIncrement must be at least 1 and at most 1e9, not ".concat
+           (t));
+ return r;
+}
+function ValidateTemporalRoundingIncrement(e, t, r){
+ var o = r ? t : t - 1;
+ if(e > o)
+  throw new
+         RangeError
+         ("roundingIncrement must be at least 1 and less than ".concat
+            (o, ", not ").concat
+           (e));
+ if(t % e != 0)
+  throw new
+         RangeError
+         ("Rounding increment must divide evenly into ".concat(t));
+}
+function ToFractionalSecondDigits(e){
+ var t = e.fractionalSecondDigits;
+ if(void 0 === t) return "auto";
+ if("number" != typeof t){
+  if("auto" !== ToString(t))
+   throw new
+          RangeError
+          ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
+            (t));
+  return "auto";
+ }
+ var r = ie(t);
+ if(! me(r) || r < 0 || r > 9)
+  throw new
+         RangeError
+         ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
+           (t));
+ return r;
+}
+function ToSecondsStringPrecisionRecord(e, t){
+ switch(e){
+   case "minute":
+    return {precision: "minute", unit: "minute", increment: 1};
+   case "second":
+    return {precision: 0, unit: "second", increment: 1};
+   case "millisecond":
+    return {precision: 3, unit: "millisecond", increment: 1};
+   case "microsecond":
+    return {precision: 6, unit: "microsecond", increment: 1};
+   case "nanosecond":
+    return {precision: 9, unit: "nanosecond", increment: 1};
+ }
+ switch(t){
+   case "auto":
+    return {precision: t, unit: "nanosecond", increment: 1};
+   case 0:
+    return {precision: t, unit: "second", increment: 1};
+   case 1:
+   case 2:
+   case 3:
+    return {precision: t, unit: "millisecond", increment: Math.pow(10, 3 - t)};
+   case 4:
+   case 5:
+   case 6:
+    return {precision: t, unit: "microsecond", increment: Math.pow(10, 6 - t)};
+   case 7:
+   case 8:
+   case 9:
+    return {precision: t, unit: "nanosecond", increment: Math.pow(10, 9 - t)};
+   default:
+    throw new
+           RangeError
+           ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
+             (t));
+ }
 }
 var He = Symbol("~required~");
-function GetTemporalUnit(e, t, r, o) {
-  var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
-  var a = [];
-  for (var _i2 = 0, _Ue = Ue; _i2 < _Ue.length; _i2++) {
-    var _Ue$_i = _slicedToArray(_Ue[_i2], 3),
-      _e7 = _Ue$_i[1],
-      _t9 = _Ue$_i[2];
-    "datetime" !== r && r !== _t9 || a.push(_e7);
-  }
-  a.push.apply(a, _toConsumableArray(n));
-  var i = o;
-  i === He ? i = void 0 : void 0 !== i && a.push(i);
-  var s = [].concat(a);
-  for (var _i3 = 0, _a3 = a; _i3 < _a3.length; _i3++) {
-    var _e8 = _a3[_i3];
-    var _t10 = Le.get(_e8);
-    void 0 !== _t10 && s.push(_t10);
-  }
-  var l = GetOption(e, t, s, i);
-  if (void 0 === l && o === He) throw new RangeError("".concat(t, " is required"));
-  return Ae.has(l) ? Ae.get(l) : l;
-}
-function ToRelativeTemporalObject(e) {
-  var t = e.relativeTo;
-  if (void 0 === t) return t;
-  var r,
-    o,
-    n,
-    a,
-    i,
-    s,
-    l,
-    d,
-    m,
-    c,
-    h,
-    u,
-    T = "option",
-    p = !1;
-  if (IsObject(t)) {
-    var _InterpretTemporalDat;
-    if (IsTemporalZonedDateTime(t) || IsTemporalDate(t)) return t;
-    if (IsTemporalDateTime(t)) return TemporalDateTimeToDate(t);
-    c = GetTemporalCalendarSlotValueWithISODefault(t);
-    var _e9 = CalendarFields(c, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
-    _e9.push("timeZone", "offset");
-    var _p = PrepareTemporalFields(t, _e9, []),
-      _f = Te(null);
-    _f.overflow = "constrain", (_InterpretTemporalDat = InterpretTemporalDateTimeFields(c, _p, _f), r = _InterpretTemporalDat.year, o = _InterpretTemporalDat.month, n = _InterpretTemporalDat.day, a = _InterpretTemporalDat.hour, i = _InterpretTemporalDat.minute, s = _InterpretTemporalDat.second, l = _InterpretTemporalDat.millisecond, d = _InterpretTemporalDat.microsecond, m = _InterpretTemporalDat.nanosecond), u = _p.offset, void 0 === u && (T = "wall"), h = _p.timeZone, void 0 !== h && (h = ToTemporalTimeZoneSlotValue(h));
-  } else {
-    var _ParseISODateTime3;
-    var _e10, _f2;
-    if ((_ParseISODateTime3 = ParseISODateTime(ToString(t)), r = _ParseISODateTime3.year, o = _ParseISODateTime3.month, n = _ParseISODateTime3.day, a = _ParseISODateTime3.hour, i = _ParseISODateTime3.minute, s = _ParseISODateTime3.second, l = _ParseISODateTime3.millisecond, d = _ParseISODateTime3.microsecond, m = _ParseISODateTime3.nanosecond, c = _ParseISODateTime3.calendar, _e10 = _ParseISODateTime3.ianaName, u = _ParseISODateTime3.offset, _f2 = _ParseISODateTime3.z), _e10) h = ToTemporalTimeZoneSlotValue(_e10), _f2 ? T = "exact" : u || (T = "wall"), p = !0;else if (_f2) throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
-    if (c || (c = "iso8601"), !IsBuiltinCalendar(c)) throw new RangeError("invalid calendar identifier ".concat(c));
-    c = ASCIILowercase(c);
-  }
-  if (void 0 === h) return CreateTemporalDate(r, o, n, c);
-  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r, o, n, a, i, s, l, d, m, T, "option" === T ? ParseTimeZoneOffsetString(u) : 0, h, "compatible", "reject", p), h, c);
-}
-function DefaultTemporalLargestUnit(e, t, r, o, n, a, i, s, l, d) {
-  for (var _i4 = 0, _arr = [["years", e], ["months", t], ["weeks", r], ["days", o], ["hours", n], ["minutes", a], ["seconds", i], ["milliseconds", s], ["microseconds", l], ["nanoseconds", d]]; _i4 < _arr.length; _i4++) {
-    var _arr$_i = _slicedToArray(_arr[_i4], 2),
-      _m = _arr$_i[0],
-      _c = _arr$_i[1];
-    if (0 !== _c) return Ae.get(_m);
-  }
-  return "nanosecond";
-}
-function LargerOfTwoTemporalUnits(e, t) {
-  return xe.indexOf(e) > xe.indexOf(t) ? t : e;
-}
-function PrepareTemporalFields(e, t, r) {
-  var _ref7 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
-      emptySourceErrorMessage: "no supported properties found"
-    },
-    o = _ref7.emptySourceErrorMessage;
-  var n = Te(null);
-  var a = !1;
-  t.sort();
-  var _iterator9 = _createForOfIteratorHelper(t),
-    _step9;
-  try {
-    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
-      var _o5 = _step9.value;
-      var _t11 = e[_o5];
-      if (void 0 !== _t11) a = !0, $e.has(_o5) && (_t11 = $e.get(_o5)(_t11)), n[_o5] = _t11;else if ("partial" !== r) {
-        if (ee.call(r, _o5)) throw new TypeError("required property '".concat(_o5, "' missing or undefined"));
-        _t11 = ke.get(_o5), n[_o5] = _t11;
-      }
-    }
-  } catch (err) {
-    _iterator9.e(err);
-  } finally {
-    _iterator9.f();
-  }
-  if ("partial" === r && !a) throw new TypeError(o);
-  return n;
-}
-function ToTemporalTimeRecord(e) {
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "complete";
-  var r = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"],
-    o = PrepareTemporalFields(e, r, "partial", {
-      emptySourceErrorMessage: "invalid time-like"
-    }),
-    n = {};
-  for (var _i5 = 0, _r8 = r; _i5 < _r8.length; _i5++) {
-    var _e11 = _r8[_i5];
-    var _r9 = pe(o, _e11);
-    void 0 !== _r9 ? n[_e11] = _r9.value : "complete" === t && (n[_e11] = 0);
-  }
-  return n;
-}
-function ToTemporalDate(e, t) {
-  var r = e;
-  if (IsObject(r)) {
-    if (IsTemporalDate(r)) return r;
-    if (IsTemporalZonedDateTime(r) && (ToTemporalOverflow(t), r = GetPlainDateTimeFor(GetSlot(r, g), GetSlot(r, S), GetSlot(r, p))), IsTemporalDateTime(r)) return ToTemporalOverflow(t), CreateTemporalDate(GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(r, p));
-    var _e12 = GetTemporalCalendarSlotValueWithISODefault(r);
-    return CalendarDateFromFields(_e12, PrepareTemporalFields(r, CalendarFields(_e12, ["day", "month", "monthCode", "year"]), []), t);
-  }
-  ToTemporalOverflow(t);
-  var _ParseTemporalDateStr = function ParseTemporalDateString(e) {
-      return ParseISODateTime(e);
-    }(ToString(r)),
-    o = _ParseTemporalDateStr.year,
-    n = _ParseTemporalDateStr.month,
-    a = _ParseTemporalDateStr.day,
-    d = _ParseTemporalDateStr.calendar,
-    m = _ParseTemporalDateStr.z;
-  if (m) throw new RangeError("Z designator not supported for PlainDate");
-  if (d || (d = "iso8601"), !IsBuiltinCalendar(d)) throw new RangeError("invalid calendar identifier ".concat(d));
-  return d = ASCIILowercase(d), CreateTemporalDate(o, n, a, d);
-}
-function InterpretTemporalDateTimeFields(e, t, r) {
-  var _RegulateTime;
-  var _ToTemporalTimeRecord = ToTemporalTimeRecord(t),
-    o = _ToTemporalTimeRecord.hour,
-    n = _ToTemporalTimeRecord.minute,
-    a = _ToTemporalTimeRecord.second,
-    d = _ToTemporalTimeRecord.millisecond,
-    m = _ToTemporalTimeRecord.microsecond,
-    c = _ToTemporalTimeRecord.nanosecond;
-  var h = ToTemporalOverflow(r),
-    u = CalendarDateFromFields(e, t, r),
-    T = GetSlot(u, i),
-    p = GetSlot(u, s),
-    f = GetSlot(u, l);
-  return (_RegulateTime = RegulateTime(o, n, a, d, m, c, h), o = _RegulateTime.hour, n = _RegulateTime.minute, a = _RegulateTime.second, d = _RegulateTime.millisecond, m = _RegulateTime.microsecond, c = _RegulateTime.nanosecond), {
-    year: T,
-    month: p,
-    day: f,
-    hour: o,
-    minute: n,
-    second: a,
-    millisecond: d,
-    microsecond: m,
-    nanosecond: c
-  };
-}
-function ToTemporalDateTime(e, t) {
-  var r, o, n, a, d, m, c, h, u, T;
-  if (IsObject(e)) {
-    if (IsTemporalDateTime(e)) return e;
-    if (IsTemporalZonedDateTime(e)) return ToTemporalOverflow(t), GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
-    if (IsTemporalDate(e)) return ToTemporalOverflow(t), CreateTemporalDateTime(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), 0, 0, 0, 0, 0, 0, GetSlot(e, p));
-    T = GetTemporalCalendarSlotValueWithISODefault(e);
-    var _f3 = PrepareTemporalFields(e, CalendarFields(T, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
-    var _InterpretTemporalDat2 = InterpretTemporalDateTimeFields(T, _f3, t);
-    r = _InterpretTemporalDat2.year;
-    o = _InterpretTemporalDat2.month;
-    n = _InterpretTemporalDat2.day;
-    a = _InterpretTemporalDat2.hour;
-    d = _InterpretTemporalDat2.minute;
-    m = _InterpretTemporalDat2.second;
-    c = _InterpretTemporalDat2.millisecond;
-    h = _InterpretTemporalDat2.microsecond;
-    u = _InterpretTemporalDat2.nanosecond;
-  } else {
-    var _ParseTemporalDateTim;
-    var _i6;
-    if (ToTemporalOverflow(t), (_ParseTemporalDateTim = function ParseTemporalDateTimeString(e) {
-      return ParseISODateTime(e);
-    }(ToString(e)), r = _ParseTemporalDateTim.year, o = _ParseTemporalDateTim.month, n = _ParseTemporalDateTim.day, a = _ParseTemporalDateTim.hour, d = _ParseTemporalDateTim.minute, m = _ParseTemporalDateTim.second, c = _ParseTemporalDateTim.millisecond, h = _ParseTemporalDateTim.microsecond, u = _ParseTemporalDateTim.nanosecond, T = _ParseTemporalDateTim.calendar, _i6 = _ParseTemporalDateTim.z), _i6) throw new RangeError("Z designator not supported for PlainDateTime");
-    if (RejectDateTime(r, o, n, a, d, m, c, h, u), T || (T = "iso8601"), !IsBuiltinCalendar(T)) throw new RangeError("invalid calendar identifier ".concat(T));
-    T = ASCIILowercase(T);
-  }
-  return CreateTemporalDateTime(r, o, n, a, d, m, c, h, u, T);
-}
-function ToTemporalDuration(e) {
-  if (IsTemporalDuration(e)) return e;
-  var _ToTemporalDurationRe = ToTemporalDurationRecord(e),
-    t = _ToTemporalDurationRe.years,
-    r = _ToTemporalDurationRe.months,
-    o = _ToTemporalDurationRe.weeks,
-    n = _ToTemporalDurationRe.days,
-    a = _ToTemporalDurationRe.hours,
-    i = _ToTemporalDurationRe.minutes,
-    s = _ToTemporalDurationRe.seconds,
-    l = _ToTemporalDurationRe.milliseconds,
-    d = _ToTemporalDurationRe.microseconds,
-    m = _ToTemporalDurationRe.nanoseconds;
-  return new (GetIntrinsic("%Temporal.Duration%"))(t, r, o, n, a, i, s, l, d, m);
-}
-function ToTemporalInstant(e) {
-  if (IsTemporalInstant(e)) return e;
-  if (IsTemporalZonedDateTime(e)) {
-    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
-  }
-  var t = ParseTemporalInstant(ToString(e));
-  return new (GetIntrinsic("%Temporal.Instant%"))(t);
-}
-function ToTemporalMonthDay(e, t) {
-  var r = e;
-  if (IsObject(r)) {
-    if (IsTemporalMonthDay(r)) return r;
-    var _e13, _o6;
-    if (HasSlot(r, p)) _e13 = GetSlot(r, p), _o6 = !1;else {
-      var _t12 = r.calendar;
-      _o6 = void 0 === _t12, void 0 === _t12 && (_t12 = "iso8601"), _e13 = ToTemporalCalendarSlotValue(_t12);
-    }
-    var _n3 = PrepareTemporalFields(r, CalendarFields(_e13, ["day", "month", "monthCode", "year"]), []);
-    return _o6 && void 0 !== _n3.month && void 0 === _n3.monthCode && void 0 === _n3.year && (_n3.year = 1972), CalendarMonthDayFromFields(_e13, _n3, t);
-  }
-  ToTemporalOverflow(t);
-  var _ParseTemporalMonthDa = ParseTemporalMonthDayString(ToString(r)),
-    o = _ParseTemporalMonthDa.month,
-    n = _ParseTemporalMonthDa.day,
-    a = _ParseTemporalMonthDa.referenceISOYear,
-    i = _ParseTemporalMonthDa.calendar;
-  if (void 0 === i && (i = "iso8601"), !IsBuiltinCalendar(i)) throw new RangeError("invalid calendar identifier ".concat(i));
-  if (i = ASCIILowercase(i), void 0 === a) return RejectISODate(1972, o, n), CreateTemporalMonthDay(o, n, i);
-  return CalendarMonthDayFromFields(i, CreateTemporalMonthDay(o, n, i, a));
-}
-function ToTemporalTime(e) {
-  var _ParseTemporalTimeStr;
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "constrain";
-  var r,
-    o,
-    n,
-    a,
-    i,
-    s,
-    l = e;
-  if (IsObject(l)) {
-    var _ToTemporalTimeRecord2, _RegulateTime2;
-    if (IsTemporalTime(l)) return l;
-    if (IsTemporalZonedDateTime(l) && (l = GetPlainDateTimeFor(GetSlot(l, g), GetSlot(l, S), GetSlot(l, p))), IsTemporalDateTime(l)) {
-      return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(l, d), GetSlot(l, m), GetSlot(l, c), GetSlot(l, h), GetSlot(l, u), GetSlot(l, T));
-    }
-    (_ToTemporalTimeRecord2 = ToTemporalTimeRecord(l), r = _ToTemporalTimeRecord2.hour, o = _ToTemporalTimeRecord2.minute, n = _ToTemporalTimeRecord2.second, a = _ToTemporalTimeRecord2.millisecond, i = _ToTemporalTimeRecord2.microsecond, s = _ToTemporalTimeRecord2.nanosecond), (_RegulateTime2 = RegulateTime(r, o, n, a, i, s, t), r = _RegulateTime2.hour, o = _RegulateTime2.minute, n = _RegulateTime2.second, a = _RegulateTime2.millisecond, i = _RegulateTime2.microsecond, s = _RegulateTime2.nanosecond);
-  } else (_ParseTemporalTimeStr = function ParseTemporalTimeString(e) {
-    var t = z.exec(e);
-    var r, o, n, a, i, s, l;
-    if (t) {
-      r = ToIntegerOrInfinity(t[1]), o = ToIntegerOrInfinity(t[2] || t[5]), n = ToIntegerOrInfinity(t[3] || t[6]), 60 === n && (n = 59);
+function GetTemporalUnit(e, t, r, o){
+ var
+  n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
+ var a = [];
+ for(var _i2 = 0, _Ue = Ue; _i2 < _Ue.length; _i2++){
+  var _Ue$_i = _slicedToArray(_Ue[_i2], 3), _e7 = _Ue$_i[1], _t9 = _Ue$_i[2];
+  "datetime" !== r && r !== _t9 || a.push(_e7);
+ }
+ a.push.apply(a, _toConsumableArray(n));
+ var i = o;
+ i === He ? i = void 0 : void 0 !== i && a.push(i);
+ var s = [].concat(a);
+ for(var _i3 = 0, _a3 = a; _i3 < _a3.length; _i3++){
+  var _e8 = _a3[_i3];
+  var _t10 = Le.get(_e8);
+  void 0 !== _t10 && s.push(_t10);
+ }
+ var l = GetOption(e, t, s, i);
+ if(void 0 === l && o === He)
+  throw new RangeError("".concat(t, " is required"));
+ return Ae.has(l) ? Ae.get(l) : l;
+}
+function ToRelativeTemporalObject(e){
+ var t = e.relativeTo;
+ if(void 0 === t) return t;
+ var r, o, n, a, i, s, l, d, m, c, h, u, T = "option", p = ! 1;
+ if(IsObject(t)){
+  var _InterpretTemporalDat;
+  if(IsTemporalZonedDateTime(t) || IsTemporalDate(t)) return t;
+  if(IsTemporalDateTime(t)) return TemporalDateTimeToDate(t);
+  c = GetTemporalCalendarSlotValueWithISODefault(t);
+  var
+   _e9 =
+     CalendarFields
+      (c,
+       ["day",
+        "hour",
+        "microsecond",
+        "millisecond",
+        "minute",
+        "month",
+        "monthCode",
+        "nanosecond",
+        "second",
+        "year"]);
+  _e9.push("timeZone", "offset");
+  var _p = PrepareTemporalFields(t, _e9, []), _f = Te(null);
+  _f.overflow = "constrain",
+  _InterpretTemporalDat = InterpretTemporalDateTimeFields(c, _p, _f),
+  r = _InterpretTemporalDat.year,
+  o = _InterpretTemporalDat.month,
+  n = _InterpretTemporalDat.day,
+  a = _InterpretTemporalDat.hour,
+  i = _InterpretTemporalDat.minute,
+  s = _InterpretTemporalDat.second,
+  l = _InterpretTemporalDat.millisecond,
+  d = _InterpretTemporalDat.microsecond,
+  m = _InterpretTemporalDat.nanosecond,
+  u = _p.offset,
+  void 0 === u && (T = "wall"),
+  h = _p.timeZone,
+  void 0 !== h && (h = ToTemporalTimeZoneSlotValue(h));
+ }
+ else{
+  var _ParseISODateTime3;
+  var _e10, _f2;
+  if
+   (_ParseISODateTime3 = ParseISODateTime(ToString(t)),
+    r = _ParseISODateTime3.year,
+    o = _ParseISODateTime3.month,
+    n = _ParseISODateTime3.day,
+    a = _ParseISODateTime3.hour,
+    i = _ParseISODateTime3.minute,
+    s = _ParseISODateTime3.second,
+    l = _ParseISODateTime3.millisecond,
+    d = _ParseISODateTime3.microsecond,
+    m = _ParseISODateTime3.nanosecond,
+    c = _ParseISODateTime3.calendar,
+    _e10 = _ParseISODateTime3.ianaName,
+    u = _ParseISODateTime3.offset,
+    _f2 = _ParseISODateTime3.z,
+    _e10)
+   h = ToTemporalTimeZoneSlotValue(_e10),
+   _f2 ? T = "exact" : u || (T = "wall"),
+   p = ! 0;
+  else if(_f2)
+   throw new
+          RangeError
+          ("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
+  if(c || (c = "iso8601"), ! IsBuiltinCalendar(c))
+   throw new RangeError("invalid calendar identifier ".concat(c));
+  c = ASCIILowercase(c);
+ }
+ if(void 0 === h) return CreateTemporalDate(r, o, n, c);
+ return CreateTemporalZonedDateTime
+         (InterpretISODateTimeOffset
+           (r,
+            o,
+            n,
+            a,
+            i,
+            s,
+            l,
+            d,
+            m,
+            T,
+            "option" === T ? ParseTimeZoneOffsetString(u) : 0,
+            h,
+            "compatible",
+            "reject",
+            p),
+          h,
+          c);
+}
+function DefaultTemporalLargestUnit(e, t, r, o, n, a, i, s, l, d){
+ for
+ (var
+   _i4 = 0,
+   _arr =
+     [["years", e],
+      ["months", t],
+      ["weeks", r],
+      ["days", o],
+      ["hours", n],
+      ["minutes", a],
+      ["seconds", i],
+      ["milliseconds", s],
+      ["microseconds", l],
+      ["nanoseconds", d]];
+  _i4 < _arr.length;
+  _i4++){
+  var
+   _arr$_i = _slicedToArray(_arr[_i4], 2),
+   _m = _arr$_i[0],
+   _c = _arr$_i[1];
+  if(0 !== _c) return Ae.get(_m);
+ }
+ return "nanosecond";
+}
+function LargerOfTwoTemporalUnits(e, t){
+ return xe.indexOf(e) > xe.indexOf(t) ? t : e;
+}
+function PrepareTemporalFields(e, t, r){
+ var
+  _ref7 =
+    arguments.length > 3 && arguments[3] !== undefined
+     ? arguments[3]
+     : {emptySourceErrorMessage: "no supported properties found"},
+  o = _ref7.emptySourceErrorMessage;
+ var n = Te(null);
+ var a = ! 1;
+ t.sort();
+ var _iterator9 = _createForOfIteratorHelper(t), _step9;
+ try{
+  for(_iterator9.s(); ! (_step9 = _iterator9.n()).done;){
+   var _o5 = _step9.value;
+   var _t11 = e[_o5];
+   if(void 0 !== _t11)
+    a = ! 0, $e.has(_o5) && (_t11 = $e.get(_o5)(_t11)), n[_o5] = _t11;
+   else if("partial" !== r){
+    if(ee.call(r, _o5))
+     throw new
+            TypeError
+            ("required property '".concat(_o5, "' missing or undefined"));
+    _t11 = ke.get(_o5), n[_o5] = _t11;
+   }
+  }
+ }
+ catch(err){_iterator9.e(err);}
+ finally{_iterator9.f();}
+ if("partial" === r && ! a) throw new TypeError(o);
+ return n;
+}
+function ToTemporalTimeRecord(e){
+ var
+  t =
+    arguments.length > 1 && arguments[1] !== undefined
+     ? arguments[1]
+     : "complete";
+ var
+  r = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"],
+  o =
+    PrepareTemporalFields
+     (e, r, "partial", {emptySourceErrorMessage: "invalid time-like"}),
+  n = {};
+ for(var _i5 = 0, _r8 = r; _i5 < _r8.length; _i5++){
+  var _e11 = _r8[_i5];
+  var _r9 = pe(o, _e11);
+  void 0 !== _r9 ? n[_e11] = _r9.value : "complete" === t && (n[_e11] = 0);
+ }
+ return n;
+}
+function ToTemporalDate(e, t){
+ var r = e;
+ if(IsObject(r)){
+  if(IsTemporalDate(r)) return r;
+  if
+   (IsTemporalZonedDateTime(r)
+    &&
+     (ToTemporalOverflow(t),
+      r = GetPlainDateTimeFor(GetSlot(r, g), GetSlot(r, S), GetSlot(r, p))),
+    IsTemporalDateTime(r))
+   return ToTemporalOverflow(t),
+          CreateTemporalDate
+           (GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(r, p));
+  var _e12 = GetTemporalCalendarSlotValueWithISODefault(r);
+  return CalendarDateFromFields
+          (_e12,
+           PrepareTemporalFields
+            (r,
+             CalendarFields(_e12, ["day", "month", "monthCode", "year"]),
+             []),
+           t);
+ }
+ ToTemporalOverflow(t);
+ var
+  _ParseTemporalDateStr =
+    function ParseTemporalDateString(e){return ParseISODateTime(e);}
+     (ToString(r)),
+  o = _ParseTemporalDateStr.year,
+  n = _ParseTemporalDateStr.month,
+  a = _ParseTemporalDateStr.day,
+  d = _ParseTemporalDateStr.calendar,
+  m = _ParseTemporalDateStr.z;
+ if(m) throw new RangeError("Z designator not supported for PlainDate");
+ if(d || (d = "iso8601"), ! IsBuiltinCalendar(d))
+  throw new RangeError("invalid calendar identifier ".concat(d));
+ return d = ASCIILowercase(d), CreateTemporalDate(o, n, a, d);
+}
+function InterpretTemporalDateTimeFields(e, t, r){
+ var _RegulateTime;
+ var
+  _ToTemporalTimeRecord = ToTemporalTimeRecord(t),
+  o = _ToTemporalTimeRecord.hour,
+  n = _ToTemporalTimeRecord.minute,
+  a = _ToTemporalTimeRecord.second,
+  d = _ToTemporalTimeRecord.millisecond,
+  m = _ToTemporalTimeRecord.microsecond,
+  c = _ToTemporalTimeRecord.nanosecond;
+ var
+  h = ToTemporalOverflow(r),
+  u = CalendarDateFromFields(e, t, r),
+  T = GetSlot(u, i),
+  p = GetSlot(u, s),
+  f = GetSlot(u, l);
+ return _RegulateTime = RegulateTime(o, n, a, d, m, c, h),
+        o = _RegulateTime.hour,
+        n = _RegulateTime.minute,
+        a = _RegulateTime.second,
+        d = _RegulateTime.millisecond,
+        m = _RegulateTime.microsecond,
+        c = _RegulateTime.nanosecond,
+        {year: T,
+         month: p,
+         day: f,
+         hour: o,
+         minute: n,
+         second: a,
+         millisecond: d,
+         microsecond: m,
+         nanosecond: c};
+}
+function ToTemporalDateTime(e, t){
+ var r, o, n, a, d, m, c, h, u, T;
+ if(IsObject(e)){
+  if(IsTemporalDateTime(e)) return e;
+  if(IsTemporalZonedDateTime(e))
+   return ToTemporalOverflow(t),
+          GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
+  if(IsTemporalDate(e))
+   return ToTemporalOverflow(t),
+          CreateTemporalDateTime
+           (GetSlot(e, i),
+            GetSlot(e, s),
+            GetSlot(e, l),
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            GetSlot(e, p));
+  T = GetTemporalCalendarSlotValueWithISODefault(e);
+  var
+   _f3 =
+     PrepareTemporalFields
+      (e,
+       CalendarFields
+        (T,
+         ["day",
+          "hour",
+          "microsecond",
+          "millisecond",
+          "minute",
+          "month",
+          "monthCode",
+          "nanosecond",
+          "second",
+          "year"]),
+       []);
+  var _InterpretTemporalDat2 = InterpretTemporalDateTimeFields(T, _f3, t);
+  r = _InterpretTemporalDat2.year;
+  o = _InterpretTemporalDat2.month;
+  n = _InterpretTemporalDat2.day;
+  a = _InterpretTemporalDat2.hour;
+  d = _InterpretTemporalDat2.minute;
+  m = _InterpretTemporalDat2.second;
+  c = _InterpretTemporalDat2.millisecond;
+  h = _InterpretTemporalDat2.microsecond;
+  u = _InterpretTemporalDat2.nanosecond;
+ }
+ else{
+  var _ParseTemporalDateTim;
+  var _i6;
+  if
+   (ToTemporalOverflow(t),
+    _ParseTemporalDateTim =
+     function ParseTemporalDateTimeString(e){return ParseISODateTime(e);}
+      (ToString(e)),
+    r = _ParseTemporalDateTim.year,
+    o = _ParseTemporalDateTim.month,
+    n = _ParseTemporalDateTim.day,
+    a = _ParseTemporalDateTim.hour,
+    d = _ParseTemporalDateTim.minute,
+    m = _ParseTemporalDateTim.second,
+    c = _ParseTemporalDateTim.millisecond,
+    h = _ParseTemporalDateTim.microsecond,
+    u = _ParseTemporalDateTim.nanosecond,
+    T = _ParseTemporalDateTim.calendar,
+    _i6 = _ParseTemporalDateTim.z,
+    _i6)
+   throw new RangeError("Z designator not supported for PlainDateTime");
+  if
+   (RejectDateTime(r, o, n, a, d, m, c, h, u),
+    T || (T = "iso8601"),
+    !
+    IsBuiltinCalendar(T))
+   throw new RangeError("invalid calendar identifier ".concat(T));
+  T = ASCIILowercase(T);
+ }
+ return CreateTemporalDateTime(r, o, n, a, d, m, c, h, u, T);
+}
+function ToTemporalDuration(e){
+ if(IsTemporalDuration(e)) return e;
+ var
+  _ToTemporalDurationRe = ToTemporalDurationRecord(e),
+  t = _ToTemporalDurationRe.years,
+  r = _ToTemporalDurationRe.months,
+  o = _ToTemporalDurationRe.weeks,
+  n = _ToTemporalDurationRe.days,
+  a = _ToTemporalDurationRe.hours,
+  i = _ToTemporalDurationRe.minutes,
+  s = _ToTemporalDurationRe.seconds,
+  l = _ToTemporalDurationRe.milliseconds,
+  d = _ToTemporalDurationRe.microseconds,
+  m = _ToTemporalDurationRe.nanoseconds;
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (t, r, o, n, a, i, s, l, d, m);
+}
+function ToTemporalInstant(e){
+ if(IsTemporalInstant(e)) return e;
+ if(IsTemporalZonedDateTime(e)){
+  return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
+ }
+ var t = ParseTemporalInstant(ToString(e));
+ return new (GetIntrinsic("%Temporal.Instant%"))(t);
+}
+function ToTemporalMonthDay(e, t){
+ var r = e;
+ if(IsObject(r)){
+  if(IsTemporalMonthDay(r)) return r;
+  var _e13, _o6;
+  if(HasSlot(r, p))
+   _e13 = GetSlot(r, p), _o6 = ! 1;
+  else{
+   var _t12 = r.calendar;
+   _o6 = void 0 === _t12,
+   void 0 === _t12 && (_t12 = "iso8601"),
+   _e13 = ToTemporalCalendarSlotValue(_t12);
+  }
+  var
+   _n3 =
+     PrepareTemporalFields
+      (r, CalendarFields(_e13, ["day", "month", "monthCode", "year"]), []);
+  return _o6 && void 0 !== _n3.month && void 0 === _n3.monthCode
+         && void 0 === _n3.year
+         && (_n3.year = 1972),
+         CalendarMonthDayFromFields(_e13, _n3, t);
+ }
+ ToTemporalOverflow(t);
+ var
+  _ParseTemporalMonthDa = ParseTemporalMonthDayString(ToString(r)),
+  o = _ParseTemporalMonthDa.month,
+  n = _ParseTemporalMonthDa.day,
+  a = _ParseTemporalMonthDa.referenceISOYear,
+  i = _ParseTemporalMonthDa.calendar;
+ if(void 0 === i && (i = "iso8601"), ! IsBuiltinCalendar(i))
+  throw new RangeError("invalid calendar identifier ".concat(i));
+ if(i = ASCIILowercase(i), void 0 === a)
+  return RejectISODate(1972, o, n), CreateTemporalMonthDay(o, n, i);
+ return CalendarMonthDayFromFields(i, CreateTemporalMonthDay(o, n, i, a));
+}
+function ToTemporalTime(e){
+ var _ParseTemporalTimeStr;
+ var
+  t =
+    arguments.length > 1 && arguments[1] !== undefined
+     ? arguments[1]
+     : "constrain";
+ var r, o, n, a, i, s, l = e;
+ if(IsObject(l)){
+  var _ToTemporalTimeRecord2, _RegulateTime2;
+  if(IsTemporalTime(l)) return l;
+  if
+   (IsTemporalZonedDateTime(l)
+    && (l = GetPlainDateTimeFor(GetSlot(l, g), GetSlot(l, S), GetSlot(l, p))),
+    IsTemporalDateTime(l)){
+   return new
+           (GetIntrinsic("%Temporal.PlainTime%"))
+           (GetSlot(l, d),
+            GetSlot(l, m),
+            GetSlot(l, c),
+            GetSlot(l, h),
+            GetSlot(l, u),
+            GetSlot(l, T));
+  }
+  _ToTemporalTimeRecord2 = ToTemporalTimeRecord(l),
+  r = _ToTemporalTimeRecord2.hour,
+  o = _ToTemporalTimeRecord2.minute,
+  n = _ToTemporalTimeRecord2.second,
+  a = _ToTemporalTimeRecord2.millisecond,
+  i = _ToTemporalTimeRecord2.microsecond,
+  s = _ToTemporalTimeRecord2.nanosecond,
+  _RegulateTime2 = RegulateTime(r, o, n, a, i, s, t),
+  r = _RegulateTime2.hour,
+  o = _RegulateTime2.minute,
+  n = _RegulateTime2.second,
+  a = _RegulateTime2.millisecond,
+  i = _RegulateTime2.microsecond,
+  s = _RegulateTime2.nanosecond;
+ }
+ else
+  _ParseTemporalTimeStr =
+   function ParseTemporalTimeString(e){
+     var t = z.exec(e);
+     var r, o, n, a, i, s, l;
+     if(t){
+      r = ToIntegerOrInfinity(t[1]),
+      o = ToIntegerOrInfinity(t[2] || t[5]),
+      n = ToIntegerOrInfinity(t[3] || t[6]),
+      60 === n && (n = 59);
       var _e14 = (t[4] || t[7]) + "000000000";
-      a = ToIntegerOrInfinity(_e14.slice(0, 3)), i = ToIntegerOrInfinity(_e14.slice(3, 6)), s = ToIntegerOrInfinity(_e14.slice(6, 9)), l = t[14];
-      var _iterator10 = _createForOfIteratorHelper(l.matchAll(H)),
-        _step10;
-      try {
-        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
-          var _step10$value = _slicedToArray(_step10.value, 4),
-            _e15 = _step10$value[1],
-            _t13 = _step10$value[2],
-            _r10 = _step10$value[3];
-          if ("u-ca" !== _t13 && "!" === _e15) throw new RangeError("Unrecognized annotation: !".concat(_t13, "=").concat(_r10));
-        }
-      } catch (err) {
-        _iterator10.e(err);
-      } finally {
-        _iterator10.f();
-      }
-      if (t[8]) throw new RangeError("Z designator not supported for PlainTime");
-    } else {
+      a = ToIntegerOrInfinity(_e14.slice(0, 3)),
+      i = ToIntegerOrInfinity(_e14.slice(3, 6)),
+      s = ToIntegerOrInfinity(_e14.slice(6, 9)),
+      l = t[14];
+      var _iterator10 = _createForOfIteratorHelper(l.matchAll(H)), _step10;
+      try{
+       for(_iterator10.s(); ! (_step10 = _iterator10.n()).done;){
+        var
+         _step10$value = _slicedToArray(_step10.value, 4),
+         _e15 = _step10$value[1],
+         _t13 = _step10$value[2],
+         _r10 = _step10$value[3];
+        if("u-ca" !== _t13 && "!" === _e15)
+         throw new
+                RangeError
+                ("Unrecognized annotation: !".concat(_t13, "=").concat(_r10));
+       }
+      }
+      catch(err){_iterator10.e(err);}
+      finally{_iterator10.f();}
+      if(t[8])
+       throw new RangeError("Z designator not supported for PlainTime");
+     }
+     else{
       var _ParseISODateTime4;
       var _t14, _l;
-      if ((_ParseISODateTime4 = ParseISODateTime(e), _l = _ParseISODateTime4.hasTime, r = _ParseISODateTime4.hour, o = _ParseISODateTime4.minute, n = _ParseISODateTime4.second, a = _ParseISODateTime4.millisecond, i = _ParseISODateTime4.microsecond, s = _ParseISODateTime4.nanosecond, _t14 = _ParseISODateTime4.z), !_l) throw new RangeError("time is missing in string: ".concat(e));
-      if (_t14) throw new RangeError("Z designator not supported for PlainTime");
-    }
-    if (/[tT ][0-9][0-9]/.test(e)) return {
-      hour: r,
-      minute: o,
-      second: n,
-      millisecond: a,
-      microsecond: i,
-      nanosecond: s
-    };
-    try {
-      var _ParseTemporalMonthDa2 = ParseTemporalMonthDayString(e),
-        _t15 = _ParseTemporalMonthDa2.month,
-        _r11 = _ParseTemporalMonthDa2.day;
+      if
+       (_ParseISODateTime4 = ParseISODateTime(e),
+        _l = _ParseISODateTime4.hasTime,
+        r = _ParseISODateTime4.hour,
+        o = _ParseISODateTime4.minute,
+        n = _ParseISODateTime4.second,
+        a = _ParseISODateTime4.millisecond,
+        i = _ParseISODateTime4.microsecond,
+        s = _ParseISODateTime4.nanosecond,
+        _t14 = _ParseISODateTime4.z,
+        !
+        _l)
+       throw new RangeError("time is missing in string: ".concat(e));
+      if(_t14)
+       throw new RangeError("Z designator not supported for PlainTime");
+     }
+     if(/[tT ][0-9][0-9]/.test(e))
+      return {hour: r,
+              minute: o,
+              second: n,
+              millisecond: a,
+              microsecond: i,
+              nanosecond: s};
+     try{
+      var
+       _ParseTemporalMonthDa2 = ParseTemporalMonthDayString(e),
+       _t15 = _ParseTemporalMonthDa2.month,
+       _r11 = _ParseTemporalMonthDa2.day;
       RejectISODate(1972, _t15, _r11);
-    } catch (_unused2) {
-      try {
-        var _ParseTemporalYearMon = ParseTemporalYearMonthString(e),
-          _t16 = _ParseTemporalYearMon.year,
-          _r12 = _ParseTemporalYearMon.month;
-        RejectISODate(_t16, _r12, 1);
-      } catch (_unused3) {
-        return {
-          hour: r,
-          minute: o,
-          second: n,
-          millisecond: a,
-          microsecond: i,
-          nanosecond: s
-        };
-      }
-    }
-    throw new RangeError("invalid ISO 8601 time-only string ".concat(e, "; may need a T prefix"));
-  }(ToString(l)), r = _ParseTemporalTimeStr.hour, o = _ParseTemporalTimeStr.minute, n = _ParseTemporalTimeStr.second, a = _ParseTemporalTimeStr.millisecond, i = _ParseTemporalTimeStr.microsecond, s = _ParseTemporalTimeStr.nanosecond), RejectTime(r, o, n, a, i, s);
-  return new (GetIntrinsic("%Temporal.PlainTime%"))(r, o, n, a, i, s);
-}
-function ToTemporalYearMonth(e, t) {
-  if (IsObject(e)) {
-    if (IsTemporalYearMonth(e)) return e;
-    var _r13 = GetTemporalCalendarSlotValueWithISODefault(e);
-    return CalendarYearMonthFromFields(_r13, PrepareTemporalFields(e, CalendarFields(_r13, ["month", "monthCode", "year"]), []), t);
-  }
+     }
+     catch(_unused2){
+      try{
+       var
+        _ParseTemporalYearMon = ParseTemporalYearMonthString(e),
+        _t16 = _ParseTemporalYearMon.year,
+        _r12 = _ParseTemporalYearMon.month;
+       RejectISODate(_t16, _r12, 1);
+      }
+      catch(_unused3){
+       return {hour: r,
+               minute: o,
+               second: n,
+               millisecond: a,
+               microsecond: i,
+               nanosecond: s};
+      }
+     }
+     throw new
+            RangeError
+            ("invalid ISO 8601 time-only string ".concat
+              (e, "; may need a T prefix"));
+    }
+    (ToString(l)),
+  r = _ParseTemporalTimeStr.hour,
+  o = _ParseTemporalTimeStr.minute,
+  n = _ParseTemporalTimeStr.second,
+  a = _ParseTemporalTimeStr.millisecond,
+  i = _ParseTemporalTimeStr.microsecond,
+  s = _ParseTemporalTimeStr.nanosecond,
+  RejectTime(r, o, n, a, i, s);
+ return new (GetIntrinsic("%Temporal.PlainTime%"))(r, o, n, a, i, s);
+}
+function ToTemporalYearMonth(e, t){
+ if(IsObject(e)){
+  if(IsTemporalYearMonth(e)) return e;
+  var _r13 = GetTemporalCalendarSlotValueWithISODefault(e);
+  return CalendarYearMonthFromFields
+          (_r13,
+           PrepareTemporalFields
+            (e, CalendarFields(_r13, ["month", "monthCode", "year"]), []),
+           t);
+ }
+ ToTemporalOverflow(t);
+ var
+  _ParseTemporalYearMon2 = ParseTemporalYearMonthString(ToString(e)),
+  r = _ParseTemporalYearMon2.year,
+  o = _ParseTemporalYearMon2.month,
+  n = _ParseTemporalYearMon2.referenceISODay,
+  a = _ParseTemporalYearMon2.calendar;
+ if(void 0 === a && (a = "iso8601"), ! IsBuiltinCalendar(a))
+  throw new RangeError("invalid calendar identifier ".concat(a));
+ if(a = ASCIILowercase(a), void 0 === n)
+  return RejectISODate(r, o, 1), CreateTemporalYearMonth(r, o, a);
+ return CalendarYearMonthFromFields(a, CreateTemporalYearMonth(r, o, a, n));
+}
+function InterpretISODateTimeOffset
+(t, r, o, i, s, l, d, m, c, h, u, T, p, f, y){
+ var
+  I =
+    new (GetIntrinsic("%Temporal.PlainDateTime%"))(t, r, o, i, s, l, d, m, c);
+ if("wall" === h || "ignore" === f){
+  return GetSlot(GetInstantFor(T, I, p), n);
+ }
+ if("exact" === h || "use" === f){
+  var _n4 = GetUTCEpochNanoseconds(t, r, o, i, s, l, d, m, c);
+  if(null === _n4)
+   throw new RangeError("ZonedDateTime outside of supported range");
+  return _n4 - BigInt(u);
+ }
+ var S = GetPossibleInstantsFor(T, I);
+ var _iterator11 = _createForOfIteratorHelper(S), _step11;
+ try{
+  for(_iterator11.s(); ! (_step11 = _iterator11.n()).done;){
+   var _t18 = _step11.value;
+   var
+    _r14 = GetOffsetNanosecondsFor(T, _t18),
+    _o7 = Number(RoundNumberToIncrement(BigInt(_r14), be, "halfExpand"));
+   if(_r14 === u || y && _o7 === u) return GetSlot(_t18, n);
+  }
+ }
+ catch(err){_iterator11.e(err);}
+ finally{_iterator11.f();}
+ if("reject" === f){
+  var
+   _e16 = FormatTimeZoneOffsetString(u),
+   _t17 = IsTemporalTimeZone(T) ? GetSlot(T, a) : "time zone";
+  throw new
+         RangeError
+         ("Offset ".concat(_e16, " is invalid for ").concat
+            (I.toString(), " in ").concat
+           (_t17));
+ }
+ return GetSlot(DisambiguatePossibleInstants(S, T, I, p), n);
+}
+function ToTemporalZonedDateTime(e, t){
+ var r, o, n, a, i, s, l, d, m, c, h, u, T, p, f = ! 1, y = "option";
+ if(IsObject(e)){
+  var _InterpretTemporalDat3;
+  if(IsTemporalZonedDateTime(e)) return e;
+  u = GetTemporalCalendarSlotValueWithISODefault(e);
+  var
+   _f4 =
+     CalendarFields
+      (u,
+       ["day",
+        "hour",
+        "microsecond",
+        "millisecond",
+        "minute",
+        "month",
+        "monthCode",
+        "nanosecond",
+        "second",
+        "year"]);
+  _f4.push("timeZone", "offset");
+  var _I = PrepareTemporalFields(e, _f4, ["timeZone"]);
+  c = ToTemporalTimeZoneSlotValue(_I.timeZone),
+  h = _I.offset,
+  void 0 === h && (y = "wall"),
+  T = ToTemporalDisambiguation(t),
+  p = ToTemporalOffset(t, "reject"),
+  _InterpretTemporalDat3 = InterpretTemporalDateTimeFields(u, _I, t),
+  r = _InterpretTemporalDat3.year,
+  o = _InterpretTemporalDat3.month,
+  n = _InterpretTemporalDat3.day,
+  a = _InterpretTemporalDat3.hour,
+  i = _InterpretTemporalDat3.minute,
+  s = _InterpretTemporalDat3.second,
+  l = _InterpretTemporalDat3.millisecond,
+  d = _InterpretTemporalDat3.microsecond,
+  m = _InterpretTemporalDat3.nanosecond;
+ }
+ else{
+  var _ParseTemporalZonedDa;
+  var _I2, _S;
+  if
+   (_ParseTemporalZonedDa =
+     function ParseTemporalZonedDateTimeString(e){
+       var t = ParseISODateTime(e);
+       if(! t.ianaName)
+        throw new
+               RangeError
+               ("Temporal.ZonedDateTime requires a time zone ID in brackets");
+       return t;
+      }
+      (ToString(e)),
+    r = _ParseTemporalZonedDa.year,
+    o = _ParseTemporalZonedDa.month,
+    n = _ParseTemporalZonedDa.day,
+    a = _ParseTemporalZonedDa.hour,
+    i = _ParseTemporalZonedDa.minute,
+    s = _ParseTemporalZonedDa.second,
+    l = _ParseTemporalZonedDa.millisecond,
+    d = _ParseTemporalZonedDa.microsecond,
+    m = _ParseTemporalZonedDa.nanosecond,
+    _I2 = _ParseTemporalZonedDa.ianaName,
+    h = _ParseTemporalZonedDa.offset,
+    _S = _ParseTemporalZonedDa.z,
+    u = _ParseTemporalZonedDa.calendar,
+    c = ToTemporalTimeZoneSlotValue(_I2),
+    _S ? y = "exact" : h || (y = "wall"),
+    u || (u = "iso8601"),
+    !
+    IsBuiltinCalendar(u))
+   throw new RangeError("invalid calendar identifier ".concat(u));
+  u = ASCIILowercase(u),
+  f = ! 0,
+  T = ToTemporalDisambiguation(t),
+  p = ToTemporalOffset(t, "reject"),
   ToTemporalOverflow(t);
-  var _ParseTemporalYearMon2 = ParseTemporalYearMonthString(ToString(e)),
-    r = _ParseTemporalYearMon2.year,
-    o = _ParseTemporalYearMon2.month,
-    n = _ParseTemporalYearMon2.referenceISODay,
-    a = _ParseTemporalYearMon2.calendar;
-  if (void 0 === a && (a = "iso8601"), !IsBuiltinCalendar(a)) throw new RangeError("invalid calendar identifier ".concat(a));
-  if (a = ASCIILowercase(a), void 0 === n) return RejectISODate(r, o, 1), CreateTemporalYearMonth(r, o, a);
-  return CalendarYearMonthFromFields(a, CreateTemporalYearMonth(r, o, a, n));
-}
-function InterpretISODateTimeOffset(t, r, o, i, s, l, d, m, c, h, u, T, p, f, y) {
-  var I = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t, r, o, i, s, l, d, m, c);
-  if ("wall" === h || "ignore" === f) {
-    return GetSlot(GetInstantFor(T, I, p), n);
-  }
-  if ("exact" === h || "use" === f) {
-    var _n4 = GetUTCEpochNanoseconds(t, r, o, i, s, l, d, m, c);
-    if (null === _n4) throw new RangeError("ZonedDateTime outside of supported range");
-    return _n4 - BigInt(u);
-  }
-  var S = GetPossibleInstantsFor(T, I);
-  var _iterator11 = _createForOfIteratorHelper(S),
-    _step11;
-  try {
-    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
-      var _t18 = _step11.value;
-      var _r14 = GetOffsetNanosecondsFor(T, _t18),
-        _o7 = Number(RoundNumberToIncrement(BigInt(_r14), be, "halfExpand"));
-      if (_r14 === u || y && _o7 === u) return GetSlot(_t18, n);
-    }
-  } catch (err) {
-    _iterator11.e(err);
-  } finally {
-    _iterator11.f();
-  }
-  if ("reject" === f) {
-    var _e16 = FormatTimeZoneOffsetString(u),
-      _t17 = IsTemporalTimeZone(T) ? GetSlot(T, a) : "time zone";
-    throw new RangeError("Offset ".concat(_e16, " is invalid for ").concat(I.toString(), " in ").concat(_t17));
-  }
-  return GetSlot(DisambiguatePossibleInstants(S, T, I, p), n);
-}
-function ToTemporalZonedDateTime(e, t) {
-  var r,
-    o,
-    n,
-    a,
-    i,
-    s,
-    l,
-    d,
-    m,
-    c,
-    h,
-    u,
-    T,
-    p,
-    f = !1,
-    y = "option";
-  if (IsObject(e)) {
-    var _InterpretTemporalDat3;
-    if (IsTemporalZonedDateTime(e)) return e;
-    u = GetTemporalCalendarSlotValueWithISODefault(e);
-    var _f4 = CalendarFields(u, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
-    _f4.push("timeZone", "offset");
-    var _I = PrepareTemporalFields(e, _f4, ["timeZone"]);
-    c = ToTemporalTimeZoneSlotValue(_I.timeZone), h = _I.offset, void 0 === h && (y = "wall"), T = ToTemporalDisambiguation(t), p = ToTemporalOffset(t, "reject"), (_InterpretTemporalDat3 = InterpretTemporalDateTimeFields(u, _I, t), r = _InterpretTemporalDat3.year, o = _InterpretTemporalDat3.month, n = _InterpretTemporalDat3.day, a = _InterpretTemporalDat3.hour, i = _InterpretTemporalDat3.minute, s = _InterpretTemporalDat3.second, l = _InterpretTemporalDat3.millisecond, d = _InterpretTemporalDat3.microsecond, m = _InterpretTemporalDat3.nanosecond);
-  } else {
-    var _ParseTemporalZonedDa;
-    var _I2, _S;
-    if ((_ParseTemporalZonedDa = function ParseTemporalZonedDateTimeString(e) {
-      var t = ParseISODateTime(e);
-      if (!t.ianaName) throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
-      return t;
-    }(ToString(e)), r = _ParseTemporalZonedDa.year, o = _ParseTemporalZonedDa.month, n = _ParseTemporalZonedDa.day, a = _ParseTemporalZonedDa.hour, i = _ParseTemporalZonedDa.minute, s = _ParseTemporalZonedDa.second, l = _ParseTemporalZonedDa.millisecond, d = _ParseTemporalZonedDa.microsecond, m = _ParseTemporalZonedDa.nanosecond, _I2 = _ParseTemporalZonedDa.ianaName, h = _ParseTemporalZonedDa.offset, _S = _ParseTemporalZonedDa.z, u = _ParseTemporalZonedDa.calendar), c = ToTemporalTimeZoneSlotValue(_I2), _S ? y = "exact" : h || (y = "wall"), u || (u = "iso8601"), !IsBuiltinCalendar(u)) throw new RangeError("invalid calendar identifier ".concat(u));
-    u = ASCIILowercase(u), f = !0, T = ToTemporalDisambiguation(t), p = ToTemporalOffset(t, "reject"), ToTemporalOverflow(t);
-  }
-  var I = 0;
-  "option" === y && (I = ParseTimeZoneOffsetString(h));
-  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r, o, n, a, i, s, l, d, m, y, I, c, T, p, f), c, u);
-}
-function CreateTemporalDateSlots(e, t, r, o, n) {
-  RejectISODate(t, r, o), RejectDateRange(t, r, o), N(e), SetSlot(e, i, t), SetSlot(e, s, r), SetSlot(e, l, o), SetSlot(e, p, n), SetSlot(e, f, !0);
-}
-function CreateTemporalDate(e, t, r) {
-  var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "iso8601";
-  var n = GetIntrinsic("%Temporal.PlainDate%"),
-    a = Te(n.prototype);
-  return CreateTemporalDateSlots(a, e, t, r, o), a;
-}
-function CreateTemporalDateTimeSlots(e, t, r, o, n, a, f, y, I, S, g) {
-  RejectDateTime(t, r, o, n, a, f, y, I, S), RejectDateTimeRange(t, r, o, n, a, f, y, I, S), N(e), SetSlot(e, i, t), SetSlot(e, s, r), SetSlot(e, l, o), SetSlot(e, d, n), SetSlot(e, m, a), SetSlot(e, c, f), SetSlot(e, h, y), SetSlot(e, u, I), SetSlot(e, T, S), SetSlot(e, p, g);
-}
-function CreateTemporalDateTime(e, t, r, o, n, a, i, s, l) {
-  var d = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : "iso8601";
-  var m = GetIntrinsic("%Temporal.PlainDateTime%"),
-    c = Te(m.prototype);
-  return CreateTemporalDateTimeSlots(c, e, t, r, o, n, a, i, s, l, d), c;
-}
-function CreateTemporalMonthDaySlots(e, t, r, o, n) {
-  RejectISODate(n, t, r), RejectDateRange(n, t, r), N(e), SetSlot(e, s, t), SetSlot(e, l, r), SetSlot(e, i, n), SetSlot(e, p, o), SetSlot(e, I, !0);
-}
-function CreateTemporalMonthDay(e, t) {
-  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "iso8601";
-  var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1972;
-  var n = GetIntrinsic("%Temporal.PlainMonthDay%"),
-    a = Te(n.prototype);
-  return CreateTemporalMonthDaySlots(a, e, t, r, o), a;
-}
-function CreateTemporalYearMonthSlots(e, t, r, o, n) {
-  RejectISODate(t, r, n), function RejectYearMonthRange(e, t) {
-    RejectToRange(e, Fe, Ye), e === Fe ? RejectToRange(t, 4, 12) : e === Ye && RejectToRange(t, 1, 9);
-  }(t, r), N(e), SetSlot(e, i, t), SetSlot(e, s, r), SetSlot(e, l, n), SetSlot(e, p, o), SetSlot(e, y, !0);
-}
-function CreateTemporalYearMonth(e, t) {
-  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "iso8601";
-  var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
-  var n = GetIntrinsic("%Temporal.PlainYearMonth%"),
-    a = Te(n.prototype);
-  return CreateTemporalYearMonthSlots(a, e, t, r, o), a;
-}
-function CreateTemporalZonedDateTimeSlots(e, t, r, o) {
-  ValidateEpochNanoseconds(t), N(e), SetSlot(e, n, t), SetSlot(e, g, r), SetSlot(e, p, o);
-  var a = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
-  SetSlot(e, S, a);
-}
-function CreateTemporalZonedDateTime(e, t) {
-  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "iso8601";
-  var o = GetIntrinsic("%Temporal.ZonedDateTime%"),
-    n = Te(o.prototype);
-  return CreateTemporalZonedDateTimeSlots(n, e, t, r), n;
-}
-function CalendarFields(e, t) {
-  if ("string" == typeof e) {
-    var _r15 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"), _r15, [t]);
-  }
-  var r = Call(GetMethod(e, "fields"), e, [t]),
-    o = [];
-  var _iterator12 = _createForOfIteratorHelper(r),
-    _step12;
-  try {
-    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
-      var _e17 = _step12.value;
-      if ("string" != typeof _e17) throw new TypeError("bad return from calendar.fields()");
-      te.call(o, _e17);
-    }
-  } catch (err) {
-    _iterator12.e(err);
-  } finally {
-    _iterator12.f();
-  }
-  return o;
-}
-function CalendarMergeFields(e, t, r) {
-  if ("string" == typeof e) {
-    var _o8 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"), _o8, [t, r]);
-  }
-  var o = Call(GetMethod(e, "mergeFields"), e, [t, r]);
-  if (!IsObject(o)) throw new TypeError("bad return from calendar.mergeFields()");
-  return o;
-}
-function CalendarDateAdd(e, t, r, o, n) {
-  var a = n;
-  if ("string" == typeof e) {
-    var _n5 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"), _n5, [t, r, o]);
-  }
-  void 0 === a && (a = GetMethod(e, "dateAdd"));
-  var i = fe(a, e, [t, r, o]);
-  if (!IsTemporalDate(i)) throw new TypeError("invalid result");
-  return i;
-}
-function CalendarDateUntil(e, t, r, o, n) {
-  var a = n;
-  if ("string" == typeof e) {
-    var _n6 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"), _n6, [t, r, o]);
-  }
-  void 0 === a && (a = GetMethod(e, "dateUntil"));
-  var i = fe(a, e, [t, r, o]);
-  if (!IsTemporalDuration(i)) throw new TypeError("invalid result");
-  return i;
-}
-function CalendarYear(e, t) {
-  if ("string" == typeof e) {
-    var _r16 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"), _r16, [t]);
-  }
-  var r = Call(GetMethod(e, "year"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar year result must be an integer");
-  if (!IsIntegralNumber(r)) throw new RangeError("calendar year result must be an integer");
-  return r;
-}
-function CalendarMonth(e, t) {
-  if ("string" == typeof e) {
-    var _r17 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"), _r17, [t]);
-  }
-  var r = Call(GetMethod(e, "month"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar month result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar month result must be a positive integer");
-  return r;
-}
-function CalendarMonthCode(e, t) {
-  if ("string" == typeof e) {
-    var _r18 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"), _r18, [t]);
-  }
-  var r = Call(GetMethod(e, "monthCode"), e, [t]);
-  if ("string" != typeof r) throw new TypeError("calendar monthCode result must be a string");
-  return r;
-}
-function CalendarDay(e, t) {
-  if ("string" == typeof e) {
-    var _r19 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), _r19, [t]);
-  }
-  var r = Call(GetMethod(e, "day"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar day result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar day result must be a positive integer");
-  return r;
-}
-function CalendarEra(e, t) {
-  if ("string" == typeof e) {
-    var _r20 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), _r20, [t]);
-  }
-  var r = Call(GetMethod(e, "era"), e, [t]);
-  if (void 0 === r) return r;
-  if ("string" != typeof r) throw new TypeError("calendar era result must be a string or undefined");
-  return r;
-}
-function CalendarEraYear(e, t) {
-  if ("string" == typeof e) {
-    var _r21 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"), _r21, [t]);
-  }
-  var r = Call(GetMethod(e, "eraYear"), e, [t]);
-  if (void 0 === r) return r;
-  if ("number" != typeof r) throw new TypeError("calendar eraYear result must be an integer or undefined");
-  if (!IsIntegralNumber(r)) throw new RangeError("calendar eraYear result must be an integer or undefined");
-  return r;
-}
-function CalendarDayOfWeek(e, t) {
-  if ("string" == typeof e) {
-    var _r22 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"), _r22, [t]);
-  }
-  var r = Call(GetMethod(e, "dayOfWeek"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar dayOfWeek result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar dayOfWeek result must be a positive integer");
-  return r;
-}
-function CalendarDayOfYear(e, t) {
-  if ("string" == typeof e) {
-    var _r23 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"), _r23, [t]);
-  }
-  var r = Call(GetMethod(e, "dayOfYear"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar dayOfYear result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar dayOfYear result must be a positive integer");
-  return r;
-}
-function CalendarWeekOfYear(e, t) {
-  if ("string" == typeof e) {
-    var _r24 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"), _r24, [t]);
-  }
-  var r = Call(GetMethod(e, "weekOfYear"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar weekOfYear result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar weekOfYear result must be a positive integer");
-  return r;
-}
-function CalendarYearOfWeek(e, t) {
-  if ("string" == typeof e) {
-    var _r25 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"), _r25, [t]);
-  }
-  var r = Call(GetMethod(e, "yearOfWeek"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar yearOfWeek result must be an integer");
-  if (!IsIntegralNumber(r)) throw new RangeError("calendar yearOfWeek result must be an integer");
-  return r;
-}
-function CalendarDaysInWeek(e, t) {
-  if ("string" == typeof e) {
-    var _r26 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"), _r26, [t]);
-  }
-  var r = Call(GetMethod(e, "daysInWeek"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar daysInWeek result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar daysInWeek result must be a positive integer");
-  return r;
-}
-function CalendarDaysInMonth(e, t) {
-  if ("string" == typeof e) {
-    var _r27 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"), _r27, [t]);
-  }
-  var r = Call(GetMethod(e, "daysInMonth"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar daysInMonth result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar daysInMonth result must be a positive integer");
-  return r;
-}
-function CalendarDaysInYear(e, t) {
-  if ("string" == typeof e) {
-    var _r28 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"), _r28, [t]);
-  }
-  var r = Call(GetMethod(e, "daysInYear"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar daysInYear result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar daysInYear result must be a positive integer");
-  return r;
-}
-function CalendarMonthsInYear(e, t) {
-  if ("string" == typeof e) {
-    var _r29 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"), _r29, [t]);
-  }
-  var r = Call(GetMethod(e, "monthsInYear"), e, [t]);
-  if ("number" != typeof r) throw new TypeError("calendar monthsInYear result must be a positive integer");
-  if (!IsIntegralNumber(r) || r < 1) throw new RangeError("calendar monthsInYear result must be a positive integer");
-  return r;
-}
-function CalendarInLeapYear(e, t) {
-  if ("string" == typeof e) {
-    var _r30 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"), _r30, [t]);
-  }
-  var r = Call(GetMethod(e, "inLeapYear"), e, [t]);
-  if ("boolean" != typeof r) throw new TypeError("calendar inLeapYear result must be a boolean");
-  return r;
-}
-function ToTemporalCalendarSlotValue(e) {
-  if (IsObject(e)) {
-    if (HasSlot(e, p)) return GetSlot(e, p);
-    if (!function ObjectImplementsTemporalCalendarProtocol(e) {
-      return !!IsTemporalCalendar(e) || "dateAdd" in e && "dateFromFields" in e && "dateUntil" in e && "day" in e && "dayOfWeek" in e && "dayOfYear" in e && "daysInMonth" in e && "daysInWeek" in e && "daysInYear" in e && "fields" in e && "id" in e && "inLeapYear" in e && "mergeFields" in e && "month" in e && "monthCode" in e && "monthDayFromFields" in e && "monthsInYear" in e && "weekOfYear" in e && "year" in e && "yearMonthFromFields" in e && "yearOfWeek" in e;
-    }(e)) throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
-    return e;
-  }
-  var t = ToString(e);
-  if (IsBuiltinCalendar(t)) return ASCIILowercase(t);
-  var r;
-  try {
-    var _ParseISODateTime5 = ParseISODateTime(t);
-    r = _ParseISODateTime5.calendar;
-  } catch (_unused4) {
-    try {
-      var _ParseTemporalYearMon3 = ParseTemporalYearMonthString(t);
-      r = _ParseTemporalYearMon3.calendar;
-    } catch (_unused5) {
-      var _ParseTemporalMonthDa3 = ParseTemporalMonthDayString(t);
-      r = _ParseTemporalMonthDa3.calendar;
-    }
-  }
-  if (r || (r = "iso8601"), !IsBuiltinCalendar(r)) throw new RangeError("invalid calendar identifier ".concat(r));
-  return ASCIILowercase(r);
-}
-function GetTemporalCalendarSlotValueWithISODefault(e) {
-  if (HasSlot(e, p)) return GetSlot(e, p);
-  var t = e.calendar;
-  return void 0 === t ? "iso8601" : ToTemporalCalendarSlotValue(t);
-}
-function ToTemporalCalendarIdentifier(e) {
-  if ("string" == typeof e) return e;
-  var t = e.id;
-  if ("string" != typeof t) throw new TypeError("calendar.id should be a string");
-  return t;
-}
-function ToTemporalCalendarObject(e) {
-  if (IsObject(e)) return e;
-  return new (GetIntrinsic("%Temporal.Calendar%"))(e);
-}
-function CalendarEquals(e, t) {
-  if (e === t) return !0;
-  return ToTemporalCalendarIdentifier(e) === ToTemporalCalendarIdentifier(t);
-}
-function ThrowIfCalendarsNotEqual(e, t, r) {
-  if (e === t) return;
-  var o = ToTemporalCalendarIdentifier(e),
-    n = ToTemporalCalendarIdentifier(t);
-  if (o !== n) throw new RangeError("cannot ".concat(r, " of ").concat(o, " and ").concat(n, " calendars"));
-}
-function ConsolidateCalendars(e, t) {
-  if (e === t) return t;
-  var r = ToTemporalCalendarIdentifier(e),
-    o = ToTemporalCalendarIdentifier(t);
-  if (r === o || "iso8601" === r) return t;
-  if ("iso8601" === o) return e;
-  throw new RangeError("irreconcilable calendars");
-}
-function CalendarDateFromFields(e, t, r, o) {
-  if ("string" == typeof e) {
-    var _o9 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"), _o9, [t, r]);
-  }
-  var n = Call(o !== null && o !== void 0 ? o : GetMethod(e, "dateFromFields"), e, [t, r]);
-  if (!IsTemporalDate(n)) throw new TypeError("invalid result");
-  return n;
+ }
+ var I = 0;
+ "option" === y && (I = ParseTimeZoneOffsetString(h));
+ return CreateTemporalZonedDateTime
+         (InterpretISODateTimeOffset
+           (r, o, n, a, i, s, l, d, m, y, I, c, T, p, f),
+          c,
+          u);
 }
-function CalendarYearMonthFromFields(e, t, r) {
-  if ("string" == typeof e) {
-    var _o10 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"), _o10, [t, r]);
-  }
-  var o = Call(GetMethod(e, "yearMonthFromFields"), e, [t, r]);
-  if (!IsTemporalYearMonth(o)) throw new TypeError("invalid result");
-  return o;
-}
-function CalendarMonthDayFromFields(e, t, r) {
-  if ("string" == typeof e) {
-    var _o11 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
-    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"), _o11, [t, r]);
-  }
-  var o = Call(GetMethod(e, "monthDayFromFields"), e, [t, r]);
-  if (!IsTemporalMonthDay(o)) throw new TypeError("invalid result");
-  return o;
-}
-function ToTemporalTimeZoneSlotValue(e) {
-  if (IsObject(e)) {
-    if (IsTemporalZonedDateTime(e)) return GetSlot(e, g);
-    if (!function ObjectImplementsTemporalTimeZoneProtocol(e) {
-      return !!IsTemporalTimeZone(e) || "getOffsetNanosecondsFor" in e && "getPossibleInstantsFor" in e && "id" in e;
-    }(e)) throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
-    return e;
-  }
-  return ParseTemporalTimeZone(ToString(e));
+function CreateTemporalDateSlots(e, t, r, o, n){
+ RejectISODate(t, r, o),
+ RejectDateRange(t, r, o),
+ N(e),
+ SetSlot(e, i, t),
+ SetSlot(e, s, r),
+ SetSlot(e, l, o),
+ SetSlot(e, p, n),
+ SetSlot(e, f, ! 0);
+}
+function CreateTemporalDate(e, t, r){
+ var
+  o =
+    arguments.length > 3 && arguments[3] !== undefined
+     ? arguments[3]
+     : "iso8601";
+ var n = GetIntrinsic("%Temporal.PlainDate%"), a = Te(n.prototype);
+ return CreateTemporalDateSlots(a, e, t, r, o), a;
+}
+function CreateTemporalDateTimeSlots(e, t, r, o, n, a, f, y, I, S, g){
+ RejectDateTime(t, r, o, n, a, f, y, I, S),
+ RejectDateTimeRange(t, r, o, n, a, f, y, I, S),
+ N(e),
+ SetSlot(e, i, t),
+ SetSlot(e, s, r),
+ SetSlot(e, l, o),
+ SetSlot(e, d, n),
+ SetSlot(e, m, a),
+ SetSlot(e, c, f),
+ SetSlot(e, h, y),
+ SetSlot(e, u, I),
+ SetSlot(e, T, S),
+ SetSlot(e, p, g);
+}
+function CreateTemporalDateTime(e, t, r, o, n, a, i, s, l){
+ var
+  d =
+    arguments.length > 9 && arguments[9] !== undefined
+     ? arguments[9]
+     : "iso8601";
+ var m = GetIntrinsic("%Temporal.PlainDateTime%"), c = Te(m.prototype);
+ return CreateTemporalDateTimeSlots(c, e, t, r, o, n, a, i, s, l, d), c;
+}
+function CreateTemporalMonthDaySlots(e, t, r, o, n){
+ RejectISODate(n, t, r),
+ RejectDateRange(n, t, r),
+ N(e),
+ SetSlot(e, s, t),
+ SetSlot(e, l, r),
+ SetSlot(e, i, n),
+ SetSlot(e, p, o),
+ SetSlot(e, I, ! 0);
+}
+function CreateTemporalMonthDay(e, t){
+ var
+  r =
+    arguments.length > 2 && arguments[2] !== undefined
+     ? arguments[2]
+     : "iso8601";
+ var
+  o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1972;
+ var n = GetIntrinsic("%Temporal.PlainMonthDay%"), a = Te(n.prototype);
+ return CreateTemporalMonthDaySlots(a, e, t, r, o), a;
+}
+function CreateTemporalYearMonthSlots(e, t, r, o, n){
+ RejectISODate(t, r, n),
+ function RejectYearMonthRange(e, t){
+   RejectToRange(e, Fe, Ye),
+   e === Fe ? RejectToRange(t, 4, 12) : e === Ye && RejectToRange(t, 1, 9);
+  }
+  (t, r),
+ N(e),
+ SetSlot(e, i, t),
+ SetSlot(e, s, r),
+ SetSlot(e, l, n),
+ SetSlot(e, p, o),
+ SetSlot(e, y, ! 0);
+}
+function CreateTemporalYearMonth(e, t){
+ var
+  r =
+    arguments.length > 2 && arguments[2] !== undefined
+     ? arguments[2]
+     : "iso8601";
+ var
+  o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
+ var n = GetIntrinsic("%Temporal.PlainYearMonth%"), a = Te(n.prototype);
+ return CreateTemporalYearMonthSlots(a, e, t, r, o), a;
+}
+function CreateTemporalZonedDateTimeSlots(e, t, r, o){
+ ValidateEpochNanoseconds(t),
+ N(e),
+ SetSlot(e, n, t),
+ SetSlot(e, g, r),
+ SetSlot(e, p, o);
+ var a = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
+ SetSlot(e, S, a);
+}
+function CreateTemporalZonedDateTime(e, t){
+ var
+  r =
+    arguments.length > 2 && arguments[2] !== undefined
+     ? arguments[2]
+     : "iso8601";
+ var o = GetIntrinsic("%Temporal.ZonedDateTime%"), n = Te(o.prototype);
+ return CreateTemporalZonedDateTimeSlots(n, e, t, r), n;
+}
+function CalendarFields(e, t){
+ if("string" == typeof e){
+  var _r15 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"), _r15, [t]);
+ }
+ var r = Call(GetMethod(e, "fields"), e, [t]), o = [];
+ var _iterator12 = _createForOfIteratorHelper(r), _step12;
+ try{
+  for(_iterator12.s(); ! (_step12 = _iterator12.n()).done;){
+   var _e17 = _step12.value;
+   if("string" != typeof _e17)
+    throw new TypeError("bad return from calendar.fields()");
+   te.call(o, _e17);
+  }
+ }
+ catch(err){_iterator12.e(err);}
+ finally{_iterator12.f();}
+ return o;
+}
+function CalendarMergeFields(e, t, r){
+ if("string" == typeof e){
+  var _o8 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"),
+           _o8,
+           [t, r]);
+ }
+ var o = Call(GetMethod(e, "mergeFields"), e, [t, r]);
+ if(! IsObject(o))
+  throw new TypeError("bad return from calendar.mergeFields()");
+ return o;
+}
+function CalendarDateAdd(e, t, r, o, n){
+ var a = n;
+ if("string" == typeof e){
+  var _n5 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"),
+           _n5,
+           [t, r, o]);
+ }
+ void 0 === a && (a = GetMethod(e, "dateAdd"));
+ var i = fe(a, e, [t, r, o]);
+ if(! IsTemporalDate(i)) throw new TypeError("invalid result");
+ return i;
+}
+function CalendarDateUntil(e, t, r, o, n){
+ var a = n;
+ if("string" == typeof e){
+  var _n6 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"),
+           _n6,
+           [t, r, o]);
+ }
+ void 0 === a && (a = GetMethod(e, "dateUntil"));
+ var i = fe(a, e, [t, r, o]);
+ if(! IsTemporalDuration(i)) throw new TypeError("invalid result");
+ return i;
+}
+function CalendarYear(e, t){
+ if("string" == typeof e){
+  var _r16 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"), _r16, [t]);
+ }
+ var r = Call(GetMethod(e, "year"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar year result must be an integer");
+ if(! IsIntegralNumber(r))
+  throw new RangeError("calendar year result must be an integer");
+ return r;
+}
+function CalendarMonth(e, t){
+ if("string" == typeof e){
+  var _r17 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"), _r17, [t]);
+ }
+ var r = Call(GetMethod(e, "month"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar month result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new RangeError("calendar month result must be a positive integer");
+ return r;
+}
+function CalendarMonthCode(e, t){
+ if("string" == typeof e){
+  var _r18 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"), _r18, [t]);
+ }
+ var r = Call(GetMethod(e, "monthCode"), e, [t]);
+ if("string" != typeof r)
+  throw new TypeError("calendar monthCode result must be a string");
+ return r;
+}
+function CalendarDay(e, t){
+ if("string" == typeof e){
+  var _r19 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), _r19, [t]);
+ }
+ var r = Call(GetMethod(e, "day"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar day result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new RangeError("calendar day result must be a positive integer");
+ return r;
+}
+function CalendarEra(e, t){
+ if("string" == typeof e){
+  var _r20 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), _r20, [t]);
+ }
+ var r = Call(GetMethod(e, "era"), e, [t]);
+ if(void 0 === r) return r;
+ if("string" != typeof r)
+  throw new TypeError("calendar era result must be a string or undefined");
+ return r;
+}
+function CalendarEraYear(e, t){
+ if("string" == typeof e){
+  var _r21 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"), _r21, [t]);
+ }
+ var r = Call(GetMethod(e, "eraYear"), e, [t]);
+ if(void 0 === r) return r;
+ if("number" != typeof r)
+  throw new
+         TypeError
+         ("calendar eraYear result must be an integer or undefined");
+ if(! IsIntegralNumber(r))
+  throw new
+         RangeError
+         ("calendar eraYear result must be an integer or undefined");
+ return r;
+}
+function CalendarDayOfWeek(e, t){
+ if("string" == typeof e){
+  var _r22 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"), _r22, [t]);
+ }
+ var r = Call(GetMethod(e, "dayOfWeek"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar dayOfWeek result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new RangeError("calendar dayOfWeek result must be a positive integer");
+ return r;
+}
+function CalendarDayOfYear(e, t){
+ if("string" == typeof e){
+  var _r23 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"), _r23, [t]);
+ }
+ var r = Call(GetMethod(e, "dayOfYear"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar dayOfYear result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new RangeError("calendar dayOfYear result must be a positive integer");
+ return r;
+}
+function CalendarWeekOfYear(e, t){
+ if("string" == typeof e){
+  var _r24 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"),
+           _r24,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "weekOfYear"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar weekOfYear result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new
+         RangeError
+         ("calendar weekOfYear result must be a positive integer");
+ return r;
+}
+function CalendarYearOfWeek(e, t){
+ if("string" == typeof e){
+  var _r25 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"),
+           _r25,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "yearOfWeek"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar yearOfWeek result must be an integer");
+ if(! IsIntegralNumber(r))
+  throw new RangeError("calendar yearOfWeek result must be an integer");
+ return r;
+}
+function CalendarDaysInWeek(e, t){
+ if("string" == typeof e){
+  var _r26 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"),
+           _r26,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "daysInWeek"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar daysInWeek result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new
+         RangeError
+         ("calendar daysInWeek result must be a positive integer");
+ return r;
+}
+function CalendarDaysInMonth(e, t){
+ if("string" == typeof e){
+  var _r27 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"),
+           _r27,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "daysInMonth"), e, [t]);
+ if("number" != typeof r)
+  throw new
+         TypeError
+         ("calendar daysInMonth result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new
+         RangeError
+         ("calendar daysInMonth result must be a positive integer");
+ return r;
+}
+function CalendarDaysInYear(e, t){
+ if("string" == typeof e){
+  var _r28 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"),
+           _r28,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "daysInYear"), e, [t]);
+ if("number" != typeof r)
+  throw new TypeError("calendar daysInYear result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new
+         RangeError
+         ("calendar daysInYear result must be a positive integer");
+ return r;
+}
+function CalendarMonthsInYear(e, t){
+ if("string" == typeof e){
+  var _r29 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"),
+           _r29,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "monthsInYear"), e, [t]);
+ if("number" != typeof r)
+  throw new
+         TypeError
+         ("calendar monthsInYear result must be a positive integer");
+ if(! IsIntegralNumber(r) || r < 1)
+  throw new
+         RangeError
+         ("calendar monthsInYear result must be a positive integer");
+ return r;
+}
+function CalendarInLeapYear(e, t){
+ if("string" == typeof e){
+  var _r30 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"),
+           _r30,
+           [t]);
+ }
+ var r = Call(GetMethod(e, "inLeapYear"), e, [t]);
+ if("boolean" != typeof r)
+  throw new TypeError("calendar inLeapYear result must be a boolean");
+ return r;
+}
+function ToTemporalCalendarSlotValue(e){
+ if(IsObject(e)){
+  if(HasSlot(e, p)) return GetSlot(e, p);
+  if
+   (!
+    function ObjectImplementsTemporalCalendarProtocol(e){
+      return !
+             !
+             IsTemporalCalendar(e)
+             ||
+              "dateAdd" in e && "dateFromFields" in e && "dateUntil" in e
+              && "day" in e
+              && "dayOfWeek" in e
+              && "dayOfYear" in e
+              && "daysInMonth" in e
+              && "daysInWeek" in e
+              && "daysInYear" in e
+              && "fields" in e
+              && "id" in e
+              && "inLeapYear" in e
+              && "mergeFields" in e
+              && "month" in e
+              && "monthCode" in e
+              && "monthDayFromFields" in e
+              && "monthsInYear" in e
+              && "weekOfYear" in e
+              && "year" in e
+              && "yearMonthFromFields" in e
+              && "yearOfWeek" in e;
+     }
+     (e))
+   throw new
+          TypeError
+          ("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
+  return e;
+ }
+ var t = ToString(e);
+ if(IsBuiltinCalendar(t)) return ASCIILowercase(t);
+ var r;
+ try{
+  var _ParseISODateTime5 = ParseISODateTime(t);
+  r = _ParseISODateTime5.calendar;
+ }
+ catch(_unused4){
+  try{
+   var _ParseTemporalYearMon3 = ParseTemporalYearMonthString(t);
+   r = _ParseTemporalYearMon3.calendar;
+  }
+  catch(_unused5){
+   var _ParseTemporalMonthDa3 = ParseTemporalMonthDayString(t);
+   r = _ParseTemporalMonthDa3.calendar;
+  }
+ }
+ if(r || (r = "iso8601"), ! IsBuiltinCalendar(r))
+  throw new RangeError("invalid calendar identifier ".concat(r));
+ return ASCIILowercase(r);
+}
+function GetTemporalCalendarSlotValueWithISODefault(e){
+ if(HasSlot(e, p)) return GetSlot(e, p);
+ var t = e.calendar;
+ return void 0 === t ? "iso8601" : ToTemporalCalendarSlotValue(t);
+}
+function ToTemporalCalendarIdentifier(e){
+ if("string" == typeof e) return e;
+ var t = e.id;
+ if("string" != typeof t)
+  throw new TypeError("calendar.id should be a string");
+ return t;
+}
+function ToTemporalCalendarObject(e){
+ if(IsObject(e)) return e;
+ return new (GetIntrinsic("%Temporal.Calendar%"))(e);
+}
+function CalendarEquals(e, t){
+ if(e === t) return ! 0;
+ return ToTemporalCalendarIdentifier(e) === ToTemporalCalendarIdentifier(t);
+}
+function ThrowIfCalendarsNotEqual(e, t, r){
+ if(e === t) return;
+ var o = ToTemporalCalendarIdentifier(e), n = ToTemporalCalendarIdentifier(t);
+ if(o !== n)
+  throw new
+         RangeError
+         ("cannot ".concat(r, " of ").concat(o, " and ").concat
+           (n, " calendars"));
+}
+function ConsolidateCalendars(e, t){
+ if(e === t) return t;
+ var r = ToTemporalCalendarIdentifier(e), o = ToTemporalCalendarIdentifier(t);
+ if(r === o || "iso8601" === r) return t;
+ if("iso8601" === o) return e;
+ throw new RangeError("irreconcilable calendars");
+}
+function CalendarDateFromFields(e, t, r, o){
+ if("string" == typeof e){
+  var _o9 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"),
+           _o9,
+           [t, r]);
+ }
+ var
+  n =
+    Call
+     (o !== null && o !== void 0 ? o : GetMethod(e, "dateFromFields"),
+      e,
+      [t, r]);
+ if(! IsTemporalDate(n)) throw new TypeError("invalid result");
+ return n;
+}
+function CalendarYearMonthFromFields(e, t, r){
+ if("string" == typeof e){
+  var _o10 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"),
+           _o10,
+           [t, r]);
+ }
+ var o = Call(GetMethod(e, "yearMonthFromFields"), e, [t, r]);
+ if(! IsTemporalYearMonth(o)) throw new TypeError("invalid result");
+ return o;
+}
+function CalendarMonthDayFromFields(e, t, r){
+ if("string" == typeof e){
+  var _o11 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
+  return Call
+          (GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"),
+           _o11,
+           [t, r]);
+ }
+ var o = Call(GetMethod(e, "monthDayFromFields"), e, [t, r]);
+ if(! IsTemporalMonthDay(o)) throw new TypeError("invalid result");
+ return o;
+}
+function ToTemporalTimeZoneSlotValue(e){
+ if(IsObject(e)){
+  if(IsTemporalZonedDateTime(e)) return GetSlot(e, g);
+  if
+   (!
+    function ObjectImplementsTemporalTimeZoneProtocol(e){
+      return !
+             !
+             IsTemporalTimeZone(e)
+             ||
+              "getOffsetNanosecondsFor" in e && "getPossibleInstantsFor" in e
+              && "id" in e;
+     }
+     (e))
+   throw new
+          TypeError
+          ("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
+  return e;
+ }
+ return ParseTemporalTimeZone(ToString(e));
 }
-function ToTemporalTimeZoneIdentifier(e) {
-  if ("string" == typeof e) return e;
-  var t = e.id;
-  if ("string" != typeof t) throw new TypeError("timeZone.id should be a string");
-  return t;
-}
-function ToTemporalTimeZoneObject(e) {
-  if (IsObject(e)) return e;
-  return new (GetIntrinsic("%Temporal.TimeZone%"))(e);
-}
-function TimeZoneEquals(e, t) {
-  if (e === t) return !0;
-  return ToTemporalTimeZoneIdentifier(e) === ToTemporalTimeZoneIdentifier(t);
-}
-function TemporalDateTimeToDate(e) {
-  return CreateTemporalDate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p));
-}
-function TemporalDateTimeToTime(e) {
-  return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T));
-}
-function GetOffsetNanosecondsFor(e, t, r) {
-  if ("string" == typeof e) {
-    var _r31 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
-    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"), _r31, [t]);
-  }
-  var o = Call(r !== null && r !== void 0 ? r : GetMethod(e, "getOffsetNanosecondsFor"), e, [t]);
-  if ("number" != typeof o) throw new TypeError("bad return from getOffsetNanosecondsFor");
-  if (!IsIntegralNumber(o) || ae(o) >= 864e11) throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
-  return o;
-}
-function GetOffsetStringFor(e, t) {
-  return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e, t));
-}
-function GetPlainDateTimeFor(e, t, r) {
-  var _BalanceISODateTime2;
-  var o = GetSlot(t, n),
-    a = GetOffsetNanosecondsFor(e, t);
-  var _GetISOPartsFromEpoch = GetISOPartsFromEpoch(o),
-    i = _GetISOPartsFromEpoch.year,
-    s = _GetISOPartsFromEpoch.month,
-    l = _GetISOPartsFromEpoch.day,
-    d = _GetISOPartsFromEpoch.hour,
-    m = _GetISOPartsFromEpoch.minute,
-    c = _GetISOPartsFromEpoch.second,
-    h = _GetISOPartsFromEpoch.millisecond,
-    u = _GetISOPartsFromEpoch.microsecond,
-    T = _GetISOPartsFromEpoch.nanosecond;
-  return (_BalanceISODateTime2 = BalanceISODateTime(i, s, l, d, m, c, h, u, T + a), i = _BalanceISODateTime2.year, s = _BalanceISODateTime2.month, l = _BalanceISODateTime2.day, d = _BalanceISODateTime2.hour, m = _BalanceISODateTime2.minute, c = _BalanceISODateTime2.second, h = _BalanceISODateTime2.millisecond, u = _BalanceISODateTime2.microsecond, T = _BalanceISODateTime2.nanosecond), CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, r);
-}
-function GetInstantFor(e, t, r) {
-  return DisambiguatePossibleInstants(GetPossibleInstantsFor(e, t), e, t, r);
-}
-function DisambiguatePossibleInstants(t, r, o, n) {
-  var a = GetIntrinsic("%Temporal.Instant%"),
-    f = t.length;
-  if (1 === f) return t[0];
-  if (f) switch (n) {
-    case "compatible":
-    case "earlier":
-      return t[0];
-    case "later":
-      return t[f - 1];
-    case "reject":
-      throw new RangeError("multiple instants found");
-  }
-  var y = GetSlot(o, i),
-    I = GetSlot(o, s),
-    S = GetSlot(o, l),
-    g = GetSlot(o, d),
-    w = GetSlot(o, m),
-    D = GetSlot(o, c),
-    G = GetSlot(o, h),
-    v = GetSlot(o, u),
-    C = GetSlot(o, T),
-    O = GetUTCEpochNanoseconds(y, I, S, g, w, D, G, v, C);
-  if (null === O) throw new RangeError("DateTime outside of supported range");
-  var b = new a(O - Ee),
-    E = new a(O + Ee),
-    M = GetOffsetNanosecondsFor(r, b),
-    R = GetOffsetNanosecondsFor(r, E) - M;
-  switch (n) {
-    case "earlier":
-      {
-        var _e18 = GetSlot(o, p),
-          _t19 = GetIntrinsic("%Temporal.PlainDateTime%"),
-          _n7 = AddDateTime(y, I, S, g, w, D, G, v, C, _e18, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R, void 0);
-        return GetPossibleInstantsFor(r, new _t19(_n7.year, _n7.month, _n7.day, _n7.hour, _n7.minute, _n7.second, _n7.millisecond, _n7.microsecond, _n7.nanosecond, _e18))[0];
-      }
+function ToTemporalTimeZoneIdentifier(e){
+ if("string" == typeof e) return e;
+ var t = e.id;
+ if("string" != typeof t)
+  throw new TypeError("timeZone.id should be a string");
+ return t;
+}
+function ToTemporalTimeZoneObject(e){
+ if(IsObject(e)) return e;
+ return new (GetIntrinsic("%Temporal.TimeZone%"))(e);
+}
+function TimeZoneEquals(e, t){
+ if(e === t) return ! 0;
+ return ToTemporalTimeZoneIdentifier(e) === ToTemporalTimeZoneIdentifier(t);
+}
+function TemporalDateTimeToDate(e){
+ return CreateTemporalDate
+         (GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p));
+}
+function TemporalDateTimeToTime(e){
+ return new
+         (GetIntrinsic("%Temporal.PlainTime%"))
+         (GetSlot(e, d),
+          GetSlot(e, m),
+          GetSlot(e, c),
+          GetSlot(e, h),
+          GetSlot(e, u),
+          GetSlot(e, T));
+}
+function GetOffsetNanosecondsFor(e, t, r){
+ if("string" == typeof e){
+  var _r31 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
+  return Call
+          (GetIntrinsic
+            ("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"),
+           _r31,
+           [t]);
+ }
+ var
+  o =
+    Call
+     (r !== null && r !== void 0 ? r : GetMethod(e, "getOffsetNanosecondsFor"),
+      e,
+      [t]);
+ if("number" != typeof o)
+  throw new TypeError("bad return from getOffsetNanosecondsFor");
+ if(! IsIntegralNumber(o) || ae(o) >= 864e11)
+  throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
+ return o;
+}
+function GetOffsetStringFor(e, t){
+ return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e, t));
+}
+function GetPlainDateTimeFor(e, t, r){
+ var _BalanceISODateTime2;
+ var o = GetSlot(t, n), a = GetOffsetNanosecondsFor(e, t);
+ var
+  _GetISOPartsFromEpoch = GetISOPartsFromEpoch(o),
+  i = _GetISOPartsFromEpoch.year,
+  s = _GetISOPartsFromEpoch.month,
+  l = _GetISOPartsFromEpoch.day,
+  d = _GetISOPartsFromEpoch.hour,
+  m = _GetISOPartsFromEpoch.minute,
+  c = _GetISOPartsFromEpoch.second,
+  h = _GetISOPartsFromEpoch.millisecond,
+  u = _GetISOPartsFromEpoch.microsecond,
+  T = _GetISOPartsFromEpoch.nanosecond;
+ return _BalanceISODateTime2 =
+         BalanceISODateTime(i, s, l, d, m, c, h, u, T + a),
+        i = _BalanceISODateTime2.year,
+        s = _BalanceISODateTime2.month,
+        l = _BalanceISODateTime2.day,
+        d = _BalanceISODateTime2.hour,
+        m = _BalanceISODateTime2.minute,
+        c = _BalanceISODateTime2.second,
+        h = _BalanceISODateTime2.millisecond,
+        u = _BalanceISODateTime2.microsecond,
+        T = _BalanceISODateTime2.nanosecond,
+        CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, r);
+}
+function GetInstantFor(e, t, r){
+ return DisambiguatePossibleInstants(GetPossibleInstantsFor(e, t), e, t, r);
+}
+function DisambiguatePossibleInstants(t, r, o, n){
+ var a = GetIntrinsic("%Temporal.Instant%"), f = t.length;
+ if(1 === f) return t[0];
+ if(f)
+  switch(n){
     case "compatible":
+    case "earlier": return t[0];
     case "later":
-      {
-        var _e19 = GetSlot(o, p),
-          _t20 = GetIntrinsic("%Temporal.PlainDateTime%"),
-          _n8 = AddDateTime(y, I, S, g, w, D, G, v, C, _e19, 0, 0, 0, 0, 0, 0, 0, 0, 0, R, void 0),
-          _a4 = GetPossibleInstantsFor(r, new _t20(_n8.year, _n8.month, _n8.day, _n8.hour, _n8.minute, _n8.second, _n8.millisecond, _n8.microsecond, _n8.nanosecond, _e19));
-        return _a4[_a4.length - 1];
-      }
+     return t[f - 1];
     case "reject":
-      throw new RangeError("no such instant found");
-  }
-}
-function GetPossibleInstantsFor(e, t, r) {
-  if ("string" == typeof e) {
-    var _r32 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
-    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"), _r32, [t]);
-  }
-  var o = Call(r !== null && r !== void 0 ? r : GetMethod(e, "getPossibleInstantsFor"), e, [t]),
-    n = [];
-  var _iterator13 = _createForOfIteratorHelper(o),
-    _step13;
-  try {
-    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
-      var _e20 = _step13.value;
-      if (!IsTemporalInstant(_e20)) throw new TypeError("bad return from getPossibleInstantsFor");
-      te.call(n, _e20);
-    }
-  } catch (err) {
-    _iterator13.e(err);
-  } finally {
-    _iterator13.f();
-  }
-  return n;
-}
-function ISOYearString(e) {
-  var t;
-  if (e < 0 || e > 9999) {
-    t = (e < 0 ? "-" : "+") + "000000".concat(ae(e)).slice(-6);
-  } else t = "0000".concat(e).slice(-4);
-  return t;
-}
-function ISODateTimePartString(e) {
-  return "00".concat(e).slice(-2);
-}
-function FormatSecondsStringPart(e, t, r, o, n) {
-  if ("minute" === n) return "";
-  var a = ":".concat(ISODateTimePartString(e));
-  var i,
-    s = 1e6 * t + 1e3 * r + o;
-  if ("auto" === n) {
-    if (0 === s) return a;
-    for (i = "".concat(s).padStart(9, "0"); "0" === i[i.length - 1];) i = i.slice(0, -1);
-  } else {
-    if (0 === n) return a;
-    i = "".concat(s).padStart(9, "0").slice(0, n);
-  }
-  return "".concat(a, ".").concat(i);
-}
-function TemporalInstantToString(e, t, r) {
-  var o = t;
-  void 0 === o && (o = "UTC");
-  var n = GetPlainDateTimeFor(o, e, "iso8601"),
-    a = ISOYearString(GetSlot(n, i)),
-    p = ISODateTimePartString(GetSlot(n, s)),
-    f = ISODateTimePartString(GetSlot(n, l)),
-    y = ISODateTimePartString(GetSlot(n, d)),
-    I = ISODateTimePartString(GetSlot(n, m)),
-    S = FormatSecondsStringPart(GetSlot(n, c), GetSlot(n, h), GetSlot(n, u), GetSlot(n, T), r);
-  var g = "Z";
-  if (void 0 !== t) {
-    g = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o, e));
-  }
-  return "".concat(a, "-").concat(p, "-").concat(f, "T").concat(y, ":").concat(I).concat(S).concat(g);
-}
-function TemporalDurationToString(t) {
-  var _divmod, _divmod2, _divmod3;
-  var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
-  var o = arguments.length > 2 ? arguments[2] : undefined;
-  function formatNumber(t) {
-    return t <= ue ? t.toString(10) : BigInt(t).toString(10);
+     throw new RangeError("multiple instants found");
   }
-  var n = GetSlot(t, w),
-    a = GetSlot(t, D),
-    i = GetSlot(t, G),
-    s = GetSlot(t, v),
-    l = GetSlot(t, C),
-    d = GetSlot(t, O);
-  var m = GetSlot(t, b),
-    c = GetSlot(t, E),
-    h = GetSlot(t, M),
-    u = GetSlot(t, R);
-  var T = DurationSign(n, a, i, s, l, d, m, c, h, u);
-  if (o) {
-    var _e21 = o.unit,
-      _t21 = o.increment,
-      _r33 = o.roundingMode;
-    var _RoundDuration = RoundDuration(0, 0, 0, 0, 0, 0, m, c, h, u, _t21, _e21, _r33);
-    m = _RoundDuration.seconds;
-    c = _RoundDuration.milliseconds;
-    h = _RoundDuration.microseconds;
-    u = _RoundDuration.nanoseconds;
-  }
-  var p = [];
-  n && p.push("".concat(formatNumber(ae(n)), "Y")), a && p.push("".concat(formatNumber(ae(a)), "M")), i && p.push("".concat(formatNumber(ae(i)), "W")), s && p.push("".concat(formatNumber(ae(s)), "D"));
-  var f = [];
-  l && f.push("".concat(formatNumber(ae(l)), "H")), d && f.push("".concat(formatNumber(ae(d)), "M"));
-  var y = [];
-  var I,
-    S,
-    g,
-    F,
-    Y = TotalDurationNanoseconds(0, 0, 0, m, c, h, u, 0);
-  (_divmod = divmod(Y, De), Y = _divmod.quotient, I = _divmod.remainder), (_divmod2 = divmod(Y, De), Y = _divmod2.quotient, S = _divmod2.remainder), (_divmod3 = divmod(Y, De), F = _divmod3.quotient, g = _divmod3.remainder);
-  var P = 1e6 * ae(Number(g)) + 1e3 * ae(Number(S)) + ae(Number(I));
-  var Z;
-  if ("auto" === r) {
-    if (0 !== P) for (Z = "".concat(P).padStart(9, "0"); "0" === Z[Z.length - 1];) Z = Z.slice(0, -1);
-  } else 0 !== r && (Z = "".concat(P).padStart(9, "0").slice(0, r));
-  return Z && y.unshift(".", Z), F === Ie && !y.length && "auto" === r || y.unshift(abs(F).toString()), y.length && f.push("".concat(y.join(""), "S")), f.length && f.unshift("T"), p.length || f.length ? "".concat(T < 0 ? "-" : "", "P").concat(p.join("")).concat(f.join("")) : "PT0S";
-}
-function TemporalDateToString(e) {
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
-  return "".concat(ISOYearString(GetSlot(e, i)), "-").concat(ISODateTimePartString(GetSlot(e, s)), "-").concat(ISODateTimePartString(GetSlot(e, l))).concat(MaybeFormatCalendarAnnotation(GetSlot(e, p), t));
-}
-function TemporalDateTimeToString(e, t) {
-  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "auto";
-  var o = arguments.length > 3 ? arguments[3] : undefined;
-  var n = GetSlot(e, i),
-    a = GetSlot(e, s),
-    f = GetSlot(e, l),
-    y = GetSlot(e, d),
-    I = GetSlot(e, m),
-    S = GetSlot(e, c),
-    g = GetSlot(e, h),
-    w = GetSlot(e, u),
-    D = GetSlot(e, T);
-  if (o) {
-    var _e22 = o.unit,
-      _t22 = o.increment,
-      _r34 = o.roundingMode;
-    var _RoundISODateTime = RoundISODateTime(n, a, f, y, I, S, g, w, D, _t22, _e22, _r34);
-    n = _RoundISODateTime.year;
-    a = _RoundISODateTime.month;
-    f = _RoundISODateTime.day;
-    y = _RoundISODateTime.hour;
-    I = _RoundISODateTime.minute;
-    S = _RoundISODateTime.second;
-    g = _RoundISODateTime.millisecond;
-    w = _RoundISODateTime.microsecond;
-    D = _RoundISODateTime.nanosecond;
-  }
-  return "".concat(ISOYearString(n), "-").concat(ISODateTimePartString(a), "-").concat(ISODateTimePartString(f), "T").concat(ISODateTimePartString(y), ":").concat(ISODateTimePartString(I)).concat(FormatSecondsStringPart(S, g, w, D, t)).concat(MaybeFormatCalendarAnnotation(GetSlot(e, p), r));
-}
-function TemporalMonthDayToString(e) {
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
-  var r = "".concat(ISODateTimePartString(GetSlot(e, s)), "-").concat(ISODateTimePartString(GetSlot(e, l)));
-  var o = ToTemporalCalendarIdentifier(GetSlot(e, p));
-  if ("always" === t || "critical" === t || "iso8601" !== o) {
-    r = "".concat(ISOYearString(GetSlot(e, i)), "-").concat(r);
-  }
-  var n = FormatCalendarAnnotation(o, t);
-  return n && (r += n), r;
-}
-function TemporalYearMonthToString(e) {
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
-  var r = "".concat(ISOYearString(GetSlot(e, i)), "-").concat(ISODateTimePartString(GetSlot(e, s)));
-  var o = ToTemporalCalendarIdentifier(GetSlot(e, p));
-  if ("always" === t || "critical" === t || "iso8601" !== o) {
-    r += "-".concat(ISODateTimePartString(GetSlot(e, l)));
-  }
-  var n = FormatCalendarAnnotation(o, t);
-  return n && (r += n), r;
-}
-function TemporalZonedDateTimeToString(e, t) {
-  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "auto";
-  var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "auto";
-  var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "auto";
-  var f = arguments.length > 5 ? arguments[5] : undefined;
-  var y = GetSlot(e, S);
-  if (f) {
-    var _t23 = f.unit,
-      _r35 = f.increment,
-      _o12 = f.roundingMode,
-      _a5 = RoundInstant(GetSlot(e, n), _r35, _t23, _o12);
-    y = new (GetIntrinsic("%Temporal.Instant%"))(_a5);
-  }
-  var I = GetSlot(e, g),
-    w = GetPlainDateTimeFor(I, y, "iso8601");
-  var D = "".concat(ISOYearString(GetSlot(w, i)), "-").concat(ISODateTimePartString(GetSlot(w, s)), "-").concat(ISODateTimePartString(GetSlot(w, l)), "T").concat(ISODateTimePartString(GetSlot(w, d)), ":").concat(ISODateTimePartString(GetSlot(w, m))).concat(FormatSecondsStringPart(GetSlot(w, c), GetSlot(w, h), GetSlot(w, u), GetSlot(w, T), t));
-  if ("never" !== a) {
-    D += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I, y));
-  }
-  if ("never" !== o) {
-    D += "[".concat("critical" === o ? "!" : "").concat(ToTemporalTimeZoneIdentifier(I), "]");
-  }
-  return D += MaybeFormatCalendarAnnotation(GetSlot(e, p), r), D;
-}
-function IsTimeZoneOffsetString(e) {
-  return ze.test(he(e));
-}
-function ParseTimeZoneOffsetString(e) {
-  var t = ze.exec(he(e));
-  if (!t) throw new RangeError("invalid time zone offset: ".concat(e));
-  return ("-" === t[1] || "−" === t[1] ? -1 : 1) * (1e9 * (60 * (60 * +t[2] + +(t[3] || 0)) + +(t[4] || 0)) + +((t[5] || 0) + "000000000").slice(0, 9));
-}
-function GetCanonicalTimeZoneIdentifier(e) {
-  if (IsTimeZoneOffsetString(e)) {
-    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e));
-  }
-  return getIntlDateTimeFormatEnUsForTimeZone(he(e)).resolvedOptions().timeZone;
-}
-function GetNamedTimeZoneOffsetNanoseconds(t, r) {
-  var _GetNamedTimeZoneDate = GetNamedTimeZoneDateTimeParts(t, r),
-    o = _GetNamedTimeZoneDate.year,
-    n = _GetNamedTimeZoneDate.month,
-    a = _GetNamedTimeZoneDate.day,
-    i = _GetNamedTimeZoneDate.hour,
-    s = _GetNamedTimeZoneDate.minute,
-    l = _GetNamedTimeZoneDate.second,
-    d = _GetNamedTimeZoneDate.millisecond,
-    m = _GetNamedTimeZoneDate.microsecond,
-    c = _GetNamedTimeZoneDate.nanosecond,
-    h = o % 400,
-    u = (o - h) / 400,
-    T = 146097n * Ee,
-    p = GetUTCEpochNanoseconds(h, n, a, i, s, l, d, m, c),
-    f = p + T * BigInt(u);
-  return Number(f - r);
-}
-function FormatTimeZoneOffsetString(e) {
-  var t = e < 0 ? "-" : "+",
-    r = ae(e),
-    o = r % 1e9,
-    n = ie(r / 1e9) % 60,
-    a = ie(r / 6e10) % 60,
-    i = ISODateTimePartString(ie(r / 36e11)),
-    s = ISODateTimePartString(a),
-    l = ISODateTimePartString(n);
-  var d = "";
-  if (o) {
-    var _e23 = "".concat(o).padStart(9, "0");
-    for (; "0" === _e23[_e23.length - 1];) _e23 = _e23.slice(0, -1);
-    d = ":".concat(l, ".").concat(_e23);
-  } else n && (d = ":".concat(l));
-  return "".concat(t).concat(i, ":").concat(s).concat(d);
-}
-function FormatISOTimeZoneOffsetString(t) {
-  var r = Number(RoundNumberToIncrement(BigInt(t), be, "halfExpand"));
-  var o = r < 0 ? "-" : "+";
-  r = ae(r);
-  var n = r / 6e10 % 60;
-  return "".concat(o).concat(ISODateTimePartString(ie(r / 36e11)), ":").concat(ISODateTimePartString(n));
-}
-function GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d) {
-  var m = new Date();
-  m.setUTCHours(n, a, i, s), m.setUTCFullYear(t, r - 1, o);
-  var c = m.getTime();
-  if (de(c)) return null;
-  var h = BigInt(c) * Ge;
-  return h = h + BigInt(l) * De, h = h + BigInt(d), h < Me || h > Re ? null : h;
-}
-function GetISOPartsFromEpoch(t) {
-  var _divmod4 = divmod(t, Ge),
-    r = _divmod4.quotient,
-    o = _divmod4.remainder;
-  var n = Number(r),
-    a = Number(o);
-  a < 0 && (a += 1e6, n -= 1);
-  var i = ie(a / 1e3) % 1e3,
-    s = a % 1e3,
-    l = new Date(n);
-  return {
-    epochMilliseconds: n,
-    year: l.getUTCFullYear(),
-    month: l.getUTCMonth() + 1,
-    day: l.getUTCDate(),
-    hour: l.getUTCHours(),
-    minute: l.getUTCMinutes(),
-    second: l.getUTCSeconds(),
-    millisecond: l.getUTCMilliseconds(),
-    microsecond: i,
-    nanosecond: s
-  };
-}
-function GetNamedTimeZoneDateTimeParts(e, t) {
-  var _GetISOPartsFromEpoch2 = GetISOPartsFromEpoch(t),
-    r = _GetISOPartsFromEpoch2.epochMilliseconds,
-    o = _GetISOPartsFromEpoch2.millisecond,
-    n = _GetISOPartsFromEpoch2.microsecond,
-    a = _GetISOPartsFromEpoch2.nanosecond,
-    _GetFormatterParts = function GetFormatterParts(e, t) {
+ var
+  y = GetSlot(o, i),
+  I = GetSlot(o, s),
+  S = GetSlot(o, l),
+  g = GetSlot(o, d),
+  w = GetSlot(o, m),
+  D = GetSlot(o, c),
+  G = GetSlot(o, h),
+  v = GetSlot(o, u),
+  C = GetSlot(o, T),
+  O = GetUTCEpochNanoseconds(y, I, S, g, w, D, G, v, C);
+ if(null === O) throw new RangeError("DateTime outside of supported range");
+ var
+  b = new a(O - Ee),
+  E = new a(O + Ee),
+  M = GetOffsetNanosecondsFor(r, b),
+  R = GetOffsetNanosecondsFor(r, E) - M;
+ switch(n){
+   case "earlier":
+    {
+     var
+      _e18 = GetSlot(o, p),
+      _t19 = GetIntrinsic("%Temporal.PlainDateTime%"),
+      _n7 =
+        AddDateTime
+         (y,
+          I,
+          S,
+          g,
+          w,
+          D,
+          G,
+          v,
+          C,
+          _e18,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          - R,
+          void 0);
+     return GetPossibleInstantsFor
+              (r,
+               new
+                _t19
+                (_n7.year,
+                 _n7.month,
+                 _n7.day,
+                 _n7.hour,
+                 _n7.minute,
+                 _n7.second,
+                 _n7.millisecond,
+                 _n7.microsecond,
+                 _n7.nanosecond,
+                 _e18))
+             [0];
+    }
+   case "compatible":
+   case "later":
+    {
+     var
+      _e19 = GetSlot(o, p),
+      _t20 = GetIntrinsic("%Temporal.PlainDateTime%"),
+      _n8 =
+        AddDateTime
+         (y,
+          I,
+          S,
+          g,
+          w,
+          D,
+          G,
+          v,
+          C,
+          _e19,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          R,
+          void 0),
+      _a4 =
+        GetPossibleInstantsFor
+         (r,
+          new
+           _t20
+           (_n8.year,
+            _n8.month,
+            _n8.day,
+            _n8.hour,
+            _n8.minute,
+            _n8.second,
+            _n8.millisecond,
+            _n8.microsecond,
+            _n8.nanosecond,
+            _e19));
+     return _a4[_a4.length - 1];
+    }
+   case "reject":
+    throw new RangeError("no such instant found");
+ }
+}
+function GetPossibleInstantsFor(e, t, r){
+ if("string" == typeof e){
+  var _r32 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
+  return Call
+          (GetIntrinsic
+            ("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"),
+           _r32,
+           [t]);
+ }
+ var
+  o =
+    Call
+     (r !== null && r !== void 0 ? r : GetMethod(e, "getPossibleInstantsFor"),
+      e,
+      [t]),
+  n = [];
+ var _iterator13 = _createForOfIteratorHelper(o), _step13;
+ try{
+  for(_iterator13.s(); ! (_step13 = _iterator13.n()).done;){
+   var _e20 = _step13.value;
+   if(! IsTemporalInstant(_e20))
+    throw new TypeError("bad return from getPossibleInstantsFor");
+   te.call(n, _e20);
+  }
+ }
+ catch(err){_iterator13.e(err);}
+ finally{_iterator13.f();}
+ return n;
+}
+function ISOYearString(e){
+ var t;
+ if(e < 0 || e > 9999){
+  t = (e < 0 ? "-" : "+") + "000000".concat(ae(e)).slice(- 6);
+ }
+ else
+  t = "0000".concat(e).slice(- 4);
+ return t;
+}
+function ISODateTimePartString(e){return "00".concat(e).slice(- 2);}
+function FormatSecondsStringPart(e, t, r, o, n){
+ if("minute" === n) return "";
+ var a = ":".concat(ISODateTimePartString(e));
+ var i, s = 1e6 * t + 1e3 * r + o;
+ if("auto" === n){
+  if(0 === s) return a;
+  for(i = "".concat(s).padStart(9, "0"); "0" === i[i.length - 1];)
+   i = i.slice(0, - 1);
+ }
+ else{if(0 === n) return a; i = "".concat(s).padStart(9, "0").slice(0, n);}
+ return "".concat(a, ".").concat(i);
+}
+function TemporalInstantToString(e, t, r){
+ var o = t;
+ void 0 === o && (o = "UTC");
+ var
+  n = GetPlainDateTimeFor(o, e, "iso8601"),
+  a = ISOYearString(GetSlot(n, i)),
+  p = ISODateTimePartString(GetSlot(n, s)),
+  f = ISODateTimePartString(GetSlot(n, l)),
+  y = ISODateTimePartString(GetSlot(n, d)),
+  I = ISODateTimePartString(GetSlot(n, m)),
+  S =
+    FormatSecondsStringPart
+     (GetSlot(n, c), GetSlot(n, h), GetSlot(n, u), GetSlot(n, T), r);
+ var g = "Z";
+ if(void 0 !== t){
+  g = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o, e));
+ }
+ return "".concat(a, "-").concat(p, "-").concat(f, "T").concat(y, ":").concat
+           (I).concat
+          (S).concat
+         (g);
+}
+function TemporalDurationToString(t){
+ var _divmod, _divmod2, _divmod3;
+ var
+  r =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
+ var o = arguments.length > 2 ? arguments[2] : undefined;
+ function formatNumber(t){
+  return t <= ue ? t.toString(10) : BigInt(t).toString(10);
+ }
+ var
+  n = GetSlot(t, w),
+  a = GetSlot(t, D),
+  i = GetSlot(t, G),
+  s = GetSlot(t, v),
+  l = GetSlot(t, C),
+  d = GetSlot(t, O);
+ var
+  m = GetSlot(t, b),
+  c = GetSlot(t, E),
+  h = GetSlot(t, M),
+  u = GetSlot(t, R);
+ var T = DurationSign(n, a, i, s, l, d, m, c, h, u);
+ if(o){
+  var _e21 = o.unit, _t21 = o.increment, _r33 = o.roundingMode;
+  var
+   _RoundDuration =
+     RoundDuration(0, 0, 0, 0, 0, 0, m, c, h, u, _t21, _e21, _r33);
+  m = _RoundDuration.seconds;
+  c = _RoundDuration.milliseconds;
+  h = _RoundDuration.microseconds;
+  u = _RoundDuration.nanoseconds;
+ }
+ var p = [];
+ n && p.push("".concat(formatNumber(ae(n)), "Y")),
+ a && p.push("".concat(formatNumber(ae(a)), "M")),
+ i && p.push("".concat(formatNumber(ae(i)), "W")),
+ s && p.push("".concat(formatNumber(ae(s)), "D"));
+ var f = [];
+ l && f.push("".concat(formatNumber(ae(l)), "H")),
+ d && f.push("".concat(formatNumber(ae(d)), "M"));
+ var y = [];
+ var I, S, g, F, Y = TotalDurationNanoseconds(0, 0, 0, m, c, h, u, 0);
+ _divmod = divmod(Y, De),
+ Y = _divmod.quotient,
+ I = _divmod.remainder,
+ _divmod2 = divmod(Y, De),
+ Y = _divmod2.quotient,
+ S = _divmod2.remainder,
+ _divmod3 = divmod(Y, De),
+ F = _divmod3.quotient,
+ g = _divmod3.remainder;
+ var P = 1e6 * ae(Number(g)) + 1e3 * ae(Number(S)) + ae(Number(I));
+ var Z;
+ if("auto" === r){
+  if(0 !== P)
+   for(Z = "".concat(P).padStart(9, "0"); "0" === Z[Z.length - 1];)
+    Z = Z.slice(0, - 1);
+ }
+ else
+  0 !== r && (Z = "".concat(P).padStart(9, "0").slice(0, r));
+ return Z && y.unshift(".", Z),
+        F === Ie && ! y.length && "auto" === r || y.unshift(abs(F).toString()),
+        y.length && f.push("".concat(y.join(""), "S")),
+        f.length && f.unshift("T"),
+        p.length || f.length
+         ? "".concat
+             (T < 0 ? "-" : "", "P").concat
+            (p.join("")).concat
+           (f.join(""))
+         : "PT0S";
+}
+function TemporalDateToString(e){
+ var
+  t =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
+ return "".concat(ISOYearString(GetSlot(e, i)), "-").concat
+           (ISODateTimePartString(GetSlot(e, s)), "-").concat
+          (ISODateTimePartString(GetSlot(e, l))).concat
+         (MaybeFormatCalendarAnnotation(GetSlot(e, p), t));
+}
+function TemporalDateTimeToString(e, t){
+ var
+  r =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "auto";
+ var o = arguments.length > 3 ? arguments[3] : undefined;
+ var
+  n = GetSlot(e, i),
+  a = GetSlot(e, s),
+  f = GetSlot(e, l),
+  y = GetSlot(e, d),
+  I = GetSlot(e, m),
+  S = GetSlot(e, c),
+  g = GetSlot(e, h),
+  w = GetSlot(e, u),
+  D = GetSlot(e, T);
+ if(o){
+  var _e22 = o.unit, _t22 = o.increment, _r34 = o.roundingMode;
+  var
+   _RoundISODateTime =
+     RoundISODateTime(n, a, f, y, I, S, g, w, D, _t22, _e22, _r34);
+  n = _RoundISODateTime.year;
+  a = _RoundISODateTime.month;
+  f = _RoundISODateTime.day;
+  y = _RoundISODateTime.hour;
+  I = _RoundISODateTime.minute;
+  S = _RoundISODateTime.second;
+  g = _RoundISODateTime.millisecond;
+  w = _RoundISODateTime.microsecond;
+  D = _RoundISODateTime.nanosecond;
+ }
+ return "".concat(ISOYearString(n), "-").concat(ISODateTimePartString(a), "-").concat
+             (ISODateTimePartString(f), "T").concat
+            (ISODateTimePartString(y), ":").concat
+           (ISODateTimePartString(I)).concat
+          (FormatSecondsStringPart(S, g, w, D, t)).concat
+         (MaybeFormatCalendarAnnotation(GetSlot(e, p), r));
+}
+function TemporalMonthDayToString(e){
+ var
+  t =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
+ var
+  r =
+    "".concat(ISODateTimePartString(GetSlot(e, s)), "-").concat
+     (ISODateTimePartString(GetSlot(e, l)));
+ var o = ToTemporalCalendarIdentifier(GetSlot(e, p));
+ if("always" === t || "critical" === t || "iso8601" !== o){
+  r = "".concat(ISOYearString(GetSlot(e, i)), "-").concat(r);
+ }
+ var n = FormatCalendarAnnotation(o, t);
+ return n && (r += n), r;
+}
+function TemporalYearMonthToString(e){
+ var
+  t =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";
+ var
+  r =
+    "".concat(ISOYearString(GetSlot(e, i)), "-").concat
+     (ISODateTimePartString(GetSlot(e, s)));
+ var o = ToTemporalCalendarIdentifier(GetSlot(e, p));
+ if("always" === t || "critical" === t || "iso8601" !== o){r += "-".concat(ISODateTimePartString(GetSlot(e, l)));}
+ var n = FormatCalendarAnnotation(o, t);
+ return n && (r += n), r;
+}
+function TemporalZonedDateTimeToString(e, t){
+ var
+  r =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "auto";
+ var
+  o =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "auto";
+ var
+  a =
+    arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "auto";
+ var f = arguments.length > 5 ? arguments[5] : undefined;
+ var y = GetSlot(e, S);
+ if(f){
+  var
+   _t23 = f.unit,
+   _r35 = f.increment,
+   _o12 = f.roundingMode,
+   _a5 = RoundInstant(GetSlot(e, n), _r35, _t23, _o12);
+  y = new (GetIntrinsic("%Temporal.Instant%"))(_a5);
+ }
+ var I = GetSlot(e, g), w = GetPlainDateTimeFor(I, y, "iso8601");
+ var
+  D =
+    "".concat(ISOYearString(GetSlot(w, i)), "-").concat
+         (ISODateTimePartString(GetSlot(w, s)), "-").concat
+        (ISODateTimePartString(GetSlot(w, l)), "T").concat
+       (ISODateTimePartString(GetSlot(w, d)), ":").concat
+      (ISODateTimePartString(GetSlot(w, m))).concat
+     (FormatSecondsStringPart
+       (GetSlot(w, c), GetSlot(w, h), GetSlot(w, u), GetSlot(w, T), t));
+ if("never" !== a){
+  D += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I, y));
+ }
+ if("never" !== o){
+  D +=
+   "[".concat("critical" === o ? "!" : "").concat
+    (ToTemporalTimeZoneIdentifier(I), "]");
+ }
+ return D += MaybeFormatCalendarAnnotation(GetSlot(e, p), r), D;
+}
+function IsTimeZoneOffsetString(e){return ze.test(he(e));}
+function ParseTimeZoneOffsetString(e){
+ var t = ze.exec(he(e));
+ if(! t) throw new RangeError("invalid time zone offset: ".concat(e));
+ return ("-" === t[1] || "−" === t[1] ? - 1 : 1)
+        *
+         (1e9 * (60 * (60 * + t[2] + + (t[3] || 0)) + + (t[4] || 0))
+         + + ((t[5] || 0) + "000000000").slice(0, 9));
+}
+function GetCanonicalTimeZoneIdentifier(e){
+ if(IsTimeZoneOffsetString(e)){
+  return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e));
+ }
+ return getIntlDateTimeFormatEnUsForTimeZone(he(e)).resolvedOptions().timeZone;
+}
+function GetNamedTimeZoneOffsetNanoseconds(t, r){
+ var
+  _GetNamedTimeZoneDate = GetNamedTimeZoneDateTimeParts(t, r),
+  o = _GetNamedTimeZoneDate.year,
+  n = _GetNamedTimeZoneDate.month,
+  a = _GetNamedTimeZoneDate.day,
+  i = _GetNamedTimeZoneDate.hour,
+  s = _GetNamedTimeZoneDate.minute,
+  l = _GetNamedTimeZoneDate.second,
+  d = _GetNamedTimeZoneDate.millisecond,
+  m = _GetNamedTimeZoneDate.microsecond,
+  c = _GetNamedTimeZoneDate.nanosecond,
+  h = o % 400,
+  u = (o - h) / 400,
+  T = BigInt("146097") * Ee,
+  p = GetUTCEpochNanoseconds(h, n, a, i, s, l, d, m, c),
+  f = p + T * BigInt(u);
+ return Number(f - r);
+}
+function FormatTimeZoneOffsetString(e){
+ var
+  t = e < 0 ? "-" : "+",
+  r = ae(e),
+  o = r % 1e9,
+  n = ie(r / 1e9) % 60,
+  a = ie(r / 6e10) % 60,
+  i = ISODateTimePartString(ie(r / 36e11)),
+  s = ISODateTimePartString(a),
+  l = ISODateTimePartString(n);
+ var d = "";
+ if(o){
+  var _e23 = "".concat(o).padStart(9, "0");
+  for(; "0" === _e23[_e23.length - 1];) _e23 = _e23.slice(0, - 1);
+  d = ":".concat(l, ".").concat(_e23);
+ }
+ else
+  n && (d = ":".concat(l));
+ return "".concat(t).concat(i, ":").concat(s).concat(d);
+}
+function FormatISOTimeZoneOffsetString(t){
+ var r = Number(RoundNumberToIncrement(BigInt(t), be, "halfExpand"));
+ var o = r < 0 ? "-" : "+";
+ r = ae(r);
+ var n = r / 6e10 % 60;
+ return "".concat(o).concat(ISODateTimePartString(ie(r / 36e11)), ":").concat
+         (ISODateTimePartString(n));
+}
+function GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d){
+ var m = new Date();
+ m.setUTCHours(n, a, i, s), m.setUTCFullYear(t, r - 1, o);
+ var c = m.getTime();
+ if(de(c)) return null;
+ var h = BigInt(c) * Ge;
+ return h = h + BigInt(l) * De,
+        h = h + BigInt(d),
+        h < Me || h > Re ? null : h;
+}
+function GetISOPartsFromEpoch(t){
+ var _divmod4 = divmod(t, Ge), r = _divmod4.quotient, o = _divmod4.remainder;
+ var n = Number(r), a = Number(o);
+ a < 0 && (a += 1e6, n -= 1);
+ var i = ie(a / 1e3) % 1e3, s = a % 1e3, l = new Date(n);
+ return {epochMilliseconds: n,
+         year: l.getUTCFullYear(),
+         month: l.getUTCMonth() + 1,
+         day: l.getUTCDate(),
+         hour: l.getUTCHours(),
+         minute: l.getUTCMinutes(),
+         second: l.getUTCSeconds(),
+         millisecond: l.getUTCMilliseconds(),
+         microsecond: i,
+         nanosecond: s};
+}
+function GetNamedTimeZoneDateTimeParts(e, t){
+ var
+  _GetISOPartsFromEpoch2 = GetISOPartsFromEpoch(t),
+  r = _GetISOPartsFromEpoch2.epochMilliseconds,
+  o = _GetISOPartsFromEpoch2.millisecond,
+  n = _GetISOPartsFromEpoch2.microsecond,
+  a = _GetISOPartsFromEpoch2.nanosecond,
+  _GetFormatterParts =
+    function GetFormatterParts(e, t){
       var r = getIntlDateTimeFormatEnUsForTimeZone(e).format(new Date(t));
-      return function parseFromEnUsFormat(e) {
-        var t = e.split(/[^\w]+/);
-        if (7 !== t.length) throw new RangeError("expected 7 parts in \"".concat(e));
-        var r = +t[0],
-          o = +t[1];
-        var n = +t[2];
-        var a = t[3].toUpperCase();
-        if ("B" === a || "BC" === a) n = 1 - n;else if ("A" !== a && "AD" !== a) throw new RangeError("Unknown era ".concat(a, " in \"").concat(e));
-        var i = +t[4];
-        24 === i && (i = 0);
-        var s = +t[5],
-          l = +t[6];
-        if (!(me(n) && me(r) && me(o) && me(i) && me(s) && me(l))) throw new RangeError("Invalid number in \"".concat(e));
-        return {
-          year: n,
-          month: r,
-          day: o,
-          hour: i,
-          minute: s,
-          second: l
-        };
-      }(r);
-    }(e, r),
-    i = _GetFormatterParts.year,
-    s = _GetFormatterParts.month,
-    l = _GetFormatterParts.day,
-    d = _GetFormatterParts.hour,
-    m = _GetFormatterParts.minute,
-    c = _GetFormatterParts.second;
-  return BalanceISODateTime(i, s, l, d, m, c, o, n, a);
-}
-function maxJSBI(t, r) {
-  return t < r ? r : t;
-}
-function afterLatestPossibleTzdbRuleChange() {
-  return Ve() + Ze;
-}
-function GetNamedTimeZoneNextTransition(t, r) {
-  if (r < Pe) return GetNamedTimeZoneNextTransition(t, Pe);
-  var o = r + Be,
-    n = maxJSBI(afterLatestPossibleTzdbRuleChange(), o);
-  var a = maxJSBI(Pe, r);
-  var i = GetNamedTimeZoneOffsetNanoseconds(t, a);
-  var s = a,
-    l = i;
-  for (; i === l && BigInt(a) < n;) {
-    if (s = a + Ne, s > Re) return null;
-    l = GetNamedTimeZoneOffsetNanoseconds(t, s), i === l && (a = s);
-  }
-  if (i === l) return null;
-  return bisect(function (e) {
-    return GetNamedTimeZoneOffsetNanoseconds(t, e);
-  }, a, s, i, l);
-}
-function GetNamedTimeZonePreviousTransition(t, r) {
-  var o = afterLatestPossibleTzdbRuleChange(),
-    a = r > o,
-    i = a ? r - Be : Pe;
-  if ("Africa/Casablanca" === t || "Africa/El_Aaiun" === t) {
-    var _o13 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
-    if (_o13 < r) return GetNamedTimeZonePreviousTransition(t, _o13);
-  }
-  var s = r - Se;
-  if (s < Pe) return null;
-  var l = GetNamedTimeZoneOffsetNanoseconds(t, s);
-  var d = s,
-    m = l;
-  for (; l === m && s > i;) {
-    if (d = s - Ne, d < Pe) return null;
-    m = GetNamedTimeZoneOffsetNanoseconds(t, d), l === m && (s = d);
-  }
-  if (l === m) {
-    if (a) {
-      var _r36 = o - Ee;
-      return GetNamedTimeZonePreviousTransition(t, _r36);
-    }
-    return null;
-  }
-  return bisect(function (e) {
-    return GetNamedTimeZoneOffsetNanoseconds(t, e);
-  }, d, s, m, l);
-}
-function LeapYear(e) {
-  if (void 0 === e) return !1;
-  return e % 4 == 0 && (!(e % 100 == 0) || e % 400 == 0);
-}
-function ISODaysInMonth(e, t) {
-  return {
-    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
-    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
-  }[LeapYear(e) ? "leapyear" : "standard"][t - 1];
-}
-function DayOfWeek(e, t, r) {
-  var o = t + (t < 3 ? 10 : -2),
-    n = e - (t < 3 ? 1 : 0),
-    a = ie(n / 100),
-    i = n - 100 * a,
-    s = (r + ie(2.6 * o - .2) + (i + ie(i / 4)) + (ie(a / 4) - 2 * a)) % 7;
-  return s + (s <= 0 ? 7 : 0);
-}
-function DayOfYear(e, t, r) {
-  var o = r;
-  for (var _r37 = t - 1; _r37 > 0; _r37--) o += ISODaysInMonth(e, _r37);
-  return o;
-}
-function WeekOfYear(e, t, r) {
-  var o = DayOfYear(e, t, r),
-    n = DayOfWeek(e, t, r) || 7,
-    a = DayOfWeek(e, 1, 1),
-    i = ie((o - n + 10) / 7);
-  return i < 1 ? 5 === a || 6 === a && LeapYear(e - 1) ? {
-    week: 53,
-    year: e - 1
-  } : {
-    week: 52,
-    year: e - 1
-  } : 53 === i && (LeapYear(e) ? 366 : 365) - o < 4 - n ? {
-    week: 1,
-    year: e + 1
-  } : {
-    week: i,
-    year: e
-  };
-}
-function DurationSign(e, t, r, o, n, a, i, s, l, d) {
-  for (var _i7 = 0, _arr2 = [e, t, r, o, n, a, i, s, l, d]; _i7 < _arr2.length; _i7++) {
-    var _m2 = _arr2[_i7];
-    if (0 !== _m2) return _m2 < 0 ? -1 : 1;
-  }
-  return 0;
-}
-function BalanceISOYearMonth(e, t) {
-  var r = e,
-    o = t;
-  if (!me(r) || !me(o)) throw new RangeError("infinity is out of range");
-  return o -= 1, r += ie(o / 12), o %= 12, o < 0 && (o += 12), o += 1, {
-    year: r,
-    month: o
-  };
-}
-function BalanceISODate(e, t, r) {
-  var o = e,
-    n = t,
-    a = r;
-  if (!me(a)) throw new RangeError("infinity is out of range");
-  var _BalanceISOYearMonth = BalanceISOYearMonth(o, n);
-  o = _BalanceISOYearMonth.year;
-  n = _BalanceISOYearMonth.month;
-  var i = 146097;
-  if (ae(a) > i) {
-    var _e24 = le(a / i);
-    o += 400 * _e24, a -= _e24 * i;
-  }
-  var s = 0,
-    l = n > 2 ? o : o - 1;
-  for (; s = LeapYear(l) ? 366 : 365, a < -s;) o -= 1, l -= 1, a += s;
-  for (l += 1; s = LeapYear(l) ? 366 : 365, a > s;) o += 1, l += 1, a -= s;
-  for (; a < 1;) {
-    var _BalanceISOYearMonth2;
-    (_BalanceISOYearMonth2 = BalanceISOYearMonth(o, n - 1), o = _BalanceISOYearMonth2.year, n = _BalanceISOYearMonth2.month), a += ISODaysInMonth(o, n);
-  }
-  for (; a > ISODaysInMonth(o, n);) {
-    var _BalanceISOYearMonth3;
-    a -= ISODaysInMonth(o, n), (_BalanceISOYearMonth3 = BalanceISOYearMonth(o, n + 1), o = _BalanceISOYearMonth3.year, n = _BalanceISOYearMonth3.month);
-  }
-  return {
-    year: o,
-    month: n,
-    day: a
-  };
-}
-function BalanceISODateTime(e, t, r, o, n, a, i, s, l) {
-  var _BalanceTime = BalanceTime(o, n, a, i, s, l),
-    d = _BalanceTime.deltaDays,
-    m = _BalanceTime.hour,
-    c = _BalanceTime.minute,
-    h = _BalanceTime.second,
-    u = _BalanceTime.millisecond,
-    T = _BalanceTime.microsecond,
-    p = _BalanceTime.nanosecond,
-    _BalanceISODate = BalanceISODate(e, t, r + d),
-    f = _BalanceISODate.year,
-    y = _BalanceISODate.month,
-    I = _BalanceISODate.day;
-  return {
-    year: f,
-    month: y,
-    day: I,
-    hour: m,
-    minute: c,
-    second: h,
-    millisecond: u,
-    microsecond: T,
-    nanosecond: p
-  };
-}
-function BalanceTime(t, r, o, n, a, i) {
-  var _NonNegativeBigIntDiv, _NonNegativeBigIntDiv2, _NonNegativeBigIntDiv3, _NonNegativeBigIntDiv4, _NonNegativeBigIntDiv5, _NonNegativeBigIntDiv6;
-  var s,
-    l = BigInt(t),
-    d = BigInt(r),
-    m = BigInt(o),
-    c = BigInt(n),
-    h = BigInt(a),
-    u = BigInt(i);
-  return (_NonNegativeBigIntDiv = NonNegativeBigIntDivmod(u, De), s = _NonNegativeBigIntDiv.quotient, u = _NonNegativeBigIntDiv.remainder), h = h + s, (_NonNegativeBigIntDiv2 = NonNegativeBigIntDivmod(h, De), s = _NonNegativeBigIntDiv2.quotient, h = _NonNegativeBigIntDiv2.remainder), c = c + s, (_NonNegativeBigIntDiv3 = NonNegativeBigIntDivmod(c, De), s = _NonNegativeBigIntDiv3.quotient, c = _NonNegativeBigIntDiv3.remainder), m = m + s, (_NonNegativeBigIntDiv4 = NonNegativeBigIntDivmod(m, ge), s = _NonNegativeBigIntDiv4.quotient, m = _NonNegativeBigIntDiv4.remainder), d = d + s, (_NonNegativeBigIntDiv5 = NonNegativeBigIntDivmod(d, ge), s = _NonNegativeBigIntDiv5.quotient, d = _NonNegativeBigIntDiv5.remainder), l = l + s, (_NonNegativeBigIntDiv6 = NonNegativeBigIntDivmod(l, we), s = _NonNegativeBigIntDiv6.quotient, l = _NonNegativeBigIntDiv6.remainder), {
-    deltaDays: Number(s),
-    hour: Number(l),
-    minute: Number(d),
-    second: Number(m),
-    millisecond: Number(c),
-    microsecond: Number(h),
-    nanosecond: Number(u)
-  };
-}
-function TotalDurationNanoseconds(t, r, o, n, a, i, s, l) {
-  var d = BigInt(t);
-  var m = BigInt(s);
-  0 !== t && (m = BigInt(s) - BigInt(l));
-  var c = BigInt(r) + d * 24n,
-    h = BigInt(o) + c * ge,
-    u = BigInt(n) + h * ge,
-    T = BigInt(a) + u * De,
-    p = BigInt(i) + T * De;
-  return BigInt(m) + p * De;
-}
-function NanosecondsToDays(t, r) {
-  var o = GetIntrinsic("%Temporal.Instant%"),
-    a = se(Number(t));
-  var f = BigInt(t),
-    y = 864e11;
-  if (0 === a) return {
-    days: 0,
-    nanoseconds: Ie,
-    dayLengthNs: y
-  };
-  if (!IsTemporalZonedDateTime(r)) {
-    var _divmod5;
-    var _t24;
-    return (_divmod5 = divmod(f, BigInt(y)), _t24 = _divmod5.quotient, f = _divmod5.remainder), {
-      days: Number(_t24),
-      nanoseconds: f,
-      dayLengthNs: y
-    };
-  }
-  var I = GetSlot(r, n),
-    w = GetSlot(r, S),
-    D = I + f,
-    G = new o(D),
-    v = GetSlot(r, g),
-    C = GetSlot(r, p),
-    O = GetPlainDateTimeFor(v, w, C),
-    b = GetPlainDateTimeFor(v, G, C);
-  var _DifferenceISODateTim = DifferenceISODateTime(GetSlot(O, i), GetSlot(O, s), GetSlot(O, l), GetSlot(O, d), GetSlot(O, m), GetSlot(O, c), GetSlot(O, h), GetSlot(O, u), GetSlot(O, T), GetSlot(b, i), GetSlot(b, s), GetSlot(b, l), GetSlot(b, d), GetSlot(b, m), GetSlot(b, c), GetSlot(b, h), GetSlot(b, u), GetSlot(b, T), C, "day", Te(null)),
-    E = _DifferenceISODateTim.days,
-    M = AddZonedDateTime(w, v, C, 0, 0, 0, E, 0, 0, 0, 0, 0, 0),
-    R = BigInt(E);
-  if (1 === a) for (; R > Ie && M > D;) R = R - Se, M = AddZonedDateTime(w, v, C, 0, 0, 0, Number(R), 0, 0, 0, 0, 0, 0);
-  f = D - M;
-  var F = !1,
-    Y = new o(M);
-  do {
-    var _t25 = AddZonedDateTime(Y, v, C, 0, 0, 0, a, 0, 0, 0, 0, 0, 0),
-      _r38 = GetSlot(Y, n);
-    y = Number(_t25 - _r38), F = (f - BigInt(y)) * BigInt(a) >= Ie, F && (f = f - BigInt(y), Y = new o(_t25), R = R + BigInt(a));
-  } while (F);
-  if (!isZero(R) && signJSBI(R) !== a) throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
-  if (!isZero(f) && signJSBI(f) !== a) {
-    if (isNegativeJSBI(f) && 1 === a) throw new Error("assert not reached");
-    throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
-  }
-  if (abs(f) >= abs(BigInt(y))) throw new Error("assert not reached");
-  return {
-    days: Number(R),
-    nanoseconds: f,
-    dayLengthNs: ae(y)
-  };
-}
-function BalanceDuration(e, t, r, o, n, a, i, s, l) {
-  var d = BalancePossiblyInfiniteDuration(e, t, r, o, n, a, i, s, l);
-  if ("positive overflow" === d || "negative overflow" === d) throw new RangeError("Duration out of range");
-  return d;
-}
-function BalancePossiblyInfiniteDuration(t, r, o, a, i, s, l, d, m) {
-  var _NanosecondsToDays, _divmod6, _divmod7, _divmod8, _divmod9, _divmod10, _divmod11, _divmod12, _divmod13, _divmod14, _divmod15, _divmod16, _divmod17, _divmod18, _divmod19;
-  var c,
-    h,
-    u,
-    T,
-    f,
-    y,
-    I = t;
-  if (IsTemporalZonedDateTime(m)) {
-    var _t26 = AddZonedDateTime(GetSlot(m, S), GetSlot(m, g), GetSlot(m, p), 0, 0, 0, I, r, o, a, i, s, l),
-      _d = GetSlot(m, n);
-    c = _t26 - _d;
-  } else c = TotalDurationNanoseconds(I, r, o, a, i, s, l, 0);
-  "year" === d || "month" === d || "week" === d || "day" === d ? (_NanosecondsToDays = NanosecondsToDays(c, m), I = _NanosecondsToDays.days, c = _NanosecondsToDays.nanoseconds, _NanosecondsToDays) : I = 0;
-  var w = c < Ie ? -1 : 1;
-  switch (c = abs(c), h = u = T = f = y = Ie, d) {
-    case "year":
-    case "month":
-    case "week":
-    case "day":
-    case "hour":
-      (_divmod6 = divmod(c, De), h = _divmod6.quotient, c = _divmod6.remainder), (_divmod7 = divmod(h, De), u = _divmod7.quotient, h = _divmod7.remainder), (_divmod8 = divmod(u, De), T = _divmod8.quotient, u = _divmod8.remainder), (_divmod9 = divmod(T, ge), f = _divmod9.quotient, T = _divmod9.remainder), (_divmod10 = divmod(f, ge), y = _divmod10.quotient, f = _divmod10.remainder);
-      break;
-    case "minute":
-      (_divmod11 = divmod(c, De), h = _divmod11.quotient, c = _divmod11.remainder), (_divmod12 = divmod(h, De), u = _divmod12.quotient, h = _divmod12.remainder), (_divmod13 = divmod(u, De), T = _divmod13.quotient, u = _divmod13.remainder), (_divmod14 = divmod(T, ge), f = _divmod14.quotient, T = _divmod14.remainder);
-      break;
-    case "second":
-      (_divmod15 = divmod(c, De), h = _divmod15.quotient, c = _divmod15.remainder), (_divmod16 = divmod(h, De), u = _divmod16.quotient, h = _divmod16.remainder), (_divmod17 = divmod(u, De), T = _divmod17.quotient, u = _divmod17.remainder);
-      break;
-    case "millisecond":
-      (_divmod18 = divmod(c, De), h = _divmod18.quotient, c = _divmod18.remainder), (_divmod19 = divmod(h, De), u = _divmod19.quotient, h = _divmod19.remainder);
-      break;
-    case "microsecond":
-      var _divmod20 = divmod(c, De);
-      h = _divmod20.quotient;
-      c = _divmod20.remainder;
-      break;
-    case "nanosecond":
-      break;
-    default:
-      throw new Error("assert not reached");
-  }
-  var D = Number(y) * w,
-    G = Number(f) * w,
-    v = Number(T) * w,
-    C = Number(u) * w,
-    O = Number(h) * w,
-    b = Number(c) * w;
-  for (var _i8 = 0, _arr3 = [I, D, G, v, C, O, b]; _i8 < _arr3.length; _i8++) {
-    var _e25 = _arr3[_i8];
-    if (!me(_e25)) return 1 === w ? "positive overflow" : "negative overflow";
-  }
-  return {
-    days: I,
-    hours: D,
-    minutes: G,
-    seconds: v,
-    milliseconds: C,
-    microseconds: O,
-    nanoseconds: b
-  };
-}
-function UnbalanceDurationRelative(t, r, o, n, a, i) {
-  var s = GetIntrinsic("%Temporal.Duration%"),
-    l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
-  if (0 === l) return {
-    years: t,
-    months: r,
-    weeks: o,
-    days: n
-  };
-  var d = BigInt(l);
-  var m,
-    c,
-    h = BigInt(t),
-    u = BigInt(r),
-    T = BigInt(o),
-    f = BigInt(n);
-  i && (c = ToTemporalDate(i), m = GetSlot(c, p));
-  var y = new s(l),
-    I = new s(0, l),
-    S = new s(0, 0, l);
-  switch (a) {
-    case "year":
-      break;
-    case "month":
-      {
-        if (!m) throw new RangeError("a starting point is required for months balancing");
-        var _t27, _r39;
-        for ("string" != typeof m && (_t27 = GetMethod(m, "dateAdd"), _r39 = GetMethod(m, "dateUntil")); !isZero(h);) {
-          var _o14 = CalendarDateAdd(m, c, y, void 0, _t27),
-            _n9 = Te(null);
-          _n9.largestUnit = "month";
-          var _a6 = CalendarDateUntil(m, c, _o14, _n9, _r39),
-            _i9 = BigInt(GetSlot(_a6, D));
-          c = _o14, u = u + _i9, h = h - d;
-        }
-      }
-      break;
-    case "week":
-      {
-        if (!m) throw new RangeError("a starting point is required for weeks balancing");
-        var _t28 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
-        for (; !isZero(h);) {
-          var _MoveRelativeDate;
-          var _r40 = void 0;
-          (_MoveRelativeDate = MoveRelativeDate(m, c, y, _t28), c = _MoveRelativeDate.relativeTo, _r40 = _MoveRelativeDate.days), f = f + BigInt(_r40), h = h - d;
-        }
-        for (; !isZero(u);) {
-          var _MoveRelativeDate2;
-          var _r41 = void 0;
-          (_MoveRelativeDate2 = MoveRelativeDate(m, c, I, _t28), c = _MoveRelativeDate2.relativeTo, _r41 = _MoveRelativeDate2.days), f = f + BigInt(_r41), u = u - d;
-        }
-        break;
-      }
-    default:
-      {
-        if (isZero(h) && isZero(u) && isZero(T)) break;
-        if (!m) throw new RangeError("a starting point is required for balancing calendar units");
-        var _t29 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
-        for (; !isZero(h);) {
-          var _MoveRelativeDate3;
-          var _r42 = void 0;
-          (_MoveRelativeDate3 = MoveRelativeDate(m, c, y, _t29), c = _MoveRelativeDate3.relativeTo, _r42 = _MoveRelativeDate3.days), f = f + BigInt(_r42), h = h - d;
-        }
-        for (; !isZero(u);) {
-          var _MoveRelativeDate4;
-          var _r43 = void 0;
-          (_MoveRelativeDate4 = MoveRelativeDate(m, c, I, _t29), c = _MoveRelativeDate4.relativeTo, _r43 = _MoveRelativeDate4.days), f = f + BigInt(_r43), u = u - d;
-        }
-        for (; !isZero(T);) {
-          var _MoveRelativeDate5;
-          var _r44 = void 0;
-          (_MoveRelativeDate5 = MoveRelativeDate(m, c, S, _t29), c = _MoveRelativeDate5.relativeTo, _r44 = _MoveRelativeDate5.days), f = f + BigInt(_r44), T = T - d;
-        }
-        break;
-      }
-  }
-  return {
-    years: Number(h),
-    months: Number(u),
-    weeks: Number(T),
-    days: Number(f)
-  };
-}
-function CalculateOffsetShift(e, t, r, o, n) {
-  if (IsTemporalZonedDateTime(e)) {
-    var _a7 = GetSlot(e, S),
-      _i10 = GetSlot(e, g),
-      _s = GetSlot(e, p),
-      _l2 = GetOffsetNanosecondsFor(_i10, _a7),
-      _d2 = AddZonedDateTime(_a7, _i10, _s, t, r, o, n, 0, 0, 0, 0, 0, 0);
-    return GetOffsetNanosecondsFor(_i10, new (GetIntrinsic("%Temporal.Instant%"))(_d2)) - _l2;
-  }
-  return 0;
-}
-function CreateNegatedTemporalDuration(e) {
-  return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e, w), -GetSlot(e, D), -GetSlot(e, G), -GetSlot(e, v), -GetSlot(e, C), -GetSlot(e, O), -GetSlot(e, b), -GetSlot(e, E), -GetSlot(e, M), -GetSlot(e, R));
-}
-function ConstrainToRange(e, t, r) {
-  return oe(r, ne(t, e));
-}
-function ConstrainISODate(e, t, r) {
-  var o = ConstrainToRange(t, 1, 12);
-  return {
-    year: e,
-    month: o,
-    day: ConstrainToRange(r, 1, ISODaysInMonth(e, o))
-  };
-}
-function RejectToRange(e, t, r) {
-  if (e < t || e > r) throw new RangeError("value out of range: ".concat(t, " <= ").concat(e, " <= ").concat(r));
-}
-function RejectISODate(e, t, r) {
-  RejectToRange(t, 1, 12), RejectToRange(r, 1, ISODaysInMonth(e, t));
-}
-function RejectDateRange(e, t, r) {
-  RejectDateTimeRange(e, t, r, 12, 0, 0, 0, 0, 0);
-}
-function RejectTime(e, t, r, o, n, a) {
-  RejectToRange(e, 0, 23), RejectToRange(t, 0, 59), RejectToRange(r, 0, 59), RejectToRange(o, 0, 999), RejectToRange(n, 0, 999), RejectToRange(a, 0, 999);
-}
-function RejectDateTime(e, t, r, o, n, a, i, s, l) {
-  RejectISODate(e, t, r), RejectTime(o, n, a, i, s, l);
-}
-function RejectDateTimeRange(e, t, r, o, n, a, i, s, l) {
-  if (RejectToRange(e, Fe, Ye), e === Fe && null == GetUTCEpochNanoseconds(e, t, r + 1, o, n, a, i, s, l - 1) || e === Ye && null == GetUTCEpochNanoseconds(e, t, r - 1, o, n, a, i, s, l + 1)) throw new RangeError("DateTime outside of supported range");
-}
-function ValidateEpochNanoseconds(t) {
-  if (t < Me || t > Re) throw new RangeError("Instant outside of supported range");
-}
-function RejectDuration(e, t, r, o, n, a, i, s, l, d) {
-  var m = DurationSign(e, t, r, o, n, a, i, s, l, d);
-  for (var _i11 = 0, _arr4 = [e, t, r, o, n, a, i, s, l, d]; _i11 < _arr4.length; _i11++) {
-    var _c2 = _arr4[_i11];
-    if (!me(_c2)) throw new RangeError("infinite values not allowed as duration fields");
-    var _e26 = se(_c2);
-    if (0 !== _e26 && _e26 !== m) throw new RangeError("mixed-sign values not allowed as duration fields");
-  }
-}
-function DifferenceISODate(e, t, r, o, n, a, i) {
-  switch (i) {
-    case "year":
-    case "month":
-      {
-        var _s2 = -CompareISODate(e, t, r, o, n, a);
-        if (0 === _s2) return {
-          years: 0,
-          months: 0,
-          weeks: 0,
-          days: 0
-        };
-        var _l3 = {
-            year: e,
-            month: t,
-            day: r
-          },
-          _d3 = {
-            year: o,
-            month: n,
-            day: a
-          };
-        var _m3 = _d3.year - _l3.year,
-          _c3 = AddISODate(e, t, r, _m3, 0, 0, 0, "constrain"),
-          _h = -CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a);
-        if (0 === _h) return "year" === i ? {
-          years: _m3,
+      return function parseFromEnUsFormat(e){
+               var t = e.split(/[^\w]+/);
+               if(7 !== t.length)
+                throw new RangeError('expected 7 parts in "'.concat(e));
+               var r = + t[0], o = + t[1];
+               var n = + t[2];
+               var a = t[3].toUpperCase();
+               if("B" === a || "BC" === a)
+                n = 1 - n;
+               else if("A" !== a && "AD" !== a)
+                throw new
+                       RangeError
+                       ("Unknown era ".concat(a, ' in "').concat(e));
+               var i = + t[4];
+               24 === i && (i = 0);
+               var s = + t[5], l = + t[6];
+               if(! (me(n) && me(r) && me(o) && me(i) && me(s) && me(l)))
+                throw new RangeError('Invalid number in "'.concat(e));
+               return {year: n,
+                       month: r,
+                       day: o,
+                       hour: i,
+                       minute: s,
+                       second: l};
+              }
+              (r);
+     }
+     (e, r),
+  i = _GetFormatterParts.year,
+  s = _GetFormatterParts.month,
+  l = _GetFormatterParts.day,
+  d = _GetFormatterParts.hour,
+  m = _GetFormatterParts.minute,
+  c = _GetFormatterParts.second;
+ return BalanceISODateTime(i, s, l, d, m, c, o, n, a);
+}
+function maxJSBI(t, r){return t < r ? r : t;}
+function afterLatestPossibleTzdbRuleChange(){return Ve() + Ze;}
+function GetNamedTimeZoneNextTransition(t, r){
+ if(r < Pe) return GetNamedTimeZoneNextTransition(t, Pe);
+ var o = r + Be, n = maxJSBI(afterLatestPossibleTzdbRuleChange(), o);
+ var a = maxJSBI(Pe, r);
+ var i = GetNamedTimeZoneOffsetNanoseconds(t, a);
+ var s = a, l = i;
+ for(; i === l && BigInt(a) < n;){
+  if(s = a + Ne, s > Re) return null;
+  l = GetNamedTimeZoneOffsetNanoseconds(t, s), i === l && (a = s);
+ }
+ if(i === l) return null;
+ return bisect
+         (function(e){return GetNamedTimeZoneOffsetNanoseconds(t, e);},
+          a,
+          s,
+          i,
+          l);
+}
+function GetNamedTimeZonePreviousTransition(t, r){
+ var o = afterLatestPossibleTzdbRuleChange(), a = r > o, i = a ? r - Be : Pe;
+ if("Africa/Casablanca" === t || "Africa/El_Aaiun" === t){
+  var _o13 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
+  if(_o13 < r) return GetNamedTimeZonePreviousTransition(t, _o13);
+ }
+ var s = r - Se;
+ if(s < Pe) return null;
+ var l = GetNamedTimeZoneOffsetNanoseconds(t, s);
+ var d = s, m = l;
+ for(; l === m && s > i;){
+  if(d = s - Ne, d < Pe) return null;
+  m = GetNamedTimeZoneOffsetNanoseconds(t, d), l === m && (s = d);
+ }
+ if(l === m){
+  if(a){
+   var _r36 = o - Ee;
+   return GetNamedTimeZonePreviousTransition(t, _r36);
+  }
+  return null;
+ }
+ return bisect
+         (function(e){return GetNamedTimeZoneOffsetNanoseconds(t, e);},
+          d,
+          s,
+          m,
+          l);
+}
+function LeapYear(e){
+ if(void 0 === e) return ! 1;
+ return e % 4 == 0 && (! (e % 100 == 0) || e % 400 == 0);
+}
+function ISODaysInMonth(e, t){
+ return {standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
+           leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]}
+          [LeapYear(e) ? "leapyear" : "standard"]
+         [t - 1];
+}
+function DayOfWeek(e, t, r){
+ var
+  o = t + (t < 3 ? 10 : - 2),
+  n = e - (t < 3 ? 1 : 0),
+  a = ie(n / 100),
+  i = n - 100 * a,
+  s = (r + ie(2.6 * o - .2) + (i + ie(i / 4)) + (ie(a / 4) - 2 * a)) % 7;
+ return s + (s <= 0 ? 7 : 0);
+}
+function DayOfYear(e, t, r){
+ var o = r;
+ for(var _r37 = t - 1; _r37 > 0; _r37--) o += ISODaysInMonth(e, _r37);
+ return o;
+}
+function WeekOfYear(e, t, r){
+ var
+  o = DayOfYear(e, t, r),
+  n = DayOfWeek(e, t, r) || 7,
+  a = DayOfWeek(e, 1, 1),
+  i = ie((o - n + 10) / 7);
+ return i < 1
+         ? 5
+           === a
+           || 6 === a && LeapYear(e - 1)
+           ? {week: 53, year: e - 1}
+           : {week: 52, year: e - 1}
+         : 53
+           === i
+           && (LeapYear(e) ? 366 : 365) - o < 4 - n
+           ? {week: 1, year: e + 1}
+           : {week: i, year: e};
+}
+function DurationSign(e, t, r, o, n, a, i, s, l, d){
+ for
+ (var _i7 = 0, _arr2 = [e, t, r, o, n, a, i, s, l, d];
+  _i7 < _arr2.length;
+  _i7++){var _m2 = _arr2[_i7]; if(0 !== _m2) return _m2 < 0 ? - 1 : 1;}
+ return 0;
+}
+function BalanceISOYearMonth(e, t){
+ var r = e, o = t;
+ if(! me(r) || ! me(o)) throw new RangeError("infinity is out of range");
+ return o -= 1,
+        r += ie(o / 12),
+        o %= 12,
+        o < 0 && (o += 12),
+        o += 1,
+        {year: r, month: o};
+}
+function BalanceISODate(e, t, r){
+ var o = e, n = t, a = r;
+ if(! me(a)) throw new RangeError("infinity is out of range");
+ var _BalanceISOYearMonth = BalanceISOYearMonth(o, n);
+ o = _BalanceISOYearMonth.year;
+ n = _BalanceISOYearMonth.month;
+ var i = 146097;
+ if(ae(a) > i){var _e24 = le(a / i); o += 400 * _e24, a -= _e24 * i;}
+ var s = 0, l = n > 2 ? o : o - 1;
+ for(; s = LeapYear(l) ? 366 : 365, a < - s;) o -= 1, l -= 1, a += s;
+ for(l += 1; s = LeapYear(l) ? 366 : 365, a > s;) o += 1, l += 1, a -= s;
+ for(; a < 1;){
+  var _BalanceISOYearMonth2;
+  _BalanceISOYearMonth2 = BalanceISOYearMonth(o, n - 1),
+  o = _BalanceISOYearMonth2.year,
+  n = _BalanceISOYearMonth2.month,
+  a += ISODaysInMonth(o, n);
+ }
+ for(; a > ISODaysInMonth(o, n);){
+  var _BalanceISOYearMonth3;
+  a -= ISODaysInMonth(o, n),
+  _BalanceISOYearMonth3 = BalanceISOYearMonth(o, n + 1),
+  o = _BalanceISOYearMonth3.year,
+  n = _BalanceISOYearMonth3.month;
+ }
+ return {year: o, month: n, day: a};
+}
+function BalanceISODateTime(e, t, r, o, n, a, i, s, l){
+ var
+  _BalanceTime = BalanceTime(o, n, a, i, s, l),
+  d = _BalanceTime.deltaDays,
+  m = _BalanceTime.hour,
+  c = _BalanceTime.minute,
+  h = _BalanceTime.second,
+  u = _BalanceTime.millisecond,
+  T = _BalanceTime.microsecond,
+  p = _BalanceTime.nanosecond,
+  _BalanceISODate = BalanceISODate(e, t, r + d),
+  f = _BalanceISODate.year,
+  y = _BalanceISODate.month,
+  I = _BalanceISODate.day;
+ return {year: f,
+         month: y,
+         day: I,
+         hour: m,
+         minute: c,
+         second: h,
+         millisecond: u,
+         microsecond: T,
+         nanosecond: p};
+}
+function BalanceTime(t, r, o, n, a, i){
+ var
+  _NonNegativeBigIntDiv,
+  _NonNegativeBigIntDiv2,
+  _NonNegativeBigIntDiv3,
+  _NonNegativeBigIntDiv4,
+  _NonNegativeBigIntDiv5,
+  _NonNegativeBigIntDiv6;
+ var
+  s,
+  l = BigInt(t),
+  d = BigInt(r),
+  m = BigInt(o),
+  c = BigInt(n),
+  h = BigInt(a),
+  u = BigInt(i);
+ return _NonNegativeBigIntDiv = NonNegativeBigIntDivmod(u, De),
+        s = _NonNegativeBigIntDiv.quotient,
+        u = _NonNegativeBigIntDiv.remainder,
+        h = h + s,
+        _NonNegativeBigIntDiv2 = NonNegativeBigIntDivmod(h, De),
+        s = _NonNegativeBigIntDiv2.quotient,
+        h = _NonNegativeBigIntDiv2.remainder,
+        c = c + s,
+        _NonNegativeBigIntDiv3 = NonNegativeBigIntDivmod(c, De),
+        s = _NonNegativeBigIntDiv3.quotient,
+        c = _NonNegativeBigIntDiv3.remainder,
+        m = m + s,
+        _NonNegativeBigIntDiv4 = NonNegativeBigIntDivmod(m, ge),
+        s = _NonNegativeBigIntDiv4.quotient,
+        m = _NonNegativeBigIntDiv4.remainder,
+        d = d + s,
+        _NonNegativeBigIntDiv5 = NonNegativeBigIntDivmod(d, ge),
+        s = _NonNegativeBigIntDiv5.quotient,
+        d = _NonNegativeBigIntDiv5.remainder,
+        l = l + s,
+        _NonNegativeBigIntDiv6 = NonNegativeBigIntDivmod(l, we),
+        s = _NonNegativeBigIntDiv6.quotient,
+        l = _NonNegativeBigIntDiv6.remainder,
+        {deltaDays: Number(s),
+         hour: Number(l),
+         minute: Number(d),
+         second: Number(m),
+         millisecond: Number(c),
+         microsecond: Number(h),
+         nanosecond: Number(u)};
+}
+function TotalDurationNanoseconds(t, r, o, n, a, i, s, l){
+ var d = BigInt(t);
+ var m = BigInt(s);
+ 0 !== t && (m = BigInt(s) - BigInt(l));
+ var
+  c = BigInt(r) + d * BigInt("24"),
+  h = BigInt(o) + c * ge,
+  u = BigInt(n) + h * ge,
+  T = BigInt(a) + u * De,
+  p = BigInt(i) + T * De;
+ return BigInt(m) + p * De;
+}
+function NanosecondsToDays(t, r){
+ var o = GetIntrinsic("%Temporal.Instant%"), a = se(Number(t));
+ var f = BigInt(t), y = 864e11;
+ if(0 === a) return {days: 0, nanoseconds: Ie, dayLengthNs: y};
+ if(! IsTemporalZonedDateTime(r)){
+  var _divmod5;
+  var _t24;
+  return _divmod5 = divmod(f, BigInt(y)),
+         _t24 = _divmod5.quotient,
+         f = _divmod5.remainder,
+         {days: Number(_t24), nanoseconds: f, dayLengthNs: y};
+ }
+ var
+  I = GetSlot(r, n),
+  w = GetSlot(r, S),
+  D = I + f,
+  G = new o(D),
+  v = GetSlot(r, g),
+  C = GetSlot(r, p),
+  O = GetPlainDateTimeFor(v, w, C),
+  b = GetPlainDateTimeFor(v, G, C);
+ var
+  _DifferenceISODateTim =
+    DifferenceISODateTime
+     (GetSlot(O, i),
+      GetSlot(O, s),
+      GetSlot(O, l),
+      GetSlot(O, d),
+      GetSlot(O, m),
+      GetSlot(O, c),
+      GetSlot(O, h),
+      GetSlot(O, u),
+      GetSlot(O, T),
+      GetSlot(b, i),
+      GetSlot(b, s),
+      GetSlot(b, l),
+      GetSlot(b, d),
+      GetSlot(b, m),
+      GetSlot(b, c),
+      GetSlot(b, h),
+      GetSlot(b, u),
+      GetSlot(b, T),
+      C,
+      "day",
+      Te(null)),
+  E = _DifferenceISODateTim.days,
+  M = AddZonedDateTime(w, v, C, 0, 0, 0, E, 0, 0, 0, 0, 0, 0),
+  R = BigInt(E);
+ if(1 === a)
+  for(; R > Ie && M > D;)
+   R = R - Se,
+   M = AddZonedDateTime(w, v, C, 0, 0, 0, Number(R), 0, 0, 0, 0, 0, 0);
+ f = D - M;
+ var F = ! 1, Y = new o(M);
+ do{
+  var
+   _t25 = AddZonedDateTime(Y, v, C, 0, 0, 0, a, 0, 0, 0, 0, 0, 0),
+   _r38 = GetSlot(Y, n);
+  y = Number(_t25 - _r38),
+  F = (f - BigInt(y)) * BigInt(a) >= Ie,
+  F && (f = f - BigInt(y), Y = new o(_t25), R = R + BigInt(a));
+ }
+ while
+  (F);
+ if(! isZero(R) && signJSBI(R) !== a)
+  throw new
+         RangeError
+         ("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
+ if(! isZero(f) && signJSBI(f) !== a){
+  if(isNegativeJSBI(f) && 1 === a) throw new Error("assert not reached");
+  throw new
+         RangeError
+         ("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
+ }
+ if(abs(f) >= abs(BigInt(y))) throw new Error("assert not reached");
+ return {days: Number(R), nanoseconds: f, dayLengthNs: ae(y)};
+}
+function BalanceDuration(e, t, r, o, n, a, i, s, l){
+ var d = BalancePossiblyInfiniteDuration(e, t, r, o, n, a, i, s, l);
+ if("positive overflow" === d || "negative overflow" === d)
+  throw new RangeError("Duration out of range");
+ return d;
+}
+function BalancePossiblyInfiniteDuration(t, r, o, a, i, s, l, d, m){
+ var
+  _NanosecondsToDays,
+  _divmod6,
+  _divmod7,
+  _divmod8,
+  _divmod9,
+  _divmod10,
+  _divmod11,
+  _divmod12,
+  _divmod13,
+  _divmod14,
+  _divmod15,
+  _divmod16,
+  _divmod17,
+  _divmod18,
+  _divmod19;
+ var c, h, u, T, f, y, I = t;
+ if(IsTemporalZonedDateTime(m)){
+  var
+   _t26 =
+     AddZonedDateTime
+      (GetSlot(m, S),
+       GetSlot(m, g),
+       GetSlot(m, p),
+       0,
+       0,
+       0,
+       I,
+       r,
+       o,
+       a,
+       i,
+       s,
+       l),
+   _d = GetSlot(m, n);
+  c = _t26 - _d;
+ }
+ else
+  c = TotalDurationNanoseconds(I, r, o, a, i, s, l, 0);
+ "year" === d || "month" === d || "week" === d || "day" === d
+  ? (_NanosecondsToDays
+    = NanosecondsToDays(c, m),
+    I = _NanosecondsToDays.days,
+    c = _NanosecondsToDays.nanoseconds,
+    _NanosecondsToDays)
+  : I = 0;
+ var w = c < Ie ? - 1 : 1;
+ switch(c = abs(c), h = u = T = f = y = Ie, d){
+   case "year":
+   case "month":
+   case "week":
+   case "day":
+   case "hour":
+    _divmod6 = divmod(c, De),
+    h = _divmod6.quotient,
+    c = _divmod6.remainder,
+    _divmod7 = divmod(h, De),
+    u = _divmod7.quotient,
+    h = _divmod7.remainder,
+    _divmod8 = divmod(u, De),
+    T = _divmod8.quotient,
+    u = _divmod8.remainder,
+    _divmod9 = divmod(T, ge),
+    f = _divmod9.quotient,
+    T = _divmod9.remainder,
+    _divmod10 = divmod(f, ge),
+    y = _divmod10.quotient,
+    f = _divmod10.remainder;
+    break;
+   case "minute":
+    _divmod11 = divmod(c, De),
+    h = _divmod11.quotient,
+    c = _divmod11.remainder,
+    _divmod12 = divmod(h, De),
+    u = _divmod12.quotient,
+    h = _divmod12.remainder,
+    _divmod13 = divmod(u, De),
+    T = _divmod13.quotient,
+    u = _divmod13.remainder,
+    _divmod14 = divmod(T, ge),
+    f = _divmod14.quotient,
+    T = _divmod14.remainder;
+    break;
+   case "second":
+    _divmod15 = divmod(c, De),
+    h = _divmod15.quotient,
+    c = _divmod15.remainder,
+    _divmod16 = divmod(h, De),
+    u = _divmod16.quotient,
+    h = _divmod16.remainder,
+    _divmod17 = divmod(u, De),
+    T = _divmod17.quotient,
+    u = _divmod17.remainder;
+    break;
+   case "millisecond":
+    _divmod18 = divmod(c, De),
+    h = _divmod18.quotient,
+    c = _divmod18.remainder,
+    _divmod19 = divmod(h, De),
+    u = _divmod19.quotient,
+    h = _divmod19.remainder;
+    break;
+   case "microsecond":
+    var _divmod20 = divmod(c, De);
+    h = _divmod20.quotient;
+    c = _divmod20.remainder;
+    break;
+   case "nanosecond": break;
+   default: throw new Error("assert not reached");
+ }
+ var
+  D = Number(y) * w,
+  G = Number(f) * w,
+  v = Number(T) * w,
+  C = Number(u) * w,
+  O = Number(h) * w,
+  b = Number(c) * w;
+ for(var _i8 = 0, _arr3 = [I, D, G, v, C, O, b]; _i8 < _arr3.length; _i8++){
+  var _e25 = _arr3[_i8];
+  if(! me(_e25)) return 1 === w ? "positive overflow" : "negative overflow";
+ }
+ return {days: I,
+         hours: D,
+         minutes: G,
+         seconds: v,
+         milliseconds: C,
+         microseconds: O,
+         nanoseconds: b};
+}
+function UnbalanceDurationRelative(t, r, o, n, a, i){
+ var
+  s = GetIntrinsic("%Temporal.Duration%"),
+  l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
+ if(0 === l) return {years: t, months: r, weeks: o, days: n};
+ var d = BigInt(l);
+ var m, c, h = BigInt(t), u = BigInt(r), T = BigInt(o), f = BigInt(n);
+ i && (c = ToTemporalDate(i), m = GetSlot(c, p));
+ var y = new s(l), I = new s(0, l), S = new s(0, 0, l);
+ switch(a){
+   case "year": break;
+   case "month":
+    {
+     if(! m)
+      throw new
+             RangeError
+             ("a starting point is required for months balancing");
+     var _t27, _r39;
+     for
+     ("string" != typeof m
+      && (_t27 = GetMethod(m, "dateAdd"), _r39 = GetMethod(m, "dateUntil"));
+      !
+      isZero(h);){
+      var _o14 = CalendarDateAdd(m, c, y, void 0, _t27), _n9 = Te(null);
+      _n9.largestUnit = "month";
+      var
+       _a6 = CalendarDateUntil(m, c, _o14, _n9, _r39),
+       _i9 = BigInt(GetSlot(_a6, D));
+      c = _o14, u = u + _i9, h = h - d;
+     }
+    }
+    break;
+   case "week":
+    {
+     if(! m)
+      throw new RangeError("a starting point is required for weeks balancing");
+     var _t28 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
+     for(; ! isZero(h);){
+      var _MoveRelativeDate;
+      var _r40 = void 0;
+      _MoveRelativeDate = MoveRelativeDate(m, c, y, _t28),
+      c = _MoveRelativeDate.relativeTo,
+      _r40 = _MoveRelativeDate.days,
+      f = f + BigInt(_r40),
+      h = h - d;
+     }
+     for(; ! isZero(u);){
+      var _MoveRelativeDate2;
+      var _r41 = void 0;
+      _MoveRelativeDate2 = MoveRelativeDate(m, c, I, _t28),
+      c = _MoveRelativeDate2.relativeTo,
+      _r41 = _MoveRelativeDate2.days,
+      f = f + BigInt(_r41),
+      u = u - d;
+     }
+     break;
+    }
+   default:
+    {
+     if(isZero(h) && isZero(u) && isZero(T)) break;
+     if(! m)
+      throw new
+             RangeError
+             ("a starting point is required for balancing calendar units");
+     var _t29 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
+     for(; ! isZero(h);){
+      var _MoveRelativeDate3;
+      var _r42 = void 0;
+      _MoveRelativeDate3 = MoveRelativeDate(m, c, y, _t29),
+      c = _MoveRelativeDate3.relativeTo,
+      _r42 = _MoveRelativeDate3.days,
+      f = f + BigInt(_r42),
+      h = h - d;
+     }
+     for(; ! isZero(u);){
+      var _MoveRelativeDate4;
+      var _r43 = void 0;
+      _MoveRelativeDate4 = MoveRelativeDate(m, c, I, _t29),
+      c = _MoveRelativeDate4.relativeTo,
+      _r43 = _MoveRelativeDate4.days,
+      f = f + BigInt(_r43),
+      u = u - d;
+     }
+     for(; ! isZero(T);){
+      var _MoveRelativeDate5;
+      var _r44 = void 0;
+      _MoveRelativeDate5 = MoveRelativeDate(m, c, S, _t29),
+      c = _MoveRelativeDate5.relativeTo,
+      _r44 = _MoveRelativeDate5.days,
+      f = f + BigInt(_r44),
+      T = T - d;
+     }
+     break;
+    }
+ }
+ return {years: Number(h),
+         months: Number(u),
+         weeks: Number(T),
+         days: Number(f)};
+}
+function CalculateOffsetShift(e, t, r, o, n){
+ if(IsTemporalZonedDateTime(e)){
+  var
+   _a7 = GetSlot(e, S),
+   _i10 = GetSlot(e, g),
+   _s = GetSlot(e, p),
+   _l2 = GetOffsetNanosecondsFor(_i10, _a7),
+   _d2 = AddZonedDateTime(_a7, _i10, _s, t, r, o, n, 0, 0, 0, 0, 0, 0);
+  return GetOffsetNanosecondsFor
+          (_i10, new (GetIntrinsic("%Temporal.Instant%"))(_d2))
+         - _l2;
+ }
+ return 0;
+}
+function CreateNegatedTemporalDuration(e){
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (- GetSlot(e, w),
+          - GetSlot(e, D),
+          - GetSlot(e, G),
+          - GetSlot(e, v),
+          - GetSlot(e, C),
+          - GetSlot(e, O),
+          - GetSlot(e, b),
+          - GetSlot(e, E),
+          - GetSlot(e, M),
+          - GetSlot(e, R));
+}
+function ConstrainToRange(e, t, r){return oe(r, ne(t, e));}
+function ConstrainISODate(e, t, r){
+ var o = ConstrainToRange(t, 1, 12);
+ return {year: e, month: o, day: ConstrainToRange(r, 1, ISODaysInMonth(e, o))};
+}
+function RejectToRange(e, t, r){
+ if(e < t || e > r)
+  throw new
+         RangeError
+         ("value out of range: ".concat(t, " <= ").concat(e, " <= ").concat(r));
+}
+function RejectISODate(e, t, r){
+ RejectToRange(t, 1, 12), RejectToRange(r, 1, ISODaysInMonth(e, t));
+}
+function RejectDateRange(e, t, r){
+ RejectDateTimeRange(e, t, r, 12, 0, 0, 0, 0, 0);
+}
+function RejectTime(e, t, r, o, n, a){
+ RejectToRange(e, 0, 23),
+ RejectToRange(t, 0, 59),
+ RejectToRange(r, 0, 59),
+ RejectToRange(o, 0, 999),
+ RejectToRange(n, 0, 999),
+ RejectToRange(a, 0, 999);
+}
+function RejectDateTime(e, t, r, o, n, a, i, s, l){
+ RejectISODate(e, t, r), RejectTime(o, n, a, i, s, l);
+}
+function RejectDateTimeRange(e, t, r, o, n, a, i, s, l){
+ if
+  (RejectToRange(e, Fe, Ye),
+   e === Fe
+   && null == GetUTCEpochNanoseconds(e, t, r + 1, o, n, a, i, s, l - 1)
+   ||
+    e === Ye
+    && null == GetUTCEpochNanoseconds(e, t, r - 1, o, n, a, i, s, l + 1))
+  throw new RangeError("DateTime outside of supported range");
+}
+function ValidateEpochNanoseconds(t){
+ if(t < Me || t > Re)
+  throw new RangeError("Instant outside of supported range");
+}
+function RejectDuration(e, t, r, o, n, a, i, s, l, d){
+ var m = DurationSign(e, t, r, o, n, a, i, s, l, d);
+ for
+ (var _i11 = 0, _arr4 = [e, t, r, o, n, a, i, s, l, d];
+  _i11 < _arr4.length;
+  _i11++){
+  var _c2 = _arr4[_i11];
+  if(! me(_c2))
+   throw new RangeError("infinite values not allowed as duration fields");
+  var _e26 = se(_c2);
+  if(0 !== _e26 && _e26 !== m)
+   throw new RangeError("mixed-sign values not allowed as duration fields");
+ }
+}
+function DifferenceISODate(e, t, r, o, n, a, i){
+ switch(i){
+   case "year":
+   case "month":
+    {
+     var _s2 = - CompareISODate(e, t, r, o, n, a);
+     if(0 === _s2) return {years: 0, months: 0, weeks: 0, days: 0};
+     var _l3 = {year: e, month: t, day: r}, _d3 = {year: o, month: n, day: a};
+     var
+      _m3 = _d3.year - _l3.year,
+      _c3 = AddISODate(e, t, r, _m3, 0, 0, 0, "constrain"),
+      _h = - CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a);
+     if(0 === _h)
+      return "year" === i
+              ? {years: _m3, months: 0, weeks: 0, days: 0}
+              : {years: 0, months: 12 * _m3, weeks: 0, days: 0};
+     var _u = _d3.month - _l3.month;
+     if
+      (_h !== _s2 && (_m3 -= _s2, _u += 12 * _s2),
+       _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"),
+       _h = - CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a),
+       0 === _h)
+      return "year" === i
+              ? {years: _m3, months: _u, weeks: 0, days: 0}
+              : {years: 0, months: _u + 12 * _m3, weeks: 0, days: 0};
+     _h !== _s2
+     &&
+      (_u -= _s2,
+       _u === - _s2 && (_m3 -= _s2, _u = 11 * _s2),
+       _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"));
+     var _T = 0;
+     return _T =
+             _c3.month === _d3.month
+              ? _d3.day - _c3.day
+              : _s2
+                < 0
+                ? - _c3.day - (ISODaysInMonth(_d3.year, _d3.month) - _d3.day)
+                : _d3.day + (ISODaysInMonth(_c3.year, _c3.month) - _c3.day),
+            "month" === i && (_u += 12 * _m3, _m3 = 0),
+            {years: _m3, months: _u, weeks: 0, days: _T};
+    }
+   case "week":
+   case "day":
+    {
+     var _s3, _l4, _d4;
+     CompareISODate(e, t, r, o, n, a) < 0
+      ? (_l4
+        = {year: e, month: t, day: r},
+        _s3 = {year: o, month: n, day: a},
+        _d4 = 1)
+      : (_l4
+        = {year: o, month: n, day: a},
+        _s3 = {year: e, month: t, day: r},
+        _d4 = - 1);
+     var
+      _m4 =
+        DayOfYear(_s3.year, _s3.month, _s3.day)
+        - DayOfYear(_l4.year, _l4.month, _l4.day);
+     for(var _e27 = _l4.year; _e27 < _s3.year; ++_e27)
+      _m4 += LeapYear(_e27) ? 366 : 365;
+     var _c4 = 0;
+     return "week" === i && (_c4 = ie(_m4 / 7), _m4 %= 7),
+            _c4 *= _d4,
+            _m4 *= _d4,
+            {years: 0, months: 0, weeks: _c4, days: _m4};
+    }
+   default: throw new Error("assert not reached");
+ }
+}
+function DifferenceTime(e, t, r, o, n, a, i, s, l, d, m, c){
+ var _BalanceTime2;
+ var h = i - e, u = s - t, T = l - r, p = d - o, f = m - n, y = c - a;
+ var I = DurationSign(0, 0, 0, 0, h, u, T, p, f, y);
+ h *= I, u *= I, T *= I, p *= I, f *= I, y *= I;
+ var S = 0;
+ if
+  (_BalanceTime2 = BalanceTime(h, u, T, p, f, y),
+   S = _BalanceTime2.deltaDays,
+   h = _BalanceTime2.hour,
+   u = _BalanceTime2.minute,
+   T = _BalanceTime2.second,
+   p = _BalanceTime2.millisecond,
+   f = _BalanceTime2.microsecond,
+   y = _BalanceTime2.nanosecond,
+   0 != S)
+  throw new
+         Error
+         ("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
+ return h *= I,
+        u *= I,
+        T *= I,
+        p *= I,
+        f *= I,
+        y *= I,
+        {hours: h,
+         minutes: u,
+         seconds: T,
+         milliseconds: p,
+         microseconds: f,
+         nanoseconds: y};
+}
+function DifferenceInstant(t, r, o, n, a, i){
+ var _RoundDuration2;
+ var s = r - t;
+ var
+  l = 0,
+  d = 0,
+  m = Number(s % De),
+  c = Number(s / De % De),
+  h = Number(s / Ge % De),
+  u = Number(s / ve);
+ return _RoundDuration2 = RoundDuration(0, 0, 0, 0, 0, 0, u, h, c, m, o, n, i),
+        l = _RoundDuration2.hours,
+        d = _RoundDuration2.minutes,
+        u = _RoundDuration2.seconds,
+        h = _RoundDuration2.milliseconds,
+        c = _RoundDuration2.microseconds,
+        m = _RoundDuration2.nanoseconds,
+        BalanceDuration(0, l, d, u, h, c, m, a);
+}
+function DifferenceISODateTime
+(e, t, r, o, n, a, i, s, l, d, m, c, h, u, T, p, f, y, I, S, g){
+ var _BalanceISODate2, _BalanceDuration, _BalanceDuration2;
+ var
+  w = e,
+  D = t,
+  G = r,
+  _DifferenceTime = DifferenceTime(o, n, a, i, s, l, h, u, T, p, f, y),
+  v = _DifferenceTime.hours,
+  C = _DifferenceTime.minutes,
+  O = _DifferenceTime.seconds,
+  b = _DifferenceTime.milliseconds,
+  E = _DifferenceTime.microseconds,
+  M = _DifferenceTime.nanoseconds;
+ var R = DurationSign(0, 0, 0, 0, v, C, O, b, E, M);
+ CompareISODate(d, m, c, w, D, G) === - R
+ &&
+  (_BalanceISODate2 = BalanceISODate(w, D, G - R),
+   w = _BalanceISODate2.year,
+   D = _BalanceISODate2.month,
+   G = _BalanceISODate2.day,
+   _BalanceDuration = BalanceDuration(- R, v, C, O, b, E, M, S),
+   v = _BalanceDuration.hours,
+   C = _BalanceDuration.minutes,
+   O = _BalanceDuration.seconds,
+   b = _BalanceDuration.milliseconds,
+   E = _BalanceDuration.microseconds,
+   M = _BalanceDuration.nanoseconds);
+ var
+  F = CreateTemporalDate(w, D, G, I),
+  Y = CreateTemporalDate(d, m, c, I),
+  P = LargerOfTwoTemporalUnits("day", S),
+  Z = CopyOptions(g);
+ Z.largestUnit = P;
+ var
+  _CalendarDateUntil = CalendarDateUntil(I, F, Y, Z),
+  B = _CalendarDateUntil.years,
+  N = _CalendarDateUntil.months,
+  j = _CalendarDateUntil.weeks,
+  $ = _CalendarDateUntil.days;
+ return _BalanceDuration2 = BalanceDuration($, v, C, O, b, E, M, S),
+        $ = _BalanceDuration2.days,
+        v = _BalanceDuration2.hours,
+        C = _BalanceDuration2.minutes,
+        O = _BalanceDuration2.seconds,
+        b = _BalanceDuration2.milliseconds,
+        E = _BalanceDuration2.microseconds,
+        M = _BalanceDuration2.nanoseconds,
+        {years: B,
+         months: N,
+         weeks: j,
+         days: $,
+         hours: v,
+         minutes: C,
+         seconds: O,
+         milliseconds: b,
+         microseconds: E,
+         nanoseconds: M};
+}
+function DifferenceZonedDateTime(t, r, o, n, a, p){
+ var f = r - t;
+ if(f === Ie)
+  return {years: 0,
           months: 0,
           weeks: 0,
-          days: 0
-        } : {
-          years: 0,
-          months: 12 * _m3,
-          weeks: 0,
-          days: 0
-        };
-        var _u = _d3.month - _l3.month;
-        if (_h !== _s2 && (_m3 -= _s2, _u += 12 * _s2), _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"), _h = -CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a), 0 === _h) return "year" === i ? {
-          years: _m3,
-          months: _u,
-          weeks: 0,
-          days: 0
-        } : {
-          years: 0,
-          months: _u + 12 * _m3,
-          weeks: 0,
-          days: 0
-        };
-        _h !== _s2 && (_u -= _s2, _u === -_s2 && (_m3 -= _s2, _u = 11 * _s2), _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"));
-        var _T = 0;
-        return _T = _c3.month === _d3.month ? _d3.day - _c3.day : _s2 < 0 ? -_c3.day - (ISODaysInMonth(_d3.year, _d3.month) - _d3.day) : _d3.day + (ISODaysInMonth(_c3.year, _c3.month) - _c3.day), "month" === i && (_u += 12 * _m3, _m3 = 0), {
-          years: _m3,
-          months: _u,
-          weeks: 0,
-          days: _T
-        };
-      }
-    case "week":
-    case "day":
-      {
-        var _s3, _l4, _d4;
-        CompareISODate(e, t, r, o, n, a) < 0 ? (_l4 = {
-          year: e,
-          month: t,
-          day: r
-        }, _s3 = {
-          year: o,
-          month: n,
-          day: a
-        }, _d4 = 1) : (_l4 = {
-          year: o,
-          month: n,
-          day: a
-        }, _s3 = {
-          year: e,
-          month: t,
-          day: r
-        }, _d4 = -1);
-        var _m4 = DayOfYear(_s3.year, _s3.month, _s3.day) - DayOfYear(_l4.year, _l4.month, _l4.day);
-        for (var _e27 = _l4.year; _e27 < _s3.year; ++_e27) _m4 += LeapYear(_e27) ? 366 : 365;
-        var _c4 = 0;
-        return "week" === i && (_c4 = ie(_m4 / 7), _m4 %= 7), _c4 *= _d4, _m4 *= _d4, {
-          years: 0,
-          months: 0,
-          weeks: _c4,
-          days: _m4
-        };
-      }
-    default:
-      throw new Error("assert not reached");
-  }
-}
-function DifferenceTime(e, t, r, o, n, a, i, s, l, d, m, c) {
-  var _BalanceTime2;
-  var h = i - e,
-    u = s - t,
-    T = l - r,
-    p = d - o,
-    f = m - n,
-    y = c - a;
-  var I = DurationSign(0, 0, 0, 0, h, u, T, p, f, y);
-  h *= I, u *= I, T *= I, p *= I, f *= I, y *= I;
-  var S = 0;
-  if ((_BalanceTime2 = BalanceTime(h, u, T, p, f, y), S = _BalanceTime2.deltaDays, h = _BalanceTime2.hour, u = _BalanceTime2.minute, T = _BalanceTime2.second, p = _BalanceTime2.millisecond, f = _BalanceTime2.microsecond, y = _BalanceTime2.nanosecond), 0 != S) throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
-  return h *= I, u *= I, T *= I, p *= I, f *= I, y *= I, {
-    hours: h,
-    minutes: u,
-    seconds: T,
-    milliseconds: p,
-    microseconds: f,
-    nanoseconds: y
-  };
-}
-function DifferenceInstant(t, r, o, n, a, i) {
-  var _RoundDuration2;
-  var s = r - t;
-  var l = 0,
-    d = 0,
-    m = Number(s % De),
-    c = Number(s / De % De),
-    h = Number(s / Ge % De),
-    u = Number(s / ve);
-  return (_RoundDuration2 = RoundDuration(0, 0, 0, 0, 0, 0, u, h, c, m, o, n, i), l = _RoundDuration2.hours, d = _RoundDuration2.minutes, u = _RoundDuration2.seconds, h = _RoundDuration2.milliseconds, c = _RoundDuration2.microseconds, m = _RoundDuration2.nanoseconds), BalanceDuration(0, l, d, u, h, c, m, a);
-}
-function DifferenceISODateTime(e, t, r, o, n, a, i, s, l, d, m, c, h, u, T, p, f, y, I, S, g) {
-  var _BalanceISODate2, _BalanceDuration, _BalanceDuration2;
-  var w = e,
-    D = t,
-    G = r,
-    _DifferenceTime = DifferenceTime(o, n, a, i, s, l, h, u, T, p, f, y),
-    v = _DifferenceTime.hours,
-    C = _DifferenceTime.minutes,
-    O = _DifferenceTime.seconds,
-    b = _DifferenceTime.milliseconds,
-    E = _DifferenceTime.microseconds,
-    M = _DifferenceTime.nanoseconds;
-  var R = DurationSign(0, 0, 0, 0, v, C, O, b, E, M);
-  CompareISODate(d, m, c, w, D, G) === -R && ((_BalanceISODate2 = BalanceISODate(w, D, G - R), w = _BalanceISODate2.year, D = _BalanceISODate2.month, G = _BalanceISODate2.day), (_BalanceDuration = BalanceDuration(-R, v, C, O, b, E, M, S), v = _BalanceDuration.hours, C = _BalanceDuration.minutes, O = _BalanceDuration.seconds, b = _BalanceDuration.milliseconds, E = _BalanceDuration.microseconds, M = _BalanceDuration.nanoseconds));
-  var F = CreateTemporalDate(w, D, G, I),
-    Y = CreateTemporalDate(d, m, c, I),
-    P = LargerOfTwoTemporalUnits("day", S),
-    Z = CopyOptions(g);
-  Z.largestUnit = P;
-  var _CalendarDateUntil = CalendarDateUntil(I, F, Y, Z),
-    B = _CalendarDateUntil.years,
-    N = _CalendarDateUntil.months,
-    j = _CalendarDateUntil.weeks,
-    $ = _CalendarDateUntil.days;
-  return (_BalanceDuration2 = BalanceDuration($, v, C, O, b, E, M, S), $ = _BalanceDuration2.days, v = _BalanceDuration2.hours, C = _BalanceDuration2.minutes, O = _BalanceDuration2.seconds, b = _BalanceDuration2.milliseconds, E = _BalanceDuration2.microseconds, M = _BalanceDuration2.nanoseconds), {
-    years: B,
-    months: N,
-    weeks: j,
-    days: $,
-    hours: v,
-    minutes: C,
-    seconds: O,
-    milliseconds: b,
-    microseconds: E,
-    nanoseconds: M
-  };
-}
-function DifferenceZonedDateTime(t, r, o, n, a, p) {
-  var f = r - t;
-  if (f === Ie) return {
-    years: 0,
-    months: 0,
-    weeks: 0,
-    days: 0,
-    hours: 0,
-    minutes: 0,
-    seconds: 0,
-    milliseconds: 0,
-    microseconds: 0,
-    nanoseconds: 0
-  };
-  var y = GetIntrinsic("%Temporal.Instant%"),
-    I = new y(t),
-    S = new y(r),
-    g = GetPlainDateTimeFor(o, I, n),
-    w = GetPlainDateTimeFor(o, S, n);
-  var _DifferenceISODateTim2 = DifferenceISODateTime(GetSlot(g, i), GetSlot(g, s), GetSlot(g, l), GetSlot(g, d), GetSlot(g, m), GetSlot(g, c), GetSlot(g, h), GetSlot(g, u), GetSlot(g, T), GetSlot(w, i), GetSlot(w, s), GetSlot(w, l), GetSlot(w, d), GetSlot(w, m), GetSlot(w, c), GetSlot(w, h), GetSlot(w, u), GetSlot(w, T), n, a, p),
-    D = _DifferenceISODateTim2.years,
-    G = _DifferenceISODateTim2.months,
-    v = _DifferenceISODateTim2.weeks,
-    C = _DifferenceISODateTim2.days;
-  var O = AddZonedDateTime(I, o, n, D, G, v, 0, 0, 0, 0, 0, 0, 0);
-  var b = r - O;
-  var E = CreateTemporalZonedDateTime(O, o, n);
-  var _NanosecondsToDays2 = NanosecondsToDays(b, E);
-  b = _NanosecondsToDays2.nanoseconds;
-  C = _NanosecondsToDays2.days;
-  var _BalanceDuration3 = BalanceDuration(0, 0, 0, 0, 0, 0, Number(b), "hour"),
-    M = _BalanceDuration3.hours,
-    R = _BalanceDuration3.minutes,
-    F = _BalanceDuration3.seconds,
-    Y = _BalanceDuration3.milliseconds,
-    P = _BalanceDuration3.microseconds,
-    Z = _BalanceDuration3.nanoseconds;
-  return {
-    years: D,
-    months: G,
-    weeks: v,
-    days: C,
-    hours: M,
-    minutes: R,
-    seconds: F,
-    milliseconds: Y,
-    microseconds: P,
-    nanoseconds: Z
-  };
-}
-function GetDifferenceSettings(e, t, r, o, n, a) {
-  var i = Ue.reduce(function (e, t) {
-    var n = t[0],
-      a = t[1],
-      i = t[2];
-    return "datetime" !== r && i !== r || o.includes(a) || e.push(a, n), e;
-  }, []);
-  var s = GetTemporalUnit(t, "largestUnit", r, "auto");
-  if (o.includes(s)) throw new RangeError("largestUnit must be one of ".concat(i.join(", "), ", not ").concat(s));
-  var l = ToTemporalRoundingIncrement(t);
-  var d = ToTemporalRoundingMode(t, "trunc");
-  "since" === e && (d = function NegateTemporalRoundingMode(e) {
-    switch (e) {
-      case "ceil":
+          days: 0,
+          hours: 0,
+          minutes: 0,
+          seconds: 0,
+          milliseconds: 0,
+          microseconds: 0,
+          nanoseconds: 0};
+ var
+  y = GetIntrinsic("%Temporal.Instant%"),
+  I = new y(t),
+  S = new y(r),
+  g = GetPlainDateTimeFor(o, I, n),
+  w = GetPlainDateTimeFor(o, S, n);
+ var
+  _DifferenceISODateTim2 =
+    DifferenceISODateTime
+     (GetSlot(g, i),
+      GetSlot(g, s),
+      GetSlot(g, l),
+      GetSlot(g, d),
+      GetSlot(g, m),
+      GetSlot(g, c),
+      GetSlot(g, h),
+      GetSlot(g, u),
+      GetSlot(g, T),
+      GetSlot(w, i),
+      GetSlot(w, s),
+      GetSlot(w, l),
+      GetSlot(w, d),
+      GetSlot(w, m),
+      GetSlot(w, c),
+      GetSlot(w, h),
+      GetSlot(w, u),
+      GetSlot(w, T),
+      n,
+      a,
+      p),
+  D = _DifferenceISODateTim2.years,
+  G = _DifferenceISODateTim2.months,
+  v = _DifferenceISODateTim2.weeks,
+  C = _DifferenceISODateTim2.days;
+ var O = AddZonedDateTime(I, o, n, D, G, v, 0, 0, 0, 0, 0, 0, 0);
+ var b = r - O;
+ var E = CreateTemporalZonedDateTime(O, o, n);
+ var _NanosecondsToDays2 = NanosecondsToDays(b, E);
+ b = _NanosecondsToDays2.nanoseconds;
+ C = _NanosecondsToDays2.days;
+ var
+  _BalanceDuration3 = BalanceDuration(0, 0, 0, 0, 0, 0, Number(b), "hour"),
+  M = _BalanceDuration3.hours,
+  R = _BalanceDuration3.minutes,
+  F = _BalanceDuration3.seconds,
+  Y = _BalanceDuration3.milliseconds,
+  P = _BalanceDuration3.microseconds,
+  Z = _BalanceDuration3.nanoseconds;
+ return {years: D,
+         months: G,
+         weeks: v,
+         days: C,
+         hours: M,
+         minutes: R,
+         seconds: F,
+         milliseconds: Y,
+         microseconds: P,
+         nanoseconds: Z};
+}
+function GetDifferenceSettings(e, t, r, o, n, a){
+ var
+  i =
+    Ue.reduce
+     (function(e, t){
+       var n = t[0], a = t[1], i = t[2];
+       return "datetime" !== r && i !== r || o.includes(a) || e.push(a, n), e;
+      },
+      []);
+ var s = GetTemporalUnit(t, "largestUnit", r, "auto");
+ if(o.includes(s))
+  throw new
+         RangeError
+         ("largestUnit must be one of ".concat(i.join(", "), ", not ").concat
+           (s));
+ var l = ToTemporalRoundingIncrement(t);
+ var d = ToTemporalRoundingMode(t, "trunc");
+ "since" === e
+ &&
+  (d =
+   function NegateTemporalRoundingMode(e){
+     switch(e){
+       case "ceil":
         return "floor";
-      case "floor":
+       case "floor":
         return "ceil";
-      case "halfCeil":
+       case "halfCeil":
         return "halfFloor";
-      case "halfFloor":
+       case "halfFloor":
         return "halfCeil";
-      default:
-        return e;
+       default: return e;
+     }
     }
-  }(d));
-  var m = GetTemporalUnit(t, "smallestUnit", r, n);
-  if (o.includes(m)) throw new RangeError("smallestUnit must be one of ".concat(i.join(", "), ", not ").concat(m));
-  var c = LargerOfTwoTemporalUnits(a, m);
-  if ("auto" === s && (s = c), LargerOfTwoTemporalUnits(s, m) !== s) throw new RangeError("largestUnit ".concat(s, " cannot be smaller than smallestUnit ").concat(m));
-  var h = {
-    hour: 24,
-    minute: 60,
-    second: 60,
-    millisecond: 1e3,
-    microsecond: 1e3,
-    nanosecond: 1e3
-  }[m];
-  return void 0 !== h && ValidateTemporalRoundingIncrement(l, h, !1), {
-    largestUnit: s,
-    roundingIncrement: l,
-    roundingMode: d,
-    smallestUnit: m
-  };
-}
-function DifferenceTemporalInstant(e, t, r, o) {
-  var a = "since" === e ? -1 : 1,
-    i = ToTemporalInstant(r),
-    s = GetDifferenceSettings(e, CopyOptions(o), "time", [], "nanosecond", "second"),
-    l = GetSlot(t, n),
-    d = GetSlot(i, n);
-  var _DifferenceInstant = DifferenceInstant(l, d, s.roundingIncrement, s.smallestUnit, s.largestUnit, s.roundingMode),
-    m = _DifferenceInstant.hours,
-    c = _DifferenceInstant.minutes,
-    h = _DifferenceInstant.seconds,
-    u = _DifferenceInstant.milliseconds,
-    T = _DifferenceInstant.microseconds,
-    p = _DifferenceInstant.nanoseconds;
-  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, a * m, a * c, a * h, a * u, a * T, a * p);
-}
-function DifferenceTemporalPlainDate(e, t, r, o) {
-  var _RoundDuration3;
-  var n = "since" === e ? -1 : 1,
-    a = ToTemporalDate(r),
-    i = GetSlot(t, p);
-  ThrowIfCalendarsNotEqual(i, GetSlot(a, p), "compute difference between dates");
-  var s = CopyOptions(o),
-    l = GetDifferenceSettings(e, s, "date", [], "day", "day");
-  s.largestUnit = l.largestUnit;
-  var _CalendarDateUntil2 = CalendarDateUntil(i, t, a, s),
-    d = _CalendarDateUntil2.years,
-    m = _CalendarDateUntil2.months,
-    c = _CalendarDateUntil2.weeks,
-    h = _CalendarDateUntil2.days;
-  "day" === l.smallestUnit && 1 === l.roundingIncrement || (_RoundDuration3 = RoundDuration(d, m, c, h, 0, 0, 0, 0, 0, 0, l.roundingIncrement, l.smallestUnit, l.roundingMode, t), d = _RoundDuration3.years, m = _RoundDuration3.months, c = _RoundDuration3.weeks, h = _RoundDuration3.days, _RoundDuration3);
-  return new (GetIntrinsic("%Temporal.Duration%"))(n * d, n * m, n * c, n * h, 0, 0, 0, 0, 0, 0);
-}
-function DifferenceTemporalPlainDateTime(e, t, r, o) {
-  var _RoundDuration4, _BalanceDuration4;
-  var n = "since" === e ? -1 : 1,
-    a = ToTemporalDateTime(r),
-    f = GetSlot(t, p);
-  ThrowIfCalendarsNotEqual(f, GetSlot(a, p), "compute difference between dates");
-  var y = CopyOptions(o),
-    I = GetDifferenceSettings(e, y, "datetime", [], "nanosecond", "day");
-  var _DifferenceISODateTim3 = DifferenceISODateTime(GetSlot(t, i), GetSlot(t, s), GetSlot(t, l), GetSlot(t, d), GetSlot(t, m), GetSlot(t, c), GetSlot(t, h), GetSlot(t, u), GetSlot(t, T), GetSlot(a, i), GetSlot(a, s), GetSlot(a, l), GetSlot(a, d), GetSlot(a, m), GetSlot(a, c), GetSlot(a, h), GetSlot(a, u), GetSlot(a, T), f, I.largestUnit, y),
-    S = _DifferenceISODateTim3.years,
-    g = _DifferenceISODateTim3.months,
-    w = _DifferenceISODateTim3.weeks,
-    D = _DifferenceISODateTim3.days,
-    G = _DifferenceISODateTim3.hours,
-    v = _DifferenceISODateTim3.minutes,
-    C = _DifferenceISODateTim3.seconds,
-    O = _DifferenceISODateTim3.milliseconds,
-    b = _DifferenceISODateTim3.microseconds,
-    E = _DifferenceISODateTim3.nanoseconds;
-  var M = TemporalDateTimeToDate(t);
-  (_RoundDuration4 = RoundDuration(S, g, w, D, G, v, C, O, b, E, I.roundingIncrement, I.smallestUnit, I.roundingMode, M), S = _RoundDuration4.years, g = _RoundDuration4.months, w = _RoundDuration4.weeks, D = _RoundDuration4.days, G = _RoundDuration4.hours, v = _RoundDuration4.minutes, C = _RoundDuration4.seconds, O = _RoundDuration4.milliseconds, b = _RoundDuration4.microseconds, E = _RoundDuration4.nanoseconds), (_BalanceDuration4 = BalanceDuration(D, G, v, C, O, b, E, I.largestUnit), D = _BalanceDuration4.days, G = _BalanceDuration4.hours, v = _BalanceDuration4.minutes, C = _BalanceDuration4.seconds, O = _BalanceDuration4.milliseconds, b = _BalanceDuration4.microseconds, E = _BalanceDuration4.nanoseconds);
-  return new (GetIntrinsic("%Temporal.Duration%"))(n * S, n * g, n * w, n * D, n * G, n * v, n * C, n * O, n * b, n * E);
-}
-function DifferenceTemporalPlainTime(e, t, r, o) {
-  var _RoundDuration5, _BalanceDuration5;
-  var n = "since" === e ? -1 : 1,
-    a = ToTemporalTime(r),
-    i = GetDifferenceSettings(e, CopyOptions(o), "time", [], "nanosecond", "hour");
-  var _DifferenceTime2 = DifferenceTime(GetSlot(t, d), GetSlot(t, m), GetSlot(t, c), GetSlot(t, h), GetSlot(t, u), GetSlot(t, T), GetSlot(a, d), GetSlot(a, m), GetSlot(a, c), GetSlot(a, h), GetSlot(a, u), GetSlot(a, T)),
-    s = _DifferenceTime2.hours,
-    l = _DifferenceTime2.minutes,
-    p = _DifferenceTime2.seconds,
-    f = _DifferenceTime2.milliseconds,
-    y = _DifferenceTime2.microseconds,
-    I = _DifferenceTime2.nanoseconds;
-  (_RoundDuration5 = RoundDuration(0, 0, 0, 0, s, l, p, f, y, I, i.roundingIncrement, i.smallestUnit, i.roundingMode), s = _RoundDuration5.hours, l = _RoundDuration5.minutes, p = _RoundDuration5.seconds, f = _RoundDuration5.milliseconds, y = _RoundDuration5.microseconds, I = _RoundDuration5.nanoseconds), (_BalanceDuration5 = BalanceDuration(0, s, l, p, f, y, I, i.largestUnit), s = _BalanceDuration5.hours, l = _BalanceDuration5.minutes, p = _BalanceDuration5.seconds, f = _BalanceDuration5.milliseconds, y = _BalanceDuration5.microseconds, I = _BalanceDuration5.nanoseconds);
-  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n * s, n * l, n * p, n * f, n * y, n * I);
-}
-function DifferenceTemporalPlainYearMonth(e, t, r, o) {
-  var _RoundDuration6;
-  var n = "since" === e ? -1 : 1,
-    a = ToTemporalYearMonth(r),
-    i = GetSlot(t, p);
-  ThrowIfCalendarsNotEqual(i, GetSlot(a, p), "compute difference between months");
-  var s = CopyOptions(o),
-    l = GetDifferenceSettings(e, s, "date", ["week", "day"], "month", "year");
-  s.largestUnit = l.largestUnit;
-  var d = CalendarFields(i, ["monthCode", "year"]),
-    m = PrepareTemporalFields(t, d, []);
-  m.day = 1;
-  var c = CalendarDateFromFields(i, m),
-    h = PrepareTemporalFields(a, d, []);
-  h.day = 1;
-  var u = CalendarDateFromFields(i, h);
-  var _CalendarDateUntil3 = CalendarDateUntil(i, c, u, s),
-    T = _CalendarDateUntil3.years,
-    f = _CalendarDateUntil3.months;
-  "month" === l.smallestUnit && 1 === l.roundingIncrement || (_RoundDuration6 = RoundDuration(T, f, 0, 0, 0, 0, 0, 0, 0, 0, l.roundingIncrement, l.smallestUnit, l.roundingMode, c), T = _RoundDuration6.years, f = _RoundDuration6.months, _RoundDuration6);
-  return new (GetIntrinsic("%Temporal.Duration%"))(n * T, n * f, 0, 0, 0, 0, 0, 0, 0, 0);
-}
-function DifferenceTemporalZonedDateTime(e, t, r, o) {
-  var _DifferenceInstant2;
-  var a = "since" === e ? -1 : 1,
-    i = ToTemporalZonedDateTime(r),
-    s = GetSlot(t, p);
-  ThrowIfCalendarsNotEqual(s, GetSlot(i, p), "compute difference between dates");
-  var l = CopyOptions(o),
-    d = GetDifferenceSettings(e, l, "datetime", [], "nanosecond", "hour");
-  l.largestUnit = d.largestUnit;
-  var m = GetSlot(t, n),
-    c = GetSlot(i, n);
-  var h, u, T, f, y, I, S, w, D, G;
-  if ("year" !== d.largestUnit && "month" !== d.largestUnit && "week" !== d.largestUnit && "day" !== d.largestUnit) h = 0, u = 0, T = 0, f = 0, (_DifferenceInstant2 = DifferenceInstant(m, c, d.roundingIncrement, d.smallestUnit, d.largestUnit, d.roundingMode), y = _DifferenceInstant2.hours, I = _DifferenceInstant2.minutes, S = _DifferenceInstant2.seconds, w = _DifferenceInstant2.milliseconds, D = _DifferenceInstant2.microseconds, G = _DifferenceInstant2.nanoseconds);else {
-    var _DifferenceZonedDateT, _RoundDuration7, _AdjustRoundedDuratio;
-    var _e28 = GetSlot(t, g);
-    if (!TimeZoneEquals(_e28, GetSlot(i, g))) throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
-    (_DifferenceZonedDateT = DifferenceZonedDateTime(m, c, _e28, s, d.largestUnit, l), h = _DifferenceZonedDateT.years, u = _DifferenceZonedDateT.months, T = _DifferenceZonedDateT.weeks, f = _DifferenceZonedDateT.days, y = _DifferenceZonedDateT.hours, I = _DifferenceZonedDateT.minutes, S = _DifferenceZonedDateT.seconds, w = _DifferenceZonedDateT.milliseconds, D = _DifferenceZonedDateT.microseconds, G = _DifferenceZonedDateT.nanoseconds), (_RoundDuration7 = RoundDuration(h, u, T, f, y, I, S, w, D, G, d.roundingIncrement, d.smallestUnit, d.roundingMode, t), h = _RoundDuration7.years, u = _RoundDuration7.months, T = _RoundDuration7.weeks, f = _RoundDuration7.days, y = _RoundDuration7.hours, I = _RoundDuration7.minutes, S = _RoundDuration7.seconds, w = _RoundDuration7.milliseconds, D = _RoundDuration7.microseconds, G = _RoundDuration7.nanoseconds), (_AdjustRoundedDuratio = AdjustRoundedDurationDays(h, u, T, f, y, I, S, w, D, G, d.roundingIncrement, d.smallestUnit, d.roundingMode, t), h = _AdjustRoundedDuratio.years, u = _AdjustRoundedDuratio.months, T = _AdjustRoundedDuratio.weeks, f = _AdjustRoundedDuratio.days, y = _AdjustRoundedDuratio.hours, I = _AdjustRoundedDuratio.minutes, S = _AdjustRoundedDuratio.seconds, w = _AdjustRoundedDuratio.milliseconds, D = _AdjustRoundedDuratio.microseconds, G = _AdjustRoundedDuratio.nanoseconds);
-  }
-  return new (GetIntrinsic("%Temporal.Duration%"))(a * h, a * u, a * T, a * f, a * y, a * I, a * S, a * w, a * D, a * G);
-}
-function AddISODate(e, t, r, o, n, a, i, s) {
-  var _BalanceISOYearMonth4, _RegulateISODate, _BalanceISODate3;
-  var l = e,
-    d = t,
-    m = r,
-    c = a,
-    h = i;
-  return l += o, d += n, (_BalanceISOYearMonth4 = BalanceISOYearMonth(l, d), l = _BalanceISOYearMonth4.year, d = _BalanceISOYearMonth4.month), (_RegulateISODate = RegulateISODate(l, d, m, s), l = _RegulateISODate.year, d = _RegulateISODate.month, m = _RegulateISODate.day), h += 7 * c, m += h, (_BalanceISODate3 = BalanceISODate(l, d, m), l = _BalanceISODate3.year, d = _BalanceISODate3.month, m = _BalanceISODate3.day), {
-    year: l,
-    month: d,
-    day: m
-  };
-}
-function AddTime(e, t, r, o, n, a, i, s, l, d, m, c) {
-  var _BalanceTime3;
-  var h = e,
-    u = t,
-    T = r,
-    p = o,
-    f = n,
-    y = a;
-  h += i, u += s, T += l, p += d, f += m, y += c;
-  var I = 0;
-  return (_BalanceTime3 = BalanceTime(h, u, T, p, f, y), I = _BalanceTime3.deltaDays, h = _BalanceTime3.hour, u = _BalanceTime3.minute, T = _BalanceTime3.second, p = _BalanceTime3.millisecond, f = _BalanceTime3.microsecond, y = _BalanceTime3.nanosecond), {
-    deltaDays: I,
-    hour: h,
-    minute: u,
-    second: T,
-    millisecond: p,
-    microsecond: f,
-    nanosecond: y
-  };
-}
-function AddDuration(t, r, o, a, i, s, l, d, m, c, h, u, T, f, y, I, w, D, G, v, C) {
-  var O = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(t, r, o, a, i, s, l, d, m, c), DefaultTemporalLargestUnit(h, u, T, f, y, I, w, D, G, v));
-  var b, E, M, R, F, Y, P, Z, B, N;
-  if (C) {
-    if (IsTemporalDate(C)) {
-      var _CalendarDateUntil4, _BalanceDuration6;
-      var _n10 = GetIntrinsic("%Temporal.Duration%"),
-        _S2 = GetSlot(C, p),
-        _g = new _n10(t, r, o, a, 0, 0, 0, 0, 0, 0),
-        _j = new _n10(h, u, T, f, 0, 0, 0, 0, 0, 0),
-        _$ = "string" != typeof _S2 ? GetMethod(_S2, "dateAdd") : void 0,
-        _k = CalendarDateAdd(_S2, C, _g, void 0, _$),
-        _U = CalendarDateAdd(_S2, _k, _j, void 0, _$),
-        _A = LargerOfTwoTemporalUnits("day", O),
-        _L = Te(null);
-      _L.largestUnit = _A, (_CalendarDateUntil4 = CalendarDateUntil(_S2, C, _U, _L), b = _CalendarDateUntil4.years, E = _CalendarDateUntil4.months, M = _CalendarDateUntil4.weeks, R = _CalendarDateUntil4.days), (_BalanceDuration6 = BalanceDuration(R, BigInt(i) + BigInt(y), BigInt(s) + BigInt(I), BigInt(l) + BigInt(w), BigInt(d) + BigInt(D), BigInt(m) + BigInt(G), BigInt(c) + BigInt(v), O), R = _BalanceDuration6.days, F = _BalanceDuration6.hours, Y = _BalanceDuration6.minutes, P = _BalanceDuration6.seconds, Z = _BalanceDuration6.milliseconds, B = _BalanceDuration6.microseconds, N = _BalanceDuration6.nanoseconds);
-    } else {
-      var _DifferenceInstant3, _DifferenceZonedDateT2;
-      var _e29 = GetIntrinsic("%Temporal.Instant%"),
-        _j2 = GetSlot(C, g),
-        _$2 = GetSlot(C, p),
-        _k2 = AddZonedDateTime(GetSlot(C, S), _j2, _$2, t, r, o, a, i, s, l, d, m, c),
-        _U2 = AddZonedDateTime(new _e29(_k2), _j2, _$2, h, u, T, f, y, I, w, D, G, v);
-      "year" !== O && "month" !== O && "week" !== O && "day" !== O ? (b = 0, E = 0, M = 0, R = 0, (_DifferenceInstant3 = DifferenceInstant(GetSlot(C, n), _U2, 1, "nanosecond", O, "halfExpand"), F = _DifferenceInstant3.hours, Y = _DifferenceInstant3.minutes, P = _DifferenceInstant3.seconds, Z = _DifferenceInstant3.milliseconds, B = _DifferenceInstant3.microseconds, N = _DifferenceInstant3.nanoseconds)) : (_DifferenceZonedDateT2 = DifferenceZonedDateTime(GetSlot(C, n), _U2, _j2, _$2, O, Te(null)), b = _DifferenceZonedDateT2.years, E = _DifferenceZonedDateT2.months, M = _DifferenceZonedDateT2.weeks, R = _DifferenceZonedDateT2.days, F = _DifferenceZonedDateT2.hours, Y = _DifferenceZonedDateT2.minutes, P = _DifferenceZonedDateT2.seconds, Z = _DifferenceZonedDateT2.milliseconds, B = _DifferenceZonedDateT2.microseconds, N = _DifferenceZonedDateT2.nanoseconds, _DifferenceZonedDateT2);
-    }
-  } else {
-    var _BalanceDuration7;
-    if ("year" === O || "month" === O || "week" === O) throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
-    b = E = M = 0, (_BalanceDuration7 = BalanceDuration(a + f, BigInt(i) + BigInt(y), BigInt(s) + BigInt(I), BigInt(l) + BigInt(w), BigInt(d) + BigInt(D), BigInt(m) + BigInt(G), BigInt(c) + BigInt(v), O), R = _BalanceDuration7.days, F = _BalanceDuration7.hours, Y = _BalanceDuration7.minutes, P = _BalanceDuration7.seconds, Z = _BalanceDuration7.milliseconds, B = _BalanceDuration7.microseconds, N = _BalanceDuration7.nanoseconds);
-  }
-  return RejectDuration(b, E, M, R, F, Y, P, Z, B, N), {
-    years: b,
-    months: E,
-    weeks: M,
-    days: R,
-    hours: F,
-    minutes: Y,
-    seconds: P,
-    milliseconds: Z,
-    microseconds: B,
-    nanoseconds: N
-  };
-}
-function AddInstant(t, r, o, n, a, i, s) {
-  var l = Ie;
-  l = l + BigInt(s), l = l + BigInt(i) * De, l = l + BigInt(a) * Ge, l = l + BigInt(n) * ve, l = l + BigInt(o) * 60000000000n, l = l + BigInt(r) * 3600000000000n;
-  var d = t + l;
-  return ValidateEpochNanoseconds(d), d;
-}
-function AddDateTime(e, t, r, o, n, a, d, m, c, h, u, T, p, f, y, I, S, g, w, D, G) {
-  var v = f,
-    _AddTime = AddTime(o, n, a, d, m, c, y, I, S, g, w, D),
-    C = _AddTime.deltaDays,
-    O = _AddTime.hour,
-    b = _AddTime.minute,
-    E = _AddTime.second,
-    M = _AddTime.millisecond,
-    R = _AddTime.microsecond,
-    F = _AddTime.nanosecond;
-  v += C;
-  var Y = GetIntrinsic("%Temporal.Duration%"),
-    P = CalendarDateAdd(h, CreateTemporalDate(e, t, r, h), new Y(u, T, p, v, 0, 0, 0, 0, 0, 0), G);
-  return {
-    year: GetSlot(P, i),
-    month: GetSlot(P, s),
-    day: GetSlot(P, l),
-    hour: O,
-    minute: b,
-    second: E,
-    millisecond: M,
-    microsecond: R,
-    nanosecond: F
-  };
-}
-function AddZonedDateTime(e, t, r, o, a, p, f, y, I, S, g, w, D, G) {
-  var v = GetIntrinsic("%Temporal.Duration%");
-  if (0 === DurationSign(o, a, p, f, 0, 0, 0, 0, 0, 0)) return AddInstant(GetSlot(e, n), y, I, S, g, w, D);
-  var C = GetPlainDateTimeFor(t, e, r),
-    O = CalendarDateAdd(r, CreateTemporalDate(GetSlot(C, i), GetSlot(C, s), GetSlot(C, l), r), new v(o, a, p, f, 0, 0, 0, 0, 0, 0), G),
-    b = CreateTemporalDateTime(GetSlot(O, i), GetSlot(O, s), GetSlot(O, l), GetSlot(C, d), GetSlot(C, m), GetSlot(C, c), GetSlot(C, h), GetSlot(C, u), GetSlot(C, T), r);
-  return AddInstant(GetSlot(GetInstantFor(t, b, "compatible"), n), y, I, S, g, w, D);
-}
-function AddDurationToOrSubtractDurationFromDuration(e, t, r, o) {
-  var n = "subtract" === e ? -1 : 1;
-  var _ToTemporalDurationRe2 = ToTemporalDurationRecord(r),
-    a = _ToTemporalDurationRe2.years,
-    i = _ToTemporalDurationRe2.months,
-    s = _ToTemporalDurationRe2.weeks,
-    l = _ToTemporalDurationRe2.days,
-    d = _ToTemporalDurationRe2.hours,
-    m = _ToTemporalDurationRe2.minutes,
-    c = _ToTemporalDurationRe2.seconds,
-    h = _ToTemporalDurationRe2.milliseconds,
-    u = _ToTemporalDurationRe2.microseconds,
-    T = _ToTemporalDurationRe2.nanoseconds;
-  var p = ToRelativeTemporalObject(GetOptionsObject(o));
-  var _AddDuration = AddDuration(GetSlot(t, w), GetSlot(t, D), GetSlot(t, G), GetSlot(t, v), GetSlot(t, C), GetSlot(t, O), GetSlot(t, b), GetSlot(t, E), GetSlot(t, M), GetSlot(t, R), n * a, n * i, n * s, n * l, n * d, n * m, n * c, n * h, n * u, n * T, p);
-  a = _AddDuration.years;
-  i = _AddDuration.months;
-  s = _AddDuration.weeks;
-  l = _AddDuration.days;
-  d = _AddDuration.hours;
-  m = _AddDuration.minutes;
-  c = _AddDuration.seconds;
-  h = _AddDuration.milliseconds;
-  u = _AddDuration.microseconds;
-  T = _AddDuration.nanoseconds;
-  return new (GetIntrinsic("%Temporal.Duration%"))(a, i, s, l, d, m, c, h, u, T);
-}
-function AddDurationToOrSubtractDurationFromInstant(e, t, r) {
-  var o = "subtract" === e ? -1 : 1,
-    _ToLimitedTemporalDur = function ToLimitedTemporalDuration(e, t) {
+    (d));
+ var m = GetTemporalUnit(t, "smallestUnit", r, n);
+ if(o.includes(m))
+  throw new
+         RangeError
+         ("smallestUnit must be one of ".concat(i.join(", "), ", not ").concat
+           (m));
+ var c = LargerOfTwoTemporalUnits(a, m);
+ if("auto" === s && (s = c), LargerOfTwoTemporalUnits(s, m) !== s)
+  throw new
+         RangeError
+         ("largestUnit ".concat(s, " cannot be smaller than smallestUnit ").concat
+           (m));
+ var
+  h =
+    {hour: 24,
+      minute: 60,
+      second: 60,
+      millisecond: 1e3,
+      microsecond: 1e3,
+      nanosecond: 1e3}
+     [m];
+ return void 0 !== h && ValidateTemporalRoundingIncrement(l, h, ! 1),
+        {largestUnit: s,
+         roundingIncrement: l,
+         roundingMode: d,
+         smallestUnit: m};
+}
+function DifferenceTemporalInstant(e, t, r, o){
+ var
+  a = "since" === e ? - 1 : 1,
+  i = ToTemporalInstant(r),
+  s =
+    GetDifferenceSettings
+     (e, CopyOptions(o), "time", [], "nanosecond", "second"),
+  l = GetSlot(t, n),
+  d = GetSlot(i, n);
+ var
+  _DifferenceInstant =
+    DifferenceInstant
+     (l,
+      d,
+      s.roundingIncrement,
+      s.smallestUnit,
+      s.largestUnit,
+      s.roundingMode),
+  m = _DifferenceInstant.hours,
+  c = _DifferenceInstant.minutes,
+  h = _DifferenceInstant.seconds,
+  u = _DifferenceInstant.milliseconds,
+  T = _DifferenceInstant.microseconds,
+  p = _DifferenceInstant.nanoseconds;
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (0, 0, 0, 0, a * m, a * c, a * h, a * u, a * T, a * p);
+}
+function DifferenceTemporalPlainDate(e, t, r, o){
+ var _RoundDuration3;
+ var n = "since" === e ? - 1 : 1, a = ToTemporalDate(r), i = GetSlot(t, p);
+ ThrowIfCalendarsNotEqual
+  (i, GetSlot(a, p), "compute difference between dates");
+ var
+  s = CopyOptions(o),
+  l = GetDifferenceSettings(e, s, "date", [], "day", "day");
+ s.largestUnit = l.largestUnit;
+ var
+  _CalendarDateUntil2 = CalendarDateUntil(i, t, a, s),
+  d = _CalendarDateUntil2.years,
+  m = _CalendarDateUntil2.months,
+  c = _CalendarDateUntil2.weeks,
+  h = _CalendarDateUntil2.days;
+ "day" === l.smallestUnit && 1 === l.roundingIncrement
+ ||
+  (_RoundDuration3 =
+    RoundDuration
+     (d,
+      m,
+      c,
+      h,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      l.roundingIncrement,
+      l.smallestUnit,
+      l.roundingMode,
+      t),
+   d = _RoundDuration3.years,
+   m = _RoundDuration3.months,
+   c = _RoundDuration3.weeks,
+   h = _RoundDuration3.days,
+   _RoundDuration3);
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (n * d, n * m, n * c, n * h, 0, 0, 0, 0, 0, 0);
+}
+function DifferenceTemporalPlainDateTime(e, t, r, o){
+ var _RoundDuration4, _BalanceDuration4;
+ var
+  n = "since" === e ? - 1 : 1,
+  a = ToTemporalDateTime(r),
+  f = GetSlot(t, p);
+ ThrowIfCalendarsNotEqual
+  (f, GetSlot(a, p), "compute difference between dates");
+ var
+  y = CopyOptions(o),
+  I = GetDifferenceSettings(e, y, "datetime", [], "nanosecond", "day");
+ var
+  _DifferenceISODateTim3 =
+    DifferenceISODateTime
+     (GetSlot(t, i),
+      GetSlot(t, s),
+      GetSlot(t, l),
+      GetSlot(t, d),
+      GetSlot(t, m),
+      GetSlot(t, c),
+      GetSlot(t, h),
+      GetSlot(t, u),
+      GetSlot(t, T),
+      GetSlot(a, i),
+      GetSlot(a, s),
+      GetSlot(a, l),
+      GetSlot(a, d),
+      GetSlot(a, m),
+      GetSlot(a, c),
+      GetSlot(a, h),
+      GetSlot(a, u),
+      GetSlot(a, T),
+      f,
+      I.largestUnit,
+      y),
+  S = _DifferenceISODateTim3.years,
+  g = _DifferenceISODateTim3.months,
+  w = _DifferenceISODateTim3.weeks,
+  D = _DifferenceISODateTim3.days,
+  G = _DifferenceISODateTim3.hours,
+  v = _DifferenceISODateTim3.minutes,
+  C = _DifferenceISODateTim3.seconds,
+  O = _DifferenceISODateTim3.milliseconds,
+  b = _DifferenceISODateTim3.microseconds,
+  E = _DifferenceISODateTim3.nanoseconds;
+ var M = TemporalDateTimeToDate(t);
+ _RoundDuration4 =
+  RoundDuration
+   (S,
+    g,
+    w,
+    D,
+    G,
+    v,
+    C,
+    O,
+    b,
+    E,
+    I.roundingIncrement,
+    I.smallestUnit,
+    I.roundingMode,
+    M),
+ S = _RoundDuration4.years,
+ g = _RoundDuration4.months,
+ w = _RoundDuration4.weeks,
+ D = _RoundDuration4.days,
+ G = _RoundDuration4.hours,
+ v = _RoundDuration4.minutes,
+ C = _RoundDuration4.seconds,
+ O = _RoundDuration4.milliseconds,
+ b = _RoundDuration4.microseconds,
+ E = _RoundDuration4.nanoseconds,
+ _BalanceDuration4 = BalanceDuration(D, G, v, C, O, b, E, I.largestUnit),
+ D = _BalanceDuration4.days,
+ G = _BalanceDuration4.hours,
+ v = _BalanceDuration4.minutes,
+ C = _BalanceDuration4.seconds,
+ O = _BalanceDuration4.milliseconds,
+ b = _BalanceDuration4.microseconds,
+ E = _BalanceDuration4.nanoseconds;
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (n * S,
+          n * g,
+          n * w,
+          n * D,
+          n * G,
+          n * v,
+          n * C,
+          n * O,
+          n * b,
+          n * E);
+}
+function DifferenceTemporalPlainTime(e, t, r, o){
+ var _RoundDuration5, _BalanceDuration5;
+ var
+  n = "since" === e ? - 1 : 1,
+  a = ToTemporalTime(r),
+  i =
+    GetDifferenceSettings(e, CopyOptions(o), "time", [], "nanosecond", "hour");
+ var
+  _DifferenceTime2 =
+    DifferenceTime
+     (GetSlot(t, d),
+      GetSlot(t, m),
+      GetSlot(t, c),
+      GetSlot(t, h),
+      GetSlot(t, u),
+      GetSlot(t, T),
+      GetSlot(a, d),
+      GetSlot(a, m),
+      GetSlot(a, c),
+      GetSlot(a, h),
+      GetSlot(a, u),
+      GetSlot(a, T)),
+  s = _DifferenceTime2.hours,
+  l = _DifferenceTime2.minutes,
+  p = _DifferenceTime2.seconds,
+  f = _DifferenceTime2.milliseconds,
+  y = _DifferenceTime2.microseconds,
+  I = _DifferenceTime2.nanoseconds;
+ _RoundDuration5 =
+  RoundDuration
+   (0,
+    0,
+    0,
+    0,
+    s,
+    l,
+    p,
+    f,
+    y,
+    I,
+    i.roundingIncrement,
+    i.smallestUnit,
+    i.roundingMode),
+ s = _RoundDuration5.hours,
+ l = _RoundDuration5.minutes,
+ p = _RoundDuration5.seconds,
+ f = _RoundDuration5.milliseconds,
+ y = _RoundDuration5.microseconds,
+ I = _RoundDuration5.nanoseconds,
+ _BalanceDuration5 = BalanceDuration(0, s, l, p, f, y, I, i.largestUnit),
+ s = _BalanceDuration5.hours,
+ l = _BalanceDuration5.minutes,
+ p = _BalanceDuration5.seconds,
+ f = _BalanceDuration5.milliseconds,
+ y = _BalanceDuration5.microseconds,
+ I = _BalanceDuration5.nanoseconds;
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (0, 0, 0, 0, n * s, n * l, n * p, n * f, n * y, n * I);
+}
+function DifferenceTemporalPlainYearMonth(e, t, r, o){
+ var _RoundDuration6;
+ var
+  n = "since" === e ? - 1 : 1,
+  a = ToTemporalYearMonth(r),
+  i = GetSlot(t, p);
+ ThrowIfCalendarsNotEqual
+  (i, GetSlot(a, p), "compute difference between months");
+ var
+  s = CopyOptions(o),
+  l = GetDifferenceSettings(e, s, "date", ["week", "day"], "month", "year");
+ s.largestUnit = l.largestUnit;
+ var
+  d = CalendarFields(i, ["monthCode", "year"]),
+  m = PrepareTemporalFields(t, d, []);
+ m.day = 1;
+ var c = CalendarDateFromFields(i, m), h = PrepareTemporalFields(a, d, []);
+ h.day = 1;
+ var u = CalendarDateFromFields(i, h);
+ var
+  _CalendarDateUntil3 = CalendarDateUntil(i, c, u, s),
+  T = _CalendarDateUntil3.years,
+  f = _CalendarDateUntil3.months;
+ "month" === l.smallestUnit && 1 === l.roundingIncrement
+ ||
+  (_RoundDuration6 =
+    RoundDuration
+     (T,
+      f,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      l.roundingIncrement,
+      l.smallestUnit,
+      l.roundingMode,
+      c),
+   T = _RoundDuration6.years,
+   f = _RoundDuration6.months,
+   _RoundDuration6);
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (n * T, n * f, 0, 0, 0, 0, 0, 0, 0, 0);
+}
+function DifferenceTemporalZonedDateTime(e, t, r, o){
+ var _DifferenceInstant2;
+ var
+  a = "since" === e ? - 1 : 1,
+  i = ToTemporalZonedDateTime(r),
+  s = GetSlot(t, p);
+ ThrowIfCalendarsNotEqual
+  (s, GetSlot(i, p), "compute difference between dates");
+ var
+  l = CopyOptions(o),
+  d = GetDifferenceSettings(e, l, "datetime", [], "nanosecond", "hour");
+ l.largestUnit = d.largestUnit;
+ var m = GetSlot(t, n), c = GetSlot(i, n);
+ var h, u, T, f, y, I, S, w, D, G;
+ if
+  ("year" !== d.largestUnit && "month" !== d.largestUnit
+   && "week" !== d.largestUnit
+   && "day" !== d.largestUnit)
+  h = 0,
+  u = 0,
+  T = 0,
+  f = 0,
+  _DifferenceInstant2 =
+   DifferenceInstant
+    (m, c, d.roundingIncrement, d.smallestUnit, d.largestUnit, d.roundingMode),
+  y = _DifferenceInstant2.hours,
+  I = _DifferenceInstant2.minutes,
+  S = _DifferenceInstant2.seconds,
+  w = _DifferenceInstant2.milliseconds,
+  D = _DifferenceInstant2.microseconds,
+  G = _DifferenceInstant2.nanoseconds;
+ else{
+  var _DifferenceZonedDateT, _RoundDuration7, _AdjustRoundedDuratio;
+  var _e28 = GetSlot(t, g);
+  if(! TimeZoneEquals(_e28, GetSlot(i, g)))
+   throw new
+          RangeError
+          ("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
+  _DifferenceZonedDateT =
+   DifferenceZonedDateTime(m, c, _e28, s, d.largestUnit, l),
+  h = _DifferenceZonedDateT.years,
+  u = _DifferenceZonedDateT.months,
+  T = _DifferenceZonedDateT.weeks,
+  f = _DifferenceZonedDateT.days,
+  y = _DifferenceZonedDateT.hours,
+  I = _DifferenceZonedDateT.minutes,
+  S = _DifferenceZonedDateT.seconds,
+  w = _DifferenceZonedDateT.milliseconds,
+  D = _DifferenceZonedDateT.microseconds,
+  G = _DifferenceZonedDateT.nanoseconds,
+  _RoundDuration7 =
+   RoundDuration
+    (h,
+     u,
+     T,
+     f,
+     y,
+     I,
+     S,
+     w,
+     D,
+     G,
+     d.roundingIncrement,
+     d.smallestUnit,
+     d.roundingMode,
+     t),
+  h = _RoundDuration7.years,
+  u = _RoundDuration7.months,
+  T = _RoundDuration7.weeks,
+  f = _RoundDuration7.days,
+  y = _RoundDuration7.hours,
+  I = _RoundDuration7.minutes,
+  S = _RoundDuration7.seconds,
+  w = _RoundDuration7.milliseconds,
+  D = _RoundDuration7.microseconds,
+  G = _RoundDuration7.nanoseconds,
+  _AdjustRoundedDuratio =
+   AdjustRoundedDurationDays
+    (h,
+     u,
+     T,
+     f,
+     y,
+     I,
+     S,
+     w,
+     D,
+     G,
+     d.roundingIncrement,
+     d.smallestUnit,
+     d.roundingMode,
+     t),
+  h = _AdjustRoundedDuratio.years,
+  u = _AdjustRoundedDuratio.months,
+  T = _AdjustRoundedDuratio.weeks,
+  f = _AdjustRoundedDuratio.days,
+  y = _AdjustRoundedDuratio.hours,
+  I = _AdjustRoundedDuratio.minutes,
+  S = _AdjustRoundedDuratio.seconds,
+  w = _AdjustRoundedDuratio.milliseconds,
+  D = _AdjustRoundedDuratio.microseconds,
+  G = _AdjustRoundedDuratio.nanoseconds;
+ }
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (a * h,
+          a * u,
+          a * T,
+          a * f,
+          a * y,
+          a * I,
+          a * S,
+          a * w,
+          a * D,
+          a * G);
+}
+function AddISODate(e, t, r, o, n, a, i, s){
+ var _BalanceISOYearMonth4, _RegulateISODate, _BalanceISODate3;
+ var l = e, d = t, m = r, c = a, h = i;
+ return l += o,
+        d += n,
+        _BalanceISOYearMonth4 = BalanceISOYearMonth(l, d),
+        l = _BalanceISOYearMonth4.year,
+        d = _BalanceISOYearMonth4.month,
+        _RegulateISODate = RegulateISODate(l, d, m, s),
+        l = _RegulateISODate.year,
+        d = _RegulateISODate.month,
+        m = _RegulateISODate.day,
+        h += 7 * c,
+        m += h,
+        _BalanceISODate3 = BalanceISODate(l, d, m),
+        l = _BalanceISODate3.year,
+        d = _BalanceISODate3.month,
+        m = _BalanceISODate3.day,
+        {year: l, month: d, day: m};
+}
+function AddTime(e, t, r, o, n, a, i, s, l, d, m, c){
+ var _BalanceTime3;
+ var h = e, u = t, T = r, p = o, f = n, y = a;
+ h += i, u += s, T += l, p += d, f += m, y += c;
+ var I = 0;
+ return _BalanceTime3 = BalanceTime(h, u, T, p, f, y),
+        I = _BalanceTime3.deltaDays,
+        h = _BalanceTime3.hour,
+        u = _BalanceTime3.minute,
+        T = _BalanceTime3.second,
+        p = _BalanceTime3.millisecond,
+        f = _BalanceTime3.microsecond,
+        y = _BalanceTime3.nanosecond,
+        {deltaDays: I,
+         hour: h,
+         minute: u,
+         second: T,
+         millisecond: p,
+         microsecond: f,
+         nanosecond: y};
+}
+function AddDuration
+(t, r, o, a, i, s, l, d, m, c, h, u, T, f, y, I, w, D, G, v, C){
+ var
+  O =
+    LargerOfTwoTemporalUnits
+     (DefaultTemporalLargestUnit(t, r, o, a, i, s, l, d, m, c),
+      DefaultTemporalLargestUnit(h, u, T, f, y, I, w, D, G, v));
+ var b, E, M, R, F, Y, P, Z, B, N;
+ if(C){
+  if(IsTemporalDate(C)){
+   var _CalendarDateUntil4, _BalanceDuration6;
+   var
+    _n10 = GetIntrinsic("%Temporal.Duration%"),
+    _S2 = GetSlot(C, p),
+    _g = new _n10(t, r, o, a, 0, 0, 0, 0, 0, 0),
+    _j = new _n10(h, u, T, f, 0, 0, 0, 0, 0, 0),
+    _$ = "string" != typeof _S2 ? GetMethod(_S2, "dateAdd") : void 0,
+    _k = CalendarDateAdd(_S2, C, _g, void 0, _$),
+    _U = CalendarDateAdd(_S2, _k, _j, void 0, _$),
+    _A = LargerOfTwoTemporalUnits("day", O),
+    _L = Te(null);
+   _L.largestUnit = _A,
+   _CalendarDateUntil4 = CalendarDateUntil(_S2, C, _U, _L),
+   b = _CalendarDateUntil4.years,
+   E = _CalendarDateUntil4.months,
+   M = _CalendarDateUntil4.weeks,
+   R = _CalendarDateUntil4.days,
+   _BalanceDuration6 =
+    BalanceDuration
+     (R,
+      BigInt(i) + BigInt(y),
+      BigInt(s) + BigInt(I),
+      BigInt(l) + BigInt(w),
+      BigInt(d) + BigInt(D),
+      BigInt(m) + BigInt(G),
+      BigInt(c) + BigInt(v),
+      O),
+   R = _BalanceDuration6.days,
+   F = _BalanceDuration6.hours,
+   Y = _BalanceDuration6.minutes,
+   P = _BalanceDuration6.seconds,
+   Z = _BalanceDuration6.milliseconds,
+   B = _BalanceDuration6.microseconds,
+   N = _BalanceDuration6.nanoseconds;
+  }
+  else{
+   var _DifferenceInstant3, _DifferenceZonedDateT2;
+   var
+    _e29 = GetIntrinsic("%Temporal.Instant%"),
+    _j2 = GetSlot(C, g),
+    _$2 = GetSlot(C, p),
+    _k2 =
+      AddZonedDateTime(GetSlot(C, S), _j2, _$2, t, r, o, a, i, s, l, d, m, c),
+    _U2 =
+      AddZonedDateTime(new _e29(_k2), _j2, _$2, h, u, T, f, y, I, w, D, G, v);
+   "year" !== O && "month" !== O && "week" !== O && "day" !== O
+    ? (b
+      = 0,
+      E = 0,
+      M = 0,
+      R = 0,
+      _DifferenceInstant3 =
+       DifferenceInstant(GetSlot(C, n), _U2, 1, "nanosecond", O, "halfExpand"),
+      F = _DifferenceInstant3.hours,
+      Y = _DifferenceInstant3.minutes,
+      P = _DifferenceInstant3.seconds,
+      Z = _DifferenceInstant3.milliseconds,
+      B = _DifferenceInstant3.microseconds,
+      N = _DifferenceInstant3.nanoseconds)
+    : (_DifferenceZonedDateT2
+      = DifferenceZonedDateTime(GetSlot(C, n), _U2, _j2, _$2, O, Te(null)),
+      b = _DifferenceZonedDateT2.years,
+      E = _DifferenceZonedDateT2.months,
+      M = _DifferenceZonedDateT2.weeks,
+      R = _DifferenceZonedDateT2.days,
+      F = _DifferenceZonedDateT2.hours,
+      Y = _DifferenceZonedDateT2.minutes,
+      P = _DifferenceZonedDateT2.seconds,
+      Z = _DifferenceZonedDateT2.milliseconds,
+      B = _DifferenceZonedDateT2.microseconds,
+      N = _DifferenceZonedDateT2.nanoseconds,
+      _DifferenceZonedDateT2);
+  }
+ }
+ else{
+  var _BalanceDuration7;
+  if("year" === O || "month" === O || "week" === O)
+   throw new
+          RangeError
+          ("relativeTo is required for years, months, or weeks arithmetic");
+  b = E = M = 0,
+  _BalanceDuration7 =
+   BalanceDuration
+    (a + f,
+     BigInt(i) + BigInt(y),
+     BigInt(s) + BigInt(I),
+     BigInt(l) + BigInt(w),
+     BigInt(d) + BigInt(D),
+     BigInt(m) + BigInt(G),
+     BigInt(c) + BigInt(v),
+     O),
+  R = _BalanceDuration7.days,
+  F = _BalanceDuration7.hours,
+  Y = _BalanceDuration7.minutes,
+  P = _BalanceDuration7.seconds,
+  Z = _BalanceDuration7.milliseconds,
+  B = _BalanceDuration7.microseconds,
+  N = _BalanceDuration7.nanoseconds;
+ }
+ return RejectDuration(b, E, M, R, F, Y, P, Z, B, N),
+        {years: b,
+         months: E,
+         weeks: M,
+         days: R,
+         hours: F,
+         minutes: Y,
+         seconds: P,
+         milliseconds: Z,
+         microseconds: B,
+         nanoseconds: N};
+}
+function AddInstant(t, r, o, n, a, i, s){
+ var l = Ie;
+ l = l + BigInt(s),
+ l = l + BigInt(i) * De,
+ l = l + BigInt(a) * Ge,
+ l = l + BigInt(n) * ve,
+ l = l + BigInt(o) * BigInt("60000000000"),
+ l = l + BigInt(r) * BigInt("3600000000000");
+ var d = t + l;
+ return ValidateEpochNanoseconds(d), d;
+}
+function AddDateTime
+(e, t, r, o, n, a, d, m, c, h, u, T, p, f, y, I, S, g, w, D, G){
+ var
+  v = f,
+  _AddTime = AddTime(o, n, a, d, m, c, y, I, S, g, w, D),
+  C = _AddTime.deltaDays,
+  O = _AddTime.hour,
+  b = _AddTime.minute,
+  E = _AddTime.second,
+  M = _AddTime.millisecond,
+  R = _AddTime.microsecond,
+  F = _AddTime.nanosecond;
+ v += C;
+ var
+  Y = GetIntrinsic("%Temporal.Duration%"),
+  P =
+    CalendarDateAdd
+     (h,
+      CreateTemporalDate(e, t, r, h),
+      new Y(u, T, p, v, 0, 0, 0, 0, 0, 0),
+      G);
+ return {year: GetSlot(P, i),
+         month: GetSlot(P, s),
+         day: GetSlot(P, l),
+         hour: O,
+         minute: b,
+         second: E,
+         millisecond: M,
+         microsecond: R,
+         nanosecond: F};
+}
+function AddZonedDateTime(e, t, r, o, a, p, f, y, I, S, g, w, D, G){
+ var v = GetIntrinsic("%Temporal.Duration%");
+ if(0 === DurationSign(o, a, p, f, 0, 0, 0, 0, 0, 0))
+  return AddInstant(GetSlot(e, n), y, I, S, g, w, D);
+ var
+  C = GetPlainDateTimeFor(t, e, r),
+  O =
+    CalendarDateAdd
+     (r,
+      CreateTemporalDate(GetSlot(C, i), GetSlot(C, s), GetSlot(C, l), r),
+      new v(o, a, p, f, 0, 0, 0, 0, 0, 0),
+      G),
+  b =
+    CreateTemporalDateTime
+     (GetSlot(O, i),
+      GetSlot(O, s),
+      GetSlot(O, l),
+      GetSlot(C, d),
+      GetSlot(C, m),
+      GetSlot(C, c),
+      GetSlot(C, h),
+      GetSlot(C, u),
+      GetSlot(C, T),
+      r);
+ return AddInstant
+         (GetSlot(GetInstantFor(t, b, "compatible"), n), y, I, S, g, w, D);
+}
+function AddDurationToOrSubtractDurationFromDuration(e, t, r, o){
+ var n = "subtract" === e ? - 1 : 1;
+ var
+  _ToTemporalDurationRe2 = ToTemporalDurationRecord(r),
+  a = _ToTemporalDurationRe2.years,
+  i = _ToTemporalDurationRe2.months,
+  s = _ToTemporalDurationRe2.weeks,
+  l = _ToTemporalDurationRe2.days,
+  d = _ToTemporalDurationRe2.hours,
+  m = _ToTemporalDurationRe2.minutes,
+  c = _ToTemporalDurationRe2.seconds,
+  h = _ToTemporalDurationRe2.milliseconds,
+  u = _ToTemporalDurationRe2.microseconds,
+  T = _ToTemporalDurationRe2.nanoseconds;
+ var p = ToRelativeTemporalObject(GetOptionsObject(o));
+ var
+  _AddDuration =
+    AddDuration
+     (GetSlot(t, w),
+      GetSlot(t, D),
+      GetSlot(t, G),
+      GetSlot(t, v),
+      GetSlot(t, C),
+      GetSlot(t, O),
+      GetSlot(t, b),
+      GetSlot(t, E),
+      GetSlot(t, M),
+      GetSlot(t, R),
+      n * a,
+      n * i,
+      n * s,
+      n * l,
+      n * d,
+      n * m,
+      n * c,
+      n * h,
+      n * u,
+      n * T,
+      p);
+ a = _AddDuration.years;
+ i = _AddDuration.months;
+ s = _AddDuration.weeks;
+ l = _AddDuration.days;
+ d = _AddDuration.hours;
+ m = _AddDuration.minutes;
+ c = _AddDuration.seconds;
+ h = _AddDuration.milliseconds;
+ u = _AddDuration.microseconds;
+ T = _AddDuration.nanoseconds;
+ return new
+         (GetIntrinsic("%Temporal.Duration%"))
+         (a, i, s, l, d, m, c, h, u, T);
+}
+function AddDurationToOrSubtractDurationFromInstant(e, t, r){
+ var
+  o = "subtract" === e ? - 1 : 1,
+  _ToLimitedTemporalDur =
+    function ToLimitedTemporalDuration(e, t){
       var r = ToTemporalDurationRecord(e);
-      var _iterator14 = _createForOfIteratorHelper(t),
-        _step14;
-      try {
-        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
-          var _e30 = _step14.value;
-          if (0 !== r[_e30]) throw new RangeError("Duration field ".concat(_e30, " not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead."));
-        }
-      } catch (err) {
-        _iterator14.e(err);
-      } finally {
-        _iterator14.f();
+      var _iterator14 = _createForOfIteratorHelper(t), _step14;
+      try{
+       for(_iterator14.s(); ! (_step14 = _iterator14.n()).done;){
+        var _e30 = _step14.value;
+        if(0 !== r[_e30])
+         throw new
+                RangeError
+                ("Duration field ".concat
+                  (_e30,
+                   " not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead."));
+       }
       }
+      catch(err){_iterator14.e(err);}
+      finally{_iterator14.f();}
       return r;
-    }(r, ["years", "months", "weeks", "days"]),
-    a = _ToLimitedTemporalDur.hours,
-    i = _ToLimitedTemporalDur.minutes,
-    s = _ToLimitedTemporalDur.seconds,
-    l = _ToLimitedTemporalDur.milliseconds,
-    d = _ToLimitedTemporalDur.microseconds,
-    m = _ToLimitedTemporalDur.nanoseconds,
-    c = AddInstant(GetSlot(t, n), o * a, o * i, o * s, o * l, o * d, o * m);
-  return new (GetIntrinsic("%Temporal.Instant%"))(c);
-}
-function AddDurationToOrSubtractDurationFromPlainDateTime(e, t, r, o) {
-  var n = "subtract" === e ? -1 : 1,
-    _ToTemporalDurationRe3 = ToTemporalDurationRecord(r),
-    a = _ToTemporalDurationRe3.years,
-    f = _ToTemporalDurationRe3.months,
-    y = _ToTemporalDurationRe3.weeks,
-    I = _ToTemporalDurationRe3.days,
-    S = _ToTemporalDurationRe3.hours,
-    g = _ToTemporalDurationRe3.minutes,
-    w = _ToTemporalDurationRe3.seconds,
-    D = _ToTemporalDurationRe3.milliseconds,
-    G = _ToTemporalDurationRe3.microseconds,
-    v = _ToTemporalDurationRe3.nanoseconds,
-    C = GetOptionsObject(o),
-    O = GetSlot(t, p),
-    _AddDateTime = AddDateTime(GetSlot(t, i), GetSlot(t, s), GetSlot(t, l), GetSlot(t, d), GetSlot(t, m), GetSlot(t, c), GetSlot(t, h), GetSlot(t, u), GetSlot(t, T), O, n * a, n * f, n * y, n * I, n * S, n * g, n * w, n * D, n * G, n * v, C),
-    b = _AddDateTime.year,
-    E = _AddDateTime.month,
-    M = _AddDateTime.day,
-    R = _AddDateTime.hour,
-    F = _AddDateTime.minute,
-    Y = _AddDateTime.second,
-    P = _AddDateTime.millisecond,
-    Z = _AddDateTime.microsecond,
-    B = _AddDateTime.nanosecond;
-  return CreateTemporalDateTime(b, E, M, R, F, Y, P, Z, B, O);
-}
-function AddDurationToOrSubtractDurationFromPlainTime(e, t, r) {
-  var o = "subtract" === e ? -1 : 1,
-    _ToTemporalDurationRe4 = ToTemporalDurationRecord(r),
-    n = _ToTemporalDurationRe4.hours,
-    a = _ToTemporalDurationRe4.minutes,
-    i = _ToTemporalDurationRe4.seconds,
-    s = _ToTemporalDurationRe4.milliseconds,
-    l = _ToTemporalDurationRe4.microseconds,
-    p = _ToTemporalDurationRe4.nanoseconds;
-  var _AddTime2 = AddTime(GetSlot(t, d), GetSlot(t, m), GetSlot(t, c), GetSlot(t, h), GetSlot(t, u), GetSlot(t, T), o * n, o * a, o * i, o * s, o * l, o * p),
-    f = _AddTime2.hour,
-    y = _AddTime2.minute,
-    I = _AddTime2.second,
-    S = _AddTime2.millisecond,
-    g = _AddTime2.microsecond,
-    w = _AddTime2.nanosecond;
-  var _RegulateTime3 = RegulateTime(f, y, I, S, g, w, "reject");
-  f = _RegulateTime3.hour;
-  y = _RegulateTime3.minute;
-  I = _RegulateTime3.second;
-  S = _RegulateTime3.millisecond;
-  g = _RegulateTime3.microsecond;
-  w = _RegulateTime3.nanosecond;
-  return new (GetIntrinsic("%Temporal.PlainTime%"))(f, y, I, S, g, w);
-}
-function AddDurationToOrSubtractDurationFromPlainYearMonth(e, t, r, o) {
-  var n = ToTemporalDurationRecord(r);
-  "subtract" === e && (n = {
-    years: -n.years,
-    months: -n.months,
-    weeks: -n.weeks,
-    days: -n.days,
-    hours: -n.hours,
-    minutes: -n.minutes,
-    seconds: -n.seconds,
-    milliseconds: -n.milliseconds,
-    microseconds: -n.microseconds,
-    nanoseconds: -n.nanoseconds
-  });
-  var _n11 = n,
-    a = _n11.years,
-    i = _n11.months,
-    s = _n11.weeks,
-    l = _n11.days,
-    d = _n11.hours,
-    m = _n11.minutes,
-    c = _n11.seconds,
-    h = _n11.milliseconds,
-    u = _n11.microseconds,
-    T = _n11.nanoseconds;
-  var _BalanceDuration8 = BalanceDuration(l, d, m, c, h, u, T, "day");
-  l = _BalanceDuration8.days;
-  var f = GetOptionsObject(o),
-    y = GetSlot(t, p),
-    I = CalendarFields(y, ["monthCode", "year"]),
-    S = PrepareTemporalFields(t, I, []),
-    g = Te(null);
-  CopyDataProperties(g, S, []), S.day = 1;
-  var w = CalendarDateFromFields(y, S);
-  var D = DurationSign(a, i, s, l, 0, 0, 0, 0, 0, 0),
-    G = GetMethod(y, "dateAdd"),
-    v = GetIntrinsic("%Temporal.Duration%");
-  if (D < 0) {
-    var _e31 = CalendarDateAdd(y, w, new v(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G),
-      _t30 = CalendarDateAdd(y, _e31, new v(0, 0, 0, -1, 0, 0, 0, 0, 0, 0), void 0, G);
-    g.day = CalendarDay(y, _t30), w = CalendarDateFromFields(y, g);
-  }
-  var C = new v(a, i, s, l, 0, 0, 0, 0, 0, 0),
-    O = CopyOptions(f);
-  return CalendarYearMonthFromFields(y, PrepareTemporalFields(CalendarDateAdd(y, w, C, f, G), I, []), O);
-}
-function AddDurationToOrSubtractDurationFromZonedDateTime(e, t, r, o) {
-  var n = "subtract" === e ? -1 : 1,
-    _ToTemporalDurationRe5 = ToTemporalDurationRecord(r),
-    a = _ToTemporalDurationRe5.years,
-    i = _ToTemporalDurationRe5.months,
-    s = _ToTemporalDurationRe5.weeks,
-    l = _ToTemporalDurationRe5.days,
-    d = _ToTemporalDurationRe5.hours,
-    m = _ToTemporalDurationRe5.minutes,
-    c = _ToTemporalDurationRe5.seconds,
-    h = _ToTemporalDurationRe5.milliseconds,
-    u = _ToTemporalDurationRe5.microseconds,
-    T = _ToTemporalDurationRe5.nanoseconds,
-    f = GetOptionsObject(o),
-    y = GetSlot(t, g),
-    I = GetSlot(t, p);
-  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t, S), y, I, n * a, n * i, n * s, n * l, n * d, n * m, n * c, n * h, n * u, n * T, f), y, I);
-}
-function RoundNumberToIncrement(t, r, o) {
-  if (r === Se) return t;
-  var _divmod21 = divmod(t, r),
-    n = _divmod21.quotient,
-    a = _divmod21.remainder;
-  if (a === Ie) return t;
-  var i = a < Ie ? -1 : 1,
-    s = abs(a * 2n),
-    l = s === r,
-    d = s > r;
-  switch (o) {
-    case "ceil":
-      i > 0 && (n = n + BigInt(i));
-      break;
-    case "floor":
-      i < 0 && (n = n + BigInt(i));
-      break;
-    case "expand":
-      n = n + BigInt(i);
-      break;
-    case "trunc":
-      break;
-    case "halfCeil":
-      (d || l && i > 0) && (n = n + BigInt(i));
-      break;
-    case "halfFloor":
-      (d || l && i < 0) && (n = n + BigInt(i));
-      break;
-    case "halfExpand":
-      (d || l) && (n = n + BigInt(i));
-      break;
-    case "halfTrunc":
-      d && (n = n + BigInt(i));
-      break;
-    case "halfEven":
-      (d || l && 1 === Number(abs(n) % 2n)) && (n = n + BigInt(i));
-  }
-  return n * r;
-}
-function RoundInstant(t, r, o, n) {
-  var _NonNegativeBigIntDiv7 = NonNegativeBigIntDivmod(t, Ee),
-    a = _NonNegativeBigIntDiv7.remainder;
-  var i = t - a,
-    s = RoundNumberToIncrement(a, BigInt(_e[o] * r), n);
-  return i + s;
-}
-function RoundISODateTime(e, t, r, o, n, a, i, s, l, d, m, c) {
-  var h = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 864e11;
-  var _RoundTime = RoundTime(o, n, a, i, s, l, d, m, c, h),
-    u = _RoundTime.deltaDays,
-    T = _RoundTime.hour,
-    p = _RoundTime.minute,
-    f = _RoundTime.second,
-    y = _RoundTime.millisecond,
-    I = _RoundTime.microsecond,
-    S = _RoundTime.nanosecond,
-    _BalanceISODate4 = BalanceISODate(e, t, r + u),
-    g = _BalanceISODate4.year,
-    w = _BalanceISODate4.month,
-    D = _BalanceISODate4.day;
-  return {
-    year: g,
-    month: w,
-    day: D,
-    hour: T,
-    minute: p,
-    second: f,
-    millisecond: y,
-    microsecond: I,
-    nanosecond: S
-  };
-}
-function RoundTime(t, r, o, n, a, i, s, l, d) {
-  var m = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 864e11;
-  var c = Ie;
-  switch (l) {
-    case "day":
-    case "hour":
-      c = BigInt(t);
-    case "minute":
-      c = c * ge + BigInt(r);
-    case "second":
-      c = c * ge + BigInt(o);
-    case "millisecond":
-      c = c * De + BigInt(n);
-    case "microsecond":
-      c = c * De + BigInt(a);
-    case "nanosecond":
-      c = c * De + BigInt(i);
-  }
-  var h = "day" === l ? m : _e[l],
-    u = RoundNumberToIncrement(c, BigInt(h * s), d),
-    T = Number(u / BigInt(h));
-  switch (l) {
-    case "day":
-      return {
-        deltaDays: T,
-        hour: 0,
-        minute: 0,
-        second: 0,
-        millisecond: 0,
-        microsecond: 0,
-        nanosecond: 0
-      };
-    case "hour":
-      return BalanceTime(T, 0, 0, 0, 0, 0);
-    case "minute":
-      return BalanceTime(t, T, 0, 0, 0, 0);
-    case "second":
-      return BalanceTime(t, r, T, 0, 0, 0);
-    case "millisecond":
-      return BalanceTime(t, r, o, T, 0, 0);
-    case "microsecond":
-      return BalanceTime(t, r, o, n, T, 0);
-    case "nanosecond":
-      return BalanceTime(t, r, o, n, a, T);
-    default:
-      throw new Error("Invalid unit ".concat(l));
-  }
-}
-function DaysUntil(e, t) {
-  return DifferenceISODate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(t, i), GetSlot(t, s), GetSlot(t, l), "day").days;
-}
-function MoveRelativeDate(e, t, r, o) {
-  var n = CalendarDateAdd(e, t, r, void 0, o);
-  return {
-    relativeTo: n,
-    days: DaysUntil(t, n)
-  };
-}
-function MoveRelativeZonedDateTime(e, t, r, o, n) {
-  var a = GetSlot(e, g),
-    i = GetSlot(e, p);
-  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e, S), a, i, t, r, o, n, 0, 0, 0, 0, 0, 0), a, i);
-}
-function AdjustRoundedDurationDays(t, r, o, n, a, i, s, l, d, m, c, h, u, T) {
-  var _AddDuration2, _BalanceDuration9;
-  var f = t,
-    y = r,
-    I = o,
-    w = n,
-    D = a,
-    G = i,
-    v = s,
-    C = l,
-    O = d,
-    b = m;
-  if (!IsTemporalZonedDateTime(T) || "year" === h || "month" === h || "week" === h || "day" === h || "nanosecond" === h && 1 === c) return {
-    years: f,
-    months: y,
-    weeks: I,
-    days: w,
-    hours: D,
-    minutes: G,
-    seconds: v,
-    milliseconds: C,
-    microseconds: O,
-    nanoseconds: b
-  };
-  var E = TotalDurationNanoseconds(0, D, G, v, C, O, b, 0);
-  var M = se(Number(E)),
-    R = GetSlot(T, g),
-    F = GetSlot(T, p),
-    Y = AddZonedDateTime(GetSlot(T, S), R, F, f, y, I, w, 0, 0, 0, 0, 0, 0),
-    P = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(Y), R, F, 0, 0, 0, M, 0, 0, 0, 0, 0, 0),
-    Z = P - Y;
-  return (E - Z) * BigInt(M) >= Ie && ((_AddDuration2 = AddDuration(f, y, I, w, 0, 0, 0, 0, 0, 0, 0, 0, 0, M, 0, 0, 0, 0, 0, 0, T), f = _AddDuration2.years, y = _AddDuration2.months, I = _AddDuration2.weeks, w = _AddDuration2.days), E = RoundInstant(E - Z, c, h, u), (_BalanceDuration9 = BalanceDuration(0, 0, 0, 0, 0, 0, Number(E), "hour"), D = _BalanceDuration9.hours, G = _BalanceDuration9.minutes, v = _BalanceDuration9.seconds, C = _BalanceDuration9.milliseconds, O = _BalanceDuration9.microseconds, b = _BalanceDuration9.nanoseconds)), {
-    years: f,
-    months: y,
-    weeks: I,
-    days: w,
-    hours: D,
-    minutes: G,
-    seconds: v,
-    milliseconds: C,
-    microseconds: O,
-    nanoseconds: b
-  };
-}
-function RoundDuration(t, r, o, n, a, i, s, l, d, m, c, h, u, T) {
-  var f = t,
-    y = r,
-    I = o,
-    S = n,
-    g = a,
-    w = i,
-    D = s,
-    G = l,
-    v = d,
-    C = BigInt(m);
-  var O = GetIntrinsic("%Temporal.Duration%");
-  var b,
-    E,
-    M,
-    R,
-    F = T;
-  if (F) {
-    if (IsTemporalZonedDateTime(F)) E = F, F = ToTemporalDate(F);else if (!IsTemporalDate(F)) throw new TypeError("starting point must be PlainDate or ZonedDateTime");
-    b = GetSlot(F, p);
-  }
-  if ("year" === h || "month" === h || "week" === h || "day" === h) {
-    var _NanosecondsToDays3;
-    var _t31, _r45, _o15;
-    C = TotalDurationNanoseconds(0, g, w, D, G, v, m, 0), E && (_t31 = MoveRelativeZonedDateTime(E, f, y, I, S)), (_NanosecondsToDays3 = NanosecondsToDays(C, _t31), _r45 = _NanosecondsToDays3.days, C = _NanosecondsToDays3.nanoseconds, _o15 = _NanosecondsToDays3.dayLengthNs), M = BigInt(_o15), S += _r45, g = w = D = G = v = 0;
-  }
-  switch (h) {
-    case "year":
-      {
-        if (!b) throw new RangeError("A starting point is required for years rounding");
-        var _t32 = new O(f),
-          _r46 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
-          _o16 = CalendarDateAdd(b, F, _t32, void 0, _r46),
-          _n12 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r46);
-        F = _o16, S += DaysUntil(_o16, _n12);
-        var _a8 = CalendarDateAdd(b, F, new O(0, 0, 0, S), void 0, _r46),
-          _i12 = Te(null);
-        _i12.largestUnit = "year";
-        var _s4 = CalendarDateUntil(b, F, _a8, _i12).years;
-        f += _s4;
-        var _l5 = F;
-        F = CalendarDateAdd(b, F, new O(_s4), void 0, _r46);
-        S -= DaysUntil(_l5, F);
-        var _d5 = new O(S < 0 ? -1 : 1);
-        var _MoveRelativeDate6 = MoveRelativeDate(b, F, _d5, _r46),
-          _m5 = _MoveRelativeDate6.days;
-        _m5 = ae(_m5);
-        var _h2 = BigInt(_m5) * M;
-        C = _h2 * BigInt(f) + BigInt(S) * M + C;
-        var _T2 = RoundNumberToIncrement(C, _h2 * BigInt(c), u);
-        R = BigIntDivideToNumber(C, _h2), f = Number(_T2 / _h2), C = Ie, y = I = S = 0;
-        break;
-      }
-    case "month":
-      {
-        if (!b) throw new RangeError("A starting point is required for months rounding");
-        var _t33 = new O(f, y),
-          _r47 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
-          _o17 = CalendarDateAdd(b, F, _t33, void 0, _r47),
-          _n13 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r47);
-        F = _o17, S += DaysUntil(_o17, _n13);
-        var _a9 = se(S),
-          _i13 = new O(0, S < 0 ? -1 : 1);
-        var _s5;
-        for (_MoveRelativeDate7 = MoveRelativeDate(b, F, _i13, _r47), F = _MoveRelativeDate7.relativeTo, _s5 = _MoveRelativeDate7.days, _MoveRelativeDate7; ae(S) >= ae(_s5);) {
-          var _MoveRelativeDate7, _MoveRelativeDate8;
-          y += _a9, S -= _s5, (_MoveRelativeDate8 = MoveRelativeDate(b, F, _i13, _r47), F = _MoveRelativeDate8.relativeTo, _s5 = _MoveRelativeDate8.days);
-        }
-        _s5 = ae(_s5);
-        var _l6 = BigInt(_s5) * M;
-        C = _l6 * BigInt(y) + BigInt(S) * M + C;
-        var _d6 = RoundNumberToIncrement(C, _l6 * BigInt(c), u);
-        R = BigIntDivideToNumber(C, _l6), y = Number(_d6 / _l6), C = Ie, I = S = 0;
-        break;
-      }
-    case "week":
-      {
-        if (!b) throw new RangeError("A starting point is required for weeks rounding");
-        var _t34 = se(S),
-          _r48 = new O(0, 0, S < 0 ? -1 : 1),
-          _o18 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0;
-        var _n14;
-        for (_MoveRelativeDate9 = MoveRelativeDate(b, F, _r48, _o18), F = _MoveRelativeDate9.relativeTo, _n14 = _MoveRelativeDate9.days, _MoveRelativeDate9; ae(S) >= ae(_n14);) {
-          var _MoveRelativeDate9, _MoveRelativeDate10;
-          I += _t34, S -= _n14, (_MoveRelativeDate10 = MoveRelativeDate(b, F, _r48, _o18), F = _MoveRelativeDate10.relativeTo, _n14 = _MoveRelativeDate10.days);
-        }
-        _n14 = ae(_n14);
-        var _a10 = BigInt(_n14) * M;
-        C = _a10 * BigInt(I) + BigInt(S) * M + C;
-        var _i14 = RoundNumberToIncrement(C, _a10 * BigInt(c), u);
-        R = BigIntDivideToNumber(C, _a10), I = Number(_i14 / _a10), C = Ie, S = 0;
-        break;
-      }
-    case "day":
-      {
-        var _t35 = M;
-        C = _t35 * BigInt(S) + C;
-        var _r49 = RoundNumberToIncrement(C, _t35 * BigInt(c), u);
-        R = BigIntDivideToNumber(C, _t35), S = Number(_r49 / _t35), C = Ie;
-        break;
-      }
-    case "hour":
-      {
-        var _t36 = 36e11;
-        var _r50 = BigInt(g) * 3600000000000n;
-        _r50 = _r50 + BigInt(w) * 60000000000n, _r50 = _r50 + BigInt(D) * ve, _r50 = _r50 + BigInt(G) * Ge, _r50 = _r50 + BigInt(v) * De, _r50 = _r50 + C, R = BigIntDivideToNumber(_r50, BigInt(_t36));
-        var _o19 = RoundNumberToIncrement(_r50, BigInt(_t36 * c), u);
-        g = Number(_o19 / BigInt(_t36)), C = Ie, w = D = G = v = 0;
-        break;
-      }
-    case "minute":
-      {
-        var _t37 = 6e10;
-        var _r51 = BigInt(w) * 60000000000n;
-        _r51 = _r51 + BigInt(D) * ve, _r51 = _r51 + BigInt(G) * Ge, _r51 = _r51 + BigInt(v) * De, _r51 = _r51 + C, R = BigIntDivideToNumber(_r51, BigInt(_t37));
-        var _o20 = RoundNumberToIncrement(_r51, BigInt(_t37 * c), u);
-        w = Number(_o20 / BigInt(_t37)), C = Ie, D = G = v = 0;
-        break;
-      }
-    case "second":
-      {
-        var _t38 = 1e9;
-        var _r52 = BigInt(D) * ve;
-        _r52 = _r52 + BigInt(G) * Ge, _r52 = _r52 + BigInt(v) * De, _r52 = _r52 + C, R = BigIntDivideToNumber(_r52, BigInt(_t38));
-        var _o21 = RoundNumberToIncrement(_r52, BigInt(_t38 * c), u);
-        D = Number(_o21 / BigInt(_t38)), C = Ie, G = v = 0;
-        break;
-      }
-    case "millisecond":
-      {
-        var _t39 = 1e6;
-        var _r53 = BigInt(G) * Ge;
-        _r53 = _r53 + BigInt(v) * De, _r53 = _r53 + C, R = BigIntDivideToNumber(_r53, BigInt(_t39));
-        var _o22 = RoundNumberToIncrement(_r53, BigInt(_t39 * c), u);
-        G = Number(_o22 / BigInt(_t39)), C = Ie, v = 0;
-        break;
-      }
-    case "microsecond":
-      {
-        var _t40 = 1e3;
-        var _r54 = BigInt(v) * De;
-        _r54 = _r54 + C, R = BigIntDivideToNumber(_r54, BigInt(_t40));
-        var _o23 = RoundNumberToIncrement(_r54, BigInt(_t40 * c), u);
-        v = Number(_o23 / BigInt(_t40)), C = Ie;
-        break;
-      }
-    case "nanosecond":
-      R = Number(C), C = RoundNumberToIncrement(BigInt(C), BigInt(c), u);
-  }
-  return {
-    years: f,
-    months: y,
-    weeks: I,
-    days: S,
-    hours: g,
-    minutes: w,
-    seconds: D,
-    milliseconds: G,
-    microseconds: v,
-    nanoseconds: Number(C),
-    total: R
-  };
-}
-function CompareISODate(e, t, r, o, n, a) {
-  for (var _i15 = 0, _arr5 = [[e, o], [t, n], [r, a]]; _i15 < _arr5.length; _i15++) {
-    var _arr5$_i = _slicedToArray(_arr5[_i15], 2),
-      _i16 = _arr5$_i[0],
-      _s6 = _arr5$_i[1];
-    if (_i16 !== _s6) return ComparisonResult(_i16 - _s6);
-  }
-  return 0;
-}
-function NonNegativeBigIntDivmod(t, r) {
-  var _divmod22 = divmod(t, r),
-    o = _divmod22.quotient,
-    n = _divmod22.remainder;
-  return n < Ie && (o = o - Se, n = n + r), {
-    quotient: o,
-    remainder: n
-  };
-}
-function BigIntFloorDiv(t, r) {
-  var _divmod23 = divmod(t, r),
-    o = _divmod23.quotient,
-    n = _divmod23.remainder;
-  return isZero(n) || !isNegativeJSBI(t) == !isNegativeJSBI(r) ? o : o - Se;
-}
-function BigIntDivideToNumber(t, r) {
-  var _divmod24 = divmod(t, r),
-    o = _divmod24.quotient,
-    n = _divmod24.remainder;
-  return Number(o) + Number(n) / Number(r);
-}
-function ToBigIntExternal(e) {
-  var t = ToBigInt(e);
-  return void 0 !== globalThis.BigInt ? globalThis.BigInt(t.toString(10)) : t;
-}
-function ToBigInt(t) {
-  var r = t;
-  if ("object" == _typeof(t)) {
-    var _e32 = t[Symbol.toPrimitive];
-    _e32 && "function" == typeof _e32 && (r = fe(_e32, t, ["number"]));
-  }
-  if ("number" == typeof r) throw new TypeError("cannot convert number to bigint");
-  return "bigint" == typeof r ? BigInt(r.toString(10)) : BigInt(r);
-}
-var Ve = function () {
-  var t = BigInt(Date.now() % 1e6);
-  return function () {
-    var r = BigInt(Date.now()),
-      o = r * Ge + t;
-    return t = r % Ge, o > Re ? Re : o < Me ? Me : o;
-  };
-}();
-function DefaultTimeZone() {
-  return new re().resolvedOptions().timeZone;
-}
-function ComparisonResult(e) {
-  return e < 0 ? -1 : e > 0 ? 1 : e;
-}
-function GetOptionsObject(e) {
-  if (void 0 === e) return Te(null);
-  if (IsObject(e) && null !== e) return e;
-  throw new TypeError("Options parameter must be an object, not " + (null === e ? "null" : "" + _typeof(e)));
-}
-function CreateOnePropObject(e, t) {
-  var r = Te(null);
-  return r[e] = t, r;
-}
-function CopyOptions(e) {
-  var t = Te(null);
-  return CopyDataProperties(t, GetOptionsObject(e), []), t;
-}
-function GetOption(e, t, r, o) {
-  var n = e[t];
-  if (void 0 !== n) {
-    if (n = ToString(n), !r.includes(n)) throw new RangeError("".concat(t, " must be one of ").concat(r.join(", "), ", not ").concat(n));
-    return n;
-  }
-  return o;
-}
-function IsBuiltinCalendar(e) {
-  return je.includes(ASCIILowercase(e));
+     }
+     (r, ["years", "months", "weeks", "days"]),
+  a = _ToLimitedTemporalDur.hours,
+  i = _ToLimitedTemporalDur.minutes,
+  s = _ToLimitedTemporalDur.seconds,
+  l = _ToLimitedTemporalDur.milliseconds,
+  d = _ToLimitedTemporalDur.microseconds,
+  m = _ToLimitedTemporalDur.nanoseconds,
+  c = AddInstant(GetSlot(t, n), o * a, o * i, o * s, o * l, o * d, o * m);
+ return new (GetIntrinsic("%Temporal.Instant%"))(c);
+}
+function AddDurationToOrSubtractDurationFromPlainDateTime(e, t, r, o){
+ var
+  n = "subtract" === e ? - 1 : 1,
+  _ToTemporalDurationRe3 = ToTemporalDurationRecord(r),
+  a = _ToTemporalDurationRe3.years,
+  f = _ToTemporalDurationRe3.months,
+  y = _ToTemporalDurationRe3.weeks,
+  I = _ToTemporalDurationRe3.days,
+  S = _ToTemporalDurationRe3.hours,
+  g = _ToTemporalDurationRe3.minutes,
+  w = _ToTemporalDurationRe3.seconds,
+  D = _ToTemporalDurationRe3.milliseconds,
+  G = _ToTemporalDurationRe3.microseconds,
+  v = _ToTemporalDurationRe3.nanoseconds,
+  C = GetOptionsObject(o),
+  O = GetSlot(t, p),
+  _AddDateTime =
+    AddDateTime
+     (GetSlot(t, i),
+      GetSlot(t, s),
+      GetSlot(t, l),
+      GetSlot(t, d),
+      GetSlot(t, m),
+      GetSlot(t, c),
+      GetSlot(t, h),
+      GetSlot(t, u),
+      GetSlot(t, T),
+      O,
+      n * a,
+      n * f,
+      n * y,
+      n * I,
+      n * S,
+      n * g,
+      n * w,
+      n * D,
+      n * G,
+      n * v,
+      C),
+  b = _AddDateTime.year,
+  E = _AddDateTime.month,
+  M = _AddDateTime.day,
+  R = _AddDateTime.hour,
+  F = _AddDateTime.minute,
+  Y = _AddDateTime.second,
+  P = _AddDateTime.millisecond,
+  Z = _AddDateTime.microsecond,
+  B = _AddDateTime.nanosecond;
+ return CreateTemporalDateTime(b, E, M, R, F, Y, P, Z, B, O);
+}
+function AddDurationToOrSubtractDurationFromPlainTime(e, t, r){
+ var
+  o = "subtract" === e ? - 1 : 1,
+  _ToTemporalDurationRe4 = ToTemporalDurationRecord(r),
+  n = _ToTemporalDurationRe4.hours,
+  a = _ToTemporalDurationRe4.minutes,
+  i = _ToTemporalDurationRe4.seconds,
+  s = _ToTemporalDurationRe4.milliseconds,
+  l = _ToTemporalDurationRe4.microseconds,
+  p = _ToTemporalDurationRe4.nanoseconds;
+ var
+  _AddTime2 =
+    AddTime
+     (GetSlot(t, d),
+      GetSlot(t, m),
+      GetSlot(t, c),
+      GetSlot(t, h),
+      GetSlot(t, u),
+      GetSlot(t, T),
+      o * n,
+      o * a,
+      o * i,
+      o * s,
+      o * l,
+      o * p),
+  f = _AddTime2.hour,
+  y = _AddTime2.minute,
+  I = _AddTime2.second,
+  S = _AddTime2.millisecond,
+  g = _AddTime2.microsecond,
+  w = _AddTime2.nanosecond;
+ var _RegulateTime3 = RegulateTime(f, y, I, S, g, w, "reject");
+ f = _RegulateTime3.hour;
+ y = _RegulateTime3.minute;
+ I = _RegulateTime3.second;
+ S = _RegulateTime3.millisecond;
+ g = _RegulateTime3.microsecond;
+ w = _RegulateTime3.nanosecond;
+ return new (GetIntrinsic("%Temporal.PlainTime%"))(f, y, I, S, g, w);
+}
+function AddDurationToOrSubtractDurationFromPlainYearMonth(e, t, r, o){
+ var n = ToTemporalDurationRecord(r);
+ "subtract" === e
+ &&
+  (n =
+   {years: - n.years,
+    months: - n.months,
+    weeks: - n.weeks,
+    days: - n.days,
+    hours: - n.hours,
+    minutes: - n.minutes,
+    seconds: - n.seconds,
+    milliseconds: - n.milliseconds,
+    microseconds: - n.microseconds,
+    nanoseconds: - n.nanoseconds});
+ var
+  _n11 = n,
+  a = _n11.years,
+  i = _n11.months,
+  s = _n11.weeks,
+  l = _n11.days,
+  d = _n11.hours,
+  m = _n11.minutes,
+  c = _n11.seconds,
+  h = _n11.milliseconds,
+  u = _n11.microseconds,
+  T = _n11.nanoseconds;
+ var _BalanceDuration8 = BalanceDuration(l, d, m, c, h, u, T, "day");
+ l = _BalanceDuration8.days;
+ var
+  f = GetOptionsObject(o),
+  y = GetSlot(t, p),
+  I = CalendarFields(y, ["monthCode", "year"]),
+  S = PrepareTemporalFields(t, I, []),
+  g = Te(null);
+ CopyDataProperties(g, S, []), S.day = 1;
+ var w = CalendarDateFromFields(y, S);
+ var
+  D = DurationSign(a, i, s, l, 0, 0, 0, 0, 0, 0),
+  G = GetMethod(y, "dateAdd"),
+  v = GetIntrinsic("%Temporal.Duration%");
+ if(D < 0){
+  var
+   _e31 =
+     CalendarDateAdd(y, w, new v(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G),
+   _t30 =
+     CalendarDateAdd
+      (y, _e31, new v(0, 0, 0, - 1, 0, 0, 0, 0, 0, 0), void 0, G);
+  g.day = CalendarDay(y, _t30), w = CalendarDateFromFields(y, g);
+ }
+ var C = new v(a, i, s, l, 0, 0, 0, 0, 0, 0), O = CopyOptions(f);
+ return CalendarYearMonthFromFields
+         (y, PrepareTemporalFields(CalendarDateAdd(y, w, C, f, G), I, []), O);
+}
+function AddDurationToOrSubtractDurationFromZonedDateTime(e, t, r, o){
+ var
+  n = "subtract" === e ? - 1 : 1,
+  _ToTemporalDurationRe5 = ToTemporalDurationRecord(r),
+  a = _ToTemporalDurationRe5.years,
+  i = _ToTemporalDurationRe5.months,
+  s = _ToTemporalDurationRe5.weeks,
+  l = _ToTemporalDurationRe5.days,
+  d = _ToTemporalDurationRe5.hours,
+  m = _ToTemporalDurationRe5.minutes,
+  c = _ToTemporalDurationRe5.seconds,
+  h = _ToTemporalDurationRe5.milliseconds,
+  u = _ToTemporalDurationRe5.microseconds,
+  T = _ToTemporalDurationRe5.nanoseconds,
+  f = GetOptionsObject(o),
+  y = GetSlot(t, g),
+  I = GetSlot(t, p);
+ return CreateTemporalZonedDateTime
+         (AddZonedDateTime
+           (GetSlot(t, S),
+            y,
+            I,
+            n * a,
+            n * i,
+            n * s,
+            n * l,
+            n * d,
+            n * m,
+            n * c,
+            n * h,
+            n * u,
+            n * T,
+            f),
+          y,
+          I);
+}
+function RoundNumberToIncrement(t, r, o){
+ if(r === Se) return t;
+ var
+  _divmod21 = divmod(t, r),
+  n = _divmod21.quotient,
+  a = _divmod21.remainder;
+ if(a === Ie) return t;
+ var i = a < Ie ? - 1 : 1, s = abs(a * BigInt("2")), l = s === r, d = s > r;
+ switch(o){
+   case "ceil":
+    i > 0 && (n = n + BigInt(i)); break;
+   case "floor":
+    i < 0 && (n = n + BigInt(i)); break;
+   case "expand":
+    n = n + BigInt(i); break;
+   case "trunc": break;
+   case "halfCeil":
+    (d || l && i > 0) && (n = n + BigInt(i)); break;
+   case "halfFloor":
+    (d || l && i < 0) && (n = n + BigInt(i)); break;
+   case "halfExpand":
+    (d || l) && (n = n + BigInt(i)); break;
+   case "halfTrunc":
+    d && (n = n + BigInt(i)); break;
+   case "halfEven":
+    (d || l && 1 === Number(abs(n) % BigInt("2"))) && (n = n + BigInt(i));
+ }
+ return n * r;
+}
+function RoundInstant(t, r, o, n){
+ var
+  _NonNegativeBigIntDiv7 = NonNegativeBigIntDivmod(t, Ee),
+  a = _NonNegativeBigIntDiv7.remainder;
+ var i = t - a, s = RoundNumberToIncrement(a, BigInt(_e[o] * r), n);
+ return i + s;
+}
+function RoundISODateTime(e, t, r, o, n, a, i, s, l, d, m, c){
+ var
+  h =
+    arguments.length > 12 && arguments[12] !== undefined
+     ? arguments[12]
+     : 864e11;
+ var
+  _RoundTime = RoundTime(o, n, a, i, s, l, d, m, c, h),
+  u = _RoundTime.deltaDays,
+  T = _RoundTime.hour,
+  p = _RoundTime.minute,
+  f = _RoundTime.second,
+  y = _RoundTime.millisecond,
+  I = _RoundTime.microsecond,
+  S = _RoundTime.nanosecond,
+  _BalanceISODate4 = BalanceISODate(e, t, r + u),
+  g = _BalanceISODate4.year,
+  w = _BalanceISODate4.month,
+  D = _BalanceISODate4.day;
+ return {year: g,
+         month: w,
+         day: D,
+         hour: T,
+         minute: p,
+         second: f,
+         millisecond: y,
+         microsecond: I,
+         nanosecond: S};
+}
+function RoundTime(t, r, o, n, a, i, s, l, d){
+ var
+  m =
+    arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 864e11;
+ var c = Ie;
+ switch(l){
+   case "day":
+   case "hour":
+    c = BigInt(t);
+   case "minute":
+    c = c * ge + BigInt(r);
+   case "second":
+    c = c * ge + BigInt(o);
+   case "millisecond":
+    c = c * De + BigInt(n);
+   case "microsecond":
+    c = c * De + BigInt(a);
+   case "nanosecond":
+    c = c * De + BigInt(i);
+ }
+ var
+  h = "day" === l ? m : _e[l],
+  u = RoundNumberToIncrement(c, BigInt(h * s), d),
+  T = Number(u / BigInt(h));
+ switch(l){
+   case "day":
+    return {deltaDays: T,
+            hour: 0,
+            minute: 0,
+            second: 0,
+            millisecond: 0,
+            microsecond: 0,
+            nanosecond: 0};
+   case "hour":
+    return BalanceTime(T, 0, 0, 0, 0, 0);
+   case "minute":
+    return BalanceTime(t, T, 0, 0, 0, 0);
+   case "second":
+    return BalanceTime(t, r, T, 0, 0, 0);
+   case "millisecond":
+    return BalanceTime(t, r, o, T, 0, 0);
+   case "microsecond":
+    return BalanceTime(t, r, o, n, T, 0);
+   case "nanosecond":
+    return BalanceTime(t, r, o, n, a, T);
+   default: throw new Error("Invalid unit ".concat(l));
+ }
+}
+function DaysUntil(e, t){
+ return DifferenceISODate
+         (GetSlot(e, i),
+          GetSlot(e, s),
+          GetSlot(e, l),
+          GetSlot(t, i),
+          GetSlot(t, s),
+          GetSlot(t, l),
+          "day").days;
+}
+function MoveRelativeDate(e, t, r, o){
+ var n = CalendarDateAdd(e, t, r, void 0, o);
+ return {relativeTo: n, days: DaysUntil(t, n)};
+}
+function MoveRelativeZonedDateTime(e, t, r, o, n){
+ var a = GetSlot(e, g), i = GetSlot(e, p);
+ return CreateTemporalZonedDateTime
+         (AddZonedDateTime(GetSlot(e, S), a, i, t, r, o, n, 0, 0, 0, 0, 0, 0),
+          a,
+          i);
+}
+function AdjustRoundedDurationDays(t, r, o, n, a, i, s, l, d, m, c, h, u, T){
+ var _AddDuration2, _BalanceDuration9;
+ var f = t, y = r, I = o, w = n, D = a, G = i, v = s, C = l, O = d, b = m;
+ if
+  (! IsTemporalZonedDateTime(T) || "year" === h || "month" === h
+   || "week" === h
+   || "day" === h
+   || "nanosecond" === h && 1 === c)
+  return {years: f,
+          months: y,
+          weeks: I,
+          days: w,
+          hours: D,
+          minutes: G,
+          seconds: v,
+          milliseconds: C,
+          microseconds: O,
+          nanoseconds: b};
+ var E = TotalDurationNanoseconds(0, D, G, v, C, O, b, 0);
+ var
+  M = se(Number(E)),
+  R = GetSlot(T, g),
+  F = GetSlot(T, p),
+  Y = AddZonedDateTime(GetSlot(T, S), R, F, f, y, I, w, 0, 0, 0, 0, 0, 0),
+  P =
+    AddZonedDateTime
+     (new (GetIntrinsic("%Temporal.Instant%"))(Y),
+      R,
+      F,
+      0,
+      0,
+      0,
+      M,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0),
+  Z = P - Y;
+ return (E - Z) * BigInt(M) >= Ie
+        &&
+         (_AddDuration2 =
+           AddDuration
+            (f, y, I, w, 0, 0, 0, 0, 0, 0, 0, 0, 0, M, 0, 0, 0, 0, 0, 0, T),
+          f = _AddDuration2.years,
+          y = _AddDuration2.months,
+          I = _AddDuration2.weeks,
+          w = _AddDuration2.days,
+          E = RoundInstant(E - Z, c, h, u),
+          _BalanceDuration9 =
+           BalanceDuration(0, 0, 0, 0, 0, 0, Number(E), "hour"),
+          D = _BalanceDuration9.hours,
+          G = _BalanceDuration9.minutes,
+          v = _BalanceDuration9.seconds,
+          C = _BalanceDuration9.milliseconds,
+          O = _BalanceDuration9.microseconds,
+          b = _BalanceDuration9.nanoseconds),
+        {years: f,
+         months: y,
+         weeks: I,
+         days: w,
+         hours: D,
+         minutes: G,
+         seconds: v,
+         milliseconds: C,
+         microseconds: O,
+         nanoseconds: b};
+}
+function RoundDuration(t, r, o, n, a, i, s, l, d, m, c, h, u, T){
+ var
+  f = t,
+  y = r,
+  I = o,
+  S = n,
+  g = a,
+  w = i,
+  D = s,
+  G = l,
+  v = d,
+  C = BigInt(m);
+ var O = GetIntrinsic("%Temporal.Duration%");
+ var b, E, M, R, F = T;
+ if(F){
+  if(IsTemporalZonedDateTime(F))
+   E = F, F = ToTemporalDate(F);
+  else if(! IsTemporalDate(F))
+   throw new TypeError("starting point must be PlainDate or ZonedDateTime");
+  b = GetSlot(F, p);
+ }
+ if("year" === h || "month" === h || "week" === h || "day" === h){
+  var _NanosecondsToDays3;
+  var _t31, _r45, _o15;
+  C = TotalDurationNanoseconds(0, g, w, D, G, v, m, 0),
+  E && (_t31 = MoveRelativeZonedDateTime(E, f, y, I, S)),
+  _NanosecondsToDays3 = NanosecondsToDays(C, _t31),
+  _r45 = _NanosecondsToDays3.days,
+  C = _NanosecondsToDays3.nanoseconds,
+  _o15 = _NanosecondsToDays3.dayLengthNs,
+  M = BigInt(_o15),
+  S += _r45,
+  g = w = D = G = v = 0;
+ }
+ switch(h){
+   case "year":
+    {
+     if(! b)
+      throw new RangeError("A starting point is required for years rounding");
+     var
+      _t32 = new O(f),
+      _r46 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
+      _o16 = CalendarDateAdd(b, F, _t32, void 0, _r46),
+      _n12 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r46);
+     F = _o16, S += DaysUntil(_o16, _n12);
+     var
+      _a8 = CalendarDateAdd(b, F, new O(0, 0, 0, S), void 0, _r46),
+      _i12 = Te(null);
+     _i12.largestUnit = "year";
+     var _s4 = CalendarDateUntil(b, F, _a8, _i12).years;
+     f += _s4;
+     var _l5 = F;
+     F = CalendarDateAdd(b, F, new O(_s4), void 0, _r46);
+     S -= DaysUntil(_l5, F);
+     var _d5 = new O(S < 0 ? - 1 : 1);
+     var
+      _MoveRelativeDate6 = MoveRelativeDate(b, F, _d5, _r46),
+      _m5 = _MoveRelativeDate6.days;
+     _m5 = ae(_m5);
+     var _h2 = BigInt(_m5) * M;
+     C = _h2 * BigInt(f) + BigInt(S) * M + C;
+     var _T2 = RoundNumberToIncrement(C, _h2 * BigInt(c), u);
+     R = BigIntDivideToNumber(C, _h2),
+     f = Number(_T2 / _h2),
+     C = Ie,
+     y = I = S = 0;
+     break;
+    }
+   case "month":
+    {
+     if(! b)
+      throw new RangeError("A starting point is required for months rounding");
+     var
+      _t33 = new O(f, y),
+      _r47 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
+      _o17 = CalendarDateAdd(b, F, _t33, void 0, _r47),
+      _n13 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r47);
+     F = _o17, S += DaysUntil(_o17, _n13);
+     var _a9 = se(S), _i13 = new O(0, S < 0 ? - 1 : 1);
+     var _s5;
+     for
+     (_MoveRelativeDate7 = MoveRelativeDate(b, F, _i13, _r47),
+      F = _MoveRelativeDate7.relativeTo,
+      _s5 = _MoveRelativeDate7.days,
+      _MoveRelativeDate7;
+      ae(S) >= ae(_s5);){
+      var _MoveRelativeDate7, _MoveRelativeDate8;
+      y += _a9,
+      S -= _s5,
+      _MoveRelativeDate8 = MoveRelativeDate(b, F, _i13, _r47),
+      F = _MoveRelativeDate8.relativeTo,
+      _s5 = _MoveRelativeDate8.days;
+     }
+     _s5 = ae(_s5);
+     var _l6 = BigInt(_s5) * M;
+     C = _l6 * BigInt(y) + BigInt(S) * M + C;
+     var _d6 = RoundNumberToIncrement(C, _l6 * BigInt(c), u);
+     R = BigIntDivideToNumber(C, _l6),
+     y = Number(_d6 / _l6),
+     C = Ie,
+     I = S = 0;
+     break;
+    }
+   case "week":
+    {
+     if(! b)
+      throw new RangeError("A starting point is required for weeks rounding");
+     var
+      _t34 = se(S),
+      _r48 = new O(0, 0, S < 0 ? - 1 : 1),
+      _o18 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0;
+     var _n14;
+     for
+     (_MoveRelativeDate9 = MoveRelativeDate(b, F, _r48, _o18),
+      F = _MoveRelativeDate9.relativeTo,
+      _n14 = _MoveRelativeDate9.days,
+      _MoveRelativeDate9;
+      ae(S) >= ae(_n14);){
+      var _MoveRelativeDate9, _MoveRelativeDate10;
+      I += _t34,
+      S -= _n14,
+      _MoveRelativeDate10 = MoveRelativeDate(b, F, _r48, _o18),
+      F = _MoveRelativeDate10.relativeTo,
+      _n14 = _MoveRelativeDate10.days;
+     }
+     _n14 = ae(_n14);
+     var _a10 = BigInt(_n14) * M;
+     C = _a10 * BigInt(I) + BigInt(S) * M + C;
+     var _i14 = RoundNumberToIncrement(C, _a10 * BigInt(c), u);
+     R = BigIntDivideToNumber(C, _a10),
+     I = Number(_i14 / _a10),
+     C = Ie,
+     S = 0;
+     break;
+    }
+   case "day":
+    {
+     var _t35 = M;
+     C = _t35 * BigInt(S) + C;
+     var _r49 = RoundNumberToIncrement(C, _t35 * BigInt(c), u);
+     R = BigIntDivideToNumber(C, _t35), S = Number(_r49 / _t35), C = Ie;
+     break;
+    }
+   case "hour":
+    {
+     var _t36 = 36e11;
+     var _r50 = BigInt(g) * BigInt("3600000000000");
+     _r50 = _r50 + BigInt(w) * BigInt("60000000000"),
+     _r50 = _r50 + BigInt(D) * ve,
+     _r50 = _r50 + BigInt(G) * Ge,
+     _r50 = _r50 + BigInt(v) * De,
+     _r50 = _r50 + C,
+     R = BigIntDivideToNumber(_r50, BigInt(_t36));
+     var _o19 = RoundNumberToIncrement(_r50, BigInt(_t36 * c), u);
+     g = Number(_o19 / BigInt(_t36)), C = Ie, w = D = G = v = 0;
+     break;
+    }
+   case "minute":
+    {
+     var _t37 = 6e10;
+     var _r51 = BigInt(w) * BigInt("60000000000");
+     _r51 = _r51 + BigInt(D) * ve,
+     _r51 = _r51 + BigInt(G) * Ge,
+     _r51 = _r51 + BigInt(v) * De,
+     _r51 = _r51 + C,
+     R = BigIntDivideToNumber(_r51, BigInt(_t37));
+     var _o20 = RoundNumberToIncrement(_r51, BigInt(_t37 * c), u);
+     w = Number(_o20 / BigInt(_t37)), C = Ie, D = G = v = 0;
+     break;
+    }
+   case "second":
+    {
+     var _t38 = 1e9;
+     var _r52 = BigInt(D) * ve;
+     _r52 = _r52 + BigInt(G) * Ge,
+     _r52 = _r52 + BigInt(v) * De,
+     _r52 = _r52 + C,
+     R = BigIntDivideToNumber(_r52, BigInt(_t38));
+     var _o21 = RoundNumberToIncrement(_r52, BigInt(_t38 * c), u);
+     D = Number(_o21 / BigInt(_t38)), C = Ie, G = v = 0;
+     break;
+    }
+   case "millisecond":
+    {
+     var _t39 = 1e6;
+     var _r53 = BigInt(G) * Ge;
+     _r53 = _r53 + BigInt(v) * De,
+     _r53 = _r53 + C,
+     R = BigIntDivideToNumber(_r53, BigInt(_t39));
+     var _o22 = RoundNumberToIncrement(_r53, BigInt(_t39 * c), u);
+     G = Number(_o22 / BigInt(_t39)), C = Ie, v = 0;
+     break;
+    }
+   case "microsecond":
+    {
+     var _t40 = 1e3;
+     var _r54 = BigInt(v) * De;
+     _r54 = _r54 + C, R = BigIntDivideToNumber(_r54, BigInt(_t40));
+     var _o23 = RoundNumberToIncrement(_r54, BigInt(_t40 * c), u);
+     v = Number(_o23 / BigInt(_t40)), C = Ie;
+     break;
+    }
+   case "nanosecond":
+    R = Number(C), C = RoundNumberToIncrement(BigInt(C), BigInt(c), u);
+ }
+ return {years: f,
+         months: y,
+         weeks: I,
+         days: S,
+         hours: g,
+         minutes: w,
+         seconds: D,
+         milliseconds: G,
+         microseconds: v,
+         nanoseconds: Number(C),
+         total: R};
+}
+function CompareISODate(e, t, r, o, n, a){
+ for
+ (var _i15 = 0, _arr5 = [[e, o], [t, n], [r, a]]; _i15 < _arr5.length; _i15++){
+  var
+   _arr5$_i = _slicedToArray(_arr5[_i15], 2),
+   _i16 = _arr5$_i[0],
+   _s6 = _arr5$_i[1];
+  if(_i16 !== _s6) return ComparisonResult(_i16 - _s6);
+ }
+ return 0;
+}
+function NonNegativeBigIntDivmod(t, r){
+ var
+  _divmod22 = divmod(t, r),
+  o = _divmod22.quotient,
+  n = _divmod22.remainder;
+ return n < Ie && (o = o - Se, n = n + r), {quotient: o, remainder: n};
+}
+function BigIntFloorDiv(t, r){
+ var
+  _divmod23 = divmod(t, r),
+  o = _divmod23.quotient,
+  n = _divmod23.remainder;
+ return isZero(n) || ! isNegativeJSBI(t) == ! isNegativeJSBI(r) ? o : o - Se;
+}
+function BigIntDivideToNumber(t, r){
+ var
+  _divmod24 = divmod(t, r),
+  o = _divmod24.quotient,
+  n = _divmod24.remainder;
+ return Number(o) + Number(n) / Number(r);
+}
+function ToBigIntExternal(e){
+ var t = ToBigInt(e);
+ return void 0 !== globalThis.BigInt ? globalThis.BigInt(t.toString(10)) : t;
+}
+function ToBigInt(t){
+ var r = t;
+ if("object" == _typeof(t)){
+  var _e32 = t[Symbol.toPrimitive];
+  _e32 && "function" == typeof _e32 && (r = fe(_e32, t, ["number"]));
+ }
+ if("number" == typeof r)
+  throw new TypeError("cannot convert number to bigint");
+ return "bigint" == typeof r ? BigInt(r.toString(10)) : BigInt(r);
+}
+var
+ Ve =
+   function(){
+     var t = BigInt(Date.now() % 1e6);
+     return function(){
+      var r = BigInt(Date.now()), o = r * Ge + t;
+      return t = r % Ge, o > Re ? Re : o < Me ? Me : o;};
+    }
+    ();
+function DefaultTimeZone(){return new re().resolvedOptions().timeZone;}
+function ComparisonResult(e){return e < 0 ? - 1 : e > 0 ? 1 : e;}
+function GetOptionsObject(e){
+ if(void 0 === e) return Te(null);
+ if(IsObject(e) && null !== e) return e;
+ throw new
+        TypeError
+        ("Options parameter must be an object, not "
+         + (null === e ? "null" : "" + _typeof(e)));
+}
+function CreateOnePropObject(e, t){var r = Te(null); return r[e] = t, r;}
+function CopyOptions(e){
+ var t = Te(null);
+ return CopyDataProperties(t, GetOptionsObject(e), []), t;
+}
+function GetOption(e, t, r, o){
+ var n = e[t];
+ if(void 0 !== n){
+  if(n = ToString(n), ! r.includes(n))
+   throw new
+          RangeError
+          ("".concat(t, " must be one of ").concat(r.join(", "), ", not ").concat
+            (n));
+  return n;
+ }
+ return o;
 }
-function ASCIILowercase(e) {
-  return e.replace(/[A-Z]/g, function (e) {
-    var t = e.charCodeAt(0);
-    return String.fromCharCode(t + 32);
-  });
+function IsBuiltinCalendar(e){return je.includes(ASCIILowercase(e));}
+function ASCIILowercase(e){
+ return e.replace
+         (/[A-Z]/g,
+          function(e){
+           var t = e.charCodeAt(0);
+           return String.fromCharCode(t + 32);
+          });
 }
 var ze = new RegExp("^".concat(W.source, "$"));
-function bisect(t, r, o) {
-  var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t(r);
-  var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : t(o);
-  var i = BigInt(r),
-    s = BigInt(o),
-    l = n,
-    d = a;
-  for (; s - i > Se;) {
-    var _r55 = (i + s) / 2n,
-      _o24 = t(_r55);
-    if (_o24 === l) i = _r55, l = _o24;else {
-      if (_o24 !== d) throw new Error("invalid state in bisection ".concat(l, " - ").concat(_o24, " - ").concat(d));
-      s = _r55, d = _o24;
-    }
-  }
-  return s;
-}
-var _e = {
-    hour: 36e11,
+function bisect(t, r, o){
+ var
+  n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t(r);
+ var
+  a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : t(o);
+ var i = BigInt(r), s = BigInt(o), l = n, d = a;
+ for(; s - i > Se;){
+  var _r55 = (i + s) / BigInt("2"), _o24 = t(_r55);
+  if(_o24 === l)
+   i = _r55, l = _o24;
+  else{
+   if(_o24 !== d)
+    throw new
+           Error
+           ("invalid state in bisection ".concat(l, " - ").concat(_o24, " - ").concat
+             (d));
+   s = _r55, d = _o24;
+  }
+ }
+ return s;
+}
+var
+ _e =
+   {hour: 36e11,
     minute: 6e10,
     second: 1e9,
     millisecond: 1e6,
     microsecond: 1e3,
-    nanosecond: 1
-  },
-  Je = Symbol("date"),
-  Ke = Symbol("ym"),
-  Xe = Symbol("md"),
-  Qe = Symbol("time"),
-  et = Symbol("datetime"),
-  tt = Symbol("instant"),
-  rt = Symbol("original"),
-  ot = Symbol("timezone"),
-  nt = Symbol("calendar-id"),
-  at = Symbol("locale"),
-  it = Symbol("options"),
-  descriptor = function descriptor(e) {
-    return {
-      value: e,
-      enumerable: !0,
-      writable: !1,
-      configurable: !0
-    };
-  },
-  st = globalThis.Intl.DateTimeFormat,
-  lt = Object.assign,
-  dt = Object.prototype.hasOwnProperty,
-  mt = Reflect.apply;
-function getPropLazy(e, t) {
-  var r = e[t];
-  return "function" == typeof r && (r = new st(e[at], r(e[it])), e[t] = r), r;
-}
-function DateTimeFormatImpl(e) {
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
-  if (!(this instanceof DateTimeFormatImpl)) return new DateTimeFormatImpl(e, t);
-  var r = void 0 !== t,
-    o = r ? lt({}, t) : {},
-    n = new st(e, o),
-    a = n.resolvedOptions();
-  if (r) {
-    var _e33 = lt({}, a);
-    for (var _t41 in _e33) mt(dt, o, [_t41]) || delete _e33[_t41];
-    this[it] = _e33;
-  } else this[it] = o;
-  this[at] = a.locale, this[rt] = n, this[ot] = a.timeZone, this[nt] = a.calendar, this[Je] = dateAmend, this[Ke] = yearMonthAmend, this[Xe] = monthDayAmend, this[Qe] = timeAmend, this[et] = datetimeAmend, this[tt] = instantAmend;
-}
-Object.defineProperty(DateTimeFormatImpl, "name", {
-  writable: !0,
-  value: "DateTimeFormat"
-}), DateTimeFormatImpl.supportedLocalesOf = function (e, t) {
-  return st.supportedLocalesOf(e, t);
-};
-var ct = {
-  resolvedOptions: descriptor(function resolvedOptions() {
-    return this[rt].resolvedOptions();
-  }),
-  format: descriptor(function format(e) {
-    var _this$rt;
-    var _extractOverrides = extractOverrides(e, this),
-      r = _extractOverrides.instant,
-      o = _extractOverrides.formatter;
-    if (r && o) return o.format(r.epochMilliseconds);
-    for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
-      t[_key2 - 1] = arguments[_key2];
-    }
-    return (_this$rt = this[rt]).format.apply(_this$rt, [e].concat(t));
-  }),
-  formatRange: descriptor(function formatRange(e, t) {
-    if (isTemporalObject(e) || isTemporalObject(t)) {
-      if (!sameTemporalType(e, t)) throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
-      var _extractOverrides2 = extractOverrides(e, this),
-        _r56 = _extractOverrides2.instant,
-        _o25 = _extractOverrides2.formatter,
-        _extractOverrides3 = extractOverrides(t, this),
-        _n15 = _extractOverrides3.instant,
-        _a11 = _extractOverrides3.formatter;
-      if (_r56 && _n15 && _o25 && _a11 && _o25 === _a11) return _o25.formatRange(_r56.epochMilliseconds, _n15.epochMilliseconds);
-    }
-    return this[rt].formatRange(e, t);
-  })
-};
-"formatToParts" in st.prototype && (ct.formatToParts = descriptor(function formatToParts(e) {
-  var _this$rt2;
-  var _extractOverrides4 = extractOverrides(e, this),
-    r = _extractOverrides4.instant,
-    o = _extractOverrides4.formatter;
-  if (r && o) return o.formatToParts(r.epochMilliseconds);
-  for (var _len3 = arguments.length, t = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
-    t[_key3 - 1] = arguments[_key3];
-  }
-  return (_this$rt2 = this[rt]).formatToParts.apply(_this$rt2, [e].concat(t));
-})), "formatRangeToParts" in st.prototype && (ct.formatRangeToParts = descriptor(function formatRangeToParts(e, t) {
-  if (isTemporalObject(e) || isTemporalObject(t)) {
-    if (!sameTemporalType(e, t)) throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
-    var _extractOverrides5 = extractOverrides(e, this),
-      _r57 = _extractOverrides5.instant,
-      _o26 = _extractOverrides5.formatter,
-      _extractOverrides6 = extractOverrides(t, this),
-      _n16 = _extractOverrides6.instant,
-      _a12 = _extractOverrides6.formatter;
-    if (_r57 && _n16 && _o26 && _a12 && _o26 === _a12) return _o26.formatRangeToParts(_r57.epochMilliseconds, _n16.epochMilliseconds);
-  }
-  return this[rt].formatRangeToParts(e, t);
-})), DateTimeFormatImpl.prototype = Object.create(st.prototype, ct), Object.defineProperty(DateTimeFormatImpl, "prototype", {
-  writable: !1,
-  enumerable: !1,
-  configurable: !1
-});
+    nanosecond: 1},
+ Je = Symbol("date"),
+ Ke = Symbol("ym"),
+ Xe = Symbol("md"),
+ Qe = Symbol("time"),
+ et = Symbol("datetime"),
+ tt = Symbol("instant"),
+ rt = Symbol("original"),
+ ot = Symbol("timezone"),
+ nt = Symbol("calendar-id"),
+ at = Symbol("locale"),
+ it = Symbol("options"),
+ descriptor =
+   function descriptor(e){
+    return {value: e, enumerable: ! 0, writable: ! 1, configurable: ! 0};
+   },
+ st = globalThis.Intl.DateTimeFormat,
+ lt = Object.assign,
+ dt = Object.prototype.hasOwnProperty,
+ mt = Reflect.apply;
+function getPropLazy(e, t){
+ var r = e[t];
+ return "function" == typeof r && (r = new st(e[at], r(e[it])), e[t] = r), r;
+}
+function DateTimeFormatImpl(e){
+ var
+  t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+ if(! (this instanceof DateTimeFormatImpl))
+  return new DateTimeFormatImpl(e, t);
+ var
+  r = void 0 !== t,
+  o = r ? lt({}, t) : {},
+  n = new st(e, o),
+  a = n.resolvedOptions();
+ if(r){
+  var _e33 = lt({}, a);
+  for(var _t41 in _e33) mt(dt, o, [_t41]) || delete _e33[_t41];
+  this[it] = _e33;
+ }
+ else
+  this[it] = o;
+ this[at] = a.locale,
+ this[rt] = n,
+ this[ot] = a.timeZone,
+ this[nt] = a.calendar,
+ this[Je] = dateAmend,
+ this[Ke] = yearMonthAmend,
+ this[Xe] = monthDayAmend,
+ this[Qe] = timeAmend,
+ this[et] = datetimeAmend,
+ this[tt] = instantAmend;
+}
+Object.defineProperty
+ (DateTimeFormatImpl, "name", {writable: ! 0, value: "DateTimeFormat"}),
+DateTimeFormatImpl.supportedLocalesOf =
+ function(e, t){return st.supportedLocalesOf(e, t);};
+var
+ ct =
+   {resolvedOptions:
+    descriptor(function resolvedOptions(){return this[rt].resolvedOptions();}),
+    format:
+    descriptor
+     (function format(e){
+       var _this$rt;
+       var
+        _extractOverrides = extractOverrides(e, this),
+        r = _extractOverrides.instant,
+        o = _extractOverrides.formatter;
+       if(r && o) return o.format(r.epochMilliseconds);
+       for
+       (var
+         _len2 = arguments.length,
+         t = new Array(_len2 > 1 ? _len2 - 1 : 0),
+         _key2 = 1;
+        _key2 < _len2;
+        _key2++){t[_key2 - 1] = arguments[_key2];}
+       return (_this$rt = this[rt]).format.apply(_this$rt, [e].concat(t));
+      }),
+    formatRange:
+    descriptor
+     (function formatRange(e, t){
+       if(isTemporalObject(e) || isTemporalObject(t)){
+        if(! sameTemporalType(e, t))
+         throw new
+                TypeError
+                ("Intl.DateTimeFormat.formatRange accepts two values of the same type");
+        var
+         _extractOverrides2 = extractOverrides(e, this),
+         _r56 = _extractOverrides2.instant,
+         _o25 = _extractOverrides2.formatter,
+         _extractOverrides3 = extractOverrides(t, this),
+         _n15 = _extractOverrides3.instant,
+         _a11 = _extractOverrides3.formatter;
+        if(_r56 && _n15 && _o25 && _a11 && _o25 === _a11)
+         return _o25.formatRange
+                 (_r56.epochMilliseconds, _n15.epochMilliseconds);
+       }
+       return this[rt].formatRange(e, t);
+      })};
+"formatToParts" in st.prototype
+&&
+ (ct.formatToParts =
+  descriptor
+   (function formatToParts(e){
+     var _this$rt2;
+     var
+      _extractOverrides4 = extractOverrides(e, this),
+      r = _extractOverrides4.instant,
+      o = _extractOverrides4.formatter;
+     if(r && o) return o.formatToParts(r.epochMilliseconds);
+     for
+     (var
+       _len3 = arguments.length,
+       t = new Array(_len3 > 1 ? _len3 - 1 : 0),
+       _key3 = 1;
+      _key3 < _len3;
+      _key3++){t[_key3 - 1] = arguments[_key3];}
+     return (_this$rt2 = this[rt]).formatToParts.apply
+             (_this$rt2, [e].concat(t));
+    })),
+"formatRangeToParts" in st.prototype
+&&
+ (ct.formatRangeToParts =
+  descriptor
+   (function formatRangeToParts(e, t){
+     if(isTemporalObject(e) || isTemporalObject(t)){
+      if(! sameTemporalType(e, t))
+       throw new
+              TypeError
+              ("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
+      var
+       _extractOverrides5 = extractOverrides(e, this),
+       _r57 = _extractOverrides5.instant,
+       _o26 = _extractOverrides5.formatter,
+       _extractOverrides6 = extractOverrides(t, this),
+       _n16 = _extractOverrides6.instant,
+       _a12 = _extractOverrides6.formatter;
+      if(_r57 && _n16 && _o26 && _a12 && _o26 === _a12)
+       return _o26.formatRangeToParts
+               (_r57.epochMilliseconds, _n16.epochMilliseconds);
+     }
+     return this[rt].formatRangeToParts(e, t);
+    })),
+DateTimeFormatImpl.prototype = Object.create(st.prototype, ct),
+Object.defineProperty
+ (DateTimeFormatImpl,
+  "prototype",
+  {writable: ! 1, enumerable: ! 1, configurable: ! 1});
 var ht = DateTimeFormatImpl;
-function amend() {
-  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
-  var r = lt({}, e);
-  for (var _i17 = 0, _arr6 = ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"]; _i17 < _arr6.length; _i17++) {
-    var _e34 = _arr6[_i17];
-    r[_e34] = _e34 in t ? t[_e34] : r[_e34], !1 !== r[_e34] && void 0 !== r[_e34] || delete r[_e34];
-  }
-  return r;
-}
-function timeAmend(e) {
-  var t = amend(e, {
-    year: !1,
-    month: !1,
-    day: !1,
-    weekday: !1,
-    timeZoneName: !1,
-    dateStyle: !1
-  });
-  return hasTimeOptions(t) || (t = lt({}, t, {
-    hour: "numeric",
-    minute: "numeric",
-    second: "numeric"
-  })), t;
-}
-function yearMonthAmend(e) {
-  var t = amend(e, {
-    day: !1,
-    hour: !1,
-    minute: !1,
-    second: !1,
-    weekday: !1,
-    dayPeriod: !1,
-    timeZoneName: !1,
-    dateStyle: !1,
-    timeStyle: !1
-  });
-  return "year" in t || "month" in t || (t = lt(t, {
-    year: "numeric",
-    month: "numeric"
-  })), t;
-}
-function monthDayAmend(e) {
-  var t = amend(e, {
-    year: !1,
-    hour: !1,
-    minute: !1,
-    second: !1,
-    weekday: !1,
-    dayPeriod: !1,
-    timeZoneName: !1,
-    dateStyle: !1,
-    timeStyle: !1
-  });
-  return "month" in t || "day" in t || (t = lt({}, t, {
-    month: "numeric",
-    day: "numeric"
-  })), t;
-}
-function dateAmend(e) {
-  var t = amend(e, {
-    hour: !1,
-    minute: !1,
-    second: !1,
-    dayPeriod: !1,
-    timeZoneName: !1,
-    timeStyle: !1
-  });
-  return hasDateOptions(t) || (t = lt({}, t, {
-    year: "numeric",
-    month: "numeric",
-    day: "numeric"
-  })), t;
-}
-function datetimeAmend(e) {
-  var t = amend(e, {
-    timeZoneName: !1
-  });
-  return hasTimeOptions(t) || hasDateOptions(t) || (t = lt({}, t, {
-    year: "numeric",
-    month: "numeric",
-    day: "numeric",
-    hour: "numeric",
-    minute: "numeric",
-    second: "numeric"
-  })), t;
-}
-function instantAmend(e) {
-  var t = e;
-  return hasTimeOptions(t) || hasDateOptions(t) || (t = lt({}, t, {
-    year: "numeric",
-    month: "numeric",
-    day: "numeric",
-    hour: "numeric",
-    minute: "numeric",
-    second: "numeric"
-  })), t;
-}
-function hasDateOptions(e) {
-  return "year" in e || "month" in e || "day" in e || "weekday" in e || "dateStyle" in e;
-}
-function hasTimeOptions(e) {
-  return "hour" in e || "minute" in e || "second" in e || "timeStyle" in e || "dayPeriod" in e;
-}
-function isTemporalObject(e) {
-  return IsTemporalDate(e) || IsTemporalTime(e) || IsTemporalDateTime(e) || IsTemporalZonedDateTime(e) || IsTemporalYearMonth(e) || IsTemporalMonthDay(e) || IsTemporalInstant(e);
-}
-function sameTemporalType(e, t) {
-  return !(!isTemporalObject(e) || !isTemporalObject(t)) && !(IsTemporalTime(e) && !IsTemporalTime(t)) && !(IsTemporalDate(e) && !IsTemporalDate(t)) && !(IsTemporalDateTime(e) && !IsTemporalDateTime(t)) && !(IsTemporalZonedDateTime(e) && !IsTemporalZonedDateTime(t)) && !(IsTemporalYearMonth(e) && !IsTemporalYearMonth(t)) && !(IsTemporalMonthDay(e) && !IsTemporalMonthDay(t)) && !(IsTemporalInstant(e) && !IsTemporalInstant(t));
-}
-function extractOverrides(e, t) {
-  var r = GetIntrinsic("%Temporal.PlainDateTime%");
-  if (IsTemporalTime(e)) {
-    var _o27 = new r(1970, 1, 1, GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T), t[nt]);
-    return {
-      instant: GetInstantFor(t[ot], _o27, "compatible"),
-      formatter: getPropLazy(t, Qe)
-    };
-  }
-  if (IsTemporalYearMonth(e)) {
-    var _o28 = GetSlot(e, i),
-      _n17 = GetSlot(e, s),
-      _a13 = GetSlot(e, l),
-      _d7 = ToTemporalCalendarIdentifier(GetSlot(e, p));
-    if (_d7 !== t[nt]) throw new RangeError("cannot format PlainYearMonth with calendar ".concat(_d7, " in locale with calendar ").concat(t[nt]));
-    var _m6 = new r(_o28, _n17, _a13, 12, 0, 0, 0, 0, 0, _d7);
-    return {
-      instant: GetInstantFor(t[ot], _m6, "compatible"),
-      formatter: getPropLazy(t, Ke)
-    };
-  }
-  if (IsTemporalMonthDay(e)) {
-    var _o29 = GetSlot(e, i),
-      _n18 = GetSlot(e, s),
-      _a14 = GetSlot(e, l),
-      _d8 = ToTemporalCalendarIdentifier(GetSlot(e, p));
-    if (_d8 !== t[nt]) throw new RangeError("cannot format PlainMonthDay with calendar ".concat(_d8, " in locale with calendar ").concat(t[nt]));
-    var _m7 = new r(_o29, _n18, _a14, 12, 0, 0, 0, 0, 0, _d8);
-    return {
-      instant: GetInstantFor(t[ot], _m7, "compatible"),
-      formatter: getPropLazy(t, Xe)
-    };
-  }
-  if (IsTemporalDate(e)) {
-    var _o30 = GetSlot(e, i),
-      _n19 = GetSlot(e, s),
-      _a15 = GetSlot(e, l),
-      _d9 = ToTemporalCalendarIdentifier(GetSlot(e, p));
-    if ("iso8601" !== _d9 && _d9 !== t[nt]) throw new RangeError("cannot format PlainDate with calendar ".concat(_d9, " in locale with calendar ").concat(t[nt]));
-    var _m8 = new r(_o30, _n19, _a15, 12, 0, 0, 0, 0, 0, t[nt]);
-    return {
-      instant: GetInstantFor(t[ot], _m8, "compatible"),
-      formatter: getPropLazy(t, Je)
-    };
-  }
-  if (IsTemporalDateTime(e)) {
-    var _o31 = GetSlot(e, i),
-      _n20 = GetSlot(e, s),
-      _a16 = GetSlot(e, l),
-      _f5 = GetSlot(e, d),
-      _y = GetSlot(e, m),
-      _I3 = GetSlot(e, c),
-      _S3 = GetSlot(e, h),
-      _g2 = GetSlot(e, u),
-      _w = GetSlot(e, T),
-      _D = ToTemporalCalendarIdentifier(GetSlot(e, p));
-    if ("iso8601" !== _D && _D !== t[nt]) throw new RangeError("cannot format PlainDateTime with calendar ".concat(_D, " in locale with calendar ").concat(t[nt]));
-    var _G = e;
-    return "iso8601" === _D && (_G = new r(_o31, _n20, _a16, _f5, _y, _I3, _S3, _g2, _w, t[nt])), {
-      instant: GetInstantFor(t[ot], _G, "compatible"),
-      formatter: getPropLazy(t, et)
-    };
-  }
-  if (IsTemporalZonedDateTime(e)) throw new TypeError("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
-  return IsTemporalInstant(e) ? {
-    instant: e,
-    formatter: getPropLazy(t, tt)
-  } : {};
-}
-var ut = Object.freeze({
-  __proto__: null,
-  DateTimeFormat: ht
-});
-var Instant = /*#__PURE__*/function () {
-  function Instant(e) {
-    _classCallCheck(this, Instant);
-    if (arguments.length < 1) throw new TypeError("missing argument: epochNanoseconds is required");
-    var t = ToBigInt(e);
-    ValidateEpochNanoseconds(t), N(this), SetSlot(this, n, t);
-  }
-  _createClass(Instant, [{
-    key: "epochSeconds",
-    get: function get() {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      var t = GetSlot(this, n);
-      return Number(BigIntFloorDiv(t, ve));
-    }
-  }, {
-    key: "epochMilliseconds",
-    get: function get() {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      var t = BigInt(GetSlot(this, n));
-      return Number(BigIntFloorDiv(t, Ge));
-    }
-  }, {
-    key: "epochMicroseconds",
-    get: function get() {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return ToBigIntExternal(BigIntFloorDiv(BigInt(GetSlot(this, n)), De));
-    }
-  }, {
-    key: "epochNanoseconds",
-    get: function get() {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return ToBigIntExternal(BigInt(GetSlot(this, n)));
-    }
-  }, {
-    key: "add",
-    value: function add(e) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromInstant("add", this, e);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromInstant("subtract", this, e);
-    }
-  }, {
-    key: "until",
-    value: function until(e, t) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalInstant("until", this, e, t);
-    }
-  }, {
-    key: "since",
-    value: function since(e, t) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalInstant("since", this, e, t);
-    }
-  }, {
-    key: "round",
-    value: function round(e) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      if (void 0 === e) throw new TypeError("options parameter is required");
-      var t = "string" == typeof e ? CreateOnePropObject("smallestUnit", e) : GetOptionsObject(e),
-        r = ToTemporalRoundingIncrement(t),
-        o = ToTemporalRoundingMode(t, "halfExpand"),
-        a = GetTemporalUnit(t, "smallestUnit", "time", He);
-      ValidateTemporalRoundingIncrement(r, {
-        hour: 24,
-        minute: 1440,
-        second: 86400,
-        millisecond: 864e5,
-        microsecond: 864e8,
-        nanosecond: 864e11
-      }[a], !0);
-      var i = RoundInstant(GetSlot(this, n), r, a, o);
-      return new Instant(i);
-    }
-  }, {
-    key: "equals",
-    value: function equals(t) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      var r = ToTemporalInstant(t),
-        o = GetSlot(this, n),
-        a = GetSlot(r, n);
-      return BigInt(o) === BigInt(a);
-    }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      var t = GetOptionsObject(e),
-        r = ToFractionalSecondDigits(t),
-        o = ToTemporalRoundingMode(t, "trunc"),
-        a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
-      if ("hour" === a) throw new RangeError('smallestUnit must be a time unit other than "hour"');
-      var i = t.timeZone;
-      void 0 !== i && (i = ToTemporalTimeZoneSlotValue(i));
-      var _ToSecondsStringPreci = ToSecondsStringPrecisionRecord(a, r),
-        s = _ToSecondsStringPreci.precision,
-        l = _ToSecondsStringPreci.unit,
-        d = _ToSecondsStringPreci.increment,
-        m = RoundInstant(GetSlot(this, n), d, l, o);
-      return TemporalInstantToString(new Instant(m), i, s);
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return TemporalInstantToString(this, void 0, "auto");
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      return new ht(e, t).format(this);
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() or equals() to compare Temporal.Instant");
-    }
-  }, {
-    key: "toZonedDateTime",
-    value: function toZonedDateTime(e) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument in toZonedDateTime");
-      var t = e.calendar;
-      if (void 0 === t) throw new TypeError("missing calendar property in toZonedDateTime");
-      var r = ToTemporalCalendarSlotValue(t),
-        o = e.timeZone;
-      if (void 0 === o) throw new TypeError("missing timeZone property in toZonedDateTime");
-      var a = ToTemporalTimeZoneSlotValue(o);
-      return CreateTemporalZonedDateTime(GetSlot(this, n), a, r);
-    }
-  }, {
-    key: "toZonedDateTimeISO",
-    value: function toZonedDateTimeISO(e) {
-      if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalTimeZoneSlotValue(e);
-      return CreateTemporalZonedDateTime(GetSlot(this, n), t, "iso8601");
-    }
-  }], [{
-    key: "fromEpochSeconds",
-    value: function fromEpochSeconds(t) {
-      var r = ToNumber(t),
-        o = BigInt(r) * ve;
-      return ValidateEpochNanoseconds(o), new Instant(o);
-    }
-  }, {
-    key: "fromEpochMilliseconds",
-    value: function fromEpochMilliseconds(t) {
-      var r = ToNumber(t),
-        o = BigInt(r) * Ge;
-      return ValidateEpochNanoseconds(o), new Instant(o);
-    }
-  }, {
-    key: "fromEpochMicroseconds",
-    value: function fromEpochMicroseconds(t) {
-      var r = ToBigInt(t),
-        o = r * De;
-      return ValidateEpochNanoseconds(o), new Instant(o);
-    }
-  }, {
-    key: "fromEpochNanoseconds",
-    value: function fromEpochNanoseconds(e) {
+function amend(){
+ var
+  e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+ var
+  t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+ var r = lt({}, e);
+ for
+ (var
+   _i17 = 0,
+   _arr6 =
+     ["year",
+      "month",
+      "day",
+      "hour",
+      "minute",
+      "second",
+      "weekday",
+      "dayPeriod",
+      "timeZoneName",
+      "dateStyle",
+      "timeStyle"];
+  _i17 < _arr6.length;
+  _i17++){
+  var _e34 = _arr6[_i17];
+  r[_e34] = _e34 in t ? t[_e34] : r[_e34],
+  ! 1 !== r[_e34] && void 0 !== r[_e34] || delete r[_e34];
+ }
+ return r;
+}
+function timeAmend(e){
+ var
+  t =
+    amend
+     (e,
+      {year: ! 1,
+       month: ! 1,
+       day: ! 1,
+       weekday: ! 1,
+       timeZoneName: ! 1,
+       dateStyle: ! 1});
+ return hasTimeOptions(t)
+        ||
+         (t =
+          lt({}, t, {hour: "numeric", minute: "numeric", second: "numeric"})),
+        t;
+}
+function yearMonthAmend(e){
+ var
+  t =
+    amend
+     (e,
+      {day: ! 1,
+       hour: ! 1,
+       minute: ! 1,
+       second: ! 1,
+       weekday: ! 1,
+       dayPeriod: ! 1,
+       timeZoneName: ! 1,
+       dateStyle: ! 1,
+       timeStyle: ! 1});
+ return "year" in t || "month" in t
+        || (t = lt(t, {year: "numeric", month: "numeric"})),
+        t;
+}
+function monthDayAmend(e){
+ var
+  t =
+    amend
+     (e,
+      {year: ! 1,
+       hour: ! 1,
+       minute: ! 1,
+       second: ! 1,
+       weekday: ! 1,
+       dayPeriod: ! 1,
+       timeZoneName: ! 1,
+       dateStyle: ! 1,
+       timeStyle: ! 1});
+ return "month" in t || "day" in t
+        || (t = lt({}, t, {month: "numeric", day: "numeric"})),
+        t;
+}
+function dateAmend(e){
+ var
+  t =
+    amend
+     (e,
+      {hour: ! 1,
+       minute: ! 1,
+       second: ! 1,
+       dayPeriod: ! 1,
+       timeZoneName: ! 1,
+       timeStyle: ! 1});
+ return hasDateOptions(t)
+        ||
+         (t = lt({}, t, {year: "numeric", month: "numeric", day: "numeric"})),
+        t;
+}
+function datetimeAmend(e){
+ var t = amend(e, {timeZoneName: ! 1});
+ return hasTimeOptions(t) || hasDateOptions(t)
+        ||
+         (t =
+          lt
+           ({},
+            t,
+            {year: "numeric",
+             month: "numeric",
+             day: "numeric",
+             hour: "numeric",
+             minute: "numeric",
+             second: "numeric"})),
+        t;
+}
+function instantAmend(e){
+ var t = e;
+ return hasTimeOptions(t) || hasDateOptions(t)
+        ||
+         (t =
+          lt
+           ({},
+            t,
+            {year: "numeric",
+             month: "numeric",
+             day: "numeric",
+             hour: "numeric",
+             minute: "numeric",
+             second: "numeric"})),
+        t;
+}
+function hasDateOptions(e){
+ return "year" in e || "month" in e || "day" in e || "weekday" in e
+        || "dateStyle" in e;
+}
+function hasTimeOptions(e){
+ return "hour" in e || "minute" in e || "second" in e || "timeStyle" in e
+        || "dayPeriod" in e;
+}
+function isTemporalObject(e){
+ return IsTemporalDate(e) || IsTemporalTime(e) || IsTemporalDateTime(e)
+        || IsTemporalZonedDateTime(e)
+        || IsTemporalYearMonth(e)
+        || IsTemporalMonthDay(e)
+        || IsTemporalInstant(e);
+}
+function sameTemporalType(e, t){
+ return !
+        (! isTemporalObject(e) || ! isTemporalObject(t))
+        && ! (IsTemporalTime(e) && ! IsTemporalTime(t))
+        && ! (IsTemporalDate(e) && ! IsTemporalDate(t))
+        && ! (IsTemporalDateTime(e) && ! IsTemporalDateTime(t))
+        && ! (IsTemporalZonedDateTime(e) && ! IsTemporalZonedDateTime(t))
+        && ! (IsTemporalYearMonth(e) && ! IsTemporalYearMonth(t))
+        && ! (IsTemporalMonthDay(e) && ! IsTemporalMonthDay(t))
+        && ! (IsTemporalInstant(e) && ! IsTemporalInstant(t));
+}
+function extractOverrides(e, t){
+ var r = GetIntrinsic("%Temporal.PlainDateTime%");
+ if(IsTemporalTime(e)){
+  var
+   _o27 =
+     new
+      r
+      (1970,
+       1,
+       1,
+       GetSlot(e, d),
+       GetSlot(e, m),
+       GetSlot(e, c),
+       GetSlot(e, h),
+       GetSlot(e, u),
+       GetSlot(e, T),
+       t[nt]);
+  return {instant: GetInstantFor(t[ot], _o27, "compatible"),
+          formatter: getPropLazy(t, Qe)};
+ }
+ if(IsTemporalYearMonth(e)){
+  var
+   _o28 = GetSlot(e, i),
+   _n17 = GetSlot(e, s),
+   _a13 = GetSlot(e, l),
+   _d7 = ToTemporalCalendarIdentifier(GetSlot(e, p));
+  if(_d7 !== t[nt])
+   throw new
+          RangeError
+          ("cannot format PlainYearMonth with calendar ".concat
+             (_d7, " in locale with calendar ").concat
+            (t[nt]));
+  var _m6 = new r(_o28, _n17, _a13, 12, 0, 0, 0, 0, 0, _d7);
+  return {instant: GetInstantFor(t[ot], _m6, "compatible"),
+          formatter: getPropLazy(t, Ke)};
+ }
+ if(IsTemporalMonthDay(e)){
+  var
+   _o29 = GetSlot(e, i),
+   _n18 = GetSlot(e, s),
+   _a14 = GetSlot(e, l),
+   _d8 = ToTemporalCalendarIdentifier(GetSlot(e, p));
+  if(_d8 !== t[nt])
+   throw new
+          RangeError
+          ("cannot format PlainMonthDay with calendar ".concat
+             (_d8, " in locale with calendar ").concat
+            (t[nt]));
+  var _m7 = new r(_o29, _n18, _a14, 12, 0, 0, 0, 0, 0, _d8);
+  return {instant: GetInstantFor(t[ot], _m7, "compatible"),
+          formatter: getPropLazy(t, Xe)};
+ }
+ if(IsTemporalDate(e)){
+  var
+   _o30 = GetSlot(e, i),
+   _n19 = GetSlot(e, s),
+   _a15 = GetSlot(e, l),
+   _d9 = ToTemporalCalendarIdentifier(GetSlot(e, p));
+  if("iso8601" !== _d9 && _d9 !== t[nt])
+   throw new
+          RangeError
+          ("cannot format PlainDate with calendar ".concat
+             (_d9, " in locale with calendar ").concat
+            (t[nt]));
+  var _m8 = new r(_o30, _n19, _a15, 12, 0, 0, 0, 0, 0, t[nt]);
+  return {instant: GetInstantFor(t[ot], _m8, "compatible"),
+          formatter: getPropLazy(t, Je)};
+ }
+ if(IsTemporalDateTime(e)){
+  var
+   _o31 = GetSlot(e, i),
+   _n20 = GetSlot(e, s),
+   _a16 = GetSlot(e, l),
+   _f5 = GetSlot(e, d),
+   _y = GetSlot(e, m),
+   _I3 = GetSlot(e, c),
+   _S3 = GetSlot(e, h),
+   _g2 = GetSlot(e, u),
+   _w = GetSlot(e, T),
+   _D = ToTemporalCalendarIdentifier(GetSlot(e, p));
+  if("iso8601" !== _D && _D !== t[nt])
+   throw new
+          RangeError
+          ("cannot format PlainDateTime with calendar ".concat
+             (_D, " in locale with calendar ").concat
+            (t[nt]));
+  var _G = e;
+  return "iso8601" === _D
+         && (_G = new r(_o31, _n20, _a16, _f5, _y, _I3, _S3, _g2, _w, t[nt])),
+         {instant: GetInstantFor(t[ot], _G, "compatible"),
+          formatter: getPropLazy(t, et)};
+ }
+ if(IsTemporalZonedDateTime(e))
+  throw new
+         TypeError
+         ("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
+ return IsTemporalInstant(e)
+         ? {instant: e, formatter: getPropLazy(t, tt)}
+         : {};
+}
+var ut = Object.freeze({__proto__: null, DateTimeFormat: ht});
+var
+ Instant =
+   function(){
+     function Instant(e){
+      _classCallCheck(this, Instant);
+      if(arguments.length < 1)
+       throw new TypeError("missing argument: epochNanoseconds is required");
       var t = ToBigInt(e);
-      return ValidateEpochNanoseconds(t), new Instant(t);
+      ValidateEpochNanoseconds(t), N(this), SetSlot(this, n, t);
+     }
+     return _createClass
+             (Instant,
+              [{key: "epochSeconds",
+                get:
+                function get(){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 var t = GetSlot(this, n);
+                 return Number(BigIntFloorDiv(t, ve));
+                }},
+               {key: "epochMilliseconds",
+                get:
+                function get(){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 var t = BigInt(GetSlot(this, n));
+                 return Number(BigIntFloorDiv(t, Ge));
+                }},
+               {key: "epochMicroseconds",
+                get:
+                function get(){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return ToBigIntExternal
+                         (BigIntFloorDiv(BigInt(GetSlot(this, n)), De));
+                }},
+               {key: "epochNanoseconds",
+                get:
+                function get(){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return ToBigIntExternal(BigInt(GetSlot(this, n)));
+                }},
+               {key: "add",
+                value:
+                function add(e){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromInstant
+                         ("add", this, e);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromInstant
+                         ("subtract", this, e);
+                }},
+               {key: "until",
+                value:
+                function until(e, t){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalInstant("until", this, e, t);
+                }},
+               {key: "since",
+                value:
+                function since(e, t){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalInstant("since", this, e, t);
+                }},
+               {key: "round",
+                value:
+                function round(e){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 if(void 0 === e)
+                  throw new TypeError("options parameter is required");
+                 var
+                  t =
+                    "string" == typeof e
+                     ? CreateOnePropObject("smallestUnit", e)
+                     : GetOptionsObject(e),
+                  r = ToTemporalRoundingIncrement(t),
+                  o = ToTemporalRoundingMode(t, "halfExpand"),
+                  a = GetTemporalUnit(t, "smallestUnit", "time", He);
+                 ValidateTemporalRoundingIncrement
+                  (r,
+                   {hour: 24,
+                     minute: 1440,
+                     second: 86400,
+                     millisecond: 864e5,
+                     microsecond: 864e8,
+                     nanosecond: 864e11}
+                    [a],
+                   ! 0);
+                 var i = RoundInstant(GetSlot(this, n), r, a, o);
+                 return new Instant(i);
+                }},
+               {key: "equals",
+                value:
+                function equals(t){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  r = ToTemporalInstant(t),
+                  o = GetSlot(this, n),
+                  a = GetSlot(r, n);
+                 return BigInt(o) === BigInt(a);
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetOptionsObject(e),
+                  r = ToFractionalSecondDigits(t),
+                  o = ToTemporalRoundingMode(t, "trunc"),
+                  a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
+                 if("hour" === a)
+                  throw new
+                         RangeError
+                         ('smallestUnit must be a time unit other than "hour"');
+                 var i = t.timeZone;
+                 void 0 !== i && (i = ToTemporalTimeZoneSlotValue(i));
+                 var
+                  _ToSecondsStringPreci = ToSecondsStringPrecisionRecord(a, r),
+                  s = _ToSecondsStringPreci.precision,
+                  l = _ToSecondsStringPreci.unit,
+                  d = _ToSecondsStringPreci.increment,
+                  m = RoundInstant(GetSlot(this, n), d, l, o);
+                 return TemporalInstantToString(new Instant(m), i, s);
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalInstantToString(this, void 0, "auto");
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 return new ht(e, t).format(this);
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() or equals() to compare Temporal.Instant");
+                }},
+               {key: "toZonedDateTime",
+                value:
+                function toZonedDateTime(e){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e))
+                  throw new TypeError("invalid argument in toZonedDateTime");
+                 var t = e.calendar;
+                 if(void 0 === t)
+                  throw new
+                         TypeError
+                         ("missing calendar property in toZonedDateTime");
+                 var r = ToTemporalCalendarSlotValue(t), o = e.timeZone;
+                 if(void 0 === o)
+                  throw new
+                         TypeError
+                         ("missing timeZone property in toZonedDateTime");
+                 var a = ToTemporalTimeZoneSlotValue(o);
+                 return CreateTemporalZonedDateTime(GetSlot(this, n), a, r);
+                }},
+               {key: "toZonedDateTimeISO",
+                value:
+                function toZonedDateTimeISO(e){
+                 if(! IsTemporalInstant(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalTimeZoneSlotValue(e);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot(this, n), t, "iso8601");
+                }}],
+              [{key: "fromEpochSeconds",
+                value:
+                function fromEpochSeconds(t){
+                 var r = ToNumber(t), o = BigInt(r) * ve;
+                 return ValidateEpochNanoseconds(o), new Instant(o);
+                }},
+               {key: "fromEpochMilliseconds",
+                value:
+                function fromEpochMilliseconds(t){
+                 var r = ToNumber(t), o = BigInt(r) * Ge;
+                 return ValidateEpochNanoseconds(o), new Instant(o);
+                }},
+               {key: "fromEpochMicroseconds",
+                value:
+                function fromEpochMicroseconds(t){
+                 var r = ToBigInt(t), o = r * De;
+                 return ValidateEpochNanoseconds(o), new Instant(o);
+                }},
+               {key: "fromEpochNanoseconds",
+                value:
+                function fromEpochNanoseconds(e){
+                 var t = ToBigInt(e);
+                 return ValidateEpochNanoseconds(t), new Instant(t);
+                }},
+               {key: "from",
+                value:
+                function from(e){
+                 return IsTemporalInstant(e)
+                         ? new Instant(GetSlot(e, n))
+                         : ToTemporalInstant(e);
+                }},
+               {key: "compare",
+                value:
+                function compare(t, r){
+                 var
+                  o = ToTemporalInstant(t),
+                  a = ToTemporalInstant(r),
+                  i = GetSlot(o, n),
+                  s = GetSlot(a, n);
+                 return i < s ? - 1 : i > s ? 1 : 0;
+                }}]);
     }
-  }, {
-    key: "from",
-    value: function from(e) {
-      return IsTemporalInstant(e) ? new Instant(GetSlot(e, n)) : ToTemporalInstant(e);
-    }
-  }, {
-    key: "compare",
-    value: function compare(t, r) {
-      var o = ToTemporalInstant(t),
-        a = ToTemporalInstant(r),
-        i = GetSlot(o, n),
-        s = GetSlot(a, n);
-      return i < s ? -1 : i > s ? 1 : 0;
-    }
-  }]);
-  return Instant;
-}();
+    ();
 MakeIntrinsicClass(Instant, "Temporal.Instant");
-var Tt = Array.prototype.includes,
-  pt = Array.prototype.push,
-  ft = globalThis.Intl.DateTimeFormat,
-  yt = Array.prototype.sort,
-  It = Math.abs,
-  St = Math.floor,
-  gt = Object.create,
-  wt = Object.entries,
-  Dt = Set,
-  Gt = Reflect.ownKeys,
-  vt = Set.prototype.add,
-  Ct = Set.prototype.values,
-  Ot = {};
-var Calendar = /*#__PURE__*/function () {
-  function Calendar(e) {
-    _classCallCheck(this, Calendar);
-    if (arguments.length < 1) throw new RangeError("missing argument: id is required");
-    var t = ToString(e);
-    if (!IsBuiltinCalendar(t)) throw new RangeError("invalid calendar identifier ".concat(t));
-    N(this), SetSlot(this, F, ASCIILowercase(t));
-  }
-  _createClass(Calendar, [{
-    key: "id",
-    get: function get() {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, F);
-    }
-  }, {
-    key: "dateFromFields",
-    value: function dateFromFields(e, t) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid fields");
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, F);
-      return Ot[o].dateFromFields(e, r, o);
-    }
-  }, {
-    key: "yearMonthFromFields",
-    value: function yearMonthFromFields(e, t) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid fields");
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, F);
-      return Ot[o].yearMonthFromFields(e, r, o);
-    }
-  }, {
-    key: "monthDayFromFields",
-    value: function monthDayFromFields(e, t) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid fields");
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, F);
-      return Ot[o].monthDayFromFields(e, r, o);
-    }
-  }, {
-    key: "fields",
-    value: function fields(e) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var t = [],
-        r = new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
-      var _iterator15 = _createForOfIteratorHelper(e),
-        _step15;
-      try {
-        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
-          var _o32 = _step15.value;
-          if ("string" != typeof _o32) throw new TypeError("invalid fields");
-          if (!r.has(_o32)) throw new RangeError("invalid field name ".concat(_o32));
-          r["delete"](_o32), pt.call(t, _o32);
-        }
-      } catch (err) {
-        _iterator15.e(err);
-      } finally {
-        _iterator15.f();
-      }
-      return Ot[GetSlot(this, F)].fields(t);
-    }
-  }, {
-    key: "mergeFields",
-    value: function mergeFields(e, t) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var r = ToObject(e),
-        o = gt(null);
-      CopyDataProperties(o, r, [], [void 0]);
-      var n = ToObject(t),
-        a = gt(null);
-      CopyDataProperties(a, n, [], [void 0]);
-      var i = Gt(a),
-        s = Ot[GetSlot(this, F)].fieldKeysToIgnore(i),
-        l = gt(null),
-        d = Gt(o);
-      var _iterator16 = _createForOfIteratorHelper(d),
-        _step16;
-      try {
-        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
-          var _e35 = _step16.value;
-          var _t42 = void 0;
-          _t42 = Call(Tt, s, [_e35]) ? a[_e35] : o[_e35], void 0 !== _t42 && (l[_e35] = _t42);
-        }
-      } catch (err) {
-        _iterator16.e(err);
-      } finally {
-        _iterator16.f();
-      }
-      return CopyDataProperties(l, a, []), l;
-    }
-  }, {
-    key: "dateAdd",
-    value: function dateAdd(e, t, r) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var o = ToTemporalDate(e),
-        n = ToTemporalDuration(t),
-        a = ToTemporalOverflow(GetOptionsObject(r)),
-        _BalanceDuration10 = BalanceDuration(GetSlot(n, v), GetSlot(n, C), GetSlot(n, O), GetSlot(n, b), GetSlot(n, E), GetSlot(n, M), GetSlot(n, R), "day"),
-        i = _BalanceDuration10.days,
-        s = GetSlot(this, F);
-      return Ot[s].dateAdd(o, GetSlot(n, w), GetSlot(n, D), GetSlot(n, G), i, a, s);
-    }
-  }, {
-    key: "dateUntil",
-    value: function dateUntil(e, t, r) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var o = ToTemporalDate(e),
-        n = ToTemporalDate(t);
-      var a = GetTemporalUnit(GetOptionsObject(r), "largestUnit", "date", "auto");
-      "auto" === a && (a = "day");
-      var _Ot$GetSlot$dateUntil = Ot[GetSlot(this, F)].dateUntil(o, n, a),
-        i = _Ot$GetSlot$dateUntil.years,
-        s = _Ot$GetSlot$dateUntil.months,
-        l = _Ot$GetSlot$dateUntil.weeks,
-        d = _Ot$GetSlot$dateUntil.days;
-      return new (GetIntrinsic("%Temporal.Duration%"))(i, s, l, d, 0, 0, 0, 0, 0, 0);
-    }
-  }, {
-    key: "year",
-    value: function year(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].year(t);
-    }
-  }, {
-    key: "month",
-    value: function month(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      if (IsTemporalMonthDay(t)) throw new TypeError("use monthCode on PlainMonthDay instead");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].month(t);
-    }
-  }, {
-    key: "monthCode",
-    value: function monthCode(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || IsTemporalMonthDay(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].monthCode(t);
-    }
-  }, {
-    key: "day",
-    value: function day(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalMonthDay(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].day(t);
-    }
-  }, {
-    key: "era",
-    value: function era(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].era(t);
-    }
-  }, {
-    key: "eraYear",
-    value: function eraYear(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].eraYear(t);
-    }
-  }, {
-    key: "dayOfWeek",
-    value: function dayOfWeek(e) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e);
-      return Ot[GetSlot(this, F)].dayOfWeek(t);
-    }
-  }, {
-    key: "dayOfYear",
-    value: function dayOfYear(e) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e);
-      return Ot[GetSlot(this, F)].dayOfYear(t);
-    }
-  }, {
-    key: "weekOfYear",
-    value: function weekOfYear(e) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e);
-      return Ot[GetSlot(this, F)].weekOfYear(t);
-    }
-  }, {
-    key: "yearOfWeek",
-    value: function yearOfWeek(e) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e);
-      return Ot[GetSlot(this, F)].yearOfWeek(t);
-    }
-  }, {
-    key: "daysInWeek",
-    value: function daysInWeek(e) {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e);
-      return Ot[GetSlot(this, F)].daysInWeek(t);
-    }
-  }, {
-    key: "daysInMonth",
-    value: function daysInMonth(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].daysInMonth(t);
-    }
-  }, {
-    key: "daysInYear",
-    value: function daysInYear(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].daysInYear(t);
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].monthsInYear(t);
-    }
-  }, {
-    key: "inLeapYear",
-    value: function inLeapYear(e) {
-      var t = e;
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)), Ot[GetSlot(this, F)].inLeapYear(t);
-    }
-  }, {
-    key: "toString",
-    value: function toString() {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, F);
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, F);
-    }
-  }], [{
-    key: "from",
-    value: function from(e) {
-      return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e));
-    }
-  }]);
-  return Calendar;
-}();
-function monthCodeNumberPart(e) {
-  if (!e.startsWith("M")) throw new RangeError("Invalid month code: ".concat(e, ".  Month codes must start with M."));
-  var t = +e.slice(1);
-  if (isNaN(t)) throw new RangeError("Invalid month code: ".concat(e));
-  return t;
-}
-function buildMonthCode(e) {
-  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
-  return "M".concat(e.toString().padStart(2, "0")).concat(t ? "L" : "");
-}
-function resolveNonLunisolarMonth(e, t) {
-  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;
-  var o = e.month,
-    n = e.monthCode;
-  if (void 0 === n) {
-    if (void 0 === o) throw new TypeError("Either month or monthCode are required");
-    "reject" === t && RejectToRange(o, 1, r), "constrain" === t && (o = ConstrainToRange(o, 1, r)), n = buildMonthCode(o);
-  } else {
-    var _e36 = monthCodeNumberPart(n);
-    if (void 0 !== o && o !== _e36) throw new RangeError("monthCode ".concat(n, " and month ").concat(o, " must match if both are present"));
-    if (n !== buildMonthCode(_e36)) throw new RangeError("Invalid month code: ".concat(n));
-    if (o = _e36, o < 1 || o > r) throw new RangeError("Invalid monthCode: ".concat(n));
-  }
-  return _objectSpread2(_objectSpread2({}, e), {}, {
-    month: o,
-    monthCode: n
-  });
-}
-MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), DefineIntrinsic("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd), DefineIntrinsic("Temporal.Calendar.prototype.dateFromFields", Calendar.prototype.dateFromFields), DefineIntrinsic("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil), DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day), DefineIntrinsic("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek), DefineIntrinsic("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear), DefineIntrinsic("Temporal.Calendar.prototype.daysInMonth", Calendar.prototype.daysInMonth), DefineIntrinsic("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek), DefineIntrinsic("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear), DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era), DefineIntrinsic("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear), DefineIntrinsic("Temporal.Calendar.prototype.fields", Calendar.prototype.fields), DefineIntrinsic("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear), DefineIntrinsic("Temporal.Calendar.prototype.mergeFields", Calendar.prototype.mergeFields), DefineIntrinsic("Temporal.Calendar.prototype.month", Calendar.prototype.month), DefineIntrinsic("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode), DefineIntrinsic("Temporal.Calendar.prototype.monthDayFromFields", Calendar.prototype.monthDayFromFields), DefineIntrinsic("Temporal.Calendar.prototype.monthsInYear", Calendar.prototype.monthsInYear), DefineIntrinsic("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear), DefineIntrinsic("Temporal.Calendar.prototype.year", Calendar.prototype.year), DefineIntrinsic("Temporal.Calendar.prototype.yearMonthFromFields", Calendar.prototype.yearMonthFromFields), DefineIntrinsic("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek), Ot.iso8601 = {
-  dateFromFields: function dateFromFields(e, t, r) {
-    var _RegulateISODate2;
-    var o = PrepareTemporalFields(e, ["day", "month", "monthCode", "year"], ["year", "day"]);
-    var n = ToTemporalOverflow(t);
-    o = resolveNonLunisolarMonth(o);
-    var _o33 = o,
-      a = _o33.year,
-      i = _o33.month,
-      s = _o33.day;
-    return (_RegulateISODate2 = RegulateISODate(a, i, s, n), a = _RegulateISODate2.year, i = _RegulateISODate2.month, s = _RegulateISODate2.day), CreateTemporalDate(a, i, s, r);
+var
+ Tt = Array.prototype.includes,
+ pt = Array.prototype.push,
+ ft = globalThis.Intl.DateTimeFormat,
+ yt = Array.prototype.sort,
+ It = Math.abs,
+ St = Math.floor,
+ gt = Object.create,
+ wt = Object.entries,
+ Dt = Set,
+ Gt = Reflect.ownKeys,
+ vt = Set.prototype.add,
+ Ct = Set.prototype.values,
+ Ot = {};
+var
+ Calendar =
+   function(){
+     function Calendar(e){
+      _classCallCheck(this, Calendar);
+      if(arguments.length < 1)
+       throw new RangeError("missing argument: id is required");
+      var t = ToString(e);
+      if(! IsBuiltinCalendar(t))
+       throw new RangeError("invalid calendar identifier ".concat(t));
+      N(this), SetSlot(this, F, ASCIILowercase(t));
+     }
+     return _createClass
+             (Calendar,
+              [{key: "id",
+                get:
+                function get(){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, F);
+                }},
+               {key: "dateFromFields",
+                value:
+                function dateFromFields(e, t){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid fields");
+                 var r = GetOptionsObject(t), o = GetSlot(this, F);
+                 return Ot[o].dateFromFields(e, r, o);
+                }},
+               {key: "yearMonthFromFields",
+                value:
+                function yearMonthFromFields(e, t){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid fields");
+                 var r = GetOptionsObject(t), o = GetSlot(this, F);
+                 return Ot[o].yearMonthFromFields(e, r, o);
+                }},
+               {key: "monthDayFromFields",
+                value:
+                function monthDayFromFields(e, t){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid fields");
+                 var r = GetOptionsObject(t), o = GetSlot(this, F);
+                 return Ot[o].monthDayFromFields(e, r, o);
+                }},
+               {key: "fields",
+                value:
+                function fields(e){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = [],
+                  r =
+                    new
+                     Set
+                     (["year",
+                       "month",
+                       "monthCode",
+                       "day",
+                       "hour",
+                       "minute",
+                       "second",
+                       "millisecond",
+                       "microsecond",
+                       "nanosecond"]);
+                 var _iterator15 = _createForOfIteratorHelper(e), _step15;
+                 try{
+                  for(_iterator15.s(); ! (_step15 = _iterator15.n()).done;){
+                   var _o32 = _step15.value;
+                   if("string" != typeof _o32)
+                    throw new TypeError("invalid fields");
+                   if(! r.has(_o32))
+                    throw new RangeError("invalid field name ".concat(_o32));
+                   r["delete"](_o32), pt.call(t, _o32);
+                  }
+                 }
+                 catch(err){_iterator15.e(err);}
+                 finally{_iterator15.f();}
+                 return Ot[GetSlot(this, F)].fields(t);
+                }},
+               {key: "mergeFields",
+                value:
+                function mergeFields(e, t){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var r = ToObject(e), o = gt(null);
+                 CopyDataProperties(o, r, [], [void 0]);
+                 var n = ToObject(t), a = gt(null);
+                 CopyDataProperties(a, n, [], [void 0]);
+                 var
+                  i = Gt(a),
+                  s = Ot[GetSlot(this, F)].fieldKeysToIgnore(i),
+                  l = gt(null),
+                  d = Gt(o);
+                 var _iterator16 = _createForOfIteratorHelper(d), _step16;
+                 try{
+                  for(_iterator16.s(); ! (_step16 = _iterator16.n()).done;){
+                   var _e35 = _step16.value;
+                   var _t42 = void 0;
+                   _t42 = Call(Tt, s, [_e35]) ? a[_e35] : o[_e35],
+                   void 0 !== _t42 && (l[_e35] = _t42);
+                  }
+                 }
+                 catch(err){_iterator16.e(err);}
+                 finally{_iterator16.f();}
+                 return CopyDataProperties(l, a, []), l;
+                }},
+               {key: "dateAdd",
+                value:
+                function dateAdd(e, t, r){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  o = ToTemporalDate(e),
+                  n = ToTemporalDuration(t),
+                  a = ToTemporalOverflow(GetOptionsObject(r)),
+                  _BalanceDuration10 =
+                    BalanceDuration
+                     (GetSlot(n, v),
+                      GetSlot(n, C),
+                      GetSlot(n, O),
+                      GetSlot(n, b),
+                      GetSlot(n, E),
+                      GetSlot(n, M),
+                      GetSlot(n, R),
+                      "day"),
+                  i = _BalanceDuration10.days,
+                  s = GetSlot(this, F);
+                 return Ot[s].dateAdd
+                         (o, GetSlot(n, w), GetSlot(n, D), GetSlot(n, G), i, a, s);
+                }},
+               {key: "dateUntil",
+                value:
+                function dateUntil(e, t, r){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var o = ToTemporalDate(e), n = ToTemporalDate(t);
+                 var
+                  a =
+                    GetTemporalUnit
+                     (GetOptionsObject(r), "largestUnit", "date", "auto");
+                 "auto" === a && (a = "day");
+                 var
+                  _Ot$GetSlot$dateUntil =
+                    Ot[GetSlot(this, F)].dateUntil(o, n, a),
+                  i = _Ot$GetSlot$dateUntil.years,
+                  s = _Ot$GetSlot$dateUntil.months,
+                  l = _Ot$GetSlot$dateUntil.weeks,
+                  d = _Ot$GetSlot$dateUntil.days;
+                 return new
+                         (GetIntrinsic("%Temporal.Duration%"))
+                         (i, s, l, d, 0, 0, 0, 0, 0, 0);
+                }},
+               {key: "year",
+                value:
+                function year(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].year(t);
+                }},
+               {key: "month",
+                value:
+                function month(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 if(IsTemporalMonthDay(t))
+                  throw new
+                         TypeError
+                         ("use monthCode on PlainMonthDay instead");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].month(t);
+                }},
+               {key: "monthCode",
+                value:
+                function monthCode(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || IsTemporalMonthDay(t)
+                        || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].monthCode(t);
+                }},
+               {key: "day",
+                value:
+                function day(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalMonthDay(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].day(t);
+                }},
+               {key: "era",
+                value:
+                function era(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].era(t);
+                }},
+               {key: "eraYear",
+                value:
+                function eraYear(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].eraYear(t);
+                }},
+               {key: "dayOfWeek",
+                value:
+                function dayOfWeek(e){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDate(e);
+                 return Ot[GetSlot(this, F)].dayOfWeek(t);
+                }},
+               {key: "dayOfYear",
+                value:
+                function dayOfYear(e){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDate(e);
+                 return Ot[GetSlot(this, F)].dayOfYear(t);
+                }},
+               {key: "weekOfYear",
+                value:
+                function weekOfYear(e){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDate(e);
+                 return Ot[GetSlot(this, F)].weekOfYear(t);
+                }},
+               {key: "yearOfWeek",
+                value:
+                function yearOfWeek(e){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDate(e);
+                 return Ot[GetSlot(this, F)].yearOfWeek(t);
+                }},
+               {key: "daysInWeek",
+                value:
+                function daysInWeek(e){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDate(e);
+                 return Ot[GetSlot(this, F)].daysInWeek(t);
+                }},
+               {key: "daysInMonth",
+                value:
+                function daysInMonth(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].daysInMonth(t);
+                }},
+               {key: "daysInYear",
+                value:
+                function daysInYear(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].daysInYear(t);
+                }},
+               {key: "monthsInYear",
+                value:
+                function monthsInYear(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].monthsInYear(t);
+                }},
+               {key: "inLeapYear",
+                value:
+                function inLeapYear(e){
+                 var t = e;
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
+                        Ot[GetSlot(this, F)].inLeapYear(t);
+                }},
+               {key: "toString",
+                value:
+                function toString(){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, F);
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalCalendar(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, F);
+                }}],
+              [{key: "from",
+                value:
+                function from(e){
+                 return ToTemporalCalendarObject
+                         (ToTemporalCalendarSlotValue(e));
+                }}]);
+    }
+    ();
+function monthCodeNumberPart(e){
+ if(! e.startsWith("M"))
+  throw new
+         RangeError
+         ("Invalid month code: ".concat
+           (e, ".  Month codes must start with M."));
+ var t = + e.slice(1);
+ if(isNaN(t)) throw new RangeError("Invalid month code: ".concat(e));
+ return t;
+}
+function buildMonthCode(e){
+ var
+  t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ! 1;
+ return "M".concat(e.toString().padStart(2, "0")).concat(t ? "L" : "");
+}
+function resolveNonLunisolarMonth(e, t){
+ var
+  r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;
+ var o = e.month, n = e.monthCode;
+ if(void 0 === n){
+  if(void 0 === o)
+   throw new TypeError("Either month or monthCode are required");
+  "reject" === t && RejectToRange(o, 1, r),
+  "constrain" === t && (o = ConstrainToRange(o, 1, r)),
+  n = buildMonthCode(o);
+ }
+ else{
+  var _e36 = monthCodeNumberPart(n);
+  if(void 0 !== o && o !== _e36)
+   throw new
+          RangeError
+          ("monthCode ".concat(n, " and month ").concat
+            (o, " must match if both are present"));
+  if(n !== buildMonthCode(_e36))
+   throw new RangeError("Invalid month code: ".concat(n));
+  if(o = _e36, o < 1 || o > r)
+   throw new RangeError("Invalid monthCode: ".concat(n));
+ }
+ return _objectSpread2(_objectSpread2({}, e), {}, {month: o, monthCode: n});
+}
+MakeIntrinsicClass(Calendar, "Temporal.Calendar"),
+DefineIntrinsic("Temporal.Calendar.from", Calendar.from),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.dateFromFields",
+  Calendar.prototype.dateFromFields),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil),
+DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.daysInMonth", Calendar.prototype.daysInMonth),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear),
+DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.fields", Calendar.prototype.fields),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.mergeFields", Calendar.prototype.mergeFields),
+DefineIntrinsic("Temporal.Calendar.prototype.month", Calendar.prototype.month),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.monthDayFromFields",
+  Calendar.prototype.monthDayFromFields),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.monthsInYear", Calendar.prototype.monthsInYear),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear),
+DefineIntrinsic("Temporal.Calendar.prototype.year", Calendar.prototype.year),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.yearMonthFromFields",
+  Calendar.prototype.yearMonthFromFields),
+DefineIntrinsic
+ ("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek),
+Ot.iso8601 =
+ {dateFromFields:
+  function dateFromFields(e, t, r){
+   var _RegulateISODate2;
+   var
+    o =
+      PrepareTemporalFields
+       (e, ["day", "month", "monthCode", "year"], ["year", "day"]);
+   var n = ToTemporalOverflow(t);
+   o = resolveNonLunisolarMonth(o);
+   var _o33 = o, a = _o33.year, i = _o33.month, s = _o33.day;
+   return _RegulateISODate2 = RegulateISODate(a, i, s, n),
+          a = _RegulateISODate2.year,
+          i = _RegulateISODate2.month,
+          s = _RegulateISODate2.day,
+          CreateTemporalDate(a, i, s, r);
   },
-  yearMonthFromFields: function yearMonthFromFields(e, t, r) {
-    var _RegulateISOYearMonth;
-    var o = PrepareTemporalFields(e, ["month", "monthCode", "year"], ["year"]);
-    var n = ToTemporalOverflow(t);
-    o = resolveNonLunisolarMonth(o);
-    var _o34 = o,
-      a = _o34.year,
-      i = _o34.month;
-    return (_RegulateISOYearMonth = function RegulateISOYearMonth(e, t, r) {
-      var o = e,
-        n = t;
-      switch (r) {
-        case "reject":
-          RejectISODate(o, n, 1);
-          break;
-        case "constrain":
-          var _ConstrainISODate2 = ConstrainISODate(o, n);
-          o = _ConstrainISODate2.year;
-          n = _ConstrainISODate2.month;
-      }
-      return {
-        year: o,
-        month: n
-      };
-    }(a, i, n), a = _RegulateISOYearMonth.year, i = _RegulateISOYearMonth.month), CreateTemporalYearMonth(a, i, r, 1);
-  },
-  monthDayFromFields: function monthDayFromFields(e, t, r) {
-    var _RegulateISODate3;
-    var o = PrepareTemporalFields(e, ["day", "month", "monthCode", "year"], ["day"]);
-    var n = ToTemporalOverflow(t);
-    if (void 0 !== o.month && void 0 === o.year && void 0 === o.monthCode) throw new TypeError("either year or monthCode required with month");
-    var a = void 0 === o.monthCode;
-    o = resolveNonLunisolarMonth(o);
-    var _o35 = o,
-      i = _o35.month,
-      s = _o35.day,
-      l = _o35.year;
-    return (_RegulateISODate3 = RegulateISODate(a ? l : 1972, i, s, n), i = _RegulateISODate3.month, s = _RegulateISODate3.day), CreateTemporalMonthDay(i, s, r, 1972);
-  },
-  fields: function fields(e) {
-    return e;
-  },
-  fieldKeysToIgnore: function fieldKeysToIgnore(e) {
-    var t = new Dt();
-    for (var _r58 = 0; _r58 < e.length; _r58++) {
-      var _o36 = e[_r58];
-      Call(vt, t, [_o36]), "month" === _o36 ? Call(vt, t, ["monthCode"]) : "monthCode" === _o36 && Call(vt, t, ["month"]);
-    }
-    return _toConsumableArray(Call(Ct, t, []));
-  },
-  dateAdd: function dateAdd(e, t, r, o, n, a, d) {
-    var _AddISODate;
-    var m = GetSlot(e, i),
-      c = GetSlot(e, s),
-      h = GetSlot(e, l);
-    return (_AddISODate = AddISODate(m, c, h, t, r, o, n, a), m = _AddISODate.year, c = _AddISODate.month, h = _AddISODate.day), CreateTemporalDate(m, c, h, d);
-  },
-  dateUntil: function dateUntil(e, t, r) {
-    return DifferenceISODate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(t, i), GetSlot(t, s), GetSlot(t, l), r);
-  },
-  year: function year(e) {
-    return GetSlot(e, i);
-  },
-  era: function era() {},
-  eraYear: function eraYear() {},
-  month: function month(e) {
-    return GetSlot(e, s);
+  yearMonthFromFields:
+  function yearMonthFromFields(e, t, r){
+   var _RegulateISOYearMonth;
+   var o = PrepareTemporalFields(e, ["month", "monthCode", "year"], ["year"]);
+   var n = ToTemporalOverflow(t);
+   o = resolveNonLunisolarMonth(o);
+   var _o34 = o, a = _o34.year, i = _o34.month;
+   return _RegulateISOYearMonth =
+           function RegulateISOYearMonth(e, t, r){
+             var o = e, n = t;
+             switch(r){
+               case "reject":
+                RejectISODate(o, n, 1); break;
+               case "constrain":
+                var _ConstrainISODate2 = ConstrainISODate(o, n);
+                o = _ConstrainISODate2.year;
+                n = _ConstrainISODate2.month;
+             }
+             return {year: o, month: n};
+            }
+            (a, i, n),
+          a = _RegulateISOYearMonth.year,
+          i = _RegulateISOYearMonth.month,
+          CreateTemporalYearMonth(a, i, r, 1);
   },
-  monthCode: function monthCode(e) {
-    return buildMonthCode(GetSlot(e, s));
+  monthDayFromFields:
+  function monthDayFromFields(e, t, r){
+   var _RegulateISODate3;
+   var
+    o =
+      PrepareTemporalFields(e, ["day", "month", "monthCode", "year"], ["day"]);
+   var n = ToTemporalOverflow(t);
+   if(void 0 !== o.month && void 0 === o.year && void 0 === o.monthCode)
+    throw new TypeError("either year or monthCode required with month");
+   var a = void 0 === o.monthCode;
+   o = resolveNonLunisolarMonth(o);
+   var _o35 = o, i = _o35.month, s = _o35.day, l = _o35.year;
+   return _RegulateISODate3 = RegulateISODate(a ? l : 1972, i, s, n),
+          i = _RegulateISODate3.month,
+          s = _RegulateISODate3.day,
+          CreateTemporalMonthDay(i, s, r, 1972);
   },
-  day: function day(e) {
-    return GetSlot(e, l);
+  fields: function fields(e){return e;},
+  fieldKeysToIgnore:
+  function fieldKeysToIgnore(e){
+   var t = new Dt();
+   for(var _r58 = 0; _r58 < e.length; _r58++){
+    var _o36 = e[_r58];
+    Call(vt, t, [_o36]),
+    "month" === _o36
+     ? Call(vt, t, ["monthCode"])
+     : "monthCode" === _o36 && Call(vt, t, ["month"]);
+   }
+   return _toConsumableArray(Call(Ct, t, []));
   },
-  dayOfWeek: function dayOfWeek(e) {
-    return DayOfWeek(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
+  dateAdd:
+  function dateAdd(e, t, r, o, n, a, d){
+   var _AddISODate;
+   var m = GetSlot(e, i), c = GetSlot(e, s), h = GetSlot(e, l);
+   return _AddISODate = AddISODate(m, c, h, t, r, o, n, a),
+          m = _AddISODate.year,
+          c = _AddISODate.month,
+          h = _AddISODate.day,
+          CreateTemporalDate(m, c, h, d);
   },
-  dayOfYear: function dayOfYear(e) {
-    return DayOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
+  dateUntil:
+  function dateUntil(e, t, r){
+   return DifferenceISODate
+           (GetSlot(e, i),
+            GetSlot(e, s),
+            GetSlot(e, l),
+            GetSlot(t, i),
+            GetSlot(t, s),
+            GetSlot(t, l),
+            r);
   },
-  weekOfYear: function weekOfYear(e) {
-    return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).week;
+  year: function year(e){return GetSlot(e, i);},
+  era: function era(){},
+  eraYear: function eraYear(){},
+  month: function month(e){return GetSlot(e, s);},
+  monthCode: function monthCode(e){return buildMonthCode(GetSlot(e, s));},
+  day: function day(e){return GetSlot(e, l);},
+  dayOfWeek:
+  function dayOfWeek(e){
+   return DayOfWeek(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
   },
-  yearOfWeek: function yearOfWeek(e) {
-    return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).year;
+  dayOfYear:
+  function dayOfYear(e){
+   return DayOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
   },
-  daysInWeek: function daysInWeek() {
-    return 7;
+  weekOfYear:
+  function weekOfYear(e){
+   return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).week;
   },
-  daysInMonth: function daysInMonth(e) {
-    return ISODaysInMonth(GetSlot(e, i), GetSlot(e, s));
+  yearOfWeek:
+  function yearOfWeek(e){
+   return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).year;
   },
-  daysInYear: function daysInYear(e) {
-    var t = e;
-    return HasSlot(t, i) || (t = ToTemporalDate(t)), LeapYear(GetSlot(t, i)) ? 366 : 365;
+  daysInWeek: function daysInWeek(){return 7;},
+  daysInMonth:
+  function daysInMonth(e){
+   return ISODaysInMonth(GetSlot(e, i), GetSlot(e, s));
   },
-  monthsInYear: function monthsInYear() {
-    return 12;
+  daysInYear:
+  function daysInYear(e){
+   var t = e;
+   return HasSlot(t, i) || (t = ToTemporalDate(t)),
+          LeapYear(GetSlot(t, i)) ? 366 : 365;
   },
-  inLeapYear: function inLeapYear(e) {
-    var t = e;
-    return HasSlot(t, i) || (t = ToTemporalDate(t)), LeapYear(GetSlot(t, i));
-  }
-};
-var OneObjectCache = /*#__PURE__*/function () {
-  function OneObjectCache(e) {
-    _classCallCheck(this, OneObjectCache);
-    if (this.map = new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e) {
-      var _t43 = 0;
-      var _iterator17 = _createForOfIteratorHelper(e.map.entries()),
-        _step17;
-      try {
-        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
-          var _this$map;
-          var _r59 = _step17.value;
-          if (++_t43 > OneObjectCache.MAX_CACHE_ENTRIES) break;
-          (_this$map = this.map).set.apply(_this$map, _toConsumableArray(_r59));
-        }
-      } catch (err) {
-        _iterator17.e(err);
-      } finally {
-        _iterator17.f();
-      }
-    }
-  }
-  _createClass(OneObjectCache, [{
-    key: "get",
-    value: function get(e) {
-      var t = this.map.get(e);
-      return t && (this.hits++, this.report()), this.calls++, t;
-    }
-  }, {
-    key: "set",
-    value: function set(e, t) {
-      this.map.set(e, t), this.misses++, this.report();
-    }
-  }, {
-    key: "report",
-    value: function report() {}
-  }, {
-    key: "setObject",
-    value: function setObject(e) {
-      if (OneObjectCache.objectMap.get(e)) throw new RangeError("object already cached");
-      OneObjectCache.objectMap.set(e, this), this.report();
-    }
-  }], [{
-    key: "getCacheForObject",
-    value: function getCacheForObject(e) {
-      var t = OneObjectCache.objectMap.get(e);
-      return t || (t = new OneObjectCache(), OneObjectCache.objectMap.set(e, t)), t;
-    }
-  }]);
-  return OneObjectCache;
-}();
-function toUtcIsoDateString(_ref8) {
-  var e = _ref8.isoYear,
-    t = _ref8.isoMonth,
-    r = _ref8.isoDay;
-  return "".concat(ISOYearString(e), "-").concat(ISODateTimePartString(t), "-").concat(ISODateTimePartString(r), "T00:00Z");
-}
-function simpleDateDiff(e, t) {
-  return {
-    years: e.year - t.year,
-    months: e.month - t.month,
-    days: e.day - t.day
-  };
-}
-OneObjectCache.objectMap = new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
-var HelperBase = /*#__PURE__*/function () {
-  function HelperBase() {
-    _classCallCheck(this, HelperBase);
-    this.eraLength = "short", this.hasEra = !0, this.erasBeginMidYear = !1;
-  }
-  _createClass(HelperBase, [{
-    key: "getFormatter",
-    value: function getFormatter() {
-      return void 0 === this.formatter && (this.formatter = new ft("en-US-u-ca-".concat(this.id), {
-        day: "numeric",
-        month: "numeric",
-        year: "numeric",
-        era: this.eraLength,
-        timeZone: "UTC"
-      })), this.formatter;
-    }
-  }, {
-    key: "isoToCalendarDate",
-    value: function isoToCalendarDate(e, t) {
-      var _this = this;
-      var r = e.year,
-        o = e.month,
-        n = e.day,
-        a = JSON.stringify({
-          func: "isoToCalendarDate",
-          isoYear: r,
-          isoMonth: o,
-          isoDay: n,
-          id: this.id
-        }),
-        i = t.get(a);
-      if (i) return i;
-      var s = this.getFormatter();
-      var l, d;
-      try {
-        d = toUtcIsoDateString({
-          isoYear: r,
-          isoMonth: o,
-          isoDay: n
-        }), l = s.formatToParts(new Date(d));
-      } catch (e) {
-        throw new RangeError("Invalid ISO date: ".concat(JSON.stringify({
-          isoYear: r,
-          isoMonth: o,
-          isoDay: n
-        })));
-      }
-      var m = {};
-      var _iterator18 = _createForOfIteratorHelper(l),
-        _step18;
-      try {
-        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
-          var _step18$value = _step18.value,
-            _e37 = _step18$value.type,
-            _t45 = _step18$value.value;
-          if ("year" === _e37 && (m.eraYear = +_t45), "relatedYear" === _e37 && (m.eraYear = +_t45), "month" === _e37) {
-            var _e38 = /^([0-9]*)(.*?)$/.exec(_t45);
-            if (!_e38 || 3 != _e38.length || !_e38[1] && !_e38[2]) throw new RangeError("Unexpected month: ".concat(_t45));
-            if (m.month = _e38[1] ? +_e38[1] : 1, m.month < 1) throw new RangeError("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat(this.id, "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)"));
-            if (m.month > 13) throw new RangeError("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat(this.id, "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
-            _e38[2] && (m.monthExtra = _e38[2]);
-          }
-          "day" === _e37 && (m.day = +_t45), this.hasEra && "era" === _e37 && null != _t45 && "" !== _t45 && (_t45 = _t45.split(" (")[0], m.era = _t45.normalize("NFD").replace(/(?:[\0-\x1F!-,\.\/:-@\[-`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u036F\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482-\u0489\u0530\u0557\u0558\u055A-\u055F\u0589-\u05CF\u05EB-\u05EE\u05F3-\u061F\u064B-\u066D\u0670\u06D4\u06D6-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u06FD\u06FE\u0700-\u070F\u0711\u0730-\u074C\u07A6-\u07B0\u07B2-\u07C9\u07EB-\u07F3\u07F6-\u07F9\u07FB-\u07FF\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u083F\u0859-\u085F\u086B-\u086F\u0888\u088F-\u089F\u08CA-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0970\u0981-\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA-\u09BC\u09BE-\u09CD\u09CF-\u09DB\u09DE\u09E2-\u09EF\u09F2-\u09FB\u09FD-\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A-\u0A58\u0A5D\u0A5F-\u0A71\u0A75-\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA-\u0ABC\u0ABE-\u0ACF\u0AD1-\u0ADF\u0AE2-\u0AF8\u0AFA-\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A-\u0B3C\u0B3E-\u0B5B\u0B5E\u0B62-\u0B70\u0B72-\u0B82\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BCF\u0BD1-\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C3E-\u0C57\u0C5B\u0C5C\u0C5E\u0C5F\u0C62-\u0C7F\u0C81-\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA-\u0CBC\u0CBE-\u0CDC\u0CDF\u0CE2-\u0CF0\u0CF3-\u0D03\u0D0D\u0D11\u0D3B\u0D3C\u0D3E-\u0D4D\u0D4F-\u0D53\u0D57-\u0D5E\u0D62-\u0D79\u0D80-\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0E00\u0E31\u0E34-\u0E3F\u0E47-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EB1\u0EB4-\u0EBC\u0EBE\u0EBF\u0EC5\u0EC7-\u0EDB\u0EE0-\u0EFF\u0F01-\u0F3F\u0F48\u0F6D-\u0F87\u0F8D-\u0FFF\u102B-\u103E\u1040-\u104F\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16F0\u16F9-\u16FF\u1712-\u171E\u1732-\u173F\u1752-\u175F\u176D\u1771-\u177F\u17B4-\u17D6\u17D8-\u17DB\u17DD-\u181F\u1879-\u187F\u1885\u1886\u18A9\u18AB-\u18AF\u18F6-\u18FF\u191F-\u194F\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19FF\u1A17-\u1A1F\u1A55-\u1AA6\u1AA8-\u1B04\u1B34-\u1B44\u1B4D-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BFF\u1C24-\u1C4C\u1C50-\u1C59\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1CFB-\u1CFF\u1DC0-\u1DFF\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u2182\u2185-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7F\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF-\u2E2E\u2E30-\u3004\u3007-\u3030\u3036-\u303A\u303D-\u3040\u3097-\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA620-\uA629\uA62C-\uA63F\uA66F-\uA67E\uA69E\uA69F\uA6E6-\uA716\uA720\uA721\uA789\uA78A\uA7CB-\uA7CF\uA7D2\uA7D4\uA7DA-\uA7F1\uA802\uA806\uA80B\uA823-\uA83F\uA874-\uA881\uA8B4-\uA8F1\uA8F8-\uA8FA\uA8FC\uA8FF-\uA909\uA926-\uA92F\uA947-\uA95F\uA97D-\uA983\uA9B3-\uA9CE\uA9D0-\uA9DF\uA9E5\uA9F0-\uA9F9\uA9FF\uAA29-\uAA3F\uAA43\uAA4C-\uAA5F\uAA77-\uAA79\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAC3-\uAADA\uAADE\uAADF\uAAEB-\uAAF1\uAAF5-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABE3-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB1E\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFE6F\uFE75\uFEFD-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEFF\uDF20-\uDF2C\uDF41\uDF4A-\uDF4F\uDF76-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0-\uDFFF]|\uD801[\uDC9E-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6F\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE01-\uDE0F\uDE14\uDE18\uDE36-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE5-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD24-\uDE7F\uDEAA-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF46-\uDF6F\uDF82-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC00-\uDC02\uDC38-\uDC70\uDC73\uDC74\uDC76-\uDC82\uDCB0-\uDCCF\uDCE9-\uDD02\uDD27-\uDD43\uDD45\uDD46\uDD48-\uDD4F\uDD73-\uDD75\uDD77-\uDD82\uDDB3-\uDDC0\uDDC5-\uDDD9\uDDDB\uDDDD-\uDDFF\uDE12\uDE2C-\uDE3E\uDE41-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEDF-\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A-\uDF3C\uDF3E-\uDF4F\uDF51-\uDF5C\uDF62-\uDFFF]|\uD805[\uDC35-\uDC46\uDC4B-\uDC5E\uDC62-\uDC7F\uDCB0-\uDCC3\uDCC6\uDCC8-\uDD7F\uDDAF-\uDDD7\uDDDC-\uDDFF\uDE30-\uDE43\uDE45-\uDE7F\uDEAB-\uDEB7\uDEB9-\uDEFF\uDF1B-\uDF3F\uDF47-\uDFFF]|\uD806[\uDC2C-\uDC9F\uDCE0-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD30-\uDD3E\uDD40\uDD42-\uDD9F\uDDA8\uDDA9\uDDD1-\uDDE0\uDDE2\uDDE4-\uDDFF\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE4F\uDE51-\uDE5B\uDE8A-\uDE9C\uDE9E-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC2F-\uDC3F\uDC41-\uDC71\uDC90-\uDCFF\uDD07\uDD0A\uDD31-\uDD45\uDD47-\uDD5F\uDD66\uDD69\uDD8A-\uDD97\uDD99-\uDEDF\uDEF3-\uDF01\uDF03\uDF11\uDF34-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC00-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD834\uD836\uD83C-\uD83F\uD87C\uD87D\uD87F\uD889-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF1-\uDFFF]|\uD80D[\uDC30-\uDC40\uDC47-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F-\uDE6F\uDEBF-\uDECF\uDEEE-\uDEFF\uDF30-\uDF3F\uDF44-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4F\uDF51-\uDF92\uDFA0-\uDFDF\uDFE2\uDFE4-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD31\uDD33-\uDD4F\uDD53\uDD54\uDD56-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDF24\uDF2B-\uDFFF]|\uD838[\uDC00-\uDC2F\uDC6E-\uDCFF\uDD2D-\uDD36\uDD3E-\uDD4D\uDD4F-\uDE8F\uDEAE-\uDEBF\uDEEC-\uDFFF]|\uD839[\uDC00-\uDCCF\uDCEC-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5-\uDCFF\uDD44-\uDD4A\uDD4C-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF3A-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFEF]|\uD87B[\uDE5E-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDF4F]|\uD888[\uDFB0-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, "").replace(" ", "-").toLowerCase());
-        }
-      } catch (err) {
-        _iterator18.e(err);
-      } finally {
-        _iterator18.f();
-      }
-      if (void 0 === m.eraYear) throw new RangeError("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat(this.id, " calendar. Try Node 14+ or modern browsers."));
-      if (this.reviseIntlEra) {
-        var _this$reviseIntlEra = this.reviseIntlEra(m, e),
-          _t44 = _this$reviseIntlEra.era,
-          _r60 = _this$reviseIntlEra.eraYear;
-        m.era = _t44, m.eraYear = _r60;
-      }
-      this.checkIcuBugs && this.checkIcuBugs(e);
-      var c = this.adjustCalendarDate(m, t, "constrain", !0);
-      if (void 0 === c.year) throw new RangeError("Missing year converting ".concat(JSON.stringify(e)));
-      if (void 0 === c.month) throw new RangeError("Missing month converting ".concat(JSON.stringify(e)));
-      if (void 0 === c.day) throw new RangeError("Missing day converting ".concat(JSON.stringify(e)));
-      return t.set(a, c), ["constrain", "reject"].forEach(function (r) {
-        var o = JSON.stringify({
-          func: "calendarToIsoDate",
-          year: c.year,
-          month: c.month,
-          day: c.day,
-          overflow: r,
-          id: _this.id
-        });
-        t.set(o, e);
-      }), c;
-    }
-  }, {
-    key: "validateCalendarDate",
-    value: function validateCalendarDate(e) {
-      var t = e.era,
-        r = e.month,
-        o = e.year,
-        n = e.day,
-        a = e.eraYear,
-        i = e.monthCode,
-        s = e.monthExtra;
-      if (void 0 !== s) throw new RangeError("Unexpected `monthExtra` value");
-      if (void 0 === o && void 0 === a) throw new TypeError("year or eraYear is required");
-      if (void 0 === r && void 0 === i) throw new TypeError("month or monthCode is required");
-      if (void 0 === n) throw new RangeError("Missing day");
-      if (void 0 !== i) {
-        if ("string" != typeof i) throw new RangeError("monthCode must be a string, not " + _typeof(i));
-        if (!/^M([01]?\d)(L?)$/.test(i)) throw new RangeError("Invalid monthCode: ".concat(i));
-      }
-      if (this.constantEra) {
-        if (void 0 !== t && t !== this.constantEra) throw new RangeError("era must be ".concat(this.constantEra, ", not ").concat(t));
-        if (void 0 !== a && void 0 !== o && a !== o) throw new RangeError("eraYear ".concat(a, " does not match year ").concat(o));
-      }
-      if (this.hasEra && void 0 === e.era != (void 0 === e.eraYear)) throw new RangeError("properties 'era' and 'eraYear' must be provided together");
-    }
-  }, {
-    key: "adjustCalendarDate",
-    value: function adjustCalendarDate(e, t) {
-      var _resolveNonLunisolarM;
-      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "constrain";
-      if ("lunisolar" === this.calendarType) throw new RangeError("Override required for lunisolar calendars");
-      var n = e;
-      if (this.validateCalendarDate(n), this.constantEra) {
-        var _n21 = n,
-          _e39 = _n21.year,
-          _t46 = _n21.eraYear;
-        n = _objectSpread2(_objectSpread2({}, n), {}, {
-          era: this.constantEra,
-          year: void 0 !== _e39 ? _e39 : _t46,
-          eraYear: void 0 !== _t46 ? _t46 : _e39
-        });
-      }
-      var a = this.monthsInYear(n, t);
-      var _n22 = n,
-        i = _n22.month,
-        s = _n22.monthCode;
-      return (_resolveNonLunisolarM = resolveNonLunisolarMonth(n, r, a), i = _resolveNonLunisolarM.month, s = _resolveNonLunisolarM.monthCode), _objectSpread2(_objectSpread2({}, n), {}, {
-        month: i,
-        monthCode: s
-      });
-    }
-  }, {
-    key: "regulateMonthDayNaive",
-    value: function regulateMonthDayNaive(e, t, r) {
-      var o = this.monthsInYear(e, r);
-      var n = e.month,
-        a = e.day;
-      return "reject" === t ? (RejectToRange(n, 1, o), RejectToRange(a, 1, this.maximumMonthLength(e))) : (n = ConstrainToRange(n, 1, o), a = ConstrainToRange(a, 1, this.maximumMonthLength(_objectSpread2(_objectSpread2({}, e), {}, {
-        month: n
-      })))), _objectSpread2(_objectSpread2({}, e), {}, {
-        month: n,
-        day: a
-      });
-    }
-  }, {
-    key: "calendarToIsoDate",
-    value: function calendarToIsoDate(e) {
-      var _this2 = this;
-      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "constrain";
-      var r = arguments.length > 2 ? arguments[2] : undefined;
-      var o = e;
-      var n = this.adjustCalendarDate(e, r, t, !1);
-      n = this.regulateMonthDayNaive(n, t, r);
-      var _n23 = n,
-        a = _n23.year,
-        i = _n23.month,
-        s = _n23.day,
-        l = JSON.stringify({
-          func: "calendarToIsoDate",
-          year: a,
-          month: i,
-          day: s,
-          overflow: t,
-          id: this.id
-        });
-      var d,
-        m = r.get(l);
-      if (m) return m;
-      if (void 0 !== o.year && void 0 !== o.month && void 0 !== o.day && (o.year !== n.year || o.month !== n.month || o.day !== n.day) && (d = JSON.stringify({
-        func: "calendarToIsoDate",
-        year: o.year,
-        month: o.month,
-        day: o.day,
-        overflow: t,
-        id: this.id
-      }), m = r.get(d), m)) return m;
-      var c = this.estimateIsoDate({
-        year: a,
-        month: i,
-        day: s
-      });
-      var calculateSameMonthResult = function calculateSameMonthResult(e) {
-        var o = _this2.addDaysIso(c, e);
-        if (n.day > _this2.minimumMonthLength(n)) {
-          var _e40 = _this2.isoToCalendarDate(o, r);
-          for (; _e40.month !== i || _e40.year !== a;) {
-            if ("reject" === t) throw new RangeError("day ".concat(s, " does not exist in month ").concat(i, " of year ").concat(a));
-            o = _this2.addDaysIso(o, -1), _e40 = _this2.isoToCalendarDate(o, r);
-          }
-        }
-        return o;
-      };
-      var h = 0,
-        u = this.isoToCalendarDate(c, r),
-        T = simpleDateDiff(n, u);
-      if (0 !== T.years || 0 !== T.months || 0 !== T.days) {
-        var _e41 = 365 * T.years + 30 * T.months + T.days;
-        c = this.addDaysIso(c, _e41), u = this.isoToCalendarDate(c, r), T = simpleDateDiff(n, u), 0 === T.years && 0 === T.months ? c = calculateSameMonthResult(T.days) : h = this.compareCalendarDates(n, u);
-      }
-      var p = 8;
-      for (; h;) {
-        c = this.addDaysIso(c, h * p);
-        var _e42 = u;
-        u = this.isoToCalendarDate(c, r);
-        var _a17 = h;
-        if (h = this.compareCalendarDates(n, u), h) if (T = simpleDateDiff(n, u), 0 === T.years && 0 === T.months) c = calculateSameMonthResult(T.days), h = 0;else if (_a17 && h !== _a17) if (p > 1) p /= 2;else {
-          if ("reject" === t) throw new RangeError("Can't find ISO date from calendar date: ".concat(JSON.stringify(_objectSpread2({}, o))));
-          this.compareCalendarDates(u, _e42) > 0 && (c = this.addDaysIso(c, -1)), h = 0;
-        }
-      }
-      if (r.set(l, c), d && r.set(d, c), void 0 === n.year || void 0 === n.month || void 0 === n.day || void 0 === n.monthCode || this.hasEra && (void 0 === n.era || void 0 === n.eraYear)) throw new RangeError("Unexpected missing property");
-      return c;
-    }
-  }, {
-    key: "temporalToCalendarDate",
-    value: function temporalToCalendarDate(e, t) {
-      var r = {
-        year: GetSlot(e, i),
-        month: GetSlot(e, s),
-        day: GetSlot(e, l)
-      };
-      return this.isoToCalendarDate(r, t);
-    }
-  }, {
-    key: "compareCalendarDates",
-    value: function compareCalendarDates(e, t) {
-      var r = PrepareTemporalFields(e, ["day", "month", "year"], ["day", "month", "year"]),
-        o = PrepareTemporalFields(t, ["day", "month", "year"], ["day", "month", "year"]);
-      return r.year !== o.year ? ComparisonResult(r.year - o.year) : r.month !== o.month ? ComparisonResult(r.month - o.month) : r.day !== o.day ? ComparisonResult(r.day - o.day) : 0;
-    }
-  }, {
-    key: "regulateDate",
-    value: function regulateDate(e) {
-      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "constrain";
-      var r = arguments.length > 2 ? arguments[2] : undefined;
-      var o = this.calendarToIsoDate(e, t, r);
-      return this.isoToCalendarDate(o, r);
-    }
-  }, {
-    key: "addDaysIso",
-    value: function addDaysIso(e, t) {
-      return AddISODate(e.year, e.month, e.day, 0, 0, 0, t, "constrain");
-    }
-  }, {
-    key: "addDaysCalendar",
-    value: function addDaysCalendar(e, t, r) {
-      var o = this.calendarToIsoDate(e, "constrain", r),
-        n = this.addDaysIso(o, t);
-      return this.isoToCalendarDate(n, r);
-    }
-  }, {
-    key: "addMonthsCalendar",
-    value: function addMonthsCalendar(e, t, r, o) {
-      var n = e;
-      var _n24 = n,
-        a = _n24.day;
-      for (var _e43 = 0, _r61 = It(t); _e43 < _r61; _e43++) {
-        var _n25 = n,
-          _e44 = _n25.month,
-          _r62 = n,
-          _i18 = t < 0 ? -Math.max(a, this.daysInPreviousMonth(n, o)) : this.daysInMonth(n, o),
-          _s7 = this.calendarToIsoDate(n, "constrain", o);
-        var _l7 = this.addDaysIso(_s7, _i18);
-        if (n = this.isoToCalendarDate(_l7, o), t > 0) {
-          var _t47 = this.monthsInYear(_r62, o);
-          for (; n.month - 1 != _e44 % _t47;) _l7 = this.addDaysIso(_l7, -1), n = this.isoToCalendarDate(_l7, o);
-        }
-        n.day !== a && (n = this.regulateDate(_objectSpread2(_objectSpread2({}, n), {}, {
-          day: a
-        }), "constrain", o));
-      }
-      if ("reject" === r && n.day !== a) throw new RangeError("Day ".concat(a, " does not exist in resulting calendar month"));
-      return n;
-    }
-  }, {
-    key: "addCalendar",
-    value: function addCalendar(e, _ref9, a, i) {
-      var _ref9$years = _ref9.years,
-        t = _ref9$years === void 0 ? 0 : _ref9$years,
-        _ref9$months = _ref9.months,
-        r = _ref9$months === void 0 ? 0 : _ref9$months,
-        _ref9$weeks = _ref9.weeks,
-        o = _ref9$weeks === void 0 ? 0 : _ref9$weeks,
-        _ref9$days = _ref9.days,
-        n = _ref9$days === void 0 ? 0 : _ref9$days;
-      var s = e.year,
-        l = e.day,
-        d = e.monthCode,
-        m = this.adjustCalendarDate({
-          year: s + t,
-          monthCode: d,
-          day: l
-        }, i),
-        c = this.addMonthsCalendar(m, r, a, i),
-        h = n + 7 * o;
-      return this.addDaysCalendar(c, h, i);
-    }
-  }, {
-    key: "untilCalendar",
-    value: function untilCalendar(e, t, r, o) {
-      var n = 0,
-        a = 0,
-        i = 0,
-        s = 0;
-      switch (r) {
-        case "day":
-          n = this.calendarDaysUntil(e, t, o);
-          break;
-        case "week":
-          {
-            var _r63 = this.calendarDaysUntil(e, t, o);
-            n = _r63 % 7, a = (_r63 - n) / 7;
-            break;
-          }
-        case "month":
-        case "year":
-          {
-            var _a18 = this.compareCalendarDates(t, e);
-            if (!_a18) return {
-              years: 0,
-              months: 0,
-              weeks: 0,
-              days: 0
-            };
-            var _l8 = t.year - e.year,
-              _d10 = t.day - e.day;
-            if ("year" === r && _l8) {
-              var _r64 = 0;
-              t.monthCode > e.monthCode && (_r64 = 1), t.monthCode < e.monthCode && (_r64 = -1), _r64 || (_r64 = Math.sign(_d10));
-              s = _r64 * _a18 < 0 ? _l8 - _a18 : _l8;
-            }
-            var _m9,
-              _c5 = s ? this.addCalendar(e, {
-                years: s
-              }, "constrain", o) : e;
-            do {
-              i += _a18, _m9 = _c5, _c5 = this.addMonthsCalendar(_m9, _a18, "constrain", o), _c5.day !== e.day && (_c5 = this.regulateDate(_objectSpread2(_objectSpread2({}, _c5), {}, {
-                day: e.day
-              }), "constrain", o));
-            } while (this.compareCalendarDates(t, _c5) * _a18 >= 0);
-            i -= _a18;
-            n = this.calendarDaysUntil(_m9, t, o);
-            break;
-          }
-      }
-      return {
-        years: s,
-        months: i,
-        weeks: a,
-        days: n
-      };
-    }
-  }, {
-    key: "daysInMonth",
-    value: function daysInMonth(e, t) {
-      var r = e.day,
-        o = this.maximumMonthLength(e),
-        n = this.minimumMonthLength(e);
-      if (n === o) return n;
-      var a = r <= o - n ? o : n,
-        i = this.calendarToIsoDate(e, "constrain", t),
-        s = this.addDaysIso(i, a),
-        l = this.isoToCalendarDate(s, t),
-        d = this.addDaysIso(s, -l.day);
-      return this.isoToCalendarDate(d, t).day;
-    }
-  }, {
-    key: "daysInPreviousMonth",
-    value: function daysInPreviousMonth(e, t) {
-      var r = e.day,
-        o = e.month,
-        n = e.year;
-      var a = {
-        year: o > 1 ? n : n - 1,
-        month: o,
-        day: 1
-      };
-      var i = o > 1 ? o - 1 : this.monthsInYear(a, t);
-      a = _objectSpread2(_objectSpread2({}, a), {}, {
-        month: i
-      });
-      var s = this.minimumMonthLength(a),
-        l = this.maximumMonthLength(a);
-      if (s === l) return l;
-      var d = this.calendarToIsoDate(e, "constrain", t),
-        m = this.addDaysIso(d, -r);
-      return this.isoToCalendarDate(m, t).day;
-    }
-  }, {
-    key: "startOfCalendarYear",
-    value: function startOfCalendarYear(e) {
-      return {
-        year: e.year,
-        month: 1,
-        monthCode: "M01",
-        day: 1
-      };
-    }
-  }, {
-    key: "startOfCalendarMonth",
-    value: function startOfCalendarMonth(e) {
-      return {
-        year: e.year,
-        month: e.month,
-        day: 1
-      };
-    }
-  }, {
-    key: "calendarDaysUntil",
-    value: function calendarDaysUntil(e, t, r) {
-      var o = this.calendarToIsoDate(e, "constrain", r),
-        n = this.calendarToIsoDate(t, "constrain", r);
-      return this.isoDaysUntil(o, n);
-    }
-  }, {
-    key: "isoDaysUntil",
-    value: function isoDaysUntil(e, t) {
-      return DifferenceISODate(e.year, e.month, e.day, t.year, t.month, t.day, "day").days;
-    }
-  }, {
-    key: "monthDayFromFields",
-    value: function monthDayFromFields(e, t, r) {
-      var o,
-        n,
-        a,
-        i,
-        s,
-        l = e.monthCode,
-        d = e.day;
-      if (void 0 === l) {
-        var _o37 = e.year,
-          _n26 = e.era,
-          _a19 = e.eraYear;
-        if (void 0 === _o37 && (void 0 === _n26 || void 0 === _a19)) throw new TypeError("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
-        var _this$isoToCalendarDa = this.isoToCalendarDate(this.calendarToIsoDate(e, t, r), r);
-        l = _this$isoToCalendarDa.monthCode;
-        d = _this$isoToCalendarDa.day;
-      }
-      var m = this.isoToCalendarDate({
-          year: 1972,
-          month: 12,
-          day: 31
-        }, r),
-        c = m.monthCode > l || m.monthCode === l && m.day >= d ? m.year : m.year - 1;
-      for (var _e45 = 0; _e45 < 100; _e45++) {
-        var _m10 = this.adjustCalendarDate({
-            day: d,
-            monthCode: l,
-            year: c - _e45
-          }, r),
-          _h3 = this.calendarToIsoDate(_m10, "constrain", r),
-          _u2 = this.isoToCalendarDate(_h3, r);
-        if ((o = _h3.year, n = _h3.month, a = _h3.day), _u2.monthCode === l && _u2.day === d) return {
-          month: n,
-          day: a,
-          year: o
-        };
-        "constrain" === t && (void 0 === i || _u2.monthCode === i.monthCode && _u2.day > i.day) && (i = _u2, s = _h3);
-      }
-      if ("constrain" === t && void 0 !== s) return s;
-      throw new RangeError("No recent ".concat(this.id, " year with monthCode ").concat(l, " and day ").concat(d));
-    }
-  }]);
-  return HelperBase;
-}();
-var HebrewHelper = /*#__PURE__*/function (_HelperBase) {
-  _inherits(HebrewHelper, _HelperBase);
-  var _super = _createSuper(HebrewHelper);
-  function HebrewHelper() {
-    var _this3;
-    _classCallCheck(this, HebrewHelper);
-    _this3 = _super.apply(this, arguments), _this3.id = "hebrew", _this3.calendarType = "lunisolar", _this3.months = {
-      Tishri: {
-        leap: 1,
-        regular: 1,
-        monthCode: "M01",
-        days: 30
-      },
-      Heshvan: {
-        leap: 2,
-        regular: 2,
-        monthCode: "M02",
-        days: {
-          min: 29,
-          max: 30
-        }
-      },
-      Kislev: {
-        leap: 3,
-        regular: 3,
-        monthCode: "M03",
-        days: {
-          min: 29,
-          max: 30
-        }
-      },
-      Tevet: {
-        leap: 4,
-        regular: 4,
-        monthCode: "M04",
-        days: 29
-      },
-      Shevat: {
-        leap: 5,
-        regular: 5,
-        monthCode: "M05",
-        days: 30
-      },
-      Adar: {
-        leap: void 0,
-        regular: 6,
-        monthCode: "M06",
-        days: 29
-      },
-      "Adar I": {
-        leap: 6,
-        regular: void 0,
-        monthCode: "M05L",
-        days: 30
-      },
-      "Adar II": {
-        leap: 7,
-        regular: void 0,
-        monthCode: "M06",
-        days: 29
-      },
-      Nisan: {
-        leap: 8,
-        regular: 7,
-        monthCode: "M07",
-        days: 30
-      },
-      Iyar: {
-        leap: 9,
-        regular: 8,
-        monthCode: "M08",
-        days: 29
-      },
-      Sivan: {
-        leap: 10,
-        regular: 9,
-        monthCode: "M09",
-        days: 30
-      },
-      Tamuz: {
-        leap: 11,
-        regular: 10,
-        monthCode: "M10",
-        days: 29
-      },
-      Av: {
-        leap: 12,
-        regular: 11,
-        monthCode: "M11",
-        days: 30
-      },
-      Elul: {
-        leap: 13,
-        regular: 12,
-        monthCode: "M12",
-        days: 29
-      }
-    }, _this3.hasEra = !1;
-    return _this3;
-  }
-  _createClass(HebrewHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e) {
-      var t = e.year;
-      return (7 * t + 1) % 19 < 7;
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear(e) {
-      return this.inLeapYear(e) ? 13 : 12;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength(e) {
-      return this.minMaxMonthLength(e, "min");
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength(e) {
-      return this.minMaxMonthLength(e, "max");
-    }
-  }, {
-    key: "minMaxMonthLength",
-    value: function minMaxMonthLength(e, t) {
-      var r = e.month,
-        o = e.year,
-        n = this.getMonthCode(o, r),
-        a = wt(this.months).find(function (e) {
-          return e[1].monthCode === n;
-        });
-      if (void 0 === a) throw new RangeError("unmatched Hebrew month: ".concat(r));
-      var i = a[1].days;
-      return "number" == typeof i ? i : i[t];
-    }
-  }, {
-    key: "estimateIsoDate",
-    value: function estimateIsoDate(e) {
-      var t = e.year;
-      return {
-        year: t - 3760,
-        month: 1,
-        day: 1
-      };
-    }
-  }, {
-    key: "getMonthCode",
-    value: function getMonthCode(e, t) {
-      return this.inLeapYear({
-        year: e
-      }) ? 6 === t ? buildMonthCode(5, !0) : buildMonthCode(t < 6 ? t : t - 1) : buildMonthCode(t);
-    }
-  }, {
-    key: "adjustCalendarDate",
-    value: function adjustCalendarDate(e, t) {
-      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "constrain";
-      var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
-      var n = e.year,
-        a = e.eraYear,
-        i = e.month,
-        s = e.monthCode,
-        l = e.day,
-        d = e.monthExtra;
-      if (void 0 === n && void 0 !== a && (n = a), void 0 === a && void 0 !== n && (a = n), o) {
-        if (d) {
-          var _e46 = this.months[d];
-          if (!_e46) throw new RangeError("Unrecognized month from formatToParts: ".concat(d));
-          i = this.inLeapYear({
-            year: n
-          }) ? _e46.leap : _e46.regular;
-        }
-        s = this.getMonthCode(n, i);
-        return {
-          year: n,
-          month: i,
-          day: l,
-          era: void 0,
-          eraYear: a,
-          monthCode: s
-        };
-      }
-      if (this.validateCalendarDate(e), void 0 === i) {
-        if (s.endsWith("L")) {
-          if ("M05L" !== s) throw new RangeError("Hebrew leap month must have monthCode M05L, not ".concat(s));
-          if (i = 6, !this.inLeapYear({
-            year: n
-          })) {
-            if ("reject" === r) throw new RangeError("Hebrew monthCode M05L is invalid in year ".concat(n, " which is not a leap year"));
-            i = 6, s = "M06";
-          }
-        } else {
-          i = monthCodeNumberPart(s), this.inLeapYear({
-            year: n
-          }) && i >= 6 && i++;
-          var _e47 = this.monthsInYear({
-            year: n
-          });
-          if (i < 1 || i > _e47) throw new RangeError("Invalid monthCode: ".concat(s));
-        }
-      } else if ("reject" === r ? (RejectToRange(i, 1, this.monthsInYear({
-        year: n
-      })), RejectToRange(l, 1, this.maximumMonthLength({
-        year: n,
-        month: i
-      }))) : (i = ConstrainToRange(i, 1, this.monthsInYear({
-        year: n
-      })), l = ConstrainToRange(l, 1, this.maximumMonthLength({
-        year: n,
-        month: i
-      }))), void 0 === s) s = this.getMonthCode(n, i);else {
-        if (this.getMonthCode(n, i) !== s) throw new RangeError("monthCode ".concat(s, " doesn't correspond to month ").concat(i, " in Hebrew year ").concat(n));
-      }
-      return _objectSpread2(_objectSpread2({}, e), {}, {
-        day: l,
-        month: i,
-        monthCode: s,
-        year: n,
-        eraYear: a
-      });
-    }
-  }]);
-  return HebrewHelper;
-}(HelperBase);
-var IslamicBaseHelper = /*#__PURE__*/function (_HelperBase2) {
-  _inherits(IslamicBaseHelper, _HelperBase2);
-  var _super2 = _createSuper(IslamicBaseHelper);
-  function IslamicBaseHelper() {
-    var _this4;
-    _classCallCheck(this, IslamicBaseHelper);
-    _this4 = _super2.apply(this, arguments), _this4.calendarType = "lunar", _this4.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, _this4.DAYS_PER_ISO_YEAR = 365.2425, _this4.constantEra = "ah";
-    return _this4;
-  }
-  _createClass(IslamicBaseHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e, t) {
-      return 30 === this.daysInMonth({
-        year: e.year,
-        month: 12,
-        day: 1
-      }, t);
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear() {
-      return 12;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength() {
-      return 29;
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength() {
-      return 30;
-    }
-  }, {
-    key: "estimateIsoDate",
-    value: function estimateIsoDate(e) {
-      var _this$adjustCalendarD = this.adjustCalendarDate(e),
-        t = _this$adjustCalendarD.year;
-      return {
-        year: St(t * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622,
-        month: 1,
-        day: 1
-      };
-    }
-  }]);
-  return IslamicBaseHelper;
-}(HelperBase);
-var IslamicHelper = /*#__PURE__*/function (_IslamicBaseHelper) {
-  _inherits(IslamicHelper, _IslamicBaseHelper);
-  var _super3 = _createSuper(IslamicHelper);
-  function IslamicHelper() {
-    var _this5;
-    _classCallCheck(this, IslamicHelper);
-    _this5 = _super3.apply(this, arguments), _this5.id = "islamic";
-    return _this5;
-  }
-  return _createClass(IslamicHelper);
-}(IslamicBaseHelper);
-var IslamicUmalquraHelper = /*#__PURE__*/function (_IslamicBaseHelper2) {
-  _inherits(IslamicUmalquraHelper, _IslamicBaseHelper2);
-  var _super4 = _createSuper(IslamicUmalquraHelper);
-  function IslamicUmalquraHelper() {
-    var _this6;
-    _classCallCheck(this, IslamicUmalquraHelper);
-    _this6 = _super4.apply(this, arguments), _this6.id = "islamic-umalqura";
-    return _this6;
-  }
-  return _createClass(IslamicUmalquraHelper);
-}(IslamicBaseHelper);
-var IslamicTblaHelper = /*#__PURE__*/function (_IslamicBaseHelper3) {
-  _inherits(IslamicTblaHelper, _IslamicBaseHelper3);
-  var _super5 = _createSuper(IslamicTblaHelper);
-  function IslamicTblaHelper() {
-    var _this7;
-    _classCallCheck(this, IslamicTblaHelper);
-    _this7 = _super5.apply(this, arguments), _this7.id = "islamic-tbla";
-    return _this7;
-  }
-  return _createClass(IslamicTblaHelper);
-}(IslamicBaseHelper);
-var IslamicCivilHelper = /*#__PURE__*/function (_IslamicBaseHelper4) {
-  _inherits(IslamicCivilHelper, _IslamicBaseHelper4);
-  var _super6 = _createSuper(IslamicCivilHelper);
-  function IslamicCivilHelper() {
-    var _this8;
-    _classCallCheck(this, IslamicCivilHelper);
-    _this8 = _super6.apply(this, arguments), _this8.id = "islamic-civil";
-    return _this8;
-  }
-  return _createClass(IslamicCivilHelper);
-}(IslamicBaseHelper);
-var IslamicRgsaHelper = /*#__PURE__*/function (_IslamicBaseHelper5) {
-  _inherits(IslamicRgsaHelper, _IslamicBaseHelper5);
-  var _super7 = _createSuper(IslamicRgsaHelper);
-  function IslamicRgsaHelper() {
-    var _this9;
-    _classCallCheck(this, IslamicRgsaHelper);
-    _this9 = _super7.apply(this, arguments), _this9.id = "islamic-rgsa";
-    return _this9;
-  }
-  return _createClass(IslamicRgsaHelper);
-}(IslamicBaseHelper);
-var IslamicCcHelper = /*#__PURE__*/function (_IslamicBaseHelper6) {
-  _inherits(IslamicCcHelper, _IslamicBaseHelper6);
-  var _super8 = _createSuper(IslamicCcHelper);
-  function IslamicCcHelper() {
-    var _this10;
-    _classCallCheck(this, IslamicCcHelper);
-    _this10 = _super8.apply(this, arguments), _this10.id = "islamicc";
-    return _this10;
-  }
-  return _createClass(IslamicCcHelper);
-}(IslamicBaseHelper);
-var PersianHelper = /*#__PURE__*/function (_HelperBase3) {
-  _inherits(PersianHelper, _HelperBase3);
-  var _super9 = _createSuper(PersianHelper);
-  function PersianHelper() {
-    var _this11;
-    _classCallCheck(this, PersianHelper);
-    _this11 = _super9.apply(this, arguments), _this11.id = "persian", _this11.calendarType = "solar", _this11.constantEra = "ap";
-    return _this11;
-  }
-  _createClass(PersianHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e, t) {
-      return IslamicHelper.prototype.inLeapYear.call(this, e, t);
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear() {
-      return 12;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength(e) {
-      var t = e.month;
-      return 12 === t ? 29 : t <= 6 ? 31 : 30;
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength(e) {
-      var t = e.month;
-      return 12 === t ? 30 : t <= 6 ? 31 : 30;
-    }
-  }, {
-    key: "estimateIsoDate",
-    value: function estimateIsoDate(e) {
-      var _this$adjustCalendarD2 = this.adjustCalendarDate(e),
-        t = _this$adjustCalendarD2.year;
-      return {
-        year: t + 621,
-        month: 1,
-        day: 1
-      };
-    }
-  }]);
-  return PersianHelper;
-}(HelperBase);
-var IndianHelper = /*#__PURE__*/function (_HelperBase4) {
-  _inherits(IndianHelper, _HelperBase4);
-  var _super10 = _createSuper(IndianHelper);
-  function IndianHelper() {
-    var _this12;
-    _classCallCheck(this, IndianHelper);
-    _this12 = _super10.apply(this, arguments), _this12.id = "indian", _this12.calendarType = "solar", _this12.constantEra = "saka", _this12.months = {
-      1: {
-        length: 30,
-        month: 3,
-        day: 22,
-        leap: {
-          length: 31,
-          month: 3,
-          day: 21
+  monthsInYear: function monthsInYear(){return 12;},
+  inLeapYear:
+  function inLeapYear(e){
+   var t = e;
+   return HasSlot(t, i) || (t = ToTemporalDate(t)), LeapYear(GetSlot(t, i));
+  }};
+var
+ OneObjectCache =
+   function(){
+     function OneObjectCache(e){
+      _classCallCheck(this, OneObjectCache);
+      if
+       (this.map = new Map(),
+        this.calls = 0,
+        this.hits = 0,
+        this.misses = 0,
+        this.now =
+         globalThis.performance ? globalThis.performance.now() : Date.now(),
+        void 0 !== e){
+       var _t43 = 0;
+       var _iterator17 = _createForOfIteratorHelper(e.map.entries()), _step17;
+       try{
+        for(_iterator17.s(); ! (_step17 = _iterator17.n()).done;){
+         var _this$map;
+         var _r59 = _step17.value;
+         if(++_t43 > OneObjectCache.MAX_CACHE_ENTRIES) break;
+         (_this$map = this.map).set.apply(_this$map, _toConsumableArray(_r59));
         }
-      },
-      2: {
-        length: 31,
-        month: 4,
-        day: 21
-      },
-      3: {
-        length: 31,
-        month: 5,
-        day: 22
-      },
-      4: {
-        length: 31,
-        month: 6,
-        day: 22
-      },
-      5: {
-        length: 31,
-        month: 7,
-        day: 23
-      },
-      6: {
-        length: 31,
-        month: 8,
-        day: 23
-      },
-      7: {
-        length: 30,
-        month: 9,
-        day: 23
-      },
-      8: {
-        length: 30,
-        month: 10,
-        day: 23
-      },
-      9: {
-        length: 30,
-        month: 11,
-        day: 22
-      },
-      10: {
-        length: 30,
-        month: 12,
-        day: 22
-      },
-      11: {
-        length: 30,
-        month: 1,
-        nextYear: !0,
-        day: 21
-      },
-      12: {
-        length: 30,
-        month: 2,
-        nextYear: !0,
-        day: 20
-      }
-    }, _this12.vulnerableToBceBug = "10/11/-79 Saka" !== new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian", {
-      timeZone: "UTC"
-    });
-    return _this12;
-  }
-  _createClass(IndianHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e) {
-      return isGregorianLeapYear(e.year + 78);
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear() {
-      return 12;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength(e) {
-      return this.getMonthInfo(e).length;
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength(e) {
-      return this.getMonthInfo(e).length;
-    }
-  }, {
-    key: "getMonthInfo",
-    value: function getMonthInfo(e) {
-      var t = e.month;
-      var r = this.months[t];
-      if (void 0 === r) throw new RangeError("Invalid month: ".concat(t));
-      return this.inLeapYear(e) && r.leap && (r = r.leap), r;
-    }
-  }, {
-    key: "estimateIsoDate",
-    value: function estimateIsoDate(e) {
-      var t = this.adjustCalendarDate(e),
-        r = this.getMonthInfo(t);
-      return AddISODate(t.year + 78 + (r.nextYear ? 1 : 0), r.month, r.day, 0, 0, 0, t.day - 1, "constrain");
-    }
-  }, {
-    key: "checkIcuBugs",
-    value: function checkIcuBugs(e) {
-      if (this.vulnerableToBceBug && e.year < 1) throw new RangeError("calendar '".concat(this.id, "' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
-    }
-  }]);
-  return IndianHelper;
-}(HelperBase);
-function isGregorianLeapYear(e) {
-  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
-}
-var GregorianBaseHelper = /*#__PURE__*/function (_HelperBase5) {
-  _inherits(GregorianBaseHelper, _HelperBase5);
-  var _super11 = _createSuper(GregorianBaseHelper);
-  function GregorianBaseHelper(e, t) {
-    var _this13;
-    _classCallCheck(this, GregorianBaseHelper);
-    _this13 = _super11.call(this), _this13.calendarType = "solar", _this13.v8IsVulnerableToJulianBug = new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese", {
-      timeZone: "UTC"
-    }).startsWith("12"), _this13.calendarIsVulnerableToJulianBug = !1, _this13.id = e;
-    var _adjustEras = function adjustEras(e) {
-        var t,
-          r = e;
-        if (0 === r.length) throw new RangeError("Invalid era data: eras are required");
-        if (1 === r.length && r[0].reverseOf) throw new RangeError("Invalid era data: anchor era cannot count years backwards");
-        if (1 === r.length && !r[0].name) throw new RangeError("Invalid era data: at least one named era is required");
-        if (r.filter(function (e) {
-          return null != e.reverseOf;
-        }).length > 1) throw new RangeError("Invalid era data: only one era can count years backwards");
-        r.forEach(function (e) {
-          if (e.isAnchor || !e.anchorEpoch && !e.reverseOf) {
-            if (t) throw new RangeError("Invalid era data: cannot have multiple anchor eras");
-            t = e, e.anchorEpoch = {
-              year: e.hasYearZero ? 0 : 1
-            };
-          } else if (!e.name) throw new RangeError("If era name is blank, it must be the anchor era");
-        }), r = r.filter(function (e) {
-          return e.name;
-        }), r.forEach(function (e) {
-          var t = e.reverseOf;
-          if (t) {
-            var _o38 = r.find(function (e) {
-              return e.name === t;
-            });
-            if (void 0 === _o38) throw new RangeError("Invalid era data: unmatched reverseOf era: ".concat(t));
-            e.reverseOf = _o38, e.anchorEpoch = _o38.anchorEpoch, e.isoEpoch = _o38.isoEpoch;
-          }
-          void 0 === e.anchorEpoch.month && (e.anchorEpoch.month = 1), void 0 === e.anchorEpoch.day && (e.anchorEpoch.day = 1);
-        }), yt.call(r, function (e, t) {
-          if (e.reverseOf) return 1;
-          if (t.reverseOf) return -1;
-          if (!e.isoEpoch || !t.isoEpoch) throw new RangeError("Invalid era data: missing ISO epoch");
-          return t.isoEpoch.year - e.isoEpoch.year;
-        });
-        var o = r[r.length - 1].reverseOf;
-        if (o && o !== r[r.length - 2]) throw new RangeError("Invalid era data: invalid reverse-sign era");
-        return r.forEach(function (e, t) {
-          e.genericName = "era" + (r.length - 1 - t);
-        }), {
-          eras: r,
-          anchorEra: t || r[0]
-        };
-      }(t),
-      r = _adjustEras.eras,
-      o = _adjustEras.anchorEra;
-    _this13.anchorEra = o, _this13.eras = r;
-    return _this13;
-  }
-  _createClass(GregorianBaseHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e) {
-      var _this$estimateIsoDate = this.estimateIsoDate({
-          month: 1,
-          day: 1,
-          year: e.year
-        }),
-        t = _this$estimateIsoDate.year;
-      return isGregorianLeapYear(t);
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear() {
-      return 12;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength(e) {
-      var t = e.month;
-      return 2 === t ? this.inLeapYear(e) ? 29 : 28 : [4, 6, 9, 11].indexOf(t) >= 0 ? 30 : 31;
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength(e) {
-      return this.minimumMonthLength(e);
-    }
-  }, {
-    key: "completeEraYear",
-    value: function completeEraYear(e) {
-      var _this14 = this,
-        _eraFromYear;
-      var checkField = function checkField(t, r) {
-          var o = e[t];
-          if (null != o && o != r) throw new RangeError("Input ".concat(t, " ").concat(o, " doesn't match calculated value ").concat(r));
-        },
-        eraFromYear = function eraFromYear(t) {
-          var r;
-          var o = _objectSpread2(_objectSpread2({}, e), {}, {
-              year: t
-            }),
-            n = _this14.eras.find(function (e, n) {
-              if (n === _this14.eras.length - 1) {
-                if (e.reverseOf) {
-                  if (t > 0) throw new RangeError("Signed year ".concat(t, " is invalid for era ").concat(e.name));
-                  return r = e.anchorEpoch.year - t, !0;
-                }
-                return r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1), !0;
+       }
+       catch(err){_iterator17.e(err);}
+       finally{_iterator17.f();}
+      }
+     }
+     return _createClass
+             (OneObjectCache,
+              [{key: "get",
+                value:
+                function get(e){
+                 var t = this.map.get(e);
+                 return t && (this.hits++, this.report()), this.calls++, t;
+                }},
+               {key: "set",
+                value:
+                function set(e, t){
+                 this.map.set(e, t), this.misses++, this.report();
+                }},
+               {key: "report", value: function report(){}},
+               {key: "setObject",
+                value:
+                function setObject(e){
+                 if(OneObjectCache.objectMap.get(e))
+                  throw new RangeError("object already cached");
+                 OneObjectCache.objectMap.set(e, this), this.report();
+                }}],
+              [{key: "getCacheForObject",
+                value:
+                function getCacheForObject(e){
+                 var t = OneObjectCache.objectMap.get(e);
+                 return t
+                        ||
+                         (t = new OneObjectCache(),
+                          OneObjectCache.objectMap.set(e, t)),
+                        t;
+                }}]);
+    }
+    ();
+function toUtcIsoDateString(_ref8){
+ var e = _ref8.isoYear, t = _ref8.isoMonth, r = _ref8.isoDay;
+ return "".concat(ISOYearString(e), "-").concat(ISODateTimePartString(t), "-").concat
+         (ISODateTimePartString(r), "T00:00Z");
+}
+function simpleDateDiff(e, t){
+ return {years: e.year - t.year,
+         months: e.month - t.month,
+         days: e.day - t.day};
+}
+OneObjectCache.objectMap = new WeakMap(),
+OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
+var
+ HelperBase =
+   function(){
+     function HelperBase(){
+      _classCallCheck(this, HelperBase);
+      this.eraLength = "short",
+      this.hasEra = ! 0,
+      this.erasBeginMidYear = ! 1;
+     }
+     return _createClass
+             (HelperBase,
+              [{key: "getFormatter",
+                value:
+                function getFormatter(){
+                 return void 0 === this.formatter
+                        &&
+                         (this.formatter =
+                          new
+                           ft
+                           ("en-US-u-ca-".concat(this.id),
+                            {day: "numeric",
+                             month: "numeric",
+                             year: "numeric",
+                             era: this.eraLength,
+                             timeZone: "UTC"})),
+                        this.formatter;
+                }},
+               {key: "isoToCalendarDate",
+                value:
+                function isoToCalendarDate(e, t){
+                 var _this = this;
+                 var
+                  r = e.year,
+                  o = e.month,
+                  n = e.day,
+                  a =
+                    JSON.stringify
+                     ({func: "isoToCalendarDate",
+                       isoYear: r,
+                       isoMonth: o,
+                       isoDay: n,
+                       id: this.id}),
+                  i = t.get(a);
+                 if(i) return i;
+                 var s = this.getFormatter();
+                 var l, d;
+                 try{
+                  d = toUtcIsoDateString({isoYear: r, isoMonth: o, isoDay: n}),
+                  l = s.formatToParts(new Date(d));
+                 }
+                 catch(e){
+                  throw new
+                         RangeError
+                         ("Invalid ISO date: ".concat
+                           (JSON.stringify({isoYear: r, isoMonth: o, isoDay: n})));
+                 }
+                 var m = {};
+                 var _iterator18 = _createForOfIteratorHelper(l), _step18;
+                 try{
+                  for(_iterator18.s(); ! (_step18 = _iterator18.n()).done;){
+                   var
+                    _step18$value = _step18.value,
+                    _e37 = _step18$value.type,
+                    _t45 = _step18$value.value;
+                   if
+                    ("year" === _e37 && (m.eraYear = + _t45),
+                     "relatedYear" === _e37 && (m.eraYear = + _t45),
+                     "month" === _e37){
+                    var _e38 = /^([0-9]*)(.*?)$/.exec(_t45);
+                    if(! _e38 || 3 != _e38.length || ! _e38[1] && ! _e38[2])
+                     throw new RangeError("Unexpected month: ".concat(_t45));
+                    if(m.month = _e38[1] ? + _e38[1] : 1, m.month < 1)
+                     throw new
+                            RangeError
+                            ("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat
+                              (this.id,
+                               "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)"));
+                    if(m.month > 13)
+                     throw new
+                            RangeError
+                            ("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat
+                              (this.id,
+                               "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
+                    _e38[2] && (m.monthExtra = _e38[2]);
+                   }
+                   "day" === _e37 && (m.day = + _t45),
+                   this.hasEra && "era" === _e37 && null != _t45 && "" !== _t45
+                   &&
+                    (_t45 = _t45.split(" (")[0],
+                     m.era =
+                      _t45.normalize("NFD").replace
+                         (/(?:[\0-\x1F!-,\.\/:-@\[-`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u036F\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482-\u0489\u0530\u0557\u0558\u055A-\u055F\u0589-\u05CF\u05EB-\u05EE\u05F3-\u061F\u064B-\u066D\u0670\u06D4\u06D6-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u06FD\u06FE\u0700-\u070F\u0711\u0730-\u074C\u07A6-\u07B0\u07B2-\u07C9\u07EB-\u07F3\u07F6-\u07F9\u07FB-\u07FF\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u083F\u0859-\u085F\u086B-\u086F\u0888\u088F-\u089F\u08CA-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0970\u0981-\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA-\u09BC\u09BE-\u09CD\u09CF-\u09DB\u09DE\u09E2-\u09EF\u09F2-\u09FB\u09FD-\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A-\u0A58\u0A5D\u0A5F-\u0A71\u0A75-\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA-\u0ABC\u0ABE-\u0ACF\u0AD1-\u0ADF\u0AE2-\u0AF8\u0AFA-\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A-\u0B3C\u0B3E-\u0B5B\u0B5E\u0B62-\u0B70\u0B72-\u0B82\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BCF\u0BD1-\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C3E-\u0C57\u0C5B\u0C5C\u0C5E\u0C5F\u0C62-\u0C7F\u0C81-\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA-\u0CBC\u0CBE-\u0CDC\u0CDF\u0CE2-\u0CF0\u0CF3-\u0D03\u0D0D\u0D11\u0D3B\u0D3C\u0D3E-\u0D4D\u0D4F-\u0D53\u0D57-\u0D5E\u0D62-\u0D79\u0D80-\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0E00\u0E31\u0E34-\u0E3F\u0E47-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EB1\u0EB4-\u0EBC\u0EBE\u0EBF\u0EC5\u0EC7-\u0EDB\u0EE0-\u0EFF\u0F01-\u0F3F\u0F48\u0F6D-\u0F87\u0F8D-\u0FFF\u102B-\u103E\u1040-\u104F\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16F0\u16F9-\u16FF\u1712-\u171E\u1732-\u173F\u1752-\u175F\u176D\u1771-\u177F\u17B4-\u17D6\u17D8-\u17DB\u17DD-\u181F\u1879-\u187F\u1885\u1886\u18A9\u18AB-\u18AF\u18F6-\u18FF\u191F-\u194F\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19FF\u1A17-\u1A1F\u1A55-\u1AA6\u1AA8-\u1B04\u1B34-\u1B44\u1B4D-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BFF\u1C24-\u1C4C\u1C50-\u1C59\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1CFB-\u1CFF\u1DC0-\u1DFF\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u2182\u2185-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7F\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF-\u2E2E\u2E30-\u3004\u3007-\u3030\u3036-\u303A\u303D-\u3040\u3097-\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA620-\uA629\uA62C-\uA63F\uA66F-\uA67E\uA69E\uA69F\uA6E6-\uA716\uA720\uA721\uA789\uA78A\uA7CB-\uA7CF\uA7D2\uA7D4\uA7DA-\uA7F1\uA802\uA806\uA80B\uA823-\uA83F\uA874-\uA881\uA8B4-\uA8F1\uA8F8-\uA8FA\uA8FC\uA8FF-\uA909\uA926-\uA92F\uA947-\uA95F\uA97D-\uA983\uA9B3-\uA9CE\uA9D0-\uA9DF\uA9E5\uA9F0-\uA9F9\uA9FF\uAA29-\uAA3F\uAA43\uAA4C-\uAA5F\uAA77-\uAA79\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAC3-\uAADA\uAADE\uAADF\uAAEB-\uAAF1\uAAF5-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABE3-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB1E\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFE6F\uFE75\uFEFD-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEFF\uDF20-\uDF2C\uDF41\uDF4A-\uDF4F\uDF76-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0-\uDFFF]|\uD801[\uDC9E-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6F\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE01-\uDE0F\uDE14\uDE18\uDE36-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE5-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD24-\uDE7F\uDEAA-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF46-\uDF6F\uDF82-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC00-\uDC02\uDC38-\uDC70\uDC73\uDC74\uDC76-\uDC82\uDCB0-\uDCCF\uDCE9-\uDD02\uDD27-\uDD43\uDD45\uDD46\uDD48-\uDD4F\uDD73-\uDD75\uDD77-\uDD82\uDDB3-\uDDC0\uDDC5-\uDDD9\uDDDB\uDDDD-\uDDFF\uDE12\uDE2C-\uDE3E\uDE41-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEDF-\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A-\uDF3C\uDF3E-\uDF4F\uDF51-\uDF5C\uDF62-\uDFFF]|\uD805[\uDC35-\uDC46\uDC4B-\uDC5E\uDC62-\uDC7F\uDCB0-\uDCC3\uDCC6\uDCC8-\uDD7F\uDDAF-\uDDD7\uDDDC-\uDDFF\uDE30-\uDE43\uDE45-\uDE7F\uDEAB-\uDEB7\uDEB9-\uDEFF\uDF1B-\uDF3F\uDF47-\uDFFF]|\uD806[\uDC2C-\uDC9F\uDCE0-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD30-\uDD3E\uDD40\uDD42-\uDD9F\uDDA8\uDDA9\uDDD1-\uDDE0\uDDE2\uDDE4-\uDDFF\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE4F\uDE51-\uDE5B\uDE8A-\uDE9C\uDE9E-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC2F-\uDC3F\uDC41-\uDC71\uDC90-\uDCFF\uDD07\uDD0A\uDD31-\uDD45\uDD47-\uDD5F\uDD66\uDD69\uDD8A-\uDD97\uDD99-\uDEDF\uDEF3-\uDF01\uDF03\uDF11\uDF34-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC00-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD834\uD836\uD83C-\uD83F\uD87C\uD87D\uD87F\uD889-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF1-\uDFFF]|\uD80D[\uDC30-\uDC40\uDC47-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F-\uDE6F\uDEBF-\uDECF\uDEEE-\uDEFF\uDF30-\uDF3F\uDF44-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4F\uDF51-\uDF92\uDFA0-\uDFDF\uDFE2\uDFE4-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD31\uDD33-\uDD4F\uDD53\uDD54\uDD56-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDF24\uDF2B-\uDFFF]|\uD838[\uDC00-\uDC2F\uDC6E-\uDCFF\uDD2D-\uDD36\uDD3E-\uDD4D\uDD4F-\uDE8F\uDEAE-\uDEBF\uDEEC-\uDFFF]|\uD839[\uDC00-\uDCCF\uDCEC-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5-\uDCFF\uDD44-\uDD4A\uDD4C-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF3A-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFEF]|\uD87B[\uDE5E-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDF4F]|\uD888[\uDFB0-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
+                          "").replace
+                        (" ", "-").toLowerCase
+                       ());
+                  }
+                 }
+                 catch(err){_iterator18.e(err);}
+                 finally{_iterator18.f();}
+                 if(void 0 === m.eraYear)
+                  throw new
+                         RangeError
+                         ("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat
+                           (this.id, " calendar. Try Node 14+ or modern browsers."));
+                 if(this.reviseIntlEra){
+                  var
+                   _this$reviseIntlEra = this.reviseIntlEra(m, e),
+                   _t44 = _this$reviseIntlEra.era,
+                   _r60 = _this$reviseIntlEra.eraYear;
+                  m.era = _t44, m.eraYear = _r60;
+                 }
+                 this.checkIcuBugs && this.checkIcuBugs(e);
+                 var c = this.adjustCalendarDate(m, t, "constrain", ! 0);
+                 if(void 0 === c.year)
+                  throw new
+                         RangeError
+                         ("Missing year converting ".concat(JSON.stringify(e)));
+                 if(void 0 === c.month)
+                  throw new
+                         RangeError
+                         ("Missing month converting ".concat(JSON.stringify(e)));
+                 if(void 0 === c.day)
+                  throw new
+                         RangeError
+                         ("Missing day converting ".concat(JSON.stringify(e)));
+                 return t.set(a, c),
+                        ["constrain", "reject"].forEach
+                         (function(r){
+                           var
+                            o =
+                              JSON.stringify
+                               ({func: "calendarToIsoDate",
+                                 year: c.year,
+                                 month: c.month,
+                                 day: c.day,
+                                 overflow: r,
+                                 id: _this.id});
+                           t.set(o, e);
+                          }),
+                        c;
+                }},
+               {key: "validateCalendarDate",
+                value:
+                function validateCalendarDate(e){
+                 var
+                  t = e.era,
+                  r = e.month,
+                  o = e.year,
+                  n = e.day,
+                  a = e.eraYear,
+                  i = e.monthCode,
+                  s = e.monthExtra;
+                 if(void 0 !== s)
+                  throw new RangeError("Unexpected `monthExtra` value");
+                 if(void 0 === o && void 0 === a)
+                  throw new TypeError("year or eraYear is required");
+                 if(void 0 === r && void 0 === i)
+                  throw new TypeError("month or monthCode is required");
+                 if(void 0 === n) throw new RangeError("Missing day");
+                 if(void 0 !== i){
+                  if("string" != typeof i)
+                   throw new
+                          RangeError
+                          ("monthCode must be a string, not " + _typeof(i));
+                  if(! /^M([01]?\d)(L?)$/.test(i))
+                   throw new RangeError("Invalid monthCode: ".concat(i));
+                 }
+                 if(this.constantEra){
+                  if(void 0 !== t && t !== this.constantEra)
+                   throw new
+                          RangeError
+                          ("era must be ".concat(this.constantEra, ", not ").concat(t));
+                  if(void 0 !== a && void 0 !== o && a !== o)
+                   throw new
+                          RangeError
+                          ("eraYear ".concat(a, " does not match year ").concat(o));
+                 }
+                 if(this.hasEra && void 0 === e.era != (void 0 === e.eraYear))
+                  throw new
+                         RangeError
+                         ("properties 'era' and 'eraYear' must be provided together");
+                }},
+               {key: "adjustCalendarDate",
+                value:
+                function adjustCalendarDate(e, t){
+                 var _resolveNonLunisolarM;
+                 var
+                  r =
+                    arguments.length > 2 && arguments[2] !== undefined
+                     ? arguments[2]
+                     : "constrain";
+                 if("lunisolar" === this.calendarType)
+                  throw new
+                         RangeError
+                         ("Override required for lunisolar calendars");
+                 var n = e;
+                 if(this.validateCalendarDate(n), this.constantEra){
+                  var _n21 = n, _e39 = _n21.year, _t46 = _n21.eraYear;
+                  n =
+                   _objectSpread2
+                    (_objectSpread2({}, n),
+                     {},
+                     {era: this.constantEra,
+                      year: void 0 !== _e39 ? _e39 : _t46,
+                      eraYear: void 0 !== _t46 ? _t46 : _e39});
+                 }
+                 var a = this.monthsInYear(n, t);
+                 var _n22 = n, i = _n22.month, s = _n22.monthCode;
+                 return _resolveNonLunisolarM =
+                         resolveNonLunisolarMonth(n, r, a),
+                        i = _resolveNonLunisolarM.month,
+                        s = _resolveNonLunisolarM.monthCode,
+                        _objectSpread2
+                         (_objectSpread2({}, n), {}, {month: i, monthCode: s});
+                }},
+               {key: "regulateMonthDayNaive",
+                value:
+                function regulateMonthDayNaive(e, t, r){
+                 var o = this.monthsInYear(e, r);
+                 var n = e.month, a = e.day;
+                 return "reject" === t
+                         ? (RejectToRange
+                            (n, 1, o),
+                           RejectToRange(a, 1, this.maximumMonthLength(e)))
+                         : (n
+                           = ConstrainToRange(n, 1, o),
+                           a =
+                            ConstrainToRange
+                             (a,
+                              1,
+                              this.maximumMonthLength
+                               (_objectSpread2(_objectSpread2({}, e), {}, {month: n})))),
+                        _objectSpread2
+                         (_objectSpread2({}, e), {}, {month: n, day: a});
+                }},
+               {key: "calendarToIsoDate",
+                value:
+                function calendarToIsoDate(e){
+                 var _this2 = this;
+                 var
+                  t =
+                    arguments.length > 1 && arguments[1] !== undefined
+                     ? arguments[1]
+                     : "constrain";
+                 var r = arguments.length > 2 ? arguments[2] : undefined;
+                 var o = e;
+                 var n = this.adjustCalendarDate(e, r, t, ! 1);
+                 n = this.regulateMonthDayNaive(n, t, r);
+                 var
+                  _n23 = n,
+                  a = _n23.year,
+                  i = _n23.month,
+                  s = _n23.day,
+                  l =
+                    JSON.stringify
+                     ({func: "calendarToIsoDate",
+                       year: a,
+                       month: i,
+                       day: s,
+                       overflow: t,
+                       id: this.id});
+                 var d, m = r.get(l);
+                 if(m) return m;
+                 if
+                  (void 0 !== o.year && void 0 !== o.month && void 0 !== o.day
+                   &&
+                    (o.year !== n.year || o.month !== n.month
+                    || o.day !== n.day)
+                   &&
+                    (d =
+                      JSON.stringify
+                       ({func: "calendarToIsoDate",
+                         year: o.year,
+                         month: o.month,
+                         day: o.day,
+                         overflow: t,
+                         id: this.id}),
+                     m = r.get(d),
+                     m))
+                  return m;
+                 var c = this.estimateIsoDate({year: a, month: i, day: s});
+                 var
+                  calculateSameMonthResult =
+                    function calculateSameMonthResult(e){
+                     var o = _this2.addDaysIso(c, e);
+                     if(n.day > _this2.minimumMonthLength(n)){
+                      var _e40 = _this2.isoToCalendarDate(o, r);
+                      for(; _e40.month !== i || _e40.year !== a;){
+                       if("reject" === t)
+                        throw new
+                               RangeError
+                               ("day ".concat(s, " does not exist in month ").concat
+                                  (i, " of year ").concat
+                                 (a));
+                       o = _this2.addDaysIso(o, - 1),
+                       _e40 = _this2.isoToCalendarDate(o, r);
+                      }
+                     }
+                     return o;
+                    };
+                 var
+                  h = 0,
+                  u = this.isoToCalendarDate(c, r),
+                  T = simpleDateDiff(n, u);
+                 if(0 !== T.years || 0 !== T.months || 0 !== T.days){
+                  var _e41 = 365 * T.years + 30 * T.months + T.days;
+                  c = this.addDaysIso(c, _e41),
+                  u = this.isoToCalendarDate(c, r),
+                  T = simpleDateDiff(n, u),
+                  0 === T.years && 0 === T.months
+                   ? c = calculateSameMonthResult(T.days)
+                   : h = this.compareCalendarDates(n, u);
+                 }
+                 var p = 8;
+                 for(; h;){
+                  c = this.addDaysIso(c, h * p);
+                  var _e42 = u;
+                  u = this.isoToCalendarDate(c, r);
+                  var _a17 = h;
+                  if(h = this.compareCalendarDates(n, u), h)
+                   if
+                    (T = simpleDateDiff(n, u), 0 === T.years && 0 === T.months)
+                    c = calculateSameMonthResult(T.days), h = 0;
+                   else if(_a17 && h !== _a17)
+                    if(p > 1)
+                     p /= 2;
+                    else{
+                     if("reject" === t)
+                      throw new
+                             RangeError
+                             ("Can't find ISO date from calendar date: ".concat
+                               (JSON.stringify(_objectSpread2({}, o))));
+                     this.compareCalendarDates(u, _e42) > 0
+                     && (c = this.addDaysIso(c, - 1)),
+                     h = 0;
+                    }
+                 }
+                 if
+                  (r.set(l, c),
+                   d && r.set(d, c),
+                   void 0 === n.year || void 0 === n.month || void 0 === n.day
+                   || void 0 === n.monthCode
+                   || this.hasEra && (void 0 === n.era || void 0 === n.eraYear))
+                  throw new RangeError("Unexpected missing property");
+                 return c;
+                }},
+               {key: "temporalToCalendarDate",
+                value:
+                function temporalToCalendarDate(e, t){
+                 var
+                  r =
+                    {year: GetSlot(e, i),
+                     month: GetSlot(e, s),
+                     day: GetSlot(e, l)};
+                 return this.isoToCalendarDate(r, t);
+                }},
+               {key: "compareCalendarDates",
+                value:
+                function compareCalendarDates(e, t){
+                 var
+                  r =
+                    PrepareTemporalFields
+                     (e, ["day", "month", "year"], ["day", "month", "year"]),
+                  o =
+                    PrepareTemporalFields
+                     (t, ["day", "month", "year"], ["day", "month", "year"]);
+                 return r.year !== o.year
+                         ? ComparisonResult(r.year - o.year)
+                         : r.month
+                           !== o.month
+                           ? ComparisonResult(r.month - o.month)
+                           : r.day !== o.day ? ComparisonResult(r.day - o.day) : 0;
+                }},
+               {key: "regulateDate",
+                value:
+                function regulateDate(e){
+                 var
+                  t =
+                    arguments.length > 1 && arguments[1] !== undefined
+                     ? arguments[1]
+                     : "constrain";
+                 var r = arguments.length > 2 ? arguments[2] : undefined;
+                 var o = this.calendarToIsoDate(e, t, r);
+                 return this.isoToCalendarDate(o, r);
+                }},
+               {key: "addDaysIso",
+                value:
+                function addDaysIso(e, t){
+                 return AddISODate
+                         (e.year, e.month, e.day, 0, 0, 0, t, "constrain");
+                }},
+               {key: "addDaysCalendar",
+                value:
+                function addDaysCalendar(e, t, r){
+                 var
+                  o = this.calendarToIsoDate(e, "constrain", r),
+                  n = this.addDaysIso(o, t);
+                 return this.isoToCalendarDate(n, r);
+                }},
+               {key: "addMonthsCalendar",
+                value:
+                function addMonthsCalendar(e, t, r, o){
+                 var n = e;
+                 var _n24 = n, a = _n24.day;
+                 for(var _e43 = 0, _r61 = It(t); _e43 < _r61; _e43++){
+                  var
+                   _n25 = n,
+                   _e44 = _n25.month,
+                   _r62 = n,
+                   _i18 =
+                     t < 0
+                      ? - Math.max(a, this.daysInPreviousMonth(n, o))
+                      : this.daysInMonth(n, o),
+                   _s7 = this.calendarToIsoDate(n, "constrain", o);
+                  var _l7 = this.addDaysIso(_s7, _i18);
+                  if(n = this.isoToCalendarDate(_l7, o), t > 0){
+                   var _t47 = this.monthsInYear(_r62, o);
+                   for(; n.month - 1 != _e44 % _t47;)
+                    _l7 = this.addDaysIso(_l7, - 1),
+                    n = this.isoToCalendarDate(_l7, o);
+                  }
+                  n.day !== a
+                  &&
+                   (n =
+                    this.regulateDate
+                     (_objectSpread2(_objectSpread2({}, n), {}, {day: a}),
+                      "constrain",
+                      o));
+                 }
+                 if("reject" === r && n.day !== a)
+                  throw new
+                         RangeError
+                         ("Day ".concat
+                           (a, " does not exist in resulting calendar month"));
+                 return n;
+                }},
+               {key: "addCalendar",
+                value:
+                function addCalendar(e, _ref9, a, i){
+                 var
+                  _ref9$years = _ref9.years,
+                  t = _ref9$years === void 0 ? 0 : _ref9$years,
+                  _ref9$months = _ref9.months,
+                  r = _ref9$months === void 0 ? 0 : _ref9$months,
+                  _ref9$weeks = _ref9.weeks,
+                  o = _ref9$weeks === void 0 ? 0 : _ref9$weeks,
+                  _ref9$days = _ref9.days,
+                  n = _ref9$days === void 0 ? 0 : _ref9$days;
+                 var
+                  s = e.year,
+                  l = e.day,
+                  d = e.monthCode,
+                  m =
+                    this.adjustCalendarDate
+                     ({year: s + t, monthCode: d, day: l}, i),
+                  c = this.addMonthsCalendar(m, r, a, i),
+                  h = n + 7 * o;
+                 return this.addDaysCalendar(c, h, i);
+                }},
+               {key: "untilCalendar",
+                value:
+                function untilCalendar(e, t, r, o){
+                 var n = 0, a = 0, i = 0, s = 0;
+                 switch(r){
+                   case "day":
+                    n = this.calendarDaysUntil(e, t, o); break;
+                   case "week":
+                    {
+                     var _r63 = this.calendarDaysUntil(e, t, o);
+                     n = _r63 % 7, a = (_r63 - n) / 7;
+                     break;
+                    }
+                   case "month":
+                   case "year":
+                    {
+                     var _a18 = this.compareCalendarDates(t, e);
+                     if(! _a18) return {years: 0, months: 0, weeks: 0, days: 0};
+                     var _l8 = t.year - e.year, _d10 = t.day - e.day;
+                     if("year" === r && _l8){
+                      var _r64 = 0;
+                      t.monthCode > e.monthCode && (_r64 = 1),
+                      t.monthCode < e.monthCode && (_r64 = - 1),
+                      _r64 || (_r64 = Math.sign(_d10));
+                      s = _r64 * _a18 < 0 ? _l8 - _a18 : _l8;
+                     }
+                     var
+                      _m9,
+                      _c5 =
+                        s ? this.addCalendar(e, {years: s}, "constrain", o) : e;
+                     do{
+                      i += _a18,
+                      _m9 = _c5,
+                      _c5 = this.addMonthsCalendar(_m9, _a18, "constrain", o),
+                      _c5.day !== e.day
+                      &&
+                       (_c5 =
+                        this.regulateDate
+                         (_objectSpread2(_objectSpread2({}, _c5), {}, {day: e.day}),
+                          "constrain",
+                          o));
+                     }
+                     while
+                      (this.compareCalendarDates(t, _c5) * _a18 >= 0);
+                     i -= _a18;
+                     n = this.calendarDaysUntil(_m9, t, o);
+                     break;
+                    }
+                 }
+                 return {years: s, months: i, weeks: a, days: n};
+                }},
+               {key: "daysInMonth",
+                value:
+                function daysInMonth(e, t){
+                 var
+                  r = e.day,
+                  o = this.maximumMonthLength(e),
+                  n = this.minimumMonthLength(e);
+                 if(n === o) return n;
+                 var
+                  a = r <= o - n ? o : n,
+                  i = this.calendarToIsoDate(e, "constrain", t),
+                  s = this.addDaysIso(i, a),
+                  l = this.isoToCalendarDate(s, t),
+                  d = this.addDaysIso(s, - l.day);
+                 return this.isoToCalendarDate(d, t).day;
+                }},
+               {key: "daysInPreviousMonth",
+                value:
+                function daysInPreviousMonth(e, t){
+                 var r = e.day, o = e.month, n = e.year;
+                 var a = {year: o > 1 ? n : n - 1, month: o, day: 1};
+                 var i = o > 1 ? o - 1 : this.monthsInYear(a, t);
+                 a = _objectSpread2(_objectSpread2({}, a), {}, {month: i});
+                 var
+                  s = this.minimumMonthLength(a),
+                  l = this.maximumMonthLength(a);
+                 if(s === l) return l;
+                 var
+                  d = this.calendarToIsoDate(e, "constrain", t),
+                  m = this.addDaysIso(d, - r);
+                 return this.isoToCalendarDate(m, t).day;
+                }},
+               {key: "startOfCalendarYear",
+                value:
+                function startOfCalendarYear(e){
+                 return {year: e.year, month: 1, monthCode: "M01", day: 1};
+                }},
+               {key: "startOfCalendarMonth",
+                value:
+                function startOfCalendarMonth(e){
+                 return {year: e.year, month: e.month, day: 1};
+                }},
+               {key: "calendarDaysUntil",
+                value:
+                function calendarDaysUntil(e, t, r){
+                 var
+                  o = this.calendarToIsoDate(e, "constrain", r),
+                  n = this.calendarToIsoDate(t, "constrain", r);
+                 return this.isoDaysUntil(o, n);
+                }},
+               {key: "isoDaysUntil",
+                value:
+                function isoDaysUntil(e, t){
+                 return DifferenceISODate
+                         (e.year, e.month, e.day, t.year, t.month, t.day, "day").days;
+                }},
+               {key: "monthDayFromFields",
+                value:
+                function monthDayFromFields(e, t, r){
+                 var o, n, a, i, s, l = e.monthCode, d = e.day;
+                 if(void 0 === l){
+                  var _o37 = e.year, _n26 = e.era, _a19 = e.eraYear;
+                  if(void 0 === _o37 && (void 0 === _n26 || void 0 === _a19))
+                   throw new
+                          TypeError
+                          ("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
+                  var
+                   _this$isoToCalendarDa =
+                     this.isoToCalendarDate(this.calendarToIsoDate(e, t, r), r);
+                  l = _this$isoToCalendarDa.monthCode;
+                  d = _this$isoToCalendarDa.day;
+                 }
+                 var
+                  m =
+                    this.isoToCalendarDate({year: 1972, month: 12, day: 31}, r),
+                  c =
+                    m.monthCode > l || m.monthCode === l && m.day >= d
+                     ? m.year
+                     : m.year - 1;
+                 for(var _e45 = 0; _e45 < 100; _e45++){
+                  var
+                   _m10 =
+                     this.adjustCalendarDate
+                      ({day: d, monthCode: l, year: c - _e45}, r),
+                   _h3 = this.calendarToIsoDate(_m10, "constrain", r),
+                   _u2 = this.isoToCalendarDate(_h3, r);
+                  if
+                   (o = _h3.year,
+                    n = _h3.month,
+                    a = _h3.day,
+                    _u2.monthCode === l && _u2.day === d)
+                   return {month: n, day: a, year: o};
+                  "constrain" === t
+                  &&
+                   (void 0 === i
+                   || _u2.monthCode === i.monthCode && _u2.day > i.day)
+                  && (i = _u2, s = _h3);
+                 }
+                 if("constrain" === t && void 0 !== s) return s;
+                 throw new
+                        RangeError
+                        ("No recent ".concat(this.id, " year with monthCode ").concat
+                           (l, " and day ").concat
+                          (d));
+                }}]);
+    }
+    ();
+var
+ HebrewHelper =
+   function(_HelperBase){
+     function HebrewHelper(){
+      var _this3;
+      _classCallCheck(this, HebrewHelper);
+      _this3 = _callSuper(this, HebrewHelper, arguments),
+      _this3.id = "hebrew",
+      _this3.calendarType = "lunisolar",
+      _this3.months =
+       {Tishri: {leap: 1, regular: 1, monthCode: "M01", days: 30},
+        Heshvan:
+        {leap: 2, regular: 2, monthCode: "M02", days: {min: 29, max: 30}},
+        Kislev:
+        {leap: 3, regular: 3, monthCode: "M03", days: {min: 29, max: 30}},
+        Tevet: {leap: 4, regular: 4, monthCode: "M04", days: 29},
+        Shevat: {leap: 5, regular: 5, monthCode: "M05", days: 30},
+        Adar: {leap: void 0, regular: 6, monthCode: "M06", days: 29},
+        "Adar I": {leap: 6, regular: void 0, monthCode: "M05L", days: 30},
+        "Adar II": {leap: 7, regular: void 0, monthCode: "M06", days: 29},
+        Nisan: {leap: 8, regular: 7, monthCode: "M07", days: 30},
+        Iyar: {leap: 9, regular: 8, monthCode: "M08", days: 29},
+        Sivan: {leap: 10, regular: 9, monthCode: "M09", days: 30},
+        Tamuz: {leap: 11, regular: 10, monthCode: "M10", days: 29},
+        Av: {leap: 12, regular: 11, monthCode: "M11", days: 30},
+        Elul: {leap: 13, regular: 12, monthCode: "M12", days: 29}},
+      _this3.hasEra = ! 1;
+      return _this3;
+     }
+     _inherits(HebrewHelper, _HelperBase);
+     return _createClass
+             (HebrewHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e){
+                 var t = e.year;
+                 return (7 * t + 1) % 19 < 7;
+                }},
+               {key: "monthsInYear",
+                value:
+                function monthsInYear(e){return this.inLeapYear(e) ? 13 : 12;}},
+               {key: "minimumMonthLength",
+                value:
+                function minimumMonthLength(e){
+                 return this.minMaxMonthLength(e, "min");
+                }},
+               {key: "maximumMonthLength",
+                value:
+                function maximumMonthLength(e){
+                 return this.minMaxMonthLength(e, "max");
+                }},
+               {key: "minMaxMonthLength",
+                value:
+                function minMaxMonthLength(e, t){
+                 var
+                  r = e.month,
+                  o = e.year,
+                  n = this.getMonthCode(o, r),
+                  a =
+                    wt(this.months).find
+                     (function(e){return e[1].monthCode === n;});
+                 if(void 0 === a)
+                  throw new RangeError("unmatched Hebrew month: ".concat(r));
+                 var i = a[1].days;
+                 return "number" == typeof i ? i : i[t];
+                }},
+               {key: "estimateIsoDate",
+                value:
+                function estimateIsoDate(e){
+                 var t = e.year;
+                 return {year: t - 3760, month: 1, day: 1};
+                }},
+               {key: "getMonthCode",
+                value:
+                function getMonthCode(e, t){
+                 return this.inLeapYear({year: e})
+                         ? 6
+                           === t
+                           ? buildMonthCode(5, ! 0)
+                           : buildMonthCode(t < 6 ? t : t - 1)
+                         : buildMonthCode(t);
+                }},
+               {key: "adjustCalendarDate",
+                value:
+                function adjustCalendarDate(e, t){
+                 var
+                  r =
+                    arguments.length > 2 && arguments[2] !== undefined
+                     ? arguments[2]
+                     : "constrain";
+                 var
+                  o =
+                    arguments.length > 3 && arguments[3] !== undefined
+                     ? arguments[3]
+                     : ! 1;
+                 var
+                  n = e.year,
+                  a = e.eraYear,
+                  i = e.month,
+                  s = e.monthCode,
+                  l = e.day,
+                  d = e.monthExtra;
+                 if
+                  (void 0 === n && void 0 !== a && (n = a),
+                   void 0 === a && void 0 !== n && (a = n),
+                   o){
+                  if(d){
+                   var _e46 = this.months[d];
+                   if(! _e46)
+                    throw new
+                           RangeError
+                           ("Unrecognized month from formatToParts: ".concat(d));
+                   i = this.inLeapYear({year: n}) ? _e46.leap : _e46.regular;
+                  }
+                  s = this.getMonthCode(n, i);
+                  return {year: n,
+                          month: i,
+                          day: l,
+                          era: void 0,
+                          eraYear: a,
+                          monthCode: s};
+                 }
+                 if(this.validateCalendarDate(e), void 0 === i){
+                  if(s.endsWith("L")){
+                   if("M05L" !== s)
+                    throw new
+                           RangeError
+                           ("Hebrew leap month must have monthCode M05L, not ".concat
+                             (s));
+                   if(i = 6, ! this.inLeapYear({year: n})){
+                    if("reject" === r)
+                     throw new
+                            RangeError
+                            ("Hebrew monthCode M05L is invalid in year ".concat
+                              (n, " which is not a leap year"));
+                    i = 6, s = "M06";
+                   }
+                  }
+                  else{
+                   i = monthCodeNumberPart(s),
+                   this.inLeapYear({year: n}) && i >= 6 && i++;
+                   var _e47 = this.monthsInYear({year: n});
+                   if(i < 1 || i > _e47)
+                    throw new RangeError("Invalid monthCode: ".concat(s));
+                  }
+                 }
+                 else if
+                  ("reject" === r
+                    ? (RejectToRange
+                       (i, 1, this.monthsInYear({year: n})),
+                      RejectToRange
+                       (l, 1, this.maximumMonthLength({year: n, month: i})))
+                    : (i
+                      = ConstrainToRange(i, 1, this.monthsInYear({year: n})),
+                      l =
+                       ConstrainToRange
+                        (l, 1, this.maximumMonthLength({year: n, month: i}))),
+                   void 0 === s)
+                  s = this.getMonthCode(n, i);
+                 else{
+                  if(this.getMonthCode(n, i) !== s)
+                   throw new
+                          RangeError
+                          ("monthCode ".concat(s, " doesn't correspond to month ").concat
+                             (i, " in Hebrew year ").concat
+                            (n));
+                 }
+                 return _objectSpread2
+                         (_objectSpread2({}, e),
+                          {},
+                          {day: l, month: i, monthCode: s, year: n, eraYear: a});
+                }}]);
+    }
+    (HelperBase);
+var
+ IslamicBaseHelper =
+   function(_HelperBase2){
+     function IslamicBaseHelper(){
+      var _this4;
+      _classCallCheck(this, IslamicBaseHelper);
+      _this4 = _callSuper(this, IslamicBaseHelper, arguments),
+      _this4.calendarType = "lunar",
+      _this4.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30,
+      _this4.DAYS_PER_ISO_YEAR = 365.2425,
+      _this4.constantEra = "ah";
+      return _this4;
+     }
+     _inherits(IslamicBaseHelper, _HelperBase2);
+     return _createClass
+             (IslamicBaseHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e, t){
+                 return 30
+                        === this.daysInMonth({year: e.year, month: 12, day: 1}, t);
+                }},
+               {key: "monthsInYear",
+                value: function monthsInYear(){return 12;}},
+               {key: "minimumMonthLength",
+                value: function minimumMonthLength(){return 29;}},
+               {key: "maximumMonthLength",
+                value: function maximumMonthLength(){return 30;}},
+               {key: "estimateIsoDate",
+                value:
+                function estimateIsoDate(e){
+                 var
+                  _this$adjustCalendarD = this.adjustCalendarDate(e),
+                  t = _this$adjustCalendarD.year;
+                 return {year:
+                         St(t * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR)
+                         + 622,
+                         month: 1,
+                         day: 1};
+                }}]);
+    }
+    (HelperBase);
+var
+ IslamicHelper =
+   function(_IslamicBaseHelper){
+     function IslamicHelper(){
+      var _this5;
+      _classCallCheck(this, IslamicHelper);
+      _this5 = _callSuper(this, IslamicHelper, arguments),
+      _this5.id = "islamic";
+      return _this5;
+     }
+     _inherits(IslamicHelper, _IslamicBaseHelper);
+     return _createClass(IslamicHelper);
+    }
+    (IslamicBaseHelper);
+var
+ IslamicUmalquraHelper =
+   function(_IslamicBaseHelper2){
+     function IslamicUmalquraHelper(){
+      var _this6;
+      _classCallCheck(this, IslamicUmalquraHelper);
+      _this6 = _callSuper(this, IslamicUmalquraHelper, arguments),
+      _this6.id = "islamic-umalqura";
+      return _this6;
+     }
+     _inherits(IslamicUmalquraHelper, _IslamicBaseHelper2);
+     return _createClass(IslamicUmalquraHelper);
+    }
+    (IslamicBaseHelper);
+var
+ IslamicTblaHelper =
+   function(_IslamicBaseHelper3){
+     function IslamicTblaHelper(){
+      var _this7;
+      _classCallCheck(this, IslamicTblaHelper);
+      _this7 = _callSuper(this, IslamicTblaHelper, arguments),
+      _this7.id = "islamic-tbla";
+      return _this7;
+     }
+     _inherits(IslamicTblaHelper, _IslamicBaseHelper3);
+     return _createClass(IslamicTblaHelper);
+    }
+    (IslamicBaseHelper);
+var
+ IslamicCivilHelper =
+   function(_IslamicBaseHelper4){
+     function IslamicCivilHelper(){
+      var _this8;
+      _classCallCheck(this, IslamicCivilHelper);
+      _this8 = _callSuper(this, IslamicCivilHelper, arguments),
+      _this8.id = "islamic-civil";
+      return _this8;
+     }
+     _inherits(IslamicCivilHelper, _IslamicBaseHelper4);
+     return _createClass(IslamicCivilHelper);
+    }
+    (IslamicBaseHelper);
+var
+ IslamicRgsaHelper =
+   function(_IslamicBaseHelper5){
+     function IslamicRgsaHelper(){
+      var _this9;
+      _classCallCheck(this, IslamicRgsaHelper);
+      _this9 = _callSuper(this, IslamicRgsaHelper, arguments),
+      _this9.id = "islamic-rgsa";
+      return _this9;
+     }
+     _inherits(IslamicRgsaHelper, _IslamicBaseHelper5);
+     return _createClass(IslamicRgsaHelper);
+    }
+    (IslamicBaseHelper);
+var
+ IslamicCcHelper =
+   function(_IslamicBaseHelper6){
+     function IslamicCcHelper(){
+      var _this10;
+      _classCallCheck(this, IslamicCcHelper);
+      _this10 = _callSuper(this, IslamicCcHelper, arguments),
+      _this10.id = "islamicc";
+      return _this10;
+     }
+     _inherits(IslamicCcHelper, _IslamicBaseHelper6);
+     return _createClass(IslamicCcHelper);
+    }
+    (IslamicBaseHelper);
+var
+ PersianHelper =
+   function(_HelperBase3){
+     function PersianHelper(){
+      var _this11;
+      _classCallCheck(this, PersianHelper);
+      _this11 = _callSuper(this, PersianHelper, arguments),
+      _this11.id = "persian",
+      _this11.calendarType = "solar",
+      _this11.constantEra = "ap";
+      return _this11;
+     }
+     _inherits(PersianHelper, _HelperBase3);
+     return _createClass
+             (PersianHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e, t){
+                 return IslamicHelper.prototype.inLeapYear.call(this, e, t);
+                }},
+               {key: "monthsInYear",
+                value: function monthsInYear(){return 12;}},
+               {key: "minimumMonthLength",
+                value:
+                function minimumMonthLength(e){
+                 var t = e.month;
+                 return 12 === t ? 29 : t <= 6 ? 31 : 30;
+                }},
+               {key: "maximumMonthLength",
+                value:
+                function maximumMonthLength(e){
+                 var t = e.month;
+                 return 12 === t ? 30 : t <= 6 ? 31 : 30;
+                }},
+               {key: "estimateIsoDate",
+                value:
+                function estimateIsoDate(e){
+                 var
+                  _this$adjustCalendarD2 = this.adjustCalendarDate(e),
+                  t = _this$adjustCalendarD2.year;
+                 return {year: t + 621, month: 1, day: 1};
+                }}]);
+    }
+    (HelperBase);
+var
+ IndianHelper =
+   function(_HelperBase4){
+     function IndianHelper(){
+      var _this12;
+      _classCallCheck(this, IndianHelper);
+      _this12 = _callSuper(this, IndianHelper, arguments),
+      _this12.id = "indian",
+      _this12.calendarType = "solar",
+      _this12.constantEra = "saka",
+      _this12.months =
+       {1:
+        {length: 30, month: 3, day: 22, leap: {length: 31, month: 3, day: 21}},
+        2: {length: 31, month: 4, day: 21},
+        3: {length: 31, month: 5, day: 22},
+        4: {length: 31, month: 6, day: 22},
+        5: {length: 31, month: 7, day: 23},
+        6: {length: 31, month: 8, day: 23},
+        7: {length: 30, month: 9, day: 23},
+        8: {length: 30, month: 10, day: 23},
+        9: {length: 30, month: 11, day: 22},
+        10: {length: 30, month: 12, day: 22},
+        11: {length: 30, month: 1, nextYear: ! 0, day: 21},
+        12: {length: 30, month: 2, nextYear: ! 0, day: 20}},
+      _this12.vulnerableToBceBug =
+       "10/11/-79 Saka"
+       !==
+        new Date("0000-01-01T00:00Z").toLocaleDateString
+         ("en-US-u-ca-indian", {timeZone: "UTC"});
+      return _this12;
+     }
+     _inherits(IndianHelper, _HelperBase4);
+     return _createClass
+             (IndianHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e){
+                 return isGregorianLeapYear(e.year + 78);
+                }},
+               {key: "monthsInYear",
+                value: function monthsInYear(){return 12;}},
+               {key: "minimumMonthLength",
+                value:
+                function minimumMonthLength(e){
+                 return this.getMonthInfo(e).length;
+                }},
+               {key: "maximumMonthLength",
+                value:
+                function maximumMonthLength(e){
+                 return this.getMonthInfo(e).length;
+                }},
+               {key: "getMonthInfo",
+                value:
+                function getMonthInfo(e){
+                 var t = e.month;
+                 var r = this.months[t];
+                 if(void 0 === r)
+                  throw new RangeError("Invalid month: ".concat(t));
+                 return this.inLeapYear(e) && r.leap && (r = r.leap), r;
+                }},
+               {key: "estimateIsoDate",
+                value:
+                function estimateIsoDate(e){
+                 var t = this.adjustCalendarDate(e), r = this.getMonthInfo(t);
+                 return AddISODate
+                         (t.year + 78 + (r.nextYear ? 1 : 0),
+                          r.month,
+                          r.day,
+                          0,
+                          0,
+                          0,
+                          t.day - 1,
+                          "constrain");
+                }},
+               {key: "checkIcuBugs",
+                value:
+                function checkIcuBugs(e){
+                 if(this.vulnerableToBceBug && e.year < 1)
+                  throw new
+                         RangeError
+                         ("calendar '".concat
+                           (this.id,
+                            "' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
+                }}]);
+    }
+    (HelperBase);
+function isGregorianLeapYear(e){
+ return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
+}
+var
+ GregorianBaseHelper =
+   function(_HelperBase5){
+     function GregorianBaseHelper(e, t){
+      var _this13;
+      _classCallCheck(this, GregorianBaseHelper);
+      _this13 = _callSuper(this, GregorianBaseHelper),
+      _this13.calendarType = "solar",
+      _this13.v8IsVulnerableToJulianBug =
+       new Date("+001001-01-01T00:00Z").toLocaleDateString
+         ("en-US-u-ca-japanese", {timeZone: "UTC"}).startsWith
+        ("12"),
+      _this13.calendarIsVulnerableToJulianBug = ! 1,
+      _this13.id = e;
+      var
+       _adjustEras =
+         function adjustEras(e){
+           var t, r = e;
+           if(0 === r.length)
+            throw new RangeError("Invalid era data: eras are required");
+           if(1 === r.length && r[0].reverseOf)
+            throw new
+                   RangeError
+                   ("Invalid era data: anchor era cannot count years backwards");
+           if(1 === r.length && ! r[0].name)
+            throw new
+                   RangeError
+                   ("Invalid era data: at least one named era is required");
+           if(r.filter(function(e){return null != e.reverseOf;}).length > 1)
+            throw new
+                   RangeError
+                   ("Invalid era data: only one era can count years backwards");
+           r.forEach
+            (function(e){
+              if(e.isAnchor || ! e.anchorEpoch && ! e.reverseOf){
+               if(t)
+                throw new
+                       RangeError
+                       ("Invalid era data: cannot have multiple anchor eras");
+               t = e, e.anchorEpoch = {year: e.hasYearZero ? 0 : 1};
               }
-              return _this14.compareCalendarDates(o, e.anchorEpoch) >= 0 && (r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1), !0);
-            });
-          if (!n) throw new RangeError("Year ".concat(t, " was not matched by any era"));
-          return {
-            eraYear: r,
-            era: n.name
-          };
-        };
-      var t = e.year,
-        r = e.eraYear,
-        o = e.era;
-      if (null != t) (_eraFromYear = eraFromYear(t), r = _eraFromYear.eraYear, o = _eraFromYear.era), checkField("era", o), checkField("eraYear", r);else {
-        if (null == r) throw new RangeError("Either `year` or `eraYear` and `era` are required");
-        {
-          var _eraFromYear2;
-          var _e48 = void 0 === o ? void 0 : this.eras.find(function (e) {
-            return e.name === o || e.genericName === o;
-          });
-          if (!_e48) throw new RangeError("Era ".concat(o, " (ISO year ").concat(r, ") was not matched by any era"));
-          if (r < 1 && _e48.reverseOf) throw new RangeError("Years in ".concat(o, " era must be positive, not ").concat(t));
-          t = _e48.reverseOf ? _e48.anchorEpoch.year - r : r + _e48.anchorEpoch.year - (_e48.hasYearZero ? 0 : 1), checkField("year", t), (_eraFromYear2 = eraFromYear(t), r = _eraFromYear2.eraYear, o = _eraFromYear2.era);
-        }
-      }
-      return _objectSpread2(_objectSpread2({}, e), {}, {
-        year: t,
-        eraYear: r,
-        era: o
-      });
-    }
-  }, {
-    key: "adjustCalendarDate",
-    value: function adjustCalendarDate(e, t) {
-      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "constrain";
-      var o = e;
-      var _o39 = o,
-        n = _o39.month,
-        a = _o39.monthCode;
-      return void 0 === n && (o = _objectSpread2(_objectSpread2({}, o), {}, {
-        month: monthCodeNumberPart(a)
-      })), this.validateCalendarDate(o), o = this.completeEraYear(o), _get(_getPrototypeOf(GregorianBaseHelper.prototype), "adjustCalendarDate", this).call(this, o, t, r);
-    }
-  }, {
-    key: "estimateIsoDate",
-    value: function estimateIsoDate(e) {
-      var t = this.adjustCalendarDate(e),
-        r = t.year,
-        o = t.month,
-        n = t.day,
-        a = this.anchorEra;
-      return RegulateISODate(r + a.isoEpoch.year - (a.hasYearZero ? 0 : 1), o, n, "constrain");
-    }
-  }, {
-    key: "checkIcuBugs",
-    value: function checkIcuBugs(e) {
-      if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
-        if (CompareISODate(e.year, e.month, e.day, 1582, 10, 15) < 0) throw new RangeError("calendar '".concat(this.id, "' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)"));
-      }
-    }
-  }]);
-  return GregorianBaseHelper;
-}(HelperBase);
-var OrthodoxBaseHelper = /*#__PURE__*/function (_GregorianBaseHelper) {
-  _inherits(OrthodoxBaseHelper, _GregorianBaseHelper);
-  var _super12 = _createSuper(OrthodoxBaseHelper);
-  function OrthodoxBaseHelper(e, t) {
-    _classCallCheck(this, OrthodoxBaseHelper);
-    return _super12.call(this, e, t);
-  }
-  _createClass(OrthodoxBaseHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e) {
-      var t = e.year;
-      return (t + 1) % 4 == 0;
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear() {
-      return 13;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength(e) {
-      var t = e.month;
-      return 13 === t ? this.inLeapYear(e) ? 6 : 5 : 30;
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength(e) {
-      return this.minimumMonthLength(e);
-    }
-  }]);
-  return OrthodoxBaseHelper;
-}(GregorianBaseHelper);
-var EthioaaHelper = /*#__PURE__*/function (_OrthodoxBaseHelper) {
-  _inherits(EthioaaHelper, _OrthodoxBaseHelper);
-  var _super13 = _createSuper(EthioaaHelper);
-  function EthioaaHelper() {
-    _classCallCheck(this, EthioaaHelper);
-    return _super13.call(this, "ethioaa", [{
-      name: "era0",
-      isoEpoch: {
-        year: -5492,
-        month: 7,
-        day: 17
-      }
-    }]);
-  }
-  return _createClass(EthioaaHelper);
-}(OrthodoxBaseHelper);
-var CopticHelper = /*#__PURE__*/function (_OrthodoxBaseHelper2) {
-  _inherits(CopticHelper, _OrthodoxBaseHelper2);
-  var _super14 = _createSuper(CopticHelper);
-  function CopticHelper() {
-    _classCallCheck(this, CopticHelper);
-    return _super14.call(this, "coptic", [{
-      name: "era1",
-      isoEpoch: {
-        year: 284,
-        month: 8,
-        day: 29
-      }
-    }, {
-      name: "era0",
-      reverseOf: "era1"
-    }]);
-  }
-  return _createClass(CopticHelper);
-}(OrthodoxBaseHelper);
-var EthiopicHelper = /*#__PURE__*/function (_OrthodoxBaseHelper3) {
-  _inherits(EthiopicHelper, _OrthodoxBaseHelper3);
-  var _super15 = _createSuper(EthiopicHelper);
-  function EthiopicHelper() {
-    _classCallCheck(this, EthiopicHelper);
-    return _super15.call(this, "ethiopic", [{
-      name: "era0",
-      isoEpoch: {
-        year: -5492,
-        month: 7,
-        day: 17
-      }
-    }, {
-      name: "era1",
-      isoEpoch: {
-        year: 8,
-        month: 8,
-        day: 27
-      },
-      anchorEpoch: {
-        year: 5501
-      }
-    }]);
-  }
-  return _createClass(EthiopicHelper);
-}(OrthodoxBaseHelper);
-var RocHelper = /*#__PURE__*/function (_GregorianBaseHelper2) {
-  _inherits(RocHelper, _GregorianBaseHelper2);
-  var _super16 = _createSuper(RocHelper);
-  function RocHelper() {
-    var _this15;
-    _classCallCheck(this, RocHelper);
-    _this15 = _super16.call(this, "roc", [{
-      name: "minguo",
-      isoEpoch: {
-        year: 1912,
-        month: 1,
-        day: 1
-      }
-    }, {
-      name: "before-roc",
-      reverseOf: "minguo"
-    }]), _this15.calendarIsVulnerableToJulianBug = !0;
-    return _this15;
-  }
-  return _createClass(RocHelper);
-}(GregorianBaseHelper);
-var BuddhistHelper = /*#__PURE__*/function (_GregorianBaseHelper3) {
-  _inherits(BuddhistHelper, _GregorianBaseHelper3);
-  var _super17 = _createSuper(BuddhistHelper);
-  function BuddhistHelper() {
-    var _this16;
-    _classCallCheck(this, BuddhistHelper);
-    _this16 = _super17.call(this, "buddhist", [{
-      name: "be",
-      hasYearZero: !0,
-      isoEpoch: {
-        year: -543,
-        month: 1,
-        day: 1
-      }
-    }]), _this16.calendarIsVulnerableToJulianBug = !0;
-    return _this16;
-  }
-  return _createClass(BuddhistHelper);
-}(GregorianBaseHelper);
-var GregoryHelper = /*#__PURE__*/function (_GregorianBaseHelper4) {
-  _inherits(GregoryHelper, _GregorianBaseHelper4);
-  var _super18 = _createSuper(GregoryHelper);
-  function GregoryHelper() {
-    _classCallCheck(this, GregoryHelper);
-    return _super18.call(this, "gregory", [{
-      name: "ce",
-      isoEpoch: {
-        year: 1,
-        month: 1,
-        day: 1
-      }
-    }, {
-      name: "bce",
-      reverseOf: "ce"
-    }]);
-  }
-  _createClass(GregoryHelper, [{
-    key: "reviseIntlEra",
-    value: function reviseIntlEra(e) {
-      var t = e.era,
-        r = e.eraYear;
-      return "bc" !== t && "b" !== t || (t = "bce"), "ad" !== t && "a" !== t || (t = "ce"), {
-        era: t,
-        eraYear: r
-      };
-    }
-  }]);
-  return GregoryHelper;
-}(GregorianBaseHelper);
-var JapaneseHelper = /*#__PURE__*/function (_GregorianBaseHelper5) {
-  _inherits(JapaneseHelper, _GregorianBaseHelper5);
-  var _super19 = _createSuper(JapaneseHelper);
-  function JapaneseHelper() {
-    var _this17;
-    _classCallCheck(this, JapaneseHelper);
-    _this17 = _super19.call(this, "japanese", [{
-      name: "reiwa",
-      isoEpoch: {
-        year: 2019,
-        month: 5,
-        day: 1
-      },
-      anchorEpoch: {
-        year: 2019,
-        month: 5,
-        day: 1
-      }
-    }, {
-      name: "heisei",
-      isoEpoch: {
-        year: 1989,
-        month: 1,
-        day: 8
-      },
-      anchorEpoch: {
-        year: 1989,
-        month: 1,
-        day: 8
-      }
-    }, {
-      name: "showa",
-      isoEpoch: {
-        year: 1926,
-        month: 12,
-        day: 25
-      },
-      anchorEpoch: {
-        year: 1926,
-        month: 12,
-        day: 25
-      }
-    }, {
-      name: "taisho",
-      isoEpoch: {
-        year: 1912,
-        month: 7,
-        day: 30
-      },
-      anchorEpoch: {
-        year: 1912,
-        month: 7,
-        day: 30
-      }
-    }, {
-      name: "meiji",
-      isoEpoch: {
-        year: 1868,
-        month: 9,
-        day: 8
-      },
-      anchorEpoch: {
-        year: 1868,
-        month: 9,
-        day: 8
-      }
-    }, {
-      name: "ce",
-      isoEpoch: {
-        year: 1,
-        month: 1,
-        day: 1
-      }
-    }, {
-      name: "bce",
-      reverseOf: "ce"
-    }]), _this17.calendarIsVulnerableToJulianBug = !0, _this17.eraLength = "long", _this17.erasBeginMidYear = !0;
-    return _this17;
-  }
-  _createClass(JapaneseHelper, [{
-    key: "reviseIntlEra",
-    value: function reviseIntlEra(e, t) {
-      var r = e.era,
-        o = e.eraYear,
-        n = t.year;
-      return this.eras.find(function (e) {
-        return e.name === r;
-      }) ? {
-        era: r,
-        eraYear: o
-      } : n < 1 ? {
-        era: "bce",
-        eraYear: 1 - n
-      } : {
-        era: "ce",
-        eraYear: n
-      };
-    }
-  }]);
-  return JapaneseHelper;
-}(GregorianBaseHelper);
-var ChineseBaseHelper = /*#__PURE__*/function (_HelperBase6) {
-  _inherits(ChineseBaseHelper, _HelperBase6);
-  var _super20 = _createSuper(ChineseBaseHelper);
-  function ChineseBaseHelper() {
-    var _this18;
-    _classCallCheck(this, ChineseBaseHelper);
-    _this18 = _super20.apply(this, arguments), _this18.calendarType = "lunisolar", _this18.hasEra = !1;
-    return _this18;
-  }
-  _createClass(ChineseBaseHelper, [{
-    key: "inLeapYear",
-    value: function inLeapYear(e, t) {
-      var r = this.getMonthList(e.year, t);
-      return 13 === wt(r).length;
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear(e, t) {
-      return this.inLeapYear(e, t) ? 13 : 12;
-    }
-  }, {
-    key: "minimumMonthLength",
-    value: function minimumMonthLength() {
-      return 29;
-    }
-  }, {
-    key: "maximumMonthLength",
-    value: function maximumMonthLength() {
-      return 30;
-    }
-  }, {
-    key: "getMonthList",
-    value: function getMonthList(e, t) {
-      var _this19 = this,
-        _getCalendarDate2;
-      if (void 0 === e) throw new TypeError("Missing year");
-      var r = JSON.stringify({
-          func: "getMonthList",
-          calendarYear: e,
-          id: this.id
-        }),
-        o = t.get(r);
-      if (o) return o;
-      var n = this.getFormatter(),
-        getCalendarDate = function getCalendarDate(e, t) {
-          var r = toUtcIsoDateString({
-              isoYear: e,
-              isoMonth: 2,
-              isoDay: 1
-            }),
-            o = new Date(r);
-          o.setUTCDate(t + 1);
-          var a = n.formatToParts(o),
-            i = a.find(function (e) {
-              return "month" === e.type;
-            }).value,
-            s = +a.find(function (e) {
-              return "day" === e.type;
-            }).value;
-          var l = a.find(function (e) {
-            return "relatedYear" === e.type;
-          });
-          if (void 0 === l) throw new RangeError("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat(_this19.id, " calendar. Try Node 14+ or modern browsers."));
-          return l = +l.value, {
-            calendarMonthString: i,
-            calendarDay: s,
-            calendarYearToVerify: l
-          };
-        };
-      var a = 17,
-        _getCalendarDate = getCalendarDate(e, a),
-        i = _getCalendarDate.calendarMonthString,
-        s = _getCalendarDate.calendarDay,
-        l = _getCalendarDate.calendarYearToVerify;
-      "1" !== i && (a += 29, (_getCalendarDate2 = getCalendarDate(e, a), i = _getCalendarDate2.calendarMonthString, s = _getCalendarDate2.calendarDay)), a -= s - 5;
-      var d = {};
-      var m,
-        c,
-        h = 1,
-        u = !1;
-      do {
-        var _getCalendarDate3;
-        (_getCalendarDate3 = getCalendarDate(e, a), i = _getCalendarDate3.calendarMonthString, s = _getCalendarDate3.calendarDay, l = _getCalendarDate3.calendarYearToVerify), m && (d[c].daysInMonth = m + 30 - s), l !== e ? u = !0 : (d[i] = {
-          monthIndex: h++
-        }, a += 30), m = s, c = i;
-      } while (!u);
-      return d[c].daysInMonth = m + 30 - s, t.set(r, d), d;
-    }
-  }, {
-    key: "estimateIsoDate",
-    value: function estimateIsoDate(e) {
-      var t = e.year,
-        r = e.month;
-      return {
-        year: t,
-        month: r >= 12 ? 12 : r + 1,
-        day: 1
-      };
-    }
-  }, {
-    key: "adjustCalendarDate",
-    value: function adjustCalendarDate(e, t) {
-      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "constrain";
-      var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
-      var n = e.year,
-        a = e.month,
-        i = e.monthExtra,
-        s = e.day,
-        l = e.monthCode,
-        d = e.eraYear;
-      if (o) {
-        if (n = d, i && "bis" !== i) throw new RangeError("Unexpected leap month suffix: ".concat(i));
-        var _e49 = buildMonthCode(a, void 0 !== i),
-          _r65 = "".concat(a).concat(i || ""),
-          _o40 = this.getMonthList(n, t)[_r65];
-        if (void 0 === _o40) throw new RangeError("Unmatched month ".concat(_r65, " in Chinese year ").concat(n));
-        return a = _o40.monthIndex, {
-          year: n,
-          month: a,
-          day: s,
-          era: void 0,
-          eraYear: d,
-          monthCode: _e49
-        };
-      }
-      if (this.validateCalendarDate(e), void 0 === n && (n = d), void 0 === d && (d = n), void 0 === a) {
-        var _e50 = this.getMonthList(n, t);
-        var _o41 = l.replace("L", "bis").slice(1);
-        "0" === _o41[0] && (_o41 = _o41.slice(1));
-        var _i19 = _e50[_o41];
-        if (a = _i19 && _i19.monthIndex, void 0 === a && l.endsWith("L") && "M13L" != l && "constrain" === r) {
-          var _t48 = l.slice(1, -1);
-          "0" === _t48[0] && (_t48 = _t48.slice(1)), _i19 = _e50[_t48], _i19 && (a = _i19.monthIndex, l = buildMonthCode(_t48));
-        }
-        if (void 0 === a) throw new RangeError("Unmatched month ".concat(l, " in Chinese year ").concat(n));
-      } else if (void 0 === l) {
-        var _e51 = this.getMonthList(n, t),
-          _o42 = wt(_e51),
-          _i20 = _o42.length;
-        "reject" === r ? (RejectToRange(a, 1, _i20), RejectToRange(s, 1, this.maximumMonthLength())) : (a = ConstrainToRange(a, 1, _i20), s = ConstrainToRange(s, 1, this.maximumMonthLength()));
-        var _d11 = _o42.find(function (_ref10) {
-          var _ref11 = _slicedToArray(_ref10, 2),
-            e = _ref11[1];
-          return e.monthIndex === a;
-        });
-        if (void 0 === _d11) throw new RangeError("Invalid month ".concat(a, " in Chinese year ").concat(n));
-        l = buildMonthCode(_d11[0].replace("bis", ""), -1 !== _d11[0].indexOf("bis"));
-      } else {
-        var _e52 = this.getMonthList(n, t);
-        var _r66 = l.replace("L", "bis").slice(1);
-        "0" === _r66[0] && (_r66 = _r66.slice(1));
-        var _o43 = _e52[_r66];
-        if (!_o43) throw new RangeError("Unmatched monthCode ".concat(l, " in Chinese year ").concat(n));
-        if (a !== _o43.monthIndex) throw new RangeError("monthCode ".concat(l, " doesn't correspond to month ").concat(a, " in Chinese year ").concat(n));
-      }
-      return _objectSpread2(_objectSpread2({}, e), {}, {
-        year: n,
-        eraYear: d,
-        month: a,
-        monthCode: l,
-        day: s
-      });
-    }
-  }]);
-  return ChineseBaseHelper;
-}(HelperBase);
-var ChineseHelper = /*#__PURE__*/function (_ChineseBaseHelper) {
-  _inherits(ChineseHelper, _ChineseBaseHelper);
-  var _super21 = _createSuper(ChineseHelper);
-  function ChineseHelper() {
-    var _this20;
-    _classCallCheck(this, ChineseHelper);
-    _this20 = _super21.apply(this, arguments), _this20.id = "chinese";
-    return _this20;
-  }
-  return _createClass(ChineseHelper);
-}(ChineseBaseHelper);
-var DangiHelper = /*#__PURE__*/function (_ChineseBaseHelper2) {
-  _inherits(DangiHelper, _ChineseBaseHelper2);
-  var _super22 = _createSuper(DangiHelper);
-  function DangiHelper() {
-    var _this21;
-    _classCallCheck(this, DangiHelper);
-    _this21 = _super22.apply(this, arguments), _this21.id = "dangi";
-    return _this21;
-  }
-  return _createClass(DangiHelper);
-}(ChineseBaseHelper);
-var NonIsoCalendar = /*#__PURE__*/function () {
-  function NonIsoCalendar(e) {
-    _classCallCheck(this, NonIsoCalendar);
-    this.helper = e;
-  }
-  _createClass(NonIsoCalendar, [{
-    key: "dateFromFields",
-    value: function dateFromFields(e, t, r) {
-      var o = new OneObjectCache(),
-        n = PrepareTemporalFields(e, this.fields(["day", "month", "monthCode", "year"]), []),
-        a = ToTemporalOverflow(t),
-        _this$helper$calendar = this.helper.calendarToIsoDate(n, a, o),
-        i = _this$helper$calendar.year,
-        s = _this$helper$calendar.month,
-        l = _this$helper$calendar.day,
-        d = CreateTemporalDate(i, s, l, r);
-      return o.setObject(d), d;
-    }
-  }, {
-    key: "yearMonthFromFields",
-    value: function yearMonthFromFields(e, t, r) {
-      var o = new OneObjectCache(),
-        n = PrepareTemporalFields(e, this.fields(["month", "monthCode", "year"]), []),
-        a = ToTemporalOverflow(t),
-        _this$helper$calendar2 = this.helper.calendarToIsoDate(_objectSpread2(_objectSpread2({}, n), {}, {
-          day: 1
-        }), a, o),
-        i = _this$helper$calendar2.year,
-        s = _this$helper$calendar2.month,
-        l = _this$helper$calendar2.day,
-        d = CreateTemporalYearMonth(i, s, r, l);
-      return o.setObject(d), d;
-    }
-  }, {
-    key: "monthDayFromFields",
-    value: function monthDayFromFields(e, t, r) {
-      var o = new OneObjectCache(),
-        n = PrepareTemporalFields(e, this.fields(["day", "month", "monthCode", "year"]), []),
-        a = ToTemporalOverflow(t),
-        _this$helper$monthDay = this.helper.monthDayFromFields(n, a, o),
-        i = _this$helper$monthDay.year,
-        s = _this$helper$monthDay.month,
-        l = _this$helper$monthDay.day,
-        d = CreateTemporalMonthDay(s, l, r, i);
-      return o.setObject(d), d;
-    }
-  }, {
-    key: "fields",
-    value: function fields(e) {
-      var t = e;
-      return Tt.call(t, "year") && (t = [].concat(_toConsumableArray(t), ["era", "eraYear"])), t;
-    }
-  }, {
-    key: "fieldKeysToIgnore",
-    value: function fieldKeysToIgnore(e) {
-      var t = new Dt();
-      for (var _r67 = 0; _r67 < e.length; _r67++) {
-        var _o44 = e[_r67];
-        switch (Call(vt, t, [_o44]), _o44) {
-          case "era":
-            Call(vt, t, ["eraYear"]), Call(vt, t, ["year"]);
-            break;
-          case "eraYear":
-            Call(vt, t, ["era"]), Call(vt, t, ["year"]);
-            break;
-          case "year":
-            Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]);
-            break;
-          case "month":
-            Call(vt, t, ["monthCode"]), this.helper.erasBeginMidYear && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
-            break;
-          case "monthCode":
-            Call(vt, t, ["month"]), this.helper.erasBeginMidYear && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
-            break;
-          case "day":
-            this.helper.erasBeginMidYear && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
-        }
-      }
-      return _toConsumableArray(Call(Ct, t, []));
-    }
-  }, {
-    key: "dateAdd",
-    value: function dateAdd(e, t, r, o, n, a, i) {
-      var s = OneObjectCache.getCacheForObject(e),
-        l = this.helper.temporalToCalendarDate(e, s),
-        d = this.helper.addCalendar(l, {
-          years: t,
-          months: r,
-          weeks: o,
-          days: n
-        }, a, s),
-        m = this.helper.calendarToIsoDate(d, "constrain", s),
-        c = m.year,
-        h = m.month,
-        u = m.day,
-        T = CreateTemporalDate(c, h, u, i);
-      return new OneObjectCache(s).setObject(T), T;
-    }
-  }, {
-    key: "dateUntil",
-    value: function dateUntil(e, t, r) {
-      var o = OneObjectCache.getCacheForObject(e),
-        n = OneObjectCache.getCacheForObject(t),
-        a = this.helper.temporalToCalendarDate(e, o),
-        i = this.helper.temporalToCalendarDate(t, n);
-      return this.helper.untilCalendar(a, i, r, o);
-    }
-  }, {
-    key: "year",
-    value: function year(e) {
-      var t = OneObjectCache.getCacheForObject(e);
-      return this.helper.temporalToCalendarDate(e, t).year;
-    }
-  }, {
-    key: "month",
-    value: function month(e) {
-      var t = OneObjectCache.getCacheForObject(e);
-      return this.helper.temporalToCalendarDate(e, t).month;
-    }
-  }, {
-    key: "day",
-    value: function day(e) {
-      var t = OneObjectCache.getCacheForObject(e);
-      return this.helper.temporalToCalendarDate(e, t).day;
-    }
-  }, {
-    key: "era",
-    value: function era(e) {
-      if (!this.helper.hasEra) return;
-      var t = OneObjectCache.getCacheForObject(e);
-      return this.helper.temporalToCalendarDate(e, t).era;
-    }
-  }, {
-    key: "eraYear",
-    value: function eraYear(e) {
-      if (!this.helper.hasEra) return;
-      var t = OneObjectCache.getCacheForObject(e);
-      return this.helper.temporalToCalendarDate(e, t).eraYear;
-    }
-  }, {
-    key: "monthCode",
-    value: function monthCode(e) {
-      var t = OneObjectCache.getCacheForObject(e);
-      return this.helper.temporalToCalendarDate(e, t).monthCode;
-    }
-  }, {
-    key: "dayOfWeek",
-    value: function dayOfWeek(e) {
-      return Ot.iso8601.dayOfWeek(e);
-    }
-  }, {
-    key: "dayOfYear",
-    value: function dayOfYear(e) {
-      var t = OneObjectCache.getCacheForObject(e),
-        r = this.helper.isoToCalendarDate(e, t),
-        o = this.helper.startOfCalendarYear(r);
-      return this.helper.calendarDaysUntil(o, r, t) + 1;
-    }
-  }, {
-    key: "weekOfYear",
-    value: function weekOfYear(e) {
-      return Ot.iso8601.weekOfYear(e);
-    }
-  }, {
-    key: "yearOfWeek",
-    value: function yearOfWeek(e) {
-      return Ot.iso8601.yearOfWeek(e);
-    }
-  }, {
-    key: "daysInWeek",
-    value: function daysInWeek(e) {
-      return Ot.iso8601.daysInWeek(e);
-    }
-  }, {
-    key: "daysInMonth",
-    value: function daysInMonth(e) {
-      var t = OneObjectCache.getCacheForObject(e),
-        r = this.helper.temporalToCalendarDate(e, t),
-        o = this.helper.maximumMonthLength(r);
-      if (o === this.helper.minimumMonthLength(r)) return o;
-      var n = this.helper.startOfCalendarMonth(r),
-        a = this.helper.addMonthsCalendar(n, 1, "constrain", t);
-      return this.helper.calendarDaysUntil(n, a, t);
-    }
-  }, {
-    key: "daysInYear",
-    value: function daysInYear(e) {
-      var t = e;
-      HasSlot(t, i) || (t = ToTemporalDate(t));
-      var r = OneObjectCache.getCacheForObject(t),
-        o = this.helper.temporalToCalendarDate(t, r),
-        n = this.helper.startOfCalendarYear(o),
-        a = this.helper.addCalendar(n, {
-          years: 1
-        }, "constrain", r);
-      return this.helper.calendarDaysUntil(n, a, r);
-    }
-  }, {
-    key: "monthsInYear",
-    value: function monthsInYear(e) {
-      var t = OneObjectCache.getCacheForObject(e),
-        r = this.helper.temporalToCalendarDate(e, t);
-      return this.helper.monthsInYear(r, t);
-    }
-  }, {
-    key: "inLeapYear",
-    value: function inLeapYear(e) {
-      var t = e;
-      HasSlot(t, i) || (t = ToTemporalDate(t));
-      var r = OneObjectCache.getCacheForObject(t),
-        o = this.helper.temporalToCalendarDate(t, r);
-      return this.helper.inLeapYear(o, r);
-    }
-  }]);
-  return NonIsoCalendar;
-}();
-for (var _i21 = 0, _arr7 = [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]; _i21 < _arr7.length; _i21++) {
-  var _e53 = _arr7[_i21];
-  var _t49 = new _e53();
-  Ot[_t49.id] = new NonIsoCalendar(_t49);
-}
-var PlainDate = /*#__PURE__*/function () {
-  function PlainDate(e, t, r) {
-    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "iso8601";
-    _classCallCheck(this, PlainDate);
-    CreateTemporalDateSlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t), ToIntegerWithTruncation(r), ToTemporalCalendarSlotValue(o));
-  }
-  _createClass(PlainDate, [{
-    key: "calendarId",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarIdentifier(GetSlot(this, p));
-    }
-  }, {
-    key: "era",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarEra(GetSlot(this, p), this);
-    }
-  }, {
-    key: "eraYear",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarEraYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "year",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "month",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarMonth(GetSlot(this, p), this);
-    }
-  }, {
-    key: "monthCode",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthCode(GetSlot(this, p), this);
-    }
-  }, {
-    key: "day",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarDay(GetSlot(this, p), this);
-    }
-  }, {
-    key: "dayOfWeek",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarDayOfWeek(GetSlot(this, p), this);
-    }
-  }, {
-    key: "dayOfYear",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarDayOfYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "weekOfYear",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarWeekOfYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "yearOfWeek",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarYearOfWeek(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInWeek",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInWeek(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInMonth",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInMonth(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInYear",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "monthsInYear",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthsInYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "inLeapYear",
-    get: function get() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return CalendarInLeapYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "with",
-    value: function _with(e, t) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument");
-      RejectTemporalLikeObject(e);
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, p),
-        n = CalendarFields(o, ["day", "month", "monthCode", "year"]);
-      var a = PrepareTemporalFields(this, n, []);
-      return a = CalendarMergeFields(o, a, PrepareTemporalFields(e, n, "partial")), a = PrepareTemporalFields(a, n, []), CalendarDateFromFields(o, a, r);
-    }
-  }, {
-    key: "withCalendar",
-    value: function withCalendar(e) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalCalendarSlotValue(e);
-      return new PlainDate(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t);
-    }
-  }, {
-    key: "add",
-    value: function add(e, t) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var r = ToTemporalDuration(e),
-        o = GetOptionsObject(t);
-      return CalendarDateAdd(GetSlot(this, p), this, r, o);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e, t) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var r = CreateNegatedTemporalDuration(ToTemporalDuration(e)),
-        o = GetOptionsObject(t);
-      return CalendarDateAdd(GetSlot(this, p), this, r, o);
-    }
-  }, {
-    key: "until",
-    value: function until(e, t) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainDate("until", this, e, t);
-    }
-  }, {
-    key: "since",
-    value: function since(e, t) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainDate("since", this, e, t);
-    }
-  }, {
-    key: "equals",
-    value: function equals(e) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e);
-      for (var _i22 = 0, _arr8 = [i, s, l]; _i22 < _arr8.length; _i22++) {
-        var _e54 = _arr8[_i22];
-        if (GetSlot(this, _e54) !== GetSlot(t, _e54)) return !1;
-      }
-      return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+              else if(! e.name)
+               throw new
+                      RangeError
+                      ("If era name is blank, it must be the anchor era");
+             }),
+           r = r.filter(function(e){return e.name;}),
+           r.forEach
+            (function(e){
+              var t = e.reverseOf;
+              if(t){
+               var _o38 = r.find(function(e){return e.name === t;});
+               if(void 0 === _o38)
+                throw new
+                       RangeError
+                       ("Invalid era data: unmatched reverseOf era: ".concat(t));
+               e.reverseOf = _o38,
+               e.anchorEpoch = _o38.anchorEpoch,
+               e.isoEpoch = _o38.isoEpoch;
+              }
+              void 0 === e.anchorEpoch.month && (e.anchorEpoch.month = 1),
+              void 0 === e.anchorEpoch.day && (e.anchorEpoch.day = 1);
+             }),
+           yt.call
+            (r,
+             function(e, t){
+              if(e.reverseOf) return 1;
+              if(t.reverseOf) return - 1;
+              if(! e.isoEpoch || ! t.isoEpoch)
+               throw new RangeError("Invalid era data: missing ISO epoch");
+              return t.isoEpoch.year - e.isoEpoch.year;
+             });
+           var o = r[r.length - 1].reverseOf;
+           if(o && o !== r[r.length - 2])
+            throw new RangeError("Invalid era data: invalid reverse-sign era");
+           return r.forEach
+                   (function(e, t){e.genericName = "era" + (r.length - 1 - t);}),
+                  {eras: r, anchorEra: t || r[0]};
+          }
+          (t),
+       r = _adjustEras.eras,
+       o = _adjustEras.anchorEra;
+      _this13.anchorEra = o, _this13.eras = r;
+      return _this13;
+     }
+     _inherits(GregorianBaseHelper, _HelperBase5);
+     return _createClass
+             (GregorianBaseHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e){
+                 var
+                  _this$estimateIsoDate =
+                    this.estimateIsoDate({month: 1, day: 1, year: e.year}),
+                  t = _this$estimateIsoDate.year;
+                 return isGregorianLeapYear(t);
+                }},
+               {key: "monthsInYear",
+                value: function monthsInYear(){return 12;}},
+               {key: "minimumMonthLength",
+                value:
+                function minimumMonthLength(e){
+                 var t = e.month;
+                 return 2 === t
+                         ? this.inLeapYear(e) ? 29 : 28
+                         : [4, 6, 9, 11].indexOf(t) >= 0 ? 30 : 31;
+                }},
+               {key: "maximumMonthLength",
+                value:
+                function maximumMonthLength(e){
+                 return this.minimumMonthLength(e);
+                }},
+               {key: "completeEraYear",
+                value:
+                function completeEraYear(e){
+                 var _this14 = this, _eraFromYear;
+                 var
+                  checkField =
+                    function checkField(t, r){
+                     var o = e[t];
+                     if(null != o && o != r)
+                      throw new
+                             RangeError
+                             ("Input ".concat(t, " ").concat
+                                (o, " doesn't match calculated value ").concat
+                               (r));
+                    },
+                  eraFromYear =
+                    function eraFromYear(t){
+                     var r;
+                     var
+                      o = _objectSpread2(_objectSpread2({}, e), {}, {year: t}),
+                      n =
+                        _this14.eras.find
+                         (function(e, n){
+                           if(n === _this14.eras.length - 1){
+                            if(e.reverseOf){
+                             if(t > 0)
+                              throw new
+                                     RangeError
+                                     ("Signed year ".concat(t, " is invalid for era ").concat
+                                       (e.name));
+                             return r = e.anchorEpoch.year - t, ! 0;
+                            }
+                            return r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1),
+                                   !
+                                   0;
+                           }
+                           return _this14.compareCalendarDates(o, e.anchorEpoch) >= 0
+                                  &&
+                                   (r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1), ! 0);
+                          });
+                     if(! n)
+                      throw new
+                             RangeError
+                             ("Year ".concat(t, " was not matched by any era"));
+                     return {eraYear: r, era: n.name};
+                    };
+                 var t = e.year, r = e.eraYear, o = e.era;
+                 if(null != t)
+                  _eraFromYear = eraFromYear(t),
+                  r = _eraFromYear.eraYear,
+                  o = _eraFromYear.era,
+                  checkField("era", o),
+                  checkField("eraYear", r);
+                 else{
+                  if(null == r)
+                   throw new
+                          RangeError
+                          ("Either `year` or `eraYear` and `era` are required");
+                  {
+                   var _eraFromYear2;
+                   var
+                    _e48 =
+                      void 0 === o
+                       ? void 0
+                       : this.eras.find
+                         (function(e){return e.name === o || e.genericName === o;});
+                   if(! _e48)
+                    throw new
+                           RangeError
+                           ("Era ".concat(o, " (ISO year ").concat
+                             (r, ") was not matched by any era"));
+                   if(r < 1 && _e48.reverseOf)
+                    throw new
+                           RangeError
+                           ("Years in ".concat(o, " era must be positive, not ").concat
+                             (t));
+                   t =
+                    _e48.reverseOf
+                     ? _e48.anchorEpoch.year - r
+                     : r + _e48.anchorEpoch.year - (_e48.hasYearZero ? 0 : 1),
+                   checkField("year", t),
+                   _eraFromYear2 = eraFromYear(t),
+                   r = _eraFromYear2.eraYear,
+                   o = _eraFromYear2.era;
+                  }
+                 }
+                 return _objectSpread2
+                         (_objectSpread2({}, e), {}, {year: t, eraYear: r, era: o});
+                }},
+               {key: "adjustCalendarDate",
+                value:
+                function adjustCalendarDate(e, t){
+                 var
+                  r =
+                    arguments.length > 2 && arguments[2] !== undefined
+                     ? arguments[2]
+                     : "constrain";
+                 var o = e;
+                 var _o39 = o, n = _o39.month, a = _o39.monthCode;
+                 return void 0 === n
+                        &&
+                         (o =
+                          _objectSpread2
+                           (_objectSpread2({}, o), {}, {month: monthCodeNumberPart(a)})),
+                        this.validateCalendarDate(o),
+                        o = this.completeEraYear(o),
+                        _get
+                          (_getPrototypeOf(GregorianBaseHelper.prototype),
+                           "adjustCalendarDate",
+                           this).call
+                         (this, o, t, r);
+                }},
+               {key: "estimateIsoDate",
+                value:
+                function estimateIsoDate(e){
+                 var
+                  t = this.adjustCalendarDate(e),
+                  r = t.year,
+                  o = t.month,
+                  n = t.day,
+                  a = this.anchorEra;
+                 return RegulateISODate
+                         (r + a.isoEpoch.year - (a.hasYearZero ? 0 : 1),
+                          o,
+                          n,
+                          "constrain");
+                }},
+               {key: "checkIcuBugs",
+                value:
+                function checkIcuBugs(e){
+                 if
+                  (this.calendarIsVulnerableToJulianBug
+                   && this.v8IsVulnerableToJulianBug){
+                  if(CompareISODate(e.year, e.month, e.day, 1582, 10, 15) < 0)
+                   throw new
+                          RangeError
+                          ("calendar '".concat
+                            (this.id,
+                             "' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)"));
+                 }
+                }}]);
+    }
+    (HelperBase);
+var
+ OrthodoxBaseHelper =
+   function(_GregorianBaseHelper){
+     function OrthodoxBaseHelper(e, t){
+      _classCallCheck(this, OrthodoxBaseHelper);
+      return _callSuper(this, OrthodoxBaseHelper, [e, t]);
+     }
+     _inherits(OrthodoxBaseHelper, _GregorianBaseHelper);
+     return _createClass
+             (OrthodoxBaseHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e){
+                 var t = e.year;
+                 return (t + 1) % 4 == 0;
+                }},
+               {key: "monthsInYear",
+                value: function monthsInYear(){return 13;}},
+               {key: "minimumMonthLength",
+                value:
+                function minimumMonthLength(e){
+                 var t = e.month;
+                 return 13 === t ? this.inLeapYear(e) ? 6 : 5 : 30;
+                }},
+               {key: "maximumMonthLength",
+                value:
+                function maximumMonthLength(e){
+                 return this.minimumMonthLength(e);
+                }}]);
+    }
+    (GregorianBaseHelper);
+var
+ EthioaaHelper =
+   function(_OrthodoxBaseHelper){
+     function EthioaaHelper(){
+      _classCallCheck(this, EthioaaHelper);
+      return _callSuper
+              (this,
+               EthioaaHelper,
+               ["ethioaa",
+                [{name: "era0", isoEpoch: {year: - 5492, month: 7, day: 17}}]]);
+     }
+     _inherits(EthioaaHelper, _OrthodoxBaseHelper);
+     return _createClass(EthioaaHelper);
+    }
+    (OrthodoxBaseHelper);
+var
+ CopticHelper =
+   function(_OrthodoxBaseHelper2){
+     function CopticHelper(){
+      _classCallCheck(this, CopticHelper);
+      return _callSuper
+              (this,
+               CopticHelper,
+               ["coptic",
+                [{name: "era1", isoEpoch: {year: 284, month: 8, day: 29}},
+                 {name: "era0", reverseOf: "era1"}]]);
+     }
+     _inherits(CopticHelper, _OrthodoxBaseHelper2);
+     return _createClass(CopticHelper);
+    }
+    (OrthodoxBaseHelper);
+var
+ EthiopicHelper =
+   function(_OrthodoxBaseHelper3){
+     function EthiopicHelper(){
+      _classCallCheck(this, EthiopicHelper);
+      return _callSuper
+              (this,
+               EthiopicHelper,
+               ["ethiopic",
+                [{name: "era0", isoEpoch: {year: - 5492, month: 7, day: 17}},
+                 {name: "era1",
+                  isoEpoch: {year: 8, month: 8, day: 27},
+                  anchorEpoch: {year: 5501}}]]);
+     }
+     _inherits(EthiopicHelper, _OrthodoxBaseHelper3);
+     return _createClass(EthiopicHelper);
+    }
+    (OrthodoxBaseHelper);
+var
+ RocHelper =
+   function(_GregorianBaseHelper2){
+     function RocHelper(){
+      var _this15;
+      _classCallCheck(this, RocHelper);
+      _this15 =
+       _callSuper
+        (this,
+         RocHelper,
+         ["roc",
+          [{name: "minguo", isoEpoch: {year: 1912, month: 1, day: 1}},
+           {name: "before-roc", reverseOf: "minguo"}]]),
+      _this15.calendarIsVulnerableToJulianBug = ! 0;
+      return _this15;
+     }
+     _inherits(RocHelper, _GregorianBaseHelper2);
+     return _createClass(RocHelper);
+    }
+    (GregorianBaseHelper);
+var
+ BuddhistHelper =
+   function(_GregorianBaseHelper3){
+     function BuddhistHelper(){
+      var _this16;
+      _classCallCheck(this, BuddhistHelper);
+      _this16 =
+       _callSuper
+        (this,
+         BuddhistHelper,
+         ["buddhist",
+          [{name: "be",
+            hasYearZero: ! 0,
+            isoEpoch: {year: - 543, month: 1, day: 1}}]]),
+      _this16.calendarIsVulnerableToJulianBug = ! 0;
+      return _this16;
+     }
+     _inherits(BuddhistHelper, _GregorianBaseHelper3);
+     return _createClass(BuddhistHelper);
+    }
+    (GregorianBaseHelper);
+var
+ GregoryHelper =
+   function(_GregorianBaseHelper4){
+     function GregoryHelper(){
+      _classCallCheck(this, GregoryHelper);
+      return _callSuper
+              (this,
+               GregoryHelper,
+               ["gregory",
+                [{name: "ce", isoEpoch: {year: 1, month: 1, day: 1}},
+                 {name: "bce", reverseOf: "ce"}]]);
+     }
+     _inherits(GregoryHelper, _GregorianBaseHelper4);
+     return _createClass
+             (GregoryHelper,
+              [{key: "reviseIntlEra",
+                value:
+                function reviseIntlEra(e){
+                 var t = e.era, r = e.eraYear;
+                 return "bc" !== t && "b" !== t || (t = "bce"),
+                        "ad" !== t && "a" !== t || (t = "ce"),
+                        {era: t, eraYear: r};
+                }}]);
+    }
+    (GregorianBaseHelper);
+var
+ JapaneseHelper =
+   function(_GregorianBaseHelper5){
+     function JapaneseHelper(){
+      var _this17;
+      _classCallCheck(this, JapaneseHelper);
+      _this17 =
+       _callSuper
+        (this,
+         JapaneseHelper,
+         ["japanese",
+          [{name: "reiwa",
+            isoEpoch: {year: 2019, month: 5, day: 1},
+            anchorEpoch: {year: 2019, month: 5, day: 1}},
+           {name: "heisei",
+            isoEpoch: {year: 1989, month: 1, day: 8},
+            anchorEpoch: {year: 1989, month: 1, day: 8}},
+           {name: "showa",
+            isoEpoch: {year: 1926, month: 12, day: 25},
+            anchorEpoch: {year: 1926, month: 12, day: 25}},
+           {name: "taisho",
+            isoEpoch: {year: 1912, month: 7, day: 30},
+            anchorEpoch: {year: 1912, month: 7, day: 30}},
+           {name: "meiji",
+            isoEpoch: {year: 1868, month: 9, day: 8},
+            anchorEpoch: {year: 1868, month: 9, day: 8}},
+           {name: "ce", isoEpoch: {year: 1, month: 1, day: 1}},
+           {name: "bce", reverseOf: "ce"}]]),
+      _this17.calendarIsVulnerableToJulianBug = ! 0,
+      _this17.eraLength = "long",
+      _this17.erasBeginMidYear = ! 0;
+      return _this17;
+     }
+     _inherits(JapaneseHelper, _GregorianBaseHelper5);
+     return _createClass
+             (JapaneseHelper,
+              [{key: "reviseIntlEra",
+                value:
+                function reviseIntlEra(e, t){
+                 var r = e.era, o = e.eraYear, n = t.year;
+                 return this.eras.find(function(e){return e.name === r;})
+                         ? {era: r, eraYear: o}
+                         : n
+                           < 1
+                           ? {era: "bce", eraYear: 1 - n}
+                           : {era: "ce", eraYear: n};
+                }}]);
+    }
+    (GregorianBaseHelper);
+var
+ ChineseBaseHelper =
+   function(_HelperBase6){
+     function ChineseBaseHelper(){
+      var _this18;
+      _classCallCheck(this, ChineseBaseHelper);
+      _this18 = _callSuper(this, ChineseBaseHelper, arguments),
+      _this18.calendarType = "lunisolar",
+      _this18.hasEra = ! 1;
+      return _this18;
+     }
+     _inherits(ChineseBaseHelper, _HelperBase6);
+     return _createClass
+             (ChineseBaseHelper,
+              [{key: "inLeapYear",
+                value:
+                function inLeapYear(e, t){
+                 var r = this.getMonthList(e.year, t);
+                 return 13 === wt(r).length;
+                }},
+               {key: "monthsInYear",
+                value:
+                function monthsInYear(e, t){
+                 return this.inLeapYear(e, t) ? 13 : 12;
+                }},
+               {key: "minimumMonthLength",
+                value: function minimumMonthLength(){return 29;}},
+               {key: "maximumMonthLength",
+                value: function maximumMonthLength(){return 30;}},
+               {key: "getMonthList",
+                value:
+                function getMonthList(e, t){
+                 var _this19 = this, _getCalendarDate2;
+                 if(void 0 === e) throw new TypeError("Missing year");
+                 var
+                  r =
+                    JSON.stringify
+                     ({func: "getMonthList", calendarYear: e, id: this.id}),
+                  o = t.get(r);
+                 if(o) return o;
+                 var
+                  n = this.getFormatter(),
+                  getCalendarDate =
+                    function getCalendarDate(e, t){
+                     var
+                      r = toUtcIsoDateString({isoYear: e, isoMonth: 2, isoDay: 1}),
+                      o = new Date(r);
+                     o.setUTCDate(t + 1);
+                     var
+                      a = n.formatToParts(o),
+                      i = a.find(function(e){return "month" === e.type;}).value,
+                      s = + a.find(function(e){return "day" === e.type;}).value;
+                     var
+                      l = a.find(function(e){return "relatedYear" === e.type;});
+                     if(void 0 === l)
+                      throw new
+                             RangeError
+                             ("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat
+                               (_this19.id, " calendar. Try Node 14+ or modern browsers."));
+                     return l = + l.value,
+                            {calendarMonthString: i,
+                             calendarDay: s,
+                             calendarYearToVerify: l};
+                    };
+                 var
+                  a = 17,
+                  _getCalendarDate = getCalendarDate(e, a),
+                  i = _getCalendarDate.calendarMonthString,
+                  s = _getCalendarDate.calendarDay,
+                  l = _getCalendarDate.calendarYearToVerify;
+                 "1" !== i
+                 &&
+                  (a += 29,
+                   _getCalendarDate2 = getCalendarDate(e, a),
+                   i = _getCalendarDate2.calendarMonthString,
+                   s = _getCalendarDate2.calendarDay),
+                 a -= s - 5;
+                 var d = {};
+                 var m, c, h = 1, u = ! 1;
+                 do{
+                  var _getCalendarDate3;
+                  _getCalendarDate3 = getCalendarDate(e, a),
+                  i = _getCalendarDate3.calendarMonthString,
+                  s = _getCalendarDate3.calendarDay,
+                  l = _getCalendarDate3.calendarYearToVerify,
+                  m && (d[c].daysInMonth = m + 30 - s),
+                  l !== e ? u = ! 0 : (d[i] = {monthIndex: h++}, a += 30),
+                  m = s,
+                  c = i;
+                 }
+                 while
+                  (! u);
+                 return d[c].daysInMonth = m + 30 - s, t.set(r, d), d;
+                }},
+               {key: "estimateIsoDate",
+                value:
+                function estimateIsoDate(e){
+                 var t = e.year, r = e.month;
+                 return {year: t, month: r >= 12 ? 12 : r + 1, day: 1};
+                }},
+               {key: "adjustCalendarDate",
+                value:
+                function adjustCalendarDate(e, t){
+                 var
+                  r =
+                    arguments.length > 2 && arguments[2] !== undefined
+                     ? arguments[2]
+                     : "constrain";
+                 var
+                  o =
+                    arguments.length > 3 && arguments[3] !== undefined
+                     ? arguments[3]
+                     : ! 1;
+                 var
+                  n = e.year,
+                  a = e.month,
+                  i = e.monthExtra,
+                  s = e.day,
+                  l = e.monthCode,
+                  d = e.eraYear;
+                 if(o){
+                  if(n = d, i && "bis" !== i)
+                   throw new
+                          RangeError
+                          ("Unexpected leap month suffix: ".concat(i));
+                  var
+                   _e49 = buildMonthCode(a, void 0 !== i),
+                   _r65 = "".concat(a).concat(i || ""),
+                   _o40 = this.getMonthList(n, t)[_r65];
+                  if(void 0 === _o40)
+                   throw new
+                          RangeError
+                          ("Unmatched month ".concat(_r65, " in Chinese year ").concat
+                            (n));
+                  return a = _o40.monthIndex,
+                         {year: n,
+                          month: a,
+                          day: s,
+                          era: void 0,
+                          eraYear: d,
+                          monthCode: _e49};
+                 }
+                 if
+                  (this.validateCalendarDate(e),
+                   void 0 === n && (n = d),
+                   void 0 === d && (d = n),
+                   void 0 === a){
+                  var _e50 = this.getMonthList(n, t);
+                  var _o41 = l.replace("L", "bis").slice(1);
+                  "0" === _o41[0] && (_o41 = _o41.slice(1));
+                  var _i19 = _e50[_o41];
+                  if
+                   (a = _i19 && _i19.monthIndex,
+                    void 0 === a && l.endsWith("L") && "M13L" != l
+                    && "constrain" === r){
+                   var _t48 = l.slice(1, - 1);
+                   "0" === _t48[0] && (_t48 = _t48.slice(1)),
+                   _i19 = _e50[_t48],
+                   _i19 && (a = _i19.monthIndex, l = buildMonthCode(_t48));
+                  }
+                  if(void 0 === a)
+                   throw new
+                          RangeError
+                          ("Unmatched month ".concat(l, " in Chinese year ").concat(n));
+                 }
+                 else if(void 0 === l){
+                  var
+                   _e51 = this.getMonthList(n, t),
+                   _o42 = wt(_e51),
+                   _i20 = _o42.length;
+                  "reject" === r
+                   ? (RejectToRange
+                      (a, 1, _i20),
+                     RejectToRange(s, 1, this.maximumMonthLength()))
+                   : (a
+                     = ConstrainToRange(a, 1, _i20),
+                     s = ConstrainToRange(s, 1, this.maximumMonthLength()));
+                  var
+                   _d11 =
+                     _o42.find
+                      (function(_ref10){
+                        var _ref11 = _slicedToArray(_ref10, 2), e = _ref11[1];
+                        return e.monthIndex === a;
+                       });
+                  if(void 0 === _d11)
+                   throw new
+                          RangeError
+                          ("Invalid month ".concat(a, " in Chinese year ").concat(n));
+                  l =
+                   buildMonthCode
+                    (_d11[0].replace("bis", ""), - 1 !== _d11[0].indexOf("bis"));
+                 }
+                 else{
+                  var _e52 = this.getMonthList(n, t);
+                  var _r66 = l.replace("L", "bis").slice(1);
+                  "0" === _r66[0] && (_r66 = _r66.slice(1));
+                  var _o43 = _e52[_r66];
+                  if(! _o43)
+                   throw new
+                          RangeError
+                          ("Unmatched monthCode ".concat(l, " in Chinese year ").concat
+                            (n));
+                  if(a !== _o43.monthIndex)
+                   throw new
+                          RangeError
+                          ("monthCode ".concat(l, " doesn't correspond to month ").concat
+                             (a, " in Chinese year ").concat
+                            (n));
+                 }
+                 return _objectSpread2
+                         (_objectSpread2({}, e),
+                          {},
+                          {year: n, eraYear: d, month: a, monthCode: l, day: s});
+                }}]);
+    }
+    (HelperBase);
+var
+ ChineseHelper =
+   function(_ChineseBaseHelper){
+     function ChineseHelper(){
+      var _this20;
+      _classCallCheck(this, ChineseHelper);
+      _this20 = _callSuper(this, ChineseHelper, arguments),
+      _this20.id = "chinese";
+      return _this20;
+     }
+     _inherits(ChineseHelper, _ChineseBaseHelper);
+     return _createClass(ChineseHelper);
+    }
+    (ChineseBaseHelper);
+var
+ DangiHelper =
+   function(_ChineseBaseHelper2){
+     function DangiHelper(){
+      var _this21;
+      _classCallCheck(this, DangiHelper);
+      _this21 = _callSuper(this, DangiHelper, arguments),
+      _this21.id = "dangi";
+      return _this21;
+     }
+     _inherits(DangiHelper, _ChineseBaseHelper2);
+     return _createClass(DangiHelper);
+    }
+    (ChineseBaseHelper);
+var
+ NonIsoCalendar =
+   function(){
+     function NonIsoCalendar(e){
+      _classCallCheck(this, NonIsoCalendar);
+      this.helper = e;
+     }
+     return _createClass
+             (NonIsoCalendar,
+              [{key: "dateFromFields",
+                value:
+                function dateFromFields(e, t, r){
+                 var
+                  o = new OneObjectCache(),
+                  n =
+                    PrepareTemporalFields
+                     (e, this.fields(["day", "month", "monthCode", "year"]), []),
+                  a = ToTemporalOverflow(t),
+                  _this$helper$calendar =
+                    this.helper.calendarToIsoDate(n, a, o),
+                  i = _this$helper$calendar.year,
+                  s = _this$helper$calendar.month,
+                  l = _this$helper$calendar.day,
+                  d = CreateTemporalDate(i, s, l, r);
+                 return o.setObject(d), d;
+                }},
+               {key: "yearMonthFromFields",
+                value:
+                function yearMonthFromFields(e, t, r){
+                 var
+                  o = new OneObjectCache(),
+                  n =
+                    PrepareTemporalFields
+                     (e, this.fields(["month", "monthCode", "year"]), []),
+                  a = ToTemporalOverflow(t),
+                  _this$helper$calendar2 =
+                    this.helper.calendarToIsoDate
+                     (_objectSpread2(_objectSpread2({}, n), {}, {day: 1}), a, o),
+                  i = _this$helper$calendar2.year,
+                  s = _this$helper$calendar2.month,
+                  l = _this$helper$calendar2.day,
+                  d = CreateTemporalYearMonth(i, s, r, l);
+                 return o.setObject(d), d;
+                }},
+               {key: "monthDayFromFields",
+                value:
+                function monthDayFromFields(e, t, r){
+                 var
+                  o = new OneObjectCache(),
+                  n =
+                    PrepareTemporalFields
+                     (e, this.fields(["day", "month", "monthCode", "year"]), []),
+                  a = ToTemporalOverflow(t),
+                  _this$helper$monthDay =
+                    this.helper.monthDayFromFields(n, a, o),
+                  i = _this$helper$monthDay.year,
+                  s = _this$helper$monthDay.month,
+                  l = _this$helper$monthDay.day,
+                  d = CreateTemporalMonthDay(s, l, r, i);
+                 return o.setObject(d), d;
+                }},
+               {key: "fields",
+                value:
+                function fields(e){
+                 var t = e;
+                 return Tt.call(t, "year")
+                        &&
+                         (t = [].concat(_toConsumableArray(t), ["era", "eraYear"])),
+                        t;
+                }},
+               {key: "fieldKeysToIgnore",
+                value:
+                function fieldKeysToIgnore(e){
+                 var t = new Dt();
+                 for(var _r67 = 0; _r67 < e.length; _r67++){
+                  var _o44 = e[_r67];
+                  switch(Call(vt, t, [_o44]), _o44){
+                    case "era":
+                     Call(vt, t, ["eraYear"]), Call(vt, t, ["year"]); break;
+                    case "eraYear":
+                     Call(vt, t, ["era"]), Call(vt, t, ["year"]); break;
+                    case "year":
+                     Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]); break;
+                    case "month":
+                     Call(vt, t, ["monthCode"]),
+                     this.helper.erasBeginMidYear
+                     && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
+                     break;
+                    case "monthCode":
+                     Call(vt, t, ["month"]),
+                     this.helper.erasBeginMidYear
+                     && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
+                     break;
+                    case "day":
+                     this.helper.erasBeginMidYear
+                     && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
+                  }
+                 }
+                 return _toConsumableArray(Call(Ct, t, []));
+                }},
+               {key: "dateAdd",
+                value:
+                function dateAdd(e, t, r, o, n, a, i){
+                 var
+                  s = OneObjectCache.getCacheForObject(e),
+                  l = this.helper.temporalToCalendarDate(e, s),
+                  d =
+                    this.helper.addCalendar
+                     (l, {years: t, months: r, weeks: o, days: n}, a, s),
+                  m = this.helper.calendarToIsoDate(d, "constrain", s),
+                  c = m.year,
+                  h = m.month,
+                  u = m.day,
+                  T = CreateTemporalDate(c, h, u, i);
+                 return new OneObjectCache(s).setObject(T), T;
+                }},
+               {key: "dateUntil",
+                value:
+                function dateUntil(e, t, r){
+                 var
+                  o = OneObjectCache.getCacheForObject(e),
+                  n = OneObjectCache.getCacheForObject(t),
+                  a = this.helper.temporalToCalendarDate(e, o),
+                  i = this.helper.temporalToCalendarDate(t, n);
+                 return this.helper.untilCalendar(a, i, r, o);
+                }},
+               {key: "year",
+                value:
+                function year(e){
+                 var t = OneObjectCache.getCacheForObject(e);
+                 return this.helper.temporalToCalendarDate(e, t).year;
+                }},
+               {key: "month",
+                value:
+                function month(e){
+                 var t = OneObjectCache.getCacheForObject(e);
+                 return this.helper.temporalToCalendarDate(e, t).month;
+                }},
+               {key: "day",
+                value:
+                function day(e){
+                 var t = OneObjectCache.getCacheForObject(e);
+                 return this.helper.temporalToCalendarDate(e, t).day;
+                }},
+               {key: "era",
+                value:
+                function era(e){
+                 if(! this.helper.hasEra) return;
+                 var t = OneObjectCache.getCacheForObject(e);
+                 return this.helper.temporalToCalendarDate(e, t).era;
+                }},
+               {key: "eraYear",
+                value:
+                function eraYear(e){
+                 if(! this.helper.hasEra) return;
+                 var t = OneObjectCache.getCacheForObject(e);
+                 return this.helper.temporalToCalendarDate(e, t).eraYear;
+                }},
+               {key: "monthCode",
+                value:
+                function monthCode(e){
+                 var t = OneObjectCache.getCacheForObject(e);
+                 return this.helper.temporalToCalendarDate(e, t).monthCode;
+                }},
+               {key: "dayOfWeek",
+                value: function dayOfWeek(e){return Ot.iso8601.dayOfWeek(e);}},
+               {key: "dayOfYear",
+                value:
+                function dayOfYear(e){
+                 var
+                  t = OneObjectCache.getCacheForObject(e),
+                  r = this.helper.isoToCalendarDate(e, t),
+                  o = this.helper.startOfCalendarYear(r);
+                 return this.helper.calendarDaysUntil(o, r, t) + 1;
+                }},
+               {key: "weekOfYear",
+                value:
+                function weekOfYear(e){return Ot.iso8601.weekOfYear(e);}},
+               {key: "yearOfWeek",
+                value:
+                function yearOfWeek(e){return Ot.iso8601.yearOfWeek(e);}},
+               {key: "daysInWeek",
+                value:
+                function daysInWeek(e){return Ot.iso8601.daysInWeek(e);}},
+               {key: "daysInMonth",
+                value:
+                function daysInMonth(e){
+                 var
+                  t = OneObjectCache.getCacheForObject(e),
+                  r = this.helper.temporalToCalendarDate(e, t),
+                  o = this.helper.maximumMonthLength(r);
+                 if(o === this.helper.minimumMonthLength(r)) return o;
+                 var
+                  n = this.helper.startOfCalendarMonth(r),
+                  a = this.helper.addMonthsCalendar(n, 1, "constrain", t);
+                 return this.helper.calendarDaysUntil(n, a, t);
+                }},
+               {key: "daysInYear",
+                value:
+                function daysInYear(e){
+                 var t = e;
+                 HasSlot(t, i) || (t = ToTemporalDate(t));
+                 var
+                  r = OneObjectCache.getCacheForObject(t),
+                  o = this.helper.temporalToCalendarDate(t, r),
+                  n = this.helper.startOfCalendarYear(o),
+                  a = this.helper.addCalendar(n, {years: 1}, "constrain", r);
+                 return this.helper.calendarDaysUntil(n, a, r);
+                }},
+               {key: "monthsInYear",
+                value:
+                function monthsInYear(e){
+                 var
+                  t = OneObjectCache.getCacheForObject(e),
+                  r = this.helper.temporalToCalendarDate(e, t);
+                 return this.helper.monthsInYear(r, t);
+                }},
+               {key: "inLeapYear",
+                value:
+                function inLeapYear(e){
+                 var t = e;
+                 HasSlot(t, i) || (t = ToTemporalDate(t));
+                 var
+                  r = OneObjectCache.getCacheForObject(t),
+                  o = this.helper.temporalToCalendarDate(t, r);
+                 return this.helper.inLeapYear(o, r);
+                }}]);
+    }
+    ();
+for
+(var
+  _i21 = 0,
+  _arr7 =
+    [HebrewHelper,
+     PersianHelper,
+     EthiopicHelper,
+     EthioaaHelper,
+     CopticHelper,
+     ChineseHelper,
+     DangiHelper,
+     RocHelper,
+     IndianHelper,
+     BuddhistHelper,
+     GregoryHelper,
+     JapaneseHelper,
+     IslamicHelper,
+     IslamicUmalquraHelper,
+     IslamicTblaHelper,
+     IslamicCivilHelper,
+     IslamicRgsaHelper,
+     IslamicCcHelper];
+ _i21 < _arr7.length;
+ _i21++){
+ var _e53 = _arr7[_i21];
+ var _t49 = new _e53();
+ Ot[_t49.id] = new NonIsoCalendar(_t49);
+}
+var
+ PlainDate =
+   function(){
+     function PlainDate(e, t, r){
+      var
+       o =
+         arguments.length > 3 && arguments[3] !== undefined
+          ? arguments[3]
+          : "iso8601";
+      _classCallCheck(this, PlainDate);
+      CreateTemporalDateSlots
+       (this,
+        ToIntegerWithTruncation(e),
+        ToIntegerWithTruncation(t),
+        ToIntegerWithTruncation(r),
+        ToTemporalCalendarSlotValue(o));
+     }
+     return _createClass
+             (PlainDate,
+              [{key: "calendarId",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarIdentifier(GetSlot(this, p));
+                }},
+               {key: "era",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEra(GetSlot(this, p), this);
+                }},
+               {key: "eraYear",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEraYear(GetSlot(this, p), this);
+                }},
+               {key: "year",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYear(GetSlot(this, p), this);
+                }},
+               {key: "month",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonth(GetSlot(this, p), this);
+                }},
+               {key: "monthCode",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthCode(GetSlot(this, p), this);
+                }},
+               {key: "day",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDay(GetSlot(this, p), this);
+                }},
+               {key: "dayOfWeek",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDayOfWeek(GetSlot(this, p), this);
+                }},
+               {key: "dayOfYear",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDayOfYear(GetSlot(this, p), this);
+                }},
+               {key: "weekOfYear",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarWeekOfYear(GetSlot(this, p), this);
+                }},
+               {key: "yearOfWeek",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYearOfWeek(GetSlot(this, p), this);
+                }},
+               {key: "daysInWeek",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInWeek(GetSlot(this, p), this);
+                }},
+               {key: "daysInMonth",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInMonth(GetSlot(this, p), this);
+                }},
+               {key: "daysInYear",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInYear(GetSlot(this, p), this);
+                }},
+               {key: "monthsInYear",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthsInYear(GetSlot(this, p), this);
+                }},
+               {key: "inLeapYear",
+                get:
+                function get(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarInLeapYear(GetSlot(this, p), this);
+                }},
+               {key: "with",
+                value:
+                function _with(e, t){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid argument");
+                 RejectTemporalLikeObject(e);
+                 var
+                  r = GetOptionsObject(t),
+                  o = GetSlot(this, p),
+                  n = CalendarFields(o, ["day", "month", "monthCode", "year"]);
+                 var a = PrepareTemporalFields(this, n, []);
+                 return a =
+                         CalendarMergeFields
+                          (o, a, PrepareTemporalFields(e, n, "partial")),
+                        a = PrepareTemporalFields(a, n, []),
+                        CalendarDateFromFields(o, a, r);
+                }},
+               {key: "withCalendar",
+                value:
+                function withCalendar(e){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalCalendarSlotValue(e);
+                 return new
+                         PlainDate
+                         (GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t);
+                }},
+               {key: "add",
+                value:
+                function add(e, t){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var r = ToTemporalDuration(e), o = GetOptionsObject(t);
+                 return CalendarDateAdd(GetSlot(this, p), this, r, o);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e, t){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  r = CreateNegatedTemporalDuration(ToTemporalDuration(e)),
+                  o = GetOptionsObject(t);
+                 return CalendarDateAdd(GetSlot(this, p), this, r, o);
+                }},
+               {key: "until",
+                value:
+                function until(e, t){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainDate("until", this, e, t);
+                }},
+               {key: "since",
+                value:
+                function since(e, t){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainDate("since", this, e, t);
+                }},
+               {key: "equals",
+                value:
+                function equals(e){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDate(e);
+                 for
+                 (var _i22 = 0, _arr8 = [i, s, l];
+                  _i22 < _arr8.length;
+                  _i22++){
+                  var _e54 = _arr8[_i22];
+                  if(GetSlot(this, _e54) !== GetSlot(t, _e54)) return ! 1;
+                 }
+                 return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateToString
+                         (this, ToCalendarNameOption(GetOptionsObject(e)));
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateToString(this);
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return new ht(e, t).format(this);
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() or equals() to compare Temporal.PlainDate");
+                }},
+               {key: "toPlainDateTime",
+                value:
+                function toPlainDateTime(e){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetSlot(this, i),
+                  r = GetSlot(this, s),
+                  o = GetSlot(this, l),
+                  n = GetSlot(this, p);
+                 if(void 0 === e)
+                  return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
+                 var a = ToTemporalTime(e);
+                 return CreateTemporalDateTime
+                         (t,
+                          r,
+                          o,
+                          GetSlot(a, d),
+                          GetSlot(a, m),
+                          GetSlot(a, c),
+                          GetSlot(a, h),
+                          GetSlot(a, u),
+                          GetSlot(a, T),
+                          n);
+                }},
+               {key: "toZonedDateTime",
+                value:
+                function toZonedDateTime(e){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var t, r;
+                 if(IsObject(e)){
+                  if(IsTemporalTimeZone(e))
+                   t = e;
+                  else{
+                   var _o45 = e.timeZone;
+                   void 0 === _o45
+                    ? t = ToTemporalTimeZoneSlotValue(e)
+                    : (t = ToTemporalTimeZoneSlotValue(_o45), r = e.plainTime);
+                  }
+                 }
+                 else
+                  t = ToTemporalTimeZoneSlotValue(e);
+                 var
+                  o = GetSlot(this, i),
+                  a = GetSlot(this, s),
+                  f = GetSlot(this, l),
+                  y = GetSlot(this, p);
+                 var I = 0, S = 0, g = 0, w = 0, D = 0, G = 0;
+                 void 0 !== r
+                 &&
+                  (r = ToTemporalTime(r),
+                   I = GetSlot(r, d),
+                   S = GetSlot(r, m),
+                   g = GetSlot(r, c),
+                   w = GetSlot(r, h),
+                   D = GetSlot(r, u),
+                   G = GetSlot(r, T));
+                 return CreateTemporalZonedDateTime
+                         (GetSlot
+                           (GetInstantFor
+                             (t,
+                              CreateTemporalDateTime(o, a, f, I, S, g, w, D, G, y),
+                              "compatible"),
+                            n),
+                          t,
+                          y);
+                }},
+               {key: "toPlainYearMonth",
+                value:
+                function toPlainYearMonth(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var e = GetSlot(this, p);
+                 return CalendarYearMonthFromFields
+                         (e,
+                          PrepareTemporalFields
+                           (this, CalendarFields(e, ["monthCode", "year"]), []));
+                }},
+               {key: "toPlainMonthDay",
+                value:
+                function toPlainMonthDay(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 var e = GetSlot(this, p);
+                 return CalendarMonthDayFromFields
+                         (e,
+                          PrepareTemporalFields
+                           (this, CalendarFields(e, ["day", "monthCode"]), []));
+                }},
+               {key: "getISOFields",
+                value:
+                function getISOFields(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return {calendar: GetSlot(this, p),
+                         isoDay: GetSlot(this, l),
+                         isoMonth: GetSlot(this, s),
+                         isoYear: GetSlot(this, i)};
+                }},
+               {key: "getCalendar",
+                value:
+                function getCalendar(){
+                 if(! IsTemporalDate(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarObject(GetSlot(this, p));
+                }}],
+              [{key: "from",
+                value:
+                function from(e, t){
+                 var r = GetOptionsObject(t);
+                 return IsTemporalDate(e)
+                         ? (ToTemporalOverflow
+                            (r),
+                           CreateTemporalDate
+                            (GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p)))
+                         : ToTemporalDate(e, r);
+                }},
+               {key: "compare",
+                value:
+                function compare(e, t){
+                 var r = ToTemporalDate(e), o = ToTemporalDate(t);
+                 return CompareISODate
+                         (GetSlot(r, i),
+                          GetSlot(r, s),
+                          GetSlot(r, l),
+                          GetSlot(o, i),
+                          GetSlot(o, s),
+                          GetSlot(o, l));
+                }}]);
     }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return TemporalDateToString(this, ToCalendarNameOption(GetOptionsObject(e)));
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return TemporalDateToString(this);
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return new ht(e, t).format(this);
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
-    }
-  }, {
-    key: "toPlainDateTime",
-    value: function toPlainDateTime(e) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var t = GetSlot(this, i),
-        r = GetSlot(this, s),
-        o = GetSlot(this, l),
-        n = GetSlot(this, p);
-      if (void 0 === e) return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
-      var a = ToTemporalTime(e);
-      return CreateTemporalDateTime(t, r, o, GetSlot(a, d), GetSlot(a, m), GetSlot(a, c), GetSlot(a, h), GetSlot(a, u), GetSlot(a, T), n);
-    }
-  }, {
-    key: "toZonedDateTime",
-    value: function toZonedDateTime(e) {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var t, r;
-      if (IsObject(e)) {
-        if (IsTemporalTimeZone(e)) t = e;else {
-          var _o45 = e.timeZone;
-          void 0 === _o45 ? t = ToTemporalTimeZoneSlotValue(e) : (t = ToTemporalTimeZoneSlotValue(_o45), r = e.plainTime);
-        }
-      } else t = ToTemporalTimeZoneSlotValue(e);
-      var o = GetSlot(this, i),
-        a = GetSlot(this, s),
-        f = GetSlot(this, l),
-        y = GetSlot(this, p);
-      var I = 0,
-        S = 0,
-        g = 0,
-        w = 0,
-        D = 0,
-        G = 0;
-      void 0 !== r && (r = ToTemporalTime(r), I = GetSlot(r, d), S = GetSlot(r, m), g = GetSlot(r, c), w = GetSlot(r, h), D = GetSlot(r, u), G = GetSlot(r, T));
-      return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(t, CreateTemporalDateTime(o, a, f, I, S, g, w, D, G, y), "compatible"), n), t, y);
-    }
-  }, {
-    key: "toPlainYearMonth",
-    value: function toPlainYearMonth() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var e = GetSlot(this, p);
-      return CalendarYearMonthFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["monthCode", "year"]), []));
-    }
-  }, {
-    key: "toPlainMonthDay",
-    value: function toPlainMonthDay() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      var e = GetSlot(this, p);
-      return CalendarMonthDayFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["day", "monthCode"]), []));
-    }
-  }, {
-    key: "getISOFields",
-    value: function getISOFields() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return {
-        calendar: GetSlot(this, p),
-        isoDay: GetSlot(this, l),
-        isoMonth: GetSlot(this, s),
-        isoYear: GetSlot(this, i)
-      };
-    }
-  }, {
-    key: "getCalendar",
-    value: function getCalendar() {
-      if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarObject(GetSlot(this, p));
-    }
-  }], [{
-    key: "from",
-    value: function from(e, t) {
-      var r = GetOptionsObject(t);
-      return IsTemporalDate(e) ? (ToTemporalOverflow(r), CreateTemporalDate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p))) : ToTemporalDate(e, r);
-    }
-  }, {
-    key: "compare",
-    value: function compare(e, t) {
-      var r = ToTemporalDate(e),
-        o = ToTemporalDate(t);
-      return CompareISODate(GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(o, i), GetSlot(o, s), GetSlot(o, l));
-    }
-  }]);
-  return PlainDate;
-}();
+    ();
 MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
-var PlainDateTime = /*#__PURE__*/function () {
-  function PlainDateTime(e, t, r) {
-    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
-    var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
-    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
-    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
-    var s = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
-    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
-    var d = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : "iso8601";
-    _classCallCheck(this, PlainDateTime);
-    CreateTemporalDateTimeSlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t), ToIntegerWithTruncation(r), void 0 === o ? 0 : ToIntegerWithTruncation(o), void 0 === n ? 0 : ToIntegerWithTruncation(n), void 0 === a ? 0 : ToIntegerWithTruncation(a), void 0 === i ? 0 : ToIntegerWithTruncation(i), void 0 === s ? 0 : ToIntegerWithTruncation(s), void 0 === l ? 0 : ToIntegerWithTruncation(l), ToTemporalCalendarSlotValue(d));
-  }
-  _createClass(PlainDateTime, [{
-    key: "calendarId",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarIdentifier(GetSlot(this, p));
-    }
-  }, {
-    key: "year",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "month",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarMonth(GetSlot(this, p), this);
-    }
-  }, {
-    key: "monthCode",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthCode(GetSlot(this, p), this);
-    }
-  }, {
-    key: "day",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDay(GetSlot(this, p), this);
-    }
-  }, {
-    key: "hour",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, d);
-    }
-  }, {
-    key: "minute",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, m);
-    }
-  }, {
-    key: "second",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, c);
-    }
-  }, {
-    key: "millisecond",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, h);
-    }
-  }, {
-    key: "microsecond",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, u);
-    }
-  }, {
-    key: "nanosecond",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, T);
-    }
-  }, {
-    key: "era",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarEra(GetSlot(this, p), this);
-    }
-  }, {
-    key: "eraYear",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarEraYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "dayOfWeek",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDayOfWeek(GetSlot(this, p), this);
-    }
-  }, {
-    key: "dayOfYear",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDayOfYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "weekOfYear",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarWeekOfYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "yearOfWeek",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarYearOfWeek(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInWeek",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInWeek(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInYear",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInMonth",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInMonth(GetSlot(this, p), this);
-    }
-  }, {
-    key: "monthsInYear",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthsInYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "inLeapYear",
-    get: function get() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarInLeapYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "with",
-    value: function _with(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument");
-      RejectTemporalLikeObject(e);
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, p),
-        n = CalendarFields(o, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
-      var a = PrepareTemporalFields(this, n, []);
-      a = CalendarMergeFields(o, a, PrepareTemporalFields(e, n, "partial")), a = PrepareTemporalFields(a, n, []);
-      var _InterpretTemporalDat4 = InterpretTemporalDateTimeFields(o, a, r),
-        i = _InterpretTemporalDat4.year,
-        s = _InterpretTemporalDat4.month,
-        l = _InterpretTemporalDat4.day,
-        d = _InterpretTemporalDat4.hour,
-        m = _InterpretTemporalDat4.minute,
-        c = _InterpretTemporalDat4.second,
-        h = _InterpretTemporalDat4.millisecond,
-        u = _InterpretTemporalDat4.microsecond,
-        T = _InterpretTemporalDat4.nanosecond;
-      return CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, o);
-    }
-  }, {
-    key: "withPlainTime",
-    value: function withPlainTime(e) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var t = GetSlot(this, i),
-        r = GetSlot(this, s),
-        o = GetSlot(this, l),
-        n = GetSlot(this, p);
-      if (void 0 === e) return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
-      var a = ToTemporalTime(e);
-      return CreateTemporalDateTime(t, r, o, GetSlot(a, d), GetSlot(a, m), GetSlot(a, c), GetSlot(a, h), GetSlot(a, u), GetSlot(a, T), n);
-    }
-  }, {
-    key: "withPlainDate",
-    value: function withPlainDate(e) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e),
-        r = GetSlot(t, i),
-        o = GetSlot(t, s),
-        n = GetSlot(t, l);
-      var a = GetSlot(t, p);
-      var f = GetSlot(this, d),
-        y = GetSlot(this, m),
-        I = GetSlot(this, c),
-        S = GetSlot(this, h),
-        g = GetSlot(this, u),
-        w = GetSlot(this, T);
-      return a = ConsolidateCalendars(GetSlot(this, p), a), CreateTemporalDateTime(r, o, n, f, y, I, S, g, w, a);
-    }
-  }, {
-    key: "withCalendar",
-    value: function withCalendar(e) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalCalendarSlotValue(e);
-      return new PlainDateTime(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), t);
-    }
-  }, {
-    key: "add",
-    value: function add(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e, t);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e, t);
-    }
-  }, {
-    key: "until",
-    value: function until(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainDateTime("until", this, e, t);
-    }
-  }, {
-    key: "since",
-    value: function since(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainDateTime("since", this, e, t);
-    }
-  }, {
-    key: "round",
-    value: function round(e) {
-      var _RoundISODateTime2;
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      if (void 0 === e) throw new TypeError("options parameter is required");
-      var t = "string" == typeof e ? CreateOnePropObject("smallestUnit", e) : GetOptionsObject(e),
-        r = ToTemporalRoundingIncrement(t),
-        o = ToTemporalRoundingMode(t, "halfExpand"),
-        n = GetTemporalUnit(t, "smallestUnit", "time", He, ["day"]),
-        a = {
-          day: 1,
-          hour: 24,
-          minute: 60,
-          second: 60,
-          millisecond: 1e3,
-          microsecond: 1e3,
-          nanosecond: 1e3
-        }[n];
-      ValidateTemporalRoundingIncrement(r, a, 1 === a);
-      var f = GetSlot(this, i),
-        y = GetSlot(this, s),
-        I = GetSlot(this, l),
-        S = GetSlot(this, d),
-        g = GetSlot(this, m),
-        w = GetSlot(this, c),
-        D = GetSlot(this, h),
-        G = GetSlot(this, u),
-        v = GetSlot(this, T);
-      return (_RoundISODateTime2 = RoundISODateTime(f, y, I, S, g, w, D, G, v, r, n, o), f = _RoundISODateTime2.year, y = _RoundISODateTime2.month, I = _RoundISODateTime2.day, S = _RoundISODateTime2.hour, g = _RoundISODateTime2.minute, w = _RoundISODateTime2.second, D = _RoundISODateTime2.millisecond, G = _RoundISODateTime2.microsecond, v = _RoundISODateTime2.nanosecond), CreateTemporalDateTime(f, y, I, S, g, w, D, G, v, GetSlot(this, p));
-    }
-  }, {
-    key: "equals",
-    value: function equals(e) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDateTime(e);
-      for (var _i23 = 0, _arr9 = [i, s, l, d, m, c, h, u, T]; _i23 < _arr9.length; _i23++) {
-        var _e55 = _arr9[_i23];
-        if (GetSlot(this, _e55) !== GetSlot(t, _e55)) return !1;
-      }
-      return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
-    }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var t = GetOptionsObject(e),
-        r = ToCalendarNameOption(t),
-        o = ToFractionalSecondDigits(t),
-        n = ToTemporalRoundingMode(t, "trunc"),
-        a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
-      if ("hour" === a) throw new RangeError('smallestUnit must be a time unit other than "hour"');
-      var _ToSecondsStringPreci2 = ToSecondsStringPrecisionRecord(a, o),
-        i = _ToSecondsStringPreci2.precision,
-        s = _ToSecondsStringPreci2.unit,
-        l = _ToSecondsStringPreci2.increment;
-      return TemporalDateTimeToString(this, i, r, {
-        unit: s,
-        increment: l,
-        roundingMode: n
-      });
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return TemporalDateTimeToString(this, "auto");
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return new ht(e, t).format(this);
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
-    }
-  }, {
-    key: "toZonedDateTime",
-    value: function toZonedDateTime(e, t) {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var r = ToTemporalTimeZoneSlotValue(e);
-      return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(r, this, ToTemporalDisambiguation(GetOptionsObject(t))), n), r, GetSlot(this, p));
-    }
-  }, {
-    key: "toPlainDate",
-    value: function toPlainDate() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return TemporalDateTimeToDate(this);
-    }
-  }, {
-    key: "toPlainYearMonth",
-    value: function toPlainYearMonth() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var e = GetSlot(this, p);
-      return CalendarYearMonthFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["monthCode", "year"]), []));
-    }
-  }, {
-    key: "toPlainMonthDay",
-    value: function toPlainMonthDay() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      var e = GetSlot(this, p);
-      return CalendarMonthDayFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["day", "monthCode"]), []));
-    }
-  }, {
-    key: "toPlainTime",
-    value: function toPlainTime() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return TemporalDateTimeToTime(this);
-    }
-  }, {
-    key: "getISOFields",
-    value: function getISOFields() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return {
-        calendar: GetSlot(this, p),
-        isoDay: GetSlot(this, l),
-        isoHour: GetSlot(this, d),
-        isoMicrosecond: GetSlot(this, u),
-        isoMillisecond: GetSlot(this, h),
-        isoMinute: GetSlot(this, m),
-        isoMonth: GetSlot(this, s),
-        isoNanosecond: GetSlot(this, T),
-        isoSecond: GetSlot(this, c),
-        isoYear: GetSlot(this, i)
-      };
-    }
-  }, {
-    key: "getCalendar",
-    value: function getCalendar() {
-      if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarObject(GetSlot(this, p));
-    }
-  }], [{
-    key: "from",
-    value: function from(e, t) {
-      var r = GetOptionsObject(t);
-      return IsTemporalDateTime(e) ? (ToTemporalOverflow(r), CreateTemporalDateTime(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T), GetSlot(e, p))) : ToTemporalDateTime(e, r);
-    }
-  }, {
-    key: "compare",
-    value: function compare(e, t) {
-      var r = ToTemporalDateTime(e),
-        o = ToTemporalDateTime(t);
-      for (var _i24 = 0, _arr10 = [i, s, l, d, m, c, h, u, T]; _i24 < _arr10.length; _i24++) {
-        var _e56 = _arr10[_i24];
-        var _t50 = GetSlot(r, _e56),
-          _n27 = GetSlot(o, _e56);
-        if (_t50 !== _n27) return ComparisonResult(_t50 - _n27);
-      }
-      return 0;
+var
+ PlainDateTime =
+   function(){
+     function PlainDateTime(e, t, r){
+      var
+       o =
+         arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
+      var
+       n =
+         arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
+      var
+       a =
+         arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
+      var
+       i =
+         arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
+      var
+       s =
+         arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
+      var
+       l =
+         arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
+      var
+       d =
+         arguments.length > 9 && arguments[9] !== undefined
+          ? arguments[9]
+          : "iso8601";
+      _classCallCheck(this, PlainDateTime);
+      CreateTemporalDateTimeSlots
+       (this,
+        ToIntegerWithTruncation(e),
+        ToIntegerWithTruncation(t),
+        ToIntegerWithTruncation(r),
+        void 0 === o ? 0 : ToIntegerWithTruncation(o),
+        void 0 === n ? 0 : ToIntegerWithTruncation(n),
+        void 0 === a ? 0 : ToIntegerWithTruncation(a),
+        void 0 === i ? 0 : ToIntegerWithTruncation(i),
+        void 0 === s ? 0 : ToIntegerWithTruncation(s),
+        void 0 === l ? 0 : ToIntegerWithTruncation(l),
+        ToTemporalCalendarSlotValue(d));
+     }
+     return _createClass
+             (PlainDateTime,
+              [{key: "calendarId",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarIdentifier(GetSlot(this, p));
+                }},
+               {key: "year",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYear(GetSlot(this, p), this);
+                }},
+               {key: "month",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonth(GetSlot(this, p), this);
+                }},
+               {key: "monthCode",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthCode(GetSlot(this, p), this);
+                }},
+               {key: "day",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDay(GetSlot(this, p), this);
+                }},
+               {key: "hour",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, d);
+                }},
+               {key: "minute",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, m);
+                }},
+               {key: "second",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, c);
+                }},
+               {key: "millisecond",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, h);
+                }},
+               {key: "microsecond",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, u);
+                }},
+               {key: "nanosecond",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, T);
+                }},
+               {key: "era",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEra(GetSlot(this, p), this);
+                }},
+               {key: "eraYear",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEraYear(GetSlot(this, p), this);
+                }},
+               {key: "dayOfWeek",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDayOfWeek(GetSlot(this, p), this);
+                }},
+               {key: "dayOfYear",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDayOfYear(GetSlot(this, p), this);
+                }},
+               {key: "weekOfYear",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarWeekOfYear(GetSlot(this, p), this);
+                }},
+               {key: "yearOfWeek",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYearOfWeek(GetSlot(this, p), this);
+                }},
+               {key: "daysInWeek",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInWeek(GetSlot(this, p), this);
+                }},
+               {key: "daysInYear",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInYear(GetSlot(this, p), this);
+                }},
+               {key: "daysInMonth",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInMonth(GetSlot(this, p), this);
+                }},
+               {key: "monthsInYear",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthsInYear(GetSlot(this, p), this);
+                }},
+               {key: "inLeapYear",
+                get:
+                function get(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarInLeapYear(GetSlot(this, p), this);
+                }},
+               {key: "with",
+                value:
+                function _with(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid argument");
+                 RejectTemporalLikeObject(e);
+                 var
+                  r = GetOptionsObject(t),
+                  o = GetSlot(this, p),
+                  n =
+                    CalendarFields
+                     (o,
+                      ["day",
+                       "hour",
+                       "microsecond",
+                       "millisecond",
+                       "minute",
+                       "month",
+                       "monthCode",
+                       "nanosecond",
+                       "second",
+                       "year"]);
+                 var a = PrepareTemporalFields(this, n, []);
+                 a =
+                  CalendarMergeFields
+                   (o, a, PrepareTemporalFields(e, n, "partial")),
+                 a = PrepareTemporalFields(a, n, []);
+                 var
+                  _InterpretTemporalDat4 =
+                    InterpretTemporalDateTimeFields(o, a, r),
+                  i = _InterpretTemporalDat4.year,
+                  s = _InterpretTemporalDat4.month,
+                  l = _InterpretTemporalDat4.day,
+                  d = _InterpretTemporalDat4.hour,
+                  m = _InterpretTemporalDat4.minute,
+                  c = _InterpretTemporalDat4.second,
+                  h = _InterpretTemporalDat4.millisecond,
+                  u = _InterpretTemporalDat4.microsecond,
+                  T = _InterpretTemporalDat4.nanosecond;
+                 return CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, o);
+                }},
+               {key: "withPlainTime",
+                value:
+                function withPlainTime(e){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetSlot(this, i),
+                  r = GetSlot(this, s),
+                  o = GetSlot(this, l),
+                  n = GetSlot(this, p);
+                 if(void 0 === e)
+                  return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
+                 var a = ToTemporalTime(e);
+                 return CreateTemporalDateTime
+                         (t,
+                          r,
+                          o,
+                          GetSlot(a, d),
+                          GetSlot(a, m),
+                          GetSlot(a, c),
+                          GetSlot(a, h),
+                          GetSlot(a, u),
+                          GetSlot(a, T),
+                          n);
+                }},
+               {key: "withPlainDate",
+                value:
+                function withPlainDate(e){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = ToTemporalDate(e),
+                  r = GetSlot(t, i),
+                  o = GetSlot(t, s),
+                  n = GetSlot(t, l);
+                 var a = GetSlot(t, p);
+                 var
+                  f = GetSlot(this, d),
+                  y = GetSlot(this, m),
+                  I = GetSlot(this, c),
+                  S = GetSlot(this, h),
+                  g = GetSlot(this, u),
+                  w = GetSlot(this, T);
+                 return a = ConsolidateCalendars(GetSlot(this, p), a),
+                        CreateTemporalDateTime(r, o, n, f, y, I, S, g, w, a);
+                }},
+               {key: "withCalendar",
+                value:
+                function withCalendar(e){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalCalendarSlotValue(e);
+                 return new
+                         PlainDateTime
+                         (GetSlot(this, i),
+                          GetSlot(this, s),
+                          GetSlot(this, l),
+                          GetSlot(this, d),
+                          GetSlot(this, m),
+                          GetSlot(this, c),
+                          GetSlot(this, h),
+                          GetSlot(this, u),
+                          GetSlot(this, T),
+                          t);
+                }},
+               {key: "add",
+                value:
+                function add(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromPlainDateTime
+                         ("add", this, e, t);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromPlainDateTime
+                         ("subtract", this, e, t);
+                }},
+               {key: "until",
+                value:
+                function until(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainDateTime("until", this, e, t);
+                }},
+               {key: "since",
+                value:
+                function since(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainDateTime("since", this, e, t);
+                }},
+               {key: "round",
+                value:
+                function round(e){
+                 var _RoundISODateTime2;
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(void 0 === e)
+                  throw new TypeError("options parameter is required");
+                 var
+                  t =
+                    "string" == typeof e
+                     ? CreateOnePropObject("smallestUnit", e)
+                     : GetOptionsObject(e),
+                  r = ToTemporalRoundingIncrement(t),
+                  o = ToTemporalRoundingMode(t, "halfExpand"),
+                  n = GetTemporalUnit(t, "smallestUnit", "time", He, ["day"]),
+                  a =
+                    {day: 1,
+                      hour: 24,
+                      minute: 60,
+                      second: 60,
+                      millisecond: 1e3,
+                      microsecond: 1e3,
+                      nanosecond: 1e3}
+                     [n];
+                 ValidateTemporalRoundingIncrement(r, a, 1 === a);
+                 var
+                  f = GetSlot(this, i),
+                  y = GetSlot(this, s),
+                  I = GetSlot(this, l),
+                  S = GetSlot(this, d),
+                  g = GetSlot(this, m),
+                  w = GetSlot(this, c),
+                  D = GetSlot(this, h),
+                  G = GetSlot(this, u),
+                  v = GetSlot(this, T);
+                 return _RoundISODateTime2 =
+                         RoundISODateTime(f, y, I, S, g, w, D, G, v, r, n, o),
+                        f = _RoundISODateTime2.year,
+                        y = _RoundISODateTime2.month,
+                        I = _RoundISODateTime2.day,
+                        S = _RoundISODateTime2.hour,
+                        g = _RoundISODateTime2.minute,
+                        w = _RoundISODateTime2.second,
+                        D = _RoundISODateTime2.millisecond,
+                        G = _RoundISODateTime2.microsecond,
+                        v = _RoundISODateTime2.nanosecond,
+                        CreateTemporalDateTime
+                         (f, y, I, S, g, w, D, G, v, GetSlot(this, p));
+                }},
+               {key: "equals",
+                value:
+                function equals(e){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalDateTime(e);
+                 for
+                 (var _i23 = 0, _arr9 = [i, s, l, d, m, c, h, u, T];
+                  _i23 < _arr9.length;
+                  _i23++){
+                  var _e55 = _arr9[_i23];
+                  if(GetSlot(this, _e55) !== GetSlot(t, _e55)) return ! 1;
+                 }
+                 return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetOptionsObject(e),
+                  r = ToCalendarNameOption(t),
+                  o = ToFractionalSecondDigits(t),
+                  n = ToTemporalRoundingMode(t, "trunc"),
+                  a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
+                 if("hour" === a)
+                  throw new
+                         RangeError
+                         ('smallestUnit must be a time unit other than "hour"');
+                 var
+                  _ToSecondsStringPreci2 =
+                    ToSecondsStringPrecisionRecord(a, o),
+                  i = _ToSecondsStringPreci2.precision,
+                  s = _ToSecondsStringPreci2.unit,
+                  l = _ToSecondsStringPreci2.increment;
+                 return TemporalDateTimeToString
+                         (this, i, r, {unit: s, increment: l, roundingMode: n});
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateTimeToString(this, "auto");
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return new ht(e, t).format(this);
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() or equals() to compare Temporal.PlainDateTime");
+                }},
+               {key: "toZonedDateTime",
+                value:
+                function toZonedDateTime(e, t){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var r = ToTemporalTimeZoneSlotValue(e);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot
+                           (GetInstantFor
+                             (r, this, ToTemporalDisambiguation(GetOptionsObject(t))),
+                            n),
+                          r,
+                          GetSlot(this, p));
+                }},
+               {key: "toPlainDate",
+                value:
+                function toPlainDate(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateTimeToDate(this);
+                }},
+               {key: "toPlainYearMonth",
+                value:
+                function toPlainYearMonth(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var e = GetSlot(this, p);
+                 return CalendarYearMonthFromFields
+                         (e,
+                          PrepareTemporalFields
+                           (this, CalendarFields(e, ["monthCode", "year"]), []));
+                }},
+               {key: "toPlainMonthDay",
+                value:
+                function toPlainMonthDay(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var e = GetSlot(this, p);
+                 return CalendarMonthDayFromFields
+                         (e,
+                          PrepareTemporalFields
+                           (this, CalendarFields(e, ["day", "monthCode"]), []));
+                }},
+               {key: "toPlainTime",
+                value:
+                function toPlainTime(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateTimeToTime(this);
+                }},
+               {key: "getISOFields",
+                value:
+                function getISOFields(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return {calendar: GetSlot(this, p),
+                         isoDay: GetSlot(this, l),
+                         isoHour: GetSlot(this, d),
+                         isoMicrosecond: GetSlot(this, u),
+                         isoMillisecond: GetSlot(this, h),
+                         isoMinute: GetSlot(this, m),
+                         isoMonth: GetSlot(this, s),
+                         isoNanosecond: GetSlot(this, T),
+                         isoSecond: GetSlot(this, c),
+                         isoYear: GetSlot(this, i)};
+                }},
+               {key: "getCalendar",
+                value:
+                function getCalendar(){
+                 if(! IsTemporalDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarObject(GetSlot(this, p));
+                }}],
+              [{key: "from",
+                value:
+                function from(e, t){
+                 var r = GetOptionsObject(t);
+                 return IsTemporalDateTime(e)
+                         ? (ToTemporalOverflow
+                            (r),
+                           CreateTemporalDateTime
+                            (GetSlot(e, i),
+                             GetSlot(e, s),
+                             GetSlot(e, l),
+                             GetSlot(e, d),
+                             GetSlot(e, m),
+                             GetSlot(e, c),
+                             GetSlot(e, h),
+                             GetSlot(e, u),
+                             GetSlot(e, T),
+                             GetSlot(e, p)))
+                         : ToTemporalDateTime(e, r);
+                }},
+               {key: "compare",
+                value:
+                function compare(e, t){
+                 var r = ToTemporalDateTime(e), o = ToTemporalDateTime(t);
+                 for
+                 (var _i24 = 0, _arr10 = [i, s, l, d, m, c, h, u, T];
+                  _i24 < _arr10.length;
+                  _i24++){
+                  var _e56 = _arr10[_i24];
+                  var _t50 = GetSlot(r, _e56), _n27 = GetSlot(o, _e56);
+                  if(_t50 !== _n27) return ComparisonResult(_t50 - _n27);
+                 }
+                 return 0;
+                }}]);
     }
-  }]);
-  return PlainDateTime;
-}();
+    ();
 MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
-var Duration = /*#__PURE__*/function () {
-  function Duration() {
-    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
-    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
-    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
-    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
-    var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
-    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
-    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
-    var s = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
-    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
-    var d = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
-    _classCallCheck(this, Duration);
-    var m = void 0 === e ? 0 : ToIntegerIfIntegral(e),
-      c = void 0 === t ? 0 : ToIntegerIfIntegral(t),
-      h = void 0 === r ? 0 : ToIntegerIfIntegral(r),
-      u = void 0 === o ? 0 : ToIntegerIfIntegral(o),
-      T = void 0 === n ? 0 : ToIntegerIfIntegral(n),
-      p = void 0 === a ? 0 : ToIntegerIfIntegral(a),
-      f = void 0 === i ? 0 : ToIntegerIfIntegral(i),
-      y = void 0 === s ? 0 : ToIntegerIfIntegral(s),
-      I = void 0 === l ? 0 : ToIntegerIfIntegral(l),
-      S = void 0 === d ? 0 : ToIntegerIfIntegral(d);
-    RejectDuration(m, c, h, u, T, p, f, y, I, S), N(this), SetSlot(this, w, m), SetSlot(this, D, c), SetSlot(this, G, h), SetSlot(this, v, u), SetSlot(this, C, T), SetSlot(this, O, p), SetSlot(this, b, f), SetSlot(this, E, y), SetSlot(this, M, I), SetSlot(this, R, S);
-  }
-  _createClass(Duration, [{
-    key: "years",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, w);
-    }
-  }, {
-    key: "months",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, D);
-    }
-  }, {
-    key: "weeks",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, G);
-    }
-  }, {
-    key: "days",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, v);
-    }
-  }, {
-    key: "hours",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, C);
-    }
-  }, {
-    key: "minutes",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, O);
-    }
-  }, {
-    key: "seconds",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, b);
-    }
-  }, {
-    key: "milliseconds",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, E);
-    }
-  }, {
-    key: "microseconds",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, M);
-    }
-  }, {
-    key: "nanoseconds",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, R);
-    }
-  }, {
-    key: "sign",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
-    }
-  }, {
-    key: "blank",
-    get: function get() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return 0 === DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
-    }
-  }, {
-    key: "with",
-    value: function _with(e) {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      var t = PrepareTemporalFields(e, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial"),
-        _t$years = t.years,
-        r = _t$years === void 0 ? GetSlot(this, w) : _t$years,
-        _t$months = t.months,
-        o = _t$months === void 0 ? GetSlot(this, D) : _t$months,
-        _t$weeks = t.weeks,
-        n = _t$weeks === void 0 ? GetSlot(this, G) : _t$weeks,
-        _t$days = t.days,
-        a = _t$days === void 0 ? GetSlot(this, v) : _t$days,
-        _t$hours = t.hours,
-        i = _t$hours === void 0 ? GetSlot(this, C) : _t$hours,
-        _t$minutes = t.minutes,
-        s = _t$minutes === void 0 ? GetSlot(this, O) : _t$minutes,
-        _t$seconds = t.seconds,
-        l = _t$seconds === void 0 ? GetSlot(this, b) : _t$seconds,
-        _t$milliseconds = t.milliseconds,
-        d = _t$milliseconds === void 0 ? GetSlot(this, E) : _t$milliseconds,
-        _t$microseconds = t.microseconds,
-        m = _t$microseconds === void 0 ? GetSlot(this, M) : _t$microseconds,
-        _t$nanoseconds = t.nanoseconds,
-        c = _t$nanoseconds === void 0 ? GetSlot(this, R) : _t$nanoseconds;
-      return new Duration(r, o, n, a, i, s, l, d, m, c);
-    }
-  }, {
-    key: "negated",
-    value: function negated() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return CreateNegatedTemporalDuration(this);
-    }
-  }, {
-    key: "abs",
-    value: function abs() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return new Duration(Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, C)), Math.abs(GetSlot(this, O)), Math.abs(GetSlot(this, b)), Math.abs(GetSlot(this, E)), Math.abs(GetSlot(this, M)), Math.abs(GetSlot(this, R)));
-    }
-  }, {
-    key: "add",
-    value: function add(e, t) {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromDuration("add", this, e, t);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e, t) {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromDuration("subtract", this, e, t);
-    }
-  }, {
-    key: "round",
-    value: function round(t) {
-      var _UnbalanceDurationRel, _RoundDuration8, _AdjustRoundedDuratio2, _BalanceDuration11, _BalanceDurationRelat;
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      if (void 0 === t) throw new TypeError("options parameter is required");
-      var r = GetSlot(this, w),
-        o = GetSlot(this, D),
-        n = GetSlot(this, G),
-        a = GetSlot(this, v),
-        i = GetSlot(this, C),
-        s = GetSlot(this, O),
-        l = GetSlot(this, b),
-        d = GetSlot(this, E),
-        m = GetSlot(this, M),
-        c = GetSlot(this, R),
-        h = DefaultTemporalLargestUnit(r, o, n, a, i, s, l, d, m, c);
-      var u = "string" == typeof t ? CreateOnePropObject("smallestUnit", t) : GetOptionsObject(t);
-      var T = GetTemporalUnit(u, "largestUnit", "datetime", void 0, ["auto"]),
-        f = ToRelativeTemporalObject(u);
-      var y = ToTemporalRoundingIncrement(u),
-        I = ToTemporalRoundingMode(u, "halfExpand");
-      var S = GetTemporalUnit(u, "smallestUnit", "datetime", void 0),
-        g = !0;
-      S || (g = !1, S = "nanosecond"), h = LargerOfTwoTemporalUnits(h, S);
-      var F = !0;
-      if (T || (F = !1, T = h), "auto" === T && (T = h), !g && !F) throw new RangeError("at least one of smallestUnit or largestUnit is required");
-      if (LargerOfTwoTemporalUnits(T, S) !== T) throw new RangeError("largestUnit ".concat(T, " cannot be smaller than smallestUnit ").concat(S));
-      var Y = {
-        hour: 24,
-        minute: 60,
-        second: 60,
-        millisecond: 1e3,
-        microsecond: 1e3,
-        nanosecond: 1e3
-      }[S];
-      return void 0 !== Y && ValidateTemporalRoundingIncrement(y, Y, !1), (_UnbalanceDurationRel = UnbalanceDurationRelative(r, o, n, a, T, f), r = _UnbalanceDurationRel.years, o = _UnbalanceDurationRel.months, n = _UnbalanceDurationRel.weeks, a = _UnbalanceDurationRel.days), (_RoundDuration8 = RoundDuration(r, o, n, a, i, s, l, d, m, c, y, S, I, f), r = _RoundDuration8.years, o = _RoundDuration8.months, n = _RoundDuration8.weeks, a = _RoundDuration8.days, i = _RoundDuration8.hours, s = _RoundDuration8.minutes, l = _RoundDuration8.seconds, d = _RoundDuration8.milliseconds, m = _RoundDuration8.microseconds, c = _RoundDuration8.nanoseconds), (_AdjustRoundedDuratio2 = AdjustRoundedDurationDays(r, o, n, a, i, s, l, d, m, c, y, S, I, f), r = _AdjustRoundedDuratio2.years, o = _AdjustRoundedDuratio2.months, n = _AdjustRoundedDuratio2.weeks, a = _AdjustRoundedDuratio2.days, i = _AdjustRoundedDuratio2.hours, s = _AdjustRoundedDuratio2.minutes, l = _AdjustRoundedDuratio2.seconds, d = _AdjustRoundedDuratio2.milliseconds, m = _AdjustRoundedDuratio2.microseconds, c = _AdjustRoundedDuratio2.nanoseconds), (_BalanceDuration11 = BalanceDuration(a, i, s, l, d, m, c, T, f), a = _BalanceDuration11.days, i = _BalanceDuration11.hours, s = _BalanceDuration11.minutes, l = _BalanceDuration11.seconds, d = _BalanceDuration11.milliseconds, m = _BalanceDuration11.microseconds, c = _BalanceDuration11.nanoseconds), (_BalanceDurationRelat = function BalanceDurationRelative(t, r, o, n, a, i) {
-        var s = GetIntrinsic("%Temporal.Duration%"),
-          l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
-        if (0 === l) return {
-          years: t,
-          months: r,
-          weeks: o,
-          days: n
-        };
-        var d = BigInt(l);
-        var m,
-          c,
-          h = BigInt(t),
-          u = BigInt(r),
-          T = BigInt(o),
-          f = BigInt(n);
-        i && (c = ToTemporalDate(i), m = GetSlot(c, p));
-        var y = new s(l),
-          I = new s(0, l),
-          S = new s(0, 0, l);
-        switch (a) {
-          case "year":
-            {
-              if (!m) throw new RangeError("a starting point is required for years balancing");
-              var _t51 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
-              var _r68, _o46, _n28;
-              for (_MoveRelativeDate11 = MoveRelativeDate(m, c, y, _t51), _r68 = _MoveRelativeDate11.relativeTo, _o46 = _MoveRelativeDate11.days, _MoveRelativeDate11; abs(f) >= BigInt(ae(_o46));) {
-                var _MoveRelativeDate11, _MoveRelativeDate12;
-                f = f - BigInt(_o46), h = h + d, c = _r68, (_MoveRelativeDate12 = MoveRelativeDate(m, c, y, _t51), _r68 = _MoveRelativeDate12.relativeTo, _o46 = _MoveRelativeDate12.days);
-              }
-              for (_MoveRelativeDate13 = MoveRelativeDate(m, c, I, _t51), _r68 = _MoveRelativeDate13.relativeTo, _n28 = _MoveRelativeDate13.days, _MoveRelativeDate13; abs(f) >= BigInt(ae(_n28));) {
-                var _MoveRelativeDate13, _MoveRelativeDate14;
-                f = f - BigInt(_n28), u = u + d, c = _r68, (_MoveRelativeDate14 = MoveRelativeDate(m, c, I, _t51), _r68 = _MoveRelativeDate14.relativeTo, _n28 = _MoveRelativeDate14.days);
-              }
-              _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
-              var _a20 = "string" != typeof m ? GetMethod(m, "dateUntil") : void 0,
-                _i25 = Te(null);
-              _i25.largestUnit = "month";
-              var _s8 = CalendarDateUntil(m, c, _r68, _i25, _a20),
-                _l9 = GetSlot(_s8, D);
-              for (; abs(u) >= BigInt(ae(_l9));) {
-                u = u - BigInt(_l9), h = h + d, c = _r68, _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
-                var _o47 = Te(null);
-                _o47.largestUnit = "month", _s8 = CalendarDateUntil(m, c, _r68, _o47, _a20), _l9 = GetSlot(_s8, D);
-              }
-              break;
-            }
-          case "month":
-            {
-              if (!m) throw new RangeError("a starting point is required for months balancing");
-              var _t52 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
-              var _r69, _o48;
-              for (_MoveRelativeDate15 = MoveRelativeDate(m, c, I, _t52), _r69 = _MoveRelativeDate15.relativeTo, _o48 = _MoveRelativeDate15.days, _MoveRelativeDate15; abs(f) >= BigInt(ae(_o48));) {
-                var _MoveRelativeDate15, _MoveRelativeDate16;
-                f = f - BigInt(_o48), u = u + d, c = _r69, (_MoveRelativeDate16 = MoveRelativeDate(m, c, I, _t52), _r69 = _MoveRelativeDate16.relativeTo, _o48 = _MoveRelativeDate16.days);
-              }
-              break;
-            }
-          case "week":
-            {
-              if (!m) throw new RangeError("a starting point is required for weeks balancing");
-              var _t53 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
-              var _r70, _o49;
-              for (_MoveRelativeDate17 = MoveRelativeDate(m, c, S, _t53), _r70 = _MoveRelativeDate17.relativeTo, _o49 = _MoveRelativeDate17.days, _MoveRelativeDate17; abs(f) >= BigInt(ae(_o49));) {
-                var _MoveRelativeDate17, _MoveRelativeDate18;
-                f = f - BigInt(_o49), T = T + d, c = _r70, (_MoveRelativeDate18 = MoveRelativeDate(m, c, S, _t53), _r70 = _MoveRelativeDate18.relativeTo, _o49 = _MoveRelativeDate18.days);
-              }
-              break;
-            }
-        }
-        return {
-          years: Number(h),
-          months: Number(u),
-          weeks: Number(T),
-          days: Number(f)
-        };
-      }(r, o, n, a, T, f), r = _BalanceDurationRelat.years, o = _BalanceDurationRelat.months, n = _BalanceDurationRelat.weeks, a = _BalanceDurationRelat.days), new Duration(r, o, n, a, i, s, l, d, m, c);
-    }
-  }, {
-    key: "total",
-    value: function total(e) {
-      var _UnbalanceDurationRel2;
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      var t = GetSlot(this, w),
-        r = GetSlot(this, D),
-        o = GetSlot(this, G),
-        n = GetSlot(this, v),
-        a = GetSlot(this, C),
-        i = GetSlot(this, O),
-        s = GetSlot(this, b),
-        l = GetSlot(this, E),
-        d = GetSlot(this, M),
-        m = GetSlot(this, R);
-      if (void 0 === e) throw new TypeError("options argument is required");
-      var c = "string" == typeof e ? CreateOnePropObject("unit", e) : GetOptionsObject(e),
-        h = ToRelativeTemporalObject(c),
-        u = GetTemporalUnit(c, "unit", "datetime", He);
-      var T;
-      (_UnbalanceDurationRel2 = UnbalanceDurationRelative(t, r, o, n, u, h), t = _UnbalanceDurationRel2.years, r = _UnbalanceDurationRel2.months, o = _UnbalanceDurationRel2.weeks, n = _UnbalanceDurationRel2.days), IsTemporalZonedDateTime(h) && (T = MoveRelativeZonedDateTime(h, t, r, o, 0));
-      var p = BalancePossiblyInfiniteDuration(n, a, i, s, l, d, m, u, T);
-      if ("positive overflow" === p) return 1 / 0;
-      if ("negative overflow" === p) return -1 / 0;
-      n = p.days;
-      a = p.hours;
-      i = p.minutes;
-      s = p.seconds;
-      l = p.milliseconds;
-      d = p.microseconds;
-      m = p.nanoseconds;
-      var _RoundDuration9 = RoundDuration(t, r, o, n, a, i, s, l, d, m, 1, u, "trunc", h),
-        f = _RoundDuration9.total;
-      return f;
-    }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      var t = GetOptionsObject(e),
-        r = ToFractionalSecondDigits(t),
-        o = ToTemporalRoundingMode(t, "trunc"),
-        n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
-      if ("hour" === n || "minute" === n) throw new RangeError('smallestUnit must be a time unit other than "hours" or "minutes"');
-      var _ToSecondsStringPreci3 = ToSecondsStringPrecisionRecord(n, r),
-        a = _ToSecondsStringPreci3.precision,
-        i = _ToSecondsStringPreci3.unit,
-        s = _ToSecondsStringPreci3.increment;
-      return TemporalDurationToString(this, a, {
-        unit: i,
-        increment: s,
-        roundingMode: o
-      });
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return TemporalDurationToString(this);
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
-      return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e, t).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() to compare Temporal.Duration");
-    }
-  }], [{
-    key: "from",
-    value: function from(e) {
-      return IsTemporalDuration(e) ? new Duration(GetSlot(e, w), GetSlot(e, D), GetSlot(e, G), GetSlot(e, v), GetSlot(e, C), GetSlot(e, O), GetSlot(e, b), GetSlot(e, E), GetSlot(e, M), GetSlot(e, R)) : ToTemporalDuration(e);
-    }
-  }, {
-    key: "compare",
-    value: function compare(t, r, o) {
-      var _UnbalanceDurationRel3, _UnbalanceDurationRel4;
-      var n = ToTemporalDuration(t),
-        a = ToTemporalDuration(r),
-        i = ToRelativeTemporalObject(GetOptionsObject(o)),
-        s = GetSlot(n, w),
-        l = GetSlot(n, D),
-        d = GetSlot(n, G);
-      var m = GetSlot(n, v);
-      var c = GetSlot(n, C),
-        h = GetSlot(n, O),
-        u = GetSlot(n, b),
-        T = GetSlot(n, E),
-        p = GetSlot(n, M);
-      var f = GetSlot(n, R);
-      var y = GetSlot(a, w),
-        I = GetSlot(a, D),
-        S = GetSlot(a, G);
-      var g = GetSlot(a, v);
-      var F = GetSlot(a, C),
-        Y = GetSlot(a, O),
-        P = GetSlot(a, b),
-        Z = GetSlot(a, E),
-        B = GetSlot(a, M);
-      var N = GetSlot(a, R);
-      var j = CalculateOffsetShift(i, s, l, d, m),
-        $ = CalculateOffsetShift(i, y, I, S, g);
-      0 === s && 0 === y && 0 === l && 0 === I && 0 === d && 0 === S || ((_UnbalanceDurationRel3 = UnbalanceDurationRelative(s, l, d, m, "day", i), m = _UnbalanceDurationRel3.days), (_UnbalanceDurationRel4 = UnbalanceDurationRelative(y, I, S, g, "day", i), g = _UnbalanceDurationRel4.days));
-      var k = TotalDurationNanoseconds(m, c, h, u, T, p, f, j),
-        U = TotalDurationNanoseconds(g, F, Y, P, Z, B, N, $);
-      return ComparisonResult(Number(k - U));
-    }
-  }]);
-  return Duration;
-}();
+var
+ Duration =
+   function(){
+     function Duration(){
+      var
+       e =
+         arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+      var
+       t =
+         arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+      var
+       r =
+         arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
+      var
+       o =
+         arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
+      var
+       n =
+         arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
+      var
+       a =
+         arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
+      var
+       i =
+         arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
+      var
+       s =
+         arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
+      var
+       l =
+         arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
+      var
+       d =
+         arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
+      _classCallCheck(this, Duration);
+      var
+       m = void 0 === e ? 0 : ToIntegerIfIntegral(e),
+       c = void 0 === t ? 0 : ToIntegerIfIntegral(t),
+       h = void 0 === r ? 0 : ToIntegerIfIntegral(r),
+       u = void 0 === o ? 0 : ToIntegerIfIntegral(o),
+       T = void 0 === n ? 0 : ToIntegerIfIntegral(n),
+       p = void 0 === a ? 0 : ToIntegerIfIntegral(a),
+       f = void 0 === i ? 0 : ToIntegerIfIntegral(i),
+       y = void 0 === s ? 0 : ToIntegerIfIntegral(s),
+       I = void 0 === l ? 0 : ToIntegerIfIntegral(l),
+       S = void 0 === d ? 0 : ToIntegerIfIntegral(d);
+      RejectDuration(m, c, h, u, T, p, f, y, I, S),
+      N(this),
+      SetSlot(this, w, m),
+      SetSlot(this, D, c),
+      SetSlot(this, G, h),
+      SetSlot(this, v, u),
+      SetSlot(this, C, T),
+      SetSlot(this, O, p),
+      SetSlot(this, b, f),
+      SetSlot(this, E, y),
+      SetSlot(this, M, I),
+      SetSlot(this, R, S);
+     }
+     return _createClass
+             (Duration,
+              [{key: "years",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, w);
+                }},
+               {key: "months",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, D);
+                }},
+               {key: "weeks",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, G);
+                }},
+               {key: "days",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, v);
+                }},
+               {key: "hours",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, C);
+                }},
+               {key: "minutes",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, O);
+                }},
+               {key: "seconds",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, b);
+                }},
+               {key: "milliseconds",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, E);
+                }},
+               {key: "microseconds",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, M);
+                }},
+               {key: "nanoseconds",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, R);
+                }},
+               {key: "sign",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return DurationSign
+                         (GetSlot(this, w),
+                          GetSlot(this, D),
+                          GetSlot(this, G),
+                          GetSlot(this, v),
+                          GetSlot(this, C),
+                          GetSlot(this, O),
+                          GetSlot(this, b),
+                          GetSlot(this, E),
+                          GetSlot(this, M),
+                          GetSlot(this, R));
+                }},
+               {key: "blank",
+                get:
+                function get(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return 0
+                        ===
+                         DurationSign
+                          (GetSlot(this, w),
+                           GetSlot(this, D),
+                           GetSlot(this, G),
+                           GetSlot(this, v),
+                           GetSlot(this, C),
+                           GetSlot(this, O),
+                           GetSlot(this, b),
+                           GetSlot(this, E),
+                           GetSlot(this, M),
+                           GetSlot(this, R));
+                }},
+               {key: "with",
+                value:
+                function _with(e){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t =
+                    PrepareTemporalFields
+                     (e,
+                      ["days",
+                       "hours",
+                       "microseconds",
+                       "milliseconds",
+                       "minutes",
+                       "months",
+                       "nanoseconds",
+                       "seconds",
+                       "weeks",
+                       "years"],
+                      "partial"),
+                  _t$years = t.years,
+                  r = _t$years === void 0 ? GetSlot(this, w) : _t$years,
+                  _t$months = t.months,
+                  o = _t$months === void 0 ? GetSlot(this, D) : _t$months,
+                  _t$weeks = t.weeks,
+                  n = _t$weeks === void 0 ? GetSlot(this, G) : _t$weeks,
+                  _t$days = t.days,
+                  a = _t$days === void 0 ? GetSlot(this, v) : _t$days,
+                  _t$hours = t.hours,
+                  i = _t$hours === void 0 ? GetSlot(this, C) : _t$hours,
+                  _t$minutes = t.minutes,
+                  s = _t$minutes === void 0 ? GetSlot(this, O) : _t$minutes,
+                  _t$seconds = t.seconds,
+                  l = _t$seconds === void 0 ? GetSlot(this, b) : _t$seconds,
+                  _t$milliseconds = t.milliseconds,
+                  d =
+                    _t$milliseconds === void 0
+                     ? GetSlot(this, E)
+                     : _t$milliseconds,
+                  _t$microseconds = t.microseconds,
+                  m =
+                    _t$microseconds === void 0
+                     ? GetSlot(this, M)
+                     : _t$microseconds,
+                  _t$nanoseconds = t.nanoseconds,
+                  c =
+                    _t$nanoseconds === void 0
+                     ? GetSlot(this, R)
+                     : _t$nanoseconds;
+                 return new Duration(r, o, n, a, i, s, l, d, m, c);
+                }},
+               {key: "negated",
+                value:
+                function negated(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return CreateNegatedTemporalDuration(this);
+                }},
+               {key: "abs",
+                value:
+                function abs(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return new
+                         Duration
+                         (Math.abs(GetSlot(this, w)),
+                          Math.abs(GetSlot(this, D)),
+                          Math.abs(GetSlot(this, G)),
+                          Math.abs(GetSlot(this, v)),
+                          Math.abs(GetSlot(this, C)),
+                          Math.abs(GetSlot(this, O)),
+                          Math.abs(GetSlot(this, b)),
+                          Math.abs(GetSlot(this, E)),
+                          Math.abs(GetSlot(this, M)),
+                          Math.abs(GetSlot(this, R)));
+                }},
+               {key: "add",
+                value:
+                function add(e, t){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromDuration
+                         ("add", this, e, t);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e, t){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromDuration
+                         ("subtract", this, e, t);
+                }},
+               {key: "round",
+                value:
+                function round(t){
+                 var
+                  _UnbalanceDurationRel,
+                  _RoundDuration8,
+                  _AdjustRoundedDuratio2,
+                  _BalanceDuration11,
+                  _BalanceDurationRelat;
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 if(void 0 === t)
+                  throw new TypeError("options parameter is required");
+                 var
+                  r = GetSlot(this, w),
+                  o = GetSlot(this, D),
+                  n = GetSlot(this, G),
+                  a = GetSlot(this, v),
+                  i = GetSlot(this, C),
+                  s = GetSlot(this, O),
+                  l = GetSlot(this, b),
+                  d = GetSlot(this, E),
+                  m = GetSlot(this, M),
+                  c = GetSlot(this, R),
+                  h = DefaultTemporalLargestUnit(r, o, n, a, i, s, l, d, m, c);
+                 var
+                  u =
+                    "string" == typeof t
+                     ? CreateOnePropObject("smallestUnit", t)
+                     : GetOptionsObject(t);
+                 var
+                  T =
+                    GetTemporalUnit
+                     (u, "largestUnit", "datetime", void 0, ["auto"]),
+                  f = ToRelativeTemporalObject(u);
+                 var
+                  y = ToTemporalRoundingIncrement(u),
+                  I = ToTemporalRoundingMode(u, "halfExpand");
+                 var
+                  S = GetTemporalUnit(u, "smallestUnit", "datetime", void 0),
+                  g = ! 0;
+                 S || (g = ! 1, S = "nanosecond"),
+                 h = LargerOfTwoTemporalUnits(h, S);
+                 var F = ! 0;
+                 if
+                  (T || (F = ! 1, T = h), "auto" === T && (T = h), ! g && ! F)
+                  throw new
+                         RangeError
+                         ("at least one of smallestUnit or largestUnit is required");
+                 if(LargerOfTwoTemporalUnits(T, S) !== T)
+                  throw new
+                         RangeError
+                         ("largestUnit ".concat
+                            (T, " cannot be smaller than smallestUnit ").concat
+                           (S));
+                 var
+                  Y =
+                    {hour: 24,
+                      minute: 60,
+                      second: 60,
+                      millisecond: 1e3,
+                      microsecond: 1e3,
+                      nanosecond: 1e3}
+                     [S];
+                 return void 0 !== Y
+                        && ValidateTemporalRoundingIncrement(y, Y, ! 1),
+                        _UnbalanceDurationRel =
+                         UnbalanceDurationRelative(r, o, n, a, T, f),
+                        r = _UnbalanceDurationRel.years,
+                        o = _UnbalanceDurationRel.months,
+                        n = _UnbalanceDurationRel.weeks,
+                        a = _UnbalanceDurationRel.days,
+                        _RoundDuration8 =
+                         RoundDuration(r, o, n, a, i, s, l, d, m, c, y, S, I, f),
+                        r = _RoundDuration8.years,
+                        o = _RoundDuration8.months,
+                        n = _RoundDuration8.weeks,
+                        a = _RoundDuration8.days,
+                        i = _RoundDuration8.hours,
+                        s = _RoundDuration8.minutes,
+                        l = _RoundDuration8.seconds,
+                        d = _RoundDuration8.milliseconds,
+                        m = _RoundDuration8.microseconds,
+                        c = _RoundDuration8.nanoseconds,
+                        _AdjustRoundedDuratio2 =
+                         AdjustRoundedDurationDays
+                          (r, o, n, a, i, s, l, d, m, c, y, S, I, f),
+                        r = _AdjustRoundedDuratio2.years,
+                        o = _AdjustRoundedDuratio2.months,
+                        n = _AdjustRoundedDuratio2.weeks,
+                        a = _AdjustRoundedDuratio2.days,
+                        i = _AdjustRoundedDuratio2.hours,
+                        s = _AdjustRoundedDuratio2.minutes,
+                        l = _AdjustRoundedDuratio2.seconds,
+                        d = _AdjustRoundedDuratio2.milliseconds,
+                        m = _AdjustRoundedDuratio2.microseconds,
+                        c = _AdjustRoundedDuratio2.nanoseconds,
+                        _BalanceDuration11 =
+                         BalanceDuration(a, i, s, l, d, m, c, T, f),
+                        a = _BalanceDuration11.days,
+                        i = _BalanceDuration11.hours,
+                        s = _BalanceDuration11.minutes,
+                        l = _BalanceDuration11.seconds,
+                        d = _BalanceDuration11.milliseconds,
+                        m = _BalanceDuration11.microseconds,
+                        c = _BalanceDuration11.nanoseconds,
+                        _BalanceDurationRelat =
+                         function BalanceDurationRelative(t, r, o, n, a, i){
+                           var
+                            s = GetIntrinsic("%Temporal.Duration%"),
+                            l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
+                           if(0 === l) return {years: t, months: r, weeks: o, days: n};
+                           var d = BigInt(l);
+                           var
+                            m,
+                            c,
+                            h = BigInt(t),
+                            u = BigInt(r),
+                            T = BigInt(o),
+                            f = BigInt(n);
+                           i && (c = ToTemporalDate(i), m = GetSlot(c, p));
+                           var y = new s(l), I = new s(0, l), S = new s(0, 0, l);
+                           switch(a){
+                             case "year":
+                              {
+                               if(! m)
+                                throw new
+                                       RangeError
+                                       ("a starting point is required for years balancing");
+                               var
+                                _t51 =
+                                  "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
+                               var _r68, _o46, _n28;
+                               for
+                               (_MoveRelativeDate11 = MoveRelativeDate(m, c, y, _t51),
+                                _r68 = _MoveRelativeDate11.relativeTo,
+                                _o46 = _MoveRelativeDate11.days,
+                                _MoveRelativeDate11;
+                                abs(f) >= BigInt(ae(_o46));){
+                                var _MoveRelativeDate11, _MoveRelativeDate12;
+                                f = f - BigInt(_o46),
+                                h = h + d,
+                                c = _r68,
+                                _MoveRelativeDate12 = MoveRelativeDate(m, c, y, _t51),
+                                _r68 = _MoveRelativeDate12.relativeTo,
+                                _o46 = _MoveRelativeDate12.days;
+                               }
+                               for
+                               (_MoveRelativeDate13 = MoveRelativeDate(m, c, I, _t51),
+                                _r68 = _MoveRelativeDate13.relativeTo,
+                                _n28 = _MoveRelativeDate13.days,
+                                _MoveRelativeDate13;
+                                abs(f) >= BigInt(ae(_n28));){
+                                var _MoveRelativeDate13, _MoveRelativeDate14;
+                                f = f - BigInt(_n28),
+                                u = u + d,
+                                c = _r68,
+                                _MoveRelativeDate14 = MoveRelativeDate(m, c, I, _t51),
+                                _r68 = _MoveRelativeDate14.relativeTo,
+                                _n28 = _MoveRelativeDate14.days;
+                               }
+                               _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
+                               var
+                                _a20 =
+                                  "string" != typeof m ? GetMethod(m, "dateUntil") : void 0,
+                                _i25 = Te(null);
+                               _i25.largestUnit = "month";
+                               var
+                                _s8 = CalendarDateUntil(m, c, _r68, _i25, _a20),
+                                _l9 = GetSlot(_s8, D);
+                               for(; abs(u) >= BigInt(ae(_l9));){
+                                u = u - BigInt(_l9),
+                                h = h + d,
+                                c = _r68,
+                                _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
+                                var _o47 = Te(null);
+                                _o47.largestUnit = "month",
+                                _s8 = CalendarDateUntil(m, c, _r68, _o47, _a20),
+                                _l9 = GetSlot(_s8, D);
+                               }
+                               break;
+                              }
+                             case "month":
+                              {
+                               if(! m)
+                                throw new
+                                       RangeError
+                                       ("a starting point is required for months balancing");
+                               var
+                                _t52 =
+                                  "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
+                               var _r69, _o48;
+                               for
+                               (_MoveRelativeDate15 = MoveRelativeDate(m, c, I, _t52),
+                                _r69 = _MoveRelativeDate15.relativeTo,
+                                _o48 = _MoveRelativeDate15.days,
+                                _MoveRelativeDate15;
+                                abs(f) >= BigInt(ae(_o48));){
+                                var _MoveRelativeDate15, _MoveRelativeDate16;
+                                f = f - BigInt(_o48),
+                                u = u + d,
+                                c = _r69,
+                                _MoveRelativeDate16 = MoveRelativeDate(m, c, I, _t52),
+                                _r69 = _MoveRelativeDate16.relativeTo,
+                                _o48 = _MoveRelativeDate16.days;
+                               }
+                               break;
+                              }
+                             case "week":
+                              {
+                               if(! m)
+                                throw new
+                                       RangeError
+                                       ("a starting point is required for weeks balancing");
+                               var
+                                _t53 =
+                                  "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
+                               var _r70, _o49;
+                               for
+                               (_MoveRelativeDate17 = MoveRelativeDate(m, c, S, _t53),
+                                _r70 = _MoveRelativeDate17.relativeTo,
+                                _o49 = _MoveRelativeDate17.days,
+                                _MoveRelativeDate17;
+                                abs(f) >= BigInt(ae(_o49));){
+                                var _MoveRelativeDate17, _MoveRelativeDate18;
+                                f = f - BigInt(_o49),
+                                T = T + d,
+                                c = _r70,
+                                _MoveRelativeDate18 = MoveRelativeDate(m, c, S, _t53),
+                                _r70 = _MoveRelativeDate18.relativeTo,
+                                _o49 = _MoveRelativeDate18.days;
+                               }
+                               break;
+                              }
+                           }
+                           return {years: Number(h),
+                                   months: Number(u),
+                                   weeks: Number(T),
+                                   days: Number(f)};
+                          }
+                          (r, o, n, a, T, f),
+                        r = _BalanceDurationRelat.years,
+                        o = _BalanceDurationRelat.months,
+                        n = _BalanceDurationRelat.weeks,
+                        a = _BalanceDurationRelat.days,
+                        new Duration(r, o, n, a, i, s, l, d, m, c);
+                }},
+               {key: "total",
+                value:
+                function total(e){
+                 var _UnbalanceDurationRel2;
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetSlot(this, w),
+                  r = GetSlot(this, D),
+                  o = GetSlot(this, G),
+                  n = GetSlot(this, v),
+                  a = GetSlot(this, C),
+                  i = GetSlot(this, O),
+                  s = GetSlot(this, b),
+                  l = GetSlot(this, E),
+                  d = GetSlot(this, M),
+                  m = GetSlot(this, R);
+                 if(void 0 === e)
+                  throw new TypeError("options argument is required");
+                 var
+                  c =
+                    "string" == typeof e
+                     ? CreateOnePropObject("unit", e)
+                     : GetOptionsObject(e),
+                  h = ToRelativeTemporalObject(c),
+                  u = GetTemporalUnit(c, "unit", "datetime", He);
+                 var T;
+                 _UnbalanceDurationRel2 =
+                  UnbalanceDurationRelative(t, r, o, n, u, h),
+                 t = _UnbalanceDurationRel2.years,
+                 r = _UnbalanceDurationRel2.months,
+                 o = _UnbalanceDurationRel2.weeks,
+                 n = _UnbalanceDurationRel2.days,
+                 IsTemporalZonedDateTime(h)
+                 && (T = MoveRelativeZonedDateTime(h, t, r, o, 0));
+                 var
+                  p =
+                    BalancePossiblyInfiniteDuration(n, a, i, s, l, d, m, u, T);
+                 if("positive overflow" === p) return 1 / 0;
+                 if("negative overflow" === p) return - (1 / 0);
+                 n = p.days;
+                 a = p.hours;
+                 i = p.minutes;
+                 s = p.seconds;
+                 l = p.milliseconds;
+                 d = p.microseconds;
+                 m = p.nanoseconds;
+                 var
+                  _RoundDuration9 =
+                    RoundDuration
+                     (t, r, o, n, a, i, s, l, d, m, 1, u, "trunc", h),
+                  f = _RoundDuration9.total;
+                 return f;
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetOptionsObject(e),
+                  r = ToFractionalSecondDigits(t),
+                  o = ToTemporalRoundingMode(t, "trunc"),
+                  n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
+                 if("hour" === n || "minute" === n)
+                  throw new
+                         RangeError
+                         ('smallestUnit must be a time unit other than "hours" or "minutes"');
+                 var
+                  _ToSecondsStringPreci3 =
+                    ToSecondsStringPrecisionRecord(n, r),
+                  a = _ToSecondsStringPreci3.precision,
+                  i = _ToSecondsStringPreci3.unit,
+                  s = _ToSecondsStringPreci3.increment;
+                 return TemporalDurationToString
+                         (this, a, {unit: i, increment: s, roundingMode: o});
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDurationToString(this);
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalDuration(this))
+                  throw new TypeError("invalid receiver");
+                 return "undefined" != typeof Intl
+                         && void 0 !== Intl.DurationFormat
+                         ? new Intl.DurationFormat(e, t).format(this)
+                         : (console.warn
+                            ("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."),
+                           TemporalDurationToString(this));
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() to compare Temporal.Duration");
+                }}],
+              [{key: "from",
+                value:
+                function from(e){
+                 return IsTemporalDuration(e)
+                         ? new
+                           Duration
+                           (GetSlot(e, w),
+                            GetSlot(e, D),
+                            GetSlot(e, G),
+                            GetSlot(e, v),
+                            GetSlot(e, C),
+                            GetSlot(e, O),
+                            GetSlot(e, b),
+                            GetSlot(e, E),
+                            GetSlot(e, M),
+                            GetSlot(e, R))
+                         : ToTemporalDuration(e);
+                }},
+               {key: "compare",
+                value:
+                function compare(t, r, o){
+                 var _UnbalanceDurationRel3, _UnbalanceDurationRel4;
+                 var
+                  n = ToTemporalDuration(t),
+                  a = ToTemporalDuration(r),
+                  i = ToRelativeTemporalObject(GetOptionsObject(o)),
+                  s = GetSlot(n, w),
+                  l = GetSlot(n, D),
+                  d = GetSlot(n, G);
+                 var m = GetSlot(n, v);
+                 var
+                  c = GetSlot(n, C),
+                  h = GetSlot(n, O),
+                  u = GetSlot(n, b),
+                  T = GetSlot(n, E),
+                  p = GetSlot(n, M);
+                 var f = GetSlot(n, R);
+                 var y = GetSlot(a, w), I = GetSlot(a, D), S = GetSlot(a, G);
+                 var g = GetSlot(a, v);
+                 var
+                  F = GetSlot(a, C),
+                  Y = GetSlot(a, O),
+                  P = GetSlot(a, b),
+                  Z = GetSlot(a, E),
+                  B = GetSlot(a, M);
+                 var N = GetSlot(a, R);
+                 var
+                  j = CalculateOffsetShift(i, s, l, d, m),
+                  $ = CalculateOffsetShift(i, y, I, S, g);
+                 0 === s && 0 === y && 0 === l && 0 === I && 0 === d
+                 && 0 === S
+                 ||
+                  (_UnbalanceDurationRel3 =
+                    UnbalanceDurationRelative(s, l, d, m, "day", i),
+                   m = _UnbalanceDurationRel3.days,
+                   _UnbalanceDurationRel4 =
+                    UnbalanceDurationRelative(y, I, S, g, "day", i),
+                   g = _UnbalanceDurationRel4.days);
+                 var
+                  k = TotalDurationNanoseconds(m, c, h, u, T, p, f, j),
+                  U = TotalDurationNanoseconds(g, F, Y, P, Z, B, N, $);
+                 return ComparisonResult(Number(k - U));
+                }}]);
+    }
+    ();
 MakeIntrinsicClass(Duration, "Temporal.Duration");
 var bt = Object.create;
-var PlainMonthDay = /*#__PURE__*/function () {
-  function PlainMonthDay(e, t) {
-    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "iso8601";
-    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1972;
-    _classCallCheck(this, PlainMonthDay);
-    CreateTemporalMonthDaySlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t), ToTemporalCalendarSlotValue(r), ToIntegerWithTruncation(o));
-  }
-  _createClass(PlainMonthDay, [{
-    key: "monthCode",
-    get: function get() {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthCode(GetSlot(this, p), this);
-    }
-  }, {
-    key: "day",
-    get: function get() {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return CalendarDay(GetSlot(this, p), this);
-    }
-  }, {
-    key: "calendarId",
-    get: function get() {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarIdentifier(GetSlot(this, p));
-    }
-  }, {
-    key: "with",
-    value: function _with(e, t) {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument");
-      RejectTemporalLikeObject(e);
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, p),
-        n = CalendarFields(o, ["day", "month", "monthCode", "year"]);
-      var a = PrepareTemporalFields(this, n, []);
-      return a = CalendarMergeFields(o, a, PrepareTemporalFields(e, n, "partial")), a = PrepareTemporalFields(a, n, []), CalendarMonthDayFromFields(o, a, r);
-    }
-  }, {
-    key: "equals",
-    value: function equals(e) {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalMonthDay(e);
-      for (var _i26 = 0, _arr11 = [s, l, i]; _i26 < _arr11.length; _i26++) {
-        var _e57 = _arr11[_i26];
-        if (GetSlot(this, _e57) !== GetSlot(t, _e57)) return !1;
-      }
-      return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+var
+ PlainMonthDay =
+   function(){
+     function PlainMonthDay(e, t){
+      var
+       r =
+         arguments.length > 2 && arguments[2] !== undefined
+          ? arguments[2]
+          : "iso8601";
+      var
+       o =
+         arguments.length > 3 && arguments[3] !== undefined
+          ? arguments[3]
+          : 1972;
+      _classCallCheck(this, PlainMonthDay);
+      CreateTemporalMonthDaySlots
+       (this,
+        ToIntegerWithTruncation(e),
+        ToIntegerWithTruncation(t),
+        ToTemporalCalendarSlotValue(r),
+        ToIntegerWithTruncation(o));
+     }
+     return _createClass
+             (PlainMonthDay,
+              [{key: "monthCode",
+                get:
+                function get(){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthCode(GetSlot(this, p), this);
+                }},
+               {key: "day",
+                get:
+                function get(){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDay(GetSlot(this, p), this);
+                }},
+               {key: "calendarId",
+                get:
+                function get(){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarIdentifier(GetSlot(this, p));
+                }},
+               {key: "with",
+                value:
+                function _with(e, t){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid argument");
+                 RejectTemporalLikeObject(e);
+                 var
+                  r = GetOptionsObject(t),
+                  o = GetSlot(this, p),
+                  n = CalendarFields(o, ["day", "month", "monthCode", "year"]);
+                 var a = PrepareTemporalFields(this, n, []);
+                 return a =
+                         CalendarMergeFields
+                          (o, a, PrepareTemporalFields(e, n, "partial")),
+                        a = PrepareTemporalFields(a, n, []),
+                        CalendarMonthDayFromFields(o, a, r);
+                }},
+               {key: "equals",
+                value:
+                function equals(e){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalMonthDay(e);
+                 for
+                 (var _i26 = 0, _arr11 = [s, l, i];
+                  _i26 < _arr11.length;
+                  _i26++){
+                  var _e57 = _arr11[_i26];
+                  if(GetSlot(this, _e57) !== GetSlot(t, _e57)) return ! 1;
+                 }
+                 return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalMonthDayToString
+                         (this, ToCalendarNameOption(GetOptionsObject(e)));
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalMonthDayToString(this);
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return new ht(e, t).format(this);
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use equals() to compare Temporal.PlainMonthDay");
+                }},
+               {key: "toPlainDate",
+                value:
+                function toPlainDate(e){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e))
+                  throw new TypeError("argument should be an object");
+                 var
+                  t = GetSlot(this, p),
+                  r = CalendarFields(t, ["day", "monthCode"]),
+                  o = PrepareTemporalFields(this, r, []),
+                  n = CalendarFields(t, ["year"]);
+                 var
+                  a =
+                    CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
+                 a =
+                  PrepareTemporalFields
+                   (a,
+                    _toConsumableArray
+                     (new
+                       Set
+                       ([].concat(_toConsumableArray(r), _toConsumableArray(n)))),
+                    []);
+                 var i = bt(null);
+                 return i.overflow = "reject",
+                        CalendarDateFromFields(t, a, i);
+                }},
+               {key: "getISOFields",
+                value:
+                function getISOFields(){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return {calendar: GetSlot(this, p),
+                         isoDay: GetSlot(this, l),
+                         isoMonth: GetSlot(this, s),
+                         isoYear: GetSlot(this, i)};
+                }},
+               {key: "getCalendar",
+                value:
+                function getCalendar(){
+                 if(! IsTemporalMonthDay(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarObject(GetSlot(this, p));
+                }}],
+              [{key: "from",
+                value:
+                function from(e, t){
+                 var r = GetOptionsObject(t);
+                 return IsTemporalMonthDay(e)
+                         ? (ToTemporalOverflow
+                            (r),
+                           CreateTemporalMonthDay
+                            (GetSlot(e, s), GetSlot(e, l), GetSlot(e, p), GetSlot(e, i)))
+                         : ToTemporalMonthDay(e, r);
+                }}]);
     }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return TemporalMonthDayToString(this, ToCalendarNameOption(GetOptionsObject(e)));
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return TemporalMonthDayToString(this);
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return new ht(e, t).format(this);
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
-    }
-  }, {
-    key: "toPlainDate",
-    value: function toPlainDate(e) {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("argument should be an object");
-      var t = GetSlot(this, p),
-        r = CalendarFields(t, ["day", "monthCode"]),
-        o = PrepareTemporalFields(this, r, []),
-        n = CalendarFields(t, ["year"]);
-      var a = CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
-      a = PrepareTemporalFields(a, _toConsumableArray(new Set([].concat(_toConsumableArray(r), _toConsumableArray(n)))), []);
-      var i = bt(null);
-      return i.overflow = "reject", CalendarDateFromFields(t, a, i);
-    }
-  }, {
-    key: "getISOFields",
-    value: function getISOFields() {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return {
-        calendar: GetSlot(this, p),
-        isoDay: GetSlot(this, l),
-        isoMonth: GetSlot(this, s),
-        isoYear: GetSlot(this, i)
-      };
-    }
-  }, {
-    key: "getCalendar",
-    value: function getCalendar() {
-      if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarObject(GetSlot(this, p));
-    }
-  }], [{
-    key: "from",
-    value: function from(e, t) {
-      var r = GetOptionsObject(t);
-      return IsTemporalMonthDay(e) ? (ToTemporalOverflow(r), CreateTemporalMonthDay(GetSlot(e, s), GetSlot(e, l), GetSlot(e, p), GetSlot(e, i))) : ToTemporalMonthDay(e, r);
-    }
-  }]);
-  return PlainMonthDay;
-}();
+    ();
 MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
-var instant = function instant() {
-    return new (GetIntrinsic("%Temporal.Instant%"))(Ve());
-  },
-  plainDateTime = function plainDateTime(e) {
-    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultTimeZone();
-    var r = ToTemporalTimeZoneSlotValue(t),
-      o = ToTemporalCalendarSlotValue(e);
+var
+ instant =
+   function instant(){return new (GetIntrinsic("%Temporal.Instant%"))(Ve());},
+ plainDateTime =
+   function plainDateTime(e){
+    var
+     t =
+       arguments.length > 1 && arguments[1] !== undefined
+        ? arguments[1]
+        : DefaultTimeZone();
+    var
+     r = ToTemporalTimeZoneSlotValue(t),
+     o = ToTemporalCalendarSlotValue(e);
     return GetPlainDateTimeFor(r, instant(), o);
-  },
-  plainDateTimeISO = function plainDateTimeISO() {
-    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultTimeZone();
-    return GetPlainDateTimeFor(ToTemporalTimeZoneSlotValue(e), instant(), "iso8601");
-  },
-  zonedDateTime = function zonedDateTime(e) {
-    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultTimeZone();
-    var r = ToTemporalTimeZoneSlotValue(t),
-      o = ToTemporalCalendarSlotValue(e);
+   },
+ plainDateTimeISO =
+   function plainDateTimeISO(){
+    var
+     e =
+       arguments.length > 0 && arguments[0] !== undefined
+        ? arguments[0]
+        : DefaultTimeZone();
+    return GetPlainDateTimeFor
+            (ToTemporalTimeZoneSlotValue(e), instant(), "iso8601");
+   },
+ zonedDateTime =
+   function zonedDateTime(e){
+    var
+     t =
+       arguments.length > 1 && arguments[1] !== undefined
+        ? arguments[1]
+        : DefaultTimeZone();
+    var
+     r = ToTemporalTimeZoneSlotValue(t),
+     o = ToTemporalCalendarSlotValue(e);
     return CreateTemporalZonedDateTime(Ve(), r, o);
-  },
-  Et = _defineProperty({
-    instant: instant,
-    plainDateTime: plainDateTime,
-    plainDateTimeISO: plainDateTimeISO,
-    plainDate: function plainDate(e) {
-      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultTimeZone();
-      return TemporalDateTimeToDate(plainDateTime(e, t));
-    },
-    plainDateISO: function plainDateISO() {
-      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultTimeZone();
-      return TemporalDateTimeToDate(plainDateTimeISO(e));
-    },
-    plainTimeISO: function plainTimeISO() {
-      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultTimeZone();
-      return TemporalDateTimeToTime(plainDateTimeISO(e));
-    },
-    timeZoneId: function timeZoneId() {
-      return DefaultTimeZone();
-    },
-    zonedDateTime: zonedDateTime,
-    zonedDateTimeISO: function zonedDateTimeISO() {
-      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultTimeZone();
-      return zonedDateTime("iso8601", e);
-    }
-  }, Symbol.toStringTag, "Temporal.Now");
-Object.defineProperty(Et, Symbol.toStringTag, {
-  value: "Temporal.Now",
-  writable: !1,
-  enumerable: !1,
-  configurable: !0
-});
+   },
+ Et =
+   _defineProperty
+    ({instant: instant,
+      plainDateTime: plainDateTime,
+      plainDateTimeISO: plainDateTimeISO,
+      plainDate:
+      function plainDate(e){
+       var
+        t =
+          arguments.length > 1 && arguments[1] !== undefined
+           ? arguments[1]
+           : DefaultTimeZone();
+       return TemporalDateTimeToDate(plainDateTime(e, t));
+      },
+      plainDateISO:
+      function plainDateISO(){
+       var
+        e =
+          arguments.length > 0 && arguments[0] !== undefined
+           ? arguments[0]
+           : DefaultTimeZone();
+       return TemporalDateTimeToDate(plainDateTimeISO(e));
+      },
+      plainTimeISO:
+      function plainTimeISO(){
+       var
+        e =
+          arguments.length > 0 && arguments[0] !== undefined
+           ? arguments[0]
+           : DefaultTimeZone();
+       return TemporalDateTimeToTime(plainDateTimeISO(e));
+      },
+      timeZoneId: function timeZoneId(){return DefaultTimeZone();},
+      zonedDateTime: zonedDateTime,
+      zonedDateTimeISO:
+      function zonedDateTimeISO(){
+       var
+        e =
+          arguments.length > 0 && arguments[0] !== undefined
+           ? arguments[0]
+           : DefaultTimeZone();
+       return zonedDateTime("iso8601", e);
+      }},
+     Symbol.toStringTag,
+     "Temporal.Now");
+Object.defineProperty
+ (Et,
+  Symbol.toStringTag,
+  {value: "Temporal.Now", writable: ! 1, enumerable: ! 1, configurable: ! 0});
 var Mt = Object.assign;
-function TemporalTimeToString(e, t, r) {
-  var o = GetSlot(e, d),
-    n = GetSlot(e, m),
-    a = GetSlot(e, c),
-    i = GetSlot(e, h),
-    s = GetSlot(e, u),
-    l = GetSlot(e, T);
-  if (r) {
-    var _e58 = r.unit,
-      _t54 = r.increment,
-      _d12 = r.roundingMode;
-    var _RoundTime2 = RoundTime(o, n, a, i, s, l, _t54, _e58, _d12);
-    o = _RoundTime2.hour;
-    n = _RoundTime2.minute;
-    a = _RoundTime2.second;
-    i = _RoundTime2.millisecond;
-    s = _RoundTime2.microsecond;
-    l = _RoundTime2.nanosecond;
-  }
-  return "".concat(ISODateTimePartString(o), ":").concat(ISODateTimePartString(n)).concat(FormatSecondsStringPart(a, i, s, l, t));
-}
-var PlainTime = /*#__PURE__*/function () {
-  function PlainTime() {
-    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
-    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
-    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
-    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
-    var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
-    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
-    _classCallCheck(this, PlainTime);
-    var i = void 0 === e ? 0 : ToIntegerWithTruncation(e),
-      s = void 0 === t ? 0 : ToIntegerWithTruncation(t),
-      l = void 0 === r ? 0 : ToIntegerWithTruncation(r),
-      p = void 0 === o ? 0 : ToIntegerWithTruncation(o),
-      f = void 0 === n ? 0 : ToIntegerWithTruncation(n),
-      y = void 0 === a ? 0 : ToIntegerWithTruncation(a);
-    RejectTime(i, s, l, p, f, y), N(this), SetSlot(this, d, i), SetSlot(this, m, s), SetSlot(this, c, l), SetSlot(this, h, p), SetSlot(this, u, f), SetSlot(this, T, y);
-  }
-  _createClass(PlainTime, [{
-    key: "hour",
-    get: function get() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, d);
-    }
-  }, {
-    key: "minute",
-    get: function get() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, m);
-    }
-  }, {
-    key: "second",
-    get: function get() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, c);
-    }
-  }, {
-    key: "millisecond",
-    get: function get() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, h);
-    }
-  }, {
-    key: "microsecond",
-    get: function get() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, u);
-    }
-  }, {
-    key: "nanosecond",
-    get: function get() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, T);
-    }
-  }, {
-    key: "with",
-    value: function _with(e, t) {
-      var _RegulateTime4;
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument");
-      RejectTemporalLikeObject(e);
-      var r = ToTemporalOverflow(GetOptionsObject(t)),
-        o = ToTemporalTimeRecord(e, "partial"),
-        n = ToTemporalTimeRecord(this);
-      var _Mt = Mt(n, o),
-        a = _Mt.hour,
-        i = _Mt.minute,
-        s = _Mt.second,
-        l = _Mt.millisecond,
-        d = _Mt.microsecond,
-        m = _Mt.nanosecond;
-      return (_RegulateTime4 = RegulateTime(a, i, s, l, d, m, r), a = _RegulateTime4.hour, i = _RegulateTime4.minute, s = _RegulateTime4.second, l = _RegulateTime4.millisecond, d = _RegulateTime4.microsecond, m = _RegulateTime4.nanosecond), new PlainTime(a, i, s, l, d, m);
-    }
-  }, {
-    key: "add",
-    value: function add(e) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromPlainTime("add", this, e);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e);
-    }
-  }, {
-    key: "until",
-    value: function until(e, t) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainTime("until", this, e, t);
-    }
-  }, {
-    key: "since",
-    value: function since(e, t) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainTime("since", this, e, t);
-    }
-  }, {
-    key: "round",
-    value: function round(e) {
-      var _RoundTime3;
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      if (void 0 === e) throw new TypeError("options parameter is required");
-      var t = "string" == typeof e ? CreateOnePropObject("smallestUnit", e) : GetOptionsObject(e),
-        r = ToTemporalRoundingIncrement(t),
-        o = ToTemporalRoundingMode(t, "halfExpand"),
-        n = GetTemporalUnit(t, "smallestUnit", "time", He);
-      ValidateTemporalRoundingIncrement(r, {
-        hour: 24,
-        minute: 60,
-        second: 60,
-        millisecond: 1e3,
-        microsecond: 1e3,
-        nanosecond: 1e3
-      }[n], !1);
-      var a = GetSlot(this, d),
-        i = GetSlot(this, m),
-        s = GetSlot(this, c),
-        l = GetSlot(this, h),
-        p = GetSlot(this, u),
-        f = GetSlot(this, T);
-      return (_RoundTime3 = RoundTime(a, i, s, l, p, f, r, n, o), a = _RoundTime3.hour, i = _RoundTime3.minute, s = _RoundTime3.second, l = _RoundTime3.millisecond, p = _RoundTime3.microsecond, f = _RoundTime3.nanosecond), new PlainTime(a, i, s, l, p, f);
-    }
-  }, {
-    key: "equals",
-    value: function equals(e) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalTime(e);
-      for (var _i27 = 0, _arr12 = [d, m, c, h, u, T]; _i27 < _arr12.length; _i27++) {
-        var _e59 = _arr12[_i27];
-        if (GetSlot(this, _e59) !== GetSlot(t, _e59)) return !1;
-      }
-      return !0;
-    }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      var t = GetOptionsObject(e),
-        r = ToFractionalSecondDigits(t),
-        o = ToTemporalRoundingMode(t, "trunc"),
-        n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
-      if ("hour" === n) throw new RangeError('smallestUnit must be a time unit other than "hour"');
-      var _ToSecondsStringPreci4 = ToSecondsStringPrecisionRecord(n, r),
-        a = _ToSecondsStringPreci4.precision,
-        i = _ToSecondsStringPreci4.unit,
-        s = _ToSecondsStringPreci4.increment;
-      return TemporalTimeToString(this, a, {
-        unit: i,
-        increment: s,
-        roundingMode: o
-      });
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return TemporalTimeToString(this, "auto");
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return new ht(e, t).format(this);
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
-    }
-  }, {
-    key: "toPlainDateTime",
-    value: function toPlainDateTime(e) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e),
-        r = GetSlot(t, i),
-        o = GetSlot(t, s),
-        n = GetSlot(t, l),
-        a = GetSlot(t, p);
-      return CreateTemporalDateTime(r, o, n, GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), a);
-    }
-  }, {
-    key: "toZonedDateTime",
-    value: function toZonedDateTime(e) {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument");
-      var t = e.plainDate;
-      if (void 0 === t) throw new TypeError("missing date property");
-      var r = ToTemporalDate(t),
-        o = e.timeZone;
-      if (void 0 === o) throw new TypeError("missing timeZone property");
-      var a = ToTemporalTimeZoneSlotValue(o),
-        f = GetSlot(r, i),
-        y = GetSlot(r, s),
-        I = GetSlot(r, l),
-        S = GetSlot(r, p),
-        g = GetSlot(this, d),
-        w = GetSlot(this, m),
-        D = GetSlot(this, c),
-        G = GetSlot(this, h),
-        v = GetSlot(this, u),
-        C = GetSlot(this, T);
-      return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f, y, I, g, w, D, G, v, C, S), "compatible"), n), a, S);
-    }
-  }, {
-    key: "getISOFields",
-    value: function getISOFields() {
-      if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
-      return {
-        isoHour: GetSlot(this, d),
-        isoMicrosecond: GetSlot(this, u),
-        isoMillisecond: GetSlot(this, h),
-        isoMinute: GetSlot(this, m),
-        isoNanosecond: GetSlot(this, T),
-        isoSecond: GetSlot(this, c)
-      };
-    }
-  }], [{
-    key: "from",
-    value: function from(e, t) {
-      var r = ToTemporalOverflow(GetOptionsObject(t));
-      return IsTemporalTime(e) ? new PlainTime(GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T)) : ToTemporalTime(e, r);
-    }
-  }, {
-    key: "compare",
-    value: function compare(e, t) {
-      var r = ToTemporalTime(e),
-        o = ToTemporalTime(t);
-      for (var _i28 = 0, _arr13 = [d, m, c, h, u, T]; _i28 < _arr13.length; _i28++) {
-        var _e60 = _arr13[_i28];
-        var _t55 = GetSlot(r, _e60),
-          _n29 = GetSlot(o, _e60);
-        if (_t55 !== _n29) return ComparisonResult(_t55 - _n29);
-      }
-      return 0;
+function TemporalTimeToString(e, t, r){
+ var
+  o = GetSlot(e, d),
+  n = GetSlot(e, m),
+  a = GetSlot(e, c),
+  i = GetSlot(e, h),
+  s = GetSlot(e, u),
+  l = GetSlot(e, T);
+ if(r){
+  var _e58 = r.unit, _t54 = r.increment, _d12 = r.roundingMode;
+  var _RoundTime2 = RoundTime(o, n, a, i, s, l, _t54, _e58, _d12);
+  o = _RoundTime2.hour;
+  n = _RoundTime2.minute;
+  a = _RoundTime2.second;
+  i = _RoundTime2.millisecond;
+  s = _RoundTime2.microsecond;
+  l = _RoundTime2.nanosecond;
+ }
+ return "".concat(ISODateTimePartString(o), ":").concat
+          (ISODateTimePartString(n)).concat
+         (FormatSecondsStringPart(a, i, s, l, t));
+}
+var
+ PlainTime =
+   function(){
+     function PlainTime(){
+      var
+       e =
+         arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+      var
+       t =
+         arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+      var
+       r =
+         arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
+      var
+       o =
+         arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
+      var
+       n =
+         arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
+      var
+       a =
+         arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
+      _classCallCheck(this, PlainTime);
+      var
+       i = void 0 === e ? 0 : ToIntegerWithTruncation(e),
+       s = void 0 === t ? 0 : ToIntegerWithTruncation(t),
+       l = void 0 === r ? 0 : ToIntegerWithTruncation(r),
+       p = void 0 === o ? 0 : ToIntegerWithTruncation(o),
+       f = void 0 === n ? 0 : ToIntegerWithTruncation(n),
+       y = void 0 === a ? 0 : ToIntegerWithTruncation(a);
+      RejectTime(i, s, l, p, f, y),
+      N(this),
+      SetSlot(this, d, i),
+      SetSlot(this, m, s),
+      SetSlot(this, c, l),
+      SetSlot(this, h, p),
+      SetSlot(this, u, f),
+      SetSlot(this, T, y);
+     }
+     return _createClass
+             (PlainTime,
+              [{key: "hour",
+                get:
+                function get(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, d);
+                }},
+               {key: "minute",
+                get:
+                function get(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, m);
+                }},
+               {key: "second",
+                get:
+                function get(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, c);
+                }},
+               {key: "millisecond",
+                get:
+                function get(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, h);
+                }},
+               {key: "microsecond",
+                get:
+                function get(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, u);
+                }},
+               {key: "nanosecond",
+                get:
+                function get(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, T);
+                }},
+               {key: "with",
+                value:
+                function _with(e, t){
+                 var _RegulateTime4;
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid argument");
+                 RejectTemporalLikeObject(e);
+                 var
+                  r = ToTemporalOverflow(GetOptionsObject(t)),
+                  o = ToTemporalTimeRecord(e, "partial"),
+                  n = ToTemporalTimeRecord(this);
+                 var
+                  _Mt = Mt(n, o),
+                  a = _Mt.hour,
+                  i = _Mt.minute,
+                  s = _Mt.second,
+                  l = _Mt.millisecond,
+                  d = _Mt.microsecond,
+                  m = _Mt.nanosecond;
+                 return _RegulateTime4 = RegulateTime(a, i, s, l, d, m, r),
+                        a = _RegulateTime4.hour,
+                        i = _RegulateTime4.minute,
+                        s = _RegulateTime4.second,
+                        l = _RegulateTime4.millisecond,
+                        d = _RegulateTime4.microsecond,
+                        m = _RegulateTime4.nanosecond,
+                        new PlainTime(a, i, s, l, d, m);
+                }},
+               {key: "add",
+                value:
+                function add(e){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromPlainTime
+                         ("add", this, e);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromPlainTime
+                         ("subtract", this, e);
+                }},
+               {key: "until",
+                value:
+                function until(e, t){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainTime("until", this, e, t);
+                }},
+               {key: "since",
+                value:
+                function since(e, t){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainTime("since", this, e, t);
+                }},
+               {key: "round",
+                value:
+                function round(e){
+                 var _RoundTime3;
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(void 0 === e)
+                  throw new TypeError("options parameter is required");
+                 var
+                  t =
+                    "string" == typeof e
+                     ? CreateOnePropObject("smallestUnit", e)
+                     : GetOptionsObject(e),
+                  r = ToTemporalRoundingIncrement(t),
+                  o = ToTemporalRoundingMode(t, "halfExpand"),
+                  n = GetTemporalUnit(t, "smallestUnit", "time", He);
+                 ValidateTemporalRoundingIncrement
+                  (r,
+                   {hour: 24,
+                     minute: 60,
+                     second: 60,
+                     millisecond: 1e3,
+                     microsecond: 1e3,
+                     nanosecond: 1e3}
+                    [n],
+                   ! 1);
+                 var
+                  a = GetSlot(this, d),
+                  i = GetSlot(this, m),
+                  s = GetSlot(this, c),
+                  l = GetSlot(this, h),
+                  p = GetSlot(this, u),
+                  f = GetSlot(this, T);
+                 return _RoundTime3 = RoundTime(a, i, s, l, p, f, r, n, o),
+                        a = _RoundTime3.hour,
+                        i = _RoundTime3.minute,
+                        s = _RoundTime3.second,
+                        l = _RoundTime3.millisecond,
+                        p = _RoundTime3.microsecond,
+                        f = _RoundTime3.nanosecond,
+                        new PlainTime(a, i, s, l, p, f);
+                }},
+               {key: "equals",
+                value:
+                function equals(e){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalTime(e);
+                 for
+                 (var _i27 = 0, _arr12 = [d, m, c, h, u, T];
+                  _i27 < _arr12.length;
+                  _i27++){
+                  var _e59 = _arr12[_i27];
+                  if(GetSlot(this, _e59) !== GetSlot(t, _e59)) return ! 1;
+                 }
+                 return ! 0;
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetOptionsObject(e),
+                  r = ToFractionalSecondDigits(t),
+                  o = ToTemporalRoundingMode(t, "trunc"),
+                  n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
+                 if("hour" === n)
+                  throw new
+                         RangeError
+                         ('smallestUnit must be a time unit other than "hour"');
+                 var
+                  _ToSecondsStringPreci4 =
+                    ToSecondsStringPrecisionRecord(n, r),
+                  a = _ToSecondsStringPreci4.precision,
+                  i = _ToSecondsStringPreci4.unit,
+                  s = _ToSecondsStringPreci4.increment;
+                 return TemporalTimeToString
+                         (this, a, {unit: i, increment: s, roundingMode: o});
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalTimeToString(this, "auto");
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return new ht(e, t).format(this);
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() or equals() to compare Temporal.PlainTime");
+                }},
+               {key: "toPlainDateTime",
+                value:
+                function toPlainDateTime(e){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = ToTemporalDate(e),
+                  r = GetSlot(t, i),
+                  o = GetSlot(t, s),
+                  n = GetSlot(t, l),
+                  a = GetSlot(t, p);
+                 return CreateTemporalDateTime
+                         (r,
+                          o,
+                          n,
+                          GetSlot(this, d),
+                          GetSlot(this, m),
+                          GetSlot(this, c),
+                          GetSlot(this, h),
+                          GetSlot(this, u),
+                          GetSlot(this, T),
+                          a);
+                }},
+               {key: "toZonedDateTime",
+                value:
+                function toZonedDateTime(e){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid argument");
+                 var t = e.plainDate;
+                 if(void 0 === t)
+                  throw new TypeError("missing date property");
+                 var r = ToTemporalDate(t), o = e.timeZone;
+                 if(void 0 === o)
+                  throw new TypeError("missing timeZone property");
+                 var
+                  a = ToTemporalTimeZoneSlotValue(o),
+                  f = GetSlot(r, i),
+                  y = GetSlot(r, s),
+                  I = GetSlot(r, l),
+                  S = GetSlot(r, p),
+                  g = GetSlot(this, d),
+                  w = GetSlot(this, m),
+                  D = GetSlot(this, c),
+                  G = GetSlot(this, h),
+                  v = GetSlot(this, u),
+                  C = GetSlot(this, T);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot
+                           (GetInstantFor
+                             (a,
+                              new
+                               (GetIntrinsic("%Temporal.PlainDateTime%"))
+                               (f, y, I, g, w, D, G, v, C, S),
+                              "compatible"),
+                            n),
+                          a,
+                          S);
+                }},
+               {key: "getISOFields",
+                value:
+                function getISOFields(){
+                 if(! IsTemporalTime(this))
+                  throw new TypeError("invalid receiver");
+                 return {isoHour: GetSlot(this, d),
+                         isoMicrosecond: GetSlot(this, u),
+                         isoMillisecond: GetSlot(this, h),
+                         isoMinute: GetSlot(this, m),
+                         isoNanosecond: GetSlot(this, T),
+                         isoSecond: GetSlot(this, c)};
+                }}],
+              [{key: "from",
+                value:
+                function from(e, t){
+                 var r = ToTemporalOverflow(GetOptionsObject(t));
+                 return IsTemporalTime(e)
+                         ? new
+                           PlainTime
+                           (GetSlot(e, d),
+                            GetSlot(e, m),
+                            GetSlot(e, c),
+                            GetSlot(e, h),
+                            GetSlot(e, u),
+                            GetSlot(e, T))
+                         : ToTemporalTime(e, r);
+                }},
+               {key: "compare",
+                value:
+                function compare(e, t){
+                 var r = ToTemporalTime(e), o = ToTemporalTime(t);
+                 for
+                 (var _i28 = 0, _arr13 = [d, m, c, h, u, T];
+                  _i28 < _arr13.length;
+                  _i28++){
+                  var _e60 = _arr13[_i28];
+                  var _t55 = GetSlot(r, _e60), _n29 = GetSlot(o, _e60);
+                  if(_t55 !== _n29) return ComparisonResult(_t55 - _n29);
+                 }
+                 return 0;
+                }}]);
     }
-  }]);
-  return PlainTime;
-}();
+    ();
 MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
-var TimeZone = /*#__PURE__*/function () {
-  function TimeZone(e) {
-    _classCallCheck(this, TimeZone);
-    if (arguments.length < 1) throw new RangeError("missing argument: identifier is required");
-    var t = GetCanonicalTimeZoneIdentifier(e);
-    N(this), SetSlot(this, a, t);
-  }
-  _createClass(TimeZone, [{
-    key: "id",
-    get: function get() {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, a);
-    }
-  }, {
-    key: "getOffsetNanosecondsFor",
-    value: function getOffsetNanosecondsFor(e) {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalInstant(e),
-        r = GetSlot(this, a);
-      return IsTimeZoneOffsetString(r) ? ParseTimeZoneOffsetString(r) : GetNamedTimeZoneOffsetNanoseconds(r, GetSlot(t, n));
-    }
-  }, {
-    key: "getOffsetStringFor",
-    value: function getOffsetStringFor(e) {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      return GetOffsetStringFor(this, ToTemporalInstant(e));
-    }
-  }, {
-    key: "getPlainDateTimeFor",
-    value: function getPlainDateTimeFor(e) {
-      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "iso8601";
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      return GetPlainDateTimeFor(this, ToTemporalInstant(e), ToTemporalCalendarSlotValue(t));
-    }
-  }, {
-    key: "getInstantFor",
-    value: function getInstantFor(e, t) {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      return GetInstantFor(this, ToTemporalDateTime(e), ToTemporalDisambiguation(GetOptionsObject(t)));
-    }
-  }, {
-    key: "getPossibleInstantsFor",
-    value: function getPossibleInstantsFor(t) {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      var r = ToTemporalDateTime(t),
-        o = GetIntrinsic("%Temporal.Instant%"),
-        n = GetSlot(this, a);
-      if (IsTimeZoneOffsetString(n)) {
-        var _t56 = GetUTCEpochNanoseconds(GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(r, d), GetSlot(r, m), GetSlot(r, c), GetSlot(r, h), GetSlot(r, u), GetSlot(r, T));
-        if (null === _t56) throw new RangeError("DateTime outside of supported range");
-        var _a21 = ParseTimeZoneOffsetString(n);
-        return [new o(_t56 - BigInt(_a21))];
-      }
-      var p = function GetNamedTimeZoneEpochNanoseconds(t, r, o, n, a, i, s, l, d, m) {
-        var c = GetUTCEpochNanoseconds(r, o, n, a, i, s, l, d, m);
-        if (null === c) throw new RangeError("DateTime outside of supported range");
-        var h = c - Ee;
-        h < Me && (h = c);
-        var u = c + Ee;
-        u > Re && (u = c);
-        var T = GetNamedTimeZoneOffsetNanoseconds(t, h),
-          p = GetNamedTimeZoneOffsetNanoseconds(t, u);
-        return (T === p ? [T] : [T, p]).map(function (h) {
-          var u = c - BigInt(h),
-            T = GetNamedTimeZoneDateTimeParts(t, u);
-          if (r === T.year && o === T.month && n === T.day && a === T.hour && i === T.minute && s === T.second && l === T.millisecond && d === T.microsecond && m === T.nanosecond) return u;
-        }).filter(function (e) {
-          return void 0 !== e;
-        });
-      }(n, GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(r, d), GetSlot(r, m), GetSlot(r, c), GetSlot(r, h), GetSlot(r, u), GetSlot(r, T));
-      return p.map(function (e) {
-        return new o(e);
-      });
-    }
-  }, {
-    key: "getNextTransition",
-    value: function getNextTransition(e) {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalInstant(e),
-        r = GetSlot(this, a);
-      if (IsTimeZoneOffsetString(r) || "UTC" === r) return null;
-      var o = GetSlot(t, n);
-      var i = GetIntrinsic("%Temporal.Instant%");
-      return o = GetNamedTimeZoneNextTransition(r, o), null === o ? null : new i(o);
-    }
-  }, {
-    key: "getPreviousTransition",
-    value: function getPreviousTransition(e) {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalInstant(e),
-        r = GetSlot(this, a);
-      if (IsTimeZoneOffsetString(r) || "UTC" === r) return null;
-      var o = GetSlot(t, n);
-      var i = GetIntrinsic("%Temporal.Instant%");
-      return o = GetNamedTimeZonePreviousTransition(r, o), null === o ? null : new i(o);
-    }
-  }, {
-    key: "toString",
-    value: function toString() {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, a);
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
-      return GetSlot(this, a);
-    }
-  }], [{
-    key: "from",
-    value: function from(e) {
-      return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e));
-    }
-  }]);
-  return TimeZone;
-}();
-MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"), DefineIntrinsic("Temporal.TimeZone.prototype.getOffsetNanosecondsFor", TimeZone.prototype.getOffsetNanosecondsFor), DefineIntrinsic("Temporal.TimeZone.prototype.getPossibleInstantsFor", TimeZone.prototype.getPossibleInstantsFor);
+var
+ TimeZone =
+   function(){
+     function TimeZone(e){
+      _classCallCheck(this, TimeZone);
+      if(arguments.length < 1)
+       throw new RangeError("missing argument: identifier is required");
+      var t = GetCanonicalTimeZoneIdentifier(e);
+      N(this), SetSlot(this, a, t);
+     }
+     return _createClass
+             (TimeZone,
+              [{key: "id",
+                get:
+                function get(){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, a);
+                }},
+               {key: "getOffsetNanosecondsFor",
+                value:
+                function getOffsetNanosecondsFor(e){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalInstant(e), r = GetSlot(this, a);
+                 return IsTimeZoneOffsetString(r)
+                         ? ParseTimeZoneOffsetString(r)
+                         : GetNamedTimeZoneOffsetNanoseconds(r, GetSlot(t, n));
+                }},
+               {key: "getOffsetStringFor",
+                value:
+                function getOffsetStringFor(e){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 return GetOffsetStringFor(this, ToTemporalInstant(e));
+                }},
+               {key: "getPlainDateTimeFor",
+                value:
+                function getPlainDateTimeFor(e){
+                 var
+                  t =
+                    arguments.length > 1 && arguments[1] !== undefined
+                     ? arguments[1]
+                     : "iso8601";
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 return GetPlainDateTimeFor
+                         (this, ToTemporalInstant(e), ToTemporalCalendarSlotValue(t));
+                }},
+               {key: "getInstantFor",
+                value:
+                function getInstantFor(e, t){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 return GetInstantFor
+                         (this,
+                          ToTemporalDateTime(e),
+                          ToTemporalDisambiguation(GetOptionsObject(t)));
+                }},
+               {key: "getPossibleInstantsFor",
+                value:
+                function getPossibleInstantsFor(t){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  r = ToTemporalDateTime(t),
+                  o = GetIntrinsic("%Temporal.Instant%"),
+                  n = GetSlot(this, a);
+                 if(IsTimeZoneOffsetString(n)){
+                  var
+                   _t56 =
+                     GetUTCEpochNanoseconds
+                      (GetSlot(r, i),
+                       GetSlot(r, s),
+                       GetSlot(r, l),
+                       GetSlot(r, d),
+                       GetSlot(r, m),
+                       GetSlot(r, c),
+                       GetSlot(r, h),
+                       GetSlot(r, u),
+                       GetSlot(r, T));
+                  if(null === _t56)
+                   throw new RangeError("DateTime outside of supported range");
+                  var _a21 = ParseTimeZoneOffsetString(n);
+                  return [new o(_t56 - BigInt(_a21))];
+                 }
+                 var
+                  p =
+                    function GetNamedTimeZoneEpochNanoseconds
+                     (t, r, o, n, a, i, s, l, d, m){
+                      var c = GetUTCEpochNanoseconds(r, o, n, a, i, s, l, d, m);
+                      if(null === c)
+                       throw new RangeError("DateTime outside of supported range");
+                      var h = c - Ee;
+                      h < Me && (h = c);
+                      var u = c + Ee;
+                      u > Re && (u = c);
+                      var
+                       T = GetNamedTimeZoneOffsetNanoseconds(t, h),
+                       p = GetNamedTimeZoneOffsetNanoseconds(t, u);
+                      return (T === p ? [T] : [T, p]).map
+                               (function(h){
+                                 var
+                                  u = c - BigInt(h),
+                                  T = GetNamedTimeZoneDateTimeParts(t, u);
+                                 if
+                                  (r === T.year && o === T.month && n === T.day
+                                   && a === T.hour
+                                   && i === T.minute
+                                   && s === T.second
+                                   && l === T.millisecond
+                                   && d === T.microsecond
+                                   && m === T.nanosecond)
+                                  return u;
+                                }).filter
+                              (function(e){return void 0 !== e;});
+                     }
+                     (n,
+                      GetSlot(r, i),
+                      GetSlot(r, s),
+                      GetSlot(r, l),
+                      GetSlot(r, d),
+                      GetSlot(r, m),
+                      GetSlot(r, c),
+                      GetSlot(r, h),
+                      GetSlot(r, u),
+                      GetSlot(r, T));
+                 return p.map(function(e){return new o(e);});
+                }},
+               {key: "getNextTransition",
+                value:
+                function getNextTransition(e){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalInstant(e), r = GetSlot(this, a);
+                 if(IsTimeZoneOffsetString(r) || "UTC" === r) return null;
+                 var o = GetSlot(t, n);
+                 var i = GetIntrinsic("%Temporal.Instant%");
+                 return o = GetNamedTimeZoneNextTransition(r, o),
+                        null === o ? null : new i(o);
+                }},
+               {key: "getPreviousTransition",
+                value:
+                function getPreviousTransition(e){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalInstant(e), r = GetSlot(this, a);
+                 if(IsTimeZoneOffsetString(r) || "UTC" === r) return null;
+                 var o = GetSlot(t, n);
+                 var i = GetIntrinsic("%Temporal.Instant%");
+                 return o = GetNamedTimeZonePreviousTransition(r, o),
+                        null === o ? null : new i(o);
+                }},
+               {key: "toString",
+                value:
+                function toString(){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, a);
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalTimeZone(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(this, a);
+                }}],
+              [{key: "from",
+                value:
+                function from(e){
+                 return ToTemporalTimeZoneObject
+                         (ToTemporalTimeZoneSlotValue(e));
+                }}]);
+    }
+    ();
+MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"),
+DefineIntrinsic
+ ("Temporal.TimeZone.prototype.getOffsetNanosecondsFor",
+  TimeZone.prototype.getOffsetNanosecondsFor),
+DefineIntrinsic
+ ("Temporal.TimeZone.prototype.getPossibleInstantsFor",
+  TimeZone.prototype.getPossibleInstantsFor);
 var Rt = Object.create;
-var PlainYearMonth = /*#__PURE__*/function () {
-  function PlainYearMonth(e, t) {
-    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "iso8601";
-    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
-    _classCallCheck(this, PlainYearMonth);
-    CreateTemporalYearMonthSlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t), ToTemporalCalendarSlotValue(r), ToIntegerWithTruncation(o));
-  }
-  _createClass(PlainYearMonth, [{
-    key: "year",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "month",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarMonth(GetSlot(this, p), this);
-    }
-  }, {
-    key: "monthCode",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthCode(GetSlot(this, p), this);
-    }
-  }, {
-    key: "calendarId",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarIdentifier(GetSlot(this, p));
-    }
-  }, {
-    key: "era",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarEra(GetSlot(this, p), this);
-    }
-  }, {
-    key: "eraYear",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarEraYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInMonth",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInMonth(GetSlot(this, p), this);
-    }
-  }, {
-    key: "daysInYear",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "monthsInYear",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthsInYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "inLeapYear",
-    get: function get() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return CalendarInLeapYear(GetSlot(this, p), this);
-    }
-  }, {
-    key: "with",
-    value: function _with(e, t) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid argument");
-      RejectTemporalLikeObject(e);
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, p),
-        n = CalendarFields(o, ["month", "monthCode", "year"]);
-      var a = PrepareTemporalFields(this, n, []);
-      return a = CalendarMergeFields(o, a, PrepareTemporalFields(e, n, "partial")), a = PrepareTemporalFields(a, n, []), CalendarYearMonthFromFields(o, a, r);
-    }
-  }, {
-    key: "add",
-    value: function add(e, t) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e, t);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e, t) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e, t);
-    }
-  }, {
-    key: "until",
-    value: function until(e, t) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainYearMonth("until", this, e, t);
-    }
-  }, {
-    key: "since",
-    value: function since(e, t) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalPlainYearMonth("since", this, e, t);
-    }
-  }, {
-    key: "equals",
-    value: function equals(e) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalYearMonth(e);
-      for (var _i29 = 0, _arr14 = [i, s, l]; _i29 < _arr14.length; _i29++) {
-        var _e61 = _arr14[_i29];
-        if (GetSlot(this, _e61) !== GetSlot(t, _e61)) return !1;
-      }
-      return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+var
+ PlainYearMonth =
+   function(){
+     function PlainYearMonth(e, t){
+      var
+       r =
+         arguments.length > 2 && arguments[2] !== undefined
+          ? arguments[2]
+          : "iso8601";
+      var
+       o =
+         arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
+      _classCallCheck(this, PlainYearMonth);
+      CreateTemporalYearMonthSlots
+       (this,
+        ToIntegerWithTruncation(e),
+        ToIntegerWithTruncation(t),
+        ToTemporalCalendarSlotValue(r),
+        ToIntegerWithTruncation(o));
+     }
+     return _createClass
+             (PlainYearMonth,
+              [{key: "year",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYear(GetSlot(this, p), this);
+                }},
+               {key: "month",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonth(GetSlot(this, p), this);
+                }},
+               {key: "monthCode",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthCode(GetSlot(this, p), this);
+                }},
+               {key: "calendarId",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarIdentifier(GetSlot(this, p));
+                }},
+               {key: "era",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEra(GetSlot(this, p), this);
+                }},
+               {key: "eraYear",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEraYear(GetSlot(this, p), this);
+                }},
+               {key: "daysInMonth",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInMonth(GetSlot(this, p), this);
+                }},
+               {key: "daysInYear",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInYear(GetSlot(this, p), this);
+                }},
+               {key: "monthsInYear",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthsInYear(GetSlot(this, p), this);
+                }},
+               {key: "inLeapYear",
+                get:
+                function get(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarInLeapYear(GetSlot(this, p), this);
+                }},
+               {key: "with",
+                value:
+                function _with(e, t){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e)) throw new TypeError("invalid argument");
+                 RejectTemporalLikeObject(e);
+                 var
+                  r = GetOptionsObject(t),
+                  o = GetSlot(this, p),
+                  n = CalendarFields(o, ["month", "monthCode", "year"]);
+                 var a = PrepareTemporalFields(this, n, []);
+                 return a =
+                         CalendarMergeFields
+                          (o, a, PrepareTemporalFields(e, n, "partial")),
+                        a = PrepareTemporalFields(a, n, []),
+                        CalendarYearMonthFromFields(o, a, r);
+                }},
+               {key: "add",
+                value:
+                function add(e, t){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromPlainYearMonth
+                         ("add", this, e, t);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e, t){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromPlainYearMonth
+                         ("subtract", this, e, t);
+                }},
+               {key: "until",
+                value:
+                function until(e, t){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainYearMonth("until", this, e, t);
+                }},
+               {key: "since",
+                value:
+                function since(e, t){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalPlainYearMonth("since", this, e, t);
+                }},
+               {key: "equals",
+                value:
+                function equals(e){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalYearMonth(e);
+                 for
+                 (var _i29 = 0, _arr14 = [i, s, l];
+                  _i29 < _arr14.length;
+                  _i29++){
+                  var _e61 = _arr14[_i29];
+                  if(GetSlot(this, _e61) !== GetSlot(t, _e61)) return ! 1;
+                 }
+                 return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalYearMonthToString
+                         (this, ToCalendarNameOption(GetOptionsObject(e)));
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalYearMonthToString(this);
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return new ht(e, t).format(this);
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() or equals() to compare Temporal.PlainYearMonth");
+                }},
+               {key: "toPlainDate",
+                value:
+                function toPlainDate(e){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e))
+                  throw new TypeError("argument should be an object");
+                 var
+                  t = GetSlot(this, p),
+                  r = CalendarFields(t, ["monthCode", "year"]),
+                  o = PrepareTemporalFields(this, r, []),
+                  n = CalendarFields(t, ["day"]);
+                 var
+                  a =
+                    CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
+                 a =
+                  PrepareTemporalFields
+                   (a,
+                    _toConsumableArray
+                     (new
+                       Set
+                       ([].concat(_toConsumableArray(r), _toConsumableArray(n)))),
+                    []);
+                 var i = Rt(null);
+                 return i.overflow = "reject",
+                        CalendarDateFromFields(t, a, i);
+                }},
+               {key: "getISOFields",
+                value:
+                function getISOFields(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return {calendar: GetSlot(this, p),
+                         isoDay: GetSlot(this, l),
+                         isoMonth: GetSlot(this, s),
+                         isoYear: GetSlot(this, i)};
+                }},
+               {key: "getCalendar",
+                value:
+                function getCalendar(){
+                 if(! IsTemporalYearMonth(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarObject(GetSlot(this, p));
+                }}],
+              [{key: "from",
+                value:
+                function from(e, t){
+                 var r = GetOptionsObject(t);
+                 return IsTemporalYearMonth(e)
+                         ? (ToTemporalOverflow
+                            (r),
+                           CreateTemporalYearMonth
+                            (GetSlot(e, i), GetSlot(e, s), GetSlot(e, p), GetSlot(e, l)))
+                         : ToTemporalYearMonth(e, r);
+                }},
+               {key: "compare",
+                value:
+                function compare(e, t){
+                 var r = ToTemporalYearMonth(e), o = ToTemporalYearMonth(t);
+                 return CompareISODate
+                         (GetSlot(r, i),
+                          GetSlot(r, s),
+                          GetSlot(r, l),
+                          GetSlot(o, i),
+                          GetSlot(o, s),
+                          GetSlot(o, l));
+                }}]);
     }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return TemporalYearMonthToString(this, ToCalendarNameOption(GetOptionsObject(e)));
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return TemporalYearMonthToString(this);
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return new ht(e, t).format(this);
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
-    }
-  }, {
-    key: "toPlainDate",
-    value: function toPlainDate(e) {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("argument should be an object");
-      var t = GetSlot(this, p),
-        r = CalendarFields(t, ["monthCode", "year"]),
-        o = PrepareTemporalFields(this, r, []),
-        n = CalendarFields(t, ["day"]);
-      var a = CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
-      a = PrepareTemporalFields(a, _toConsumableArray(new Set([].concat(_toConsumableArray(r), _toConsumableArray(n)))), []);
-      var i = Rt(null);
-      return i.overflow = "reject", CalendarDateFromFields(t, a, i);
-    }
-  }, {
-    key: "getISOFields",
-    value: function getISOFields() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return {
-        calendar: GetSlot(this, p),
-        isoDay: GetSlot(this, l),
-        isoMonth: GetSlot(this, s),
-        isoYear: GetSlot(this, i)
-      };
-    }
-  }, {
-    key: "getCalendar",
-    value: function getCalendar() {
-      if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarObject(GetSlot(this, p));
-    }
-  }], [{
-    key: "from",
-    value: function from(e, t) {
-      var r = GetOptionsObject(t);
-      return IsTemporalYearMonth(e) ? (ToTemporalOverflow(r), CreateTemporalYearMonth(GetSlot(e, i), GetSlot(e, s), GetSlot(e, p), GetSlot(e, l))) : ToTemporalYearMonth(e, r);
-    }
-  }, {
-    key: "compare",
-    value: function compare(e, t) {
-      var r = ToTemporalYearMonth(e),
-        o = ToTemporalYearMonth(t);
-      return CompareISODate(GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(o, i), GetSlot(o, s), GetSlot(o, l));
-    }
-  }]);
-  return PlainYearMonth;
-}();
+    ();
 MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
-var Ft = ht.prototype.resolvedOptions,
-  Yt = Object.create;
-var ZonedDateTime = /*#__PURE__*/function () {
-  function ZonedDateTime(e, t) {
-    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "iso8601";
-    _classCallCheck(this, ZonedDateTime);
-    if (arguments.length < 1) throw new TypeError("missing argument: epochNanoseconds is required");
-    CreateTemporalZonedDateTimeSlots(this, ToBigInt(e), ToTemporalTimeZoneSlotValue(t), ToTemporalCalendarSlotValue(r));
-  }
-  _createClass(ZonedDateTime, [{
-    key: "calendarId",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarIdentifier(GetSlot(this, p));
-    }
-  }, {
-    key: "timeZoneId",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
-    }
-  }, {
-    key: "year",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "month",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarMonth(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "monthCode",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthCode(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "day",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDay(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "hour",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(dateTime(this), d);
-    }
-  }, {
-    key: "minute",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(dateTime(this), m);
-    }
-  }, {
-    key: "second",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(dateTime(this), c);
-    }
-  }, {
-    key: "millisecond",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(dateTime(this), h);
-    }
-  }, {
-    key: "microsecond",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(dateTime(this), u);
-    }
-  }, {
-    key: "nanosecond",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetSlot(dateTime(this), T);
-    }
-  }, {
-    key: "era",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarEra(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "eraYear",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarEraYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "epochSeconds",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = GetSlot(this, n);
-      return Number(BigIntFloorDiv(t, ve));
-    }
-  }, {
-    key: "epochMilliseconds",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = GetSlot(this, n);
-      return Number(BigIntFloorDiv(t, Ge));
-    }
-  }, {
-    key: "epochMicroseconds",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
-    }
-  }, {
-    key: "epochNanoseconds",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return ToBigIntExternal(GetSlot(this, n));
-    }
-  }, {
-    key: "dayOfWeek",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "dayOfYear",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "weekOfYear",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "yearOfWeek",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "hoursInDay",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = dateTime(this),
-        r = GetIntrinsic("%Temporal.PlainDateTime%"),
-        o = GetSlot(t, i),
-        a = GetSlot(t, s),
-        d = GetSlot(t, l),
-        m = new r(o, a, d, 0, 0, 0, 0, 0, 0),
-        c = AddISODate(o, a, d, 0, 0, 0, 1, "reject"),
-        h = new r(c.year, c.month, c.day, 0, 0, 0, 0, 0, 0),
-        u = GetSlot(this, g),
-        T = GetSlot(GetInstantFor(u, m, "compatible"), n),
-        p = GetSlot(GetInstantFor(u, h, "compatible"), n);
-      return BigIntDivideToNumber(p - T, Oe);
-    }
-  }, {
-    key: "daysInWeek",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "daysInMonth",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "daysInYear",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "monthsInYear",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "inLeapYear",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
-    }
-  }, {
-    key: "offset",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
-    }
-  }, {
-    key: "offsetNanoseconds",
-    get: function get() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return GetOffsetNanosecondsFor(GetSlot(this, g), GetSlot(this, S));
-    }
-  }, {
-    key: "with",
-    value: function _with(e, t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      if (!IsObject(e)) throw new TypeError("invalid zoned-date-time-like");
-      RejectTemporalLikeObject(e);
-      var r = GetOptionsObject(t),
-        o = GetSlot(this, p);
-      var n = CalendarFields(o, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
-      n.push("offset");
-      var a = PrepareTemporalFields(this, n, ["offset"]);
-      a = CalendarMergeFields(o, a, PrepareTemporalFields(e, n, "partial")), a = PrepareTemporalFields(a, n, ["offset"]);
-      var i = ToTemporalDisambiguation(r),
-        s = ToTemporalOffset(r, "prefer");
-      var _InterpretTemporalDat5 = InterpretTemporalDateTimeFields(o, a, r),
-        l = _InterpretTemporalDat5.year,
-        d = _InterpretTemporalDat5.month,
-        m = _InterpretTemporalDat5.day,
-        c = _InterpretTemporalDat5.hour,
-        h = _InterpretTemporalDat5.minute,
-        u = _InterpretTemporalDat5.second,
-        T = _InterpretTemporalDat5.millisecond,
-        f = _InterpretTemporalDat5.microsecond,
-        y = _InterpretTemporalDat5.nanosecond;
-      var I = ParseTimeZoneOffsetString(a.offset),
-        S = GetSlot(this, g);
-      return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(l, d, m, c, h, u, T, f, y, "option", I, S, i, s, !1), S, o);
-    }
-  }, {
-    key: "withPlainDate",
-    value: function withPlainDate(e) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalDate(e),
-        r = GetSlot(t, i),
-        o = GetSlot(t, s),
-        a = GetSlot(t, l);
-      var f = GetSlot(t, p);
-      var y = dateTime(this),
-        I = GetSlot(y, d),
-        S = GetSlot(y, m),
-        w = GetSlot(y, c),
-        D = GetSlot(y, h),
-        G = GetSlot(y, u),
-        v = GetSlot(y, T);
-      f = ConsolidateCalendars(GetSlot(this, p), f);
-      var C = GetSlot(this, g);
-      return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(C, new (GetIntrinsic("%Temporal.PlainDateTime%"))(r, o, a, I, S, w, D, G, v, f), "compatible"), n), C, f);
-    }
-  }, {
-    key: "withPlainTime",
-    value: function withPlainTime(e) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = GetIntrinsic("%Temporal.PlainTime%"),
-        r = void 0 === e ? new t() : ToTemporalTime(e),
-        o = dateTime(this),
-        a = GetSlot(o, i),
-        f = GetSlot(o, s),
-        y = GetSlot(o, l),
-        I = GetSlot(this, p),
-        S = GetSlot(r, d),
-        w = GetSlot(r, m),
-        D = GetSlot(r, c),
-        G = GetSlot(r, h),
-        v = GetSlot(r, u),
-        C = GetSlot(r, T),
-        O = GetSlot(this, g);
-      return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(O, new (GetIntrinsic("%Temporal.PlainDateTime%"))(a, f, y, S, w, D, G, v, C, I), "compatible"), n), O, I);
-    }
-  }, {
-    key: "withTimeZone",
-    value: function withTimeZone(e) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalTimeZoneSlotValue(e);
-      return CreateTemporalZonedDateTime(GetSlot(this, n), t, GetSlot(this, p));
-    }
-  }, {
-    key: "withCalendar",
-    value: function withCalendar(e) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = ToTemporalCalendarSlotValue(e);
-      return CreateTemporalZonedDateTime(GetSlot(this, n), GetSlot(this, g), t);
-    }
-  }, {
-    key: "add",
-    value: function add(e, t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e, t);
-    }
-  }, {
-    key: "subtract",
-    value: function subtract(e, t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e, t);
-    }
-  }, {
-    key: "until",
-    value: function until(e, t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalZonedDateTime("until", this, e, t);
-    }
-  }, {
-    key: "since",
-    value: function since(e, t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return DifferenceTemporalZonedDateTime("since", this, e, t);
-    }
-  }, {
-    key: "round",
-    value: function round(t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      if (void 0 === t) throw new TypeError("options parameter is required");
-      var r = "string" == typeof t ? CreateOnePropObject("smallestUnit", t) : GetOptionsObject(t),
-        o = ToTemporalRoundingIncrement(r),
-        a = ToTemporalRoundingMode(r, "halfExpand"),
-        f = GetTemporalUnit(r, "smallestUnit", "time", He, ["day"]),
-        y = {
-          day: 1,
-          hour: 24,
-          minute: 60,
-          second: 60,
-          millisecond: 1e3,
-          microsecond: 1e3,
-          nanosecond: 1e3
-        }[f];
-      ValidateTemporalRoundingIncrement(o, y, 1 === y);
-      var I = dateTime(this);
-      var w = GetSlot(I, i),
-        D = GetSlot(I, s),
-        G = GetSlot(I, l),
-        v = GetSlot(I, d),
-        C = GetSlot(I, m),
-        O = GetSlot(I, c),
-        b = GetSlot(I, h),
-        E = GetSlot(I, u),
-        M = GetSlot(I, T);
-      var R = GetIntrinsic("%Temporal.PlainDateTime%"),
-        F = GetSlot(this, g),
-        Y = GetSlot(this, p),
-        P = GetInstantFor(F, new R(GetSlot(I, i), GetSlot(I, s), GetSlot(I, l), 0, 0, 0, 0, 0, 0), "compatible"),
-        Z = AddZonedDateTime(P, F, Y, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0),
-        B = Z - BigInt(GetSlot(P, n));
-      if (B <= Ie) throw new RangeError("cannot round a ZonedDateTime in a calendar with zero or negative length days");
-      var _RoundISODateTime3 = RoundISODateTime(w, D, G, v, C, O, b, E, M, o, f, a, Number(B));
-      w = _RoundISODateTime3.year;
-      D = _RoundISODateTime3.month;
-      G = _RoundISODateTime3.day;
-      v = _RoundISODateTime3.hour;
-      C = _RoundISODateTime3.minute;
-      O = _RoundISODateTime3.second;
-      b = _RoundISODateTime3.millisecond;
-      E = _RoundISODateTime3.microsecond;
-      M = _RoundISODateTime3.nanosecond;
-      return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(w, D, G, v, C, O, b, E, M, "option", GetOffsetNanosecondsFor(F, GetSlot(this, S)), F, "compatible", "prefer", !1), F, GetSlot(this, p));
-    }
-  }, {
-    key: "equals",
-    value: function equals(t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var r = ToTemporalZonedDateTime(t),
-        o = GetSlot(this, n),
-        a = GetSlot(r, n);
-      return !!(BigInt(o) === BigInt(a)) && !!TimeZoneEquals(GetSlot(this, g), GetSlot(r, g)) && CalendarEquals(GetSlot(this, p), GetSlot(r, p));
-    }
-  }, {
-    key: "toString",
-    value: function toString(e) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var t = GetOptionsObject(e),
-        r = ToCalendarNameOption(t),
-        o = ToFractionalSecondDigits(t),
-        n = function ToShowOffsetOption(e) {
-          return GetOption(e, "offset", ["auto", "never"], "auto");
-        }(t),
-        a = ToTemporalRoundingMode(t, "trunc"),
-        i = GetTemporalUnit(t, "smallestUnit", "time", void 0);
-      if ("hour" === i) throw new RangeError('smallestUnit must be a time unit other than "hour"');
-      var s = function ToTimeZoneNameOption(e) {
-          return GetOption(e, "timeZoneName", ["auto", "never", "critical"], "auto");
-        }(t),
-        _ToSecondsStringPreci5 = ToSecondsStringPrecisionRecord(i, o),
-        l = _ToSecondsStringPreci5.precision,
-        d = _ToSecondsStringPreci5.unit,
-        m = _ToSecondsStringPreci5.increment;
-      return TemporalZonedDateTimeToString(this, l, r, s, n, {
-        unit: d,
-        increment: m,
-        roundingMode: a
-      });
-    }
-  }, {
-    key: "toLocaleString",
-    value: function toLocaleString(e, t) {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var r = GetOptionsObject(t),
-        o = Yt(null);
-      if (CopyDataProperties(o, r, ["timeZone"]), void 0 !== r.timeZone) throw new TypeError("ZonedDateTime toLocaleString does not accept a timeZone option");
-      void 0 === o.year && void 0 === o.month && void 0 === o.day && void 0 === o.weekday && void 0 === o.dateStyle && void 0 === o.hour && void 0 === o.minute && void 0 === o.second && void 0 === o.timeStyle && void 0 === o.dayPeriod && void 0 === o.timeZoneName && (o.timeZoneName = "short");
-      var n = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
-      if (IsTimeZoneOffsetString(n)) throw new RangeError("toLocaleString does not support offset string time zones");
-      n = GetCanonicalTimeZoneIdentifier(n), o.timeZone = n;
-      var a = new ht(e, o),
-        i = Call(Ft, a, []).calendar,
-        s = ToTemporalCalendarIdentifier(GetSlot(this, p));
-      if ("iso8601" !== s && "iso8601" !== i && i !== s) throw new RangeError("cannot format ZonedDateTime with calendar ".concat(s, " in locale with calendar ").concat(i));
-      return a.format(GetSlot(this, S));
-    }
-  }, {
-    key: "toJSON",
-    value: function toJSON() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return TemporalZonedDateTimeToString(this, "auto");
-    }
-  }, {
-    key: "valueOf",
-    value: function valueOf() {
-      throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
-    }
-  }, {
-    key: "startOfDay",
-    value: function startOfDay() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var e = dateTime(this),
-        t = GetIntrinsic("%Temporal.PlainDateTime%"),
-        r = GetSlot(this, p),
-        o = new t(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), 0, 0, 0, 0, 0, 0, r),
-        a = GetSlot(this, g);
-      return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a, o, "compatible"), n), a, r);
-    }
-  }, {
-    key: "toInstant",
-    value: function toInstant() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
-    }
-  }, {
-    key: "toPlainDate",
-    value: function toPlainDate() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return TemporalDateTimeToDate(dateTime(this));
-    }
-  }, {
-    key: "toPlainTime",
-    value: function toPlainTime() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return TemporalDateTimeToTime(dateTime(this));
-    }
-  }, {
-    key: "toPlainDateTime",
-    value: function toPlainDateTime() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return dateTime(this);
-    }
-  }, {
-    key: "toPlainYearMonth",
-    value: function toPlainYearMonth() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var e = GetSlot(this, p);
-      return CalendarYearMonthFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["monthCode", "year"]), []));
-    }
-  }, {
-    key: "toPlainMonthDay",
-    value: function toPlainMonthDay() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var e = GetSlot(this, p);
-      return CalendarMonthDayFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["day", "monthCode"]), []));
-    }
-  }, {
-    key: "getISOFields",
-    value: function getISOFields() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      var e = dateTime(this),
-        t = GetSlot(this, g);
-      return {
-        calendar: GetSlot(this, p),
-        isoDay: GetSlot(e, l),
-        isoHour: GetSlot(e, d),
-        isoMicrosecond: GetSlot(e, u),
-        isoMillisecond: GetSlot(e, h),
-        isoMinute: GetSlot(e, m),
-        isoMonth: GetSlot(e, s),
-        isoNanosecond: GetSlot(e, T),
-        isoSecond: GetSlot(e, c),
-        isoYear: GetSlot(e, i),
-        offset: GetOffsetStringFor(t, GetSlot(this, S)),
-        timeZone: t
-      };
-    }
-  }, {
-    key: "getCalendar",
-    value: function getCalendar() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return ToTemporalCalendarObject(GetSlot(this, p));
-    }
-  }, {
-    key: "getTimeZone",
-    value: function getTimeZone() {
-      if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
-      return ToTemporalTimeZoneObject(GetSlot(this, g));
-    }
-  }], [{
-    key: "from",
-    value: function from(e, t) {
-      var r = GetOptionsObject(t);
-      return IsTemporalZonedDateTime(e) ? (ToTemporalDisambiguation(r), ToTemporalOffset(r, "reject"), ToTemporalOverflow(r), CreateTemporalZonedDateTime(GetSlot(e, n), GetSlot(e, g), GetSlot(e, p))) : ToTemporalZonedDateTime(e, r);
-    }
-  }, {
-    key: "compare",
-    value: function compare(t, r) {
-      var o = ToTemporalZonedDateTime(t),
-        a = ToTemporalZonedDateTime(r),
-        i = GetSlot(o, n),
-        s = GetSlot(a, n);
-      return BigInt(i) < BigInt(s) ? -1 : BigInt(i) > BigInt(s) ? 1 : 0;
-    }
-  }]);
-  return ZonedDateTime;
-}();
-function dateTime(e) {
-  return GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
+var Ft = ht.prototype.resolvedOptions, Yt = Object.create;
+var
+ ZonedDateTime =
+   function(){
+     function ZonedDateTime(e, t){
+      var
+       r =
+         arguments.length > 2 && arguments[2] !== undefined
+          ? arguments[2]
+          : "iso8601";
+      _classCallCheck(this, ZonedDateTime);
+      if(arguments.length < 1)
+       throw new TypeError("missing argument: epochNanoseconds is required");
+      CreateTemporalZonedDateTimeSlots
+       (this,
+        ToBigInt(e),
+        ToTemporalTimeZoneSlotValue(t),
+        ToTemporalCalendarSlotValue(r));
+     }
+     return _createClass
+             (ZonedDateTime,
+              [{key: "calendarId",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarIdentifier(GetSlot(this, p));
+                }},
+               {key: "timeZoneId",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
+                }},
+               {key: "year",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "month",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonth(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "monthCode",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthCode(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "day",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDay(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "hour",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(dateTime(this), d);
+                }},
+               {key: "minute",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(dateTime(this), m);
+                }},
+               {key: "second",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(dateTime(this), c);
+                }},
+               {key: "millisecond",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(dateTime(this), h);
+                }},
+               {key: "microsecond",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(dateTime(this), u);
+                }},
+               {key: "nanosecond",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetSlot(dateTime(this), T);
+                }},
+               {key: "era",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEra(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "eraYear",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarEraYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "epochSeconds",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = GetSlot(this, n);
+                 return Number(BigIntFloorDiv(t, ve));
+                }},
+               {key: "epochMilliseconds",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = GetSlot(this, n);
+                 return Number(BigIntFloorDiv(t, Ge));
+                }},
+               {key: "epochMicroseconds",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
+                }},
+               {key: "epochNanoseconds",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToBigIntExternal(GetSlot(this, n));
+                }},
+               {key: "dayOfWeek",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "dayOfYear",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "weekOfYear",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "yearOfWeek",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "hoursInDay",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = dateTime(this),
+                  r = GetIntrinsic("%Temporal.PlainDateTime%"),
+                  o = GetSlot(t, i),
+                  a = GetSlot(t, s),
+                  d = GetSlot(t, l),
+                  m = new r(o, a, d, 0, 0, 0, 0, 0, 0),
+                  c = AddISODate(o, a, d, 0, 0, 0, 1, "reject"),
+                  h = new r(c.year, c.month, c.day, 0, 0, 0, 0, 0, 0),
+                  u = GetSlot(this, g),
+                  T = GetSlot(GetInstantFor(u, m, "compatible"), n),
+                  p = GetSlot(GetInstantFor(u, h, "compatible"), n);
+                 return BigIntDivideToNumber(p - T, Oe);
+                }},
+               {key: "daysInWeek",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "daysInMonth",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "daysInYear",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "monthsInYear",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "inLeapYear",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
+                }},
+               {key: "offset",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
+                }},
+               {key: "offsetNanoseconds",
+                get:
+                function get(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return GetOffsetNanosecondsFor
+                         (GetSlot(this, g), GetSlot(this, S));
+                }},
+               {key: "with",
+                value:
+                function _with(e, t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(! IsObject(e))
+                  throw new TypeError("invalid zoned-date-time-like");
+                 RejectTemporalLikeObject(e);
+                 var r = GetOptionsObject(t), o = GetSlot(this, p);
+                 var
+                  n =
+                    CalendarFields
+                     (o,
+                      ["day",
+                       "hour",
+                       "microsecond",
+                       "millisecond",
+                       "minute",
+                       "month",
+                       "monthCode",
+                       "nanosecond",
+                       "second",
+                       "year"]);
+                 n.push("offset");
+                 var a = PrepareTemporalFields(this, n, ["offset"]);
+                 a =
+                  CalendarMergeFields
+                   (o, a, PrepareTemporalFields(e, n, "partial")),
+                 a = PrepareTemporalFields(a, n, ["offset"]);
+                 var
+                  i = ToTemporalDisambiguation(r),
+                  s = ToTemporalOffset(r, "prefer");
+                 var
+                  _InterpretTemporalDat5 =
+                    InterpretTemporalDateTimeFields(o, a, r),
+                  l = _InterpretTemporalDat5.year,
+                  d = _InterpretTemporalDat5.month,
+                  m = _InterpretTemporalDat5.day,
+                  c = _InterpretTemporalDat5.hour,
+                  h = _InterpretTemporalDat5.minute,
+                  u = _InterpretTemporalDat5.second,
+                  T = _InterpretTemporalDat5.millisecond,
+                  f = _InterpretTemporalDat5.microsecond,
+                  y = _InterpretTemporalDat5.nanosecond;
+                 var
+                  I = ParseTimeZoneOffsetString(a.offset),
+                  S = GetSlot(this, g);
+                 return CreateTemporalZonedDateTime
+                         (InterpretISODateTimeOffset
+                           (l, d, m, c, h, u, T, f, y, "option", I, S, i, s, ! 1),
+                          S,
+                          o);
+                }},
+               {key: "withPlainDate",
+                value:
+                function withPlainDate(e){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = ToTemporalDate(e),
+                  r = GetSlot(t, i),
+                  o = GetSlot(t, s),
+                  a = GetSlot(t, l);
+                 var f = GetSlot(t, p);
+                 var
+                  y = dateTime(this),
+                  I = GetSlot(y, d),
+                  S = GetSlot(y, m),
+                  w = GetSlot(y, c),
+                  D = GetSlot(y, h),
+                  G = GetSlot(y, u),
+                  v = GetSlot(y, T);
+                 f = ConsolidateCalendars(GetSlot(this, p), f);
+                 var C = GetSlot(this, g);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot
+                           (GetInstantFor
+                             (C,
+                              new
+                               (GetIntrinsic("%Temporal.PlainDateTime%"))
+                               (r, o, a, I, S, w, D, G, v, f),
+                              "compatible"),
+                            n),
+                          C,
+                          f);
+                }},
+               {key: "withPlainTime",
+                value:
+                function withPlainTime(e){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetIntrinsic("%Temporal.PlainTime%"),
+                  r = void 0 === e ? new t() : ToTemporalTime(e),
+                  o = dateTime(this),
+                  a = GetSlot(o, i),
+                  f = GetSlot(o, s),
+                  y = GetSlot(o, l),
+                  I = GetSlot(this, p),
+                  S = GetSlot(r, d),
+                  w = GetSlot(r, m),
+                  D = GetSlot(r, c),
+                  G = GetSlot(r, h),
+                  v = GetSlot(r, u),
+                  C = GetSlot(r, T),
+                  O = GetSlot(this, g);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot
+                           (GetInstantFor
+                             (O,
+                              new
+                               (GetIntrinsic("%Temporal.PlainDateTime%"))
+                               (a, f, y, S, w, D, G, v, C, I),
+                              "compatible"),
+                            n),
+                          O,
+                          I);
+                }},
+               {key: "withTimeZone",
+                value:
+                function withTimeZone(e){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalTimeZoneSlotValue(e);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot(this, n), t, GetSlot(this, p));
+                }},
+               {key: "withCalendar",
+                value:
+                function withCalendar(e){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var t = ToTemporalCalendarSlotValue(e);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot(this, n), GetSlot(this, g), t);
+                }},
+               {key: "add",
+                value:
+                function add(e, t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromZonedDateTime
+                         ("add", this, e, t);
+                }},
+               {key: "subtract",
+                value:
+                function subtract(e, t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return AddDurationToOrSubtractDurationFromZonedDateTime
+                         ("subtract", this, e, t);
+                }},
+               {key: "until",
+                value:
+                function until(e, t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalZonedDateTime("until", this, e, t);
+                }},
+               {key: "since",
+                value:
+                function since(e, t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return DifferenceTemporalZonedDateTime("since", this, e, t);
+                }},
+               {key: "round",
+                value:
+                function round(t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 if(void 0 === t)
+                  throw new TypeError("options parameter is required");
+                 var
+                  r =
+                    "string" == typeof t
+                     ? CreateOnePropObject("smallestUnit", t)
+                     : GetOptionsObject(t),
+                  o = ToTemporalRoundingIncrement(r),
+                  a = ToTemporalRoundingMode(r, "halfExpand"),
+                  f = GetTemporalUnit(r, "smallestUnit", "time", He, ["day"]),
+                  y =
+                    {day: 1,
+                      hour: 24,
+                      minute: 60,
+                      second: 60,
+                      millisecond: 1e3,
+                      microsecond: 1e3,
+                      nanosecond: 1e3}
+                     [f];
+                 ValidateTemporalRoundingIncrement(o, y, 1 === y);
+                 var I = dateTime(this);
+                 var
+                  w = GetSlot(I, i),
+                  D = GetSlot(I, s),
+                  G = GetSlot(I, l),
+                  v = GetSlot(I, d),
+                  C = GetSlot(I, m),
+                  O = GetSlot(I, c),
+                  b = GetSlot(I, h),
+                  E = GetSlot(I, u),
+                  M = GetSlot(I, T);
+                 var
+                  R = GetIntrinsic("%Temporal.PlainDateTime%"),
+                  F = GetSlot(this, g),
+                  Y = GetSlot(this, p),
+                  P =
+                    GetInstantFor
+                     (F,
+                      new
+                       R
+                       (GetSlot(I, i),
+                        GetSlot(I, s),
+                        GetSlot(I, l),
+                        0,
+                        0,
+                        0,
+                        0,
+                        0,
+                        0),
+                      "compatible"),
+                  Z = AddZonedDateTime(P, F, Y, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0),
+                  B = Z - BigInt(GetSlot(P, n));
+                 if(B <= Ie)
+                  throw new
+                         RangeError
+                         ("cannot round a ZonedDateTime in a calendar with zero or negative length days");
+                 var
+                  _RoundISODateTime3 =
+                    RoundISODateTime
+                     (w, D, G, v, C, O, b, E, M, o, f, a, Number(B));
+                 w = _RoundISODateTime3.year;
+                 D = _RoundISODateTime3.month;
+                 G = _RoundISODateTime3.day;
+                 v = _RoundISODateTime3.hour;
+                 C = _RoundISODateTime3.minute;
+                 O = _RoundISODateTime3.second;
+                 b = _RoundISODateTime3.millisecond;
+                 E = _RoundISODateTime3.microsecond;
+                 M = _RoundISODateTime3.nanosecond;
+                 return CreateTemporalZonedDateTime
+                         (InterpretISODateTimeOffset
+                           (w,
+                            D,
+                            G,
+                            v,
+                            C,
+                            O,
+                            b,
+                            E,
+                            M,
+                            "option",
+                            GetOffsetNanosecondsFor(F, GetSlot(this, S)),
+                            F,
+                            "compatible",
+                            "prefer",
+                            ! 1),
+                          F,
+                          GetSlot(this, p));
+                }},
+               {key: "equals",
+                value:
+                function equals(t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  r = ToTemporalZonedDateTime(t),
+                  o = GetSlot(this, n),
+                  a = GetSlot(r, n);
+                 return !
+                        !
+                        (BigInt(o) === BigInt(a))
+                        && ! ! TimeZoneEquals(GetSlot(this, g), GetSlot(r, g))
+                        && CalendarEquals(GetSlot(this, p), GetSlot(r, p));
+                }},
+               {key: "toString",
+                value:
+                function toString(e){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  t = GetOptionsObject(e),
+                  r = ToCalendarNameOption(t),
+                  o = ToFractionalSecondDigits(t),
+                  n =
+                    function ToShowOffsetOption(e){
+                      return GetOption(e, "offset", ["auto", "never"], "auto");
+                     }
+                     (t),
+                  a = ToTemporalRoundingMode(t, "trunc"),
+                  i = GetTemporalUnit(t, "smallestUnit", "time", void 0);
+                 if("hour" === i)
+                  throw new
+                         RangeError
+                         ('smallestUnit must be a time unit other than "hour"');
+                 var
+                  s =
+                    function ToTimeZoneNameOption(e){
+                      return GetOption
+                              (e, "timeZoneName", ["auto", "never", "critical"], "auto");
+                     }
+                     (t),
+                  _ToSecondsStringPreci5 =
+                    ToSecondsStringPrecisionRecord(i, o),
+                  l = _ToSecondsStringPreci5.precision,
+                  d = _ToSecondsStringPreci5.unit,
+                  m = _ToSecondsStringPreci5.increment;
+                 return TemporalZonedDateTimeToString
+                         (this, l, r, s, n, {unit: d, increment: m, roundingMode: a});
+                }},
+               {key: "toLocaleString",
+                value:
+                function toLocaleString(e, t){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var r = GetOptionsObject(t), o = Yt(null);
+                 if
+                  (CopyDataProperties(o, r, ["timeZone"]),
+                   void 0 !== r.timeZone)
+                  throw new
+                         TypeError
+                         ("ZonedDateTime toLocaleString does not accept a timeZone option");
+                 void 0 === o.year && void 0 === o.month && void 0 === o.day
+                 && void 0 === o.weekday
+                 && void 0 === o.dateStyle
+                 && void 0 === o.hour
+                 && void 0 === o.minute
+                 && void 0 === o.second
+                 && void 0 === o.timeStyle
+                 && void 0 === o.dayPeriod
+                 && void 0 === o.timeZoneName
+                 && (o.timeZoneName = "short");
+                 var n = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
+                 if(IsTimeZoneOffsetString(n))
+                  throw new
+                         RangeError
+                         ("toLocaleString does not support offset string time zones");
+                 n = GetCanonicalTimeZoneIdentifier(n), o.timeZone = n;
+                 var
+                  a = new ht(e, o),
+                  i = Call(Ft, a, []).calendar,
+                  s = ToTemporalCalendarIdentifier(GetSlot(this, p));
+                 if("iso8601" !== s && "iso8601" !== i && i !== s)
+                  throw new
+                         RangeError
+                         ("cannot format ZonedDateTime with calendar ".concat
+                            (s, " in locale with calendar ").concat
+                           (i));
+                 return a.format(GetSlot(this, S));
+                }},
+               {key: "toJSON",
+                value:
+                function toJSON(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalZonedDateTimeToString(this, "auto");
+                }},
+               {key: "valueOf",
+                value:
+                function valueOf(){
+                 throw new
+                        TypeError
+                        ("use compare() or equals() to compare Temporal.ZonedDateTime");
+                }},
+               {key: "startOfDay",
+                value:
+                function startOfDay(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var
+                  e = dateTime(this),
+                  t = GetIntrinsic("%Temporal.PlainDateTime%"),
+                  r = GetSlot(this, p),
+                  o =
+                    new
+                     t
+                     (GetSlot(e, i),
+                      GetSlot(e, s),
+                      GetSlot(e, l),
+                      0,
+                      0,
+                      0,
+                      0,
+                      0,
+                      0,
+                      r),
+                  a = GetSlot(this, g);
+                 return CreateTemporalZonedDateTime
+                         (GetSlot(GetInstantFor(a, o, "compatible"), n), a, r);
+                }},
+               {key: "toInstant",
+                value:
+                function toInstant(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return new
+                         (GetIntrinsic("%Temporal.Instant%"))
+                         (GetSlot(this, n));
+                }},
+               {key: "toPlainDate",
+                value:
+                function toPlainDate(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateTimeToDate(dateTime(this));
+                }},
+               {key: "toPlainTime",
+                value:
+                function toPlainTime(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return TemporalDateTimeToTime(dateTime(this));
+                }},
+               {key: "toPlainDateTime",
+                value:
+                function toPlainDateTime(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return dateTime(this);
+                }},
+               {key: "toPlainYearMonth",
+                value:
+                function toPlainYearMonth(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var e = GetSlot(this, p);
+                 return CalendarYearMonthFromFields
+                         (e,
+                          PrepareTemporalFields
+                           (this, CalendarFields(e, ["monthCode", "year"]), []));
+                }},
+               {key: "toPlainMonthDay",
+                value:
+                function toPlainMonthDay(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var e = GetSlot(this, p);
+                 return CalendarMonthDayFromFields
+                         (e,
+                          PrepareTemporalFields
+                           (this, CalendarFields(e, ["day", "monthCode"]), []));
+                }},
+               {key: "getISOFields",
+                value:
+                function getISOFields(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 var e = dateTime(this), t = GetSlot(this, g);
+                 return {calendar: GetSlot(this, p),
+                         isoDay: GetSlot(e, l),
+                         isoHour: GetSlot(e, d),
+                         isoMicrosecond: GetSlot(e, u),
+                         isoMillisecond: GetSlot(e, h),
+                         isoMinute: GetSlot(e, m),
+                         isoMonth: GetSlot(e, s),
+                         isoNanosecond: GetSlot(e, T),
+                         isoSecond: GetSlot(e, c),
+                         isoYear: GetSlot(e, i),
+                         offset: GetOffsetStringFor(t, GetSlot(this, S)),
+                         timeZone: t};
+                }},
+               {key: "getCalendar",
+                value:
+                function getCalendar(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalCalendarObject(GetSlot(this, p));
+                }},
+               {key: "getTimeZone",
+                value:
+                function getTimeZone(){
+                 if(! IsTemporalZonedDateTime(this))
+                  throw new TypeError("invalid receiver");
+                 return ToTemporalTimeZoneObject(GetSlot(this, g));
+                }}],
+              [{key: "from",
+                value:
+                function from(e, t){
+                 var r = GetOptionsObject(t);
+                 return IsTemporalZonedDateTime(e)
+                         ? (ToTemporalDisambiguation
+                            (r),
+                           ToTemporalOffset(r, "reject"),
+                           ToTemporalOverflow(r),
+                           CreateTemporalZonedDateTime
+                            (GetSlot(e, n), GetSlot(e, g), GetSlot(e, p)))
+                         : ToTemporalZonedDateTime(e, r);
+                }},
+               {key: "compare",
+                value:
+                function compare(t, r){
+                 var
+                  o = ToTemporalZonedDateTime(t),
+                  a = ToTemporalZonedDateTime(r),
+                  i = GetSlot(o, n),
+                  s = GetSlot(a, n);
+                 return BigInt(i) < BigInt(s)
+                         ? - 1
+                         : BigInt(i) > BigInt(s) ? 1 : 0;
+                }}]);
+    }
+    ();
+function dateTime(e){
+ return GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
 }
 MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
-var Pt = Object.freeze({
-  __proto__: null,
-  Calendar: Calendar,
-  Duration: Duration,
-  Instant: Instant,
-  Now: Et,
-  PlainDate: PlainDate,
-  PlainDateTime: PlainDateTime,
-  PlainMonthDay: PlainMonthDay,
-  PlainTime: PlainTime,
-  PlainYearMonth: PlainYearMonth,
-  TimeZone: TimeZone,
-  ZonedDateTime: ZonedDateTime
-});
-function toTemporalInstant() {
-  var t = BigInt(+this) * Ge;
-  return new Instant(t);
-}
-var Zt = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime];
-for (var _i30 = 0, _Zt = Zt; _i30 < _Zt.length; _i30++) {
-  var _e62 = _Zt[_i30];
-  var _t57 = Object.getOwnPropertyDescriptor(_e62, "prototype");
-  (_t57.configurable || _t57.enumerable || _t57.writable) && (_t57.configurable = !1, _t57.enumerable = !1, _t57.writable = !1, Object.defineProperty(_e62, "prototype", _t57));
-}
-
-var TemporalPolyfill = /*#__PURE__*/Object.freeze({
-  __proto__: null,
-  Intl: ut,
-  Temporal: Pt,
-  toTemporalInstant: toTemporalInstant
-});
-
+var
+ Pt =
+   Object.freeze
+    ({__proto__: null,
+      Calendar: Calendar,
+      Duration: Duration,
+      Instant: Instant,
+      Now: Et,
+      PlainDate: PlainDate,
+      PlainDateTime: PlainDateTime,
+      PlainMonthDay: PlainMonthDay,
+      PlainTime: PlainTime,
+      PlainYearMonth: PlainYearMonth,
+      TimeZone: TimeZone,
+      ZonedDateTime: ZonedDateTime});
+function toTemporalInstant(){
+ var t = BigInt(+ this) * Ge;
+ return new Instant(t);
+}
+var
+ Zt =
+   [Instant,
+    Calendar,
+    PlainDate,
+    PlainDateTime,
+    Duration,
+    PlainMonthDay,
+    PlainTime,
+    TimeZone,
+    PlainYearMonth,
+    ZonedDateTime];
+for(var _i30 = 0, _Zt = Zt; _i30 < _Zt.length; _i30++){
+ var _e62 = _Zt[_i30];
+ var _t57 = Object.getOwnPropertyDescriptor(_e62, "prototype");
+ (_t57.configurable || _t57.enumerable || _t57.writable)
+ &&
+  (_t57.configurable = ! 1,
+   _t57.enumerable = ! 1,
+   _t57.writable = ! 1,
+   Object.defineProperty(_e62, "prototype", _t57));
+}
+var
+ TemporalPolyfill =
+   Object.freeze
+    ({__proto__: null,
+      Intl: ut,
+      Temporal: Pt,
+      toTemporalInstant: toTemporalInstant});
 globalThis.TemporalPolyfill = TemporalPolyfill;
Index: core-0.17.1/core/src/time.ml
===================================================================
--- core-0.17.1.orig/core/src/time.ml
+++ core-0.17.1/core/src/time.ml
@@ -24,6 +24,11 @@ module Make (Time0 : Time0_intf.S) = str
       |> Time0.Span.of_int63_seconds
     ;;
 
+    let to_span_in_seconds_round_down span =
+      Time0.Span.to_int63_seconds_round_down_exn span
+      |> Time_in_seconds.Span.of_int63_seconds
+    ;;
+
     let of_time_in_seconds time_in_seconds =
       Time_in_seconds.to_span_since_epoch time_in_seconds
       (* NB. no actual rounding or exns can occur here *)
@@ -46,6 +51,14 @@ module Make (Time0 : Time0_intf.S) = str
       |> Time_in_seconds.Date_and_ofday.of_synthetic_span_since_epoch
     ;;
 
+    let of_utc_offset_in_seconds_round_down ?name span =
+      of_utc_offset_in_seconds_round_down ?name (to_span_in_seconds_round_down span)
+    ;;
+
+    let add_offset_in_seconds_round_down t ~name ~span =
+      add_offset_in_seconds_round_down t ~name ~span:(to_span_in_seconds_round_down span)
+    ;;
+
     let index t time = index t (to_time_in_seconds_round_down_exn time)
 
     let index_of_date_and_ofday t relative =
Index: core-0.17.1/core/src/time0_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/time0_intf.ml
+++ core-0.17.1/core/src/time0_intf.ml
@@ -34,31 +34,31 @@ module type S = sig
 
   include
     Comparable.S_common
-      with type t := t
-       and module Replace_polymorphic_compare := Replace_polymorphic_compare
+    with type t := t
+     and module Replace_polymorphic_compare := Replace_polymorphic_compare
 
   (** Equivalent to a [Date.t] and an [Ofday.t] with no time zone. A [Date_and_ofday.t]
       does not correspond to a single, unambiguous point in time. *)
   module Date_and_ofday : sig
-    type absolute = t
-    type t = private underlying
+      type absolute = t
+      type t = private underlying
 
-    (** {2 Constructors and accessors} *)
+      (** {2 Constructors and accessors} *)
 
-    val of_date_ofday : Date0.t -> Ofday.t -> t
-    val to_date_ofday : t -> Date0.t * Ofday.t
-    val to_date : t -> Date0.t
-    val to_ofday : t -> Ofday.t
+      val of_date_ofday : Date0.t -> Ofday.t -> t
+      val to_date_ofday : t -> Date0.t * Ofday.t
+      val to_date : t -> Date0.t
+      val to_ofday : t -> Ofday.t
 
-    (** {2 Conversions between absolute times and date + ofday}
+      (** {2 Conversions between absolute times and date + ofday}
 
         Based on the offset from UTC at the given time. It is usually simpler to use the
         [Time.Zone] wrappers of these conversions. *)
 
-    val of_absolute : absolute -> offset_from_utc:Span.t -> t
-    val to_absolute : t -> offset_from_utc:Span.t -> absolute
+      val of_absolute : absolute -> offset_from_utc:Span.t -> t
+      val to_absolute : t -> offset_from_utc:Span.t -> absolute
 
-    (** {2 Low-level conversions}
+      (** {2 Low-level conversions}
 
         Convert between [t] and a synthetic span representing the difference in date from
         epoch, times the length of a day, plus the ofday's distance from midnight.
@@ -71,10 +71,10 @@ module type S = sig
         These functions are intended for low-level DST transition arithmetic. Most clients
         should not call these functions directly. *)
 
-    val of_synthetic_span_since_epoch : Span.t -> t
-    val to_synthetic_span_since_epoch : t -> Span.t
-  end
-  with type absolute := t
+      val of_synthetic_span_since_epoch : Span.t -> t
+      val to_synthetic_span_since_epoch : t -> Span.t
+    end
+    with type absolute := t
 
   (** [next_multiple ~base ~after ~interval] returns the smallest [time] of the form:
 
Index: core-0.17.1/core/src/time_float.ml
===================================================================
--- core-0.17.1.orig/core/src/time_float.ml
+++ core-0.17.1/core/src/time_float.ml
@@ -1,154 +1,442 @@
-open! Import
 open! Std_internal
+open! Import
+
+module Time = struct
+  include Time.Make (Time_float0)
+  include Time_float0
+end
+
+include Time
+
+module Span = struct
+  include Time.Span
+
+  let arg_type = Command.Arg_type.create of_string
+end
+
+module Zone = struct
+  include Time.Zone
+  include (Timezone : Timezone.Extend_zone with type t := t)
+
+  let arg_type = Command.Arg_type.create of_string
+end
+
+module Ofday = struct
+  include Time.Ofday
+
+  let arg_type = Command.Arg_type.create of_string
+  let now ~zone = Time.to_ofday ~zone (Time.now ())
+
+  module Zoned = struct
+    type t =
+      { ofday : Time.Ofday.t
+      ; zone : Zone.t
+      }
+    [@@deriving bin_io, fields ~getters, compare, equal, hash]
+
+    type sexp_repr = Time.Ofday.t * Zone.t [@@deriving sexp]
+
+    let sexp_of_t t = [%sexp_of: sexp_repr] (t.ofday, t.zone)
+
+    let t_of_sexp sexp =
+      let ofday, zone = [%of_sexp: sexp_repr] sexp in
+      { ofday; zone }
+    ;;
+
+    let to_time t date = Time.of_date_ofday ~zone:(zone t) date (ofday t)
+    let create ofday zone = { ofday; zone }
+    let create_local ofday = create ofday (Lazy.force Zone.local)
+
+    let of_string string : t =
+      match String.split string ~on:' ' with
+      | [ ofday; zone ] ->
+        { ofday = Time.Ofday.of_string ofday; zone = Zone.of_string zone }
+      | _ -> failwithf "Ofday.Zoned.of_string %s" string ()
+    ;;
+
+    let to_string (t : t) : string =
+      String.concat [ Time.Ofday.to_string t.ofday; " "; Zone.to_string t.zone ]
+    ;;
+
+    let to_string_trimmed (t : t) : string =
+      String.concat [ Time.Ofday.to_string_trimmed t.ofday; " "; Zone.to_string t.zone ]
+    ;;
+
+    let arg_type = Command.Arg_type.create of_string
+
+    module With_nonchronological_compare = struct
+      type nonrec t = t [@@deriving bin_io, compare, equal, sexp, hash]
+    end
+
+    include Pretty_printer.Register (struct
+        type nonrec t = t
+
+        let to_string = to_string
+        let module_name = "Core.Time_float.Ofday.Zoned"
+      end)
+  end
+end
+
+module T = struct
+  include (
+    Time :
+      module type of Time
+      with module Zone := Time.Zone
+       and module Ofday := Time.Ofday
+       and module Span := Time.Span
+       and module Stable := Time.Stable)
+
+  let of_date_ofday_zoned date ofday_zoned = Ofday.Zoned.to_time ofday_zoned date
+
+  let to_date_ofday_zoned t ~zone =
+    let date, ofday = to_date_ofday t ~zone in
+    date, Ofday.Zoned.create ofday zone
+  ;;
+
+  let to_ofday_zoned t ~zone =
+    let ofday = to_ofday t ~zone in
+    Ofday.Zoned.create ofday zone
+  ;;
+
+  let of_string_fix_proto utc str =
+    try
+      let expect_length = 21 in
+      (* = 8 + 1 + 12 *)
+      let expect_dash = 8 in
+      if Char.( <> ) str.[expect_dash] '-'
+      then failwithf "no dash in position %d" expect_dash ();
+      let zone =
+        match utc with
+        | `Utc -> Zone.utc
+        | `Local -> Lazy.force Zone.local
+      in
+      if Int.( > ) (String.length str) expect_length then failwithf "input too long" ();
+      of_date_ofday
+        ~zone
+        (Date0.of_string_iso8601_basic str ~pos:0)
+        (Ofday.of_string_iso8601_extended str ~pos:(expect_dash + 1))
+    with
+    | exn -> invalid_argf "Time.of_string_fix_proto %s: %s" str (Exn.to_string exn) ()
+  ;;
+
+  let to_string_fix_proto utc t =
+    let zone =
+      match utc with
+      | `Utc -> Zone.utc
+      | `Local -> Lazy.force Zone.local
+    in
+    let date, sec = to_date_ofday t ~zone in
+    Date0.to_string_iso8601_basic date ^ "-" ^ Ofday.to_millisecond_string sec
+  ;;
+
+  let to_string t = to_string_abs t ~zone:(Lazy.force Zone.local)
+
+  let ensure_colon_in_offset offset =
+    if Char.( = ) offset.[1] ':' || Char.( = ) offset.[2] ':'
+    then offset
+    else (
+      let offset_length = String.length offset in
+      if Int.( < ) offset_length 3 || Int.( > ) offset_length 4
+      then failwithf "invalid offset %s" offset ()
+      else
+        String.concat
+          [ String.slice offset 0 (offset_length - 2)
+          ; ":"
+          ; String.slice offset (offset_length - 2) offset_length
+          ])
+  ;;
+
+  exception Time_string_not_absolute of string [@@deriving sexp]
+
+  let of_string_gen ~if_no_timezone s =
+    let default_zone () =
+      match if_no_timezone with
+      | `Fail -> raise (Time_string_not_absolute s)
+      | `Local -> Lazy.force Zone.local
+      | `Use_this_one zone -> zone
+    in
+    of_string_gen ~default_zone ~find_zone:Zone.find_exn s
+  ;;
+
+  let of_string_abs s = of_string_gen ~if_no_timezone:`Fail s
+  let of_string s = of_string_gen ~if_no_timezone:`Local s
+  let arg_type = Command.Arg_type.create of_string_abs
+
+  include Pretty_printer.Register (struct
+      type nonrec t = t
+
+      let to_string = to_string
+      let module_name = "Core.Time_float"
+    end)
+
+  let sexp_zone = ref Zone.local
+  let get_sexp_zone () = Lazy.force !sexp_zone
+  let set_sexp_zone zone = sexp_zone := lazy zone
+
+  let t_of_sexp_gen ~if_no_timezone sexp =
+    try
+      match sexp with
+      | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday; Sexp.Atom tz ] ->
+        of_date_ofday
+          ~zone:(Zone.find_exn tz)
+          (Date0.of_string date)
+          (Ofday.of_string ofday)
+      (* This is actually where the output of [sexp_of_t] is handled, since that's e.g.
+         (2015-07-06 09:09:44.787988+01:00). *)
+      | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday_and_possibly_zone ] ->
+        of_string_gen ~if_no_timezone (date ^ " " ^ ofday_and_possibly_zone)
+      | Sexp.Atom datetime -> of_string_gen ~if_no_timezone datetime
+      | _ -> of_sexp_error "Time.t_of_sexp" sexp
+    with
+    | Of_sexp_error _ as e -> raise e
+    | e -> of_sexp_error (sprintf "Time.t_of_sexp: %s" (Exn.to_string e)) sexp
+  ;;
+
+  let t_of_sexp sexp =
+    t_of_sexp_gen sexp ~if_no_timezone:(`Use_this_one (Lazy.force !sexp_zone))
+  ;;
+
+  let t_sexp_grammar : t Sexplib.Sexp_grammar.t =
+    { untyped =
+        Union
+          [ String
+          ; List (Cons (String, Cons (String, Empty)))
+          ; List (Cons (String, Cons (String, Cons (String, Empty))))
+          ]
+    }
+  ;;
+
+  let t_of_sexp_abs sexp = t_of_sexp_gen sexp ~if_no_timezone:`Fail
+
+  let sexp_of_t_abs t ~zone =
+    Sexp.List (List.map (Time.to_string_abs_parts ~zone t) ~f:(fun s -> Sexp.Atom s))
+  ;;
+
+  let sexp_of_t t = sexp_of_t_abs ~zone:(Lazy.force !sexp_zone) t
+
+  include (
+  struct
+    module C = struct
+      type nonrec t = t [@@deriving bin_io]
+      type nonrec comparator_witness = comparator_witness
+
+      let comparator = comparator
+      let sexp_of_t = sexp_of_t
+
+      (* In 108.06a and earlier, times in sexps of Maps and Sets were raw floats.  From
+         108.07 through 109.13, the output format remained raw as before, but both the raw
+         and pretty format were accepted as input.  From 109.14 on, the output format was
+         changed from raw to pretty, while continuing to accept both formats.  Once we
+         believe most programs are beyond 109.14, we will switch the input format to no
+         longer accept raw. *)
+      let t_of_sexp sexp =
+        match
+          Option.try_with (fun () ->
+            of_span_since_epoch (Span.of_sec (Float.t_of_sexp sexp)))
+        with
+        | Some t -> t
+        | None -> t_of_sexp sexp
+      ;;
+    end
 
-module type S_kernel_without_zone = Time0_intf.S
-module type S_kernel = Time_intf.S
+    include C
+    module Map = Map.Make_binable_using_comparator (C)
+    module Set = Set.Make_binable_using_comparator (C)
+  end :
+    Comparable.Map_and_set_binable
+    with type t := t
+     and type comparator_witness := comparator_witness)
+
+  let%test _ =
+    Set.equal
+      (Set.of_list [ epoch ])
+      (Set.t_of_sexp
+         (Sexp.List [ Float.sexp_of_t (Span.to_sec (to_span_since_epoch epoch)) ]))
+  ;;
 
-module Zone_stable = Zone.Stable
-include Time.Make (Time_float0)
-include Time_float0
+  module Exposed_for_tests = struct
+    let ensure_colon_in_offset = ensure_colon_in_offset
+  end
+end
+
+include Diffable.Atomic.Make (T)
+
+(* Previous versions rendered hash-based containers using float serialization rather than
+   time serialization, so when reading hash-based containers in we accept either
+   serialization. *)
+include Hashable.Make_binable (struct
+    type t = Time.t [@@deriving bin_io, compare, hash]
+
+    let sexp_of_t = T.sexp_of_t
+
+    let t_of_sexp sexp =
+      match Float.t_of_sexp sexp with
+      | float -> Time.of_span_since_epoch (Time.Span.of_sec float)
+      | exception _ -> T.t_of_sexp sexp
+    ;;
+  end)
 
 module Stable = struct
-  include Time_float0.Stable
-  module V1 = struct end
-  module With_t_of_sexp_abs = struct end
+  module V1 = struct
+    (* There is no simple, pristine implementation of "stable time", and in fact
+       [Time.Stable.V1] has always called out to "unstable" string conversions.
+       For a complicated "stable" story like this, we rely on comprehensive tests
+       of stability; see [lib/core/test/src/test_time.ml]. *)
+    include T
+    include Diffable.Atomic.Make (T)
 
-  module Ofday = struct
-    include Ofday
-    module Zoned = struct end
+    let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
+
+    module Map = struct
+      include Map
+
+      let stable_witness _ = Stable_witness.assert_stable
+    end
+
+    module Set = struct
+      include Set
+
+      let stable_witness = Stable_witness.assert_stable
+    end
   end
 
   module With_utc_sexp = struct
-    module V1 = struct end
+    module V1 = struct
+      module C = struct
+        include (
+          V1 : module type of V1 with module Map := V1.Map and module Set := V1.Set)
+
+        let sexp_of_t t = sexp_of_t_abs t ~zone:Zone.utc
+      end
+
+      include C
+      module Map = Map.Make_binable_using_comparator (C)
+      module Set = Set.Make_binable_using_comparator (C)
+    end
 
     module V2 = struct
-      type nonrec t = t [@@deriving bin_io, compare, hash]
+      module C = struct
+        type nonrec t = t [@@deriving bin_io, compare, hash]
 
-      let sexp_of_t t = [%sexp (to_string_abs_parts t ~zone:Zone.utc : string list)]
-      let stable_witness = Stable_witness.assert_stable
+        let sexp_of_t t = [%sexp (to_string_abs_parts t ~zone:Zone.utc : string list)]
+        let stable_witness = Stable_witness.assert_stable
 
-      let t_of_sexp sexp =
-        try
-          match sexp with
-          | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday_and_possibly_zone ] ->
-            of_string_gen
-              ~default_zone:(fun () -> Zone.utc)
-              ~find_zone:(fun _ ->
-                of_sexp_error "Time.Stable.With_utc.V2.t_of_sexp: unknown time zone" sexp)
-              (date ^ " " ^ ofday_and_possibly_zone)
-          | _ -> of_sexp_error "Time.Stable.With_utc.V2.t_of_sexp" sexp
-        with
-        | Of_sexp_error _ as e -> raise e
-        | e ->
-          of_sexp_error
-            (sprintf "Time.Stable.With_utc.V2.t_of_sexp: %s" (Exn.to_string e))
-            sexp
-      ;;
+        let t_of_sexp sexp =
+          try
+            match sexp with
+            | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday_and_possibly_zone ] ->
+              of_string_gen
+                ~default_zone:(fun () -> Zone.utc)
+                ~find_zone:(fun _ ->
+                  of_sexp_error
+                    "Time.Stable.With_utc.V2.t_of_sexp: unknown time zone"
+                    sexp)
+                (date ^ " " ^ ofday_and_possibly_zone)
+            | _ -> of_sexp_error "Time.Stable.With_utc.V2.t_of_sexp" sexp
+          with
+          | Of_sexp_error _ as e -> raise e
+          | e ->
+            of_sexp_error
+              (sprintf "Time.Stable.With_utc.V2.t_of_sexp: %s" (Exn.to_string e))
+              sexp
+        ;;
+
+        let t_sexp_grammar = Sexplib.Sexp_grammar.coerce Sexplib.Sexp.t_sexp_grammar
 
-      let t_sexp_grammar = Sexplib.Sexp_grammar.coerce Sexplib.Sexp.t_sexp_grammar
-      let comparator = `Use_Time_unix
+        type comparator_witness = T.comparator_witness
 
-      module Map = struct end
-      module Set = struct end
+        let comparator = T.comparator
+      end
+
+      include C
+      include Comparable.Stable.V1.With_stable_witness.Make (C)
     end
   end
 
-  module Zone = struct
-    module V1 = struct end
-    include Zone_stable
+  module With_t_of_sexp_abs = struct
+    module V1 = struct
+      include (V1 : module type of V1 with module Map := V1.Map and module Set := V1.Set)
+
+      let t_of_sexp = t_of_sexp_abs
+    end
   end
-end
 
-module Ofday = struct
-  include Ofday
+  module Span = Time.Stable.Span
 
-  let arg_type = `Use_Time_unix
-  let now = `Use_Time_unix
+  module Ofday = struct
+    include Time.Stable.Ofday
 
-  module Zoned = struct end
-end
+    module Zoned = struct
+      module V1 = struct
+        open Ofday.Zoned
+
+        type nonrec t = t [@@deriving hash]
+
+        let compare = With_nonchronological_compare.compare
+        let equal = With_nonchronological_compare.equal
+
+        module Bin_repr = struct
+          type t =
+            { ofday : Time.Stable.Ofday.V1.t
+            ; zone : Timezone.Stable.V1.t
+            }
+          [@@deriving bin_io, stable_witness]
+        end
+
+        let to_binable t : Bin_repr.t = { ofday = ofday t; zone = zone t }
+        let of_binable (repr : Bin_repr.t) = create repr.ofday repr.zone
+
+        include
+          Binable.Stable.Of_binable.V1 [@alert "-legacy"]
+            (Bin_repr)
+            (struct
+              type nonrec t = t
+
+              let to_binable = to_binable
+              let of_binable = of_binable
+            end)
+
+        let stable_witness =
+          Stable_witness.of_serializable
+            [%stable_witness: Bin_repr.t]
+            of_binable
+            to_binable
+        ;;
+
+        let%expect_test _ =
+          print_endline [%bin_digest: t];
+          [%expect {| 490573c3397b4fe37e8ade0086fb4759 |}]
+        ;;
+
+        type sexp_repr = Time.Stable.Ofday.V1.t * Timezone.Stable.V1.t
+        [@@deriving sexp, sexp_grammar]
+
+        let sexp_of_t t = [%sexp_of: sexp_repr] (ofday t, zone t)
+
+        let t_of_sexp sexp =
+          let ofday, zone = [%of_sexp: sexp_repr] sexp in
+          create ofday zone
+        ;;
 
-module Span = struct
-  include Span
+        let t_sexp_grammar = Sexplib.Sexp_grammar.coerce sexp_repr_sexp_grammar
+      end
+    end
+  end
 
-  let arg_type = `Use_Time_unix
+  module Zone = Timezone.Stable
 end
 
-module Zone = struct
-  include Zone
-  module Hash_queue = struct end
-  module Hash_set = struct end
-  module Map = struct end
-  module Replace_polymorphic_compare = struct end
-  module Set = struct end
-  module Table = struct end
-
-  let ( < ) = `Use_Time_unix
-  let ( <= ) = `Use_Time_unix
-  let ( <> ) = `Use_Time_unix
-  let ( = ) = `Use_Time_unix
-  let ( > ) = `Use_Time_unix
-  let ( >= ) = `Use_Time_unix
-  let __bin_read_t__ = `Use_Time_unix
-  let arg_type = `Use_Time_unix
-  let ascending = `Use_Time_unix
-  let between = `Use_Time_unix
-  let bin_read_t = `Use_Time_unix
-  let bin_reader_t = `Use_Time_unix
-  let bin_shape_t = `Use_Time_unix
-  let bin_size_t = `Use_Time_unix
-  let bin_t = `Use_Time_unix
-  let bin_write_t = `Use_Time_unix
-  let bin_writer_t = `Use_Time_unix
-  let clamp = `Use_Time_unix
-  let clamp_exn = `Use_Time_unix
-  let comparator = `Use_Time_unix
-  let descending = `Use_Time_unix
-  let equal = `Use_Time_unix
-  let find = `Use_Time_unix
-  let find_exn = `Use_Time_unix
-  let hash = `Use_Time_unix
-  let hash_fold_t = `Use_Time_unix
-  let hashable = `Use_Time_unix
-  let init = `Use_Time_unix
-  let initialized_zones = `Use_Time_unix
-  let local = `Use_Time_unix
-  let max = `Use_Time_unix
-  let min = `Use_Time_unix
-  let of_string = `Use_Time_unix
-  let pp = `Use_Time_unix
-  let t_of_sexp = `Use_Time_unix
-  let to_string = `Use_Time_unix
-  let validate_bound = `Use_Time_unix
-  let validate_lbound = `Use_Time_unix
-  let validate_ubound = `Use_Time_unix
-end
-
-module Exposed_for_tests = struct end
-module Hash_queue = struct end
-module Hash_set = struct end
-module Map = struct end
-module Set = struct end
-module Table = struct end
-
-let arg_type = `Use_Time_unix
-let format = `Use_Time_unix
-let get_sexp_zone = `Use_Time_unix
-let hashable = `Use_Time_unix
-let interruptible_pause = `Use_Time_unix
-let of_date_ofday_zoned = `Use_Time_unix
-let of_string_abs = `Use_Time_unix
-let of_string_fix_proto = `Use_Time_unix
-let of_tm = `Use_Time_unix
-let parse = `Use_Time_unix
-let pause = `Use_Time_unix
-let pause_forever = `Use_Time_unix
-let pp = `Use_Time_unix
-let set_sexp_zone = `Use_Time_unix
-let sexp_of_t = `Use_Time_unix
-let sexp_of_t_abs = `Use_Time_unix
-let t_of_sexp = `Use_Time_unix
-let t_of_sexp_abs = `Use_Time_unix
-let to_date_ofday_zoned = `Use_Time_unix
-let to_ofday_zoned = `Use_Time_unix
-let to_string_fix_proto = `Use_Time_unix
+include (
+  T :
+    module type of struct
+      include T
+    end
+    with module Replace_polymorphic_compare := T.Replace_polymorphic_compare
+    with module Date_and_ofday := T.Date_and_ofday
+    with type underlying := T.underlying
+    with type t := T.t
+    with type comparator_witness := T.comparator_witness)
+
+let to_string = T.to_string
+let of_string = T.of_string
+let of_string_gen = T.of_string_gen
Index: core-0.17.1/core/src/time_float.mli
===================================================================
--- core-0.17.1.orig/core/src/time_float.mli
+++ core-0.17.1/core/src/time_float.mli
@@ -1,235 +1,381 @@
-open! Import
-open! Std_internal
-
-module type S_kernel_without_zone = Time0_intf.S
-module type S_kernel = Time_intf.S
+(** A module for representing absolute points in time, independent of time zone.
 
-include Time_intf.S with module Time := Time_float0
+    Note that on 32bit architecture, most functions will raise when used on time
+    outside the range [1901-12-13 20:45:52 - 2038-01-19 03:14:07].
+*)
 
-module Ofday : sig
-  include module type of struct
-    include Ofday
-  end
+open! Std_internal
+open! Import
+module Time := Time_float0
 
-  val arg_type : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val now : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+module Span : sig
+  include module type of Time.Span
 
-  module Zoned : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+  val arg_type : t Command.Arg_type.t
 end
 
-module Span : sig
-  include module type of struct
-    include Span
-  end
+module Zone : sig
+  include Time_intf.Zone with module Time := Time
+  include Timezone.Extend_zone with type t := t
 
-  val arg_type : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+  val arg_type : t Command.Arg_type.t
 end
 
-module Zone : sig
+module Ofday : sig
   include module type of struct
-    include Zone
+      include Time.Ofday
+    end [@ocaml.remove_aliases]
+    with type underlying := Time.Ofday.underlying
+
+  val arg_type : t Command.Arg_type.t
+
+  module Zoned : sig
+    (** Sexps look like "(12:01 nyc)"
+
+          Two [t]'s may or may not correspond to the same times depending on which date
+          they're evaluated. *)
+    type t [@@deriving bin_io, sexp, hash]
+
+    include Pretty_printer.S with type t := t
+
+    (** Strings look like "12:01 nyc" *)
+    include Stringable with type t := t
+
+    (** Like [to_string] but uses [Time_float.Ofday.to_string_trimmed] to format the
+          ofday *)
+    val to_string_trimmed : t -> string
+
+    val arg_type : t Command.Arg_type.t
+    val create : Time.Ofday.t -> Zone.t -> t
+    val create_local : Time.Ofday.t -> t
+    val ofday : t -> Time.Ofday.t
+    val zone : t -> Zone.t
+    val to_time : t -> Date0.t -> Time.t
+
+    module With_nonchronological_compare : sig
+      (** It is possible to consistently compare [t]'s, but due to the complexities of
+            time zones and daylight savings, the resulting ordering is not chronological.
+            That is, [compare t1 t2 > 0] does not imply [t2] occurs after [t1] every day,
+            or any day. *)
+      type nonrec t = t [@@deriving bin_io, sexp, compare, equal, hash]
+    end
   end
 
-  module Hash_queue : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  module Hash_set : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  module Map : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  module Replace_polymorphic_compare : sig end
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  module Set : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  module Table : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val ( < ) : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val ( <= ) : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val ( <> ) : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val ( = ) : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val ( > ) : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val ( >= ) : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val __bin_read_t__ : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val arg_type : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val ascending : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val between : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_read_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_reader_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_shape_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_size_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_t : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_write_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val bin_writer_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val clamp : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val clamp_exn : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val comparator : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val descending : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val equal : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val find : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val find_exn : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val hash : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val hash_fold_t : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val hashable : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val init : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val initialized_zones : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val local : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val max : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-  val min : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val of_string : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val pp : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  val t_of_sexp : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+  val now : zone:Zone.t -> t
+end
 
-  val to_string : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+(** A fully qualified point in time, independent of timezone. *)
+type t = Time.t [@@deriving bin_io, compare, hash, sexp, sexp_grammar, typerep]
 
-  val validate_bound : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+include
+  Time_intf.S
+  with module Time := Time
+   and type t := t
+   and module Zone := Zone
+   and module Ofday := Ofday
+   and module Span := Span
+
+val arg_type : t Command.Arg_type.t
+
+(** String conversions use the local timezone by default. Sexp conversions use
+      [get_sexp_zone ()] by default, which can be overridden by calling [set_sexp_zone].
+      These default time zones are used when writing a time, and when reading a time with
+      no explicit zone or UTC offset.
+
+      Sexps and strings display the date, ofday, and UTC offset of [t] relative to the
+      appropriate time zone. *)
+include
+  Identifiable.S
+  with type t := t
+   and type comparator_witness := comparator_witness
+   and module Replace_polymorphic_compare := Replace_polymorphic_compare
+
+val get_sexp_zone : unit -> Zone.t
+val set_sexp_zone : Zone.t -> unit
+
+include Robustly_comparable with type t := t
+
+(** Conversion functions that involved Ofday.Zoned.t, exactly analogous to the
+      conversion functions that involve Ofday.t *)
+val of_date_ofday_zoned : Date0.t -> Ofday.Zoned.t -> t
+
+val to_date_ofday_zoned : t -> zone:Zone.t -> Date0.t * Ofday.Zoned.t
+val to_ofday_zoned : t -> zone:Zone.t -> Ofday.Zoned.t
+val to_string_fix_proto : [ `Utc | `Local ] -> t -> string
+val of_string_fix_proto : [ `Utc | `Local ] -> string -> t
+
+(** This is like [of_string] except that if the string doesn't specify the zone then it
+      raises rather than assume the local timezone. *)
+val of_string_abs : string -> t
+
+(** [of_string_gen ~if_no_timezone s] attempts to parse [s] to a [t].  If [s] doesn't
+      supply a time zone [if_no_timezone] is consulted. *)
+val of_string_gen
+  :  if_no_timezone:[ `Fail | `Local | `Use_this_one of Zone.t ]
+  -> string
+  -> t
+
+(** [t_of_sexp_abs sexp] as [t_of_sexp], but demands that [sexp] indicate the timezone
+      the time is expressed in. *)
+val t_of_sexp_abs : Sexp.t -> t
 
-  val validate_lbound : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+val sexp_of_t_abs : t -> zone:Zone.t -> Sexp.t
 
-  val validate_ubound : [ `Use_Time_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+module Exposed_for_tests : sig
+  val ensure_colon_in_offset : string -> string
 end
 
-module Stable : sig
-  include module type of struct
-    include Time_float0.Stable
-  end
+include Diffable.S_atomic with type t := t
 
-  module Ofday : sig
-    include module type of struct
-      include Ofday
-    end
+module Stable : sig
+  module V1 : sig
+    type nonrec t = t [@@deriving hash, typerep, sexp_grammar]
+    type nonrec comparator_witness = comparator_witness
+
+    include
+      Stable_comparable.With_stable_witness.V1
+      with type t := t
+      with type comparator_witness := comparator_witness
 
-    module Zoned : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    include Diffable.S_atomic with type t := t
   end
 
-  module V1 : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-  module With_t_of_sexp_abs : sig end
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
+  (** Provides a sexp representation that is independent of the time zone of the machine
+      writing it.
+      [V1.t_of_sexp] will be generous in what sexps it accepts, while [V2.t_of_sexp]
+      should not be expected to parse sexps not generated by [V2.sexp_of_t]
+  *)
   module With_utc_sexp : sig
-    module V1 : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    module V1 :
+      Stable_comparable.V1
+      with type t = t
+      with type comparator_witness = comparator_witness
 
-    (** [Time_float_unix.Stable.V1.t_of_sexp] has parsing that understands non-UTC time
-        zones. *)
     module V2 : sig
-      type t = Time_float0.t [@@deriving hash, sexp_grammar]
-
-      include Stable_without_comparator_with_witness with type t := t
+      type nonrec t = t [@@deriving hash, sexp_grammar]
+      type nonrec comparator_witness = comparator_witness
 
-      val comparator : [ `Use_Time_unix ]
-        [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-      module Map : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-      module Set : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include
+        Stable_comparable.With_stable_witness.V1
+        with type t := t
+        with type comparator_witness := comparator_witness
     end
   end
 
-  module Zone : sig
-    module V1 : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-    include Zone_intf.S_stable with type t := Zone.t
-  end
-end
-
-module Exposed_for_tests : sig end [@@deprecated "[since 2021-03] use [Time_float_unix]"]
-module Hash_queue : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-module Hash_set : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-module Map : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-module Set : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-module Table : sig end [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+  (** Provides a sexp representation where all sexps must include a timezone (in contrast
+      to [V1] above, which will assume local timezone if it's not specified). When
+      serializing, it uses the local timezone.  Concretely, this is just [V1] but
+      [t_of_sexp] is replaced with [t_of_sexp_abs]. *)
+  module With_t_of_sexp_abs : sig
+    module V1 : sig
+      type nonrec t = t
+      type nonrec comparator_witness = comparator_witness
 
-val arg_type : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-val format : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-val get_sexp_zone : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-val hashable : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-val interruptible_pause : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-
-val of_date_ofday_zoned : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include Stable with type t := t with type comparator_witness := comparator_witness
+    end
+  end
 
-val of_string : string -> t
-  [@@deprecated
-    "[since 2021-03] Use [of_string_with_utc_offset] or [Time_float_unix.of_string]"]
+  module Span : sig
+    module V1 : sig
+      type t = Time.Stable.Span.V1.t [@@deriving hash, equal, sexp_grammar]
 
-val of_string_abs : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include Stable_without_comparator_with_witness with type t := t
+      include Diffable.S_atomic with type t := t
+    end
 
-val of_string_fix_proto : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    module V2 : sig
+      type t = Time.Stable.Span.V2.t [@@deriving hash, equal, sexp_grammar]
 
-val of_tm : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-val parse : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
-val pause : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include Stable_without_comparator_with_witness with type t := t
+      include Diffable.S_atomic with type t := t
+    end
 
-val pause_forever : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    module V3 : sig
+      type t = Time.Stable.Span.V3.t [@@deriving hash, typerep, equal, sexp_grammar]
 
-val pp : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include Stable_without_comparator_with_witness with type t := t
+      include Diffable.S_atomic with type t := t
+    end
+  end
 
-val set_sexp_zone : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+  module Ofday : sig
+    module V1 : sig
+      type t = Time.Stable.Ofday.V1.t [@@deriving hash, equal, sexp_grammar]
 
-val sexp_of_t : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include Stable_without_comparator_with_witness with type t := t
+      include Diffable.S_atomic with type t := t
+    end
 
-val sexp_of_t_abs : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    module Zoned : sig
+      module V1 : sig
+        (** This uses [With_nonchronological_compare.compare] and
+            [With_nonchronological_compare.equal]. *)
+        type t = Ofday.Zoned.t [@@deriving hash, equal, sexp_grammar]
 
-val t_of_sexp : [ `Use_Time_unix ] [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+        include Stable_without_comparator_with_witness with type t := t
+      end
+    end
+  end
 
-val t_of_sexp_abs : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+  module Zone : sig
+    module V1 : sig
+      type t = Timezone.Stable.V1.t [@@deriving hash, sexp_grammar]
 
-val to_date_ofday_zoned : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+      include Stable_without_comparator_with_witness with type t := t
+      include Diffable.S_atomic with type t := t
+    end
 
-val to_ofday_zoned : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    module Full_data : sig
+      module V1 :
+        Stable_without_comparator_with_witness
+        with type t = Timezone.Stable.Full_data.V1.t
+    end
+  end
+end
 
-val to_string : t -> string
-  [@@deprecated "[since 2021-03] Use [to_string_utc] or [Time_float_unix.to_string]"]
+(** {1 Notes on time}
 
-val to_string_fix_proto : [ `Use_Time_unix ]
-  [@@deprecated "[since 2021-03] Use [Time_float_unix]"]
+    This library replicates and extends the functionality of the standard Unix time
+    handling functions (currently exposed in the Unix module, and indirectly through the
+    Time module).
+
+    Things you should know before delving into the mess of time...
+
+    {2 Some general resources (summarized information also appears below) }
+
+    {v
+    general overview   - http://www.twinsun.com/tz/tz-link.htm
+    zone abbreviations - http://blogs.msdn.com/oldnewthing/archive/2008/03/07/8080060.aspx
+    leap seconds       - http://en.wikipedia.org/wiki/Leap_second
+    epoch time         - http://en.wikipedia.org/wiki/Unix_time
+    UTC/GMT time       - http://www.apparent-wind.com/gmt-explained.html
+    TAI time           - http://en.wikipedia.org/wiki/International_Atomic_Time
+    Almost every possible time measurement -
+      http://www.ucolick.org/~sla/leapsecs/timescales.html
+  v}
+
+    {2 Standards for measuring time }
+
+    - Epoch time/Unix time/Posix time: Defined as the number of seconds that have passed
+      since midnight, January 1st, 1970 GMT.  However, under epoch time, a day is always
+      86,400 seconds long, and a minute never contains more than 60 total seconds.  In other
+      words, epoch time does not take leap seconds into account properly.  What a POSIX
+      compliant system does during a leap second depends on the way in which its clock is
+      managed.  It either ignores it, replays the second, or causes a second to last longer
+      than a second (retards the second).  The important thing to remember is that however
+      the transition is managed, all days start on an evenly divisible multiple of 86,400.
+    - GMT/Greenwich Mean Time/Greenwich Civil Time: The time based on the movement of the
+      sun relative to the meridian through the Old Greenwich Observatory (0 degrees).  The
+      movement of the sun in this case is a "mean" movement of the sun to adjust for slight
+      eccentricities in the rotation of the earth, as well as for the effect of the tilt of
+      the earth on the visible speed of the sun across the sky at different times of the
+      year.  GMT is often used synonymously with the term UTC (see below), but may also be
+      used to refer to the time system described here, which differs from UTC (as of 2009)
+      by ~1 second.
+    - Standard Time: The time based on the adjusted (as in GMT) movement of the sun over a
+      point on the earth that is not Greenwich.  Colloquially, the time in a time zone
+      without accounting for any form of daylight savings time.
+    - Wall Clock Time: The time as it appears on a clock on the wall in a given time zone.
+      Essentially this is standard time with DST adjustments.
+    - TAI: International atomic time.  The time based on a weighted average of the time kept
+      by roughly 300 atomic clocks worldwide.  TAI is written using the same format as
+      normal solar (also called civil) times, but is not based on, or adjusted for the
+      apparent solar time.  Thus, as of 2009 TAI appears to be ahead of most other time
+      systems by ~34 seconds when written out in date/time form (2004-09-17T00:00:32 TAI is
+      2004-09-17T00:00:00 UTC)
+    - UTC/Universal Coordinated Time: Often taken as just another term for GMT, UTC is
+      actually TAI adjusted with leap seconds to keep it in line with apparent solar time.
+      Each UTC day is not an exact number of seconds long (unlike TAI or epoch time), and
+      every second is exactly one real second long (unlike GMT, which is based entirely on
+      the apparent motion of the sun, meaning that seconds under GMT slowly get longer as
+      the earth's rotation slows down).  Leap seconds are determined by the rotation of
+      the earth, which is carefully measured by the International Earth Rotation Service
+      in Paris, France using a combination of satellite and lunar laser ranging, very
+      long baseline interferometry, and Navstar Global Positioning System (GPS) stations.
+      This isn't important for using UTC, but is very cool.  UTC is not well defined before
+      about 1960.
+    - Windows File Time: The number of 100-nanosecond intervals that have elapsed since
+      12:00 A.M. January 1, 1601, UTC.  This is great because UTC has no meaning in 1601
+      (being based on atomic timekeeping technologies that didn't exist then), and also
+      because 1601 predates the development of even reasonably accurate clocks of any sort.
+      The reasoning behind the Windows epoch time choice is that "The Gregorian calendar
+      operates on a 400-year cycle, and 1601 is the first year of the cycle that was
+      active at the time Windows NT was being designed. In other words, it was chosen to
+      make the math come out nicely."
+      (http://blogs.msdn.com/oldnewthing/archive/2009/03/06/9461176.aspx)
+    - VBScript (this is my favorite):
+      http://blogs.msdn.com/ericlippert/archive/2003/09/16/eric-s-complete-guide-to-vt-date.aspx
+
+    All of these systems start to exhibit problems as you go further back in time, partly
+    because truly accurate timekeeping didn't make an appearance until roughly 1958, and
+    partly because different parts of the world didn't actually have well defined time zones
+    for a long time.  If you go back far enough, you run into the switch between the Julian
+    (old) and the Gregorian calendar, which happened at different times in history in
+    different places in the world.
+
+    {2 How does a system determine what time zone it is in? }
+
+    + Check to see if the TZ environment variable is set.  If it is, it can be set to one
+    of three forms, two of which are rarely, if ever used see:
+
+    http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html
+
+    for more information on the obscure forms.  The common form represents a relative path
+    from the base /usr/share/zoneinfo/posix, and is generally in the form of a continent
+    or country name paired with a city name (Europe/London, America/New_York).  This is
+    used to load the specified file from disk, which contains a time zone database in zic
+    format (man tzfile).
+
+    + If TZ is not set, the system will try to read the file located at /etc/localtime,
+    which must be a zic timezone database (and which is often just a symlink into
+    /usr/share/zoneinfo/posix).
+    + If /etc/localtime cannot be found, then the system is assumed to be in GMT.
+
+    It's worth noting that under this system there is no place on the system to go to get
+    the name of the file you are using (/etc/localtime may not be a link, and may just be a
+    copy, or its own database not represented in /usr/share/zoneinfo).  Additionally, the
+    names of the files in the system zoneinfo database follow an internal standard, and
+    there is no established standard for naming timezones.  So even if you were using one of
+    these files, and you did know its name, you cannot assume that that name matches any
+    timezone specified by any other system or description.
+
+    One common misconception about time zones is that the standard time zone abbreviations
+    can be used.  For instance, EST surely refers to Eastern Standard Time.  This is
+    unfortunately not true - CST can refer to China Central Time, Central Standard Time, or
+    Cuba Summer Time for instance - and time zone libraries that appear to correctly parse
+    times that use time zone abbreviations do so by using a heuristic that usually assumes
+    you mean a time in the US or Europe, in that order.  Time zones also sometimes use two
+    different abbreviations depending on whether the time in question is in standard time,
+    or daylight savings time.  These abbreviations are kept in the timezone databases, which
+    is how programs like date manage to output meaningful abbreviations. The only poorly
+    specified operation is reading in times with abbreviations.
+
+    This library contains a function that attempts to make an accurate determination of the
+    machine timezone by testing the md5 sum of the currently referenced timezone file
+    against all of the possible candidates in the system database.  It additionally makes
+    some adjustments to return the more common timezone names since some files in the
+    database are duplicated under several names.  It returns an option because of the
+    problems mentioned above.
+
+    {2 The problems with string time conversions }
+
+    There are two cases where string time conversions are problematic, both related to
+    daylight savings time.
+
+    In the case where time jumps forward one hour, there are possible representations of
+    times that never happened 2006-04-02T02:30:00 in the eastern U.S. never happened for
+    instance, because the clock jumped forward one hour directly from 2 to 3.  Unix time
+    zone libraries asked to convert one of these times will generally produce the epoch time
+    that represents the time 1/2 hour after 2 am, which when converted back to a string
+    representation will be T03:30:00.
+
+    The second case is when the clocks are set back one hour, which causes one hour of time
+    to happen twice.  Converting a string in this range without further specification into
+    an epoch time is indeterminate since it could be referring to either of two times.  Unix
+    libraries handle this by either allowing you to pass in a dst flag to the conversion
+    function to specify which time you mean, or by using a heuristic to guess which time you
+    meant.
+
+    The existence of both cases make a strong argument for serializing all times in UTC,
+    which doesn't suffer from these issues.
+*)
Index: core-0.17.1/core/src/time_float0.ml
===================================================================
--- core-0.17.1.orig/core/src/time_float0.ml
+++ core-0.17.1/core/src/time_float0.ml
@@ -9,23 +9,19 @@ module Absolute = struct
 
   include (
     Float :
-      sig
-        type t = float [@@deriving bin_io, hash, typerep]
+    sig
+      type t = float [@@deriving bin_io, hash, typerep]
 
-        include Comparable.S_common with type t := t
-
-        include module type of struct
-          include Float.O
-        end
-      end)
+      include Comparable.S_common with type t := t
+    end)
 
   (* due to precision limitations in float we can't expect better than microsecond
      precision *)
   include Float.Robust_compare.Make (struct
-    let robust_comparison_tolerance = 1E-6
-  end)
+      let robust_comparison_tolerance = 1E-6
+    end)
 
-  let diff t1 t2 = Span.of_sec (t1 - t2)
+  let diff t1 t2 = Span.of_sec (t1 -. t2)
   let add t span = t +. Span.to_sec span
   let sub t span = t -. Span.to_sec span
   let prev t = Float.one_ulp `Down t
Index: core-0.17.1/core/src/time_float0.mli
===================================================================
--- core-0.17.1.orig/core/src/time_float0.mli
+++ core-0.17.1/core/src/time_float0.mli
@@ -1,20 +1,21 @@
 open! Import
 
 module Span : module type of struct
-  include Span_float
-end
-with module Stable := Span_float.Stable
+    include Span_float
+  end
+  with module Stable := Span_float.Stable
+   and module Private := Span_float.Private
 
 module Ofday : module type of struct
-  include Ofday_float
-end
-with module Stable := Ofday_float.Stable
+    include Ofday_float
+  end
+  with module Stable := Ofday_float.Stable
 
 include
   Time0_intf.S
-    with type underlying = float
-     and module Span := Span
-     and module Ofday := Ofday
+  with type underlying = float
+   and module Span := Span
+   and module Ofday := Ofday
 
 module Stable : sig
   module Span = Span_float.Stable
Index: core-0.17.1/core/src/time_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/time_intf.ml
+++ core-0.17.1/core/src/time_intf.ml
@@ -4,7 +4,12 @@ module Date = Date0
 
 module type Zone = sig
   module Time : Time0_intf.S
-  include Zone.S with type t = Zone.t and module Time_in_seconds := Time
+
+  include
+    Zone.S
+    with type t = Zone.t
+     and type Index.t = Zone.Index.t
+     and module Time_in_seconds := Time
 
   (** [abbreviation t time] returns the abbreviation name (such as EDT, EST, JST) of given
       zone [t] at [time]. This string conversion is one-way only, and cannot reliably be
@@ -223,8 +228,8 @@ module type S = sig
   include Shared with type t := t with module Span := Span with module Ofday := Ofday
 
   val of_string : string -> t
-    [@@deprecated
-      "[since 2021-04] Use [of_string_with_utc_offset] or [Time_float_unix.of_string]"]
+  [@@deprecated
+    "[since 2021-04] Use [of_string_with_utc_offset] or [Time_float_unix.of_string]"]
 
   (** [of_string_with_utc_offset] requires its input to have an explicit
       UTC offset, e.g. [2000-01-01 12:34:56.789012-23], or use the UTC zone, "Z",
@@ -232,7 +237,7 @@ module type S = sig
   val of_string_with_utc_offset : string -> t
 
   val to_string : t -> string
-    [@@deprecated "[since 2021-04] Use [to_string_utc] or [Time_float_unix.to_string]"]
+  [@@deprecated "[since 2021-04] Use [to_string_utc] or [Time_float_unix.to_string]"]
 
   (** [to_string_utc] generates a time string with the UTC zone, "Z", e.g. [2000-01-01
       12:34:56.789012Z]. *)
Index: core-0.17.1/core/src/time_ns.ml
===================================================================
--- core-0.17.1.orig/core/src/time_ns.ml
+++ core-0.17.1/core/src/time_ns.ml
@@ -4,31 +4,29 @@ open Std_internal
 let arch_sixtyfour = Sys.word_size_in_bits = 64
 
 module Span = Span_ns
-module Ofday = Ofday_ns
 
 type t = Span.t (* since the Unix epoch (1970-01-01 00:00:00 UTC) *)
 [@@deriving bin_io, compare, hash, typerep]
 
 module Replace_polymorphic_compare_efficient = Span.Replace_polymorphic_compare
-module Replace_polymorphic_compare = Replace_polymorphic_compare_efficient
 include Replace_polymorphic_compare_efficient
 include (Span : Quickcheck.S_range with type t := t)
 
-let now = Span.since_unix_epoch
+let[@zero_alloc] now t = Span.since_unix_epoch t
 let equal = Span.equal
 let min_value_for_1us_rounding = Span.min_value_for_1us_rounding
 let max_value_for_1us_rounding = Span.max_value_for_1us_rounding
 let epoch = Span.zero
-let add = Span.( + )
-let sub = Span.( - )
-let diff = Span.( - )
-let abs_diff t u = Span.abs (diff t u)
+let[@zero_alloc] add t1 t2 = Span.(t1 + t2)
+let[@zero_alloc] sub t1 t2 = Span.(t1 - t2)
+let[@zero_alloc] diff t1 t2 = Span.(t1 - t2)
+let[@zero_alloc] abs_diff t u = Span.abs (diff t u)
 let max = Span.max
 let min = Span.min
-let next = Span.next
-let prev = Span.prev
-let to_span_since_epoch t = t
-let of_span_since_epoch s = s
+let[@zero_alloc] next t = Span.next t
+let[@zero_alloc] prev t = Span.prev t
+let[@zero_alloc] to_span_since_epoch t = t
+let[@zero_alloc] of_span_since_epoch s = s
 let to_int63_ns_since_epoch t : Int63.t = Span.to_int63_ns (to_span_since_epoch t)
 let[@inline] of_int63_ns_since_epoch i = of_span_since_epoch (Span.of_int63_ns i)
 let[@cold] overflow () = raise_s [%message "Time_ns: overflow"]
@@ -53,7 +51,7 @@ let sub_exn x y =
   if sub_overflowed x y ~diff then overflow () else diff
 ;;
 
-let add_saturating x y =
+let[@zero_alloc] add_saturating x y =
   let sum = add x y in
   if add_overflowed x y ~sum
   then
@@ -61,7 +59,7 @@ let add_saturating x y =
   else sum
 ;;
 
-let sub_saturating x y =
+let[@zero_alloc] sub_saturating x y =
   let diff = sub x y in
   if sub_overflowed x y ~diff
   then
@@ -71,11 +69,12 @@ let sub_saturating x y =
 
 let to_int_ns_since_epoch =
   if arch_sixtyfour
-  then fun t -> Int63.to_int_exn (to_int63_ns_since_epoch t)
+  then fun [@zero_alloc] t -> Int63.to_int_exn (to_int63_ns_since_epoch t)
   else fun _ -> failwith "Time_ns.to_int_ns_since_epoch: unsupported on 32bit machines"
 ;;
 
-let of_int_ns_since_epoch i = of_int63_ns_since_epoch (Int63.of_int i)
+let[@zero_alloc] to_int_ns_since_epoch t = to_int_ns_since_epoch t
+let[@zero_alloc] of_int_ns_since_epoch i = of_int63_ns_since_epoch (Int63.of_int i)
 
 let to_time_float_round_nearest t =
   Time_float.of_span_since_epoch
@@ -106,12 +105,12 @@ let check_before_conversion_for_1us_roun
       [%sexp_of: Time_float.Stable.With_utc_sexp.V2.t]
 ;;
 
-let[@inline] of_time_float_round_nearest time =
+let[@inline] [@zero_alloc] of_time_float_round_nearest time =
   of_span_since_epoch
     (Span.of_span_float_round_nearest (Time_float.to_span_since_epoch time))
 ;;
 
-let of_time_float_round_nearest_microsecond time =
+let[@zero_alloc] of_time_float_round_nearest_microsecond time =
   check_before_conversion_for_1us_rounding time;
   of_span_since_epoch
     (Span.of_span_float_round_nearest_microsecond (Time_float.to_span_since_epoch time))
@@ -125,7 +124,13 @@ let[@cold] raise_next_multiple_got_nonpo
     [%sexp_of: Span.t]
 ;;
 
-let next_multiple_internal ~calling_function_name ~can_equal_after ~base ~after ~interval =
+let[@zero_alloc] next_multiple_internal
+  ~calling_function_name
+  ~can_equal_after
+  ~base
+  ~after
+  ~interval
+  =
   if Span.( <= ) interval Span.zero
   then raise_next_multiple_got_nonpositive_interval ~calling_function_name interval;
   let base_to_after = diff after base in
@@ -215,7 +220,7 @@ let random ?state () = Span.random ?stat
 
 module Utc : sig
   val to_date_and_span_since_start_of_day : t -> Date0.t * Span.t
-  val of_date_and_span_since_start_of_day : Date0.t -> Span.t -> t
+  val of_date_and_span_since_start_of_day : Date0.t -> Span.t -> t [@@zero_alloc]
 end = struct
   (* a recreation of the system call gmtime specialized to the fields we need that also
      doesn't rely on Unix. *)
@@ -239,7 +244,7 @@ end = struct
     date, span_since_start_of_day
   ;;
 
-  let of_date_and_span_since_start_of_day date span_since_start_of_day =
+  let[@zero_alloc] of_date_and_span_since_start_of_day date span_since_start_of_day =
     assert (
       Span.( >= ) span_since_start_of_day Span.zero
       && Span.( < ) span_since_start_of_day Span.day);
@@ -372,11 +377,11 @@ module Alternate_sexp = struct
     ;;
 
     include Sexpable.Of_stringable (struct
-      type nonrec t = t
+        type nonrec t = t
 
-      let to_string = to_string
-      let of_string = of_string
-    end)
+        let to_string = to_string
+        let of_string = of_string
+      end)
 
     let t_sexp_grammar =
       let open Sexplib in
@@ -392,8 +397,8 @@ module Alternate_sexp = struct
   include Replace_polymorphic_compare_efficient
 
   include Diffable.Atomic.Make (struct
-    type nonrec t = t [@@deriving bin_io, equal, sexp]
-  end)
+      type nonrec t = t [@@deriving bin_io, equal, sexp]
+    end)
 
   module Stable = struct
     module V1 = struct
@@ -416,150 +421,39 @@ module Alternate_sexp = struct
   end
 end
 
-module Option0 = struct
-  type time = t [@@deriving compare]
-  type t = Span.Option.t [@@deriving bin_io, compare, hash, typerep, quickcheck]
-
-  let none = Span.Option.none
-  let some time = Span.Option.some (to_span_since_epoch time)
-  let is_none = Span.Option.is_none
-  let is_some = Span.Option.is_some
-
-  let some_is_representable time =
-    Span.Option.some_is_representable (to_span_since_epoch time)
-  ;;
-
-  let value t ~default =
-    of_span_since_epoch (Span.Option.value ~default:(to_span_since_epoch default) t)
-  ;;
-
-  let value_exn t =
-    if is_some t
-    then of_span_since_epoch (Span.Option.unchecked_value t)
-    else raise_s [%message [%here] "Time_ns.Option.value_exn none"]
-  ;;
-
-  let unchecked_value t = of_span_since_epoch (Span.Option.unchecked_value t)
-
-  let of_option = function
-    | None -> none
-    | Some t -> some t
-  ;;
-
-  let to_option t = if is_none t then None else Some (value_exn t)
-
-  module Optional_syntax = struct
-    module Optional_syntax = struct
-      let is_none = is_none
-      let unsafe_value = unchecked_value
-    end
-  end
-
-  module Alternate_sexp = struct
-    module T = struct
-      type nonrec t = t [@@deriving bin_io, compare, hash]
-
-      let sexp_of_t t = [%sexp_of: Alternate_sexp.t option] (to_option t)
-      let t_of_sexp s = of_option ([%of_sexp: Alternate_sexp.t option] s)
-
-      let t_sexp_grammar =
-        Sexplib.Sexp_grammar.coerce [%sexp_grammar: Alternate_sexp.t option]
-      ;;
-    end
-
-    include T
-    include Comparable.Make (T)
-
-    include Diffable.Atomic.Make (struct
-      include T
-
-      let equal = [%compare.equal: t]
-    end)
-
-    module Stable = struct
-      module V1 = struct
-        module T = struct
-          type nonrec t = t [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
-
-          let stable_witness : t Stable_witness.t =
-            Stable_witness.of_serializable
-              [%stable_witness: Alternate_sexp.Stable.V1.t option]
-              of_option
-              to_option
-          ;;
-
-          type nonrec comparator_witness = comparator_witness
-
-          let comparator = comparator
-        end
-
-        include T
-        include Comparable.Stable.V1.With_stable_witness.Make (T)
-
-        include Diffable.Atomic.Make (struct
-          include T
-
-          let equal = [%compare.equal: t]
-        end)
-      end
-    end
-  end
-
-  module Stable = struct
-    module V1 = struct
-      type nonrec t = t [@@deriving compare, bin_io]
-
-      let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
-      let to_int63 t = Span.Option.Stable.V1.to_int63 t
-      let of_int63_exn t = Span.Option.Stable.V1.of_int63_exn t
-    end
-
-    module Alternate_sexp = Alternate_sexp.Stable
-  end
-
-  let sexp_of_t = `Use_Time_ns_unix
-
-  (* bring back the efficient implementation of comparison operators *)
-  include (Span.Option : Comparisons.S with type t := t)
-end
-
-module Stable = struct
-  module V1 = struct end
-  module Option = Option0.Stable
-  module Alternate_sexp = Alternate_sexp.Stable
-  module Span = Span.Stable
-  module Ofday = Ofday.Stable
-end
-
 (* this code is directly duplicated from Time.ml functor, converted enough to get Time_ns
    to/of_string working *)
 module To_and_of_string : sig
-  val of_date_ofday : zone:Zone.t -> Date.t -> Ofday.t -> t
+  val of_date_ofday : zone:Zone.t -> Date.t -> Ofday_ns.t -> t
 
   val of_date_ofday_precise
     :  Date.t
-    -> Ofday.t
+    -> Ofday_ns.t
     -> zone:Zone.t
     -> [ `Once of t | `Twice of t * t | `Never of t ]
 
-  val to_date_ofday : t -> zone:Zone.t -> Date.t * Ofday.t
+  val to_date_ofday : t -> zone:Zone.t -> Date.t * Ofday_ns.t
 
   val to_date_ofday_precise
     :  t
     -> zone:Zone.t
-    -> Date.t * Ofday.t * [ `Only | `Also_at of t | `Also_skipped of Date.t * Ofday.t ]
+    -> Date.t
+       * Ofday_ns.t
+       * [ `Only | `Also_at of t | `Also_skipped of Date.t * Ofday_ns.t ]
 
   val to_date : t -> zone:Zone.t -> Date.t
-  val to_ofday : t -> zone:Zone.t -> Ofday.t
-  val convert : from_tz:Zone.t -> to_tz:Zone.t -> Date.t -> Ofday.t -> Date.t * Ofday.t
-  val reset_date_cache : unit -> unit
-  val utc_offset : t -> zone:Zone.t -> Span.t
+  val to_ofday : t -> zone:Zone.t -> Ofday_ns.t
 
-  val of_string : string -> t
-    [@@deprecated "[since 2021-04] Use [of_string_with_utc_offset]"]
+  val convert
+    :  from_tz:Zone.t
+    -> to_tz:Zone.t
+    -> Date.t
+    -> Ofday_ns.t
+    -> Date.t * Ofday_ns.t
 
+  val reset_date_cache : unit -> unit
+  val utc_offset : t -> zone:Zone.t -> Span.t
   val of_string_with_utc_offset : string -> t
-  val to_string : t -> string [@@deprecated "[since 2021-04] Use [to_string_utc]"]
   val to_string_utc : t -> string
   val to_filename_string : t -> zone:Zone.t -> string
   val of_filename_string : string -> zone:Zone.t -> t
@@ -582,7 +476,7 @@ module To_and_of_string : sig
   val occurrence
     :  [ `First_after_or_at | `Last_before_or_at ]
     -> t
-    -> ofday:Ofday.t
+    -> ofday:Ofday_ns.t
     -> zone:Zone.t
     -> t
 end = struct
@@ -599,7 +493,7 @@ end = struct
       in
       let open Int63.O in
       (days * Span.to_int63_ns Span.day)
-      + Span.to_int63_ns (Ofday.to_span_since_start_of_day ofday)
+      + Span.to_int63_ns (Ofday_ns.to_span_since_start_of_day ofday)
     ;;
 
     let to_absolute relative ~offset_from_utc =
@@ -629,7 +523,7 @@ end = struct
       let open Int63.O in
       let days_from_epoch_in_ns = days_from_epoch * ns_per_day in
       let remainder = t - days_from_epoch_in_ns in
-      Span.of_int63_ns remainder |> Ofday.of_span_since_start_of_day_exn
+      Span.of_int63_ns remainder |> Ofday_ns.of_span_since_start_of_day_exn
     ;;
 
     let date_of_days_from_epoch ~days_from_epoch =
@@ -767,8 +661,8 @@ end = struct
 
   let of_date_ofday_precise date ofday ~zone =
     (* We assume that there will be only one zone shift within a given local day.  *)
-    let start_of_day = of_date_ofday ~zone date Ofday.start_of_day in
-    let proposed_time = add start_of_day (Ofday.to_span_since_start_of_day ofday) in
+    let start_of_day = of_date_ofday ~zone date Ofday_ns.start_of_day in
+    let proposed_time = add start_of_day (Ofday_ns.to_span_since_start_of_day ofday) in
     match Zone.next_clock_shift zone ~strictly_after:start_of_day with
     | None -> `Once proposed_time
     | Some (shift_start, shift_amount) ->
@@ -831,7 +725,7 @@ end = struct
       let offset_from_utc = Zone.index_offset_from_utc_exn zone index in
       let rel = Date_and_ofday.of_absolute time ~offset_from_utc in
       let date = Date_and_ofday.to_date rel in
-      let span = Date_and_ofday.to_ofday rel |> Ofday.to_span_since_start_of_day in
+      let span = Date_and_ofday.to_ofday rel |> Ofday_ns.to_span_since_start_of_day in
       let effective_day_start =
         sub (Date_and_ofday.to_absolute rel ~offset_from_utc) span
       in
@@ -862,7 +756,7 @@ end = struct
 
   let to_ofday time ~zone =
     set_date_cache time ~zone;
-    diff time date_cache.effective_day_start |> Ofday.of_span_since_start_of_day_exn
+    diff time date_cache.effective_day_start |> Ofday_ns.of_span_since_start_of_day_exn
   ;;
 
   let to_date_ofday time ~zone = to_date time ~zone, to_ofday time ~zone
@@ -880,7 +774,7 @@ end = struct
          shifts can't cross date boundaries. This is true in all cases I've ever heard
          of (and [of_date_ofday_precise] would need revisiting if it turned out to be
          false) *)
-      match Ofday.sub ofday amount with
+      match Ofday_ns.sub ofday amount with
       | Some ofday -> `Also_skipped (date, ofday)
       | None ->
         raise_s
@@ -940,8 +834,8 @@ end = struct
     else
       String.concat
         [ (if Span.( < ) utc_offset Span.zero then "-" else "+")
-        ; Ofday.to_string_trimmed
-            (Ofday.of_span_since_start_of_day_exn (Span.abs utc_offset))
+        ; Ofday_ns.to_string_trimmed
+            (Ofday_ns.of_span_since_start_of_day_exn (Span.abs utc_offset))
         ]
   ;;
 
@@ -950,7 +844,7 @@ end = struct
       let date, ofday = to_date_ofday time ~zone in
       let offset_string = offset_string time ~zone in
       [ Date0.to_string date
-      ; String.concat ~sep:"" [ Ofday.to_string ofday; offset_string ]
+      ; String.concat ~sep:"" [ Ofday_ns.to_string ofday; offset_string ]
       ]
     in
     fun time ~zone ->
@@ -965,12 +859,11 @@ end = struct
     let offset_string = offset_string time ~zone in
     String.concat
       ~sep:" "
-      [ Date0.to_string date; Ofday.to_string_trimmed ofday ^ offset_string ]
+      [ Date0.to_string date; Ofday_ns.to_string_trimmed ofday ^ offset_string ]
   ;;
 
   let to_string_abs time ~zone = String.concat ~sep:" " (to_string_abs_parts ~zone time)
   let to_string_utc t = to_string_abs t ~zone:Zone.utc
-  let to_string = to_string_utc
 
   let to_string_iso8601_basic time ~zone =
     String.concat ~sep:"T" (to_string_abs_parts ~zone time)
@@ -978,12 +871,12 @@ end = struct
 
   let to_string_trimmed t ~zone =
     let date, sec = to_date_ofday ~zone t in
-    Date0.to_string date ^ " " ^ Ofday.to_string_trimmed sec
+    Date0.to_string date ^ " " ^ Ofday_ns.to_string_trimmed sec
   ;;
 
   let to_sec_string t ~zone =
     let date, sec = to_date_ofday ~zone t in
-    Date0.to_string date ^ " " ^ Ofday.to_sec_string sec
+    Date0.to_string date ^ " " ^ Ofday_ns.to_sec_string sec
   ;;
 
   let to_sec_string_with_zone t ~zone = to_sec_string t ~zone ^ offset_string t ~zone
@@ -995,7 +888,7 @@ end = struct
     ^ String.tr
         ~target:':'
         ~replacement:'-'
-        (String.drop_suffix (Ofday.to_string ofday) 3)
+        (String.drop_suffix (Ofday_ns.to_string ofday) 3)
   ;;
 
   let of_filename_string s ~zone =
@@ -1005,7 +898,7 @@ end = struct
       | Some (date, ofday) ->
         let date = Date0.of_string date in
         let ofday = String.tr ~target:'-' ~replacement:':' ofday in
-        let ofday = Ofday.of_string ofday in
+        let ofday = Ofday_ns.of_string ofday in
         of_date_ofday date ofday ~zone
     with
     | exn -> invalid_argf "Time.of_filename_string (%s): %s" s (Exn.to_string exn) ()
@@ -1017,7 +910,7 @@ end = struct
       | None -> invalid_arg (sprintf "no space in date_ofday string: %s" str)
       | Some (date, time) ->
         let date = Date0.of_string date in
-        let ofday = Ofday.of_string time in
+        let ofday = Ofday_ns.of_string time in
         of_date_ofday ~zone date ofday
     with
     | e -> Exn.reraise e "Time.of_localized_string"
@@ -1070,7 +963,7 @@ end = struct
            | None -> failwith "no spaces or T found")
         | _ -> failwith "too many spaces"
       in
-      let ofday_to_sec od = Span.to_sec (Ofday.to_span_since_start_of_day od) in
+      let ofday_to_sec od = Span.to_sec (Ofday_ns.to_span_since_start_of_day od) in
       let ofday, utc_offset =
         match tz with
         | Some _ -> ofday, None
@@ -1080,15 +973,18 @@ end = struct
           else (
             match String.lsplit2 ~on:'+' ofday with
             | Some (l, r) ->
-              l, Some (ofday_to_sec (Ofday.of_string (ensure_colon_in_offset r)))
+              l, Some (ofday_to_sec (Ofday_ns.of_string (ensure_colon_in_offset r)))
             | None ->
               (match String.lsplit2 ~on:'-' ofday with
                | Some (l, r) ->
-                 l, Some (-1. *. ofday_to_sec (Ofday.of_string (ensure_colon_in_offset r)))
+                 ( l
+                 , Some
+                     (-1. *. ofday_to_sec (Ofday_ns.of_string (ensure_colon_in_offset r)))
+                 )
                | None -> ofday, None))
       in
       let date = Date0.of_string date in
-      let ofday = Ofday.of_string ofday in
+      let ofday = Ofday_ns.of_string ofday in
       match tz with
       | Some tz -> of_date_ofday ~zone:(find_zone tz) date ofday
       | None ->
@@ -1110,12 +1006,326 @@ end = struct
     in
     of_string_gen ~default_zone ~find_zone s
   ;;
-
-  let of_string = of_string_with_utc_offset
 end
 
 include To_and_of_string
 
+let to_string t = to_string_abs t ~zone:(Lazy.force Timezone.local)
+
+exception Time_string_not_absolute of string [@@deriving sexp]
+
+let of_string_gen ~if_no_timezone ?(find_zone = Timezone.find_exn) s =
+  let default_zone () =
+    match if_no_timezone with
+    | `Fail -> raise (Time_string_not_absolute s)
+    | `Local -> Lazy.force Timezone.local
+    | `Use_this_one zone -> zone
+    | `Use_this_one_lazy zone -> Lazy.force zone
+  in
+  of_string_gen ~default_zone ~find_zone s
+;;
+
+let of_string_abs s = of_string_gen ~if_no_timezone:`Fail s
+let of_string s = of_string_gen ~if_no_timezone:`Local s
+let arg_type = Command.Arg_type.create of_string_abs
+
+module Ofday = struct
+  include Ofday_ns
+
+  let arg_type = Command.Arg_type.create of_string
+
+  let[@zero_alloc] of_ofday_float_round_nearest_microsecond core =
+    of_span_since_start_of_day_exn
+      (Span.of_span_float_round_nearest_microsecond
+         (Time_float.Ofday.to_span_since_start_of_day core))
+  ;;
+
+  let[@zero_alloc] of_ofday_float_round_nearest core =
+    of_span_since_start_of_day_exn
+      (Span.of_span_float_round_nearest
+         (Time_float.Ofday.to_span_since_start_of_day core))
+  ;;
+
+  let of_time time ~zone = to_ofday time ~zone
+
+  let to_ofday_float_round_nearest_microsecond t =
+    Time_float.Ofday.of_span_since_start_of_day_exn
+      (Span.to_span_float_round_nearest_microsecond (to_span_since_start_of_day t))
+  ;;
+
+  let to_ofday_float_round_nearest t =
+    Time_float.Ofday.of_span_since_start_of_day_exn
+      (Span.to_span_float_round_nearest (to_span_since_start_of_day t))
+  ;;
+
+  let now ~zone = of_time (now ()) ~zone
+
+  (* Legacy conversions that round to the nearest microsecond *)
+  let to_ofday = to_ofday_float_round_nearest_microsecond
+  let of_ofday = of_ofday_float_round_nearest_microsecond
+
+  module Zoned = struct
+    type t =
+      { ofday : Ofday_ns.t
+      ; zone : Timezone.t
+      }
+    [@@deriving bin_io, fields ~getters, compare, equal, hash]
+
+    type sexp_repr = Ofday_ns.t * Timezone.t [@@deriving sexp]
+
+    let sexp_of_t t = [%sexp_of: sexp_repr] (t.ofday, t.zone)
+
+    let t_of_sexp sexp =
+      let ofday, zone = [%of_sexp: sexp_repr] sexp in
+      { ofday; zone }
+    ;;
+
+    let to_time_ns t date = of_date_ofday ~zone:(zone t) date (ofday t)
+    let create ofday zone = { ofday; zone }
+    let create_local ofday = create ofday (Lazy.force Timezone.local)
+
+    let of_string string : t =
+      match String.split string ~on:' ' with
+      | [ ofday; zone ] ->
+        { ofday = Ofday_ns.of_string ofday; zone = Timezone.of_string zone }
+      | _ -> failwithf "Ofday.Zoned.of_string %s" string ()
+    ;;
+
+    let to_string (t : t) : string =
+      String.concat [ Ofday_ns.to_string t.ofday; " "; Timezone.to_string t.zone ]
+    ;;
+
+    let arg_type = Command.Arg_type.create of_string
+
+    module With_nonchronological_compare = struct
+      type nonrec t = t [@@deriving bin_io, compare, equal, sexp, hash]
+    end
+
+    include Pretty_printer.Register (struct
+        type nonrec t = t
+
+        let to_string = to_string
+        let module_name = "Core.Time_ns.Ofday.Zoned"
+      end)
+
+    module Stable = struct
+      module V1 = struct
+        let compare = With_nonchronological_compare.compare
+
+        module Bin_repr = struct
+          type nonrec t = t =
+            { ofday : Ofday_ns.Stable.V1.t
+            ; zone : Timezone.Stable.V1.t
+            }
+          [@@deriving bin_io, stable_witness]
+        end
+
+        include
+          Binable.Of_binable_without_uuid [@alert "-legacy"]
+            (Bin_repr)
+            (struct
+              type nonrec t = t
+
+              let to_binable t : Bin_repr.t = { ofday = ofday t; zone = zone t }
+              let of_binable (repr : Bin_repr.t) = create repr.ofday repr.zone
+            end)
+
+        type nonrec t = t [@@deriving hash]
+
+        let stable_witness : t Stable_witness.t = Bin_repr.stable_witness
+
+        type sexp_repr = Ofday_ns.Stable.V1.t * Timezone.Stable.V1.t [@@deriving sexp]
+
+        let sexp_of_t t = [%sexp_of: sexp_repr] (ofday t, zone t)
+
+        let t_of_sexp sexp =
+          let ofday, zone = [%of_sexp: sexp_repr] sexp in
+          create ofday zone
+        ;;
+      end
+    end
+  end
+
+  module Option = struct
+    type ofday = t [@@deriving sexp, compare]
+    type t = Span.Option.t [@@deriving bin_io, compare, equal, hash, typerep]
+
+    let none = Span.Option.none
+    let[@zero_alloc] some t = Span.Option.some (to_span_since_start_of_day t)
+    let[@zero_alloc] is_none t = Span.Option.is_none t
+    let[@zero_alloc] is_some t = Span.Option.is_some t
+
+    let[@zero_alloc] some_is_representable t =
+      Span.Option.some_is_representable (to_span_since_start_of_day t)
+    ;;
+
+    let[@zero_alloc] value t ~default =
+      Bool.select
+        (is_none t)
+        default
+        (of_span_since_start_of_day_unchecked (Span.Option.unchecked_value t))
+    ;;
+
+    let[@zero_alloc] of_span_since_start_of_day span =
+      if span_since_start_of_day_is_valid span then Span.Option.some span else none
+    ;;
+
+    let[@zero_alloc] value_exn t =
+      if is_some t
+      then of_span_since_start_of_day_unchecked (Span.Option.unchecked_value t)
+      else raise_s [%message [%here] "Time_ns.Ofday.Option.value_exn none"]
+    ;;
+
+    let[@zero_alloc] unchecked_value t =
+      of_span_since_start_of_day_unchecked (Span.Option.unchecked_value t)
+    ;;
+
+    let[@zero_alloc] of_option = function
+      | None -> none
+      | Some t -> some t
+    ;;
+
+    let to_option t = if is_none t then None else Some (value_exn t)
+
+    (* Can't use the quickcheck generator and shrinker inherited from [Span.Option]
+       because they may produce spans whose representation is larger than
+       [start_of_next_day] *)
+    let quickcheck_generator : t Quickcheck.Generator.t =
+      Quickcheck.Generator.map
+        ~f:of_option
+        (quickcheck_generator_option
+           (Quickcheck.Generator.filter
+              ~f:some_is_representable
+              Ofday_ns.quickcheck_generator))
+    ;;
+
+    let quickcheck_shrinker : t Quickcheck.Shrinker.t =
+      Quickcheck.Shrinker.map
+        ~f:of_option
+        ~f_inverse:to_option
+        (quickcheck_shrinker_option
+           (Base_quickcheck.Shrinker.filter
+              ~f:some_is_representable
+              Ofday_ns.quickcheck_shrinker))
+    ;;
+
+    let quickcheck_observer = Span.Option.quickcheck_observer
+
+    module Optional_syntax = struct
+      module Optional_syntax = struct
+        let is_none = is_none
+        let unsafe_value = unchecked_value
+      end
+    end
+
+    module Stable = struct
+      module V1 = struct
+        module T = struct
+          type nonrec t = t [@@deriving compare, equal, bin_io]
+
+          let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
+          let sexp_of_t t = [%sexp_of: Ofday_ns.Stable.V1.t option] (to_option t)
+          let t_of_sexp s = of_option ([%of_sexp: Ofday_ns.Stable.V1.t option] s)
+          let to_int63 t = Span.Option.Stable.V1.to_int63 t
+          let of_int63_exn t = Span.Option.Stable.V1.of_int63_exn t
+        end
+
+        include T
+        include Comparator.Stable.V1.Make (T)
+
+        include Diffable.Atomic.Make (struct
+            type nonrec t = t [@@deriving sexp, bin_io, equal]
+          end)
+      end
+    end
+
+    let sexp_of_t = Stable.V1.sexp_of_t
+    let t_of_sexp = Stable.V1.t_of_sexp
+
+    include Identifiable.Make (struct
+        type nonrec t = t [@@deriving sexp, compare, bin_io, hash]
+
+        let module_name = "Core.Time_ns.Ofday.Option"
+
+        include Sexpable.To_stringable (struct
+            type nonrec t = t [@@deriving sexp]
+          end)
+      end)
+
+    include (Span.Option : Comparisons.S with type t := t)
+
+    include Diffable.Atomic.Make (struct
+        type nonrec t = t [@@deriving sexp, bin_io, equal]
+      end)
+  end
+end
+
+let get_sexp_zone = Time_float.get_sexp_zone
+let set_sexp_zone = Time_float.set_sexp_zone
+
+let t_of_sexp_gen ~if_no_timezone sexp =
+  try
+    match sexp with
+    | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday; Sexp.Atom tz ] ->
+      of_date_ofday
+        ~zone:(Timezone.find_exn tz)
+        (Date.of_string date)
+        (Ofday.of_string ofday)
+    (* This is actually where the output of [sexp_of_t] is handled, since that's e.g.
+       (2015-07-06 09:09:44.787988+01:00). *)
+    | Sexp.List [ Sexp.Atom date; Sexp.Atom ofday_and_possibly_zone ] ->
+      of_string_gen ~if_no_timezone (date ^ " " ^ ofday_and_possibly_zone)
+    | Sexp.Atom datetime -> of_string_gen ~if_no_timezone datetime
+    | _ -> of_sexp_error "Time.t_of_sexp" sexp
+  with
+  | Of_sexp_error _ as e -> raise e
+  | e -> of_sexp_error (sprintf "Time.t_of_sexp: %s" (Exn.to_string e)) sexp
+;;
+
+let t_of_sexp sexp = t_of_sexp_gen sexp ~if_no_timezone:(`Use_this_one (get_sexp_zone ()))
+let t_of_sexp_abs sexp = t_of_sexp_gen sexp ~if_no_timezone:`Fail
+
+let t_sexp_grammar : t Sexplib.Sexp_grammar.t =
+  { untyped =
+      Union
+        [ String
+        ; List (Cons (String, Cons (String, Empty)))
+        ; List (Cons (String, Cons (String, Cons (String, Empty))))
+        ]
+  }
+;;
+
+let sexp_of_t_abs t ~zone =
+  Sexp.List (List.map (to_string_abs_parts ~zone t) ~f:(fun s -> Sexp.Atom s))
+;;
+
+let sexp_of_t t = sexp_of_t_abs ~zone:(get_sexp_zone ()) t
+let of_date_ofday_zoned date ofday_zoned = Ofday.Zoned.to_time_ns ofday_zoned date
+
+let to_date_ofday_zoned t ~zone =
+  let date, ofday = to_date_ofday t ~zone in
+  date, Ofday.Zoned.create ofday zone
+;;
+
+let to_ofday_zoned t ~zone =
+  let ofday = to_ofday t ~zone in
+  Ofday.Zoned.create ofday zone
+;;
+
+include Diffable.Atomic.Make (struct
+    type nonrec t = t [@@deriving bin_io, equal, sexp]
+  end)
+
+(* Note: This is FIX standard millisecond precision. You should use
+   [Zero.Time_ns_with_fast_accurate_to_of_string] if you need nanosecond precision. *)
+let to_string_fix_proto zone t =
+  Time_float.to_string_fix_proto zone (to_time_float_round_nearest_microsecond t)
+;;
+
+let of_string_fix_proto zone s =
+  of_time_float_round_nearest_microsecond (Time_float.of_string_fix_proto zone s)
+;;
+
 let min_value_representable = of_span_since_epoch Span.min_value_representable
 let max_value_representable = of_span_since_epoch Span.max_value_representable
 
@@ -1130,55 +1340,220 @@ module _ = struct
 
   let () =
     Duration.format
-      := (module struct
-           let duration_of_span s = s |> Span.to_int63_ns |> Duration.of_nanoseconds
-           let span_of_duration d = d |> Duration.to_nanoseconds |> Span.of_int63_ns
-           let of_string string = string |> Span.of_string |> duration_of_span
-
-           let to_string_with_same_unit durations =
-             let spans = durations |> List.map ~f:span_of_duration in
-             let unit_of_time =
-               spans
-               |> List.max_elt ~compare:Span.compare
-               |> Option.value_map
-                    ~f:Span.to_unit_of_time
-                    ~default:Unit_of_time.Nanosecond
-             in
-             spans |> List.map ~f:(Span.to_string_hum ~unit_of_time ~align_decimal:true)
-           ;;
-         end)
+    := (module struct
+         let duration_of_span s = s |> Span.to_int63_ns |> Duration.of_nanoseconds
+         let span_of_duration d = d |> Duration.to_nanoseconds |> Span.of_int63_ns
+         let of_string string = string |> Span.of_string |> duration_of_span
+
+         let to_string_with_same_unit durations =
+           let spans = durations |> List.map ~f:span_of_duration in
+           let unit_of_time =
+             spans
+             |> List.max_elt ~compare:Span.compare
+             |> Option.value_map ~f:Span.to_unit_of_time ~default:Unit_of_time.Nanosecond
+           in
+           spans |> List.map ~f:(Span.to_string_hum ~unit_of_time ~align_decimal:true)
+         ;;
+       end)
   ;;
 end
 
-module Option = Option0
-module Hash_queue = struct end
-module Hash_set = struct end
-module Map = struct end
-module Set = struct end
-module Table = struct end
-module Zone = struct end
-
-let arg_type = `Use_Time_ns_unix
-let comparator = `Use_Time_ns_unix
-let get_sexp_zone = `Use_Time_ns_unix
+module Stable0 = struct
+  module V1 = struct
+    module T0 = struct
+      (* We use the unstable serialization here, and rely on comprehensive tests of the
+         stable conversion to make sure we don't change it. *)
+
+      type nonrec t = t [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar]
+
+      let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
+      let of_int63_exn t = of_span_since_epoch (Span.of_int63_ns t)
+      let to_int63 t = to_int63_ns_since_epoch t
+    end
+
+    module T = struct
+      include T0
+      module Comparator = Comparator.Stable.V1.Make (T0)
+      include Comparator
+    end
+
+    include T
+    include Comparable.Stable.V1.With_stable_witness.Make (T)
+    include Diffable.Atomic.Make (T)
+  end
+end
+
+include Stable0.V1.Comparator
+
+module Option = struct
+  type time = t [@@deriving compare]
+  type t = Span.Option.t [@@deriving bin_io, compare, hash, typerep, quickcheck]
+
+  let none = Span.Option.none
+  let[@zero_alloc] some time = Span.Option.some (to_span_since_epoch time)
+  let[@zero_alloc] is_none t = Span.Option.is_none t
+  let[@zero_alloc] is_some t = Span.Option.is_some t
+
+  let[@zero_alloc] some_is_representable time =
+    Span.Option.some_is_representable (to_span_since_epoch time)
+  ;;
+
+  let[@zero_alloc] value t ~default =
+    of_span_since_epoch (Span.Option.value ~default:(to_span_since_epoch default) t)
+  ;;
+
+  let[@zero_alloc] value_exn t =
+    if is_some t
+    then of_span_since_epoch (Span.Option.unchecked_value t)
+    else raise_s [%message [%here] "Time_ns.Option.value_exn none"]
+  ;;
+
+  let[@zero_alloc] unchecked_value t = of_span_since_epoch (Span.Option.unchecked_value t)
+
+  let[@zero_alloc] of_option = function
+    | None -> none
+    | Some t -> some t
+  ;;
+
+  let to_option t = if is_none t then None else Some (value_exn t)
+
+  module Optional_syntax = struct
+    module Optional_syntax = struct
+      let[@zero_alloc] is_none t = is_none t
+      let[@zero_alloc] unsafe_value t = unchecked_value t
+    end
+  end
+
+  module Alternate_sexp = struct
+    module T = struct
+      type nonrec t = t [@@deriving bin_io, compare, hash]
+
+      let sexp_of_t t = [%sexp_of: Alternate_sexp.t option] (to_option t)
+      let t_of_sexp s = of_option ([%of_sexp: Alternate_sexp.t option] s)
+
+      let t_sexp_grammar =
+        Sexplib.Sexp_grammar.coerce [%sexp_grammar: Alternate_sexp.t option]
+      ;;
+    end
+
+    include T
+    include Comparable.Make (T)
+
+    include Diffable.Atomic.Make (struct
+        include T
+
+        let equal = [%compare.equal: t]
+      end)
+
+    module Stable = struct
+      module V1 = struct
+        module T = struct
+          type nonrec t = t [@@deriving bin_io, compare, hash, sexp, sexp_grammar]
+
+          let stable_witness : t Stable_witness.t =
+            Stable_witness.of_serializable
+              [%stable_witness: Alternate_sexp.Stable.V1.t option]
+              of_option
+              to_option
+          ;;
+
+          type nonrec comparator_witness = comparator_witness
+
+          let comparator = comparator
+        end
+
+        include T
+        include Comparable.Stable.V1.With_stable_witness.Make (T)
+
+        include Diffable.Atomic.Make (struct
+            include T
+
+            let equal = [%compare.equal: t]
+          end)
+      end
+    end
+  end
+
+  module Stable = struct
+    module V1 = struct
+      module T = struct
+        type nonrec t = t [@@deriving compare, bin_io]
+
+        let sexp_of_t t = [%sexp_of: Stable0.V1.t option] (to_option t)
+        let t_of_sexp s = of_option ([%of_sexp: Stable0.V1.t option] s)
+      end
+
+      include T
+      include Comparator.Stable.V1.Make (T)
+
+      let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
+      let to_int63 t = Span.Option.Stable.V1.to_int63 t
+      let of_int63_exn t = Span.Option.Stable.V1.of_int63_exn t
+
+      include Diffable.Atomic.Make (struct
+          include T
+
+          let equal = [%compare.equal: t]
+        end)
+    end
+
+    module Alternate_sexp = Alternate_sexp.Stable
+  end
+
+  let sexp_of_t = Stable.V1.sexp_of_t
+  let t_of_sexp = Stable.V1.t_of_sexp
+
+  include Identifiable.Make (struct
+      type nonrec t = t [@@deriving sexp, compare, bin_io, hash]
+
+      let module_name = "Core.Time_ns.Option"
+
+      include Sexpable.To_stringable (struct
+          type nonrec t = t [@@deriving sexp]
+        end)
+    end)
+
+  (* bring back the efficient implementation of comparison operators *)
+  include (Span.Option : Comparisons.S with type t := t)
+
+  include Diffable.Atomic.Make (struct
+      type nonrec t = t [@@deriving bin_io, equal, sexp]
+    end)
+end
+
+include Identifiable.Make_using_comparator (struct
+    include Stable0.V1
+
+    let module_name = "Core.Time_ns"
+    let of_string, to_string = of_string, to_string
+  end)
+
+(* bring back the efficient implementation of comparison operators *)
+include (Replace_polymorphic_compare_efficient : Comparisons.S with type t := t)
+module Zone = Time_float.Zone
+
+module Stable = struct
+  include Stable0
+  module Option = Option.Stable
+  module Alternate_sexp = Alternate_sexp.Stable
+
+  module Span = struct
+    include Span.Stable
+    module Option = Span.Option.Stable
+  end
+
+  module Ofday = struct
+    include Ofday_ns.Stable
+    module Zoned = Ofday.Zoned.Stable
+    module Option = Ofday.Option.Stable
+  end
+
+  module Zone = Timezone.Stable
+end
+
 let interruptible_pause = `Use_Time_ns_unix
-let of_date_ofday_zoned = `Use_Time_ns_unix
-let of_string_abs = `Use_Time_ns_unix
-let of_string_fix_proto = `Use_Time_ns_unix
 let pause = `Use_Time_ns_unix
 let pause_forever = `Use_Time_ns_unix
-let pp = `Use_Time_ns_unix
-let set_sexp_zone = `Use_Time_ns_unix
-let sexp_of_t = `Use_Time_ns_unix_or_Time_ns_alternate_sexp
-let sexp_of_t_abs = `Use_Time_ns_unix
-let t_of_sexp = `Use_Time_ns_unix_or_Time_ns_alternate_sexp
-let t_of_sexp_abs = `Use_Time_ns_unix
-let to_date_ofday_zoned = `Use_Time_ns_unix
-let to_ofday_zoned = `Use_Time_ns_unix
-let to_string_fix_proto = `Use_Time_ns_unix
-let validate_bound = `Use_Time_ns_unix
-let validate_lbound = `Use_Time_ns_unix
-let validate_ubound = `Use_Time_ns_unix
 
 module O = struct
   let ( >= ) = ( >= )
@@ -1187,6 +1562,36 @@ module O = struct
   let ( > ) = ( > )
   let ( < ) = ( < )
   let ( <> ) = ( <> )
-  let ( + ) = add
-  let ( - ) = diff
+  let[@zero_alloc] ( + ) t1 t2 = add t1 t2
+  let[@zero_alloc] ( - ) t1 t2 = diff t1 t2
 end
+
+(*
+   Dropping Time in favor of Time_ns is possible and has been discussed, but we have
+   chosen not to do so at this time for a few reasons:
+
+   - It's a lot of work.  All functions over Time, including the related
+     modules Date, Ofday, Zone, Span, Schedule have to be converted to Time_ns
+     space.  This is largely mechanical, but will create a lot of churn within
+     the modules and possibly externally where the floatiness of the Time world
+     leaks out.
+
+   - It's of limited utility compared to other things we could be working on.
+     Time math would be easier to understand and somewhat faster, but very few
+     modules/programs would benefit from faster time math.  Those that do can
+     use Time_ns already for the most part.
+
+   - Having Time_ns and a conversion function already gives the bulk of the
+     value to programs that want a fast, non-allocating version of [Time.now].
+     Indeed, many remaining unconverted functions
+
+   - We aren't certain about how the boundaries around Time_ns will affect the
+     external viability of Core.  Internally we don't think being limited to
+     a smaller time range is an issue, and really far off times are better
+     represented as (Date.t * Ofday.t), but it is still a restriction.  This
+     pushback is probably minimal and, if we could get over the work concerns,
+     could be eliminated.
+
+   - Converting between Time and Time_ns when you use libraries based on different ones
+     isn't so bad. (?)
+*)
Index: core-0.17.1/core/src/time_ns_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/time_ns_intf.ml
+++ core-0.17.1/core/src/time_ns_intf.ml
@@ -1,4 +1,5 @@
 open! Import
+open! Std_internal
 
 module Rounding_direction = struct
   type t =
@@ -11,16 +12,16 @@ end
 
 module type Span = sig
   (** [t] is immediate on 64bit boxes and so plays nicely with the GC write barrier. *)
-  type t = private Int63.t [@@deriving hash]
+  type t = private Int63.t [@@deriving hash, typerep]
 
   include Span_intf.S with type underlying = Int63.t and type t := t
 
   val of_sec_with_microsecond_precision : float -> t
-  val of_int_us : int -> t
-  val of_int_ms : int -> t
-  val to_int_us : t -> int
-  val to_int_ms : t -> int
-  val to_int_sec : t -> int
+  val of_int_us : int -> t [@@zero_alloc]
+  val of_int_ms : int -> t [@@zero_alloc]
+  val to_int_us : t -> int [@@zero_alloc]
+  val to_int_ms : t -> int [@@zero_alloc]
+  val to_int_sec : t -> int [@@zero_alloc]
 
   (** Approximations of float conversions using multiplication instead of division. *)
 
@@ -45,18 +46,18 @@ module type Span = sig
 
   (** An alias for [min_value_for_1us_rounding]. *)
   val min_value : t
-    [@@deprecated
-      "[since 2019-02] use [min_value_representable] or [min_value_for_1us_rounding] \
-       instead"]
+  [@@deprecated
+    "[since 2019-02] use [min_value_representable] or [min_value_for_1us_rounding] \
+     instead"]
 
   (** An alias for [max_value_for_1us_rounding]. *)
   val max_value : t
-    [@@deprecated
-      "[since 2019-02] use [max_value_representable] or [max_value_for_1us_rounding] \
-       instead"]
+  [@@deprecated
+    "[since 2019-02] use [max_value_representable] or [max_value_for_1us_rounding] \
+     instead"]
 
   (** overflows silently *)
-  val scale_int : t -> int -> t
+  val scale_int : t -> int -> t [@@zero_alloc]
 
   (** overflows silently *)
   val scale_int63 : t -> Int63.t -> t
@@ -72,9 +73,10 @@ module type Span = sig
 
   (** Will raise on 32-bit platforms.  Consider [to_int63_ns] instead. *)
   val to_int_ns : t -> int
+  [@@zero_alloc]
 
   val of_int_ns : int -> t
-  val since_unix_epoch : unit -> t
+  val since_unix_epoch : unit -> t [@@zero_alloc]
   val random : ?state:Random.State.t -> unit -> t
 
   (** WARNING!!! [to_span] and [of_span] both round to the nearest 1us.
@@ -82,14 +84,14 @@ module type Span = sig
       Around 135y magnitudes [to_span] and [of_span] raise.
   *)
   val to_span : t -> Span_float.t
-    [@@deprecated
-      "[since 2019-01] use [to_span_float_round_nearest] or \
-       [to_span_float_round_nearest_microsecond]"]
+  [@@deprecated
+    "[since 2019-01] use [to_span_float_round_nearest] or \
+     [to_span_float_round_nearest_microsecond]"]
 
   val of_span : Span_float.t -> t
-    [@@deprecated
-      "[since 2019-01] use [of_span_float_round_nearest] or \
-       [of_span_float_round_nearest_microsecond]"]
+  [@@deprecated
+    "[since 2019-01] use [of_span_float_round_nearest] or \
+     [of_span_float_round_nearest_microsecond]"]
 
   (** [*_round_nearest] vs [*_round_nearest_microsecond]: If you don't know that you need
       microsecond precision, use the [*_round_nearest] version.
@@ -119,19 +121,19 @@ module type Span = sig
   val arg_type : t Command.Arg_type.t
 
   module O : sig
-    val ( / ) : t -> float -> t
+    val ( / ) : t -> float -> t [@@zero_alloc]
     val ( // ) : t -> t -> float
-    val ( + ) : t -> t -> t
-    val ( - ) : t -> t -> t
+    val ( + ) : t -> t -> t [@@zero_alloc]
+    val ( - ) : t -> t -> t [@@zero_alloc]
 
     (** alias for [neg] *)
-    val ( ~- ) : t -> t
+    val ( ~- ) : t -> t [@@zero_alloc]
 
     (** alias for [scale] *)
-    val ( *. ) : t -> float -> t
+    val ( *. ) : t -> float -> t [@@zero_alloc]
 
     (** alias for [scale_int] *)
-    val ( * ) : t -> int -> t
+    val ( * ) : t -> int -> t [@@zero_alloc]
 
     include Comparisons.Infix with type t := t
   end
@@ -140,7 +142,7 @@ module type Span = sig
       architectures where [Int63.t] is immediate.  This module should mainly be used to
       avoid allocations. *)
   module Option : sig
-    include Immediate_option.S_int63 with type value := t
+    include Immediate_option.S_int63_zero_alloc with type value := t
     include Identifiable.S with type t := t
     include Diffable.S_atomic with type t := t
     include Quickcheck.S with type t := t
@@ -167,18 +169,18 @@ module type Span = sig
     end
 
     module V2 : sig
-      type nonrec t = t [@@deriving hash, equal, sexp_grammar]
+      type nonrec t = t [@@deriving hash, equal, sexp_grammar, typerep]
       type nonrec comparator_witness = comparator_witness
 
       include
         Stable_int63able.With_stable_witness.S
-          with type t := t
-          with type comparator_witness := comparator_witness
+        with type t := t
+        with type comparator_witness := comparator_witness
 
       include
         Comparable.Stable.V1.With_stable_witness.S
-          with type comparable := t
-          with type comparator_witness := comparator_witness
+        with type comparable := t
+        with type comparator_witness := comparator_witness
 
       include Stringable.S with type t := t
       include Diffable.S_atomic with type t := t
@@ -218,10 +220,12 @@ module type Ofday = sig
   (** [add_exn t span] shifts the time of day [t] by [span]. It raises if the result is
       not in the same 24-hour day. Daylight savings shifts are not accounted for. *)
   val add_exn : t -> Span.t -> t
+  [@@zero_alloc]
 
   (** [sub_exn t span] shifts the time of day [t] back by [span]. It raises if the result
       is not in the same 24-hour day. Daylight savings shifts are not accounted for. *)
   val sub_exn : t -> Span.t -> t
+  [@@zero_alloc]
 
   (** [every span ~start ~stop] returns a sorted list of all [t]s that can be expressed as
       [start + (i * span)] without overflow, and satisfying [t >= start && t <= stop].
@@ -240,46 +244,125 @@ module type Ofday = sig
 
       include
         Stable_int63able.With_stable_witness.S
-          with type t := t
-           and type comparator_witness = comparator_witness
+        with type t := t
+         and type comparator_witness = comparator_witness
 
       include Diffable.S_atomic with type t := t
     end
   end
+end
 
-  val arg_type : [ `Use_Time_ns_unix ] [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-  val now : [ `Use_Time_ns_unix ] [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+module type Time_ns = sig
+  (** An absolute point in time, more efficient and precise than the [float]-based
+    {!Time_float}, but representing a narrower range of times.
 
-  val of_ofday_float_round_nearest : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+    This module represents absolute times with nanosecond precision, approximately between
+    the years 1823 and 2116 CE.
 
-  val of_ofday_float_round_nearest_microsecond : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+    Some reasons you might prefer [Time_ns.t] over float-based [Time_float.t]:
 
-  val to_ofday_float_round_nearest : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+    - It has superior performance.
 
-  val to_ofday_float_round_nearest_microsecond : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+    - It uses [int]s rather than [float]s internally, which makes certain things easier to
+      reason about, since [int]s respect a bunch of arithmetic identities that [float]s
+      don't, e.g., [x + (y + z) = (x + y) + z].
 
-  module Option : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-  module Zoned : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-end
+    Some reasons you might prefer to use float-based [Time_float] instead of this module:
 
-(** Time represented as an [Int63.t] number of nanoseconds since the epoch.
+    - Some libraries use [Time_float.t] values, often for historical reasons, so it may be
+      necessary to use [Time_float.t] with them.
 
-    See {!Time_ns_unix} for important user documentation.
+    - [Time_ns] silently ignores overflow.
+
+    Neither {!Time_ns_unix} nor {!Time_float_unix} are available in JavaScript, but both
+    {!Core.Time_ns} and {!Core.Time_float} are. *)
+
+  type t = private Int63.t [@@deriving hash, typerep, bin_io, sexp, sexp_grammar]
+  type time_ns := t
 
-    Internally, arithmetic is not overflow-checked. Instead, overflows are silently
-    ignored as for [int] arithmetic, unless specifically documented otherwise. Conversions
-    may (or may not) raise if prior arithmetic operations overflowed. *)
-module type Time_ns = sig
   module Span : Span
-  module Ofday : Ofday with module Span := Span
 
-  type t = private Int63.t [@@deriving hash, typerep, bin_io]
+  module Ofday : sig
+    include Ofday with module Span := Span
+
+    val arg_type : t Command.Arg_type.t
+    val now : zone:Timezone.t -> t
+
+    val to_ofday : t -> Time_float.Ofday.t
+    [@@deprecated
+      "[since 2019-01] use [to_ofday_float_round_nearest] or \
+       [to_ofday_float_round_nearest_microsecond]"]
+
+    val of_ofday : Time_float.Ofday.t -> t
+    [@@deprecated
+      "[since 2019-01] use [of_ofday_float_round_nearest] or \
+       [of_ofday_float_round_nearest_microsecond]"]
+
+    val to_ofday_float_round_nearest : t -> Time_float.Ofday.t
+    val to_ofday_float_round_nearest_microsecond : t -> Time_float.Ofday.t
+    val of_ofday_float_round_nearest : Time_float.Ofday.t -> t [@@zero_alloc]
+    val of_ofday_float_round_nearest_microsecond : Time_float.Ofday.t -> t [@@zero_alloc]
+
+    module Zoned : sig
+      (** Sexps look like "(12:01 nyc)"
+
+        Two [t]'s may or may not correspond to the same times depending on which date
+        they're evaluated. *)
+      type ofday := t
+
+      type t [@@deriving bin_io, sexp, hash]
+
+      include Pretty_printer.S with type t := t
+
+      (** Strings look like "12:01 nyc" *)
+      include Stringable.S with type t := t
+
+      val arg_type : t Command.Arg_type.t
+      val create : ofday -> Time_float.Zone.t -> t
+      val create_local : ofday -> t
+      val ofday : t -> ofday
+      val zone : t -> Time_float.Zone.t
+      val to_time_ns : t -> Date.t -> time_ns
+
+      module With_nonchronological_compare : sig
+        (** It is possible to consistently compare [t]'s, but due to the complexities of
+          time zones and daylight savings, the resulting ordering is not chronological.
+          That is, [compare t1 t2 > 0] does not imply [t2] occurs after [t1] every day,
+          or any day. *)
+        type nonrec t = t [@@deriving bin_io, sexp, compare, equal, hash]
+      end
+
+      module Stable : sig
+        module V1 : sig
+          type nonrec t = t [@@deriving hash]
+
+          include Stable_without_comparator_with_witness with type t := t
+        end
+      end
+    end
+
+    module Option : sig
+      include Immediate_option.S_int63 with type value := t
+      include Identifiable with type t := t
+      include Quickcheck.S with type t := t
+      include Diffable.S_atomic with type t := t
+
+      module Stable : sig
+        module V1 : sig
+          include Stable_int63able_with_witness with type t = t
+          include Diffable.S_atomic with type t := t
+        end
+      end
+
+      (** Returns [some] if the given span is a valid time since start of day, and [none]
+        otherwise. *)
+      val of_span_since_start_of_day : Span.t -> t
+    end
+  end
 
   include Comparisons.S with type t := t
+  include Diffable.S_atomic with type t := t
+  module Zone : module type of Time_float.Zone with type t = Time_float.Zone.t
 
   (** Note that we expose a sexp format that is not the one exposed in [Time_ns_unix]. The
       sexp is a single atom rendered as with [to_string_utc], except that all trailing
@@ -297,21 +380,18 @@ module type Time_ns = sig
     type value := t
     type t = private Span.Option.t [@@deriving compare, bin_io]
 
-    include Immediate_option.S_int63 with type value := value with type t := t
+    include Immediate_option.S_int63_zero_alloc with type value := value with type t := t
+    include Identifiable with type t := t
     include Quickcheck.S with type t := t
+    include Diffable.S_atomic with type t := t
 
     module Stable : sig
       module V1 : sig
-        type nonrec t = t [@@deriving compare, bin_io, stable_witness]
-
-        val to_int63 : t -> Int63.t
-        val of_int63_exn : Int63.t -> t
+        include Stable_int63able_with_witness with type t = t
+        include Diffable.S_atomic with type t := t
       end
     end
 
-    val sexp_of_t : [ `Use_Time_ns_unix ]
-      [@@deprecated "[since 2023-09] Use [Time_ns_unix.Option]"]
-
     include Comparisons.S with type t := t
 
     (** Just like [Time_ns.Alternate_sexp], this is different from the sexp format exposed
@@ -327,18 +407,49 @@ module type Time_ns = sig
   include
     Time_intf.Shared with type t := t with module Span := Span with module Ofday := Ofday
 
-  val of_string : string -> t
-    [@@deprecated
-      "[since 2021-04] Use [of_string_with_utc_offset] or [Time_ns_unix.of_string]"]
+  (** These functions are identical to those in [Time] and get/set the same variable. *)
+
+  val get_sexp_zone : unit -> Zone.t
+  val set_sexp_zone : Zone.t -> unit
+
+  (** [t_of_sexp_abs sexp] as [t_of_sexp], but demands that [sexp] indicate the timezone
+      the time is expressed in. *)
+  val t_of_sexp_abs : Sexp.t -> t
+
+  val sexp_of_t_abs : t -> zone:Zone.t -> Sexp.t
+
+  (** Conversion functions that involved Ofday.Zoned.t, exactly analogous to the
+      conversion functions that involve Ofday.t *)
+  val of_date_ofday_zoned : Date.t -> Ofday.Zoned.t -> t
+
+  val to_date_ofday_zoned : t -> zone:Zone.t -> Date.t * Ofday.Zoned.t
+  val to_ofday_zoned : t -> zone:Zone.t -> Ofday.Zoned.t
+  val to_string_fix_proto : [ `Utc | `Local ] -> t -> string
+  val of_string_fix_proto : [ `Utc | `Local ] -> string -> t
+
+  (** This is like [of_string] except that if the string doesn't specify the zone then it
+      raises rather than assume the local timezone. *)
+  val of_string_abs : string -> t
+
+  (** [of_string_gen ~if_no_timezone ?find_zone s] attempts to parse [s] to a [t].  If [s]
+      doesn't supply a time zone [if_no_timezone] is consulted. [find_zone] is used to
+      look up time zones by name. *)
+  val of_string_gen
+    :  if_no_timezone:
+         [ `Fail
+         | `Local
+         | `Use_this_one of Zone.t
+         | `Use_this_one_lazy of Zone.t Lazy.t
+         ]
+    -> ?find_zone:(string -> Zone.t) (** default: [Timezone.find_exn] *)
+    -> string
+    -> t
 
   (** [of_string_with_utc_offset] requires its input to have an explicit
       UTC offset, e.g. [2000-01-01 12:34:56.789012-23], or use the UTC zone, "Z",
       e.g. [2000-01-01 12:34:56.789012Z]. *)
   val of_string_with_utc_offset : string -> t
 
-  val to_string : t -> string
-    [@@deprecated "[since 2021-04] Use [to_string_utc] or [Time_ns_unix.to_string]"]
-
   (** [to_string_utc] generates a time string with the UTC zone, "Z", e.g. [2000-01-01
       12:34:56.789012Z]. *)
   val to_string_utc : t -> string
@@ -360,54 +471,57 @@ module type Time_ns = sig
 
   (** An alias for [min_value_for_1us_rounding]. *)
   val min_value : t
-    [@@deprecated
-      "[since 2019-02] use [min_value_representable] or [min_value_for_1us_rounding] \
-       instead"]
+  [@@deprecated
+    "[since 2019-02] use [min_value_representable] or [min_value_for_1us_rounding] \
+     instead"]
 
   (** An alias for [max_value_for_1us_rounding]. *)
   val max_value : t
-    [@@deprecated
-      "[since 2019-02] use [max_value_representable] or [max_value_for_1us_rounding] \
-       instead"]
+  [@@deprecated
+    "[since 2019-02] use [max_value_representable] or [max_value_for_1us_rounding] \
+     instead"]
 
   (** The current time. *)
-  val now : unit -> t
+  val now : unit -> t [@@zero_alloc]
 
   (** overflows silently *)
-  val add : t -> Span.t -> t
+  val add : t -> Span.t -> t [@@zero_alloc]
 
   (** As [add]; rather than over/underflowing, clamps the result to the closed interval
       between [min_value_representable] and [max_value_representable]. *)
   val add_saturating : t -> Span.t -> t
+  [@@zero_alloc]
 
   (** As [sub]; rather than over/underflowing, clamps the result to the closed interval
       between [min_value_representable] and [max_value_representable]. *)
   val sub_saturating : t -> Span.t -> t
+  [@@zero_alloc]
 
   (** overflows silently *)
-  val sub : t -> Span.t -> t
+  val sub : t -> Span.t -> t [@@zero_alloc]
 
   (** overflows silently *)
-  val next : t -> t
+  val next : t -> t [@@zero_alloc]
 
   (** overflows silently *)
-  val prev : t -> t
+  val prev : t -> t [@@zero_alloc]
 
   (** overflows silently *)
-  val diff : t -> t -> Span.t
+  val diff : t -> t -> Span.t [@@zero_alloc]
 
   (** overflows silently *)
-  val abs_diff : t -> t -> Span.t
+  val abs_diff : t -> t -> Span.t [@@zero_alloc]
 
-  val to_span_since_epoch : t -> Span.t
-  val of_span_since_epoch : Span.t -> t
+  val to_span_since_epoch : t -> Span.t [@@zero_alloc]
+  val of_span_since_epoch : Span.t -> t [@@zero_alloc]
   val to_int63_ns_since_epoch : t -> Int63.t
   val of_int63_ns_since_epoch : Int63.t -> t
 
   (** Will raise on 32-bit platforms.  Consider [to_int63_ns_since_epoch] instead. *)
   val to_int_ns_since_epoch : t -> int
+  [@@zero_alloc]
 
-  val of_int_ns_since_epoch : int -> t
+  val of_int_ns_since_epoch : int -> t [@@zero_alloc]
 
   (** [next_multiple ~base ~after ~interval] returns the smallest [time] of the form:
 
@@ -488,14 +602,14 @@ module type Time_ns = sig
   val random : ?state:Random.State.t -> unit -> t
 
   val of_time : Time_float.t -> t
-    [@@deprecated
-      "[since 2019-01] use [of_time_float_round_nearest] or \
-       [of_time_float_round_nearest_microsecond]"]
+  [@@deprecated
+    "[since 2019-01] use [of_time_float_round_nearest] or \
+     [of_time_float_round_nearest_microsecond]"]
 
   val to_time : t -> Time_float.t
-    [@@deprecated
-      "[since 2019-01] use [to_time_float_round_nearest] or \
-       [to_time_float_round_nearest_microsecond]"]
+  [@@deprecated
+    "[since 2019-01] use [to_time_float_round_nearest] or \
+     [to_time_float_round_nearest_microsecond]"]
 
   (** [*_round_nearest] vs [*_round_nearest_microsecond]: If you don't know that you need
       microsecond precision, use the [*_round_nearest] version.
@@ -503,8 +617,8 @@ module type Time_ns = sig
 
   val to_time_float_round_nearest : t -> Time_float.t
   val to_time_float_round_nearest_microsecond : t -> Time_float.t
-  val of_time_float_round_nearest : Time_float.t -> t
-  val of_time_float_round_nearest_microsecond : Time_float.t -> t
+  val of_time_float_round_nearest : Time_float.t -> t [@@zero_alloc]
+  val of_time_float_round_nearest_microsecond : Time_float.t -> t [@@zero_alloc]
 
   module Utc : sig
     (** [to_date_and_span_since_start_of_day] computes the date and intraday-offset of a
@@ -514,28 +628,49 @@ module type Time_ns = sig
 
     (** The inverse of [to_date_and_span_since_start_of_day]. *)
     val of_date_and_span_since_start_of_day : Date0.t -> Span.t -> t
+    [@@zero_alloc]
   end
 
   module O : sig
     (** alias for [add] *)
-    val ( + ) : t -> Span.t -> t
+    val ( + ) : t -> Span.t -> t [@@zero_alloc]
 
     (** alias for [diff] *)
-    val ( - ) : t -> t -> Span.t
+    val ( - ) : t -> t -> Span.t [@@zero_alloc]
 
     include Comparisons.Infix with type t := t
   end
 
+  (** String conversions use the local timezone by default. Sexp conversions use
+      [get_sexp_zone ()] by default, which can be overridden by calling [set_sexp_zone].
+      These default time zones are used when writing a time, and when reading a time with
+      no explicit zone or UTC offset.
+
+      Sexps and strings display the date, ofday, and UTC offset of [t] relative to the
+      appropriate time zone. *)
+  include Identifiable with type t := t
+
   module Stable : sig
-    module V1 : sig end
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix] or [Time_ns.Alternate_sexp]"]
+    module V1 : sig
+      type nonrec t = t [@@deriving equal, hash, sexp_grammar]
+
+      include
+        Stable_int63able_with_witness
+        with type t := t
+         and type comparator_witness = comparator_witness
+
+      include
+        Comparable.Stable.V1.With_stable_witness.S
+        with type comparable := t
+        with type comparator_witness := comparator_witness
+
+      include Diffable.S_atomic with type t := t
+    end
 
     module Option : sig
       module V1 : sig
-        type nonrec t = Option.t [@@deriving compare, bin_io, stable_witness]
-
-        val to_int63 : t -> Int63.t
-        val of_int63_exn : Int63.t -> t
+        include Stable_int63able_with_witness with type t = Option.t
+        include Diffable.S_atomic with type t := t
       end
 
       module Alternate_sexp : sig
@@ -545,19 +680,21 @@ module type Time_ns = sig
 
           include
             Comparator.Stable.V1.S
-              with type t := t
-               and type comparator_witness = Option.Alternate_sexp.comparator_witness
+            with type t := t
+             and type comparator_witness = Option.Alternate_sexp.comparator_witness
 
           include
             Comparable.Stable.V1.With_stable_witness.S
-              with type comparable := t
-              with type comparator_witness := comparator_witness
+            with type comparable := t
+            with type comparator_witness := comparator_witness
 
           include Diffable.S_atomic with type t := t
         end
       end
     end
 
+    (** Provides a sexp representation that is independent of the time zone of the machine
+        writing it. *)
     module Alternate_sexp : sig
       module V1 : sig
         type t = Alternate_sexp.t
@@ -565,13 +702,13 @@ module type Time_ns = sig
 
         include
           Comparator.Stable.V1.S
-            with type t := t
-             and type comparator_witness = Alternate_sexp.comparator_witness
+          with type t := t
+           and type comparator_witness = Alternate_sexp.comparator_witness
 
         include
           Comparable.Stable.V1.With_stable_witness.S
-            with type comparable := t
-            with type comparator_witness := comparator_witness
+          with type comparable := t
+          with type comparator_witness := comparator_witness
 
         include Diffable.S_atomic with type t := t
       end
@@ -585,25 +722,35 @@ module type Time_ns = sig
         include Diffable.S_atomic with type t := t
       end
 
-      module Option : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
       module V2 : sig
         type t = Span.t [@@deriving hash, equal, sexp_grammar]
         type nonrec comparator_witness = Span.comparator_witness
 
         include
           Stable_int63able.With_stable_witness.S
-            with type t := t
-            with type comparator_witness := comparator_witness
+          with type t := t
+          with type comparator_witness := comparator_witness
 
         include
           Comparable.Stable.V1.With_stable_witness.S
-            with type comparable := t
-            with type comparator_witness := comparator_witness
+          with type comparable := t
+          with type comparator_witness := comparator_witness
 
         include Stringable.S with type t := t
         include Diffable.S_atomic with type t := t
       end
+
+      module Option : sig
+        module V1 : sig
+          include Stable_int63able_with_witness with type t = Span.Option.t
+          include Diffable.S_atomic with type t := t
+        end
+
+        module V2 : sig
+          include Stable_int63able_with_witness with type t = Span.Option.t
+          include Diffable.S_atomic with type t := t
+        end
+      end
     end
 
     module Ofday : sig
@@ -612,85 +759,40 @@ module type Time_ns = sig
 
         include
           Stable_int63able.With_stable_witness.S
-            with type t := t
-             and type comparator_witness = Ofday.comparator_witness
+          with type t := t
+           and type comparator_witness = Ofday.comparator_witness
 
         include Diffable.S_atomic with type t := t
       end
 
-      module Option : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-      module Zoned : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-    end
-  end
-
-  module Hash_queue : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-  module Hash_set : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-  module Map : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  module Replace_polymorphic_compare : sig end
-  [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+      module Zoned : sig
+        module V1 : sig
+          type nonrec t = Ofday.Zoned.t [@@deriving hash]
 
-  module Set : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-  module Table : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-  module Zone : sig end [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+          include Stable_without_comparator_with_witness with type t := t
+        end
+      end
 
-  val arg_type : [ `Use_Time_ns_unix ] [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+      module Option : sig
+        module V1 : sig
+          include Stable_int63able_with_witness with type t = Ofday.Option.t
+          include Diffable.S_atomic with type t := t
+        end
+      end
+    end
 
-  val comparator : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+    module Zone : module type of struct
+      include Timezone.Stable
+    end
+  end
 
-  val get_sexp_zone : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+  val arg_type : t Command.Arg_type.t
 
   val interruptible_pause : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val of_date_ofday_zoned : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val of_string_abs : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val of_string_fix_proto : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+  [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
 
   val pause : [ `Use_Time_ns_unix ] [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
 
   val pause_forever : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val pp : [ `Use_Time_ns_unix ] [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val set_sexp_zone : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val sexp_of_t : [ `Use_Time_ns_unix_or_Time_ns_alternate_sexp ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix] or [Time_ns.Alternate_sexp]"]
-
-  val sexp_of_t_abs : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val t_of_sexp : [ `Use_Time_ns_unix_or_Time_ns_alternate_sexp ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix] or [Time_ns.Alternate_sexp]"]
-
-  val t_of_sexp_abs : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val to_date_ofday_zoned : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val to_ofday_zoned : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val to_string_fix_proto : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val validate_bound : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val validate_lbound : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
-
-  val validate_ubound : [ `Use_Time_ns_unix ]
-    [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
+  [@@deprecated "[since 2021-03] Use [Time_ns_unix]"]
 end
Index: core-0.17.1/core/src/time_ns_stubs.c
===================================================================
--- core-0.17.1.orig/core/src/time_ns_stubs.c
+++ core-0.17.1/core/src/time_ns_stubs.c
@@ -28,8 +28,7 @@ CAMLprim value core_time_ns_format_tm(st
     return v_str;
   }
 
-  v_str =
-      caml_copy_string(buf); /* [strftime] always null terminates the string */
+  v_str = caml_copy_string(buf); /* [strftime] always null terminates the string */
   free(buf);
   return v_str;
 }
Index: core-0.17.1/core/src/timezone.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/timezone.ml
@@ -0,0 +1,285 @@
+open! Import
+open! Std_internal
+include Timezone_intf
+include Zone
+
+module type Extend_zone = Timezone_intf.Extend_zone
+
+module Zone_cache = struct
+  type z =
+    { mutable full : bool
+    ; basedir : string
+    ; table : t String.Table.t
+    }
+
+  let the_one_and_only =
+    { full = false
+    ; basedir = Option.value (Sys.getenv "TZDIR") ~default:"/usr/share/zoneinfo/"
+    ; table = String.Table.create ()
+    }
+  ;;
+
+  let find zone = Hashtbl.find the_one_and_only.table zone
+
+  let find_or_load zonename =
+    match find zonename with
+    | Some z -> Some z
+    | None ->
+      if the_one_and_only.full
+      then None
+      else (
+        try
+          let filename = the_one_and_only.basedir ^ "/" ^ zonename in
+          let zone = input_tz_file ~zonename ~filename in
+          Hashtbl.set the_one_and_only.table ~key:zonename ~data:zone;
+          Some zone
+        with
+        | _ -> None)
+  ;;
+
+  let traverse basedir ~f =
+    let skip_prefixes = [ "Etc/GMT"; "right/"; "posix/" ] in
+    let maxdepth = 10 in
+    let basedir_len = String.length basedir + 1 in
+    let rec dfs dir depth =
+      if depth < 1
+      then ()
+      else
+        Array.iter (Stdlib.Sys.readdir dir) ~f:(fun fn ->
+          let fn = dir ^ "/" ^ fn in
+          let relative_fn = String.drop_prefix fn basedir_len in
+          match Stdlib.Sys.is_directory fn with
+          | true ->
+            if not
+                 (List.exists skip_prefixes ~f:(fun prefix ->
+                    String.is_prefix ~prefix relative_fn))
+            then dfs fn (depth - 1)
+          | false -> f relative_fn)
+    in
+    dfs basedir maxdepth
+  ;;
+
+  let init_from_file_system () =
+    if not the_one_and_only.full
+    then (
+      traverse the_one_and_only.basedir ~f:(fun zone_name ->
+        ignore (find_or_load zone_name : t option));
+      the_one_and_only.full <- true)
+  ;;
+
+  let init =
+    (* On web we are relying on Timezone_js_loader and don't have access to zoneinfo files.
+       This is especially problematic because in test environments on node we do have
+       access to the files so the test/app behavior would be different if we allowed this.
+
+       wasm_of_ocaml doesn't support file access at all (2024-05), and so the
+       initialization always fails. *)
+    match
+      Timezone_js_loader.For_advanced_timezone_feature_detection
+      .should_use_timezone_js_loader
+        ()
+    with
+    | `Yes -> ignore
+    | `Platform_not_supported | `Disabled -> init_from_file_system
+  ;;
+
+  let to_alist () = Hashtbl.to_alist the_one_and_only.table
+
+  let initialized_zones () =
+    List.sort ~compare:(fun a b -> String.ascending (fst a) (fst b)) (to_alist ())
+  ;;
+
+  let find_or_load_matching t1 =
+    let file_size filename =
+      let c = Stdio.In_channel.create filename in
+      let l = Stdio.In_channel.length c in
+      Stdio.In_channel.close c;
+      l
+    in
+    let t1_file_size = Option.map (original_filename t1) ~f:file_size in
+    with_return (fun r ->
+      let return_if_matches zone_name =
+        let filename = String.concat ~sep:"/" [ the_one_and_only.basedir; zone_name ] in
+        let matches =
+          try
+            [%compare.equal: int64 option] t1_file_size (Some (file_size filename))
+            && [%compare.equal: Md5.t option]
+                 (digest t1)
+                 Option.(join (map (find_or_load zone_name) ~f:digest))
+          with
+          | _ -> false
+        in
+        if matches then r.return (find_or_load zone_name) else ()
+      in
+      List.iter !likely_machine_zones ~f:return_if_matches;
+      traverse the_one_and_only.basedir ~f:return_if_matches;
+      None)
+  ;;
+end
+
+let init = Zone_cache.init
+let initialized_zones = Zone_cache.initialized_zones
+
+let find zone =
+  let zone =
+    (* Some aliases for convenience *)
+    match zone with
+    (* case insensitivity *)
+    | "utc" -> "UTC"
+    | "gmt" -> "GMT"
+    (* some aliases for common zones *)
+    | "chi" -> "America/Chicago"
+    | "nyc" -> "America/New_York"
+    | "hkg" -> "Asia/Hong_Kong"
+    | "lon" | "ldn" -> "Europe/London"
+    | "tyo" -> "Asia/Tokyo"
+    | "syd" -> "Australia/Sydney"
+    (* catchall *)
+    | _ -> zone
+  in
+  Zone_cache.find_or_load zone
+;;
+
+let find_exn zone =
+  match find zone with
+  | None -> Error.raise_s [%message "unknown zone" (zone : string)]
+  | Some z -> z
+;;
+
+let local =
+  (* Load [TZ] immediately so that subsequent modifications to the environment cannot
+     alter the result of [force local]. *)
+  let local_zone_name = Sys.getenv "TZ" in
+  let load () =
+    match local_zone_name with
+    | Some zone_name -> find_exn zone_name
+    | None ->
+      let localtime_t =
+        input_tz_file ~zonename:"/etc/localtime" ~filename:"/etc/localtime"
+      in
+      (* Load the matching zone file from the real zone cache so that we can serialize it
+         properly. The file loaded from /etc/localtime won't have a name we can use on the
+         other side to find the right zone. *)
+      (match Zone_cache.find_or_load_matching localtime_t with
+       | Some t -> t
+       | None -> localtime_t)
+  in
+  Lazy.from_fun load
+;;
+
+module Stable = struct
+  include Zone.Stable
+
+  module V1 = struct
+    type nonrec t = t
+
+    let of_string name =
+      match name with
+      | "Local" -> Lazy.force local
+      | name ->
+        if String.equal name "UTC" || String.equal name "GMT"
+        then of_utc_offset_explicit_name ~name ~hours:0
+        else if (* This special handling is needed because the offset directionality of
+                   the zone files in /usr/share/zoneinfo for GMT<offset> files is the
+                   reverse of what is generally expected. That is, GMT+5 is what most
+                   people would call GMT-5. *)
+                String.is_prefix name ~prefix:"GMT-"
+                || String.is_prefix name ~prefix:"GMT+"
+                || String.is_prefix name ~prefix:"UTC-"
+                || String.is_prefix name ~prefix:"UTC+"
+        then (
+          let offset =
+            let base =
+              Int.of_string (String.sub name ~pos:4 ~len:(String.length name - 4))
+            in
+            match name.[3] with
+            | '-' -> -1 * base
+            | '+' -> base
+            | _ -> assert false
+          in
+          of_utc_offset_explicit_name ~name ~hours:offset)
+        else find_exn name
+    ;;
+
+    let t_of_sexp sexp =
+      match sexp with
+      | Sexp.Atom name ->
+        (try of_string name with
+         | exc ->
+           of_sexp_error (sprintf "Timezone.t_of_sexp: %s" (Exn.to_string exc)) sexp)
+      | _ -> of_sexp_error "Timezone.t_of_sexp: expected atom" sexp
+    ;;
+
+    let to_string t =
+      let name = name t in
+      if String.equal name "/etc/localtime"
+      then failwith "the local time zone cannot be serialized";
+      name
+    ;;
+
+    let sexp_of_t t = Sexp.Atom (to_string t)
+
+    let t_sexp_grammar : t Sexplib.Sexp_grammar.t =
+      { untyped =
+          Tagged
+            { key = Sexplib.Sexp_grammar.type_name_tag
+            ; value = Atom "Timezone.t"
+            ; grammar = String
+            }
+      }
+    ;;
+
+    (* The correctness of these relies on not exposing raw loading/creation functions to
+       the outside world that would allow the construction of two Zone's with the same
+       name and different transitions. *)
+    let compare t1 t2 = String.compare (to_string t1) (to_string t2)
+    let equal t1 t2 = String.equal (to_string t1) (to_string t2)
+    let hash_fold_t state t = String.hash_fold_t state (to_string t)
+    let hash = Ppx_hash_lib.Std.Hash.of_fold hash_fold_t
+
+    let to_binable t =
+      let name = name t in
+      if String.equal name "/etc/localtime"
+      then failwith "the local time zone cannot be serialized";
+      name
+    ;;
+
+    let of_binable s = t_of_sexp (Sexp.Atom s)
+
+    include (
+      Binable.Stable.Of_binable.V1 [@alert "-legacy"]
+        (String)
+        (struct
+          type nonrec t = t
+
+          let to_binable = to_binable
+          let of_binable = of_binable
+        end) :
+          Binable.S with type t := t)
+
+    let stable_witness =
+      Stable_witness.of_serializable String.Stable.V1.stable_witness of_binable to_binable
+    ;;
+
+    include Diffable.Atomic.Make (struct
+        type nonrec t = t [@@deriving sexp, bin_io, equal]
+      end)
+  end
+
+  module Current = V1
+end
+
+include Identifiable.Make (struct
+    let module_name = "Core.Timezone"
+
+    include Stable.Current
+
+    let of_string = of_string
+    let to_string = to_string
+  end)
+
+include Stable.Current
+
+module Private = struct
+  module Zone_cache = Zone_cache
+end
Index: core-0.17.1/core/src/timezone.mli
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/timezone.mli
@@ -0,0 +1 @@
+include Timezone_intf.Timezone (** @inline *)
Index: core-0.17.1/core/src/timezone_intf.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/timezone_intf.ml
@@ -0,0 +1,120 @@
+open! Import
+open! Std_internal
+open! Int.Replace_polymorphic_compare
+
+module type Extend_zone = sig
+  type t [@@deriving sexp_grammar]
+
+  include Identifiable.S with type t := t
+  include Diffable.S_atomic with type t := t
+
+  (** [find name] looks up a [t] by its name and returns it.  This also accepts some
+      aliases, including:
+
+      - chi -> America/Chicago
+      - nyc -> America/New_York
+      - hkg -> Asia/Hong_Kong
+      - ldn -> Europe/London
+      - lon -> Europe/London
+      - tyo -> Asia/Tokyo
+      - syd -> Australia/Sydney
+  *)
+  val find : string -> t option
+
+  val find_exn : string -> t
+
+  (** [local] is the machine's local timezone, as determined from the [TZ]
+      environment variable or the [/etc/localtime] file.  It is computed from
+      the state of the process environment and on-disk tzdata database at
+      some unspecified moment prior to its first use, so its value may be
+      unpredictable if that state changes during program operation. Arguably,
+      changing the timezone of a running program is a problematic operation
+      anyway -- most people write code assuming the clock doesn't suddenly
+      jump several hours without warning.
+
+      Note that any function using this timezone can throw an exception if
+      the [TZ] environment variable is misconfigured or if the appropriate
+      timezone files can't be found because of the way the box is configured.
+      We don't sprinkle [_exn] all over all the names in this module because
+      such misconfiguration is quite rare. *)
+  val local : t Lazy.t
+
+  (** [initialized_zones ()] returns a sorted list of time zone names that have
+      been loaded from disk thus far. *)
+  val initialized_zones : unit -> (string * t) list
+
+  (** {3 Low-level functions}
+
+      The functions below are lower level and should be used more rarely. *)
+
+  (** [init ()] pre-load all available time zones from disk, this function has no effect if
+      it is called multiple times.  Time zones will otherwise be loaded at need from the
+      disk on the first call to find/find_exn. *)
+  val init : unit -> unit
+end
+
+module type Timezone = sig
+  (** Timezone handles parsing timezone data and create [Timezone.t] that can later be
+      used to manipulate time using the [Time_float] and [Time_ns] modules.
+
+      Timezone is currently only able to read the Timezone Database
+      provided by {{:https://www.iana.org/time-zones}IANA}. It should work
+      out of the box on Linux and macOS.
+
+      {2 Where are the timezone data located ?}
+
+      The location of the timezone files can be set using the environment
+      variable [TZDIR]. If not set, [Timezone] will fallback to
+      [/usr/share/zoneinfo/].
+
+      {2 What is the local timezone ?}
+
+      The local timezone can be set using the environment variable [TZ]. If
+      not set, [Timezone] will fallback to [/etc/localtime].
+      In a JavaScript context, we automatically set the environment variable
+      [TZ] to [Intl.DateTimeFormat().resolvedOptions().timeZone].
+
+      {2 Compatibility with JavaScript.}
+
+      The [Timezone] library can be used when constructing JavaScript applications with
+      {{:https://github.com/ocsigen/js_of_ocaml/}Js_of_ocaml}.
+
+      In the past, web browsers needed to be provided with a copy of the timezone database, but
+      this is no longer required. *)
+
+  module type Extend_zone = Extend_zone
+
+  include Zone.S with type t = Zone.t and type Index.t = Zone.Index.t
+  include Extend_zone with type t := t
+
+  module Stable : sig
+    module V1 : sig
+      type nonrec t = t
+      [@@deriving bin_io, compare, equal, hash, sexp, sexp_grammar, stable_witness]
+
+      include Stringable.S with type t := t
+      include Diffable.S with type t := t and type Diff.t = Diff.t
+    end
+
+    include Zone.S_stable with type t := t
+  end
+
+  (**/**)
+
+  (*_ See the Jane Street Style Guide for an explanation of [Private] submodules:
+
+    https://opensource.janestreet.com/standards/#private-submodules *)
+  module Private : sig
+    module Zone_cache : sig
+      type z =
+        { mutable full : bool
+        ; basedir : string
+        ; table : Zone.t String.Table.t
+        }
+
+      val the_one_and_only : z
+      val init : unit -> unit
+      val find : string -> t option
+    end
+  end
+end
Index: core-0.17.1/core/src/timezone_js_loader.ml
===================================================================
--- core-0.17.1.orig/core/src/timezone_js_loader.ml
+++ core-0.17.1/core/src/timezone_js_loader.ml
@@ -1,12 +1,20 @@
 open! Base
 open Timezone_types
 
-external should_use_timezone_js_loader
-  :  [ `Yes ]
-  -> [ `Platform_not_supported ]
-  -> [ `Disabled ]
-  -> [ `Yes | `Platform_not_supported | `Disabled ]
-  = "should_use_timezone_js_loader"
+module For_advanced_timezone_feature_detection = struct
+  external should_use_timezone_js_loader
+    :  [ `Yes ]
+    -> [ `Platform_not_supported ]
+    -> [ `Disabled ]
+    -> [ `Yes | `Platform_not_supported | `Disabled ]
+    = "should_use_timezone_js_loader"
+
+  let should_use_timezone_js_loader () =
+    should_use_timezone_js_loader `Yes `Platform_not_supported `Disabled
+  ;;
+end
+
+open For_advanced_timezone_feature_detection
 
 module Instant = struct
   type t
@@ -118,7 +126,7 @@ module Load_error = struct
 end
 
 let load s =
-  match should_use_timezone_js_loader `Yes `Platform_not_supported `Disabled with
+  match should_use_timezone_js_loader () with
   | `Disabled -> Error Load_error.Disabled
   | `Platform_not_supported -> Error Load_error.Platform_not_supported
   | `Yes ->
Index: core-0.17.1/core/src/timezone_js_loader.mli
===================================================================
--- core-0.17.1.orig/core/src/timezone_js_loader.mli
+++ core-0.17.1/core/src/timezone_js_loader.mli
@@ -19,3 +19,9 @@ module For_testing : sig
   val disable : unit -> unit
   val enable : unit -> unit
 end
+
+module For_advanced_timezone_feature_detection : sig
+  val should_use_timezone_js_loader
+    :  unit
+    -> [ `Yes | `Platform_not_supported | `Disabled ]
+end
Index: core-0.17.1/core/src/timezone_js_loader_stubs.c
===================================================================
--- core-0.17.1.orig/core/src/timezone_js_loader_stubs.c
+++ core-0.17.1/core/src/timezone_js_loader_stubs.c
@@ -7,8 +7,7 @@
  * [should_use_timezone_js_loader] function, which returns
  * [platform_not_supported]; all the rest raise. */
 
-CAMLprim value should_use_timezone_js_loader(value yes,
-                                             value platform_not_supported,
+CAMLprim value should_use_timezone_js_loader(value yes, value platform_not_supported,
                                              value disabled) {
   CAMLparam3(yes, platform_not_supported, disabled);
   CAMLreturn(platform_not_supported);
@@ -21,8 +20,8 @@ CAMLprim value timezone_js_loader_create
   CAMLreturn(Val_unit);
 }
 
-CAMLprim value timezone_js_loader_get_next_transition_or_this_time_if_none(
-    value zone, value instant) {
+CAMLprim value
+timezone_js_loader_get_next_transition_or_this_time_if_none(value zone, value instant) {
   CAMLparam2(zone, instant);
   caml_failwith("timezone_js_loader: "
                 "timezone_js_loader_get_next_transition_or_this_time_if_none "
@@ -32,17 +31,15 @@ CAMLprim value timezone_js_loader_get_ne
 
 CAMLprim value timezone_js_loader_from_epoch_seconds(value seconds) {
   CAMLparam1(seconds);
-  caml_failwith(
-      "timezone_js_loader: timezone_js_loader_from_epoch_seconds is not "
-      "implemented for the native target");
+  caml_failwith("timezone_js_loader: timezone_js_loader_from_epoch_seconds is not "
+                "implemented for the native target");
   CAMLreturn(Val_unit);
 }
 
 CAMLprim value timezone_js_loader_compare_instants(value a, value b) {
   CAMLparam2(a, b);
-  caml_failwith(
-      "timezone_js_loader: timezone_js_loader_compare_instants is not "
-      "implemented for the native target");
+  caml_failwith("timezone_js_loader: timezone_js_loader_compare_instants is not "
+                "implemented for the native target");
   CAMLreturn(Val_unit);
 }
 
@@ -60,21 +57,17 @@ CAMLprim value timezone_js_loader_now(va
   CAMLreturn(Val_unit);
 }
 
-CAMLprim value timezone_js_loader_instant_plus_hours(value instant,
-                                                     value hours) {
+CAMLprim value timezone_js_loader_instant_plus_hours(value instant, value hours) {
   CAMLparam2(instant, hours);
-  caml_failwith(
-      "timezone_js_loader: timezone_js_loader_instant_plus_hours is not "
-      "implemented for the native target");
+  caml_failwith("timezone_js_loader: timezone_js_loader_instant_plus_hours is not "
+                "implemented for the native target");
   CAMLreturn(Val_unit);
 }
 
-CAMLprim value timezone_js_loader_get_offset_nanos_for(value zone,
-                                                       value instant) {
+CAMLprim value timezone_js_loader_get_offset_nanos_for(value zone, value instant) {
   CAMLparam2(zone, instant);
-  caml_failwith(
-      "timezone_js_loader: timezone_js_loader_get_offset_nanos_for is not "
-      "implemented for the native target");
+  caml_failwith("timezone_js_loader: timezone_js_loader_get_offset_nanos_for is not "
+                "implemented for the native target");
   CAMLreturn(Val_unit);
 }
 
Index: core-0.17.1/core/src/timezone_js_loader_stubs.wasm.js
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/timezone_js_loader_stubs.wasm.js
@@ -0,0 +1,46 @@
+//Provides: timezone_js_for_wasm_loader_create_zone
+function timezone_js_for_wasm_loader_create_zone(zone_name) {
+    return new globalThis.TemporalPolyfill.Temporal.TimeZone(zone_name);
+}
+
+//Provides: timezone_js_for_wasm_loader_get_next_transition_or_this_time_if_none
+function timezone_js_for_wasm_loader_get_next_transition_or_this_time_if_none(zone, instant) {
+    var ret = zone.getNextTransition(instant);
+    if (ret) {
+        return ret;
+    } else {
+        return instant;
+    }
+}
+
+//Provides: timezone_js_for_wasm_loader_from_epoch_seconds
+function timezone_js_for_wasm_loader_from_epoch_seconds(seconds) {
+    return globalThis.TemporalPolyfill.Temporal.Instant.fromEpochSeconds(seconds);
+}
+
+//Provides: timezone_js_for_wasm_loader_compare_instants
+function timezone_js_for_wasm_loader_compare_instants(a, b) {
+    return globalThis.TemporalPolyfill.Temporal.Instant.compare(a, b);
+}
+
+//Provides: timezone_js_for_wasm_loader_epoch_seconds
+function timezone_js_for_wasm_loader_epoch_seconds(instant) {
+    return instant.epochSeconds;
+}
+
+//Provides: timezone_js_for_wasm_loader_now
+function timezone_js_for_wasm_loader_now() {
+    return globalThis.TemporalPolyfill.Temporal.Now.instant();
+}
+
+//Provides: timezone_js_for_wasm_loader_instant_plus_hours
+//Requires: caml_int64_to_float
+function timezone_js_for_wasm_loader_instant_plus_hours(instant, hours) {
+    var duration = globalThis.TemporalPolyfill.Temporal.Duration.from({ hours: hours });
+    return instant.add(duration);
+}
+
+//Provides: timezone_js_for_wasm_loader_get_offset_nanos_for
+function timezone_js_for_wasm_loader_get_offset_nanos_for(zone, instant) {
+    return zone.getOffsetNanosecondsFor(instant);
+}
Index: core-0.17.1/core/src/timezone_js_loader_stubs.wat
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/timezone_js_loader_stubs.wat
@@ -0,0 +1,106 @@
+(module
+   (import "env" "wrap" (func $wrap (param anyref) (result (ref eq))))
+   (import "env" "unwrap" (func $unwrap (param (ref eq)) (result anyref)))
+   (import "env" "caml_string_of_jsstring"
+      (func $caml_string_of_jsstring (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_jsstring_of_string"
+      (func $caml_jsstring_of_string (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_callback_1"
+      (func $caml_callback_1 (param (ref eq) (ref eq)) (result (ref eq))))
+   (import "env" "caml_copy_int64"
+      (func $caml_copy_int64 (param i64) (result (ref eq))))
+   (import "env" "Int64_val"
+      (func $Int64_val (param (ref eq)) (result i64)))
+
+   (import "js" "timezone_js_for_wasm_loader_create_zone"
+      (func $timezone_js_for_wasm_loader_create_zone
+         (param anyref) (result anyref)))
+   (import "js" "timezone_js_for_wasm_loader_get_next_transition_or_this_time_if_none"
+      (func $timezone_js_for_wasm_loader_get_next_transition_or_this_time_if_none
+         (param anyref anyref) (result anyref)))
+   (import "js" "timezone_js_for_wasm_loader_from_epoch_seconds"
+      (func $timezone_js_for_wasm_loader_from_epoch_seconds
+         (param f64) (result anyref)))
+   (import "js" "timezone_js_for_wasm_loader_compare_instants"
+      (func $timezone_js_for_wasm_loader_compare_instants
+         (param anyref anyref) (result (ref eq))))
+   (import "js" "timezone_js_for_wasm_loader_epoch_seconds"
+      (func $timezone_js_for_wasm_loader_epoch_seconds
+         (param anyref) (result f64)))
+   (import "js" "timezone_js_for_wasm_loader_now"
+      (func $timezone_js_for_wasm_loader_now (result anyref)))
+   (import "js" "timezone_js_for_wasm_loader_instant_plus_hours"
+      (func $timezone_js_for_wasm_loader_instant_plus_hours
+         (param anyref f64) (result anyref)))
+   (import "js" "timezone_js_for_wasm_loader_get_offset_nanos_for"
+      (func $timezone_js_for_wasm_loader_get_offset_nanos_for
+         (param anyref anyref) (result f64)))
+
+   (func (export "should_use_timezone_js_loader")
+      (param $yes (ref eq))
+      (param $platform_not_supported (ref eq))
+      (param $disabled (ref eq))
+      (result (ref eq))
+      ;; wasm only supports timezone use through the js loader. File system support isn't
+      ;; implemented yet (2024-03) so a fallback to a mock file system would fail.
+      (local.get $yes))
+
+   (func (export "timezone_js_loader_disable_for_testing")
+      (param $unit (ref eq)) (result (ref eq))
+      (local.get $unit))
+
+   (func (export "timezone_js_loader_enable_for_testing")
+      (param $unit (ref eq)) (result (ref eq))
+      (local.get $unit))
+
+   (func (export "timezone_js_loader_create_zone")
+      (param $zone_name (ref eq)) (result (ref eq))
+      (return_call $wrap
+         (call $timezone_js_for_wasm_loader_create_zone
+            (call $unwrap
+               (call $caml_jsstring_of_string (local.get $zone_name))))))
+
+   (func (export "timezone_js_loader_get_next_transition_or_this_time_if_none")
+      (param $zone (ref eq)) (param $instant (ref eq)) (result (ref eq))
+      (return_call $wrap
+         (call $timezone_js_for_wasm_loader_get_next_transition_or_this_time_if_none
+            (call $unwrap (local.get $zone))
+            (call $unwrap (local.get $instant)))))
+
+   (func (export "timezone_js_loader_from_epoch_seconds")
+      (param $seconds (ref eq)) (result (ref eq))
+      (call $wrap
+         (call $timezone_js_for_wasm_loader_from_epoch_seconds
+            (f64.convert_i64_s (call $Int64_val (local.get $seconds))))))
+
+   (func (export "timezone_js_loader_compare_instants")
+      (param $a (ref eq)) (param $b (ref eq)) (result (ref eq))
+      (call $timezone_js_for_wasm_loader_compare_instants
+         (call $unwrap (local.get $a)) (call $unwrap (local.get $b))))
+
+   (func (export "timezone_js_loader_epoch_seconds")
+      (param $instant (ref eq)) (result (ref eq))
+      (call $caml_copy_int64
+         (i64.trunc_sat_f64_s
+            (call $timezone_js_for_wasm_loader_epoch_seconds
+               (call $unwrap (local.get $instant))))))
+
+   (func (export "timezone_js_loader_now")
+      (param (ref eq)) (result (ref eq))
+      (call $wrap (call $timezone_js_for_wasm_loader_now)))
+
+   (func (export "timezone_js_loader_instant_plus_hours")
+      (param $instant (ref eq)) (param $hours (ref eq)) (result (ref eq))
+      (call $wrap
+         (call $timezone_js_for_wasm_loader_instant_plus_hours
+            (call $unwrap (local.get $instant))
+            (f64.convert_i64_s (call $Int64_val (local.get $hours))))))
+
+   (func (export "timezone_js_loader_get_offset_nanos_for")
+      (param $zone (ref eq)) (param $instant (ref eq)) (result (ref eq))
+      (call $caml_copy_int64
+         (i64.trunc_sat_f64_s
+            (call $timezone_js_for_wasm_loader_get_offset_nanos_for
+               (call $unwrap (local.get $zone))
+               (call $unwrap (local.get $instant))))))
+)
Index: core-0.17.1/core/src/timezone_runtime.js
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/timezone_runtime.js
@@ -0,0 +1,15 @@
+var dateTimeFormat =
+    Intl
+    && Intl.DateTimeFormat
+    && Intl.DateTimeFormat();
+var resolvedOptions =
+    dateTimeFormat
+    && dateTimeFormat.resolvedOptions
+    && dateTimeFormat.resolvedOptions();
+var tz = resolvedOptions && resolvedOptions.timeZone
+// If a timezone is available, set the TZ env variable.
+if(tz){
+  if(!joo_global_object.jsoo_static_env)
+    joo_global_object.jsoo_static_env = {};
+  joo_global_object.jsoo_static_env.TZ = tz;
+}
Index: core-0.17.1/core/src/tuple.ml
===================================================================
--- core-0.17.1.orig/core/src/tuple.ml
+++ core-0.17.1/core/src/tuple.ml
@@ -1,4 +1,5 @@
 open! Import
+include Tuple_intf.Definitions
 
 module type T = sig
   type t
@@ -9,7 +10,7 @@ module Make (T1 : T) (T2 : T) = struct
 end
 
 module T2 = struct
-  type ('a, 'b) t = 'a * 'b [@@deriving sexp, typerep]
+  type ('a, 'b) t = 'a * 'b [@@deriving sexp, sexp_grammar, typerep]
 
   let create a b = a, b
 
@@ -51,14 +52,14 @@ module T2 = struct
   let swap (a, b) = b, a
 
   include Comparator.Derived2 (struct
-    type nonrec ('a, 'b) t = ('a, 'b) t [@@deriving sexp_of]
+      type nonrec ('a, 'b) t = ('a, 'b) t [@@deriving sexp_of]
 
-    let compare cmp1 cmp2 = compare ~cmp1 ~cmp2
-  end)
+      let compare cmp1 cmp2 = compare ~cmp1 ~cmp2
+    end)
 end
 
 module T3 = struct
-  type ('a, 'b, 'c) t = 'a * 'b * 'c [@@deriving sexp, typerep]
+  type ('a, 'b, 'c) t = 'a * 'b * 'c [@@deriving sexp, sexp_grammar, typerep]
 
   let create a b c = a, b, c
 
@@ -107,22 +108,6 @@ module T3 = struct
   let equal ~eq1 ~eq2 ~eq3 (x, y, z) (x', y', z') = eq1 x x' && eq2 y y' && eq3 z z'
 end
 
-module type Comparable_sexpable = sig
-  type t [@@deriving sexp]
-
-  include Comparable.S with type t := t
-end
-
-module type Hashable_sexpable = sig
-  type t [@@deriving sexp]
-
-  include Hashable.S with type t := t
-end
-
-module type Hasher_sexpable = sig
-  type t [@@deriving compare, hash, sexp]
-end
-
 module Sexpable (S1 : Sexpable.S) (S2 : Sexpable.S) = struct
   type t = S1.t * S2.t [@@deriving sexp]
 end
@@ -140,7 +125,7 @@ module Comparator (S1 : Comparator.S) (S
   let comparator = T2.comparator S1.comparator S2.comparator
 end
 
-module Comparable_plain (S1 : Comparable.S_plain) (S2 : Comparable.S_plain) = struct
+module Comparable_plain (S1 : Comparable_plain_arg) (S2 : Comparable_plain_arg) = struct
   module T = struct
     include Comparator (S1) (S2)
 
@@ -151,7 +136,7 @@ module Comparable_plain (S1 : Comparable
   include Comparable.Make_plain_using_comparator (T)
 end
 
-module Comparable (S1 : Comparable_sexpable) (S2 : Comparable_sexpable) = struct
+module Comparable (S1 : Comparable_arg) (S2 : Comparable_arg) = struct
   module T = struct
     include Sexpable (S1) (S2)
 
@@ -166,7 +151,16 @@ module Comparable (S1 : Comparable_sexpa
   include Comparable.Make (T)
 end
 
-module Hasher (H1 : Hasher_sexpable) (H2 : Hasher_sexpable) = struct
+module Hashable_plain (S1 : Hashable_plain_arg) (S2 : Hashable_plain_arg) = struct
+  module T = struct
+    type t = S1.t * S2.t [@@deriving compare, hash, sexp_of]
+  end
+
+  include T
+  include Hashable.Make_plain (T)
+end
+
+module Hasher (H1 : Hashable_arg) (H2 : Hashable_arg) = struct
   module T = struct
     type t = H1.t * H2.t [@@deriving compare, hash, sexp]
   end
@@ -175,14 +169,14 @@ module Hasher (H1 : Hasher_sexpable) (H2
   include Hashable.Make (T)
 end
 
-module Hasher_sexpable_of_hashable_sexpable (S : Hashable_sexpable) :
-  Hasher_sexpable with type t = S.t = struct
+module Hasher_sexpable_of_hashable_sexpable (S : Hashable_arg) :
+  Hashable_arg with type t = S.t = struct
   include S
 
   let hash_fold_t state t = hash_fold_int state (hash t)
 end
 
-module Hashable_t (S1 : Hashable_sexpable) (S2 : Hashable_sexpable) =
+module Hashable_t (S1 : Hashable_arg) (S2 : Hashable_arg) =
   Hasher
     (Hasher_sexpable_of_hashable_sexpable
        (S1))
Index: core-0.17.1/core/src/tuple.mli
===================================================================
--- core-0.17.1.orig/core/src/tuple.mli
+++ core-0.17.1/core/src/tuple.mli
@@ -1,192 +1 @@
-(** Functors and signatures for dealing with modules for tuples.  *)
-
-open! Import
-
-(** Signature for a 2-tuple module *)
-module T2 : sig
-  type ('a, 'b) t = 'a * 'b [@@deriving sexp, typerep]
-
-  include Comparator.Derived2 with type ('a, 'b) t := ('a, 'b) t
-
-  val create : 'a -> 'b -> ('a, 'b) t
-  val curry : (('a, 'b) t -> 'c) -> 'a -> 'b -> 'c
-  val uncurry : ('a -> 'b -> 'c) -> ('a, 'b) t -> 'c
-
-  val compare
-    :  cmp1:('a -> 'a -> int)
-    -> cmp2:('b -> 'b -> int)
-    -> ('a, 'b) t
-    -> ('a, 'b) t
-    -> int
-
-  val equal
-    :  eq1:('a -> 'a -> bool)
-    -> eq2:('b -> 'b -> bool)
-    -> ('a, 'b) t
-    -> ('a, 'b) t
-    -> bool
-
-  [%%if flambda_backend]
-
-  external get1 : (('a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0_immut"
-  external get2 : ((_, 'a) t[@local_opt]) -> ('a[@local_opt]) = "%field1_immut"
-
-  [%%else]
-
-  external get1 : (('a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0"
-  external get2 : ((_, 'a) t[@local_opt]) -> ('a[@local_opt]) = "%field1"
-
-  [%%endif]
-
-  val map : ('a, 'a) t -> f:('a -> 'b) -> ('b, 'b) t
-  val map_fst : ('a, 'b) t -> f:('a -> 'c) -> ('c, 'b) t
-  val map_snd : ('a, 'b) t -> f:('b -> 'c) -> ('a, 'c) t
-  val map_both : ('a, 'b) t -> f1:('a -> 'c) -> f2:('b -> 'd) -> ('c, 'd) t
-  val map2 : ('a, 'a) t -> ('b, 'b) t -> f:('a -> 'b -> 'c) -> ('c, 'c) t
-  val swap : ('a, 'b) t -> ('b, 'a) t
-end
-
-(** Signature for a 3-tuple module *)
-module T3 : sig
-  type ('a, 'b, 'c) t = 'a * 'b * 'c [@@deriving sexp, typerep]
-
-  val create : 'a -> 'b -> 'c -> ('a, 'b, 'c) t
-  val curry : (('a, 'b, 'c) t -> 'd) -> 'a -> 'b -> 'c -> 'd
-  val uncurry : ('a -> 'b -> 'c -> 'd) -> ('a, 'b, 'c) t -> 'd
-
-  val equal
-    :  eq1:('a -> 'a -> bool)
-    -> eq2:('b -> 'b -> bool)
-    -> eq3:('c -> 'c -> bool)
-    -> ('a, 'b, 'c) t
-    -> ('a, 'b, 'c) t
-    -> bool
-
-  val compare
-    :  cmp1:('a -> 'a -> int)
-    -> cmp2:('b -> 'b -> int)
-    -> cmp3:('c -> 'c -> int)
-    -> ('a, 'b, 'c) t
-    -> ('a, 'b, 'c) t
-    -> int
-
-  [%%if flambda_backend]
-
-  external get1 : (('a, _, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0_immut"
-  external get2 : ((_, 'a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field1_immut"
-
-  [%%else]
-
-  external get1 : (('a, _, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0"
-  external get2 : ((_, 'a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field1"
-
-  [%%endif]
-
-  val get3 : (_, _, 'a) t -> 'a
-  val map : ('a, 'a, 'a) t -> f:('a -> 'b) -> ('b, 'b, 'b) t
-  val map_fst : ('a, 'b, 'c) t -> f:('a -> 'd) -> ('d, 'b, 'c) t
-  val map_snd : ('a, 'b, 'c) t -> f:('b -> 'd) -> ('a, 'd, 'c) t
-  val map_trd : ('a, 'b, 'c) t -> f:('c -> 'd) -> ('a, 'b, 'd) t
-
-  val map_all
-    :  ('a, 'b, 'c) t
-    -> f1:('a -> 'd)
-    -> f2:('b -> 'e)
-    -> f3:('c -> 'f)
-    -> ('d, 'e, 'f) t
-
-  val map2 : ('a, 'a, 'a) t -> ('b, 'b, 'b) t -> f:('a -> 'b -> 'c) -> ('c, 'c, 'c) t
-end
-
-(** These functors allow users to write:
-    {[
-      module Foo = struct
-        include Tuple.Make       (String) (Int)
-        include Tuple.Comparator (String) (Int)
-        include Tuple.Comparable (String) (Int)
-        include Tuple.Hashable   (String) (Int)
-        include Tuple.Binable    (String) (Int)
-      end
-    ]}
-*)
-
-module Make (T1 : sig
-  type t
-end) (T2 : sig
-  type t
-end) : sig
-  type t = T1.t * T2.t
-end
-
-module Comparator (S1 : Comparator.S) (S2 : Comparator.S) :
-  Comparator.S with type t = Make(S1)(S2).t
-
-module type Comparable_sexpable = sig
-  type t [@@deriving sexp]
-
-  include Comparable.S with type t := t
-end
-
-module Comparable_plain (S1 : Comparable.S_plain) (S2 : Comparable.S_plain) : sig
-  (*_ This type is introduced because older versions of OCaml do not support
-    destructive substitutions with `type t1 = 'a t2`. *)
-
-  type comparator_witness =
-    (S1.comparator_witness, S2.comparator_witness) T2.comparator_witness
-
-  include
-    Comparable.S_plain
-      with type t := Make(S1)(S2).t
-      with type comparator_witness := comparator_witness
-end
-
-module Comparable (S1 : Comparable_sexpable) (S2 : Comparable_sexpable) :
-  Comparable_sexpable with type t := Make(S1)(S2).t
-
-module type Hashable_sexpable = sig
-  type t [@@deriving sexp]
-
-  include Hashable.S with type t := t
-end
-
-(** The difference between [Hashable] and [Hashable_t] functors is that the former's
-    result type doesn't contain type [t] and the latter does. Therefore, [Hashable] can't
-    be used to combine two pairs into 4-tuple. but [Hashable_t] can. On the other hand
-    result of [Hashable_t] cannot be combined with [Comparable].
-
-    example:
-    module Four_ints = Tuple.Hashable_t (Tuple.Hashable_t (Int)(Int))
-    (Tuple.Hashable_t (Int)(Int))
-
-    If instead we used [Hashable] compiler would complain that the input to outer functor
-    doesn't have type [t].
-
-    On the other hand:
-    module Foo = struct
-    type t = String.t * Int.t
-    include Tuple.Comparable (String) (Int)
-    include Tuple.Hashable (String) (Int)
-    end
-
-    If we used [Hashable_t] above, the compiler would complain that we have two types [t]
-    defined.
-
-    Unfortunately, it is not possible to define just one functor that could be used in
-    both cases.
-*)
-module Hashable (S1 : Hashable_sexpable) (S2 : Hashable_sexpable) :
-  Hashable_sexpable with type t := Make(S1)(S2).t
-
-module Hashable_t (S1 : Hashable_sexpable) (S2 : Hashable_sexpable) :
-  Hashable_sexpable with type t = Make(S1)(S2).t
-
-module Sexpable (S1 : Sexpable.S) (S2 : Sexpable.S) :
-  Sexpable.S with type t := Make(S1)(S2).t
-
-module Binable (B1 : Binable.S) (B2 : Binable.S) : Binable.S with type t := Make(B1)(B2).t
-
-module Hasher (H1 : sig
-  type t [@@deriving compare, hash, sexp]
-end) (H2 : sig
-  type t [@@deriving compare, hash, sexp]
-end) : Hashable_sexpable with type t := Make(H1)(H2).t
+include Tuple_intf.Tuple
Index: core-0.17.1/core/src/tuple_intf.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/src/tuple_intf.ml
@@ -0,0 +1,221 @@
+(** Functors and signatures for dealing with modules for tuples.  *)
+
+open! Import
+
+module Definitions = struct
+  (*_ Defined here to circumvent shadowing of [Comparator] below. *)
+  module type Comparable_plain_arg = Comparator.S
+
+  module type Comparable_arg = sig
+    type t [@@deriving compare, sexp]
+  end
+
+  module type Comparable_sexpable = sig
+    type t [@@deriving sexp]
+
+    include Comparable.S with type t := t
+  end
+
+  module type Hashable_plain_arg = sig
+    type t [@@deriving compare, hash, sexp_of]
+  end
+
+  module type Hashable_arg = sig
+    type t [@@deriving compare, hash, sexp]
+  end
+
+  module type Hashable_sexpable = sig
+    type t [@@deriving sexp]
+
+    include Hashable.S with type t := t
+  end
+end
+
+module type Tuple = sig
+  include module type of struct
+    include Definitions
+  end
+
+  (** Signature for a 2-tuple module *)
+  module T2 : sig
+    type ('a, 'b) t = 'a * 'b [@@deriving sexp, sexp_grammar, typerep]
+
+    include Comparator.Derived2 with type ('a, 'b) t := ('a, 'b) t
+
+    val create : 'a -> 'b -> ('a, 'b) t
+    val curry : (('a, 'b) t -> 'c) -> 'a -> 'b -> 'c
+    val uncurry : ('a -> 'b -> 'c) -> ('a, 'b) t -> 'c
+
+    val compare
+      :  cmp1:('a -> 'a -> int)
+      -> cmp2:('b -> 'b -> int)
+      -> ('a, 'b) t
+      -> ('a, 'b) t
+      -> int
+
+    val equal
+      :  eq1:('a -> 'a -> bool)
+      -> eq2:('b -> 'b -> bool)
+      -> ('a, 'b) t
+      -> ('a, 'b) t
+      -> bool
+
+    [%%if flambda_backend]
+
+    external get1 : (('a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0_immut"
+    external get2 : ((_, 'a) t[@local_opt]) -> ('a[@local_opt]) = "%field1_immut"
+
+    [%%else]
+
+    external get1 : (('a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0"
+    external get2 : ((_, 'a) t[@local_opt]) -> ('a[@local_opt]) = "%field1"
+
+    [%%endif]
+
+    val map : ('a, 'a) t -> f:('a -> 'b) -> ('b, 'b) t
+    val map_fst : ('a, 'b) t -> f:('a -> 'c) -> ('c, 'b) t
+    val map_snd : ('a, 'b) t -> f:('b -> 'c) -> ('a, 'c) t
+    val map_both : ('a, 'b) t -> f1:('a -> 'c) -> f2:('b -> 'd) -> ('c, 'd) t
+    val map2 : ('a, 'a) t -> ('b, 'b) t -> f:('a -> 'b -> 'c) -> ('c, 'c) t
+    val swap : ('a, 'b) t -> ('b, 'a) t
+  end
+
+  (** Signature for a 3-tuple module *)
+  module T3 : sig
+    type ('a, 'b, 'c) t = 'a * 'b * 'c [@@deriving sexp, sexp_grammar, typerep]
+
+    val create : 'a -> 'b -> 'c -> ('a, 'b, 'c) t
+    val curry : (('a, 'b, 'c) t -> 'd) -> 'a -> 'b -> 'c -> 'd
+    val uncurry : ('a -> 'b -> 'c -> 'd) -> ('a, 'b, 'c) t -> 'd
+
+    val equal
+      :  eq1:('a -> 'a -> bool)
+      -> eq2:('b -> 'b -> bool)
+      -> eq3:('c -> 'c -> bool)
+      -> ('a, 'b, 'c) t
+      -> ('a, 'b, 'c) t
+      -> bool
+
+    val compare
+      :  cmp1:('a -> 'a -> int)
+      -> cmp2:('b -> 'b -> int)
+      -> cmp3:('c -> 'c -> int)
+      -> ('a, 'b, 'c) t
+      -> ('a, 'b, 'c) t
+      -> int
+
+    [%%if flambda_backend]
+
+    external get1 : (('a, _, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0_immut"
+    external get2 : ((_, 'a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field1_immut"
+
+    [%%else]
+
+    external get1 : (('a, _, _) t[@local_opt]) -> ('a[@local_opt]) = "%field0"
+    external get2 : ((_, 'a, _) t[@local_opt]) -> ('a[@local_opt]) = "%field1"
+
+    [%%endif]
+
+    val get3 : (_, _, 'a) t -> 'a
+    val map : ('a, 'a, 'a) t -> f:('a -> 'b) -> ('b, 'b, 'b) t
+    val map_fst : ('a, 'b, 'c) t -> f:('a -> 'd) -> ('d, 'b, 'c) t
+    val map_snd : ('a, 'b, 'c) t -> f:('b -> 'd) -> ('a, 'd, 'c) t
+    val map_trd : ('a, 'b, 'c) t -> f:('c -> 'd) -> ('a, 'b, 'd) t
+
+    val map_all
+      :  ('a, 'b, 'c) t
+      -> f1:('a -> 'd)
+      -> f2:('b -> 'e)
+      -> f3:('c -> 'f)
+      -> ('d, 'e, 'f) t
+
+    val map2 : ('a, 'a, 'a) t -> ('b, 'b, 'b) t -> f:('a -> 'b -> 'c) -> ('c, 'c, 'c) t
+  end
+
+  (** These functors allow users to write:
+      {[
+        module Foo = struct
+          include Tuple.Make       (String) (Int)
+          include Tuple.Comparator (String) (Int)
+          include Tuple.Comparable (String) (Int)
+          include Tuple.Hashable   (String) (Int)
+          include Tuple.Binable    (String) (Int)
+        end
+      ]}
+  *)
+
+  module Make
+      (T1 : sig
+         type t
+       end)
+      (T2 : sig
+         type t
+       end) : sig
+    type t = T1.t * T2.t
+  end
+
+  module Comparator (S1 : Comparator.S) (S2 : Comparator.S) :
+    Comparator.S
+    with type t = Make(S1)(S2).t
+     and type comparator_witness =
+      (S1.comparator_witness, S2.comparator_witness) T2.comparator_witness
+
+  module Comparable_plain (S1 : Comparable_plain_arg) (S2 : Comparable_plain_arg) : sig
+    (*_ This type is introduced because older versions of OCaml do not support
+      destructive substitutions with `type t1 = 'a t2`. *)
+
+    type comparator_witness =
+      (S1.comparator_witness, S2.comparator_witness) T2.comparator_witness
+
+    include
+      Comparable.S_plain
+      with type t := Make(S1)(S2).t
+      with type comparator_witness := comparator_witness
+  end
+
+  module Comparable (S1 : Comparable_arg) (S2 : Comparable_arg) :
+    Comparable_sexpable with type t := Make(S1)(S2).t
+
+  module Hashable_plain (S1 : Hashable_plain_arg) (S2 : Hashable_plain_arg) :
+    Hashable.S_plain with type t := Make(S1)(S2).t
+
+  (** The difference between [Hashable] and [Hashable_t] functors is that the former's
+      result type doesn't contain type [t] and the latter does. Therefore, [Hashable] can't
+      be used to combine two pairs into 4-tuple. but [Hashable_t] can. On the other hand
+      result of [Hashable_t] cannot be combined with [Comparable].
+
+      example:
+      module Four_ints = Tuple.Hashable_t (Tuple.Hashable_t (Int)(Int))
+      (Tuple.Hashable_t (Int)(Int))
+
+      If instead we used [Hashable] compiler would complain that the input to outer functor
+      doesn't have type [t].
+
+      On the other hand:
+      module Foo = struct
+      type t = String.t * Int.t
+      include Tuple.Comparable (String) (Int)
+      include Tuple.Hashable (String) (Int)
+      end
+
+      If we used [Hashable_t] above, the compiler would complain that we have two types [t]
+      defined.
+
+      Unfortunately, it is not possible to define just one functor that could be used in
+      both cases.
+  *)
+  module Hashable (S1 : Hashable_arg) (S2 : Hashable_arg) :
+    Hashable_sexpable with type t := Make(S1)(S2).t
+
+  module Hashable_t (S1 : Hashable_arg) (S2 : Hashable_arg) :
+    Hashable_sexpable with type t = Make(S1)(S2).t
+
+  module Sexpable (S1 : Sexpable.S) (S2 : Sexpable.S) :
+    Sexpable.S with type t := Make(S1)(S2).t
+
+  module Binable (B1 : Binable.S) (B2 : Binable.S) :
+    Binable.S with type t := Make(B1)(B2).t
+
+  module Hasher (H1 : Hashable_arg) (H2 : Hashable_arg) :
+    Hashable_sexpable with type t := Make(H1)(H2).t
+end
Index: core-0.17.1/core/src/type_immediacy.ml
===================================================================
--- core-0.17.1.orig/core/src/type_immediacy.ml
+++ core-0.17.1/core/src/type_immediacy.ml
@@ -72,9 +72,13 @@ module T : sig
 
   module Never_values : sig
     val int32 : int32 t
+    val int32_u : (unit -> int32) t
     val int64 : int64 t
+    val int64_u : (unit -> int64) t
     val nativeint : nativeint t
+    val nativeint_u : (unit -> nativeint) t
     val float : float t
+    val float_u : (unit -> float) t
     val string : string t
     val bytes : bytes t
     val array : _ array t
@@ -121,9 +125,13 @@ end = struct
   module Never_values = struct
     (* int32 is boxed even on 64b platform at the moment. *)
     let int32 = never typename_of_int32
+    let int32_u = never typename_of_int32_u
     let int64 = never typename_of_int64
+    let int64_u = never typename_of_int64_u
     let nativeint = never typename_of_nativeint
+    let nativeint_u = never typename_of_nativeint_u
     let float = never typename_of_float
+    let float_u = never typename_of_float_u
     let string = never typename_of_string
     let bytes = never typename_of_bytes
     let array = never_with_name "array"
@@ -147,8 +155,8 @@ module Computation_impl = struct
   type nonrec 'a t = 'a t
 
   include Type_generic.Variant_and_record_intf.M (struct
-    type nonrec 'a t = 'a t
-  end)
+      type nonrec 'a t = 'a t
+    end)
 
   include Never_values
 
@@ -274,8 +282,8 @@ let of_typerep typerep =
 ;;
 
 module For_all_parameters (M : sig
-  val immediacy : Immediacy.t
-end) =
+    val immediacy : Immediacy.t
+  end) =
 struct
   let witness typerep1 typerep2 =
     let t1 = of_typerep typerep1 in
@@ -364,8 +372,8 @@ module Always = struct
   type nonrec 'a t = 'a t
 
   include For_all_parameters (struct
-    let immediacy = Always
-  end)
+      let immediacy = Always
+    end)
 
   let of_typerep typerep =
     let t = of_typerep typerep in
@@ -389,8 +397,8 @@ module Sometimes = struct
   type nonrec 'a t = 'a t
 
   include For_all_parameters (struct
-    let immediacy = Sometimes
-  end)
+      let immediacy = Sometimes
+    end)
 
   let of_typerep typerep =
     let t = of_typerep typerep in
@@ -414,8 +422,8 @@ module Never = struct
   type nonrec 'a t = 'a t
 
   include For_all_parameters (struct
-    let immediacy = Never
-  end)
+      let immediacy = Never
+    end)
 
   let of_typerep typerep =
     let t = of_typerep typerep in
Index: core-0.17.1/core/src/type_immediacy.mli
===================================================================
--- core-0.17.1.orig/core/src/type_immediacy.mli
+++ core-0.17.1/core/src/type_immediacy.mli
@@ -153,8 +153,8 @@ type 'a t
 module Always : sig
   type 'a t
 
-  val of_typerep : 'a Typerep.t -> 'a t option
-  val of_typerep_exn : Source_code_position.t -> 'a Typerep.t -> 'a t
+  val of_typerep : ('a, _) Typerep.t_any -> 'a t option
+  val of_typerep_exn : Source_code_position.t -> ('a, _) Typerep.t_any -> 'a t
   val int_as_value : 'a t -> int -> 'a option
   val int_as_value_exn : 'a t -> int -> 'a
   val int_is_value : 'a t -> int -> bool
Index: core-0.17.1/core/src/uchar.ml
===================================================================
--- core-0.17.1.orig/core/src/uchar.ml
+++ core-0.17.1/core/src/uchar.ml
@@ -3,14 +3,14 @@ module Stable = struct
     module T = struct
       include (
         Base.Uchar :
-          sig
-            type t = Base.Uchar.t [@@deriving compare, equal, hash, sexp, sexp_grammar]
+        sig
+          type t = Base.Uchar.t [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
-            include
-              Base.Comparator.S
-                with type t := t
-                 and type comparator_witness = Base.Uchar.comparator_witness
-          end)
+          include
+            Base.Comparator.S
+            with type t := t
+             and type comparator_witness = Base.Uchar.comparator_witness
+        end)
 
       let stable_witness : t Stable_witness.t = Stable_witness.assert_stable
 
@@ -39,10 +39,10 @@ open! Import
 include Stable.V1
 
 include Hashable.Make_binable_with_hashable (struct
-  module Key = Stable.V1
+    module Key = Stable.V1
 
-  let hashable = Key.hashable
-end)
+    let hashable = Key.hashable
+  end)
 
 include Comparable.Extend_binable (Base.Uchar) (Stable.V1)
 include Base.Uchar
Index: core-0.17.1/core/src/uchar.mli
===================================================================
--- core-0.17.1.orig/core/src/uchar.mli
+++ core-0.17.1/core/src/uchar.mli
@@ -27,8 +27,8 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-        with type comparator_witness = comparator_witness
+      with type t := t
+      with type comparator_witness = comparator_witness
 
     include Hashable.Stable.V1.With_stable_witness.S with type key := t
   end
Index: core-0.17.1/core/src/uniform_array.ml
===================================================================
--- core-0.17.1.orig/core/src/uniform_array.ml
+++ core-0.17.1/core/src/uniform_array.ml
@@ -10,3 +10,13 @@ include
       let to_binable = to_array
       let of_binable = of_array
     end)
+
+include
+  Quickcheckable.Of_quickcheckable1
+    (Array)
+    (struct
+      type nonrec 'a t = 'a t
+
+      let to_quickcheckable = to_array
+      let of_quickcheckable = of_array
+    end)
Index: core-0.17.1/core/src/uniform_array.mli
===================================================================
--- core-0.17.1.orig/core/src/uniform_array.mli
+++ core-0.17.1/core/src/uniform_array.mli
@@ -3,7 +3,7 @@
 
 open! Import
 
-type 'a t = 'a Base.Uniform_array.t [@@deriving bin_io, sexp]
+type 'a t = 'a Base.Uniform_array.t [@@deriving bin_io, quickcheck, sexp, sexp_grammar]
 
 include module type of struct
     include Base.Uniform_array
Index: core-0.17.1/core/src/union_find.ml
===================================================================
--- core-0.17.1.orig/core/src/union_find.ml
+++ core-0.17.1/core/src/union_find.ml
@@ -6,7 +6,7 @@
  *
  * MLton is released under a BSD-style license.
  * See the file MLton-LICENSE for details.
- *)
+*)
 
 open! Import
 
Index: core-0.17.1/core/src/unique_id_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/unique_id_intf.ml
+++ core-0.17.1/core/src/unique_id_intf.ml
@@ -5,7 +5,7 @@ open Std_internal
 
 module type Id = sig
   (** The sexps and strings look like integers. *)
-  type t [@@deriving bin_io, hash, sexp, typerep]
+  type t [@@deriving bin_io, hash, sexp, sexp_grammar, typerep]
 
   (** {b Caveat}: values created with [of_float], [of_sexp], or [of_string] may be equal
       to previously created values. *)
Index: core-0.17.1/core/src/unit.ml
===================================================================
--- core-0.17.1.orig/core/src/unit.ml
+++ core-0.17.1/core/src/unit.ml
@@ -5,7 +5,8 @@ module Stable = struct
 
   module V1 = struct
     module T = struct
-      type t = unit [@@deriving bin_io ~localize, compare, sexp, stable_witness]
+      type t = unit
+      [@@deriving bin_io ~localize, compare, sexp, sexp_grammar, stable_witness]
     end
 
     include T
@@ -18,7 +19,7 @@ module Stable = struct
   end
 
   module V2 = struct
-    type t = unit [@@deriving compare, equal, sexp, stable_witness]
+    type t = unit [@@deriving compare, equal, sexp, sexp_grammar, stable_witness]
     type comparator_witness = V1.comparator_witness
 
     let comparator = V1.comparator
Index: core-0.17.1/core/src/unit.mli
===================================================================
--- core-0.17.1.orig/core/src/unit.mli
+++ core-0.17.1/core/src/unit.mli
@@ -25,7 +25,7 @@ type m = (module S)
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@deriving bin_io ~localize]
+    type nonrec t = t [@@deriving bin_io ~localize, sexp_grammar]
 
     include Stable_module_types.With_stable_witness.S0 with type t := t
   end
@@ -37,7 +37,7 @@ module Stable : sig
       whether or not they say so, so we can't change the [unit] bin-io converter without
       breaking many stable types.  *)
   module V2 : sig
-    type nonrec t = t [@@deriving bin_io ~localize, equal]
+    type nonrec t = t [@@deriving bin_io ~localize, equal, sexp_grammar]
 
     include Stable_module_types.With_stable_witness.S0 with type t := t
   end
Index: core-0.17.1/core/src/unit_of_time.ml
===================================================================
--- core-0.17.1.orig/core/src/unit_of_time.ml
+++ core-0.17.1/core/src/unit_of_time.ml
@@ -8,4 +8,4 @@ type t =
   | Minute
   | Hour
   | Day
-[@@deriving sexp, compare, enumerate, hash]
+[@@deriving sexp, sexp_grammar, compare, enumerate, hash]
Index: core-0.17.1/core/src/unit_of_time.mli
===================================================================
--- core-0.17.1.orig/core/src/unit_of_time.mli
+++ core-0.17.1/core/src/unit_of_time.mli
@@ -11,4 +11,4 @@ type t =
   | Minute
   | Hour
   | Day
-[@@deriving sexp, compare, enumerate, hash]
+[@@deriving sexp, sexp_grammar, compare, enumerate, hash]
Index: core-0.17.1/core/src/validated.ml
===================================================================
--- core-0.17.1.orig/core/src/validated.ml
+++ core-0.17.1/core/src/validated.ml
@@ -56,12 +56,13 @@ module Make (Raw : Raw) = struct
   let type_equal = Type_equal.T
 end
 
-module Add_bin_io (Raw : sig
-  type t [@@deriving bin_io]
-
-  include Raw_bin_io with type t := t
-end)
-(Validated : S with type raw := Raw.t) =
+module Add_bin_io
+    (Raw : sig
+       type t [@@deriving bin_io]
+
+       include Raw_bin_io with type t := t
+     end)
+    (Validated : S with type raw := Raw.t) =
 struct
   include
     Binable.Of_binable_without_uuid [@alert "-legacy"]
@@ -77,12 +78,13 @@ struct
       end)
 end
 
-module Add_compare (Raw : sig
-  type t [@@deriving compare]
-
-  include Raw with type t := t
-end)
-(_ : S with type raw := Raw.t) =
+module Add_compare
+    (Raw : sig
+       type t [@@deriving compare]
+
+       include Raw with type t := t
+     end)
+    (_ : S with type raw := Raw.t) =
 struct
   let compare t1 t2 = [%compare: Raw.t] (raw t1) (raw t2)
 end
@@ -96,33 +98,36 @@ end
        M.globalize example_validated
      ;;
    ]} *)
-module Add_globalize (Raw : sig
-  type t [@@deriving globalize]
-
-  include Raw with type t := t
-end)
-(_ : S with type raw := Raw.t) =
+module Add_globalize
+    (Raw : sig
+       type t [@@deriving globalize]
+
+       include Raw with type t := t
+     end)
+    (_ : S with type raw := Raw.t) =
 struct
   let globalize t = Raw.globalize t
 end
 
-module Add_hash (Raw : sig
-  type t [@@deriving hash]
-
-  include Raw with type t := t
-end)
-(Validated : S with type raw := Raw.t) =
+module Add_hash
+    (Raw : sig
+       type t [@@deriving hash]
+
+       include Raw with type t := t
+     end)
+    (Validated : S with type raw := Raw.t) =
 struct
   let hash_fold_t state t = Raw.hash_fold_t state (Validated.raw t)
   let hash t = Raw.hash (Validated.raw t)
 end
 
-module Add_typerep (Raw : sig
-  type t [@@deriving typerep]
-
-  include Raw with type t := t
-end)
-(_ : S with type raw := Raw.t) =
+module Add_typerep
+    (Raw : sig
+       type t [@@deriving typerep]
+
+       include Raw with type t := t
+     end)
+    (_ : S with type raw := Raw.t) =
 struct
   type t = Raw.t [@@deriving typerep]
 end
@@ -134,10 +139,10 @@ module Make_binable (Raw : Raw_bin_io) =
 end
 
 module Make_bin_io_compare_hash_sexp (Raw : sig
-  type t [@@deriving compare, hash]
+    type t [@@deriving compare, hash]
 
-  include Raw_bin_io with type t := t
-end) =
+    include Raw_bin_io with type t := t
+  end) =
 struct
   module T = Make_binable (Raw)
   include T
@@ -152,7 +157,7 @@ struct
 end
 
 module Make_bin_io_compare_globalize_hash_sexp
-  (Raw : Raw_bin_io_compare_globalize_hash_sexp) =
+    (Raw : Raw_bin_io_compare_globalize_hash_sexp) =
 struct
   module T1 = Make_bin_io_compare_hash_sexp (Raw)
   include T1
Index: core-0.17.1/core/src/validated_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/validated_intf.ml
+++ core-0.17.1/core/src/validated_intf.ml
@@ -97,10 +97,10 @@ module type S = sig
 
   include
     S_allowing_substitution
-      with type t := t
-       and type raw := raw
-       and type witness := witness
-       and type ('raw, 'witness) validated := ('raw, 'witness) validated
+    with type t := t
+     and type raw := raw
+     and type witness := witness
+     and type ('raw, 'witness) validated := ('raw, 'witness) validated
 end
 
 module type S_bin_io = sig
@@ -158,46 +158,50 @@ module type Validated = sig
     S_bin_io_compare_hash_sexp with type raw := Raw.t
 
   module Make_bin_io_compare_globalize_hash_sexp
-    (Raw : Raw_bin_io_compare_globalize_hash_sexp) :
+      (Raw : Raw_bin_io_compare_globalize_hash_sexp) :
     S_bin_io_compare_globalize_hash_sexp with type raw := Raw.t
 
-  module Add_bin_io (Raw : sig
-    type t [@@deriving bin_io]
+  module Add_bin_io
+      (Raw : sig
+         type t [@@deriving bin_io]
+
+         include Raw_bin_io with type t := t
+       end)
+      (Validated : S with type raw := Raw.t) : sig
+      type t [@@deriving bin_io]
+    end
+    with type t := Validated.t
+
+  module Add_compare
+      (Raw : sig
+         type t [@@deriving compare]
+
+         include Raw with type t := t
+       end)
+      (Validated : S with type raw := Raw.t) : sig
+      type t [@@deriving compare]
+    end
+    with type t := Validated.t
 
-    include Raw_bin_io with type t := t
-  end)
-  (Validated : S with type raw := Raw.t) : sig
-    type t [@@deriving bin_io]
-  end
-  with type t := Validated.t
-
-  module Add_compare (Raw : sig
-    type t [@@deriving compare]
-
-    include Raw with type t := t
-  end)
-  (Validated : S with type raw := Raw.t) : sig
-    type t [@@deriving compare]
-  end
-  with type t := Validated.t
-
-  module Add_hash (Raw : sig
-    type t [@@deriving hash]
-
-    include Raw with type t := t
-  end)
-  (Validated : S with type raw := Raw.t) : sig
-    type t [@@deriving hash]
-  end
-  with type t := Validated.t
-
-  module Add_typerep (Raw : sig
-    type t [@@deriving typerep]
-
-    include Raw with type t := t
-  end)
-  (Validated : S with type raw := Raw.t) : sig
-    type t [@@deriving typerep]
-  end
-  with type t := Validated.t
+  module Add_hash
+      (Raw : sig
+         type t [@@deriving hash]
+
+         include Raw with type t := t
+       end)
+      (Validated : S with type raw := Raw.t) : sig
+      type t [@@deriving hash]
+    end
+    with type t := Validated.t
+
+  module Add_typerep
+      (Raw : sig
+         type t [@@deriving typerep]
+
+         include Raw with type t := t
+       end)
+      (Validated : S with type raw := Raw.t) : sig
+      type t [@@deriving typerep]
+    end
+    with type t := Validated.t
 end
Index: core-0.17.1/core/src/zone.ml
===================================================================
--- core-0.17.1.orig/core/src/zone.ml
+++ core-0.17.1/core/src/zone.ml
@@ -368,9 +368,41 @@ module Stable = struct
         ;;
       end
 
-      let of_utc_offset_explicit_name ~name ~hours:offset =
-        assert (offset >= -24 && offset <= 24);
-        let utc_offset_in_seconds = Int63.of_int (offset * 60 * 60) in
+      let seconds_per_day = Int63.of_int (24 * 60 * 60)
+      let seconds_per_hour = Int63.of_int (60 * 60)
+      let seconds_per_minute = Int63.of_int 60
+
+      let default_name offset =
+        let open Int63.O in
+        let sign = if offset < Int63.zero then '-' else '+'
+        and hours = offset / seconds_per_hour |> Int63.to_int_exn |> Int.abs
+        and minutes =
+          Int63.rem offset seconds_per_hour / seconds_per_minute
+          |> Int63.to_int_exn
+          |> Int.abs
+        and seconds =
+          Int63.rem offset seconds_per_minute |> Int63.to_int_exn |> Int.abs
+        in
+        let open Int.O in
+        if seconds <> 0
+        then sprintf "UTC%c%d:%02d:%02d" sign hours minutes seconds
+        else if minutes <> 0
+        then sprintf "UTC%c%d:%02d" sign hours minutes
+        else if hours <> 0
+        then sprintf "UTC%c%d" sign hours
+        else "UTC"
+      ;;
+
+      let of_utc_offset_in_seconds ?name utc_offset_in_seconds =
+        let open Int63.O in
+        assert (
+          utc_offset_in_seconds >= -seconds_per_day
+          && utc_offset_in_seconds <= seconds_per_day);
+        let name =
+          match name with
+          | Some name -> name
+          | None -> default_name utc_offset_in_seconds
+        in
         { name
         ; original_filename = None
         ; digest = None
@@ -382,13 +414,14 @@ module Stable = struct
         }
       ;;
 
+      let of_utc_offset_explicit_name ~name ~hours:offset =
+        assert (offset >= -24 && offset <= 24);
+        of_utc_offset_in_seconds ~name (Int63.of_int (offset * 60 * 60))
+      ;;
+
       let of_utc_offset ~hours:offset =
-        let name =
-          if offset = 0
-          then "UTC"
-          else sprintf "UTC%s%d" (if offset < 0 then "-" else "+") (abs offset)
-        in
-        of_utc_offset_explicit_name ~name ~hours:offset
+        assert (offset >= -24 && offset <= 24);
+        of_utc_offset_in_seconds (Int63.of_int (offset * 60 * 60))
       ;;
     end
   end
@@ -480,9 +513,14 @@ let index_upper_bound_contains_seconds_s
 ;;
 
 let binary_search_index_of_seconds_since_epoch t ~mode seconds : Index.t =
-  Array.binary_search_segmented t.transitions `Last_on_left ~segment_of:(fun transition ->
-    if Int63.( <= ) (effective_start_time transition ~mode) seconds then `Left else `Right)
-  |> Option.value ~default:Index.before_first_transition
+  (Array.binary_search_segmented
+     t.transitions
+     `Last_on_left
+     ~segment_of:(fun transition ->
+       if Int63.( <= ) (effective_start_time transition ~mode) seconds
+       then `Left
+       else `Right)
+   |> Option.value_local ~default:Index.before_first_transition) [@nontail]
 ;;
 
 let index_of_seconds_since_epoch t ~mode seconds =
@@ -541,6 +579,30 @@ end = struct
   include Absolute
 end
 
+let of_utc_offset_in_seconds_round_down ?name span =
+  Time_in_seconds.Span.to_int63_seconds_round_down_exn span
+  |> of_utc_offset_in_seconds ?name
+;;
+
+let add_offset_in_seconds_round_down t ~name ~span =
+  let span = Time_in_seconds.Span.to_int63_seconds_round_down_exn span in
+  let offset_regime ({ utc_offset_in_seconds; is_dst; abbrv } : Regime.t) : Regime.t =
+    { utc_offset_in_seconds = Int63.( + ) utc_offset_in_seconds span; is_dst; abbrv }
+  in
+  { name
+  ; original_filename = None
+  ; digest = None
+  ; transitions =
+      Array.map
+        t.transitions
+        ~f:(fun { start_time_in_seconds_since_epoch; new_regime } : Transition.t ->
+          { start_time_in_seconds_since_epoch; new_regime = offset_regime new_regime })
+  ; last_regime_index = Index.before_first_transition
+  ; default_local_time_type = offset_regime t.default_local_time_type
+  ; leap_seconds = t.leap_seconds
+  }
+;;
+
 let index t time =
   Time_in_seconds.to_span_since_epoch time
   |> Time_in_seconds.Span.to_int63_seconds_round_down_exn
Index: core-0.17.1/core/src/zone_intf.ml
===================================================================
--- core-0.17.1.orig/core/src/zone_intf.ml
+++ core-0.17.1/core/src/zone_intf.ml
@@ -55,12 +55,32 @@ module type S = sig
       use of the local timezone. *)
   val likely_machine_zones : string list ref
 
+  module Time_in_seconds : Time_in_seconds
+
   (** [of_utc_offset offset] returns a timezone with a static UTC offset (given in
       hours). *)
   val of_utc_offset : hours:int -> t
 
+  (** Like [of_utc_offset], but overriding the default name. These zones can only be
+      reliably transferred over sexp or bin-io using [Stable.Full_data]; see below. *)
   val of_utc_offset_explicit_name : name:string -> hours:int -> t
 
+  (** Returns a timezone with a static UTC offset in units of seconds. Rounds input to the
+      next lower unit of seconds if necessary. These zones can only be reliably
+      transferred over sexp or bin-io using [Stable.Full_data]; see below. *)
+  val of_utc_offset_in_seconds_round_down : ?name:string -> Time_in_seconds.Span.t -> t
+
+  (** Returns a timezone with a fixed offset relative to the given [t] in units of
+      seconds. This time zone doesn't represent any real place, but may be convenient for
+      testing or for other non-real-time purposes. Rounds [span] to the next lower unit of
+      seconds if necessary. These zones can only be reliably transferred over sexp or
+      bin-io using [Stable.Full_data]; see below. *)
+  val add_offset_in_seconds_round_down
+    :  t
+    -> name:string
+    -> span:Time_in_seconds.Span.t
+    -> t
+
   (** [utc] the UTC time zone.  Included for convenience *)
   val utc : t
 
@@ -72,8 +92,6 @@ module type S = sig
   (** [digest t] return the MD5 digest of the file the t was created from (if any) *)
   val digest : t -> Md5.t option
 
-  module Time_in_seconds : Time_in_seconds
-
   (** For performance testing only; [reset_transition_cache t] resets an internal cache in
       [t] used to speed up repeated lookups of the same clock shift transition. *)
   val reset_transition_cache : t -> unit
@@ -122,6 +140,11 @@ end
 module type S_stable = sig
   type t
 
+  (** Transfers the full contents of a time zone including all DST transitions, while
+      other protocols such as [Timezone.Stable.V1] serialize only the name. This protocol
+      is required when talking to platforms that do not have access to a time zone
+      database, or for time zones that do not come from either [Timezone.find] or
+      [of_utc_offset]. *)
   module Full_data : sig
     module V1 :
       Stable_module_types.With_stable_witness.S0_without_comparator with type t = t
Index: core-0.17.1/core/test-bin/src/test_uncaught_exception.ml
===================================================================
--- core-0.17.1.orig/core/test-bin/src/test_uncaught_exception.ml
+++ core-0.17.1/core/test-bin/src/test_uncaught_exception.ml
@@ -20,7 +20,7 @@ let%expect_test "uncaught exception at m
         output
         |> String.split_lines
         |> List.map ~f:(fun line ->
-             if is_backtrace_line line then "<backtrace lines elided>" else line)
+          if is_backtrace_line line then "<backtrace lines elided>" else line)
         (* Don't depend on backtrace contents, which are unstable. *)
         |> List.remove_consecutive_duplicates ~equal:String.equal
         (* Don't depend on backtrace line count. *)
Index: core-0.17.1/core/test/binable_and_sexpable_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/binable_and_sexpable_unit_tests.ml
+++ core-0.17.1/core/test/binable_and_sexpable_unit_tests.ml
@@ -23,136 +23,136 @@ let%test_module _ =
 
     (* S0 *)
     module _ = Stable_unit_test.Make (struct
-      module T = struct
-        type t = int [@@deriving compare]
+        module T = struct
+          type t = int [@@deriving compare]
 
-        include
-          Sexpable.Of_sexpable.V1
-            (String)
-            (struct
-              type t = int
-
-              let to_sexpable = string_of_int
-              let of_sexpable = int_of_string
-            end)
-
-        include
-          Binable.Of_binable.V1 [@alert "-legacy"]
-            (String)
-            (struct
-              type t = int
-
-              let to_binable = string_of_int
-              let of_binable = int_of_string
-            end)
-      end
-
-      type t = T.t [@@deriving bin_io, compare, sexp]
-
-      let equal a b = Int.( = ) 0 ([%compare: t] a b)
-      let tests = int_tests
-    end)
+          include
+            Sexpable.Of_sexpable.V1
+              (String)
+              (struct
+                type t = int
+
+                let to_sexpable = string_of_int
+                let of_sexpable = int_of_string
+              end)
+
+          include
+            Binable.Of_binable.V1 [@alert "-legacy"]
+              (String)
+              (struct
+                type t = int
+
+                let to_binable = string_of_int
+                let of_binable = int_of_string
+              end)
+        end
+
+        type t = T.t [@@deriving bin_io, compare, sexp]
+
+        let equal a b = Int.( = ) 0 ([%compare: t] a b)
+        let tests = int_tests
+      end)
 
     module _ = Stable_unit_test.Make (struct
-      module T = struct
-        type 'a t = 'a option [@@deriving compare]
+        module T = struct
+          type 'a t = 'a option [@@deriving compare]
 
-        include
-          Sexpable.Of_sexpable1.V1
-            (List)
-            (struct
-              type 'a t = 'a option
-
-              let to_sexpable = Option.to_list
-              let of_sexpable = List.hd
-            end)
-
-        include
-          Binable.Of_binable1.V1 [@alert "-legacy"]
-            (List)
-            (struct
-              type 'a t = 'a option
-
-              let to_binable = Option.to_list
-              let of_binable = List.hd
-            end)
-      end
-
-      type t = int T.t [@@deriving bin_io, compare, sexp]
-
-      let equal a b = Int.( = ) 0 ([%compare: t] a b)
-
-      let tests =
-        [ None, "()", "\000"
-        ; Some 1, "(1)", "\001\001"
-        ; Some 1_000, "(1000)", "\001\254\232\003"
-        ; Some ~-1, "(-1)", "\001\255\255"
-        ]
-      ;;
-    end)
+          include
+            Sexpable.Of_sexpable1.V1
+              (List)
+              (struct
+                type 'a t = 'a option
+
+                let to_sexpable = Option.to_list
+                let of_sexpable = List.hd
+              end)
+
+          include
+            Binable.Of_binable1.V1 [@alert "-legacy"]
+              (List)
+              (struct
+                type 'a t = 'a option
+
+                let to_binable = Option.to_list
+                let of_binable = List.hd
+              end)
+        end
+
+        type t = int T.t [@@deriving bin_io, compare, sexp]
+
+        let equal a b = Int.( = ) 0 ([%compare: t] a b)
+
+        let tests =
+          [ None, "()", "\000"
+          ; Some 1, "(1)", "\001\001"
+          ; Some 1_000, "(1000)", "\001\254\232\003"
+          ; Some ~-1, "(-1)", "\001\255\255"
+          ]
+        ;;
+      end)
 
     module _ = Stable_unit_test.Make (struct
-      module T = struct
-        type ('a, 'b) t = ('a, 'b) Either.Stable.V1.t [@@deriving compare]
+        module T = struct
+          type ('a, 'b) t = ('a, 'b) Either.Stable.V1.t [@@deriving compare]
 
-        module Format = struct
-          type ('a, 'b) t =
-            | Left of 'a
-            | Right of 'b
-          [@@deriving bin_io, sexp]
-
-          let of_t = function
-            | First x -> Left x
-            | Second x -> Right x
-          ;;
-
-          let to_t = function
-            | Left x -> First x
-            | Right x -> Second x
-          ;;
+          module Format = struct
+            type ('a, 'b) t =
+              | Left of 'a
+              | Right of 'b
+            [@@deriving bin_io, sexp]
+
+            let of_t = function
+              | First x -> Left x
+              | Second x -> Right x
+            ;;
+
+            let to_t = function
+              | Left x -> First x
+              | Right x -> Second x
+            ;;
+          end
+
+          include
+            Sexpable.Of_sexpable2.V1
+              (Format)
+              (struct
+                type nonrec ('a, 'b) t = ('a, 'b) t
+
+                let to_sexpable = Format.of_t
+                let of_sexpable = Format.to_t
+              end)
+
+          include
+            Binable.Of_binable2.V1 [@alert "-legacy"]
+              (Format)
+              (struct
+                type nonrec ('a, 'b) t = ('a, 'b) t
+
+                let to_binable = Format.of_t
+                let of_binable = Format.to_t
+              end)
         end
 
-        include
-          Sexpable.Of_sexpable2.V1
-            (Format)
-            (struct
-              type nonrec ('a, 'b) t = ('a, 'b) t
-
-              let to_sexpable = Format.of_t
-              let of_sexpable = Format.to_t
-            end)
-
-        include
-          Binable.Of_binable2.V1 [@alert "-legacy"]
-            (Format)
-            (struct
-              type nonrec ('a, 'b) t = ('a, 'b) t
-
-              let to_binable = Format.of_t
-              let of_binable = Format.to_t
-            end)
-      end
-
-      type t = (int, string) T.t [@@deriving bin_io, compare, sexp]
-
-      let equal a b = Int.( = ) 0 ([%compare: t] a b)
-
-      let tests =
-        [ First 1, "(Left 1)", "\000\001"
-        ; First 0, "(Left 0)", "\000\000"
-        ; Second "", "(Right \"\")", "\001\000"
-        ; Second "second", "(Right second)", "\001\006second"
-        ]
-        @
-        if Sys.word_size_in_bits = 64
-        then
-          [ ( First Int.min_value
-            , "(Left -4611686018427387904)"
-            , "\000\252\000\000\000\000\000\000\000\192" )
+        type t = (int, string) T.t [@@deriving bin_io, compare, sexp]
+
+        let equal a b = Int.( = ) 0 ([%compare: t] a b)
+
+        let tests =
+          [ First 1, "(Left 1)", "\000\001"
+          ; First 0, "(Left 0)", "\000\000"
+          ; Second "", "(Right \"\")", "\001\000"
+          ; Second "second", "(Right second)", "\001\006second"
           ]
-        else []
-      ;;
-    end)
+          @
+          if Sys.word_size_in_bits = 64
+          then
+            [ ( First Int.min_value
+              , "(Left -4611686018427387904)"
+              , "\000\252\000\000\000\000\000\000\000\192" )
+            ]
+          else []
+        ;;
+      end)
 
     let%test_module "Of_stringable" =
       (module struct
@@ -164,14 +164,14 @@ let%test_module _ =
         end
 
         include Stable_unit_test.Make (struct
-          include M
+            include M
 
-          let equal = Poly.( = )
-          let tests = int_tests
-        end)
+            let equal = Poly.( = )
+            let tests = int_tests
+          end)
 
         let%expect_test "validate sexp grammar" =
-          require_ok [%here] (Sexp_grammar_validation.validate_grammar (module M));
+          require_ok (Sexp_grammar_validation.validate_grammar (module M));
           [%expect {| String |}]
         ;;
       end)
Index: core-0.17.1/core/test/bool_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/bool_tests.ml
+++ core-0.17.1/core/test/bool_tests.ml
@@ -20,10 +20,9 @@ let%test_module "[of_string_hum]" =
         (* skip memoized allocation *)
         ignore (Or_error.try_with (fun () -> Bool.of_string_hum string) : bool Or_error.t);
         Set.iter (variations_of_string string) ~f:(fun string ->
-          match require_no_allocation [%here] (fun () -> Bool.of_string_hum string) with
-          | actual -> require_equal [%here] (module Bool) actual expect
-          | exception exn ->
-            print_cr [%here] [%message "raised" (string : string) (exn : exn)])
+          match require_no_allocation (fun () -> Bool.of_string_hum string) with
+          | actual -> require_equal (module Bool) actual expect
+          | exception exn -> print_cr [%message "raised" (string : string) (exn : exn)])
       in
       List.iter ~f:(test ~expect:true) [ "true"; "yes"; "1" ];
       [%expect {| |}];
@@ -33,7 +32,7 @@ let%test_module "[of_string_hum]" =
 
     let%expect_test "failure" =
       (* print the exception once *)
-      require_does_raise [%here] (fun () -> Bool.of_string_hum "");
+      require_does_raise (fun () -> Bool.of_string_hum "");
       [%expect
         {|
         ("Bool.of_string_hum: invalid input"
@@ -46,8 +45,7 @@ let%test_module "[of_string_hum]" =
           if String.length string > 1
           then (
             match Bool.of_string_hum string with
-            | bool ->
-              print_cr [%here] [%message "did not raise" (string : string) (bool : bool)]
+            | bool -> print_cr [%message "did not raise" (string : string) (bool : bool)]
             | exception _ -> ()))
       in
       List.iter ~f:test [ "abc"; "tru"; "truth"; "fals"; "falsey"; "0x0"; "01"; "123" ];
Index: core-0.17.1/core/test/core_gc_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/core_gc_unit_tests.ml
+++ core-0.17.1/core/test/core_gc_unit_tests.ml
@@ -174,3 +174,15 @@ let%expect_test "stat add" =
      (forced_major_collections 0))
     |}]
 ;;
+
+let[@inline never] create_and_leak_uncollectable_value () =
+  let thing_to_leak = [| "please don't collect me" |] |> Sys.opaque_identity in
+  Gc.Expert.add_finalizer_exn thing_to_leak (fun _ ->
+    raise_s [%message "that should not have been collected"]);
+  Gc.Expert.leak thing_to_leak
+;;
+
+let%test_unit "leak prevents collection" =
+  create_and_leak_uncollectable_value ();
+  Gc.full_major ()
+;;
Index: core-0.17.1/core/test/core_int63_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/core_int63_unit_tests.ml
+++ core-0.17.1/core/test/core_int63_unit_tests.ml
@@ -134,8 +134,8 @@ let%test_module "Int63_emul" = (module M
 let%test_module "Int63_maybe_native" = (module Make_tests (Int63))
 
 module Make_tests_bin_io (B : sig
-  type t = Int63.t [@@deriving bin_io]
-end) : sig end = struct
+    type t = Int63.t [@@deriving bin_io]
+  end) : sig end = struct
   let test int63 str =
     let open Int63 in
     let s = B.bin_size_t int63 in
Index: core-0.17.1/core/test/core_list_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/core_list_unit_tests.ml
+++ core-0.17.1/core/test/core_list_unit_tests.ml
@@ -60,19 +60,19 @@ let%test_module "random" =
       open G.Monad_infix
 
       module Q = Quickcheck.Configure (struct
-        include Quickcheck
+          include Quickcheck
 
-        let default_trial_count = 1_000
-        let default_sizes = Sequence.cycle_list_exn (List.range 0 10 ~stop:`inclusive)
+          let default_trial_count = 1_000
+          let default_sizes = Sequence.cycle_list_exn (List.range 0 10 ~stop:`inclusive)
 
-        let default_seed =
-          `Deterministic
-            (sprintf
-               "%s values with %s operators."
-               (String.capitalize T.module_name)
-               (String.capitalize Math.module_name))
-        ;;
-      end)
+          let default_seed =
+            `Deterministic
+              (sprintf
+                 "%s values with %s operators."
+                 (String.capitalize T.module_name)
+                 (String.capitalize Math.module_name))
+          ;;
+        end)
 
       let%test_unit "duplicates" =
         Q.test_distinct_values
@@ -131,9 +131,9 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          let q = Queue.create () in
-          List.iter list ~f:(Queue.enqueue q);
-          [%test_result: t list] (Queue.to_list q) ~expect:list)
+            let q = Queue.create () in
+            List.iter list ~f:(Queue.enqueue q);
+            [%test_result: t list] (Queue.to_list q) ~expect:list)
       ;;
 
       let%test_unit "sum vs fold" =
@@ -212,7 +212,7 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          [%test_result: t list] (Array.to_list (List.to_array list)) ~expect:list)
+            [%test_result: t list] (Array.to_list (List.to_array list)) ~expect:list)
       ;;
 
       let%test_unit "max_elt vs min_elt" =
@@ -256,7 +256,7 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          [%test_result: t list] (List.bind list ~f:List.return) ~expect:list)
+            [%test_result: t list] (List.bind list ~f:List.return) ~expect:list)
       ;;
 
       let%test_unit ("monad associativity" [@tags "no-js"]) =
@@ -284,7 +284,7 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          [%test_eq: unit list] (List.ignore_m list) (List.map list ~f:ignore))
+            [%test_eq: unit list] (List.ignore_m list) (List.map list ~f:ignore))
       ;;
 
       let%test_unit "of_list + to_list" =
@@ -467,7 +467,7 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          [%test_result: t list] (List.filter list ~f:(const true)) ~expect:list)
+            [%test_result: t list] (List.filter list ~f:(const true)) ~expect:list)
       ;;
 
       let%test_unit "filter vs rev_filter" =
@@ -612,9 +612,9 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          [%test_eq: t option]
-            (List.hd list)
-            (Option.try_with (fun () -> List.hd_exn list)))
+            [%test_eq: t option]
+              (List.hd list)
+              (Option.try_with (fun () -> List.hd_exn list)))
       ;;
 
       let%test_unit "tl vs tl_exn" =
@@ -622,9 +622,9 @@ let%test_module "random" =
           ~sexp_of:[%sexp_of: t list]
           (List.quickcheck_generator quickcheck_generator)
           ~f:(fun list ->
-          [%test_eq: t list option]
-            (List.tl list)
-            (Option.try_with (fun () -> List.tl_exn list)))
+            [%test_eq: t list option]
+              (List.tl list)
+              (Option.try_with (fun () -> List.tl_exn list)))
       ;;
 
       let%test_unit "find vs find_exn" =
Index: core-0.17.1/core/test/core_map_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/core_map_unit_tests.ml
+++ core-0.17.1/core/test/core_map_unit_tests.ml
@@ -9,29 +9,31 @@ module With_comparator = Map_intf.With_c
 module With_first_class_module = Map_intf.With_first_class_module
 module Without_comparator = Map_intf.Without_comparator
 
-module Unit_tests (Key : sig
-  type 'a t [@@deriving sexp, compare, hash]
-
-  val of_int : int -> int t
-  val to_int : int t -> int
-end) (Map : sig
-  type ('a, 'b, 'c) t_
-  type ('a, 'b, 'c) tree
-  type ('a, 'b, 'c) create_options
-  type ('a, 'b, 'c) access_options
-
-  include
-    Map_intf.Creators_and_accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t_
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
-      with type 'a key := 'a Key.t
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
-
-  val simplify_creator : (int, Int.comparator_witness, 'c) create_options -> 'c
-  val simplify_accessor : (int, Int.comparator_witness, 'c) access_options -> 'c
-  val kind : [ `Map | `Tree ]
-end) : Map_intf.Creators_and_accessors_generic =
+module Unit_tests
+    (Key : sig
+       type 'a t [@@deriving sexp, compare, hash]
+
+       val of_int : int -> int t
+       val to_int : int t -> int
+     end)
+    (Map : sig
+       type ('a, 'b, 'c) t_
+       type ('a, 'b, 'c) tree
+       type ('a, 'b, 'c) create_options
+       type ('a, 'b, 'c) access_options
+
+       include
+         Map_intf.Creators_and_accessors_generic
+         with type ('a, 'b, 'c) t := ('a, 'b, 'c) t_
+         with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+         with type 'a key := 'a Key.t
+         with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
+         with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+
+       val simplify_creator : (int, Int.comparator_witness, 'c) create_options -> 'c
+       val simplify_accessor : (int, Int.comparator_witness, 'c) access_options -> 'c
+       val kind : [ `Map | `Tree ]
+     end) : Map_intf.Creators_and_accessors_generic =
 (* The result signature doesn't actually mean anything -- the values are required so
    that implementors are reminded to add a unit test for each one. *)
 struct
@@ -504,18 +506,16 @@ struct
   let%expect_test _ =
     (* Can't use require_does_raise because the exceptions differ on different key
        types. *)
-    require
-      [%here]
-      (Exn.does_raise (fun () -> Map.of_alist_exn [ Key.sample, 0; Key.sample, 1 ]))
+    require (Exn.does_raise (fun () -> Map.of_alist_exn [ Key.sample, 0; Key.sample, 1 ]))
   ;;
 
   let%expect_test _ =
-    require_does_not_raise [%here] (fun () ->
+    require_does_not_raise (fun () ->
       ignore
         (Map.of_hashtbl_exn
            (List.map Key.samples ~f:(fun key -> key, Key.to_int key)
             |> Hashtbl.Poly.of_alist_exn)
-          : _ Map.t_))
+         : _ Map.t_))
   ;;
 
   let%expect_test _ =
@@ -536,7 +536,7 @@ struct
     in
     (* Can't use require_does_raise because the exceptions differ on different key
        types. *)
-    require [%here] (Exn.does_raise (fun () -> Map.of_hashtbl_exn hashtbl_with_dup))
+    require (Exn.does_raise (fun () -> Map.of_hashtbl_exn hashtbl_with_dup))
   ;;
 
   let of_hashtbl_exn _ = assert false
@@ -594,7 +594,6 @@ struct
     (* Can't use require_does_raise because the exceptions differ on different key
        types. *)
     require
-      [%here]
       (Exn.does_raise (fun () ->
          Map.of_iteri_exn ~iteri:(alist_iteri [ Key.sample, 0; Key.sample, 1 ])))
   ;;
@@ -606,7 +605,7 @@ struct
     let increasing_alist =
       List.sort alist ~compare:(fun a b -> Comparable.lift ~f:fst Key.compare a b)
       |> List.remove_consecutive_duplicates ~equal:(fun a b ->
-           Comparable.lift ~f:fst Key.equal a b)
+        Comparable.lift ~f:fst Key.equal a b)
     in
     let duplicates_alist =
       match increasing_alist with
@@ -717,9 +716,9 @@ struct
       ;;
     end
     in
-    Expect_test_helpers_core.require_equal [%here] (module T) list expect;
-    Expect_test_helpers_core.require_equal [%here] (module T) list_exn expect;
-    Expect_test_helpers_core.require_equal [%here] (module T) list_or_error expect
+    Expect_test_helpers_core.require_equal (module T) list expect;
+    Expect_test_helpers_core.require_equal (module T) list_exn expect;
+    Expect_test_helpers_core.require_equal (module T) list_or_error expect
   ;;
 
   let of_list_with_key_multi _ = assert false
@@ -749,9 +748,9 @@ struct
       let sexp_of_t = Map.sexp_of_t [%sexp_of: int] [%sexp_of: (Key.t * int) list]
     end
     in
-    Expect_test_helpers_core.require_equal [%here] (module T) list_multi expect;
-    Expect_test_helpers_core.require_equal [%here] (module T) list_reduce expect;
-    Expect_test_helpers_core.require_equal [%here] (module T) list_fold expect
+    Expect_test_helpers_core.require_equal (module T) list_multi expect;
+    Expect_test_helpers_core.require_equal (module T) list_reduce expect;
+    Expect_test_helpers_core.require_equal (module T) list_fold expect
   ;;
 
   let is_empty _ = assert false
@@ -855,7 +854,7 @@ struct
        types. *)
     match Map.find_exn (Map.empty ()) Key.sample with
     | exception (Not_found_s _ | Stdlib.Not_found) -> ()
-    | _ -> print_cr [%here] [%message "didn't raise"]
+    | _ -> print_cr [%message "didn't raise"]
   ;;
 
   let%test _ = [%equal: int list] (Map.find_multi (Map.empty ()) Key.sample) []
@@ -1382,12 +1381,12 @@ struct
   let%test _ = [%equal: (Key.t * int) option] (Map.max_elt (Map.empty ())) None
 
   let%expect_test _ =
-    require_does_raise [%here] (fun () -> Map.min_elt_exn (Map.empty ()));
+    require_does_raise (fun () -> Map.min_elt_exn (Map.empty ()));
     [%expect {| map.ml.Tree0.Map_min_elt_exn_of_empty_map |}]
   ;;
 
   let%expect_test _ =
-    require_does_raise [%here] (fun () -> Map.max_elt_exn (Map.empty ()));
+    require_does_raise (fun () -> Map.max_elt_exn (Map.empty ()));
     [%expect {| map.ml.Tree0.Map_max_elt_exn_of_empty_map |}]
   ;;
 
@@ -1442,22 +1441,22 @@ struct
       bool
     in
     let require_num_calls expect =
-      require_equal [%here] (module Int) !num_calls expect;
+      require_equal (module Int) !num_calls expect;
       num_calls := 0
     in
-    require [%here] (Map.for_all (Map.empty ()) ~f:(const true));
-    require [%here] (Map.for_alli (Map.empty ()) ~f:(const_kd true));
-    require [%here] (not (Map.exists (Map.empty ()) ~f:(const true)));
-    require [%here] (not (Map.existsi (Map.empty ()) ~f:(const_kd true)));
+    require (Map.for_all (Map.empty ()) ~f:(const true));
+    require (Map.for_alli (Map.empty ()) ~f:(const_kd true));
+    require (not (Map.exists (Map.empty ()) ~f:(const true)));
+    require (not (Map.existsi (Map.empty ()) ~f:(const_kd true)));
     require_num_calls 0;
     let nonempty_map = random_map Key.samples in
-    require [%here] (not (Map.for_all nonempty_map ~f:(const false)));
+    require (not (Map.for_all nonempty_map ~f:(const false)));
     require_num_calls 1;
-    require [%here] (not (Map.for_alli nonempty_map ~f:(const_kd false)));
+    require (not (Map.for_alli nonempty_map ~f:(const_kd false)));
     require_num_calls 1;
-    require [%here] (Map.exists nonempty_map ~f:(const true));
+    require (Map.exists nonempty_map ~f:(const true));
     require_num_calls 1;
-    require [%here] (Map.existsi nonempty_map ~f:(const_kd true));
+    require (Map.existsi nonempty_map ~f:(const_kd true));
     require_num_calls 1
   ;;
 
@@ -1773,11 +1772,9 @@ struct
 
       let%expect_test _ =
         Expect_test_helpers_base.quickcheck
-          [%here]
           quickcheck_generator
           ~f:(fun input ->
             Expect_test_helpers_base.require_equal
-              [%here]
               (module struct
                 type t = (Key.t * int) list [@@deriving equal, sexp_of]
               end)
@@ -2628,12 +2625,22 @@ let%test_module "Int.Map" =
               include (
                 Core.Map :
                   Map_intf.Accessors_generic
-                    with type ('k, 'v, 'c) t := 'v t
-                    with type ('k, 'v, 'c) tree := 'v Tree.t
-                    with type 'k key := int
-                    with type 'c cmp := Int.comparator_witness
-                    with type ('k, 'v, 'c) access_options :=
-                      ('k, 'v, 'c) Without_comparator.t)
+                  with type ('k, 'v, 'c) t := 'v t
+                  with type ('k, 'v, 'c) tree := 'v Tree.t
+                  with type 'k key := int
+                  with type 'c cmp := Int.comparator_witness
+                  with type ('k, 'v, 'c) access_options :=
+                    ('k, 'v, 'c) Without_comparator.t)
+
+              include (
+                Core.Map :
+                  Map_intf.Transformers_generic
+                  with type ('k, 'v, 'c) t := 'v t
+                  with type ('k, 'v, 'c) tree := 'v Tree.t
+                  with type 'k key := int
+                  with type 'c cmp := Int.comparator_witness
+                  with type ('k, 'v, 'c) access_options :=
+                    ('k, 'v, 'c) Without_comparator.t)
             end))
 ;;
 
Index: core-0.17.1/core/test/core_set_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/core_set_unit_tests.ml
+++ core-0.17.1/core/test/core_set_unit_tests.ml
@@ -6,32 +6,34 @@ module With_first_class_module = Set_int
 module Named = Set.Named
 open Expect_test_helpers_core
 
-module Unit_tests (Elt : sig
-  type 'a t [@@deriving sexp, hash]
-
-  val of_int : int -> int t
-  val to_int : int t -> int
-end) (Set : sig
-  type ('a, 'b) t_
-  type ('a, 'b) set
-  type ('a, 'b) tree
-  type ('a, 'b, 'c) create_options
-  type ('a, 'b, 'c) access_options
-
-  include
-    Set_intf.Creators_and_accessors_generic
-      with type ('a, 'b) t := ('a, 'b) t_
-      with type ('a, 'b) set := ('a, 'b) set
-      with type ('a, 'b) tree := ('a, 'b) tree
-      with type 'a elt := 'a Elt.t
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
-
-  val simplify_creator : (int, Int.comparator_witness, 'c) create_options -> 'c
-  val simplify_accessor : (int, Int.comparator_witness, 'c) access_options -> 'c
-  val kind : [ `Set | `Tree ]
-  val is_poly : bool
-end) : Set_intf.Creators_and_accessors_generic = struct
+module Unit_tests
+    (Elt : sig
+       type 'a t [@@deriving sexp, hash]
+
+       val of_int : int -> int t
+       val to_int : int t -> int
+     end)
+    (Set : sig
+       type ('a, 'b) t_
+       type ('a, 'b) set
+       type ('a, 'b) tree
+       type ('a, 'b, 'c) create_options
+       type ('a, 'b, 'c) access_options
+
+       include
+         Set_intf.Creators_and_accessors_generic
+         with type ('a, 'b) t := ('a, 'b) t_
+         with type ('a, 'b) set := ('a, 'b) set
+         with type ('a, 'b) tree := ('a, 'b) tree
+         with type 'a elt := 'a Elt.t
+         with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
+         with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+
+       val simplify_creator : (int, Int.comparator_witness, 'c) create_options -> 'c
+       val simplify_accessor : (int, Int.comparator_witness, 'c) access_options -> 'c
+       val kind : [ `Set | `Tree ]
+       val is_poly : bool
+     end) : Set_intf.Creators_and_accessors_generic = struct
   module Set = struct
     include Set
 
@@ -179,11 +181,11 @@ end) : Set_intf.Creators_and_accessors_g
       (Quickcheck.Generator.tuple2 gen_set gen_set)
       ~sexp_of:[%sexp_of: Set.t * Set.t]
       ~f:(fun (s1, s2) ->
-      [%test_result: Set.t]
-        (Set.inter s1 s2)
-        ~expect:
-          (Set.fold s1 ~init:(Set.empty ()) ~f:(fun inter elt ->
-             if Set.mem s2 elt then Set.add inter elt else inter)))
+        [%test_result: Set.t]
+          (Set.inter s1 s2)
+          ~expect:
+            (Set.fold s1 ~init:(Set.empty ()) ~f:(fun inter elt ->
+               if Set.mem s2 elt then Set.add inter elt else inter)))
   ;;
 
   let is_subset _ ~of_:_ = assert false
@@ -198,9 +200,9 @@ end) : Set_intf.Creators_and_accessors_g
       (Quickcheck.Generator.tuple2 gen_set gen_set)
       ~sexp_of:[%sexp_of: Set.t * Set.t]
       ~f:(fun (superset, subset) ->
-      [%test_result: bool]
-        (Set.is_subset subset ~of_:superset)
-        ~expect:(Set.for_all subset ~f:(Set.mem superset)))
+        [%test_result: bool]
+          (Set.is_subset subset ~of_:superset)
+          ~expect:(Set.for_all subset ~f:(Set.mem superset)))
   ;;
 
   let are_disjoint _ _ = assert false
@@ -210,9 +212,9 @@ end) : Set_intf.Creators_and_accessors_g
       (Quickcheck.Generator.tuple2 gen_set gen_set)
       ~sexp_of:[%sexp_of: Set.t * Set.t]
       ~f:(fun (s1, s2) ->
-      [%test_result: bool]
-        (Set.are_disjoint s1 s2)
-        ~expect:(Set.is_empty (Set.inter s1 s2)))
+        [%test_result: bool]
+          (Set.are_disjoint s1 s2)
+          ~expect:(Set.is_empty (Set.inter s1 s2)))
   ;;
 
   module Named = struct
@@ -489,38 +491,38 @@ end) : Set_intf.Creators_and_accessors_g
         Quickcheck.test
           Merge_to_sequence_args.quickcheck_generator
           ~f:(fun { order; greater_or_equal_to; less_or_equal_to; x; y } ->
-          let open Set_intf.Merge_to_sequence_element in
-          let value = function
-            | Left x | Right x | Both (x, _) -> Elt.to_int x
-          in
-          let expect =
-            List.concat
-              [ List.map ~f:(fun x -> Both (x, x)) (Set.to_list (Set.inter x y))
-              ; List.map ~f:(fun x -> Left x) (Set.to_list (Set.diff x y))
-              ; List.map ~f:(fun x -> Right x) (Set.to_list (Set.diff y x))
-              ]
-          in
-          let expect =
-            Option.fold greater_or_equal_to ~init:expect ~f:(fun elts min ->
-              let min = Elt.to_int min in
-              List.filter elts ~f:(fun x -> Int.( >= ) (value x) min))
-          in
-          let expect =
-            Option.fold less_or_equal_to ~init:expect ~f:(fun elts max ->
-              let max = Elt.to_int max in
-              List.filter elts ~f:(fun x -> Int.( <= ) (value x) max))
-          in
-          let expect =
-            match order with
-            | None | Some `Increasing ->
-              List.sort expect ~compare:(fun a b -> Int.compare (value a) (value b))
-            | Some `Decreasing ->
-              List.sort expect ~compare:(fun a b -> Int.compare (value b) (value a))
-          in
-          [%test_result: (Elt.t, Elt.t) Merge_to_sequence_element.t list]
-            (Sequence.to_list
-               (Set.merge_to_sequence ?order ?greater_or_equal_to ?less_or_equal_to x y))
-            ~expect)
+            let open Set_intf.Merge_to_sequence_element in
+            let value = function
+              | Left x | Right x | Both (x, _) -> Elt.to_int x
+            in
+            let expect =
+              List.concat
+                [ List.map ~f:(fun x -> Both (x, x)) (Set.to_list (Set.inter x y))
+                ; List.map ~f:(fun x -> Left x) (Set.to_list (Set.diff x y))
+                ; List.map ~f:(fun x -> Right x) (Set.to_list (Set.diff y x))
+                ]
+            in
+            let expect =
+              Option.fold greater_or_equal_to ~init:expect ~f:(fun elts min ->
+                let min = Elt.to_int min in
+                List.filter elts ~f:(fun x -> Int.( >= ) (value x) min))
+            in
+            let expect =
+              Option.fold less_or_equal_to ~init:expect ~f:(fun elts max ->
+                let max = Elt.to_int max in
+                List.filter elts ~f:(fun x -> Int.( <= ) (value x) max))
+            in
+            let expect =
+              match order with
+              | None | Some `Increasing ->
+                List.sort expect ~compare:(fun a b -> Int.compare (value a) (value b))
+              | Some `Decreasing ->
+                List.sort expect ~compare:(fun a b -> Int.compare (value b) (value a))
+            in
+            [%test_result: (Elt.t, Elt.t) Merge_to_sequence_element.t list]
+              (Sequence.to_list
+                 (Set.merge_to_sequence ?order ?greater_or_equal_to ?less_or_equal_to x y))
+              ~expect)
       ;;
     end)
   ;;
@@ -643,9 +645,9 @@ end) : Set_intf.Creators_and_accessors_g
       (Quickcheck.Generator.tuple2 gen_set gen_set)
       ~sexp_of:[%sexp_of: Set.t_ * Set.t_]
       ~f:(fun (s1, s2) ->
-      let expect = symmetric_diff_spec s1 s2 in
-      let actual = symmetric_diff_set s1 s2 in
-      assert (Set.equal actual expect))
+        let expect = symmetric_diff_spec s1 s2 in
+        let actual = symmetric_diff_set s1 s2 in
+        assert (Set.equal actual expect))
   ;;
 
   let%test _ =
@@ -915,16 +917,10 @@ end) : Set_intf.Creators_and_accessors_g
 
   let%expect_test "compare and compare_direct" =
     let set_of_list ints = Set.of_list (List.map ints ~f:Elt.of_int) in
-    require_compare_equal [%here] (module Set) (Set.empty ()) (Set.empty ());
-    require [%here] (Set.compare (Set.empty ()) (set_of_list [ 0 ]) <> 0);
-    require_compare_equal
-      [%here]
-      (module Set)
-      (set_of_list [ 1; 2; 3 ])
-      (set_of_list [ 3; 2; 1 ]);
-    require
-      [%here]
-      (Set.compare (set_of_list [ 0; 1; 2; 3 ]) (set_of_list [ 1; 1; 2; 3 ]) <> 0)
+    require_compare_equal (module Set) (Set.empty ()) (Set.empty ());
+    require (Set.compare (Set.empty ()) (set_of_list [ 0 ]) <> 0);
+    require_compare_equal (module Set) (set_of_list [ 1; 2; 3 ]) (set_of_list [ 3; 2; 1 ]);
+    require (Set.compare (set_of_list [ 0; 1; 2; 3 ]) (set_of_list [ 1; 1; 2; 3 ]) <> 0)
   ;;
 
   let to_tree _ = assert false
@@ -1149,12 +1145,11 @@ let%test_module "Int.Set.Tree" =
 let%expect_test "t_of_sexp raises on duplicate elements" =
   let no_dup_sexp = Sexp.of_string "(a b c d)" in
   require_equal
-    [%here]
     (module Sexp)
     no_dup_sexp
     ([%sexp_of: String.Set.t] ([%of_sexp: String.Set.t] no_dup_sexp));
   let dup_sexp = Sexp.of_string "(a b a d)" in
-  require_does_raise [%here] (fun () -> [%of_sexp: String.Set.t] dup_sexp);
+  require_does_raise (fun () -> [%of_sexp: String.Set.t] dup_sexp);
   [%expect
     {| (Of_sexp_error "Set.t_of_sexp: duplicate element in set" (invalid_sexp a)) |}]
 ;;
@@ -1165,12 +1160,11 @@ let%expect_test "bin_read_t raises on du
   for n = 0 to max_n do
     let s1 = Set.Poly.of_array (Array.init n ~f:succ) in
     let pos = Set.Poly.bin_write_t Int.bin_write_t bstr ~pos:0 s1 in
-    require_equal [%here] (module Int) pos (n + 1);
+    require_equal (module Int) pos (n + 1);
     let pos_ref = ref 0 in
     let s2 = Set.Poly.bin_read_t Int.bin_read_t bstr ~pos_ref in
-    require_equal [%here] (module Int) !pos_ref (n + 1);
+    require_equal (module Int) !pos_ref (n + 1);
     require_equal
-      [%here]
       (module struct
         type t = int Set.Poly.t [@@deriving sexp_of]
 
@@ -1183,17 +1177,15 @@ let%expect_test "bin_read_t raises on du
       bstr.{1} <- 'x';
       bstr.{2} <- 'x';
       pos_ref := 0;
-      require_does_raise [%here] (fun () ->
-        Set.Poly.bin_read_t Int.bin_read_t bstr ~pos_ref);
+      require_does_raise (fun () -> Set.Poly.bin_read_t Int.bin_read_t bstr ~pos_ref);
       [%expect {| (Failure "Set.bin_read_t: duplicate element in set") |}];
-      require_equal [%here] (module Int) !pos_ref (n + 1))
+      require_equal (module Int) !pos_ref (n + 1))
   done
 ;;
 
 let%expect_test _ =
   let open Expect_test_helpers_core in
   print_and_check_stable_type
-    [%here]
     (module struct
       type t = Set.M(Int).t [@@deriving bin_io, compare, sexp]
     end)
Index: core-0.17.1/core/test/core_string_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/core_string_unit_tests.ml
+++ core-0.17.1/core/test/core_string_unit_tests.ml
@@ -164,7 +164,6 @@ let%test_module "split" =
       in
       (* Now run the tests of [split] behavior. *)
       quickcheck_m
-        [%here]
         (module M)
         ~examples
         ~f:(fun (parts, delimiter) ->
@@ -175,7 +174,6 @@ let%test_module "split" =
           in
           (* Test that we got back where we started. *)
           require_equal
-            [%here]
             (module struct
               type t = Str.t list [@@deriving equal, sexp_of]
             end)
Index: core-0.17.1/core/test/digit_string_helpers_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/digit_string_helpers_tests.ml
+++ core-0.17.1/core/test/digit_string_helpers_tests.ml
@@ -70,7 +70,7 @@ let test_write_int63 ~digits ?(verbose =
   let require_does_raise here f =
     (* uses above print_endline, so if verbose is false, prints nothing on exn *)
     match f () with
-    | _ -> require_does_raise here ignore
+    | _ -> require_does_raise ~here ignore
     | exception exn -> print_endline (Exn.to_string exn)
   in
   let max = max_with ~digits in
@@ -91,7 +91,7 @@ let test_write_int63 ~digits ?(verbose =
       (Bytes.to_string bytes)
       ~expect:(sprintf "!%0*Ld!" digits (Int63.to_int64 int63))
   in
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     Quickcheck.test
       (Int63.gen_log_uniform_incl Int63.zero max)
       ~examples:[ Int63.zero; max ]
@@ -316,7 +316,7 @@ let%expect_test "write_9_digit_int" =
 
 let%expect_test "write_int63" =
   for digits = 1 to max_int63_digits do
-    require_does_not_raise [%here] (fun () ->
+    require_does_not_raise (fun () ->
       test_write_int63
         ~verbose:(digits = max_int63_digits)
         ~align:max_int63_digits
@@ -386,7 +386,7 @@ let test_read_int63 ?(verbose = true) re
   let print_endline = if verbose then print_endline ?hide_positions:None else ignore in
   let require_does_raise here f =
     match f () with
-    | _ -> require_does_raise here ignore
+    | _ -> require_does_raise ~here ignore
     | exception exn -> print_endline (Exn.to_string exn)
   in
   let max = max_with ~digits in
@@ -405,7 +405,7 @@ let test_read_int63 ?(verbose = true) re
     let parsed = read_int63 string ~pos:1 in
     [%test_result: Int63.t] parsed ~expect:int63
   in
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     Quickcheck.test
       (Int63.gen_log_uniform_incl Int63.zero max)
       ~examples:[ Int63.zero; max ]
@@ -598,7 +598,7 @@ let%expect_test "read_9_digit_int" =
 
 let%expect_test "read_int63" =
   for digits = 1 to max_int63_digits do
-    require_does_not_raise [%here] (fun () ->
+    require_does_not_raise (fun () ->
       test_read_int63 ~verbose:(digits = max_int63_digits) ~digits (read_int63 ~digits))
   done;
   [%expect
@@ -654,17 +654,17 @@ let%expect_test "read_int63" =
   let string = String.make 50 '0' in
   let int63 = read_int63 string ~pos:10 ~digits:30 in
   print_s [%sexp (int63 : Int63.t)];
-  require_equal [%here] (module Int63) int63 Int63.zero;
+  require_equal (module Int63) int63 Int63.zero;
   [%expect {| 0 |}];
   (* read Int63.max_value without overflowing *)
   let string = sprintf "%010d%030Ld%010d" 0 (Int63.to_int64 Int63.max_value) 0 in
   let int63 = read_int63 string ~pos:10 ~digits:30 in
   print_s [%sexp (int63 : Int63.t)];
-  require_equal [%here] (module Int63) int63 Int63.max_value;
+  require_equal (module Int63) int63 Int63.max_value;
   [%expect {| 4_611_686_018_427_387_903 |}];
   (* raise on overflow *)
   let string = String.make 50 '9' in
-  require_does_raise [%here] (fun () -> read_int63 string ~pos:10 ~digits:30);
+  require_does_raise (fun () -> read_int63 string ~pos:10 ~digits:30);
   [%expect
     {| (Invalid_argument "Digit_string_helpers.read_int63: overflow reading int63") |}]
 ;;
@@ -675,7 +675,7 @@ let require_no_allocation_if_64_bit_and_
   | W64 ->
     (match f () with
      | exception _ -> f ()
-     | _ -> require_no_allocation here f)
+     | _ -> require_no_allocation ~here f)
 ;;
 
 let%expect_test "read_int63_decimal" =
@@ -695,18 +695,16 @@ let%expect_test "read_int63_decimal" =
     (match restricted with
      | Ok restricted ->
        if has_underscore
-       then print_cr [%here] [%message "ignored '_'" ~_:(restricted : Int63.t)]
-       else require_equal [%here] (module Int63) permissive restricted
+       then print_cr [%message "ignored '_'" ~_:(restricted : Int63.t)]
+       else require_equal (module Int63) permissive restricted
      | Error error ->
-       if has_underscore
-       then ()
-       else print_cr [%here] [%message "failed" ~_:(error : Error.t)]);
+       if has_underscore then () else print_cr [%message "failed" ~_:(error : Error.t)]);
     permissive
   in
   let test_read string ~decimals ~scale ~round_ties =
     let pos_0 = test_read_at string ~pos:0 ~decimals ~scale ~round_ties in
     let pos_1 = test_read_at ("!" ^ string ^ "!") ~pos:1 ~decimals ~scale ~round_ties in
-    require_equal [%here] (module Int63) pos_0 pos_1;
+    require_equal (module Int63) pos_0 pos_1;
     pos_0
   in
   let test63 string ~scale =
@@ -728,7 +726,8 @@ let%expect_test "read_int63_decimal" =
   test ~scale:1 "";
   test ~scale:1 "_";
   test ~scale:1 "0";
-  [%expect {|
+  [%expect
+    {|
     0
     0
     0
@@ -748,7 +747,8 @@ let%expect_test "read_int63_decimal" =
   [%expect {| 0 |}];
   test ~scale:7 "07142857142857142857142857142857142857142857142857";
   test ~scale:7 "071428571428571428571428571428571428571428571428572";
-  [%expect {|
+  [%expect
+    {|
     0
     1
     |}];
@@ -758,13 +758,15 @@ let%expect_test "read_int63_decimal" =
   [%expect {| 30_000 |}];
   test ~scale:60_000 "333_333_333_333";
   test ~scale:60_000 "333333333333";
-  [%expect {|
+  [%expect
+    {|
     20_000
     20_000
     |}];
   test ~scale:60_000 "333_341_666";
   test ~scale:60_000 "333_341_667";
-  [%expect {|
+  [%expect
+    {|
     20_000
     20_001
     |}];
@@ -785,7 +787,8 @@ let%expect_test "read_int63_decimal" =
   test ~scale:60_000 "111_111_111";
   test ~scale:60_000 "111_111";
   test ~scale:60_000 "111";
-  [%expect {|
+  [%expect
+    {|
     6_667
     6_667
     6_667
@@ -881,7 +884,7 @@ let%expect_test "read_int63_decimal" =
     string
     =
     let decimals = Option.value decimals ~default:(String.length string - pos) in
-    require_does_raise [%here] (fun () : Int63.t ->
+    require_does_raise (fun () : Int63.t ->
       read_int63_decimal string ~pos ~decimals ~scale ~round_ties ~allow_underscore)
   in
   test_failure "not a decimal string at all";
Index: core-0.17.1/core/test/dune
===================================================================
--- core-0.17.1.orig/core/test/dune
+++ core-0.17.1/core/test/dune
@@ -1,7 +1,9 @@
 (library
  (name core_test)
- (libraries base_test_helpers core expect_test_helpers_core core_kernel.fheap
-   core_kernel.version_util expect_test_patterns sexp_grammar_validation)
+ (libraries base_test_helpers core expectable expect_test_helpers_core
+   core_kernel.fheap core_kernel.version_util
+   expect_test_helpers_core.expect_test_helpers_base expect_test_patterns
+   sexp_grammar_validation sexplib ppx_stable_witness.stable_witness)
  (preprocessor_deps ../src/config.h)
  (preprocess
   (pps ppx_jane ppx_bin_and_sexp_digest)))
Index: core-0.17.1/core/test/export_base_buffer.mlt
===================================================================
--- core-0.17.1.orig/core/test/export_base_buffer.mlt
+++ core-0.17.1/core/test/export_base_buffer.mlt
@@ -18,55 +18,55 @@ Line _, characters _-_:
 Error: Signature mismatch:
        ...
        The value `to_bytes' is required but not provided
-       File "buffer.mli", line 70, characters 0-25: Expected declaration
+       File "buffer.mli", line 71, characters 0-25: Expected declaration
        The value `output_buffer' is required but not provided
-       File "buffer.mli", line 109, characters 0-44: Expected declaration
+       File "buffer.mli", line 110, characters 0-44: Expected declaration
        The value `truncate' is required but not provided
-       File "buffer.mli", line 113, characters 0-31: Expected declaration
+       File "buffer.mli", line 114, characters 0-31: Expected declaration
        The value `add_utf_8_uchar' is required but not provided
-       File "buffer.mli", line 128, characters 0-42: Expected declaration
+       File "buffer.mli", line 129, characters 0-42: Expected declaration
        The value `add_utf_16le_uchar' is required but not provided
-       File "buffer.mli", line 134, characters 0-45: Expected declaration
+       File "buffer.mli", line 135, characters 0-45: Expected declaration
        The value `add_utf_16be_uchar' is required but not provided
-       File "buffer.mli", line 141, characters 0-45: Expected declaration
+       File "buffer.mli", line 142, characters 0-45: Expected declaration
        The value `add_substitute' is required but not provided
-       File "buffer.mli", line 171, characters 0-62: Expected declaration
+       File "buffer.mli", line 172, characters 0-62: Expected declaration
        The value `add_channel' is required but not provided
-       File "buffer.mli", line 191, characters 0-48: Expected declaration
+       File "buffer.mli", line 192, characters 0-48: Expected declaration
        The value `to_seq' is required but not provided
-       File "buffer.mli", line 203, characters 0-28: Expected declaration
+       File "buffer.mli", line 204, characters 0-28: Expected declaration
        The value `to_seqi' is required but not provided
-       File "buffer.mli", line 209, characters 0-37: Expected declaration
+       File "buffer.mli", line 210, characters 0-37: Expected declaration
        The value `add_seq' is required but not provided
-       File "buffer.mli", line 215, characters 0-37: Expected declaration
+       File "buffer.mli", line 216, characters 0-37: Expected declaration
        The value `of_seq' is required but not provided
-       File "buffer.mli", line 219, characters 0-28: Expected declaration
+       File "buffer.mli", line 220, characters 0-28: Expected declaration
        The value `add_uint8' is required but not provided
-       File "buffer.mli", line 243, characters 0-32: Expected declaration
+       File "buffer.mli", line 244, characters 0-32: Expected declaration
        The value `add_int8' is required but not provided
-       File "buffer.mli", line 249, characters 0-31: Expected declaration
+       File "buffer.mli", line 250, characters 0-31: Expected declaration
        The value `add_uint16_ne' is required but not provided
-       File "buffer.mli", line 255, characters 0-36: Expected declaration
+       File "buffer.mli", line 256, characters 0-36: Expected declaration
        The value `add_uint16_be' is required but not provided
-       File "buffer.mli", line 261, characters 0-36: Expected declaration
+       File "buffer.mli", line 262, characters 0-36: Expected declaration
        The value `add_uint16_le' is required but not provided
-       File "buffer.mli", line 267, characters 0-36: Expected declaration
+       File "buffer.mli", line 268, characters 0-36: Expected declaration
        The value `add_int16_ne' is required but not provided
-       File "buffer.mli", line 273, characters 0-35: Expected declaration
+       File "buffer.mli", line 274, characters 0-35: Expected declaration
        The value `add_int16_be' is required but not provided
-       File "buffer.mli", line 279, characters 0-35: Expected declaration
+       File "buffer.mli", line 280, characters 0-35: Expected declaration
        The value `add_int16_le' is required but not provided
-       File "buffer.mli", line 285, characters 0-35: Expected declaration
+       File "buffer.mli", line 286, characters 0-35: Expected declaration
        The value `add_int32_ne' is required but not provided
-       File "buffer.mli", line 291, characters 0-37: Expected declaration
+       File "buffer.mli", line 292, characters 0-37: Expected declaration
        The value `add_int32_be' is required but not provided
-       File "buffer.mli", line 297, characters 0-37: Expected declaration
+       File "buffer.mli", line 298, characters 0-37: Expected declaration
        The value `add_int32_le' is required but not provided
-       File "buffer.mli", line 303, characters 0-37: Expected declaration
+       File "buffer.mli", line 304, characters 0-37: Expected declaration
        The value `add_int64_ne' is required but not provided
-       File "buffer.mli", line 309, characters 0-38: Expected declaration
+       File "buffer.mli", line 310, characters 0-38: Expected declaration
        The value `add_int64_be' is required but not provided
-       File "buffer.mli", line 315, characters 0-37: Expected declaration
+       File "buffer.mli", line 316, characters 0-37: Expected declaration
        The value `add_int64_le' is required but not provided
-       File "buffer.mli", line 321, characters 0-37: Expected declaration
+       File "buffer.mli", line 322, characters 0-37: Expected declaration
 |}]
Index: core-0.17.1/core/test/hashtbl_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/hashtbl_unit_tests.ml
+++ core-0.17.1/core/test/hashtbl_unit_tests.ml
@@ -6,2347 +6,2093 @@ include Hashtbl_unit_tests_intf
 module _ (Hashtbl : Hashtbl_intf.Hashtbl) = struct
   let%test_module "tests are exhaustive" =
     (module (
-               struct
-                 (* Include [Hashtbl_for_testing]. *)
-                 include (
-                   Hashtbl : Hashtbl_for_testing with type ('a, 'b) t = ('a, 'b) Hashtbl.t)
-
-                 (* Now add what remains from [Hashtbl_intf.Hashtbl]. *)
-
-                 (* type definition *)
-                 type 'a key = 'a
-
-                 (* module type aliases *)
-                 module type For_deriving = Hashtbl.For_deriving
-                 module type Key = Hashtbl.Key
-                 module type Key_binable = Hashtbl.Key_binable
-                 module type Key_stable = Hashtbl.Key_stable
-                 module type Key_plain = Hashtbl.Key_plain
-                 module type S = Hashtbl.S
-                 module type S_binable = Hashtbl.S_binable
-                 module type S_stable = Hashtbl.S_stable
-                 module type S_plain = Hashtbl.S_plain
-
-                 (* module aliases *)
-                 module Hashable = Hashtbl.Hashable
-                 module M = Hashtbl.M
-                 module Make = Hashtbl.Make
-                 module Make_binable = Hashtbl.Make_binable
-                 module Make_binable_with_hashable = Hashtbl.Make_binable_with_hashable
-                 module Make_stable = Hashtbl.Make_stable
-                 module Make_stable_with_hashable = Hashtbl.Make_stable_with_hashable
-                 module Make_plain = Hashtbl.Make_plain
-                 module Make_plain_with_hashable = Hashtbl.Make_plain_with_hashable
-                 module Make_with_hashable = Hashtbl.Make_with_hashable
-                 module Merge_into_action = Hashtbl.Merge_into_action
-                 module Poly = Hashtbl.Poly
-                 module Using_hashable = Hashtbl.Using_hashable
-
-                 (* exports for deriving via [Hashtbl.M(_)] *)
-                 include (Hashtbl : For_deriving with type ('a, 'b) t := ('a, 'b) t)
-
-                 (* hash function accessors, not interesting to test *)
-                 let hash = Hashtbl.hash
-                 let hash_param = Hashtbl.hash_param
-                 let hashable = Hashtbl.hashable
-                 let hashable_s = Hashtbl.hashable_s
-               end :
-                 Hashtbl_intf.Hashtbl))
+    struct
+      (* Include [Hashtbl_for_testing]. *)
+      include (Hashtbl : Hashtbl_for_testing with type ('a, 'b) t = ('a, 'b) Hashtbl.t)
+
+      (* Now add what remains from [Hashtbl_intf.Hashtbl]. *)
+
+      (* type definition *)
+      type 'a key = 'a
+
+      (* module type aliases *)
+      module type For_deriving = Hashtbl.For_deriving
+      module type Key = Hashtbl.Key
+      module type Key_binable = Hashtbl.Key_binable
+      module type Key_stable = Hashtbl.Key_stable
+      module type Key_plain = Hashtbl.Key_plain
+      module type S = Hashtbl.S
+      module type S_binable = Hashtbl.S_binable
+      module type S_stable = Hashtbl.S_stable
+      module type S_plain = Hashtbl.S_plain
+
+      (* module aliases *)
+      module Hashable = Hashtbl.Hashable
+      module M = Hashtbl.M
+      module Make = Hashtbl.Make
+      module Make_binable = Hashtbl.Make_binable
+      module Make_binable_with_hashable = Hashtbl.Make_binable_with_hashable
+      module Make_stable = Hashtbl.Make_stable
+      module Make_stable_with_hashable = Hashtbl.Make_stable_with_hashable
+      module Make_plain = Hashtbl.Make_plain
+      module Make_plain_with_hashable = Hashtbl.Make_plain_with_hashable
+      module Make_with_hashable = Hashtbl.Make_with_hashable
+      module Merge_into_action = Hashtbl.Merge_into_action
+      module Poly = Hashtbl.Poly
+      module Using_hashable = Hashtbl.Using_hashable
+
+      (* exports for deriving via [Hashtbl.M(_)] *)
+      include (Hashtbl : For_deriving with type ('a, 'b) t := ('a, 'b) t)
+
+      (* hash function accessors, not interesting to test *)
+      let hash = Hashtbl.hash
+      let hash_param = Hashtbl.hash_param
+      let hashable = Hashtbl.hashable
+      let hashable_s = Hashtbl.hashable_s
+    end :
+      Hashtbl_intf.Hashtbl))
   ;;
 end
 
 module Make_quickcheck_comparison_to_Map (Hashtbl : Hashtbl_for_testing) = struct
   let%test_module "quickcheck comparison to Map" =
     (module (
-               struct
-                 module Qc = Quickcheck
-                 module Gen = Qc.Generator
-                 open Gen.Monad_infix
-
-                 module type Creators_with_quickcheck_generators = sig
-                   include
-                     Hashtbl_intf.Creators
-                       with type ('a, 'b) t := ('a, 'b) Hashtbl.t
-                       with type 'a key := 'a
-                       with type ('a, 'b, 'c) create_options :=
-                         ('a, 'b, 'c) Hashtbl_intf.create_options_with_first_class_module
-
-                   module For_tests : sig
-                     type ('key, 'data) constructor [@@deriving sexp_of]
-                     type ('key, 'data) multi_constructor [@@deriving sexp_of]
-
-                     val empty_constructor : (_, _) constructor
-
-                     val constructor_gen
-                       :  'key Gen.t
-                       -> 'data Gen.t
-                       -> compare_keys:('key -> 'key -> int)
-                       -> ('key, 'data) constructor Gen.t
-
-                     val multi_constructor_gen
-                       :  'key Gen.t
-                       -> 'data Gen.t
-                       -> compare_keys:('key -> 'key -> int)
-                       -> ('key, 'data) multi_constructor Gen.t
-
-                     val map_and_table
-                       :  'key Base.Hashtbl.Key.t
-                       -> (module Comparator.S
-                             with type t = 'key
-                              and type comparator_witness = 'cmp)
-                       -> ('key, 'data) constructor
-                       -> ('key, 'data, 'cmp) Map.t * ('key, 'data) Hashtbl.t
-
-                     val map_and_table_multi
-                       :  'key Base.Hashtbl.Key.t
-                       -> (module Comparator.S
-                             with type t = 'key
-                              and type comparator_witness = 'cmp)
-                       -> ('key, 'data) multi_constructor
-                       -> ('key, 'data list, 'cmp) Map.t * ('key, 'data list) Hashtbl.t
-                   end
-                 end
-
-                 module type Accessors_with_unit_tests = sig
-                   include
-                     Hashtbl_intf.Accessors
-                       with type ('a, 'b) t := ('a, 'b) Hashtbl.t
-                       with type 'a key := 'a
-
-                   include
-                     Hashtbl_intf.Multi
-                       with type ('a, 'b) t := ('a, 'b) Hashtbl.t
-                       with type 'a key := 'a
-
-                   val invariant
-                     :  'a Invariant.t
-                     -> 'b Invariant.t
-                     -> ('a, 'b) Hashtbl.t Invariant.t
-                 end
-
-                 include (
-                   struct
-                     let alist_gen key_gen data_gen ~unique_keys =
-                       match unique_keys with
-                       | None -> List.quickcheck_generator (Gen.tuple2 key_gen data_gen)
-                       | Some compare ->
-                         List.quickcheck_generator key_gen
-                         >>= fun keys ->
-                         let keys = List.dedup_and_sort keys ~compare in
-                         List.gen_with_length (List.length keys) data_gen
-                         >>| fun data -> List.zip_exn keys data
-                     ;;
-
-                     let create ?growth_allowed ?size m () =
-                       Hashtbl.create ?growth_allowed ?size m
-                     ;;
-
-                     let create_gen () = Gen.singleton `Create
-                     let of_alist = Hashtbl.of_alist
-                     let of_alist_exn = Hashtbl.of_alist_exn
-                     let of_alist_or_error = Hashtbl.of_alist_or_error
-                     let of_alist_report_all_dups = Hashtbl.of_alist_report_all_dups
-
-                     let of_alist_gen key_gen data_gen ~compare_keys =
-                       alist_gen key_gen data_gen ~unique_keys:(Some compare_keys)
-                       >>| fun alist -> `Of_alist alist
-                     ;;
-
-                     let of_alist_multi = Hashtbl.of_alist_multi
-
-                     let of_alist_multi_gen key_gen data_gen =
-                       alist_gen key_gen data_gen ~unique_keys:None
-                       >>| fun alist -> `Of_alist_multi alist
-                     ;;
-
-                     let create_with_key = Hashtbl.create_with_key
-                     let create_with_key_exn = Hashtbl.create_with_key_exn
-                     let create_with_key_or_error = Hashtbl.create_with_key_or_error
-
-                     let create_with_key_gen key_gen data_gen ~compare_keys =
-                       alist_gen key_gen data_gen ~unique_keys:(Some compare_keys)
-                       >>| fun alist -> `Create_with_key alist
-                     ;;
-
-                     let create_mapped = Hashtbl.create_mapped
-
-                     let create_mapped_gen key_gen data_gen ~compare_keys =
-                       alist_gen key_gen data_gen ~unique_keys:(Some compare_keys)
-                       >>| fun alist -> `Create_mapped alist
-                     ;;
-
-                     let group = Hashtbl.group
-
-                     let group_gen key_gen data_gen =
-                       alist_gen key_gen data_gen ~unique_keys:None
-                       >>| fun alist -> `Group alist
-                     ;;
-
-                     module For_tests = struct
-                       type ('key, 'data) constructor =
-                         [ `Create
-                         | `Of_alist of ('key * 'data) list
-                         | `Create_mapped of ('key * 'data) list
-                         | `Create_with_key of ('key * 'data) list
-                         ]
-                       [@@deriving sexp_of]
-
-                       type ('key, 'data) multi_constructor =
-                         [ ('key, 'data list) constructor
-                         | `Of_alist_multi of ('key * 'data) list
-                         | `Group of ('key * 'data) list
-                         ]
-                       [@@deriving sexp_of]
-
-                       let empty_constructor = `Create
-
-                       let constructor_gen key_gen data_gen ~compare_keys =
-                         Gen.union
-                           [ create_gen ()
-                           ; of_alist_gen key_gen data_gen ~compare_keys
-                           ; create_mapped_gen key_gen data_gen ~compare_keys
-                           ; create_with_key_gen key_gen data_gen ~compare_keys
-                           ]
-                       ;;
-
-                       let multi_constructor_gen key_gen data_gen ~compare_keys =
-                         Gen.union
-                           [ constructor_gen
-                               key_gen
-                               (List.quickcheck_generator data_gen)
-                               ~compare_keys
-                           ; of_alist_multi_gen key_gen data_gen
-                           ; group_gen key_gen data_gen
-                           ]
-                       ;;
-
-                       let map_and_table m_hash m_map = function
-                         | `Create -> Map.empty m_map, Hashtbl.create m_hash
-                         | `Of_alist alist ->
-                           Map.of_alist_exn m_map alist, Hashtbl.of_alist_exn m_hash alist
-                         | `Create_with_key alist ->
-                           ( Map.of_alist_exn m_map alist
-                           , Hashtbl.create_with_key_exn m_hash alist ~get_key:fst
-                             |> Hashtbl.map ~f:snd )
-                         | `Create_mapped alist ->
-                           ( Map.of_alist_exn m_map alist
-                           , Hashtbl.create_mapped m_hash alist ~get_key:fst ~get_data:snd
-                             |> (function
-                             | `Ok table -> table
-                             | `Duplicate_keys _ -> assert false) )
-                       ;;
-
-                       let map_and_table_multi m_hash m_map = function
-                         | `Of_alist_multi alist ->
-                           ( Map.of_alist_multi m_map (List.rev alist)
-                           , Hashtbl.of_alist_multi m_hash alist )
-                         | `Group alist ->
-                           ( Map.of_alist_reduce
-                               m_map
-                               ~f:( @ )
-                               (List.map alist ~f:(fun (key, data) -> key, [ data ]))
-                           , Hashtbl.group
-                               m_hash
-                               alist
-                               ~combine:( @ )
-                               ~get_key:fst
-                               ~get_data:(Fn.compose List.return snd) )
-                         | (`Create | `Of_alist _ | `Create_with_key _ | `Create_mapped _)
-                           as c -> map_and_table m_hash m_map c
-                       ;;
-                     end
-                   end :
-                     Creators_with_quickcheck_generators)
-
-                 let create ?growth_allowed ?size m = create ?growth_allowed ?size m ()
-
-                 include (
-                   struct
-                     module For_tests = struct
-                       open For_tests
-
-                       let is_even n = n land 1 = 0
-
-                       module Key = struct
-                         include String
-
-                         let quickcheck_generator =
-                           Gen.small_non_negative_int >>| sprintf "s%d"
-                         ;;
-
-                         let to_bool t =
-                           is_empty t || is_even (Char.to_int (get t (length t - 1)))
-                         ;;
-                       end
-
-                       module Data = struct
-                         include Int
-
-                         let quickcheck_generator = Gen.small_non_negative_int
-                         let to_bool = is_even
-
-                         (* Here, [succ] is useful for testing [filter_map] *)
-                         let to_option t = if is_even t then Some (succ t) else None
-
-                         let to_partition t =
-                           if is_even t then First (succ t) else Second (pred t)
-                         ;;
-                       end
-
-                       module Key_and_data = struct
-                         let to_bool ~key ~data =
-                           Bool.equal (Key.to_bool key) (Data.to_bool data)
-                         ;;
-
-                         let to_data ~key ~data =
-                           if Key.to_bool key then succ data else pred data
-                         ;;
-
-                         let to_data_option ~key ~data =
-                           if Key.to_bool key then Some data else Data.to_option data
-                         ;;
-
-                         let to_data_partition ~key ~data =
-                           if Key.to_bool key
-                           then First (succ data)
-                           else Second (pred data)
-                         ;;
-
-                         let merge ~key x =
-                           if Key.to_bool key
-                           then None
-                           else (
-                             match x with
-                             | `Left data -> Some (Data.succ data)
-                             | `Right data -> Some (Data.pred data)
-                             | `Both (x, y) -> Some (x - y))
-                         ;;
-                       end
-
-                       let comparator = Key.comparator
-                       let compare_keys = Key.compare
-
-                       type nonrec constructor = (Key.t, Data.t) constructor
-                       [@@deriving sexp_of]
-
-                       type nonrec multi_constructor = (Key.t, Data.t) multi_constructor
-                       [@@deriving sexp_of]
-
-                       let empty_constructor = For_tests.empty_constructor
-
-                       let constructor_gen =
-                         constructor_gen
-                           Key.quickcheck_generator
-                           Data.quickcheck_generator
-                           ~compare_keys
-                       ;;
-
-                       let multi_constructor_gen =
-                         multi_constructor_gen
-                           Key.quickcheck_generator
-                           Data.quickcheck_generator
-                           ~compare_keys
-                       ;;
-
-                       let map_and_table = map_and_table (module Key) (module Key)
-
-                       let map_and_table_multi =
-                         map_and_table_multi (module Key) (module Key)
-                       ;;
-
-                       let to_map t =
-                         Hashtbl.to_alist t
-                         |> Map.Using_comparator.of_alist_exn ~comparator
-                       ;;
-                     end
+    struct
+      module Qc = Quickcheck
+      module Gen = Qc.Generator
+      open Gen.Monad_infix
+
+      module type Creators_with_quickcheck_generators = sig
+        include
+          Hashtbl_intf.Creators
+          with type ('a, 'b) t := ('a, 'b) Hashtbl.t
+          with type 'a key := 'a
+          with type ('a, 'b, 'c) create_options :=
+            ('a, 'b, 'c) Hashtbl_intf.create_options_with_first_class_module
+
+        module For_tests : sig
+          type ('key, 'data) constructor [@@deriving sexp_of]
+          type ('key, 'data) multi_constructor [@@deriving sexp_of]
+
+          val empty_constructor : (_, _) constructor
+
+          val constructor_gen
+            :  'key Gen.t
+            -> 'data Gen.t
+            -> compare_keys:('key -> 'key -> int)
+            -> ('key, 'data) constructor Gen.t
+
+          val multi_constructor_gen
+            :  'key Gen.t
+            -> 'data Gen.t
+            -> compare_keys:('key -> 'key -> int)
+            -> ('key, 'data) multi_constructor Gen.t
+
+          val map_and_table
+            :  'key Base.Hashtbl.Key.t
+            -> (module Comparator.S with type t = 'key and type comparator_witness = 'cmp)
+            -> ('key, 'data) constructor
+            -> ('key, 'data, 'cmp) Map.t * ('key, 'data) Hashtbl.t
+
+          val map_and_table_multi
+            :  'key Base.Hashtbl.Key.t
+            -> (module Comparator.S with type t = 'key and type comparator_witness = 'cmp)
+            -> ('key, 'data) multi_constructor
+            -> ('key, 'data list, 'cmp) Map.t * ('key, 'data list) Hashtbl.t
+        end
+      end
+
+      module type Accessors_with_unit_tests = sig
+        include
+          Hashtbl_intf.Accessors
+          with type ('a, 'b) t := ('a, 'b) Hashtbl.t
+          with type 'a key := 'a
+
+        include
+          Hashtbl_intf.Multi
+          with type ('a, 'b) t := ('a, 'b) Hashtbl.t
+          with type 'a key := 'a
+
+        val invariant : 'a Invariant.t -> 'b Invariant.t -> ('a, 'b) Hashtbl.t Invariant.t
+      end
+
+      include (
+      struct
+        let alist_gen key_gen data_gen ~unique_keys =
+          match unique_keys with
+          | None -> List.quickcheck_generator (Gen.tuple2 key_gen data_gen)
+          | Some compare ->
+            List.quickcheck_generator key_gen
+            >>= fun keys ->
+            let keys = List.dedup_and_sort keys ~compare in
+            List.gen_with_length (List.length keys) data_gen
+            >>| fun data -> List.zip_exn keys data
+        ;;
+
+        let create ?growth_allowed ?size m () = Hashtbl.create ?growth_allowed ?size m
+        let create_gen () = Gen.singleton `Create
+        let of_alist = Hashtbl.of_alist
+        let of_alist_exn = Hashtbl.of_alist_exn
+        let of_alist_or_error = Hashtbl.of_alist_or_error
+        let of_alist_report_all_dups = Hashtbl.of_alist_report_all_dups
+
+        let of_alist_gen key_gen data_gen ~compare_keys =
+          alist_gen key_gen data_gen ~unique_keys:(Some compare_keys)
+          >>| fun alist -> `Of_alist alist
+        ;;
+
+        let of_alist_multi = Hashtbl.of_alist_multi
+
+        let of_alist_multi_gen key_gen data_gen =
+          alist_gen key_gen data_gen ~unique_keys:None
+          >>| fun alist -> `Of_alist_multi alist
+        ;;
+
+        let create_with_key = Hashtbl.create_with_key
+        let create_with_key_exn = Hashtbl.create_with_key_exn
+        let create_with_key_or_error = Hashtbl.create_with_key_or_error
+
+        let create_with_key_gen key_gen data_gen ~compare_keys =
+          alist_gen key_gen data_gen ~unique_keys:(Some compare_keys)
+          >>| fun alist -> `Create_with_key alist
+        ;;
+
+        let create_mapped = Hashtbl.create_mapped
+
+        let create_mapped_gen key_gen data_gen ~compare_keys =
+          alist_gen key_gen data_gen ~unique_keys:(Some compare_keys)
+          >>| fun alist -> `Create_mapped alist
+        ;;
+
+        let group = Hashtbl.group
+
+        let group_gen key_gen data_gen =
+          alist_gen key_gen data_gen ~unique_keys:None >>| fun alist -> `Group alist
+        ;;
+
+        module For_tests = struct
+          type ('key, 'data) constructor =
+            [ `Create
+            | `Of_alist of ('key * 'data) list
+            | `Create_mapped of ('key * 'data) list
+            | `Create_with_key of ('key * 'data) list
+            ]
+          [@@deriving sexp_of]
+
+          type ('key, 'data) multi_constructor =
+            [ ('key, 'data list) constructor
+            | `Of_alist_multi of ('key * 'data) list
+            | `Group of ('key * 'data) list
+            ]
+          [@@deriving sexp_of]
+
+          let empty_constructor = `Create
+
+          let constructor_gen key_gen data_gen ~compare_keys =
+            Gen.union
+              [ create_gen ()
+              ; of_alist_gen key_gen data_gen ~compare_keys
+              ; create_mapped_gen key_gen data_gen ~compare_keys
+              ; create_with_key_gen key_gen data_gen ~compare_keys
+              ]
+          ;;
+
+          let multi_constructor_gen key_gen data_gen ~compare_keys =
+            Gen.union
+              [ constructor_gen key_gen (List.quickcheck_generator data_gen) ~compare_keys
+              ; of_alist_multi_gen key_gen data_gen
+              ; group_gen key_gen data_gen
+              ]
+          ;;
+
+          let map_and_table m_hash m_map = function
+            | `Create -> Map.empty m_map, Hashtbl.create m_hash
+            | `Of_alist alist ->
+              Map.of_alist_exn m_map alist, Hashtbl.of_alist_exn m_hash alist
+            | `Create_with_key alist ->
+              ( Map.of_alist_exn m_map alist
+              , Hashtbl.create_with_key_exn m_hash alist ~get_key:fst
+                |> Hashtbl.map ~f:snd )
+            | `Create_mapped alist ->
+              ( Map.of_alist_exn m_map alist
+              , Hashtbl.create_mapped m_hash alist ~get_key:fst ~get_data:snd
+                |> (function
+                 | `Ok table -> table
+                 | `Duplicate_keys _ -> assert false) )
+          ;;
+
+          let map_and_table_multi m_hash m_map = function
+            | `Of_alist_multi alist ->
+              ( Map.of_alist_multi m_map (List.rev alist)
+              , Hashtbl.of_alist_multi m_hash alist )
+            | `Group alist ->
+              ( Map.of_alist_reduce
+                  m_map
+                  ~f:( @ )
+                  (List.map alist ~f:(fun (key, data) -> key, [ data ]))
+              , Hashtbl.group
+                  m_hash
+                  alist
+                  ~combine:( @ )
+                  ~get_key:fst
+                  ~get_data:(Fn.compose List.return snd) )
+            | (`Create | `Of_alist _ | `Create_with_key _ | `Create_mapped _) as c ->
+              map_and_table m_hash m_map c
+          ;;
+        end
+      end :
+        Creators_with_quickcheck_generators)
+
+      let create ?growth_allowed ?size m = create ?growth_allowed ?size m ()
+
+      include (
+      struct
+        module For_tests = struct
+          open For_tests
+
+          let is_even n = n land 1 = 0
+
+          module Key = struct
+            include String
+
+            let quickcheck_generator = Gen.small_non_negative_int >>| sprintf "s%d"
+            let to_bool t = is_empty t || is_even (Char.to_int (get t (length t - 1)))
+          end
+
+          module Data = struct
+            include Int
+
+            let quickcheck_generator = Gen.small_non_negative_int
+            let to_bool = is_even
+
+            (* Here, [succ] is useful for testing [filter_map] *)
+            let to_option t = if is_even t then Some (succ t) else None
+            let to_partition t = if is_even t then First (succ t) else Second (pred t)
+          end
+
+          module Key_and_data = struct
+            let to_bool ~key ~data = Bool.equal (Key.to_bool key) (Data.to_bool data)
+            let to_data ~key ~data = if Key.to_bool key then succ data else pred data
+
+            let to_data_option ~key ~data =
+              if Key.to_bool key then Some data else Data.to_option data
+            ;;
+
+            let to_data_partition ~key ~data =
+              if Key.to_bool key then First (succ data) else Second (pred data)
+            ;;
+
+            let merge ~key x =
+              if Key.to_bool key
+              then None
+              else (
+                match x with
+                | `Left data -> Some (Data.succ data)
+                | `Right data -> Some (Data.pred data)
+                | `Both (x, y) -> Some (x - y))
+            ;;
+          end
+
+          let comparator = Key.comparator
+          let compare_keys = Key.compare
+
+          type nonrec constructor = (Key.t, Data.t) constructor [@@deriving sexp_of]
+
+          type nonrec multi_constructor = (Key.t, Data.t) multi_constructor
+          [@@deriving sexp_of]
+
+          let empty_constructor = For_tests.empty_constructor
+
+          let constructor_gen =
+            constructor_gen
+              Key.quickcheck_generator
+              Data.quickcheck_generator
+              ~compare_keys
+          ;;
+
+          let multi_constructor_gen =
+            multi_constructor_gen
+              Key.quickcheck_generator
+              Data.quickcheck_generator
+              ~compare_keys
+          ;;
+
+          let map_and_table = map_and_table (module Key) (module Key)
+          let map_and_table_multi = map_and_table_multi (module Key) (module Key)
+
+          let to_map t =
+            Hashtbl.to_alist t |> Map.Using_comparator.of_alist_exn ~comparator
+          ;;
+        end
 
-                     open For_tests
+        open For_tests
 
-                     let invariant = Hashtbl.invariant
+        let invariant = Hashtbl.invariant
 
-                     (* This test is mostly validating constructors, making sure all of them satisfy
+        (* This test is mostly validating constructors, making sure all of them satisfy
             [invariant] and that we have correctly constructed corresponding hash tables
             and maps. *)
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.invariant ignore ignore t;
-                         [%test_result: Data.t Key.Map.t] (to_map t) ~expect:map)
-                     ;;
-
-                     let%test_unit _ =
-                       Qc.test
-                         multi_constructor_gen
-                         ~sexp_of:[%sexp_of: multi_constructor]
-                         ~f:(fun multi_constructor ->
-                         let map, t = map_and_table_multi multi_constructor in
-                         Hashtbl.invariant ignore ignore t;
-                         [%test_result: Data.t list Key.Map.t] (to_map t) ~expect:map)
-                     ;;
-
-                     let sexp_of_key = Hashtbl.sexp_of_key
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen Key.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t]
-                         ~f:(fun (constructor, key) ->
-                         let _, t = map_and_table constructor in
-                         [%test_result: Sexp.t]
-                           (Hashtbl.sexp_of_key t key)
-                           ~expect:([%sexp_of: Key.t] key))
-                     ;;
-
-                     let clear = Hashtbl.clear
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let _, t = map_and_table constructor in
-                         Hashtbl.clear t;
-                         Hashtbl.invariant ignore ignore t;
-                         [%test_result: Data.t Key.Map.t] (to_map t) ~expect:Key.Map.empty)
-                     ;;
-
-                     let copy = Hashtbl.copy
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         let t_copy = Hashtbl.copy t in
-                         Hashtbl.clear t;
-                         Hashtbl.invariant ignore ignore t_copy;
-                         [%test_result: Data.t Key.Map.t] (to_map t_copy) ~expect:map)
-                     ;;
-
-                     let fold = Hashtbl.fold
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (Hashtbl.fold t ~init:Key.Map.empty ~f:(fun ~key ~data map ->
-                              Map.set map ~key ~data))
-                           ~expect:map)
-                     ;;
-
-                     let iter = Hashtbl.iter
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         let datas = ref [] in
-                         Hashtbl.iter t ~f:(fun data -> datas := data :: !datas);
-                         [%test_result: Data.t list]
-                           (List.sort !datas ~compare:Data.compare)
-                           ~expect:(List.sort (Map.data map) ~compare:Data.compare))
-                     ;;
-
-                     let iteri = Hashtbl.iteri
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         let t_copy = Hashtbl.create (module Key) in
-                         Hashtbl.iteri t ~f:(fun ~key ~data ->
-                           Hashtbl.add_exn t_copy ~key ~data);
-                         [%test_result: Data.t Key.Map.t] (to_map t_copy) ~expect:map)
-                     ;;
-
-                     let iter_keys = Hashtbl.iter_keys
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         let keys = ref [] in
-                         Hashtbl.iter_keys t ~f:(fun key -> keys := key :: !keys);
-                         [%test_result: Key.t list]
-                           (List.sort !keys ~compare:Key.compare)
-                           ~expect:(List.sort (Map.keys map) ~compare:Key.compare))
-                     ;;
-
-                     let exists = Hashtbl.exists
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (Hashtbl.exists t ~f:Data.to_bool)
-                           ~expect:(Map.exists map ~f:Data.to_bool))
-                     ;;
-
-                     let existsi = Hashtbl.existsi
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (Hashtbl.existsi t ~f:Key_and_data.to_bool)
-                           ~expect:(Map.existsi map ~f:Key_and_data.to_bool))
-                     ;;
-
-                     let for_all = Hashtbl.for_all
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (Hashtbl.for_all t ~f:Data.to_bool)
-                           ~expect:(Map.for_all map ~f:Data.to_bool))
-                     ;;
-
-                     let for_alli = Hashtbl.for_alli
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (Hashtbl.for_alli t ~f:Key_and_data.to_bool)
-                           ~expect:(Map.for_alli map ~f:Key_and_data.to_bool))
-                     ;;
-
-                     let count = Hashtbl.count
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: int]
-                           (Hashtbl.count t ~f:Data.to_bool)
-                           ~expect:(Map.count map ~f:Data.to_bool))
-                     ;;
-
-                     let counti = Hashtbl.counti
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: int]
-                           (Hashtbl.counti t ~f:Key_and_data.to_bool)
-                           ~expect:(Map.counti map ~f:Key_and_data.to_bool))
-                     ;;
-
-                     let length = Hashtbl.length
-                     let capacity = Hashtbl.capacity
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: int] (Hashtbl.length t) ~expect:(Map.length map);
-                         assert (Hashtbl.capacity t >= Hashtbl.length t))
-                     ;;
-
-                     let is_empty = Hashtbl.is_empty
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~examples:[ empty_constructor ]
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (Hashtbl.is_empty t)
-                           ~expect:(Map.is_empty map))
-                     ;;
-
-                     let mem = Hashtbl.mem
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen Key.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t]
-                         ~f:(fun (constructor, key) ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (Hashtbl.mem t key)
-                           ~expect:(Map.mem map key))
-                     ;;
-
-                     let remove = Hashtbl.remove
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen Key.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t]
-                         ~f:(fun (constructor, key) ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.remove t key;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.remove map key))
-                     ;;
-
-                     let set = Hashtbl.set
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                         ~f:(fun (constructor, key, data) ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.set t ~key ~data;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.set map ~key ~data))
-                     ;;
-
-                     let add = Hashtbl.add
-                     let add_exn = Hashtbl.add_exn
-
-                     let%test_unit _ =
-                       let f (name, add) =
-                         Qc.test
-                           (Gen.tuple3
-                              constructor_gen
-                              Key.quickcheck_generator
-                              Data.quickcheck_generator)
-                           ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                           ~f:(fun (constructor, key, data) ->
-                           let map, t = map_and_table constructor in
-                           let expect =
-                             match add t ~key ~data with
-                             | `Ok -> Map.set map ~key ~data
-                             | `Duplicate -> map
-                           in
-                           [%test_result: Data.t Key.Map.t]
-                             (to_map t)
-                             ~expect
-                             ~message:name)
-                       in
-                       let add_exn t ~key ~data =
-                         match add_exn t ~key ~data with
-                         | () -> `Ok
-                         | exception _ -> `Duplicate
-                       in
-                       List.iter ~f [ "add", add; "add_exn", add_exn ]
-                     ;;
-
-                     let change = Hashtbl.change
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            (Option.quickcheck_generator Data.quickcheck_generator))
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t option]
-                         ~f:(fun (constructor, key, data_opt) ->
-                           let map, t = map_and_table constructor in
-                           Hashtbl.change t key ~f:(fun original ->
-                             [%test_result: Data.t option]
-                               original
-                               ~expect:(Map.find map key);
-                             data_opt);
-                           [%test_result: Data.t Key.Map.t]
-                             (to_map t)
-                             ~expect:(Map.change map key ~f:(fun _ -> data_opt)))
-                     ;;
-
-                     let choose = Hashtbl.choose
-                     let choose_exn = Hashtbl.choose_exn
-                     let choose_randomly = Hashtbl.choose_randomly
-                     let choose_randomly_exn = Hashtbl.choose_randomly_exn
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: bool]
-                           (is_some (choose t))
-                           ~expect:(not (Map.is_empty map));
-                         [%test_result: bool]
-                           (is_some (choose_randomly t))
-                           ~expect:(not (Map.is_empty map));
-                         [%test_result: bool]
-                           (Exn.does_raise (fun () -> choose_exn t))
-                           ~expect:(Map.is_empty map);
-                         [%test_result: bool]
-                           (Exn.does_raise (fun () -> choose_randomly_exn t))
-                           ~expect:(Map.is_empty map))
-                     ;;
-
-                     let update = Hashtbl.update
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                         ~f:(fun (constructor, key, data) ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.update t key ~f:(fun original ->
-                           [%test_result: Data.t option]
-                             original
-                             ~expect:(Map.find map key);
-                           data);
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.update map key ~f:(fun _ -> data)))
-                     ;;
-
-                     let update_and_return = Hashtbl.update_and_return
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                         ~f:(fun (constructor, key, data) ->
-                         let map, t = map_and_table constructor in
-                         let result =
-                           Hashtbl.update_and_return t key ~f:(fun original ->
-                             [%test_result: Data.t option]
-                               original
-                               ~expect:(Map.find map key);
-                             data)
-                         in
-                         [%test_result: Data.t Key.Map.t * Data.t]
-                           (to_map t, result)
-                           ~expect:
-                             (let map = Map.update map key ~f:(fun _ -> data) in
-                              map, Map.find_exn map key))
-                     ;;
-
-                     let add_multi = Hashtbl.add_multi
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            multi_constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: multi_constructor * Key.t * Data.t]
-                         ~f:(fun (multi_constructor, key, data) ->
-                         let map, t = map_and_table_multi multi_constructor in
-                         Hashtbl.add_multi t ~key ~data;
-                         [%test_result: Data.t list Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.add_multi map ~key ~data))
-                     ;;
-
-                     let remove_multi = Hashtbl.remove_multi
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 multi_constructor_gen Key.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: multi_constructor * Key.t]
-                         ~f:(fun (multi_constructor, key) ->
-                         let map, t = map_and_table_multi multi_constructor in
-                         Hashtbl.remove_multi t key;
-                         [%test_result: Data.t list Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.remove_multi map key))
-                     ;;
-
-                     let find_multi = Hashtbl.find_multi
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 multi_constructor_gen Key.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: multi_constructor * Key.t]
-                         ~f:(fun (multi_constructor, key) ->
-                         let map, t = map_and_table_multi multi_constructor in
-                         [%test_result: Data.t list]
-                           (Hashtbl.find_multi t key)
-                           ~expect:(Map.find_multi map key))
-                     ;;
-
-                     let map = Hashtbl.map
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.map t ~f:Data.succ))
-                           ~expect:(Map.map map ~f:Data.succ))
-                     ;;
-
-                     let mapi = Hashtbl.mapi
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.mapi t ~f:Key_and_data.to_data))
-                           ~expect:(Map.mapi map ~f:Key_and_data.to_data))
-                     ;;
-
-                     let map_inplace = Hashtbl.map_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.map_inplace t ~f:Data.succ;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.map map ~f:Data.succ))
-                     ;;
-
-                     let mapi_inplace = Hashtbl.mapi_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.mapi_inplace t ~f:Key_and_data.to_data;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.mapi map ~f:Key_and_data.to_data))
-                     ;;
-
-                     let filter_keys = Hashtbl.filter_keys
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.filter_keys t ~f:Key.to_bool))
-                           ~expect:(Map.filter_keys map ~f:Key.to_bool))
-                     ;;
-
-                     let filter = Hashtbl.filter
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.filter t ~f:Data.to_bool))
-                           ~expect:(Map.filter map ~f:Data.to_bool))
-                     ;;
-
-                     let filteri = Hashtbl.filteri
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.filteri t ~f:Key_and_data.to_bool))
-                           ~expect:(Map.filteri map ~f:Key_and_data.to_bool))
-                     ;;
-
-                     let filter_map = Hashtbl.filter_map
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.filter_map t ~f:Data.to_option))
-                           ~expect:(Map.filter_map map ~f:Data.to_option))
-                     ;;
-
-                     let filter_mapi = Hashtbl.filter_mapi
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.filter_mapi t ~f:Key_and_data.to_data_option))
-                           ~expect:(Map.filter_mapi map ~f:Key_and_data.to_data_option))
-                     ;;
-
-                     let filter_inplace = Hashtbl.filter_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.filter_inplace t ~f:Data.to_bool;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:
-                             (Map.filteri map ~f:(fun ~key:_ ~data -> Data.to_bool data)))
-                     ;;
-
-                     let filteri_inplace = Hashtbl.filteri_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.filteri_inplace t ~f:Key_and_data.to_bool;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.filteri map ~f:Key_and_data.to_bool))
-                     ;;
-
-                     let filter_map_inplace = Hashtbl.filter_map_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.filter_map_inplace t ~f:Data.to_option;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.filter_map map ~f:Data.to_option))
-                     ;;
-
-                     let filter_mapi_inplace = Hashtbl.filter_mapi_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.filter_mapi_inplace t ~f:Key_and_data.to_data_option;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.filter_mapi map ~f:Key_and_data.to_data_option))
-                     ;;
-
-                     let filter_keys_inplace = Hashtbl.filter_keys_inplace
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.filter_keys_inplace t ~f:Key.to_bool;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:
-                             (Map.filteri map ~f:(fun ~key ~data:_ -> Key.to_bool key)))
-                     ;;
-
-                     let partition_map = Hashtbl.partition_map
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
-                           (let a, b = Hashtbl.partition_map t ~f:Data.to_partition in
-                            to_map a, to_map b)
-                           ~expect:(Map.partition_map map ~f:Data.to_partition))
-                     ;;
-
-                     let partition_mapi = Hashtbl.partition_mapi
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
-                           (let a, b =
-                              Hashtbl.partition_mapi t ~f:Key_and_data.to_data_partition
-                            in
-                            to_map a, to_map b)
-                           ~expect:
-                             (Map.partition_mapi map ~f:Key_and_data.to_data_partition))
-                     ;;
-
-                     let partition_tf = Hashtbl.partition_tf
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
-                           (let a, b = Hashtbl.partition_tf t ~f:Data.to_bool in
-                            to_map a, to_map b)
-                           ~expect:(Map.partition_tf map ~f:Data.to_bool))
-                     ;;
-
-                     let partitioni_tf = Hashtbl.partitioni_tf
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
-                           (let a, b = Hashtbl.partitioni_tf t ~f:Key_and_data.to_bool in
-                            to_map a, to_map b)
-                           ~expect:(Map.partitioni_tf map ~f:Key_and_data.to_bool))
-                     ;;
-
-                     let find_or_add = Hashtbl.find_or_add
-                     let findi_or_add = Hashtbl.findi_or_add
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                         ~f:(fun (constructor, key, data) ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t]
-                           (find_or_add t key ~default:(fun () -> data))
-                           ~expect:(Map.find map key |> Option.value ~default:data);
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:
-                             (if Map.mem map key then map else Map.set map ~key ~data))
-                     ;;
-
-                     let find = Hashtbl.find
-                     let find_exn = Hashtbl.find_exn
-
-                     let%test_unit _ =
-                       let f (name, find) =
-                         Qc.test
-                           (Gen.tuple2 constructor_gen Key.quickcheck_generator)
-                           ~sexp_of:[%sexp_of: constructor * Key.t]
-                           ~f:(fun (constructor, key) ->
-                           let map, t = map_and_table constructor in
-                           [%test_result: Data.t option]
-                             (find t key)
-                             ~expect:(Map.find map key)
-                             ~message:name)
-                       in
-                       let find_exn t key =
-                         match find_exn t key with
-                         | data -> Some data
-                         | exception _ -> None
-                       in
-                       List.iter ~f [ "find", find; "find_exn", find_exn ]
-                     ;;
-
-                     let find_and_call = Hashtbl.find_and_call
-                     let findi_and_call = Hashtbl.findi_and_call
-                     let find_and_call1 = Hashtbl.find_and_call1
-                     let findi_and_call1 = Hashtbl.findi_and_call1
-                     let find_and_call2 = Hashtbl.find_and_call2
-                     let findi_and_call2 = Hashtbl.findi_and_call2
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple4
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Int.quickcheck_generator
-                            String.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * int * string]
-                         ~f:(fun (constructor, key, a, b) ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: (Data.t, Key.t) Either.t]
-                           (Hashtbl.find_and_call
-                              t
-                              key
-                              ~if_found:Either.first
-                              ~if_not_found:Either.second)
-                           ~expect:
-                             (match Map.find map key with
-                              | Some data -> First data
-                              | None -> Second key);
-                         [%test_result: (Key.t * Data.t, Key.t) Either.t]
-                           (Hashtbl.findi_and_call
-                              t
-                              key
-                              ~if_found:(fun ~key ~data -> Either.first (key, data))
-                              ~if_not_found:Either.second)
-                           ~expect:
-                             (match Map.find map key with
-                              | Some data -> First (key, data)
-                              | None -> Second key);
-                         [%test_result: (Data.t, Key.t) Either.t * int]
-                           (Hashtbl.find_and_call1
-                              t
-                              key
-                              ~a
-                              ~if_found:(fun data a -> Either.first data, a)
-                              ~if_not_found:(fun key a -> Either.second key, a))
-                           ~expect:
-                             (match Map.find map key with
-                              | Some data -> First data, a
-                              | None -> Second key, a);
-                         [%test_result: (Key.t * Data.t, Key.t) Either.t * int]
-                           (Hashtbl.findi_and_call1
-                              t
-                              key
-                              ~a
-                              ~if_found:(fun ~key ~data a -> Either.first (key, data), a)
-                              ~if_not_found:(fun key a -> Either.second key, a))
-                           ~expect:
-                             (match Map.find map key with
-                              | Some data -> First (key, data), a
-                              | None -> Second key, a);
-                         [%test_result: (Data.t, Key.t) Either.t * int * string]
-                           (Hashtbl.find_and_call2
-                              t
-                              key
-                              ~a
-                              ~b
-                              ~if_found:(fun data a b -> Either.first data, a, b)
-                              ~if_not_found:(fun key a b -> Either.second key, a, b))
-                           ~expect:
-                             (match Map.find map key with
-                              | Some data -> First data, a, b
-                              | None -> Second key, a, b);
-                         [%test_result: (Key.t * Data.t, Key.t) Either.t * int * string]
-                           (Hashtbl.findi_and_call2
-                              t
-                              key
-                              ~a
-                              ~b
-                              ~if_found:(fun ~key ~data a b ->
-                                Either.first (key, data), a, b)
-                              ~if_not_found:(fun key a b -> Either.second key, a, b))
-                           ~expect:
-                             (match Map.find map key with
-                              | Some data -> First (key, data), a, b
-                              | None -> Second key, a, b))
-                     ;;
-
-                     let find_and_remove = Hashtbl.find_and_remove
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen Key.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t]
-                         ~f:(fun (constructor, key) ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t option]
-                           (Hashtbl.find_and_remove t key)
-                           ~expect:(Map.find map key);
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:(Map.remove map key))
-                     ;;
-
-                     let merge = Hashtbl.merge
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen constructor_gen)
-                         ~sexp_of:[%sexp_of: constructor * constructor]
-                         ~f:(fun (constructor1, constructor2) ->
-                         let map1, t1 = map_and_table constructor1 in
-                         let map2, t2 = map_and_table constructor2 in
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map (Hashtbl.merge t1 t2 ~f:Key_and_data.merge))
-                           ~expect:(Map.merge map1 map2 ~f:Key_and_data.merge))
-                     ;;
-
-                     let merge_into = Hashtbl.merge_into
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen constructor_gen)
-                         ~sexp_of:[%sexp_of: constructor * constructor]
-                         ~f:(fun (constructor1, constructor2) ->
-                         let map1, t1 = map_and_table constructor1 in
-                         let map2, t2 = map_and_table constructor2 in
-                         let f ~key data2 data1_opt : _ Hashtbl_intf.Merge_into_action.t =
-                           match
-                             Key_and_data.merge
-                               ~key
-                               (match data1_opt with
-                                | Some data1 -> `Both (data1, data2)
-                                | None -> `Right data2)
-                           with
-                           | None -> Remove
-                           | Some x -> Set_to x
-                         in
-                         Hashtbl.merge_into ~dst:t1 ~src:t2 ~f;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t1)
-                           ~expect:
-                             (Map.fold map2 ~init:map1 ~f:(fun ~key ~data:data2 map1 ->
-                                Map.change map1 key ~f:(fun data1_opt ->
-                                  match f ~key data2 data1_opt with
-                                  | Set_to x -> Some x
-                                  | Remove -> None))))
-                     ;;
-
-                     let equal = Hashtbl.equal
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen constructor_gen)
-                         ~sexp_of:[%sexp_of: constructor * constructor]
-                         ~f:(fun (constructor1, constructor2) ->
-                         let map1, t1 = map_and_table constructor1 in
-                         let map2, t2 = map_and_table constructor2 in
-                         [%test_result: bool]
-                           (Hashtbl.equal Data.equal t1 t2)
-                           ~expect:(Map.equal Data.equal map1 map2))
-                     ;;
-
-                     let similar = Hashtbl.similar
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple2 constructor_gen constructor_gen)
-                         ~sexp_of:[%sexp_of: constructor * constructor]
-                         ~f:(fun (constructor1, constructor2) ->
-                         let map1, t1 = map_and_table constructor1 in
-                         let map2, t2 = map_and_table constructor2 in
-                         [%test_result: bool]
-                           (Hashtbl.similar Data.equal t1 t2)
-                           ~expect:(Map.equal Data.equal map1 map2))
-                     ;;
-
-                     let keys = Hashtbl.keys
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Key.t list]
-                           (keys t |> List.sort ~compare:Key.compare)
-                           ~expect:(Map.keys map |> List.sort ~compare:Key.compare))
-                     ;;
-
-                     let data = Hashtbl.data
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: Data.t list]
-                           (data t |> List.sort ~compare:Data.compare)
-                           ~expect:(Map.data map |> List.sort ~compare:Data.compare))
-                     ;;
-
-                     let to_alist = Hashtbl.to_alist
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         [%test_result: (Key.t * Data.t) list]
-                           (to_alist t |> List.sort ~compare:[%compare: Key.t * Data.t])
-                           ~expect:
-                             (Map.to_alist map
-                              |> List.sort ~compare:[%compare: Key.t * Data.t]))
-                     ;;
-
-                     let validate = Hashtbl.validate
-
-                     let%test_unit _ =
-                       Qc.test
-                         constructor_gen
-                         ~sexp_of:[%sexp_of: constructor]
-                         ~f:(fun constructor ->
-                         let map, t = map_and_table constructor in
-                         let name = Key.to_string in
-                         let check_data data =
-                           if Data.to_bool data
-                           then Validate.pass
-                           else Validate.fail "data"
-                         in
-                         [%test_result: bool]
-                           (Result.is_ok
-                              (Validate.result (Hashtbl.validate ~name check_data t)))
-                           ~expect:(Map.for_all map ~f:Data.to_bool))
-                     ;;
-
-                     let incr = Hashtbl.incr
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                         ~f:(fun (constructor, key, by) ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.incr t key ~by;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:
-                             (Map.update map key ~f:(fun opt ->
-                                Option.value opt ~default:0 + by)))
-                     ;;
-
-                     let decr = Hashtbl.decr
-
-                     let%test_unit _ =
-                       Qc.test
-                         (Gen.tuple3
-                            constructor_gen
-                            Key.quickcheck_generator
-                            Data.quickcheck_generator)
-                         ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
-                         ~f:(fun (constructor, key, by) ->
-                         let map, t = map_and_table constructor in
-                         Hashtbl.decr t key ~by;
-                         [%test_result: Data.t Key.Map.t]
-                           (to_map t)
-                           ~expect:
-                             (Map.update map key ~f:(fun opt ->
-                                Option.value opt ~default:0 - by)))
-                     ;;
-                   end :
-                     Accessors_with_unit_tests)
-
-                 (* not particularly interesting to test *)
-                 let sexp_of_t = Hashtbl.sexp_of_t
-               end :
-                 Hashtbl_for_testing with type ('a, 'b) t := ('a, 'b) Hashtbl.t))
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.invariant ignore ignore t;
+            [%test_result: Data.t Key.Map.t] (to_map t) ~expect:map)
+        ;;
+
+        let%test_unit _ =
+          Qc.test
+            multi_constructor_gen
+            ~sexp_of:[%sexp_of: multi_constructor]
+            ~f:(fun multi_constructor ->
+              let map, t = map_and_table_multi multi_constructor in
+              Hashtbl.invariant ignore ignore t;
+              [%test_result: Data.t list Key.Map.t] (to_map t) ~expect:map)
+        ;;
+
+        let sexp_of_key = Hashtbl.sexp_of_key
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen Key.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t]
+            ~f:(fun (constructor, key) ->
+              let _, t = map_and_table constructor in
+              [%test_result: Sexp.t]
+                (Hashtbl.sexp_of_key t key)
+                ~expect:([%sexp_of: Key.t] key))
+        ;;
+
+        let clear = Hashtbl.clear
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let _, t = map_and_table constructor in
+            Hashtbl.clear t;
+            Hashtbl.invariant ignore ignore t;
+            [%test_result: Data.t Key.Map.t] (to_map t) ~expect:Key.Map.empty)
+        ;;
+
+        let copy = Hashtbl.copy
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            let t_copy = Hashtbl.copy t in
+            Hashtbl.clear t;
+            Hashtbl.invariant ignore ignore t_copy;
+            [%test_result: Data.t Key.Map.t] (to_map t_copy) ~expect:map)
+        ;;
+
+        let fold = Hashtbl.fold
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (Hashtbl.fold t ~init:Key.Map.empty ~f:(fun ~key ~data map ->
+                 Map.set map ~key ~data))
+              ~expect:map)
+        ;;
+
+        let iter = Hashtbl.iter
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            let datas = ref [] in
+            Hashtbl.iter t ~f:(fun data -> datas := data :: !datas);
+            [%test_result: Data.t list]
+              (List.sort !datas ~compare:Data.compare)
+              ~expect:(List.sort (Map.data map) ~compare:Data.compare))
+        ;;
+
+        let iteri = Hashtbl.iteri
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            let t_copy = Hashtbl.create (module Key) in
+            Hashtbl.iteri t ~f:(fun ~key ~data -> Hashtbl.add_exn t_copy ~key ~data);
+            [%test_result: Data.t Key.Map.t] (to_map t_copy) ~expect:map)
+        ;;
+
+        let iter_keys = Hashtbl.iter_keys
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            let keys = ref [] in
+            Hashtbl.iter_keys t ~f:(fun key -> keys := key :: !keys);
+            [%test_result: Key.t list]
+              (List.sort !keys ~compare:Key.compare)
+              ~expect:(List.sort (Map.keys map) ~compare:Key.compare))
+        ;;
+
+        let exists = Hashtbl.exists
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: bool]
+              (Hashtbl.exists t ~f:Data.to_bool)
+              ~expect:(Map.exists map ~f:Data.to_bool))
+        ;;
+
+        let existsi = Hashtbl.existsi
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: bool]
+              (Hashtbl.existsi t ~f:Key_and_data.to_bool)
+              ~expect:(Map.existsi map ~f:Key_and_data.to_bool))
+        ;;
+
+        let for_all = Hashtbl.for_all
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: bool]
+              (Hashtbl.for_all t ~f:Data.to_bool)
+              ~expect:(Map.for_all map ~f:Data.to_bool))
+        ;;
+
+        let for_alli = Hashtbl.for_alli
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: bool]
+              (Hashtbl.for_alli t ~f:Key_and_data.to_bool)
+              ~expect:(Map.for_alli map ~f:Key_and_data.to_bool))
+        ;;
+
+        let count = Hashtbl.count
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: int]
+              (Hashtbl.count t ~f:Data.to_bool)
+              ~expect:(Map.count map ~f:Data.to_bool))
+        ;;
+
+        let counti = Hashtbl.counti
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: int]
+              (Hashtbl.counti t ~f:Key_and_data.to_bool)
+              ~expect:(Map.counti map ~f:Key_and_data.to_bool))
+        ;;
+
+        let length = Hashtbl.length
+        let capacity = Hashtbl.capacity
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: int] (Hashtbl.length t) ~expect:(Map.length map);
+            assert (Hashtbl.capacity t >= Hashtbl.length t))
+        ;;
+
+        let is_empty = Hashtbl.is_empty
+
+        let%test_unit _ =
+          Qc.test
+            constructor_gen
+            ~examples:[ empty_constructor ]
+            ~sexp_of:[%sexp_of: constructor]
+            ~f:(fun constructor ->
+              let map, t = map_and_table constructor in
+              [%test_result: bool] (Hashtbl.is_empty t) ~expect:(Map.is_empty map))
+        ;;
+
+        let mem = Hashtbl.mem
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen Key.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t]
+            ~f:(fun (constructor, key) ->
+              let map, t = map_and_table constructor in
+              [%test_result: bool] (Hashtbl.mem t key) ~expect:(Map.mem map key))
+        ;;
+
+        let remove = Hashtbl.remove
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen Key.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t]
+            ~f:(fun (constructor, key) ->
+              let map, t = map_and_table constructor in
+              Hashtbl.remove t key;
+              [%test_result: Data.t Key.Map.t] (to_map t) ~expect:(Map.remove map key))
+        ;;
+
+        let set = Hashtbl.set
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+            ~f:(fun (constructor, key, data) ->
+              let map, t = map_and_table constructor in
+              Hashtbl.set t ~key ~data;
+              [%test_result: Data.t Key.Map.t] (to_map t) ~expect:(Map.set map ~key ~data))
+        ;;
+
+        let add = Hashtbl.add
+        let add_exn = Hashtbl.add_exn
+
+        let%test_unit _ =
+          let f (name, add) =
+            Qc.test
+              (Gen.tuple3
+                 constructor_gen
+                 Key.quickcheck_generator
+                 Data.quickcheck_generator)
+              ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+              ~f:(fun (constructor, key, data) ->
+                let map, t = map_and_table constructor in
+                let expect =
+                  match add t ~key ~data with
+                  | `Ok -> Map.set map ~key ~data
+                  | `Duplicate -> map
+                in
+                [%test_result: Data.t Key.Map.t] (to_map t) ~expect ~message:name)
+          in
+          let add_exn t ~key ~data =
+            match add_exn t ~key ~data with
+            | () -> `Ok
+            | exception _ -> `Duplicate
+          in
+          List.iter ~f [ "add", add; "add_exn", add_exn ]
+        ;;
+
+        let change = Hashtbl.change
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               (Option.quickcheck_generator Data.quickcheck_generator))
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t option]
+            ~f:(fun (constructor, key, data_opt) ->
+              let map, t = map_and_table constructor in
+              Hashtbl.change t key ~f:(fun original ->
+                [%test_result: Data.t option] original ~expect:(Map.find map key);
+                data_opt);
+              [%test_result: Data.t Key.Map.t]
+                (to_map t)
+                ~expect:(Map.change map key ~f:(fun _ -> data_opt)))
+        ;;
+
+        let choose = Hashtbl.choose
+        let choose_exn = Hashtbl.choose_exn
+        let choose_randomly = Hashtbl.choose_randomly
+        let choose_randomly_exn = Hashtbl.choose_randomly_exn
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: bool] (is_some (choose t)) ~expect:(not (Map.is_empty map));
+            [%test_result: bool]
+              (is_some (choose_randomly t))
+              ~expect:(not (Map.is_empty map));
+            [%test_result: bool]
+              (Exn.does_raise (fun () -> choose_exn t))
+              ~expect:(Map.is_empty map);
+            [%test_result: bool]
+              (Exn.does_raise (fun () -> choose_randomly_exn t))
+              ~expect:(Map.is_empty map))
+        ;;
+
+        let update = Hashtbl.update
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+            ~f:(fun (constructor, key, data) ->
+              let map, t = map_and_table constructor in
+              Hashtbl.update t key ~f:(fun original ->
+                [%test_result: Data.t option] original ~expect:(Map.find map key);
+                data);
+              [%test_result: Data.t Key.Map.t]
+                (to_map t)
+                ~expect:(Map.update map key ~f:(fun _ -> data)))
+        ;;
+
+        let update_and_return = Hashtbl.update_and_return
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+            ~f:(fun (constructor, key, data) ->
+              let map, t = map_and_table constructor in
+              let result =
+                Hashtbl.update_and_return t key ~f:(fun original ->
+                  [%test_result: Data.t option] original ~expect:(Map.find map key);
+                  data)
+              in
+              [%test_result: Data.t Key.Map.t * Data.t]
+                (to_map t, result)
+                ~expect:
+                  (let map = Map.update map key ~f:(fun _ -> data) in
+                   map, Map.find_exn map key))
+        ;;
+
+        let add_multi = Hashtbl.add_multi
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               multi_constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: multi_constructor * Key.t * Data.t]
+            ~f:(fun (multi_constructor, key, data) ->
+              let map, t = map_and_table_multi multi_constructor in
+              Hashtbl.add_multi t ~key ~data;
+              [%test_result: Data.t list Key.Map.t]
+                (to_map t)
+                ~expect:(Map.add_multi map ~key ~data))
+        ;;
+
+        let remove_multi = Hashtbl.remove_multi
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 multi_constructor_gen Key.quickcheck_generator)
+            ~sexp_of:[%sexp_of: multi_constructor * Key.t]
+            ~f:(fun (multi_constructor, key) ->
+              let map, t = map_and_table_multi multi_constructor in
+              Hashtbl.remove_multi t key;
+              [%test_result: Data.t list Key.Map.t]
+                (to_map t)
+                ~expect:(Map.remove_multi map key))
+        ;;
+
+        let find_multi = Hashtbl.find_multi
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 multi_constructor_gen Key.quickcheck_generator)
+            ~sexp_of:[%sexp_of: multi_constructor * Key.t]
+            ~f:(fun (multi_constructor, key) ->
+              let map, t = map_and_table_multi multi_constructor in
+              [%test_result: Data.t list]
+                (Hashtbl.find_multi t key)
+                ~expect:(Map.find_multi map key))
+        ;;
+
+        let map = Hashtbl.map
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.map t ~f:Data.succ))
+              ~expect:(Map.map map ~f:Data.succ))
+        ;;
+
+        let mapi = Hashtbl.mapi
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.mapi t ~f:Key_and_data.to_data))
+              ~expect:(Map.mapi map ~f:Key_and_data.to_data))
+        ;;
+
+        let map_inplace = Hashtbl.map_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.map_inplace t ~f:Data.succ;
+            [%test_result: Data.t Key.Map.t] (to_map t) ~expect:(Map.map map ~f:Data.succ))
+        ;;
+
+        let mapi_inplace = Hashtbl.mapi_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.mapi_inplace t ~f:Key_and_data.to_data;
+            [%test_result: Data.t Key.Map.t]
+              (to_map t)
+              ~expect:(Map.mapi map ~f:Key_and_data.to_data))
+        ;;
+
+        let filter_keys = Hashtbl.filter_keys
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.filter_keys t ~f:Key.to_bool))
+              ~expect:(Map.filter_keys map ~f:Key.to_bool))
+        ;;
+
+        let filter = Hashtbl.filter
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.filter t ~f:Data.to_bool))
+              ~expect:(Map.filter map ~f:Data.to_bool))
+        ;;
+
+        let filteri = Hashtbl.filteri
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.filteri t ~f:Key_and_data.to_bool))
+              ~expect:(Map.filteri map ~f:Key_and_data.to_bool))
+        ;;
+
+        let filter_map = Hashtbl.filter_map
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.filter_map t ~f:Data.to_option))
+              ~expect:(Map.filter_map map ~f:Data.to_option))
+        ;;
+
+        let filter_mapi = Hashtbl.filter_mapi
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t]
+              (to_map (Hashtbl.filter_mapi t ~f:Key_and_data.to_data_option))
+              ~expect:(Map.filter_mapi map ~f:Key_and_data.to_data_option))
+        ;;
+
+        let filter_inplace = Hashtbl.filter_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.filter_inplace t ~f:Data.to_bool;
+            [%test_result: Data.t Key.Map.t]
+              (to_map t)
+              ~expect:(Map.filteri map ~f:(fun ~key:_ ~data -> Data.to_bool data)))
+        ;;
+
+        let filteri_inplace = Hashtbl.filteri_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.filteri_inplace t ~f:Key_and_data.to_bool;
+            [%test_result: Data.t Key.Map.t]
+              (to_map t)
+              ~expect:(Map.filteri map ~f:Key_and_data.to_bool))
+        ;;
+
+        let filter_map_inplace = Hashtbl.filter_map_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.filter_map_inplace t ~f:Data.to_option;
+            [%test_result: Data.t Key.Map.t]
+              (to_map t)
+              ~expect:(Map.filter_map map ~f:Data.to_option))
+        ;;
+
+        let filter_mapi_inplace = Hashtbl.filter_mapi_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.filter_mapi_inplace t ~f:Key_and_data.to_data_option;
+            [%test_result: Data.t Key.Map.t]
+              (to_map t)
+              ~expect:(Map.filter_mapi map ~f:Key_and_data.to_data_option))
+        ;;
+
+        let filter_keys_inplace = Hashtbl.filter_keys_inplace
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            Hashtbl.filter_keys_inplace t ~f:Key.to_bool;
+            [%test_result: Data.t Key.Map.t]
+              (to_map t)
+              ~expect:(Map.filteri map ~f:(fun ~key ~data:_ -> Key.to_bool key)))
+        ;;
+
+        let partition_map = Hashtbl.partition_map
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
+              (let a, b = Hashtbl.partition_map t ~f:Data.to_partition in
+               to_map a, to_map b)
+              ~expect:(Map.partition_map map ~f:Data.to_partition))
+        ;;
+
+        let partition_mapi = Hashtbl.partition_mapi
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
+              (let a, b = Hashtbl.partition_mapi t ~f:Key_and_data.to_data_partition in
+               to_map a, to_map b)
+              ~expect:(Map.partition_mapi map ~f:Key_and_data.to_data_partition))
+        ;;
+
+        let partition_tf = Hashtbl.partition_tf
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
+              (let a, b = Hashtbl.partition_tf t ~f:Data.to_bool in
+               to_map a, to_map b)
+              ~expect:(Map.partition_tf map ~f:Data.to_bool))
+        ;;
+
+        let partitioni_tf = Hashtbl.partitioni_tf
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t Key.Map.t * Data.t Key.Map.t]
+              (let a, b = Hashtbl.partitioni_tf t ~f:Key_and_data.to_bool in
+               to_map a, to_map b)
+              ~expect:(Map.partitioni_tf map ~f:Key_and_data.to_bool))
+        ;;
+
+        let find_or_add = Hashtbl.find_or_add
+        let findi_or_add = Hashtbl.findi_or_add
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+            ~f:(fun (constructor, key, data) ->
+              let map, t = map_and_table constructor in
+              [%test_result: Data.t]
+                (find_or_add t key ~default:(fun () -> data))
+                ~expect:(Map.find map key |> Option.value ~default:data);
+              [%test_result: Data.t Key.Map.t]
+                (to_map t)
+                ~expect:(if Map.mem map key then map else Map.set map ~key ~data))
+        ;;
+
+        let find = Hashtbl.find
+        let find_exn = Hashtbl.find_exn
+
+        let%test_unit _ =
+          let f (name, find) =
+            Qc.test
+              (Gen.tuple2 constructor_gen Key.quickcheck_generator)
+              ~sexp_of:[%sexp_of: constructor * Key.t]
+              ~f:(fun (constructor, key) ->
+                let map, t = map_and_table constructor in
+                [%test_result: Data.t option]
+                  (find t key)
+                  ~expect:(Map.find map key)
+                  ~message:name)
+          in
+          let find_exn t key =
+            match find_exn t key with
+            | data -> Some data
+            | exception _ -> None
+          in
+          List.iter ~f [ "find", find; "find_exn", find_exn ]
+        ;;
+
+        let find_and_call = Hashtbl.find_and_call
+        let findi_and_call = Hashtbl.findi_and_call
+        let find_and_call1 = Hashtbl.find_and_call1
+        let findi_and_call1 = Hashtbl.findi_and_call1
+        let find_and_call2 = Hashtbl.find_and_call2
+        let findi_and_call2 = Hashtbl.findi_and_call2
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple4
+               constructor_gen
+               Key.quickcheck_generator
+               Int.quickcheck_generator
+               String.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * int * string]
+            ~f:(fun (constructor, key, a, b) ->
+              let map, t = map_and_table constructor in
+              [%test_result: (Data.t, Key.t) Either.t]
+                (Hashtbl.find_and_call
+                   t
+                   key
+                   ~if_found:Either.first
+                   ~if_not_found:Either.second)
+                ~expect:
+                  (match Map.find map key with
+                   | Some data -> First data
+                   | None -> Second key);
+              [%test_result: (Key.t * Data.t, Key.t) Either.t]
+                (Hashtbl.findi_and_call
+                   t
+                   key
+                   ~if_found:(fun ~key ~data -> Either.first (key, data))
+                   ~if_not_found:Either.second)
+                ~expect:
+                  (match Map.find map key with
+                   | Some data -> First (key, data)
+                   | None -> Second key);
+              [%test_result: (Data.t, Key.t) Either.t * int]
+                (Hashtbl.find_and_call1
+                   t
+                   key
+                   ~a
+                   ~if_found:(fun data a -> Either.first data, a)
+                   ~if_not_found:(fun key a -> Either.second key, a))
+                ~expect:
+                  (match Map.find map key with
+                   | Some data -> First data, a
+                   | None -> Second key, a);
+              [%test_result: (Key.t * Data.t, Key.t) Either.t * int]
+                (Hashtbl.findi_and_call1
+                   t
+                   key
+                   ~a
+                   ~if_found:(fun ~key ~data a -> Either.first (key, data), a)
+                   ~if_not_found:(fun key a -> Either.second key, a))
+                ~expect:
+                  (match Map.find map key with
+                   | Some data -> First (key, data), a
+                   | None -> Second key, a);
+              [%test_result: (Data.t, Key.t) Either.t * int * string]
+                (Hashtbl.find_and_call2
+                   t
+                   key
+                   ~a
+                   ~b
+                   ~if_found:(fun data a b -> Either.first data, a, b)
+                   ~if_not_found:(fun key a b -> Either.second key, a, b))
+                ~expect:
+                  (match Map.find map key with
+                   | Some data -> First data, a, b
+                   | None -> Second key, a, b);
+              [%test_result: (Key.t * Data.t, Key.t) Either.t * int * string]
+                (Hashtbl.findi_and_call2
+                   t
+                   key
+                   ~a
+                   ~b
+                   ~if_found:(fun ~key ~data a b -> Either.first (key, data), a, b)
+                   ~if_not_found:(fun key a b -> Either.second key, a, b))
+                ~expect:
+                  (match Map.find map key with
+                   | Some data -> First (key, data), a, b
+                   | None -> Second key, a, b))
+        ;;
+
+        let find_and_remove = Hashtbl.find_and_remove
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen Key.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t]
+            ~f:(fun (constructor, key) ->
+              let map, t = map_and_table constructor in
+              [%test_result: Data.t option]
+                (Hashtbl.find_and_remove t key)
+                ~expect:(Map.find map key);
+              [%test_result: Data.t Key.Map.t] (to_map t) ~expect:(Map.remove map key))
+        ;;
+
+        let merge = Hashtbl.merge
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen constructor_gen)
+            ~sexp_of:[%sexp_of: constructor * constructor]
+            ~f:(fun (constructor1, constructor2) ->
+              let map1, t1 = map_and_table constructor1 in
+              let map2, t2 = map_and_table constructor2 in
+              [%test_result: Data.t Key.Map.t]
+                (to_map (Hashtbl.merge t1 t2 ~f:Key_and_data.merge))
+                ~expect:(Map.merge map1 map2 ~f:Key_and_data.merge))
+        ;;
+
+        let merge_into = Hashtbl.merge_into
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen constructor_gen)
+            ~sexp_of:[%sexp_of: constructor * constructor]
+            ~f:(fun (constructor1, constructor2) ->
+              let map1, t1 = map_and_table constructor1 in
+              let map2, t2 = map_and_table constructor2 in
+              let f ~key data2 data1_opt : _ Hashtbl_intf.Merge_into_action.t =
+                match
+                  Key_and_data.merge
+                    ~key
+                    (match data1_opt with
+                     | Some data1 -> `Both (data1, data2)
+                     | None -> `Right data2)
+                with
+                | None -> Remove
+                | Some x -> Set_to x
+              in
+              Hashtbl.merge_into ~dst:t1 ~src:t2 ~f;
+              [%test_result: Data.t Key.Map.t]
+                (to_map t1)
+                ~expect:
+                  (Map.fold map2 ~init:map1 ~f:(fun ~key ~data:data2 map1 ->
+                     Map.change map1 key ~f:(fun data1_opt ->
+                       match f ~key data2 data1_opt with
+                       | Set_to x -> Some x
+                       | Remove -> None))))
+        ;;
+
+        let equal = Hashtbl.equal
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen constructor_gen)
+            ~sexp_of:[%sexp_of: constructor * constructor]
+            ~f:(fun (constructor1, constructor2) ->
+              let map1, t1 = map_and_table constructor1 in
+              let map2, t2 = map_and_table constructor2 in
+              [%test_result: bool]
+                (Hashtbl.equal Data.equal t1 t2)
+                ~expect:(Map.equal Data.equal map1 map2))
+        ;;
+
+        let similar = Hashtbl.similar
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple2 constructor_gen constructor_gen)
+            ~sexp_of:[%sexp_of: constructor * constructor]
+            ~f:(fun (constructor1, constructor2) ->
+              let map1, t1 = map_and_table constructor1 in
+              let map2, t2 = map_and_table constructor2 in
+              [%test_result: bool]
+                (Hashtbl.similar Data.equal t1 t2)
+                ~expect:(Map.equal Data.equal map1 map2))
+        ;;
+
+        let keys = Hashtbl.keys
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Key.t list]
+              (keys t |> List.sort ~compare:Key.compare)
+              ~expect:(Map.keys map |> List.sort ~compare:Key.compare))
+        ;;
+
+        let data = Hashtbl.data
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: Data.t list]
+              (data t |> List.sort ~compare:Data.compare)
+              ~expect:(Map.data map |> List.sort ~compare:Data.compare))
+        ;;
+
+        let to_alist = Hashtbl.to_alist
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            [%test_result: (Key.t * Data.t) list]
+              (to_alist t |> List.sort ~compare:[%compare: Key.t * Data.t])
+              ~expect:(Map.to_alist map |> List.sort ~compare:[%compare: Key.t * Data.t]))
+        ;;
+
+        let validate = Hashtbl.validate
+
+        let%test_unit _ =
+          Qc.test constructor_gen ~sexp_of:[%sexp_of: constructor] ~f:(fun constructor ->
+            let map, t = map_and_table constructor in
+            let name = Key.to_string in
+            let check_data data =
+              if Data.to_bool data then Validate.pass else Validate.fail "data"
+            in
+            [%test_result: bool]
+              (Result.is_ok (Validate.result (Hashtbl.validate ~name check_data t)))
+              ~expect:(Map.for_all map ~f:Data.to_bool))
+        ;;
+
+        let incr = Hashtbl.incr
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+            ~f:(fun (constructor, key, by) ->
+              let map, t = map_and_table constructor in
+              Hashtbl.incr t key ~by;
+              [%test_result: Data.t Key.Map.t]
+                (to_map t)
+                ~expect:
+                  (Map.update map key ~f:(fun opt -> Option.value opt ~default:0 + by)))
+        ;;
+
+        let decr = Hashtbl.decr
+
+        let%test_unit _ =
+          Qc.test
+            (Gen.tuple3
+               constructor_gen
+               Key.quickcheck_generator
+               Data.quickcheck_generator)
+            ~sexp_of:[%sexp_of: constructor * Key.t * Data.t]
+            ~f:(fun (constructor, key, by) ->
+              let map, t = map_and_table constructor in
+              Hashtbl.decr t key ~by;
+              [%test_result: Data.t Key.Map.t]
+                (to_map t)
+                ~expect:
+                  (Map.update map key ~f:(fun opt -> Option.value opt ~default:0 - by)))
+        ;;
+      end :
+        Accessors_with_unit_tests)
+
+      (* not particularly interesting to test *)
+      let sexp_of_t = Hashtbl.sexp_of_t
+    end :
+      Hashtbl_for_testing with type ('a, 'b) t := ('a, 'b) Hashtbl.t))
   ;;
 end
 
 module Make_mutation_in_callbacks (Hashtbl : Hashtbl_for_testing) = struct
   let%test_module "mutation in callbacks" =
     (module (
-               struct
-                 module Test = struct
-                   exception Note of (string, Sexp.t) List.Assoc.t * exn [@@deriving sexp]
-
-                   let note str value sexp_of_value thunk =
-                     try thunk () with
-                     | Note (alist, exn) ->
-                       raise (Note ((str, sexp_of_value value) :: alist, exn))
-                     | exn -> raise (Note ([ str, sexp_of_value value ], exn))
-                   ;;
-
-                   let for_each str sexp_of_value values f =
-                     List.iter values ~f:(fun value ->
-                       note str value sexp_of_value (fun () -> f value))
-                   ;;
-
-                   let size = 16
-
-                   let key_funs =
-                     [ (fun i -> i); (fun i -> i + size); (fun i -> i * size) ]
-                   ;;
-
-                   let multi_funs =
-                     [ (fun _ -> []); (fun i -> [ i ]); (fun i -> List.init i ~f:Fn.id) ]
-                   ;;
-
-                   let sample_keys =
-                     List.concat_map key_funs ~f:(fun f -> [ f 1; f 2; f 3 ])
-                   ;;
-
-                   let sample_data = [ 100; 200; 300 ]
-                   let sexp_of_key = [%sexp_of: int]
-                   let sexp_of_data = [%sexp_of: int]
-
-                   let make_table ~key_of_index ~data_of_index =
-                     List.init size ~f:(fun i -> key_of_index i, data_of_index i)
-                     |> Hashtbl.of_alist_exn (module Int)
-                   ;;
-
-                   let makers =
-                     List.map key_funs ~f:(fun key_of_index ->
-                       let maker () = make_table ~key_of_index ~data_of_index:Fn.id in
-                       maker)
-                   ;;
-
-                   let multi_makers =
-                     List.concat_map key_funs ~f:(fun key_of_index ->
-                       List.concat_map multi_funs ~f:(fun data_of_index ->
-                         [ (fun () -> make_table ~key_of_index ~data_of_index) ]))
-                   ;;
-
-                   let sexp_of_maker make =
-                     make () |> Hashtbl.to_alist |> [%sexp_of: (int * int) list]
-                   ;;
-
-                   let sexp_of_multi_maker make =
-                     make () |> Hashtbl.to_alist |> [%sexp_of: (int * int list) list]
-                   ;;
-
-                   let bools = [ true; false ]
-
-                   let option values =
-                     None :: List.map values ~f:(fun value -> Some value)
-                   ;;
-
-                   let first_or_second values =
-                     List.concat_map values ~f:(fun value ->
-                       [ First value; Second value ])
-                   ;;
-
-                   let default_mutate t = Hashtbl.clear t
-
-                   let make_caller test_result =
-                     let caller t f = Hashtbl.map t ~f |> Hashtbl.to_alist in
-                     let callback x = x in
-                     caller, callback, test_result
-                   ;;
-
-                   let mono_caller () = make_caller [%test_result: (int * int) list]
-                   let multi_caller () = make_caller [%test_result: (int * int list) list]
-
-                   let inside_iter t f =
-                     with_return (fun r ->
-                       Hashtbl.iteri t ~f:(fun ~key:_ ~data:_ -> r.return (f ()));
-                       assert false)
-                   ;;
-
-                   type 'a test_result =
-                     ?here:Lexing.position list
-                     -> ?message:string
-                     -> ?equal:('a -> 'a -> bool)
-                     -> expect:'a
-                     -> 'a
-                     -> unit
-
-                   let mutation_after_callback_does_not_raise
-                     (type a)
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     let (_ : a test_result) = test_result in
-                     let t = make () in
-                     let (_ : a) = caller t callback in
-                     mutate t
-                   ;;
-
-                   let mutation_after_callback_inside_iter_does_not_raise
-                     (type a)
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     let (_ : a test_result) = test_result in
-                     let t = make () in
-                     let (_ : a Or_error.t) =
-                       Or_error.try_with (fun () ->
-                         inside_iter t (fun () -> caller t callback))
-                     in
-                     mutate t
-                   ;;
-
-                   let mutation_after_iter_inside_callback_does_not_raise
-                     (type a)
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     let (_ : a test_result) = test_result in
-                     let t = make () in
-                     let (_ : a Or_error.t) =
-                       Or_error.try_with (fun () ->
-                         caller t (fun x -> inside_iter t (fun () -> callback x)))
-                     in
-                     mutate t
-                   ;;
-
-                   let mutation_after_raising_callback_does_not_raise
-                     (type a)
-                     ~make
-                     ~caller
-                     ~callback:_
-                     ~mutate
-                     ~test_result
-                     =
-                     let (_ : a test_result) = test_result in
-                     let t = make () in
-                     let (_ : a Or_error.t) =
-                       Or_error.try_with (fun () -> caller t (fun _ -> assert false))
-                     in
-                     mutate t
-                   ;;
-
-                   let mutation_inside_callback_is_consistent
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     match
-                       let t = make () in
-                       Or_error.try_with (fun () ->
-                         caller t (fun x ->
-                           mutate t;
-                           callback x))
-                     with
-                     | Error _ -> ()
-                     | Ok actual ->
-                       let expect =
-                         let t = make () in
-                         caller t callback
-                       in
-                       test_result ?here:None ?message:None ?equal:None ~expect actual
-                   ;;
-
-                   let mutation_inside_callback_inside_iter_is_consistent
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     match
-                       let t = make () in
-                       Or_error.try_with (fun () ->
-                         inside_iter t (fun () ->
-                           caller t (fun x ->
-                             mutate t;
-                             callback x)))
-                     with
-                     | Error _ -> ()
-                     | Ok actual ->
-                       let expect =
-                         let t = make () in
-                         inside_iter t (fun () -> caller t callback)
-                       in
-                       test_result ?here:None ?message:None ?equal:None ~expect actual
-                   ;;
-
-                   let mutation_inside_iter_inside_callback_is_consistent
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     match
-                       let t = make () in
-                       Or_error.try_with (fun () ->
-                         caller t (fun x ->
-                           inside_iter t (fun () ->
-                             mutate t;
-                             callback x)))
-                     with
-                     | Error _ -> ()
-                     | Ok actual ->
-                       let expect =
-                         let t = make () in
-                         caller t (fun x -> inside_iter t (fun () -> callback x))
-                       in
-                       test_result ?here:None ?message:None ?equal:None ~expect actual
-                   ;;
-
-                   let mutation_inside_iter_after_callback_is_consistent
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     match
-                       let t = make () in
-                       Or_error.try_with (fun () ->
-                         inside_iter t (fun () ->
-                           let x = caller t callback in
-                           mutate t;
-                           x))
-                     with
-                     | Error _ -> ()
-                     | Ok actual ->
-                       let expect =
-                         let t = make () in
-                         inside_iter t (fun () -> caller t callback)
-                       in
-                       test_result ?here:None ?message:None ?equal:None ~expect actual
-                   ;;
-
-                   let mutation_inside_callback_after_iter_is_consistent
-                     ~make
-                     ~caller
-                     ~callback
-                     ~mutate
-                     ~test_result
-                     =
-                     match
-                       let t = make () in
-                       Or_error.try_with (fun () ->
-                         caller t (fun x ->
-                           inside_iter t (fun () -> ());
-                           mutate t;
-                           callback x))
-                     with
-                     | Error _ -> ()
-                     | Ok actual ->
-                       let expect =
-                         let t = make () in
-                         caller t (fun x ->
-                           inside_iter t (fun () -> ());
-                           callback x)
-                       in
-                       test_result ?here:None ?message:None ?equal:None ~expect actual
-                   ;;
-
-                   let test_cases =
-                     [ ( "mutation_inside_callback_is_consistent"
-                       , mutation_inside_callback_is_consistent )
-                     ; ( "mutation_after_callback_does_not_raise"
-                       , mutation_after_callback_does_not_raise )
-                     ; ( "mutation_after_raising_callback_does_not_raise"
-                       , mutation_after_raising_callback_does_not_raise )
-                     ; ( "mutation_inside_callback_inside_iter_is_consistent"
-                       , mutation_inside_callback_inside_iter_is_consistent )
-                     ; ( "mutation_inside_iter_inside_callback_is_consistent"
-                       , mutation_inside_iter_inside_callback_is_consistent )
-                     ; ( "mutation_inside_iter_after_callback_is_consistent"
-                       , mutation_inside_iter_after_callback_is_consistent )
-                     ; ( "mutation_inside_callback_after_iter_is_consistent"
-                       , mutation_inside_callback_after_iter_is_consistent )
-                     ; ( "mutation_after_callback_inside_iter_does_not_raise"
-                       , mutation_after_callback_inside_iter_does_not_raise )
-                     ; ( "mutation_after_iter_inside_callback_does_not_raise"
-                       , mutation_after_iter_inside_callback_does_not_raise )
-                     ]
-                   ;;
-
-                   let sexp_of_test_case (name, _) = Sexp.Atom name
-
-                   let test name ~make ~caller ~callback ~mutate ~test_result =
-                     for_each "test case" sexp_of_test_case test_cases (fun (_, f) ->
-                       note "test kind" name [%sexp_of: string] (fun () ->
-                         f ~make ~caller ~callback ~mutate ~test_result))
-                   ;;
-
-                   let test_mutate mutate =
-                     let caller, callback, test_result = mono_caller () in
-                     for_each "table to mutate" sexp_of_maker makers (fun make ->
-                       test "mutator" ~make ~caller ~callback ~mutate ~test_result)
-                   ;;
-
-                   let test_mutate_multi mutate =
-                     let caller, callback, test_result = multi_caller () in
-                     for_each
-                       "table to mutate"
-                       sexp_of_multi_maker
-                       multi_makers
-                       (fun make ->
-                       test "mutator" ~make ~caller ~callback ~mutate ~test_result)
-                   ;;
-
-                   let test_caller ~callback ~test_result caller =
-                     let mutate = default_mutate in
-                     for_each "table to mutate" sexp_of_maker makers (fun make ->
-                       test "caller" ~make ~caller ~callback ~mutate ~test_result)
-                   ;;
-
-                   let test_mutate_2ts mutate =
-                     for_each "table not mutated" sexp_of_maker makers (fun make ->
-                       test_mutate (fun t1 ->
-                         let t2 = make () in
-                         mutate t1 t2);
-                       test_mutate (fun t2 ->
-                         let t1 = make () in
-                         mutate t1 t2))
-                   ;;
-
-                   let test_caller_2ts ~callback ~test_result caller =
-                     for_each "table not mutated" sexp_of_maker makers (fun make ->
-                       test_caller ~callback ~test_result (fun t1 f ->
-                         caller t1 (make ()) f);
-                       test_caller ~callback ~test_result (fun t2 f ->
-                         caller (make ()) t2 f))
-                   ;;
-
-                   let test_caller_2fs f1 f2 ~test_result caller =
-                     test_caller ~callback:f1 ~test_result (fun t f1 -> caller t f1 f2);
-                     test_caller ~callback:f2 ~test_result (fun t f2 -> caller t f1 f2)
-                   ;;
-
-                   type ('a, 'b) merge_data =
-                     [ `Left of 'a
-                     | `Right of 'b
-                     | `Both of 'a * 'b
-                     ]
-                   [@@deriving sexp, compare]
-                 end
-
-                 open Test
-
-                 (* functions that both mutate and accept callbacks *)
-
-                 let find_or_add = Hashtbl.find_or_add
-                 let findi_or_add = Hashtbl.findi_or_add
-
-                 let%test_unit "find_or_add" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each "data" sexp_of_data sample_data (fun data ->
-                       test_mutate (fun t ->
-                         Hashtbl.find_or_add t key ~default:(fun () -> data)
-                         |> (ignore : int -> unit));
-                       let callback () = data in
-                       let test_result = [%test_result: int] in
-                       test_caller ~callback ~test_result (fun t f ->
-                         Hashtbl.find_or_add t key ~default:f)))
-                 ;;
-
-                 let change = Hashtbl.change
-                 let update = Hashtbl.update
-                 let update_and_return = Hashtbl.update_and_return
-
-                 let%test_unit "change" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each
-                       "f result"
-                       [%sexp_of: data option]
-                       (option sample_data)
-                       (fun opt ->
-                       test_mutate (fun t -> Hashtbl.change t key ~f:(fun _ -> opt));
-                       let callback _ = opt in
-                       let test_result = [%test_result: int option] in
-                       test_caller ~callback ~test_result (fun t f ->
-                         Hashtbl.change t key ~f;
-                         Hashtbl.find t key)))
-                 ;;
-
-                 let%test_unit "update" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each "f result" [%sexp_of: data] sample_data (fun data ->
-                       test_mutate (fun t -> Hashtbl.update t key ~f:(fun _ -> data));
-                       let callback _ = data in
-                       let test_result = [%test_result: int option] in
-                       test_caller ~callback ~test_result (fun t f ->
-                         Hashtbl.update t key ~f;
-                         Hashtbl.find t key)))
-                 ;;
-
-                 let%test_unit "update_and_return" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each "f result" [%sexp_of: data] sample_data (fun data ->
-                       test_mutate (fun t ->
-                         ignore (Hashtbl.update_and_return t key ~f:(fun _ -> data) : _));
-                       let callback _ = data in
-                       let test_result = [%test_result: int option] in
-                       test_caller ~callback ~test_result (fun t f ->
-                         Some (Hashtbl.update_and_return t key ~f))))
-                 ;;
-
-                 let merge_into = Hashtbl.merge_into
-
-                 let%test_unit "merge_into" =
-                   for_each
-                     "f result"
-                     [%sexp_of: data option]
-                     (option sample_data)
-                     (fun opt ->
-                     let action : _ Hashtbl_intf.Merge_into_action.t =
-                       match opt with
-                       | None -> Remove
-                       | Some x -> Set_to x
-                     in
-                     test_mutate_2ts (fun dst src ->
-                       Hashtbl.merge_into ~dst ~src ~f:(fun ~key:_ _ _ -> action));
-                     let callback _ = action in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller_2ts ~callback ~test_result (fun src dst f ->
-                       Hashtbl.merge_into ~dst ~src ~f:(fun ~key a b -> f (key, a, b));
-                       Hashtbl.to_alist dst))
-                 ;;
-
-                 let filter_inplace = Hashtbl.filter_inplace
-
-                 let%test_unit "filter_inplace" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     test_mutate (fun t -> Hashtbl.filter_inplace t ~f:(fun _ -> bool));
-                     let callback _ = bool in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_inplace t ~f;
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 let filteri_inplace = Hashtbl.filteri_inplace
-
-                 let%test_unit "filteri_inplace" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     test_mutate (fun t ->
-                       Hashtbl.filteri_inplace t ~f:(fun ~key:_ ~data:_ -> bool));
-                     let callback _ = bool in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filteri_inplace t ~f:(fun ~key ~data -> f (key, data));
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 let filter_keys_inplace = Hashtbl.filter_keys_inplace
-
-                 let%test_unit "filter_keys_inplace" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     test_mutate (fun t ->
-                       Hashtbl.filter_keys_inplace t ~f:(fun _ -> bool));
-                     let callback _ = bool in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_keys_inplace t ~f;
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 let map_inplace = Hashtbl.map_inplace
-
-                 let%test_unit "map_inplace" =
-                   for_each "f result" [%sexp_of: int] sample_data (fun data ->
-                     test_mutate (fun t -> Hashtbl.map_inplace t ~f:(fun _ -> data));
-                     let callback _ = data in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.map_inplace t ~f;
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 let mapi_inplace = Hashtbl.mapi_inplace
-
-                 let%test_unit "mapi_inplace" =
-                   for_each "f result" [%sexp_of: int] sample_data (fun data ->
-                     test_mutate (fun t ->
-                       Hashtbl.mapi_inplace t ~f:(fun ~key:_ ~data:_ -> data));
-                     let callback _ = data in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.mapi_inplace t ~f:(fun ~key ~data -> f (key, data));
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 let filter_map_inplace = Hashtbl.filter_map_inplace
-
-                 let%test_unit "filter_map_inplace" =
-                   for_each
-                     "f result"
-                     [%sexp_of: int option]
-                     (option sample_data)
-                     (fun opt ->
-                     test_mutate (fun t -> Hashtbl.filter_map_inplace t ~f:(fun _ -> opt));
-                     let callback _ = opt in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_map_inplace t ~f;
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 let filter_mapi_inplace = Hashtbl.filter_mapi_inplace
-
-                 let%test_unit "filter_mapi_inplace" =
-                   for_each
-                     "f result"
-                     [%sexp_of: int option]
-                     (option sample_data)
-                     (fun opt ->
-                     test_mutate (fun t ->
-                       Hashtbl.filter_mapi_inplace t ~f:(fun ~key:_ ~data:_ -> opt));
-                     let callback _ = opt in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_mapi_inplace t ~f:(fun ~key ~data -> f (key, data));
-                       Hashtbl.to_alist t))
-                 ;;
-
-                 (* functions that mutate *)
-
-                 let set = Hashtbl.set
-
-                 let%test_unit "set" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each "data" sexp_of_data sample_data (fun data ->
-                       test_mutate (fun t -> Hashtbl.set t ~key ~data)))
-                 ;;
-
-                 let add = Hashtbl.add
-                 let add_exn = Hashtbl.add_exn
-
-                 let%test_unit "add" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each "data" sexp_of_data sample_data (fun data ->
-                       test_mutate (fun t ->
-                         Hashtbl.add t ~key ~data
-                         |> (ignore : [ `Ok | `Duplicate ] -> unit))))
-                 ;;
-
-                 let remove = Hashtbl.remove
-
-                 let%test_unit "remove" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     test_mutate (fun t -> Hashtbl.remove t key))
-                 ;;
-
-                 let find_and_remove = Hashtbl.find_and_remove
-
-                 let%test_unit "find_and_remove" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     test_mutate (fun t ->
-                       Hashtbl.find_and_remove t key |> (ignore : int option -> unit)))
-                 ;;
-
-                 let incr = Hashtbl.incr
-
-                 let%test_unit "incr" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     test_mutate (fun t -> Hashtbl.incr t key))
-                 ;;
-
-                 let decr = Hashtbl.decr
-
-                 let%test_unit "decr" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     test_mutate (fun t -> Hashtbl.decr t key))
-                 ;;
-
-                 let add_multi = Hashtbl.add_multi
-
-                 let%test_unit "add_multi" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     for_each "data" sexp_of_data sample_data (fun data ->
-                       test_mutate_multi (fun t -> Hashtbl.add_multi t ~key ~data)))
-                 ;;
-
-                 let remove_multi = Hashtbl.remove_multi
-
-                 let%test_unit "remove_multi" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     test_mutate_multi (fun t -> Hashtbl.remove_multi t key))
-                 ;;
-
-                 let clear = Hashtbl.clear
-                 let%test_unit "clear" = test_mutate (fun t -> Hashtbl.clear t)
-
-                 (* functions that take callbacks *)
-
-                 let find_and_call = Hashtbl.find_and_call
-                 let findi_and_call = Hashtbl.findi_and_call
-                 let find_and_call1 = Hashtbl.find_and_call1
-                 let findi_and_call1 = Hashtbl.findi_and_call1
-                 let find_and_call2 = Hashtbl.find_and_call2
-                 let findi_and_call2 = Hashtbl.findi_and_call2
-
-                 let%test_unit "find_and_call" =
-                   for_each "key" sexp_of_key sample_keys (fun key ->
-                     let found x = `Found x in
-                     let not_found x = `Not_found x in
-                     let test_result =
-                       [%test_result: [ `Found of int | `Not_found of int ]]
-                     in
-                     test_caller_2fs
-                       found
-                       not_found
-                       ~test_result
-                       (fun t if_found if_not_found ->
-                       Hashtbl.find_and_call t key ~if_found ~if_not_found))
-                 ;;
-
-                 let fold = Hashtbl.fold
-
-                 let%test_unit "fold" =
-                   let callback (a, b, c) = (a, b) :: c in
-                   let test_result = [%test_result: (int * int) list] in
-                   test_caller ~callback ~test_result (fun t f ->
-                     Hashtbl.fold t ~init:[] ~f:(fun ~key ~data acc -> f (key, data, acc)))
-                 ;;
-
-                 let iter = Hashtbl.iter
-
-                 let%test_unit "iter" =
-                   let callback a = a in
-                   let test_result = [%test_result: int Queue.t] in
-                   test_caller ~callback ~test_result (fun t f ->
-                     let queue = Queue.create () in
-                     Hashtbl.iter t ~f:(fun data -> Queue.enqueue queue (f data));
-                     queue)
-                 ;;
-
-                 let iter_keys = Hashtbl.iter_keys
-
-                 let%test_unit "iter_keys" =
-                   let callback a = a in
-                   let test_result = [%test_result: int Queue.t] in
-                   test_caller ~callback ~test_result (fun t f ->
-                     let queue = Queue.create () in
-                     Hashtbl.iter_keys t ~f:(fun key -> Queue.enqueue queue (f key));
-                     queue)
-                 ;;
-
-                 let iteri = Hashtbl.iteri
-
-                 let%test_unit "iteri" =
-                   let callback (a, b) = a, b in
-                   let test_result = [%test_result: (int * int) Queue.t] in
-                   test_caller ~callback ~test_result (fun t f ->
-                     let queue = Queue.create () in
-                     Hashtbl.iteri t ~f:(fun ~key ~data ->
-                       Queue.enqueue queue (f (key, data)));
-                     queue)
-                 ;;
-
-                 let map = Hashtbl.map
-
-                 let%test_unit "map" =
-                   let callback a = a in
-                   let test_result = [%test_result: (int * int) list] in
-                   test_caller ~callback ~test_result (fun t f ->
-                     Hashtbl.map t ~f |> Hashtbl.to_alist)
-                 ;;
-
-                 let mapi = Hashtbl.mapi
-
-                 let%test_unit "mapi" =
-                   let callback (a, b) = a, b in
-                   let test_result = [%test_result: (int * (int * int)) list] in
-                   test_caller ~callback ~test_result (fun t f ->
-                     Hashtbl.mapi t ~f:(fun ~key ~data -> f (key, data))
-                     |> Hashtbl.to_alist)
-                 ;;
-
-                 let filter_keys = Hashtbl.filter_keys
-
-                 let%test_unit "filter_keys" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_keys t ~f |> Hashtbl.to_alist))
-                 ;;
-
-                 let filter = Hashtbl.filter
-
-                 let%test_unit "filter" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter t ~f |> Hashtbl.to_alist))
-                 ;;
-
-                 let filteri = Hashtbl.filteri
-
-                 let%test_unit "filteri" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filteri t ~f:(fun ~key ~data -> f (key, data))
-                       |> Hashtbl.to_alist))
-                 ;;
-
-                 let filter_map = Hashtbl.filter_map
-
-                 let%test_unit "filter_map" =
-                   for_each
-                     "f result"
-                     [%sexp_of: data option]
-                     (option sample_data)
-                     (fun opt ->
-                     let callback _ = opt in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_map t ~f |> Hashtbl.to_alist))
-                 ;;
-
-                 let filter_mapi = Hashtbl.filter_mapi
-
-                 let%test_unit "filter_mapi" =
-                   for_each
-                     "f result"
-                     [%sexp_of: data option]
-                     (option sample_data)
-                     (fun opt ->
-                     let callback _ = opt in
-                     let test_result = [%test_result: (int * int) list] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.filter_mapi t ~f:(fun ~key ~data -> f (key, data))
-                       |> Hashtbl.to_alist))
-                 ;;
-
-                 let partition_tf = Hashtbl.partition_tf
-
-                 let%test_unit "partition_tf" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result =
-                       [%test_result: (int * int) list * (int * int) list]
-                     in
-                     test_caller ~callback ~test_result (fun t f ->
-                       let t1, t2 = Hashtbl.partition_tf t ~f in
-                       Hashtbl.to_alist t1, Hashtbl.to_alist t2))
-                 ;;
-
-                 let partitioni_tf = Hashtbl.partitioni_tf
-
-                 let%test_unit "partitioni_tf" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result =
-                       [%test_result: (int * int) list * (int * int) list]
-                     in
-                     test_caller ~callback ~test_result (fun t f ->
-                       let t1, t2 =
-                         Hashtbl.partitioni_tf t ~f:(fun ~key ~data -> f (key, data))
-                       in
-                       Hashtbl.to_alist t1, Hashtbl.to_alist t2))
-                 ;;
-
-                 let partition_map = Hashtbl.partition_map
-
-                 let%test_unit "partition_map" =
-                   for_each
-                     "f result"
-                     [%sexp_of: (data, data) Either.t]
-                     (first_or_second sample_data)
-                     (fun x ->
-                     let callback _ = x in
-                     let test_result =
-                       [%test_result: (int * int) list * (int * int) list]
-                     in
-                     test_caller ~callback ~test_result (fun t f ->
-                       let t1, t2 = Hashtbl.partition_map t ~f in
-                       Hashtbl.to_alist t1, Hashtbl.to_alist t2))
-                 ;;
-
-                 let partition_mapi = Hashtbl.partition_mapi
-
-                 let%test_unit "partition_mapi" =
-                   for_each
-                     "f result"
-                     [%sexp_of: (data, data) Either.t]
-                     (first_or_second sample_data)
-                     (fun x ->
-                     let callback _ = x in
-                     let test_result =
-                       [%test_result: (int * int) list * (int * int) list]
-                     in
-                     test_caller ~callback ~test_result (fun t f ->
-                       let t1, t2 =
-                         Hashtbl.partition_mapi t ~f:(fun ~key ~data -> f (key, data))
-                       in
-                       Hashtbl.to_alist t1, Hashtbl.to_alist t2))
-                 ;;
-
-                 let existsi = Hashtbl.existsi
-
-                 let%test_unit "existsi" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: bool] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.existsi t ~f:(fun ~key ~data -> f (key, data))))
-                 ;;
-
-                 let exists = Hashtbl.exists
-
-                 let%test_unit "exists" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: bool] in
-                     test_caller ~callback ~test_result (fun t f -> Hashtbl.exists t ~f))
-                 ;;
-
-                 let for_alli = Hashtbl.for_alli
-
-                 let%test_unit "for_alli" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: bool] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.for_alli t ~f:(fun ~key ~data -> f (key, data))))
-                 ;;
-
-                 let for_all = Hashtbl.for_all
-
-                 let%test_unit "for_all" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: bool] in
-                     test_caller ~callback ~test_result (fun t f -> Hashtbl.for_all t ~f))
-                 ;;
-
-                 let count = Hashtbl.count
-
-                 let%test_unit "count" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: int] in
-                     test_caller ~callback ~test_result (fun t f -> Hashtbl.count t ~f))
-                 ;;
-
-                 let counti = Hashtbl.counti
-
-                 let%test_unit "counti" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: int] in
-                     test_caller ~callback ~test_result (fun t f ->
-                       Hashtbl.counti t ~f:(fun ~key ~data -> f (key, data))))
-                 ;;
-
-                 let merge = Hashtbl.merge
-
-                 let%test_unit "merge" =
-                   let callback (key, data) = Some (key, data) in
-                   let test_result =
-                     [%test_result: (int * (int * (int, int) merge_data)) list]
-                   in
-                   test_caller_2ts ~callback ~test_result (fun t1 t2 f ->
-                     Hashtbl.merge t1 t2 ~f:(fun ~key data -> f (key, data))
-                     |> Hashtbl.to_alist)
-                 ;;
-
-                 let equal = Hashtbl.equal
-                 let similar = Hashtbl.similar
-
-                 let%test_unit "equal" =
-                   for_each "f result" [%sexp_of: bool] bools (fun bool ->
-                     let callback _ = bool in
-                     let test_result = [%test_result: bool] in
-                     test_caller_2ts ~callback ~test_result (fun t1 t2 f ->
-                       Hashtbl.equal (fun a b -> f (a, b)) t1 t2))
-                 ;;
-
-                 let sexp_of_t = Hashtbl.sexp_of_t
-
-                 let%test_unit "sexp_of_t" =
-                   let test_result = [%test_result: Sexp.t] in
-                   test_caller_2fs
-                     [%sexp_of: int]
-                     [%sexp_of: int]
-                     ~test_result
-                     (fun t sexp_of_key sexp_of_data ->
-                     Hashtbl.sexp_of_t sexp_of_key sexp_of_data t)
-                 ;;
-
-                 let invariant = Hashtbl.invariant
-
-                 let%test_unit "invariant" =
-                   let test_result = [%test_result: int Queue.t * int Queue.t] in
-                   test_caller_2fs ignore ignore ~test_result (fun t f_key f_data ->
-                     let keys = Queue.create () in
-                     let data = Queue.create () in
-                     Hashtbl.invariant
-                       (fun k ->
-                         Queue.enqueue keys k;
-                         f_key k)
-                       (fun d ->
-                         Queue.enqueue data d;
-                         f_data d)
-                       t;
-                     keys, data)
-                 ;;
+    struct
+      module Test = struct
+        exception Note of (string, Sexp.t) List.Assoc.t * exn [@@deriving sexp]
+
+        let note str value sexp_of_value thunk =
+          try thunk () with
+          | Note (alist, exn) -> raise (Note ((str, sexp_of_value value) :: alist, exn))
+          | exn -> raise (Note ([ str, sexp_of_value value ], exn))
+        ;;
+
+        let for_each str sexp_of_value values f =
+          List.iter values ~f:(fun value ->
+            note str value sexp_of_value (fun () -> f value))
+        ;;
+
+        let size = 16
+        let key_funs = [ (fun i -> i); (fun i -> i + size); (fun i -> i * size) ]
+
+        let multi_funs =
+          [ (fun _ -> []); (fun i -> [ i ]); (fun i -> List.init i ~f:Fn.id) ]
+        ;;
+
+        let sample_keys = List.concat_map key_funs ~f:(fun f -> [ f 1; f 2; f 3 ])
+        let sample_data = [ 100; 200; 300 ]
+        let sexp_of_key = [%sexp_of: int]
+        let sexp_of_data = [%sexp_of: int]
+
+        let make_table ~key_of_index ~data_of_index =
+          List.init size ~f:(fun i -> key_of_index i, data_of_index i)
+          |> Hashtbl.of_alist_exn (module Int)
+        ;;
+
+        let makers =
+          List.map key_funs ~f:(fun key_of_index ->
+            let maker () = make_table ~key_of_index ~data_of_index:Fn.id in
+            maker)
+        ;;
+
+        let multi_makers =
+          List.concat_map key_funs ~f:(fun key_of_index ->
+            List.concat_map multi_funs ~f:(fun data_of_index ->
+              [ (fun () -> make_table ~key_of_index ~data_of_index) ]))
+        ;;
+
+        let sexp_of_maker make =
+          make () |> Hashtbl.to_alist |> [%sexp_of: (int * int) list]
+        ;;
+
+        let sexp_of_multi_maker make =
+          make () |> Hashtbl.to_alist |> [%sexp_of: (int * int list) list]
+        ;;
+
+        let bools = [ true; false ]
+        let option values = None :: List.map values ~f:(fun value -> Some value)
+
+        let first_or_second values =
+          List.concat_map values ~f:(fun value -> [ First value; Second value ])
+        ;;
+
+        let default_mutate t = Hashtbl.clear t
+
+        let make_caller test_result =
+          let caller t f = Hashtbl.map t ~f |> Hashtbl.to_alist in
+          let callback x = x in
+          caller, callback, test_result
+        ;;
+
+        let mono_caller () = make_caller [%test_result: (int * int) list]
+        let multi_caller () = make_caller [%test_result: (int * int list) list]
+
+        let inside_iter t f =
+          with_return (fun r ->
+            Hashtbl.iteri t ~f:(fun ~key:_ ~data:_ -> r.return (f ()));
+            assert false)
+        ;;
+
+        type 'a test_result =
+          ?here:Lexing.position list
+          -> ?message:string
+          -> ?equal:('a -> 'a -> bool)
+          -> expect:'a
+          -> 'a
+          -> unit
+
+        let mutation_after_callback_does_not_raise
+          (type a)
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          let (_ : a test_result) = test_result in
+          let t = make () in
+          let (_ : a) = caller t callback in
+          mutate t
+        ;;
+
+        let mutation_after_callback_inside_iter_does_not_raise
+          (type a)
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          let (_ : a test_result) = test_result in
+          let t = make () in
+          let (_ : a Or_error.t) =
+            Or_error.try_with (fun () -> inside_iter t (fun () -> caller t callback))
+          in
+          mutate t
+        ;;
+
+        let mutation_after_iter_inside_callback_does_not_raise
+          (type a)
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          let (_ : a test_result) = test_result in
+          let t = make () in
+          let (_ : a Or_error.t) =
+            Or_error.try_with (fun () ->
+              caller t (fun x -> inside_iter t (fun () -> callback x)))
+          in
+          mutate t
+        ;;
+
+        let mutation_after_raising_callback_does_not_raise
+          (type a)
+          ~make
+          ~caller
+          ~callback:_
+          ~mutate
+          ~test_result
+          =
+          let (_ : a test_result) = test_result in
+          let t = make () in
+          let (_ : a Or_error.t) =
+            Or_error.try_with (fun () -> caller t (fun _ -> assert false))
+          in
+          mutate t
+        ;;
+
+        let mutation_inside_callback_is_consistent
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          match
+            let t = make () in
+            Or_error.try_with (fun () ->
+              caller t (fun x ->
+                mutate t;
+                callback x))
+          with
+          | Error _ -> ()
+          | Ok actual ->
+            let expect =
+              let t = make () in
+              caller t callback
+            in
+            test_result ?here:None ?message:None ?equal:None ~expect actual
+        ;;
+
+        let mutation_inside_callback_inside_iter_is_consistent
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          match
+            let t = make () in
+            Or_error.try_with (fun () ->
+              inside_iter t (fun () ->
+                caller t (fun x ->
+                  mutate t;
+                  callback x)))
+          with
+          | Error _ -> ()
+          | Ok actual ->
+            let expect =
+              let t = make () in
+              inside_iter t (fun () -> caller t callback)
+            in
+            test_result ?here:None ?message:None ?equal:None ~expect actual
+        ;;
+
+        let mutation_inside_iter_inside_callback_is_consistent
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          match
+            let t = make () in
+            Or_error.try_with (fun () ->
+              caller t (fun x ->
+                inside_iter t (fun () ->
+                  mutate t;
+                  callback x)))
+          with
+          | Error _ -> ()
+          | Ok actual ->
+            let expect =
+              let t = make () in
+              caller t (fun x -> inside_iter t (fun () -> callback x))
+            in
+            test_result ?here:None ?message:None ?equal:None ~expect actual
+        ;;
+
+        let mutation_inside_iter_after_callback_is_consistent
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          match
+            let t = make () in
+            Or_error.try_with (fun () ->
+              inside_iter t (fun () ->
+                let x = caller t callback in
+                mutate t;
+                x))
+          with
+          | Error _ -> ()
+          | Ok actual ->
+            let expect =
+              let t = make () in
+              inside_iter t (fun () -> caller t callback)
+            in
+            test_result ?here:None ?message:None ?equal:None ~expect actual
+        ;;
+
+        let mutation_inside_callback_after_iter_is_consistent
+          ~make
+          ~caller
+          ~callback
+          ~mutate
+          ~test_result
+          =
+          match
+            let t = make () in
+            Or_error.try_with (fun () ->
+              caller t (fun x ->
+                inside_iter t (fun () -> ());
+                mutate t;
+                callback x))
+          with
+          | Error _ -> ()
+          | Ok actual ->
+            let expect =
+              let t = make () in
+              caller t (fun x ->
+                inside_iter t (fun () -> ());
+                callback x)
+            in
+            test_result ?here:None ?message:None ?equal:None ~expect actual
+        ;;
+
+        let test_cases =
+          [ ( "mutation_inside_callback_is_consistent"
+            , mutation_inside_callback_is_consistent )
+          ; ( "mutation_after_callback_does_not_raise"
+            , mutation_after_callback_does_not_raise )
+          ; ( "mutation_after_raising_callback_does_not_raise"
+            , mutation_after_raising_callback_does_not_raise )
+          ; ( "mutation_inside_callback_inside_iter_is_consistent"
+            , mutation_inside_callback_inside_iter_is_consistent )
+          ; ( "mutation_inside_iter_inside_callback_is_consistent"
+            , mutation_inside_iter_inside_callback_is_consistent )
+          ; ( "mutation_inside_iter_after_callback_is_consistent"
+            , mutation_inside_iter_after_callback_is_consistent )
+          ; ( "mutation_inside_callback_after_iter_is_consistent"
+            , mutation_inside_callback_after_iter_is_consistent )
+          ; ( "mutation_after_callback_inside_iter_does_not_raise"
+            , mutation_after_callback_inside_iter_does_not_raise )
+          ; ( "mutation_after_iter_inside_callback_does_not_raise"
+            , mutation_after_iter_inside_callback_does_not_raise )
+          ]
+        ;;
+
+        let sexp_of_test_case (name, _) = Sexp.Atom name
+
+        let test name ~make ~caller ~callback ~mutate ~test_result =
+          for_each "test case" sexp_of_test_case test_cases (fun (_, f) ->
+            note "test kind" name [%sexp_of: string] (fun () ->
+              f ~make ~caller ~callback ~mutate ~test_result))
+        ;;
+
+        let test_mutate mutate =
+          let caller, callback, test_result = mono_caller () in
+          for_each "table to mutate" sexp_of_maker makers (fun make ->
+            test "mutator" ~make ~caller ~callback ~mutate ~test_result)
+        ;;
+
+        let test_mutate_multi mutate =
+          let caller, callback, test_result = multi_caller () in
+          for_each "table to mutate" sexp_of_multi_maker multi_makers (fun make ->
+            test "mutator" ~make ~caller ~callback ~mutate ~test_result)
+        ;;
+
+        let test_caller ~callback ~test_result caller =
+          let mutate = default_mutate in
+          for_each "table to mutate" sexp_of_maker makers (fun make ->
+            test "caller" ~make ~caller ~callback ~mutate ~test_result)
+        ;;
+
+        let test_mutate_2ts mutate =
+          for_each "table not mutated" sexp_of_maker makers (fun make ->
+            test_mutate (fun t1 ->
+              let t2 = make () in
+              mutate t1 t2);
+            test_mutate (fun t2 ->
+              let t1 = make () in
+              mutate t1 t2))
+        ;;
+
+        let test_caller_2ts ~callback ~test_result caller =
+          for_each "table not mutated" sexp_of_maker makers (fun make ->
+            test_caller ~callback ~test_result (fun t1 f -> caller t1 (make ()) f);
+            test_caller ~callback ~test_result (fun t2 f -> caller (make ()) t2 f))
+        ;;
+
+        let test_caller_2fs f1 f2 ~test_result caller =
+          test_caller ~callback:f1 ~test_result (fun t f1 -> caller t f1 f2);
+          test_caller ~callback:f2 ~test_result (fun t f2 -> caller t f1 f2)
+        ;;
+
+        type ('a, 'b) merge_data =
+          [ `Left of 'a
+          | `Right of 'b
+          | `Both of 'a * 'b
+          ]
+        [@@deriving sexp, compare]
+      end
+
+      open Test
+
+      (* functions that both mutate and accept callbacks *)
+
+      let find_or_add = Hashtbl.find_or_add
+      let findi_or_add = Hashtbl.findi_or_add
+
+      let%test_unit "find_or_add" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "data" sexp_of_data sample_data (fun data ->
+            test_mutate (fun t ->
+              Hashtbl.find_or_add t key ~default:(fun () -> data)
+              |> (ignore : int -> unit));
+            let callback () = data in
+            let test_result = [%test_result: int] in
+            test_caller ~callback ~test_result (fun t f ->
+              Hashtbl.find_or_add t key ~default:f)))
+      ;;
+
+      let change = Hashtbl.change
+      let update = Hashtbl.update
+      let update_and_return = Hashtbl.update_and_return
+
+      let%test_unit "change" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "f result" [%sexp_of: data option] (option sample_data) (fun opt ->
+            test_mutate (fun t -> Hashtbl.change t key ~f:(fun _ -> opt));
+            let callback _ = opt in
+            let test_result = [%test_result: int option] in
+            test_caller ~callback ~test_result (fun t f ->
+              Hashtbl.change t key ~f;
+              Hashtbl.find t key)))
+      ;;
+
+      let%test_unit "update" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "f result" [%sexp_of: data] sample_data (fun data ->
+            test_mutate (fun t -> Hashtbl.update t key ~f:(fun _ -> data));
+            let callback _ = data in
+            let test_result = [%test_result: int option] in
+            test_caller ~callback ~test_result (fun t f ->
+              Hashtbl.update t key ~f;
+              Hashtbl.find t key)))
+      ;;
+
+      let%test_unit "update_and_return" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "f result" [%sexp_of: data] sample_data (fun data ->
+            test_mutate (fun t ->
+              ignore (Hashtbl.update_and_return t key ~f:(fun _ -> data) : _));
+            let callback _ = data in
+            let test_result = [%test_result: int option] in
+            test_caller ~callback ~test_result (fun t f ->
+              Some (Hashtbl.update_and_return t key ~f))))
+      ;;
+
+      let merge_into = Hashtbl.merge_into
+
+      let%test_unit "merge_into" =
+        for_each "f result" [%sexp_of: data option] (option sample_data) (fun opt ->
+          let action : _ Hashtbl_intf.Merge_into_action.t =
+            match opt with
+            | None -> Remove
+            | Some x -> Set_to x
+          in
+          test_mutate_2ts (fun dst src ->
+            Hashtbl.merge_into ~dst ~src ~f:(fun ~key:_ _ _ -> action));
+          let callback _ = action in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller_2ts ~callback ~test_result (fun src dst f ->
+            Hashtbl.merge_into ~dst ~src ~f:(fun ~key a b -> f (key, a, b));
+            Hashtbl.to_alist dst))
+      ;;
+
+      let filter_inplace = Hashtbl.filter_inplace
+
+      let%test_unit "filter_inplace" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          test_mutate (fun t -> Hashtbl.filter_inplace t ~f:(fun _ -> bool));
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_inplace t ~f;
+            Hashtbl.to_alist t))
+      ;;
+
+      let filteri_inplace = Hashtbl.filteri_inplace
+
+      let%test_unit "filteri_inplace" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          test_mutate (fun t -> Hashtbl.filteri_inplace t ~f:(fun ~key:_ ~data:_ -> bool));
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filteri_inplace t ~f:(fun ~key ~data -> f (key, data));
+            Hashtbl.to_alist t))
+      ;;
+
+      let filter_keys_inplace = Hashtbl.filter_keys_inplace
+
+      let%test_unit "filter_keys_inplace" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          test_mutate (fun t -> Hashtbl.filter_keys_inplace t ~f:(fun _ -> bool));
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_keys_inplace t ~f;
+            Hashtbl.to_alist t))
+      ;;
+
+      let map_inplace = Hashtbl.map_inplace
+
+      let%test_unit "map_inplace" =
+        for_each "f result" [%sexp_of: int] sample_data (fun data ->
+          test_mutate (fun t -> Hashtbl.map_inplace t ~f:(fun _ -> data));
+          let callback _ = data in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.map_inplace t ~f;
+            Hashtbl.to_alist t))
+      ;;
+
+      let mapi_inplace = Hashtbl.mapi_inplace
+
+      let%test_unit "mapi_inplace" =
+        for_each "f result" [%sexp_of: int] sample_data (fun data ->
+          test_mutate (fun t -> Hashtbl.mapi_inplace t ~f:(fun ~key:_ ~data:_ -> data));
+          let callback _ = data in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.mapi_inplace t ~f:(fun ~key ~data -> f (key, data));
+            Hashtbl.to_alist t))
+      ;;
+
+      let filter_map_inplace = Hashtbl.filter_map_inplace
+
+      let%test_unit "filter_map_inplace" =
+        for_each "f result" [%sexp_of: int option] (option sample_data) (fun opt ->
+          test_mutate (fun t -> Hashtbl.filter_map_inplace t ~f:(fun _ -> opt));
+          let callback _ = opt in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_map_inplace t ~f;
+            Hashtbl.to_alist t))
+      ;;
+
+      let filter_mapi_inplace = Hashtbl.filter_mapi_inplace
+
+      let%test_unit "filter_mapi_inplace" =
+        for_each "f result" [%sexp_of: int option] (option sample_data) (fun opt ->
+          test_mutate (fun t ->
+            Hashtbl.filter_mapi_inplace t ~f:(fun ~key:_ ~data:_ -> opt));
+          let callback _ = opt in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_mapi_inplace t ~f:(fun ~key ~data -> f (key, data));
+            Hashtbl.to_alist t))
+      ;;
+
+      (* functions that mutate *)
+
+      let set = Hashtbl.set
+
+      let%test_unit "set" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "data" sexp_of_data sample_data (fun data ->
+            test_mutate (fun t -> Hashtbl.set t ~key ~data)))
+      ;;
+
+      let add = Hashtbl.add
+      let add_exn = Hashtbl.add_exn
+
+      let%test_unit "add" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "data" sexp_of_data sample_data (fun data ->
+            test_mutate (fun t ->
+              Hashtbl.add t ~key ~data |> (ignore : [ `Ok | `Duplicate ] -> unit))))
+      ;;
+
+      let remove = Hashtbl.remove
+
+      let%test_unit "remove" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          test_mutate (fun t -> Hashtbl.remove t key))
+      ;;
+
+      let find_and_remove = Hashtbl.find_and_remove
+
+      let%test_unit "find_and_remove" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          test_mutate (fun t ->
+            Hashtbl.find_and_remove t key |> (ignore : int option -> unit)))
+      ;;
+
+      let incr = Hashtbl.incr
+
+      let%test_unit "incr" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          test_mutate (fun t -> Hashtbl.incr t key))
+      ;;
+
+      let decr = Hashtbl.decr
+
+      let%test_unit "decr" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          test_mutate (fun t -> Hashtbl.decr t key))
+      ;;
+
+      let add_multi = Hashtbl.add_multi
+
+      let%test_unit "add_multi" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          for_each "data" sexp_of_data sample_data (fun data ->
+            test_mutate_multi (fun t -> Hashtbl.add_multi t ~key ~data)))
+      ;;
+
+      let remove_multi = Hashtbl.remove_multi
+
+      let%test_unit "remove_multi" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          test_mutate_multi (fun t -> Hashtbl.remove_multi t key))
+      ;;
+
+      let clear = Hashtbl.clear
+      let%test_unit "clear" = test_mutate (fun t -> Hashtbl.clear t)
+
+      (* functions that take callbacks *)
+
+      let find_and_call = Hashtbl.find_and_call
+      let findi_and_call = Hashtbl.findi_and_call
+      let find_and_call1 = Hashtbl.find_and_call1
+      let findi_and_call1 = Hashtbl.findi_and_call1
+      let find_and_call2 = Hashtbl.find_and_call2
+      let findi_and_call2 = Hashtbl.findi_and_call2
+
+      let%test_unit "find_and_call" =
+        for_each "key" sexp_of_key sample_keys (fun key ->
+          let found x = `Found x in
+          let not_found x = `Not_found x in
+          let test_result = [%test_result: [ `Found of int | `Not_found of int ]] in
+          test_caller_2fs found not_found ~test_result (fun t if_found if_not_found ->
+            Hashtbl.find_and_call t key ~if_found ~if_not_found))
+      ;;
+
+      let fold = Hashtbl.fold
+
+      let%test_unit "fold" =
+        let callback (a, b, c) = (a, b) :: c in
+        let test_result = [%test_result: (int * int) list] in
+        test_caller ~callback ~test_result (fun t f ->
+          Hashtbl.fold t ~init:[] ~f:(fun ~key ~data acc -> f (key, data, acc)))
+      ;;
+
+      let iter = Hashtbl.iter
+
+      let%test_unit "iter" =
+        let callback a = a in
+        let test_result = [%test_result: int Queue.t] in
+        test_caller ~callback ~test_result (fun t f ->
+          let queue = Queue.create () in
+          Hashtbl.iter t ~f:(fun data -> Queue.enqueue queue (f data));
+          queue)
+      ;;
+
+      let iter_keys = Hashtbl.iter_keys
+
+      let%test_unit "iter_keys" =
+        let callback a = a in
+        let test_result = [%test_result: int Queue.t] in
+        test_caller ~callback ~test_result (fun t f ->
+          let queue = Queue.create () in
+          Hashtbl.iter_keys t ~f:(fun key -> Queue.enqueue queue (f key));
+          queue)
+      ;;
+
+      let iteri = Hashtbl.iteri
+
+      let%test_unit "iteri" =
+        let callback (a, b) = a, b in
+        let test_result = [%test_result: (int * int) Queue.t] in
+        test_caller ~callback ~test_result (fun t f ->
+          let queue = Queue.create () in
+          Hashtbl.iteri t ~f:(fun ~key ~data -> Queue.enqueue queue (f (key, data)));
+          queue)
+      ;;
+
+      let map = Hashtbl.map
+
+      let%test_unit "map" =
+        let callback a = a in
+        let test_result = [%test_result: (int * int) list] in
+        test_caller ~callback ~test_result (fun t f ->
+          Hashtbl.map t ~f |> Hashtbl.to_alist)
+      ;;
+
+      let mapi = Hashtbl.mapi
+
+      let%test_unit "mapi" =
+        let callback (a, b) = a, b in
+        let test_result = [%test_result: (int * (int * int)) list] in
+        test_caller ~callback ~test_result (fun t f ->
+          Hashtbl.mapi t ~f:(fun ~key ~data -> f (key, data)) |> Hashtbl.to_alist)
+      ;;
+
+      let filter_keys = Hashtbl.filter_keys
+
+      let%test_unit "filter_keys" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_keys t ~f |> Hashtbl.to_alist))
+      ;;
+
+      let filter = Hashtbl.filter
+
+      let%test_unit "filter" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter t ~f |> Hashtbl.to_alist))
+      ;;
+
+      let filteri = Hashtbl.filteri
+
+      let%test_unit "filteri" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filteri t ~f:(fun ~key ~data -> f (key, data)) |> Hashtbl.to_alist))
+      ;;
+
+      let filter_map = Hashtbl.filter_map
+
+      let%test_unit "filter_map" =
+        for_each "f result" [%sexp_of: data option] (option sample_data) (fun opt ->
+          let callback _ = opt in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_map t ~f |> Hashtbl.to_alist))
+      ;;
+
+      let filter_mapi = Hashtbl.filter_mapi
+
+      let%test_unit "filter_mapi" =
+        for_each "f result" [%sexp_of: data option] (option sample_data) (fun opt ->
+          let callback _ = opt in
+          let test_result = [%test_result: (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.filter_mapi t ~f:(fun ~key ~data -> f (key, data)) |> Hashtbl.to_alist))
+      ;;
+
+      let partition_tf = Hashtbl.partition_tf
+
+      let%test_unit "partition_tf" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list * (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            let t1, t2 = Hashtbl.partition_tf t ~f in
+            Hashtbl.to_alist t1, Hashtbl.to_alist t2))
+      ;;
+
+      let partitioni_tf = Hashtbl.partitioni_tf
+
+      let%test_unit "partitioni_tf" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: (int * int) list * (int * int) list] in
+          test_caller ~callback ~test_result (fun t f ->
+            let t1, t2 = Hashtbl.partitioni_tf t ~f:(fun ~key ~data -> f (key, data)) in
+            Hashtbl.to_alist t1, Hashtbl.to_alist t2))
+      ;;
+
+      let partition_map = Hashtbl.partition_map
+
+      let%test_unit "partition_map" =
+        for_each
+          "f result"
+          [%sexp_of: (data, data) Either.t]
+          (first_or_second sample_data)
+          (fun x ->
+             let callback _ = x in
+             let test_result = [%test_result: (int * int) list * (int * int) list] in
+             test_caller ~callback ~test_result (fun t f ->
+               let t1, t2 = Hashtbl.partition_map t ~f in
+               Hashtbl.to_alist t1, Hashtbl.to_alist t2))
+      ;;
+
+      let partition_mapi = Hashtbl.partition_mapi
+
+      let%test_unit "partition_mapi" =
+        for_each
+          "f result"
+          [%sexp_of: (data, data) Either.t]
+          (first_or_second sample_data)
+          (fun x ->
+             let callback _ = x in
+             let test_result = [%test_result: (int * int) list * (int * int) list] in
+             test_caller ~callback ~test_result (fun t f ->
+               let t1, t2 =
+                 Hashtbl.partition_mapi t ~f:(fun ~key ~data -> f (key, data))
+               in
+               Hashtbl.to_alist t1, Hashtbl.to_alist t2))
+      ;;
+
+      let existsi = Hashtbl.existsi
+
+      let%test_unit "existsi" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: bool] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.existsi t ~f:(fun ~key ~data -> f (key, data))))
+      ;;
+
+      let exists = Hashtbl.exists
+
+      let%test_unit "exists" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: bool] in
+          test_caller ~callback ~test_result (fun t f -> Hashtbl.exists t ~f))
+      ;;
+
+      let for_alli = Hashtbl.for_alli
+
+      let%test_unit "for_alli" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: bool] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.for_alli t ~f:(fun ~key ~data -> f (key, data))))
+      ;;
+
+      let for_all = Hashtbl.for_all
+
+      let%test_unit "for_all" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: bool] in
+          test_caller ~callback ~test_result (fun t f -> Hashtbl.for_all t ~f))
+      ;;
+
+      let count = Hashtbl.count
+
+      let%test_unit "count" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: int] in
+          test_caller ~callback ~test_result (fun t f -> Hashtbl.count t ~f))
+      ;;
+
+      let counti = Hashtbl.counti
+
+      let%test_unit "counti" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: int] in
+          test_caller ~callback ~test_result (fun t f ->
+            Hashtbl.counti t ~f:(fun ~key ~data -> f (key, data))))
+      ;;
+
+      let merge = Hashtbl.merge
+
+      let%test_unit "merge" =
+        let callback (key, data) = Some (key, data) in
+        let test_result = [%test_result: (int * (int * (int, int) merge_data)) list] in
+        test_caller_2ts ~callback ~test_result (fun t1 t2 f ->
+          Hashtbl.merge t1 t2 ~f:(fun ~key data -> f (key, data)) |> Hashtbl.to_alist)
+      ;;
+
+      let equal = Hashtbl.equal
+      let similar = Hashtbl.similar
+
+      let%test_unit "equal" =
+        for_each "f result" [%sexp_of: bool] bools (fun bool ->
+          let callback _ = bool in
+          let test_result = [%test_result: bool] in
+          test_caller_2ts ~callback ~test_result (fun t1 t2 f ->
+            Hashtbl.equal (fun a b -> f (a, b)) t1 t2))
+      ;;
+
+      let sexp_of_t = Hashtbl.sexp_of_t
+
+      let%test_unit "sexp_of_t" =
+        let test_result = [%test_result: Sexp.t] in
+        test_caller_2fs
+          [%sexp_of: int]
+          [%sexp_of: int]
+          ~test_result
+          (fun t sexp_of_key sexp_of_data -> Hashtbl.sexp_of_t sexp_of_key sexp_of_data t)
+      ;;
+
+      let invariant = Hashtbl.invariant
+
+      let%test_unit "invariant" =
+        let test_result = [%test_result: int Queue.t * int Queue.t] in
+        test_caller_2fs ignore ignore ~test_result (fun t f_key f_data ->
+          let keys = Queue.create () in
+          let data = Queue.create () in
+          Hashtbl.invariant
+            (fun k ->
+              Queue.enqueue keys k;
+              f_key k)
+            (fun d ->
+              Queue.enqueue data d;
+              f_data d)
+            t;
+          keys, data)
+      ;;
 
-                 (* we do not test [validate], which should never raise externally, but which may go
+      (* we do not test [validate], which should never raise externally, but which may go
           from pass to fail if the callback mutates, so it does not fit the normal
           criteria used by tests above *)
 
-                 let validate = Hashtbl.validate
+      let validate = Hashtbl.validate
 
-                 (* non-functions, and functions that neither mutate nor have callbacks *)
+      (* non-functions, and functions that neither mutate nor have callbacks *)
 
-                 let choose = Hashtbl.choose
-                 let choose_exn = Hashtbl.choose_exn
-                 let choose_randomly = Hashtbl.choose_randomly
-                 let choose_randomly_exn = Hashtbl.choose_randomly_exn
-                 let create = Hashtbl.create
-                 let create_mapped = Hashtbl.create_mapped
-                 let create_with_key = Hashtbl.create_with_key
-                 let create_with_key_exn = Hashtbl.create_with_key_exn
-                 let create_with_key_or_error = Hashtbl.create_with_key_or_error
-                 let group = Hashtbl.group
-                 let of_alist = Hashtbl.of_alist
-                 let of_alist_exn = Hashtbl.of_alist_exn
-                 let of_alist_multi = Hashtbl.of_alist_multi
-                 let of_alist_or_error = Hashtbl.of_alist_or_error
-                 let of_alist_report_all_dups = Hashtbl.of_alist_report_all_dups
-                 let sexp_of_key = Hashtbl.sexp_of_key
-                 let copy = Hashtbl.copy
-                 let keys = Hashtbl.keys
-                 let data = Hashtbl.data
-                 let length = Hashtbl.length
-                 let capacity = Hashtbl.capacity
-                 let is_empty = Hashtbl.is_empty
-                 let mem = Hashtbl.mem
-                 let find = Hashtbl.find
-                 let find_exn = Hashtbl.find_exn
-                 let find_multi = Hashtbl.find_multi
-                 let to_alist = Hashtbl.to_alist
-               end :
-                 Hashtbl_for_testing with type ('a, 'b) t := ('a, 'b) Hashtbl.t))
+      let choose = Hashtbl.choose
+      let choose_exn = Hashtbl.choose_exn
+      let choose_randomly = Hashtbl.choose_randomly
+      let choose_randomly_exn = Hashtbl.choose_randomly_exn
+      let create = Hashtbl.create
+      let create_mapped = Hashtbl.create_mapped
+      let create_with_key = Hashtbl.create_with_key
+      let create_with_key_exn = Hashtbl.create_with_key_exn
+      let create_with_key_or_error = Hashtbl.create_with_key_or_error
+      let group = Hashtbl.group
+      let of_alist = Hashtbl.of_alist
+      let of_alist_exn = Hashtbl.of_alist_exn
+      let of_alist_multi = Hashtbl.of_alist_multi
+      let of_alist_or_error = Hashtbl.of_alist_or_error
+      let of_alist_report_all_dups = Hashtbl.of_alist_report_all_dups
+      let sexp_of_key = Hashtbl.sexp_of_key
+      let copy = Hashtbl.copy
+      let keys = Hashtbl.keys
+      let data = Hashtbl.data
+      let length = Hashtbl.length
+      let capacity = Hashtbl.capacity
+      let is_empty = Hashtbl.is_empty
+      let mem = Hashtbl.mem
+      let find = Hashtbl.find
+      let find_exn = Hashtbl.find_exn
+      let find_multi = Hashtbl.find_multi
+      let to_alist = Hashtbl.to_alist
+    end :
+      Hashtbl_for_testing with type ('a, 'b) t := ('a, 'b) Hashtbl.t))
   ;;
 end
 
@@ -2383,3 +2129,21 @@ let%test_unit _ =
 let%test_unit _ =
   ignore ([%equal: string Int.Table.t] : string Int.Table.t -> string Int.Table.t -> bool)
 ;;
+
+let%expect_test _ =
+  let module M1 = struct
+    module Table = Hashtbl.Make_binable (Int)
+
+    type t = int Table.t [@@deriving bin_io]
+  end
+  in
+  let module M2 = struct
+    type t = int Hashtbl.M(Int).t [@@deriving bin_io]
+  end
+  in
+  Expect_test_helpers_base.require_equal
+    (module String)
+    [%bin_digest: M1.t]
+    [%bin_digest: M2.t];
+  [%expect {| |}]
+;;
Index: core-0.17.1/core/test/hashtbl_unit_tests_intf.ml
===================================================================
--- core-0.17.1.orig/core/test/hashtbl_unit_tests_intf.ml
+++ core-0.17.1/core/test/hashtbl_unit_tests_intf.ml
@@ -7,10 +7,10 @@ module type Hashtbl_for_testing = sig
 
   include
     Hashtbl_intf.Creators
-      with type ('a, 'b) t := ('a, 'b) t
-      with type 'a key := 'a
-      with type ('a, 'b, 'c) create_options :=
-        ('a, 'b, 'c) Hashtbl_intf.create_options_with_first_class_module
+    with type ('a, 'b) t := ('a, 'b) t
+    with type 'a key := 'a
+    with type ('a, 'b, 'c) create_options :=
+      ('a, 'b, 'c) Hashtbl_intf.create_options_with_first_class_module
 
   (* [Creators] gives us a different create than [Hashtbl_intf.Hashtbl] does *)
   val create : ?growth_allowed:bool -> ?size:int -> 'a Base.Hashtbl.Key.t -> ('a, 'b) t
Index: core-0.17.1/core/test/info_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/info_unit_tests.ml
+++ core-0.17.1/core/test/info_unit_tests.ml
@@ -7,7 +7,6 @@ let%test_unit "[create_s sexp] produces
 
 let%expect_test "Info.Stable.V2" =
   Expect_test_helpers_core.print_and_check_stable_type
-    [%here]
     (module Info.Stable.V2)
     (let here =
        { Source_code_position.pos_fname = "test.ml"
Index: core-0.17.1/core/test/or_error_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/or_error_unit_tests.ml
+++ core-0.17.1/core/test/or_error_unit_tests.ml
@@ -67,7 +67,7 @@ let%test _ =
 let%test _ = Result.is_error (find_map_ok ~f:(fun _ -> assert false) [])
 
 let%expect_test _ =
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     ignore (find_map_ok ~f:(fun _ -> failwith "abc") [ 1 ] : _ t));
   [%expect {| (Failure abc) |}];
   Ok ()
Index: core-0.17.1/core/test/quickcheck_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/quickcheck_unit_tests.ml
+++ core-0.17.1/core/test/quickcheck_unit_tests.ml
@@ -47,27 +47,27 @@ let%expect_test "ppx_quickcheck" =
   List.iter
     ~f:(fun predicate -> Quickcheck.test_can_generate M.quickcheck_generator ~f:predicate)
     [ (function
-       | M.A -> true
-       | _ -> false)
+        | M.A -> true
+        | _ -> false)
     ; (function
-       | M.B _ -> true
-       | _ -> false)
+        | M.B _ -> true
+        | _ -> false)
     ; (function
-       | M.C _ -> true
-       | _ -> false)
+        | M.C _ -> true
+        | _ -> false)
     ; (function
-       | M.D _ -> true
-       | _ -> false)
+        | M.D _ -> true
+        | _ -> false)
     ; (function
-       | M.E _ -> true
-       | _ -> false)
+        | M.E _ -> true
+        | _ -> false)
     ];
   [%expect {| |}]
 ;;
 
 module Test (S : sig
-  val default_seed : Quickcheck.seed
-end) : sig end = struct
+    val default_seed : Quickcheck.seed
+  end) : sig end = struct
   let int_middle_bits =
     match Word_size.word_size with
     | W64 -> Int.of_string "0x0000_ffff_ffff_0000"
@@ -75,9 +75,9 @@ end) : sig end = struct
   ;;
 
   module Q = Quickcheck.Configure (struct
-    include Quickcheck
-    include S
-  end)
+      include Quickcheck
+      include S
+    end)
 
   open Q
   module G = Quickcheck.Generator
@@ -746,14 +746,14 @@ let%test_module _ = (module Test (Quickc
 
 let%test_module _ =
   (module Test (struct
-    let default_seed = `Deterministic "foo"
-  end))
+      let default_seed = `Deterministic "foo"
+    end))
 ;;
 
 let%test_module _ =
   (module Test (struct
-    let default_seed = `Deterministic "bar"
-  end))
+      let default_seed = `Deterministic "bar"
+    end))
 ;;
 
 (* let%test_module _ = (module Test (struct let default_seed = `Deterministic "baz" end))
Index: core-0.17.1/core/test/test_array.ml
===================================================================
--- core-0.17.1.orig/core/test/test_array.ml
+++ core-0.17.1/core/test/test_array.ml
@@ -20,11 +20,11 @@ let%expect_test "slice" =
 
 let%test_module "nget" =
   (module struct
-    let%expect_test "neg" = require_equal [%here] (module Base.Int) (nget ar1 (-3)) 8
-    let%expect_test "pos" = require_equal [%here] (module Base.Int) (nget ar1 3) ar1.(3)
+    let%expect_test "neg" = require_equal (module Base.Int) (nget ar1 (-3)) 8
+    let%expect_test "pos" = require_equal (module Base.Int) (nget ar1 3) ar1.(3)
 
     let%expect_test "invalid" =
-      require_does_raise [%here] (fun () : int -> nget ar1 (-100));
+      require_does_raise (fun () : int -> nget ar1 (-100));
       [%expect {| (Invalid_argument "index out of bounds") |}]
     ;;
   end)
Index: core-0.17.1/core/test/test_array_local.mlt
===================================================================
--- core-0.17.1.orig/core/test/test_array_local.mlt
+++ core-0.17.1/core/test/test_array_local.mlt
@@ -10,7 +10,7 @@ Permissioned.create_local ~len:10 k
 [%%expect
   {|
 Line _, characters _-_:
-Error: This value escapes its region
+Error: This value escapes its region.
 |}]
 ;;
 
@@ -21,5 +21,5 @@ ref arr
 [%%expect
   {|
 Line _, characters _-_:
-Error: This value escapes its region
+Error: This value escapes its region.
 |}]
Index: core-0.17.1/core/test/test_avltree.ml
===================================================================
--- core-0.17.1.orig/core/test/test_avltree.ml
+++ core-0.17.1/core/test/test_avltree.ml
@@ -10,11 +10,11 @@ let invariant tree =
   Avltree.iter tree ~f:(fun ~key ~data -> assert (key = data))
 ;;
 
-let require_is_absent tree int = require [%here] (not (Avltree.mem tree ~compare int))
+let require_is_absent tree int = require (not (Avltree.mem tree ~compare int))
 
 let require_is_present tree int =
-  require [%here] (Avltree.mem tree ~compare int);
-  require_equal [%here] (module Int_option) (Avltree.find tree ~compare int) (Some int)
+  require (Avltree.mem tree ~compare int);
+  require_equal (module Int_option) (Avltree.find tree ~compare int) (Some int)
 ;;
 
 let require_equivalent_set tree set =
@@ -23,14 +23,14 @@ let require_equivalent_set tree set =
   let from_fold =
     Avltree.fold tree ~init:Int.Set.empty ~f:(fun ~key:int ~data:_ set -> Set.add set int)
   in
-  require_sets_are_equal [%here] !from_iter from_fold;
-  require_sets_are_equal [%here] !from_iter set
+  require_sets_are_equal !from_iter from_fold;
+  require_sets_are_equal !from_iter set
 ;;
 
 let require_ref_mutated f ~to_:expect =
   let r = ref (not expect) in
   let return = f r in
-  require_equal [%here] (module Bool) !r expect;
+  require_equal (module Bool) !r expect;
   return
 ;;
 
@@ -87,9 +87,9 @@ let operation_printed_crs = ref false
 let () =
   let old = !on_print_cr in
   on_print_cr
-    := fun cr ->
-         operation_printed_crs := true;
-         old cr
+  := fun cr ->
+       operation_printed_crs := true;
+       old cr
 ;;
 
 module Operation_sequence = struct
@@ -120,7 +120,6 @@ let add_then_remove_reverse_sorted =
 
 let%expect_test "random operations" =
   quickcheck_m
-    [%here]
     (module Operation_sequence)
     ~examples:[ add_then_remove_sorted; add_then_remove_reverse_sorted ]
     ~f:(fun operations ->
Index: core-0.17.1/core/test/test_bag.ml
===================================================================
--- core-0.17.1.orig/core/test/test_bag.ml
+++ core-0.17.1/core/test/test_bag.ml
@@ -3,8 +3,8 @@ open! Import
 
 let invariant bag =
   Bag.invariant ignore bag;
-  require [%here] (Bag.length bag >= 0);
-  require_equal [%here] (module Bool) (Bag.length bag = 0) (Bag.is_empty bag)
+  require (Bag.length bag >= 0);
+  require_equal (module Bool) (Bag.length bag = 0) (Bag.is_empty bag)
 ;;
 
 let test bag =
@@ -57,7 +57,7 @@ let%expect_test "add100" =
     ignore (Bag.add b i : int Bag.Elt.t);
     invariant b
   done;
-  require_equal [%here] (module Int) (Bag.length b) n;
+  require_equal (module Int) (Bag.length b) n;
   for _ = 1 to n do
     (match Bag.remove_one b with
      | None -> assert false
@@ -73,5 +73,5 @@ include Base_test_helpers.Test_container
 let%expect_test "[iter] does not allocate" =
   let t = Bag.create () in
   Bag.add_unit t ();
-  require_no_allocation [%here] (fun () -> Bag.iter t ~f:ignore)
+  require_no_allocation (fun () -> Bag.iter t ~f:ignore)
 ;;
Index: core-0.17.1/core/test/test_bigstring.ml
===================================================================
--- core-0.17.1.orig/core/test/test_bigstring.ml
+++ core-0.17.1/core/test/test_bigstring.ml
@@ -190,17 +190,15 @@ let%test_module "memcmp" =
     let b2 = Bigstring.of_string "jkcd"
 
     let%expect_test "out of bounds raises" =
-      require_does_raise [%here] (fun () ->
-        Bigstring.memcmp empty ~pos1:1 b1 ~pos2:1 ~len:0);
+      require_does_raise (fun () -> Bigstring.memcmp empty ~pos1:1 b1 ~pos2:1 ~len:0);
       [%expect {| (Invalid_argument "pos + len past end: 1 + 0 > 0") |}];
-      require_does_raise [%here] (fun () ->
-        Bigstring.memcmp empty ~pos1:1 b1 ~pos2:1 ~len:1);
+      require_does_raise (fun () -> Bigstring.memcmp empty ~pos1:1 b1 ~pos2:1 ~len:1);
       [%expect {| (Invalid_argument "pos + len past end: 1 + 1 > 0") |}];
-      require_does_raise [%here] (fun () -> Bigstring.memcmp b1 ~pos1:0 b1 ~pos2:0 ~len:5);
+      require_does_raise (fun () -> Bigstring.memcmp b1 ~pos1:0 b1 ~pos2:0 ~len:5);
       [%expect {| (Invalid_argument "pos + len past end: 0 + 5 > 4") |}];
-      require_does_raise [%here] (fun () -> Bigstring.memcmp b1 ~pos1:0 b1 ~pos2:5 ~len:0);
+      require_does_raise (fun () -> Bigstring.memcmp b1 ~pos1:0 b1 ~pos2:5 ~len:0);
       [%expect {| (Invalid_argument "pos + len past end: 5 + 0 > 4") |}];
-      require_does_raise [%here] (fun () -> Bigstring.memcmp b1 ~pos1:0 b1 ~pos2:4 ~len:2);
+      require_does_raise (fun () -> Bigstring.memcmp b1 ~pos1:0 b1 ~pos2:4 ~len:2);
       [%expect {| (Invalid_argument "pos + len past end: 4 + 2 > 4") |}]
     ;;
 
@@ -234,9 +232,9 @@ let%test_module "memset" =
 
     let%test_unit "out of bounds raises" =
       let b1 = Bigstring.of_string "abcd" in
-      require_does_raise [%here] (fun () -> Bigstring.memset empty ~pos:0 ~len:1 'a');
-      require_does_raise [%here] (fun () -> Bigstring.memset b1 ~pos:1 ~len:4 'a');
-      require_does_raise [%here] (fun () -> Bigstring.memset b1 ~pos:8 ~len:0 'a')
+      require_does_raise (fun () -> Bigstring.memset empty ~pos:0 ~len:1 'a');
+      require_does_raise (fun () -> Bigstring.memset b1 ~pos:1 ~len:4 'a');
+      require_does_raise (fun () -> Bigstring.memset b1 ~pos:8 ~len:0 'a')
     ;;
 
     let%test_unit "total memset works" =
Index: core-0.17.1/core/test/test_bigstring_safe_accessors.ml
===================================================================
--- core-0.17.1.orig/core/test/test_bigstring_safe_accessors.ml
+++ core-0.17.1/core/test/test_bigstring_safe_accessors.ml
@@ -101,7 +101,8 @@ let%expect_test "set_int16_le_exn" =
   [%expect {| ok pos: 32767 |}];
   printf "@pos:     0x%x\n" (Bigstring.get_uint8 buf ~pos);
   printf "@pos + 1: 0x%x\n" (Bigstring.get_uint8 buf ~pos:(pos + 1));
-  [%expect {|
+  [%expect
+    {|
     @pos:     0xff
     @pos + 1: 0x7f
     |}];
@@ -138,7 +139,8 @@ let%expect_test "set_int16_be_exn" =
   [%expect {| ok pos: 32767 |}];
   printf "@pos:     0x%x\n" (Bigstring.get_uint8 buf ~pos);
   printf "@pos + 1: 0x%x\n" (Bigstring.get_uint8 buf ~pos:(pos + 1));
-  [%expect {|
+  [%expect
+    {|
     @pos:     0x7f
     @pos + 1: 0xff
     |}];
@@ -176,7 +178,8 @@ let%expect_test "set_uint16_le_exn" =
   set_and_print ~test_name:"endianness check" ~pos 51966;
   printf "@pos:     0x%x\n" (Bigstring.get_uint8 buf ~pos);
   printf "@pos + 1: 0x%x\n" (Bigstring.get_uint8 buf ~pos:(pos + 1));
-  [%expect {|
+  [%expect
+    {|
     endianness check: 51966
     @pos:     0xfe
     @pos + 1: 0xca
@@ -213,7 +216,8 @@ let%expect_test "set_uint16_be_exn" =
   set_and_print ~test_name:"endianness check" ~pos 51966;
   printf "@pos:     0x%x\n" (Bigstring.get_uint8 buf ~pos);
   printf "@pos + 1: 0x%x\n" (Bigstring.get_uint8 buf ~pos:(pos + 1));
-  [%expect {|
+  [%expect
+    {|
     endianness check: 51966
     @pos:     0xca
     @pos + 1: 0xfe
Index: core-0.17.1/core/test/test_bigstring_unsafe_accessors.ml
===================================================================
--- core-0.17.1.orig/core/test/test_bigstring_unsafe_accessors.ml
+++ core-0.17.1/core/test/test_bigstring_unsafe_accessors.ml
@@ -115,10 +115,11 @@ let%test_unit _ =
     ; "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
     ]
     ~f:(fun string ->
-    assert (Exn.does_raise (fun () -> unsafe_get_uint64_be_exn ~pos:0 (of_string string)));
-    assert (
-      Exn.does_raise (fun () ->
-        unsafe_get_uint64_le_exn ~pos:0 (of_string (String.rev string)))))
+      assert (
+        Exn.does_raise (fun () -> unsafe_get_uint64_be_exn ~pos:0 (of_string string)));
+      assert (
+        Exn.does_raise (fun () ->
+          unsafe_get_uint64_le_exn ~pos:0 (of_string (String.rev string)))))
 ;;
 
 let%test _ =
Index: core-0.17.1/core/test/test_bigstring_unsafe_destroy.ml
===================================================================
--- core-0.17.1.orig/core/test/test_bigstring_unsafe_destroy.ml
+++ core-0.17.1/core/test/test_bigstring_unsafe_destroy.ml
@@ -4,7 +4,7 @@ open Expect_test_helpers_core
 let%expect_test "[unsafe_destroy] destroy after destroy" =
   let bs = Bigstring.create 100 in
   let () = Bigstring.unsafe_destroy bs in
-  require [%here] (Exn.does_raise (fun () -> Bigstring.unsafe_destroy bs))
+  require (Exn.does_raise (fun () -> Bigstring.unsafe_destroy bs))
 ;;
 
 let%expect_test "[unsafe_destroy_and_resize]" =
@@ -15,13 +15,13 @@ let%expect_test "[unsafe_destroy_and_res
   let bigstring_1 = Bigstring.unsafe_destroy_and_resize bigstring_6 ~len:1 in
   printf "%d" (Bigstring.length bigstring_6);
   [%expect {| 0 |}];
-  require_does_raise [%here] (fun () -> bigstring_6.{1} <- 'F');
+  require_does_raise (fun () -> bigstring_6.{1} <- 'F');
   [%expect {| (Invalid_argument "index out of bounds") |}];
   printf "%d" (Bigstring.length bigstring_1);
   [%expect {| 1 |}];
   printf "%s" (Bigstring.to_string bigstring_1);
   [%expect {| A |}];
-  require_does_raise [%here] (fun () -> bigstring_1.{1} <- 'F');
+  require_does_raise (fun () -> bigstring_1.{1} <- 'F');
   [%expect {| (Invalid_argument "index out of bounds") |}];
   bigstring_1.{0} <- 'X';
   let bigstring_3 = Bigstring.unsafe_destroy_and_resize bigstring_1 ~len:3 in
@@ -32,7 +32,7 @@ let%expect_test "[unsafe_destroy_and_res
   Bigstring.From_string.blito () ~src:"YZ" ~dst:bigstring_3 ~dst_pos:1;
   printf "%s" (Bigstring.to_string bigstring_3);
   [%expect {| XYZ |}];
-  require_does_raise [%here] (fun () -> bigstring_3.{5} <- 'F');
+  require_does_raise (fun () -> bigstring_3.{5} <- 'F');
   [%expect {| (Invalid_argument "index out of bounds") |}]
 ;;
 
@@ -44,7 +44,7 @@ let%expect_test ("[unsafe_destroy_and_re
   printf "%d" (Bigstring.length bigstring);
   [%expect {| 10 |}];
   let _shared = Bigstring.sub_shared bigstring in
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     let (_ : Bigstring.t_frozen) = Bigstring.unsafe_destroy_and_resize bigstring ~len:5 in
     ());
   [%expect {| (Failure "bigstring_realloc: bigstring has proxy") |}]
Index: core-0.17.1/core/test/test_binable.ml
===================================================================
--- core-0.17.1.orig/core/test/test_binable.ml
+++ core-0.17.1/core/test/test_binable.ml
@@ -30,8 +30,8 @@ let%test_unit "Of_sexpable" =
     type t = int
 
     include Of_sexpable_without_uuid [@alert "-legacy"] (struct
-      type t = int [@@deriving sexp]
-    end)
+        type t = int [@@deriving sexp]
+      end)
   end
   in
   let m = (module M : S with type t = M.t) in
@@ -48,7 +48,7 @@ let%expect_test "of_bigstring fails if t
   [%expect {| test value |}];
   (* if the bigstring is too short, the [bin_read_t] function will raise: *)
   let shorter_bigstring = Bigstring.sub_shared ~len:10 good_bigstring in
-  require_does_raise [%here] (fun () -> of_bigstring (module String) shorter_bigstring);
+  require_does_raise (fun () -> of_bigstring (module String) shorter_bigstring);
   [%expect {| (Bin_prot__Common.Buffer_short) |}];
   (* if the bigstring is too long, the [bin_read_t] function will not consume all of it,
      and [of_bigstring] will raise. *)
@@ -60,7 +60,7 @@ let%expect_test "of_bigstring fails if t
     ~dst:longer_bigstring
     ~dst_pos:0
     ~len:(Bigstring.length good_bigstring);
-  require_does_raise [%here] (fun () -> of_bigstring (module String) longer_bigstring);
+  require_does_raise (fun () -> of_bigstring (module String) longer_bigstring);
   [%expect
     {|
     ("bin_read_t did not consume the entire buffer"
Index: core-0.17.1/core/test/test_blang.ml
===================================================================
--- core-0.17.1.orig/core/test/test_blang.ml
+++ core-0.17.1/core/test/test_blang.ml
@@ -7,25 +7,28 @@ let orelse = O.( || )
 
 let%test_module "Stable.V1" =
   (module Stable_unit_test.Make (struct
-    type t = string Stable.V1.t [@@deriving bin_io, equal, sexp]
+      type t = string Stable.V1.t [@@deriving bin_io, equal, sexp]
 
-    let test_blang =
-      if_
-        (base "foo")
-        (not_ (or_ [ base "bara"; base "barb" ]))
-        (not_ (and_ [ base "baza"; base "bazb" ]))
-    ;;
+      let test_blang =
+        if_
+          (base "foo")
+          (not_ (or_ [ base "bara"; base "barb" ]))
+          (not_ (and_ [ base "baza"; base "bazb" ]))
+      ;;
 
-    let test_sexp = "(if foo (not (or bara barb)) (not (and baza bazb)))"
+      let test_sexp = "(if foo (not (or bara barb)) (not (and baza bazb)))"
 
-    let test_bin =
-      "\005\006\003foo\004\003\006\004bara\006\004barb\004\002\006\004baza\006\004bazb"
-    ;;
+      let test_bin =
+        "\005\006\003foo\004\003\006\004bara\006\004barb\004\002\006\004baza\006\004bazb"
+      ;;
 
-    let tests =
-      [ test_blang, test_sexp, test_bin; true_, "true", "\000"; false_, "false", "\001" ]
-    ;;
-  end))
+      let tests =
+        [ test_blang, test_sexp, test_bin
+        ; true_, "true", "\000"
+        ; false_, "false", "\001"
+        ]
+      ;;
+    end))
 ;;
 
 let%test_module "auto-simplification" =
@@ -348,7 +351,7 @@ let%expect_test "no-alloc-eval" =
       (not_ (or_ [ base "bara"; base "barb" ]))
       (not_ (and_ [ base "baza"; base "bazb" ]))
   in
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     let result = eval blang (fun _ -> false) in
     ignore (result : bool));
   [%expect {| |}]
@@ -369,7 +372,6 @@ let%expect_test "quickcheck generator ob
    `lib/sexp_grammar/src/sexp_grammar.ml`. *)
 let%expect_test "validate sexp grammar" =
   require_ok
-    [%here]
     (Sexp_grammar_validation.validate_grammar
        (module struct
          type t = unit Blang.t [@@deriving quickcheck, sexp, sexp_grammar]
@@ -426,7 +428,8 @@ module _ = struct
 
   let%expect_test _ =
     print [ a ];
-    [%expect {|
+    [%expect
+      {|
       (standard a)
       (raw (Base a))
       |}]
@@ -504,7 +507,8 @@ module _ = struct
                     (Base h)))))))))
       |}];
     p false_;
-    [%expect {|
+    [%expect
+      {|
       (standard false)
       (raw False)
       |}]
@@ -522,7 +526,8 @@ module _ = struct
 
   let%expect_test _ =
     print [ a ];
-    [%expect {|
+    [%expect
+      {|
       (standard a)
       (raw (Base a))
       |}]
@@ -579,7 +584,8 @@ module _ = struct
         ]
     in
     p true_;
-    [%expect {|
+    [%expect
+      {|
       (standard true)
       (raw True)
       |}];
@@ -652,11 +658,7 @@ module _ : Monadic with module M := Mona
         type t = Value.t Trace.t [@@deriving equal, sexp_of]
       end
       in
-      require_equal
-        [%here]
-        (module Value_with_trace)
-        (Trace.run op1 t ~f)
-        (Trace.run op2 t ~f)
+      require_equal (module Value_with_trace) (Trace.run op1 t ~f) (Trace.run op2 t ~f)
     ;;
   end
 
@@ -666,7 +668,6 @@ module _ : Monadic with module M := Mona
 
   let%expect_test "map" =
     quickcheck_m
-      [%here]
       (module Small_int_blang)
       ~f:(fun t -> test (module Small_int_blang) t Blang.map Monadic.map ~f:Int.succ);
     [%expect {| |}]
@@ -676,7 +677,6 @@ module _ : Monadic with module M := Mona
 
   let%expect_test "bind" =
     quickcheck_m
-      [%here]
       (module struct
         type t = Small_int_blang.t * Small_int_blang.t list
         [@@deriving quickcheck, sexp_of]
@@ -692,7 +692,6 @@ module _ : Monadic with module M := Mona
 
   let%expect_test "eval" =
     quickcheck_m
-      [%here]
       (module struct
         type t = Small_int_blang.t * Small_int.t [@@deriving quickcheck, sexp_of]
       end)
Index: core-0.17.1/core/test/test_bounded_index.ml
===================================================================
--- core-0.17.1.orig/core/test/test_bounded_index.ml
+++ core-0.17.1/core/test/test_bounded_index.ml
@@ -3,39 +3,39 @@ open! Import
 open! Bounded_index
 
 module M = Make (struct
-  let label = "index"
-  let module_name = "Test_bounded_index"
-end)
+    let label = "index"
+    let module_name = "Test_bounded_index"
+  end)
 
 let%test_module "V1" =
   (module Stable_unit_test.Make (struct
-    type t = M.Stable.V1.t [@@deriving sexp, bin_io, compare]
+      type t = M.Stable.V1.t [@@deriving sexp, bin_io, compare]
 
-    let equal x y = compare x y = 0
-    let make index min max = M.create index ~min ~max
+      let equal x y = compare x y = 0
+      let make index min max = M.create index ~min ~max
 
-    let tests =
-      [ make 0 0 0, "(index 0 of 0 to 0)", "\000\000\000"
-      ; make 0 0 1, "(index 0 of 0 to 1)", "\000\000\001"
-      ; make 1 0 1, "(index 1 of 0 to 1)", "\001\000\001"
-      ; make 0 0 2, "(index 0 of 0 to 2)", "\000\000\002"
-      ; make 1 0 2, "(index 1 of 0 to 2)", "\001\000\002"
-      ; make 2 0 2, "(index 2 of 0 to 2)", "\002\000\002"
-      ; make 1 1 1, "(index 1 of 1 to 1)", "\001\001\001"
-      ; make 1 1 2, "(index 1 of 1 to 2)", "\001\001\002"
-      ; make 2 1 2, "(index 2 of 1 to 2)", "\002\001\002"
-      ; make 1 1 3, "(index 1 of 1 to 3)", "\001\001\003"
-      ; make 2 1 3, "(index 2 of 1 to 3)", "\002\001\003"
-      ; make 3 1 3, "(index 3 of 1 to 3)", "\003\001\003"
-      ; ( make 499_999_999 0 999_999_999
-        , "(index 499_999_999 of 0 to 999_999_999)"
-        , "\253\255\100\205\029\000\253\255\201\154\059" )
-      ; ( make 500_000_000 1 1_000_000_000
-        , "(index 500_000_000 of 1 to 1_000_000_000)"
-        , "\253\000\101\205\029\001\253\000\202\154\059" )
-      ]
-    ;;
-  end))
+      let tests =
+        [ make 0 0 0, "(index 0 of 0 to 0)", "\000\000\000"
+        ; make 0 0 1, "(index 0 of 0 to 1)", "\000\000\001"
+        ; make 1 0 1, "(index 1 of 0 to 1)", "\001\000\001"
+        ; make 0 0 2, "(index 0 of 0 to 2)", "\000\000\002"
+        ; make 1 0 2, "(index 1 of 0 to 2)", "\001\000\002"
+        ; make 2 0 2, "(index 2 of 0 to 2)", "\002\000\002"
+        ; make 1 1 1, "(index 1 of 1 to 1)", "\001\001\001"
+        ; make 1 1 2, "(index 1 of 1 to 2)", "\001\001\002"
+        ; make 2 1 2, "(index 2 of 1 to 2)", "\002\001\002"
+        ; make 1 1 3, "(index 1 of 1 to 3)", "\001\001\003"
+        ; make 2 1 3, "(index 2 of 1 to 3)", "\002\001\003"
+        ; make 3 1 3, "(index 3 of 1 to 3)", "\003\001\003"
+        ; ( make 499_999_999 0 999_999_999
+          , "(index 499_999_999 of 0 to 999_999_999)"
+          , "\253\255\100\205\029\000\253\255\201\154\059" )
+        ; ( make 500_000_000 1 1_000_000_000
+          , "(index 500_000_000 of 1 to 1_000_000_000)"
+          , "\253\000\101\205\029\001\253\000\202\154\059" )
+        ]
+      ;;
+    end))
 ;;
 
 let%test_unit "zero-based indexing" =
Index: core-0.17.1/core/test/test_byte_units.ml
===================================================================
--- core-0.17.1.orig/core/test/test_byte_units.ml
+++ core-0.17.1/core/test/test_byte_units.ml
@@ -401,7 +401,7 @@ let%expect_test "Byte_units.Stable.V2.t_
 ;;
 
 let%expect_test "Byte_units.Stable.V1" =
-  print_and_check_stable_type [%here] (module Byte_units.Stable.V1) examples;
+  print_and_check_stable_type (module Byte_units.Stable.V1) examples;
   [%expect
     {|
     (bin_shape_digest 1fd923acb2dd9c5d401ad5b08b1d40cd)
@@ -441,7 +441,7 @@ let%expect_test "Byte_units.Stable.V1" =
 ;;
 
 let%expect_test "Byte_units.Stable.V2" =
-  print_and_check_stable_type [%here] (module Byte_units.Stable.V2) examples;
+  print_and_check_stable_type (module Byte_units.Stable.V2) examples;
   [%expect
     {|
     (bin_shape_digest 2b528f4b22f08e28876ffe0239315ac2)
@@ -514,7 +514,7 @@ let ensure_round_trippable
   Int63.gen_log_uniform_incl Int63.zero (Int63.of_int64_exn max)
   |> Quickcheck.Generator.map ~f:Byte_units.of_bytes_int63
   |> Quickcheck.test ~f:(fun t ->
-       [%test_eq: Byte_units.Stable.V2.t] ~equal t (from (to_ t)))
+    [%test_eq: Byte_units.Stable.V2.t] ~equal t (from (to_ t)))
 ;;
 
 (** Quick check to excercise various round-trip relations *)
@@ -611,3 +611,44 @@ let%test_unit "Byte_units.Stable.V2.sexp
     Byte_units.Stable.V2.t_of_sexp
     ~tolerance:`Zero
 ;;
+
+let%expect_test "Byte_units.Stable.V2.t_sexp_grammar" =
+  Sexp_grammar_validation.validate_grammar
+    (module struct
+      include struct
+        type t = Byte_units.t [@@deriving quickcheck]
+      end
+
+      type t = Byte_units.Stable.V2.t [@@deriving sexp, sexp_grammar]
+    end)
+  |> ok_exn;
+  [%expect
+    {|
+    (Union
+     (String
+      (Variant
+       ((case_sensitivity Case_sensitive)
+        (clauses
+         ((No_tag
+           ((name Bytes) (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Exabytes) (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Gigabytes)
+            (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Kilobytes)
+            (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Megabytes)
+            (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Petabytes)
+            (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Terabytes)
+            (clause_kind (List_clause (args (Cons Float Empty))))))
+          (No_tag
+           ((name Words) (clause_kind (List_clause (args (Cons Float Empty))))))))))))
+    |}]
+;;
Index: core-0.17.1/core/test/test_char.ml
===================================================================
--- core-0.17.1.orig/core/test/test_char.ml
+++ core-0.17.1/core/test/test_char.ml
@@ -20,9 +20,9 @@ let%test_module "Caseless Hash" =
 ;;
 
 let%expect_test "of_string" =
-  require_equal [%here] (module Char) (Char.of_string "c") 'c';
-  require_does_raise [%here] (fun () -> Char.of_string "");
+  require_equal (module Char) (Char.of_string "c") 'c';
+  require_does_raise (fun () -> Char.of_string "");
   [%expect {| (Failure "Char.of_string: \"\"") |}];
-  require_does_raise [%here] (fun () -> Char.of_string "too long");
+  require_does_raise (fun () -> Char.of_string "too long");
   [%expect {| (Failure "Char.of_string: \"too long\"") |}]
 ;;
Index: core-0.17.1/core/test/test_container_module_types.ml
===================================================================
--- core-0.17.1.orig/core/test/test_container_module_types.ml
+++ core-0.17.1/core/test/test_container_module_types.ml
@@ -151,8 +151,8 @@ module For_indexed_container = struct
 
     include
       Generic_permissions
-        with type 'a elt := 'a elt
-         and type ('a, 'b, 'c, 'd) t := ('a, 'b, 'c, 'd) t
+      with type 'a elt := 'a elt
+       and type ('a, 'b, 'c, 'd) t := ('a, 'b, 'c, 'd) t
 
     val init : int -> f:(int -> 'a elt) -> ('a, 'p1, 'p2, [< _ perms ]) t
 
@@ -189,7 +189,7 @@ module _ : module type of Container = st
 
       include
         Generic_permissions
-          with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
+        with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
     end
   end
 
@@ -206,9 +206,9 @@ module _ : module type of Container = st
 
       include
         Generic_with_creators_permissions
-          with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
-           and type ('a, 'phantom1, 'phantom2, _) concat :=
-            ('a, 'phantom1, 'phantom2) concat
+        with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
+         and type ('a, 'phantom1, 'phantom2, _) concat :=
+          ('a, 'phantom1, 'phantom2) concat
     end
   end
 
@@ -258,9 +258,9 @@ module _ : module type of Container = st
 
       include
         Generic_with_creators_permissions
-          with type 'a elt := 'a
-           and type ('a, _, _, 'p) t := ('a, 'p) t
-           and type ('a, _, _, 'p) concat := ('a, 'p) t
+        with type 'a elt := 'a
+         and type ('a, _, _, 'p) t := ('a, 'p) t
+         and type ('a, _, _, 'p) concat := ('a, 'p) t
     end
   end
 
@@ -279,7 +279,7 @@ module _ : module type of Indexed_contai
 
       include
         Generic_permissions
-          with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
+        with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
     end
   end
 
@@ -296,9 +296,9 @@ module _ : module type of Indexed_contai
 
       include
         Generic_with_creators_permissions
-          with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
-           and type ('a, 'phantom1, 'phantom2, _) concat :=
-            ('a, 'phantom1, 'phantom2) concat
+        with type ('a, 'phantom1, 'phantom2, _) t := ('a, 'phantom1, 'phantom2) t
+         and type ('a, 'phantom1, 'phantom2, _) concat :=
+          ('a, 'phantom1, 'phantom2) concat
     end
   end
 
@@ -315,8 +315,8 @@ module _ : module type of Indexed_contai
 
       include
         Generic_permissions
-          with type 'a elt := 'a
-           and type ('a, _, _, 'perms) t := ('a, 'perms) t
+        with type 'a elt := 'a
+         and type ('a, _, _, 'perms) t := ('a, 'perms) t
     end
   end
 
@@ -334,9 +334,9 @@ module _ : module type of Indexed_contai
 
       include
         Generic_with_creators_permissions
-          with type 'a elt := 'a
-           and type ('a, _, _, 'p) t := ('a, 'p) t
-           and type ('a, _, _, 'p) concat := ('a, 'p) t
+        with type 'a elt := 'a
+         and type ('a, _, _, 'p) t := ('a, 'p) t
+         and type ('a, _, _, 'p) concat := ('a, 'p) t
     end
   end
 
Index: core-0.17.1/core/test/test_date.ml
===================================================================
--- core-0.17.1.orig/core/test/test_date.ml
+++ core-0.17.1/core/test/test_date.ml
@@ -5,7 +5,6 @@ open! Date.Private
 
 let%expect_test _ =
   print_and_check_container_sexps
-    [%here]
     (module Date)
     [ Date.of_string "1955-11-12"
     ; Date.of_string "1985-10-26"
@@ -33,7 +32,7 @@ let%expect_test "Date.V1" =
     ; Date.create_exn ~y:2012 ~m:Apr ~d:19
     ]
   in
-  print_and_check_stable_type [%here] (module Date.Stable.V1) examples;
+  print_and_check_stable_type (module Date.Stable.V1) examples;
   [%expect
     {|
     (bin_shape_digest 47681bb034560d96024e1b2eca0d98ca)
@@ -48,20 +47,19 @@ let%expect_test "Date.V1" =
     let int = Date.Stable.V1.to_int date in
     print_s [%sexp (date : Date.Stable.V1.t), (int : int)];
     let round_trip = Date.Stable.V1.of_int_exn int in
-    require_compare_equal [%here] (module Date.Stable.V1) date round_trip);
+    require_compare_equal (module Date.Stable.V1) date round_trip);
   [%expect
     {|
     (1066-10-16 69_863_952)
     (1955-11-05 128_125_701)
     (2012-04-19 131_859_475)
     |}];
-  require_does_raise [%here] (fun () -> Date.Stable.V1.of_int_exn 0);
+  require_does_raise (fun () -> Date.Stable.V1.of_int_exn 0);
   [%expect {| (Failure "Month.of_int_exn 0") |}]
 ;;
 
 let%expect_test "Date.V1.Set" =
   print_and_check_stable_type
-    [%here]
     (module Date.Stable.V1.Set)
     [ Date.Set.empty
     ; Date.Set.singleton (Date.create_exn ~y:1066 ~m:Oct ~d:16)
@@ -91,7 +89,6 @@ let%expect_test "Date.V1.Map" =
   end
   in
   print_and_check_stable_type
-    [%here]
     (module T)
     [ Date.Map.empty
     ; Date.Map.singleton
@@ -137,7 +134,7 @@ let%expect_test "Date.Option.V1" =
   let date_opt_examples =
     Date.Option.none :: List.map date_examples ~f:Date.Option.some
   in
-  print_and_check_stable_type [%here] (module Date.Stable.Option.V1) date_opt_examples;
+  print_and_check_stable_type (module Date.Stable.Option.V1) date_opt_examples;
   [%expect
     {|
     (bin_shape_digest aff59493f3c14f005635a016cd36c44b)
@@ -150,7 +147,7 @@ let%expect_test "Date.Option.V1" =
     let int = Date.Stable.Option.V1.to_int date in
     print_s [%sexp (date : Date.Stable.Option.V1.t), (int : int)];
     let round_trip = Date.Stable.Option.V1.of_int_exn int in
-    require_compare_equal [%here] (module Date.Stable.Option.V1) date round_trip);
+    require_compare_equal (module Date.Stable.Option.V1) date round_trip);
   [%expect
     {|
     (() 0)
@@ -162,7 +159,7 @@ let%expect_test "Date.Option.V1" =
 
 let%expect_test "create_exn doesn't allocate" =
   let y, m, d = Sys.opaque_identity (1999, Month.Dec, 31) in
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     ignore (Sys.opaque_identity (Date.create_exn ~y ~m ~d) : Date.t));
   [%expect {| |}]
 ;;
@@ -317,7 +314,7 @@ let%test_module "adding weekdays and bus
   (module struct
     let test alist day_of_week date_string =
       let date = Date.of_string date_string in
-      require_equal [%here] (module Day_of_week) day_of_week (Date.day_of_week date);
+      require_equal (module Day_of_week) day_of_week (Date.day_of_week date);
       List.iter alist ~f:(fun (name, round_and_add) ->
         let list =
           List.map [ -2; -1; 0; 1; 2 ] ~f:(fun increment ->
@@ -604,10 +601,10 @@ let%test_unit _ =
     Date.Option.quickcheck_generator
     ~sexp_of:Date.Option.sexp_of_t
     ~f:(fun t ->
-    Date.Option.between
-      t
-      ~low:(Date.Option.some (Date.of_string "1900-01-01"))
-      ~high:(Date.Option.some (Date.of_string "2100-01-01")))
+      Date.Option.between
+        t
+        ~low:(Date.Option.some (Date.of_string "1900-01-01"))
+        ~high:(Date.Option.some (Date.of_string "2100-01-01")))
 ;;
 
 let%test_unit _ =
Index: core-0.17.1/core/test/test_day_of_week.ml
===================================================================
--- core-0.17.1.orig/core/test/test_day_of_week.ml
+++ core-0.17.1/core/test/test_day_of_week.ml
@@ -6,21 +6,21 @@ let num_days_in_week = 7
 
 let%test_module "Day_of_week.V1" =
   (module Stable_unit_test.Make (struct
-    include Stable.V1
+      include Stable.V1
 
-    let equal = [%compare.equal: t]
+      let equal = [%compare.equal: t]
 
-    let tests =
-      [ Sun, "SUN", "\000"
-      ; Mon, "MON", "\001"
-      ; Tue, "TUE", "\002"
-      ; Wed, "WED", "\003"
-      ; Thu, "THU", "\004"
-      ; Fri, "FRI", "\005"
-      ; Sat, "SAT", "\006"
-      ]
-    ;;
-  end))
+      let tests =
+        [ Sun, "SUN", "\000"
+        ; Mon, "MON", "\001"
+        ; Tue, "TUE", "\002"
+        ; Wed, "WED", "\003"
+        ; Thu, "THU", "\004"
+        ; Fri, "FRI", "\005"
+        ; Sat, "SAT", "\006"
+        ]
+      ;;
+    end))
 ;;
 
 let%test _ = List.is_sorted all ~compare
@@ -40,7 +40,7 @@ let%test "num_days is inverse to shift"
 ;;
 
 let%expect_test "validate sexp grammar" =
-  Sexp_grammar_validation.validate_grammar (module Day_of_week) |> require_ok [%here];
+  Sexp_grammar_validation.validate_grammar (module Day_of_week) |> require_ok;
   [%expect
     {|
     (Variant
Index: core-0.17.1/core/test/test_deque.ml
===================================================================
--- core-0.17.1.orig/core/test/test_deque.ml
+++ core-0.17.1/core/test/test_deque.ml
@@ -7,7 +7,11 @@ let%test _ = length (create ()) = 0
 
 let%test_module _ =
   (module struct
-    let binary_search = binary_search ~compare:Int.compare
+    let binary_search ?pos ?len t target key =
+      (binary_search ?pos ?len t ~compare:Int.compare target key
+       |> [%globalize: int option]) [@nontail]
+    ;;
+
     let t = of_array [| 1; 2; 3; 4 |]
     let%test _ = [%equal: int option] (binary_search t `First_equal_to 2) (Some 1)
     let%test _ = [%equal: int option] (binary_search t `First_equal_to 5) None
Index: core-0.17.1/core/test/test_doubly_linked.ml
===================================================================
--- core-0.17.1.orig/core/test/test_doubly_linked.ml
+++ core-0.17.1/core/test/test_doubly_linked.ml
@@ -24,8 +24,8 @@ let%expect_test "empty" =
      ("last t"    ())
      ("to_list t" ()))
     |}];
-  require_none [%here] [%sexp_of: int] (remove_first t);
-  require_none [%here] [%sexp_of: int] (remove_last t)
+  require_none [%sexp_of: int] (remove_first t);
+  require_none [%sexp_of: int] (remove_last t)
 ;;
 
 let%expect_test "singleton" =
@@ -40,8 +40,8 @@ let%expect_test "singleton" =
      ("last t"    (13))
      ("to_list t" (13)))
     |}];
-  require [%here] (is_first t elt);
-  require [%here] (is_last t elt)
+  require (is_first t elt);
+  require (is_last t elt)
 ;;
 
 let%expect_test "pair" =
@@ -57,8 +57,8 @@ let%expect_test "pair" =
      ("last t"  (14))
      ("to_list t" (13 14)))
     |}];
-  require [%here] (is_first t elt1);
-  require [%here] (is_last t elt2)
+  require (is_first t elt1);
+  require (is_last t elt2)
 ;;
 
 let%expect_test "of_list" =
@@ -66,7 +66,6 @@ let%expect_test "of_list" =
     let l = List.init i ~f:Fn.id in
     let t = of_list l in
     require_equal
-      [%here]
       (module struct
         type t = int list [@@deriving equal, sexp_of]
       end)
@@ -79,7 +78,7 @@ let%expect_test "clear" =
   for i = 0 to 5 do
     let t = of_list (List.init i ~f:Fn.id) in
     clear t;
-    require [%here] (is_empty t)
+    require (is_empty t)
   done
 ;;
 
@@ -91,9 +90,8 @@ let%expect_test "transfer" =
       let t1 = of_list l1 in
       let t2 = of_list l2 in
       transfer ~src:t1 ~dst:t2;
-      require [%here] (is_empty t1);
+      require (is_empty t1);
       require_equal
-        [%here]
         (module struct
           type t = int list [@@deriving equal, sexp_of]
         end)
@@ -109,13 +107,13 @@ let%expect_test "transfer2" =
   let l2 = create () in
   transfer ~src:l1 ~dst:l2;
   remove l2 e;
-  require [%here] (is_empty l1);
-  require [%here] (is_empty l2)
+  require (is_empty l1);
+  require (is_empty l2)
 ;;
 
 let%expect_test "self-transfer" =
   let t = of_list [] in
-  require_does_raise [%here] (fun () -> transfer ~src:t ~dst:t);
+  require_does_raise (fun () -> transfer ~src:t ~dst:t);
   [%expect {| (Core__Doubly_linked.Transfer_src_and_dst_are_same_list) |}]
 ;;
 
@@ -128,7 +126,7 @@ let%expect_test "transfer3" =
   transfer ~src ~dst;
   print_s [%message (src : int t) (dst : int t)];
   [%expect {| ((src ()) (dst (1 2 3 4 1 4))) |}];
-  require_does_not_raise [%here] (fun () -> ignore (next dst elt : _ Elt.t option))
+  require_does_not_raise (fun () -> ignore (next dst elt : _ Elt.t option))
 ;;
 
 let%expect_test "insert and remove" =
@@ -145,7 +143,6 @@ let%expect_test "insert and remove" =
   let t = create () in
   let is_elts elts =
     require_equal
-      [%here]
       (module struct
         type t = unit list [@@deriving equal, sexp_of]
       end)
@@ -155,7 +152,7 @@ let%expect_test "insert and remove" =
       match elt, elts with
       | None, [] -> ()
       | Some elt, elt' :: elts ->
-        require_equal [%here] (module Elt) elt elt';
+        require_equal (module Elt) elt elt';
         loop (next t elt) elts
       | _ -> assert false
     in
@@ -163,28 +160,28 @@ let%expect_test "insert and remove" =
     (match elts with
      | [] -> ()
      | elt :: elts ->
-       require_none [%here] [%sexp_of: Elt.t] (prev t elt);
-       require [%here] (is_first t elt);
-       require_equal [%here] (module Elt_option) (first_elt t) (Some elt);
-       List.iter elts ~f:(fun elt -> require [%here] (not (is_first t elt)));
+       require_none [%sexp_of: Elt.t] (prev t elt);
+       require (is_first t elt);
+       require_equal (module Elt_option) (first_elt t) (Some elt);
+       List.iter elts ~f:(fun elt -> require (not (is_first t elt)));
        ignore
          (List.fold elts ~init:elt ~f:(fun prev_elt elt ->
-            require_equal [%here] (module Elt_option) (prev t elt) (Some prev_elt);
+            require_equal (module Elt_option) (prev t elt) (Some prev_elt);
             elt)
-           : Elt.t));
+          : Elt.t));
     match List.rev elts with
     | [] -> ()
     | elt :: elts ->
       (* [elt] is the last elt.  each of [elts] is not last. *)
-      require_none [%here] [%sexp_of: Elt.t] (next t elt);
-      require [%here] (is_last t elt);
-      require_equal [%here] (module Elt_option) (last_elt t) (Some elt);
-      List.iter elts ~f:(fun elt -> require [%here] (not (is_last t elt)));
+      require_none [%sexp_of: Elt.t] (next t elt);
+      require (is_last t elt);
+      require_equal (module Elt_option) (last_elt t) (Some elt);
+      List.iter elts ~f:(fun elt -> require (not (is_last t elt)));
       ignore
         (List.fold elts ~init:elt ~f:(fun next_elt elt ->
            assert (Option.equal Elt.equal (next t elt) (Some next_elt));
            elt)
-          : Elt.t)
+         : Elt.t)
   in
   let elt1 = insert_first t () in
   is_elts [ elt1 ];
@@ -212,8 +209,8 @@ let%expect_test "removed element doesn't
   let t = of_list [ 1 ] in
   let e = insert_first t 2 in
   invariant ignore t;
-  require_some [%here] (remove_first t);
-  require_does_raise [%here] (fun () -> is_last t e);
+  require_some (remove_first t);
+  require_does_raise (fun () -> is_last t e);
   [%expect {| (Core__Doubly_linked.Elt_does_not_belong_to_list) |}]
 ;;
 
@@ -223,13 +220,13 @@ let%expect_test _ =
   invariant ignore t;
   remove t e;
   invariant ignore t;
-  require_some [%here] (first_elt t)
+  require_some (first_elt t)
 ;;
 
 let%expect_test _ =
   let t = of_list [ 1; 2 ] in
-  require_does_not_raise [%here] (fun _ -> [%test_result: int] ~expect:1 (first_exn t));
-  require_does_not_raise [%here] (fun _ -> [%test_result: int] ~expect:2 (last_exn t))
+  require_does_not_raise (fun _ -> [%test_result: int] ~expect:1 (first_exn t));
+  require_does_not_raise (fun _ -> [%test_result: int] ~expect:2 (last_exn t))
 ;;
 
 let%expect_test _ =
@@ -253,7 +250,8 @@ let%expect_test "length" =
   [%expect {| ("length l2" 3) |}];
   transfer ~src:l1 ~dst:l2;
   print_s [%message (length l1 : int) (length l2 : int)];
-  [%expect {|
+  [%expect
+    {|
     (("length l1" 0)
      ("length l2" 8))
     |}]
@@ -515,12 +513,13 @@ let%test_unit "findi_elt" =
 let%expect_test "[iter] does not allocate" =
   let t = create () in
   ignore (insert_first t () : _ Elt.t);
-  require_no_allocation [%here] (fun () -> iter t ~f:ignore)
+  require_no_allocation (fun () -> iter t ~f:ignore)
 ;;
 
 let%expect_test "iteri" =
   iteri (create_default ()) ~f:(fun i v -> printf "f %d %d\n" i v);
-  [%expect {|
+  [%expect
+    {|
     f 0 0
     f 1 10
     f 2 20
@@ -531,7 +530,8 @@ let%expect_test "iteri" =
 
 let%expect_test "iteri_elt" =
   iteri_elt (create_default ()) ~f:(fun i elt -> printf "f %d %d\n" i (Elt.value elt));
-  [%expect {|
+  [%expect
+    {|
     f 0 0
     f 1 10
     f 2 20
@@ -577,7 +577,8 @@ let%expect_test "fold_right_elt" =
     printf "f %d %d\n" (Elt.value elt) acc;
     acc + 1)
   |> printf "result: %d";
-  [%expect {|
+  [%expect
+    {|
     f 40 0
     f 30 1
     f 20 2
@@ -610,7 +611,7 @@ let%expect_test _ =
   let t1 = create () in
   let t2 = create () in
   let elt = insert_first t1 15 in
-  require_does_raise [%here] (fun () -> remove t2 elt);
+  require_does_raise (fun () -> remove t2 elt);
   [%expect {| (Core__Doubly_linked.Elt_does_not_belong_to_list) |}]
 ;;
 
@@ -619,7 +620,7 @@ let%expect_test _ =
   let t2 = create () in
   let elt = insert_first t1 14 in
   let (_ : int Elt.t) = insert_first t2 13 in
-  require_does_raise [%here] (fun () -> remove t2 elt);
+  require_does_raise (fun () -> remove t2 elt);
   [%expect {| (Core__Doubly_linked.Elt_does_not_belong_to_list) |}]
 ;;
 
@@ -627,7 +628,7 @@ let%expect_test _ =
   let t1 = create () in
   let t2 = create () in
   let elt = insert_first t1 14 in
-  require_does_raise [%here] (fun () -> next t2 elt);
+  require_does_raise (fun () -> next t2 elt);
   [%expect {| (Core__Doubly_linked.Elt_does_not_belong_to_list) |}]
 ;;
 
@@ -720,7 +721,6 @@ let%test_module "mutation during iterati
 
     let require_mutation_didn't_happen () =
       require_equal
-        [%here]
         (module struct
           type t = int list [@@deriving equal, sexp_of]
         end)
@@ -729,33 +729,33 @@ let%test_module "mutation during iterati
     ;;
 
     let%expect_test "remove" =
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         iter t ~f:(fun _ -> ignore (remove_first t : int option)));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ();
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         iter t ~f:(fun _ -> ignore (remove_last t : int option)));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ();
-      require_does_raise [%here] (fun () -> iter t ~f:(fun _ -> remove t e));
+      require_does_raise (fun () -> iter t ~f:(fun _ -> remove t e));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ()
     ;;
 
     let%expect_test "insert" =
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         iter t ~f:(fun _ -> ignore (insert_first t 4 : int Elt.t)));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ();
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         iter t ~f:(fun _ -> ignore (insert_last t 5 : int Elt.t)));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ();
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         iter t ~f:(fun _ -> ignore (insert_before t e 6 : int Elt.t)));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ();
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         iter t ~f:(fun _ -> ignore (insert_after t e 7 : int Elt.t)));
       [%expect {| (Core__Doubly_linked.Attempt_to_mutate_list_during_iteration) |}];
       require_mutation_didn't_happen ()
Index: core-0.17.1/core/test/test_doubly_linked_bisimulation.ml
===================================================================
--- core-0.17.1.orig/core/test/test_doubly_linked_bisimulation.ml
+++ core-0.17.1/core/test/test_doubly_linked_bisimulation.ml
@@ -235,9 +235,9 @@ module Foil : S = struct
     assert_no_pending_readers t;
     e.root <- create ();
     t.elts
-      <- (match z.before with
-          | [] -> z.after
-          | hd :: tl -> elts_of_zipper { z with before = tl; cursor = hd })
+    <- (match z.before with
+        | [] -> z.after
+        | hd :: tl -> elts_of_zipper { z with before = tl; cursor = hd })
   ;;
 
   let remove_first t =
Index: core-0.17.1/core/test/test_fdeque.ml
===================================================================
--- core-0.17.1.orig/core/test/test_fdeque.ml
+++ core-0.17.1/core/test/test_fdeque.ml
@@ -7,8 +7,8 @@ let%expect_test _ =
     invariant (ignore : int -> unit) q;
     let list = to_list q in
     print_s [%sexp (list : int list)];
-    require_equal [%here] (module Int) (length q) (List.length list);
-    require_equal [%here] (module Bool) (is_empty q) (List.is_empty list)
+    require_equal (module Int) (length q) (List.length list);
+    require_equal (module Bool) (is_empty q) (List.is_empty list)
   in
   let q0 = of_list [ 1; 2; 3; 4; 5 ] in
   show q0;
@@ -22,19 +22,17 @@ let%expect_test _ =
   let q3 = enqueue_back q2 0 in
   show q3;
   [%expect {| (3 4 5 0) |}];
-  require_equal [%here] (module Int) (peek_front_exn q3) 3;
-  require_equal [%here] (module Int) (peek_back_exn q3) 0;
+  require_equal (module Int) (peek_front_exn q3) 3;
+  require_equal (module Int) (peek_back_exn q3) 0;
   require_equal
-    [%here]
     (module struct
       type t = int list [@@deriving equal, sexp_of]
     end)
     (to_list (drop_front_exn q0))
     (to_list q1);
-  require [%here] (not (is_empty q3));
-  require [%here] (is_empty (Fn.apply_n_times drop_front_exn ~n:4 q3));
+  require (not (is_empty q3));
+  require (is_empty (Fn.apply_n_times drop_front_exn ~n:4 q3));
   require_equal
-    [%here]
     (module struct
       type t = int list [@@deriving equal, sexp_of]
     end)
@@ -148,7 +146,7 @@ let%test_unit "Arbitrary_order doesn't d
     |> of_list
     |> Arbitrary_order.to_sequence
     |> Sequence.fold ~init:Int.Map.empty ~f:(fun acc key ->
-         Map.update acc key ~f:(fun existing -> 1 + Option.value ~default:0 existing))
+      Map.update acc key ~f:(fun existing -> 1 + Option.value ~default:0 existing))
   in
   [%test_result: int Int.Map.t] ~expect arbitrary_order_elements
 ;;
Index: core-0.17.1/core/test/test_float.ml
===================================================================
--- core-0.17.1.orig/core/test/test_float.ml
+++ core-0.17.1/core/test/test_float.ml
@@ -15,13 +15,15 @@ let%expect_test "[Sexp.of_float_style] i
     print_s [%sexp (f : Core.Core_stable.float)]
   in
   print ();
-  [%expect {|
+  [%expect
+    {|
     1234.5678
     1234.5678
     1234.5678
     |}];
   Ref.set_temporarily Sexp.of_float_style `Underscores ~f:print;
-  [%expect {|
+  [%expect
+    {|
     1_234.5678
     1_234.5678
     1_234.5678
@@ -35,7 +37,7 @@ let%expect_test "[Sexp.of_float_style =
     in
     print_s [%sexp (sexp `No_underscores : Sexp.t), (sexp `Underscores : Sexp.t)];
     if not (Float.is_nan f)
-    then require [%here] (Float.equal f (sexp `Underscores |> [%of_sexp: Float.t]))
+    then require (Float.equal f (sexp `Underscores |> [%of_sexp: Float.t]))
   in
   List.iter
     [ 0.
@@ -52,8 +54,8 @@ let%expect_test "[Sexp.of_float_style =
     ; Float.nan
     ]
     ~f:(fun f ->
-    check f;
-    check (-.f));
+      check f;
+      check (-.f));
   Expect_test_patterns.require_match
     [%here]
     {|
@@ -86,11 +88,7 @@ let%expect_test "[Sexp.of_float_style =
 let%expect_test "Terse.sexp_of_t" =
   let test number =
     let string = Float.Terse.to_string number in
-    require_equal
-      [%here]
-      (module String)
-      string
-      (Sexp.to_string (Float.Terse.sexp_of_t number));
+    require_equal (module String) string (Sexp.to_string (Float.Terse.sexp_of_t number));
     print_endline string
   in
   test 0.0123456789;
@@ -148,13 +146,13 @@ let%expect_test (_ [@tags "64-bits-only"
   (* a.(0) is unboxed *)
   let one = 1. in
   (* [one] is boxed *)
-  ignore (require_no_allocation [%here] (fun () -> Float.( > ) a.(0) 0.) : bool);
+  ignore (require_no_allocation (fun () -> Float.( > ) a.(0) 0.) : bool);
   [%expect {| |}];
-  ignore (require_no_allocation [%here] (fun () -> Float.compare a.(0) 0. > 0) : bool);
+  ignore (require_no_allocation (fun () -> Float.compare a.(0) 0. > 0) : bool);
   [%expect {| |}];
-  ignore (require_no_allocation [%here] (fun () -> Float.is_positive a.(0)) : bool);
+  ignore (require_no_allocation (fun () -> Float.is_positive a.(0)) : bool);
   [%expect {| |}];
-  ignore (require_no_allocation [%here] (fun () -> Float.is_positive one) : bool);
+  ignore (require_no_allocation (fun () -> Float.is_positive one) : bool);
   [%expect {| |}]
 ;;
 
@@ -317,7 +315,7 @@ let%test_unit _ = test_class gen_nan Nan
 (* Additional tests of Base.Float requiring the Gc module *)
 
 let%expect_test (_ [@tags "64-bits-only"]) =
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     [%test_result: Int63.t] (int63_round_nearest_exn 0.8) ~expect:(Int63.of_int_exn 1));
   [%expect {| |}]
 ;;
@@ -356,8 +354,8 @@ let%expect_test ("iround does not force
                  allocation, so we don't check anything here. *)
               | exception _ -> ()
               | `minor minor, `major major ->
-                require_equal [%here] (module Int) minor 0;
-                require_equal [%here] (module Int) major 0
+                require_equal (module Int) minor 0;
+                require_equal (module Int) major 0
             done))
     with
     | Stop_the_test -> ()
@@ -375,7 +373,7 @@ let%expect_test ("iround does not force
 ;;
 
 let%expect_test "Float.validate_positive doesn't allocate on success" =
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     ignore (Sys.opaque_identity (validate_positive 1.) : Validate.t));
   [%expect {| |}]
 ;;
Index: core-0.17.1/core/test/test_hash_queue.ml
===================================================================
--- core-0.17.1.orig/core/test/test_hash_queue.ml
+++ core-0.17.1/core/test/test_hash_queue.ml
@@ -18,17 +18,17 @@ let%expect_test _ =
   inv ();
   assert (Hq.is_empty hq);
   assert (Option.is_none (Hq.dequeue_front hq));
-  require_does_raise [%here] (fun () -> Hq.dequeue_front_exn hq);
+  require_does_raise (fun () -> Hq.dequeue_front_exn hq);
   [%expect {| "Hash_queue.dequeue_exn: empty queue" |}];
   assert (Option.is_none (Hq.dequeue_front_with_key hq));
-  require_does_raise [%here] (fun () -> Hq.dequeue_front_with_key_exn hq);
+  require_does_raise (fun () -> Hq.dequeue_front_with_key_exn hq);
   [%expect {| "Hash_queue.dequeue_with_key: empty queue" |}];
   Hq.dequeue_all hq ~f:(fun _ -> assert false);
   assert (Poly.( = ) (Hq.remove hq "foobar") `No_such_key);
-  require_does_raise [%here] (fun () -> Hq.remove_exn hq "foobar");
+  require_does_raise (fun () -> Hq.remove_exn hq "foobar");
   [%expect {| ("Hash_queue.remove_exn: unknown key" foobar) |}];
   assert (Poly.( = ) (Hq.replace hq "foobar" 0) `No_such_key);
-  require_does_raise [%here] (fun () -> Hq.replace_exn hq "foobar" 0);
+  require_does_raise (fun () -> Hq.replace_exn hq "foobar" 0);
   [%expect {| ("Hash_queue.replace_exn: unknown key" foobar) |}];
   assert (List.is_empty (Hq.foldi hq ~init:[] ~f:(fun ac ~key:_ ~data:_ -> () :: ac)));
   assert (List.is_empty (Hq.fold hq ~init:[] ~f:(fun ac _ -> () :: ac)));
@@ -81,17 +81,17 @@ let%expect_test _ =
   done;
   (* double booking *)
   assert (Poly.( = ) (Hq.enqueue_back hq "42" 42) `Key_already_present);
-  require_does_raise [%here] (fun () -> Hq.enqueue_back_exn hq "42" 42);
+  require_does_raise (fun () -> Hq.enqueue_back_exn hq "42" 42);
   [%expect {| ("Hash_queue.enqueue_exn: duplicate key" 42) |}];
   assert (Poly.( = ) (Hq.replace hq "1" 42) `Ok);
   assert ([%equal: int option] (Hq.lookup hq "1") (Some 42));
   assert (Hq.lookup_exn hq "1" = 42);
   assert ([%equal: (string * int) option] (Hq.dequeue_front_with_key hq) (Some ("1", 42)));
   assert (Poly.( = ) (Hq.replace hq "1" 42) `No_such_key);
-  require_does_raise [%here] (fun () -> Hq.replace_exn hq "1" 42);
+  require_does_raise (fun () -> Hq.replace_exn hq "1" 42);
   [%expect {| ("Hash_queue.replace_exn: unknown key" 1) |}];
   assert ([%equal: int option] (Hq.lookup hq "1") None);
-  require_does_raise [%here] (fun () : int -> Hq.lookup_exn hq "1");
+  require_does_raise (fun () : int -> Hq.lookup_exn hq "1");
   [%expect {| (Not_found_s ("Hashtbl.find_exn: not found" 1)) |}];
   Hq.clear hq;
   assert (Hq.is_empty hq);
@@ -99,10 +99,10 @@ let%expect_test _ =
   List.iter [ 1; 2; 3 ] ~f:add;
   assert ([%equal: string list] [ "1"; "2"; "3" ] (Hq.keys hq));
   assert ([%equal: (string * int) list] [ "1", 1; "2", 2; "3", 3 ] (Hq.to_alist hq));
-  require_does_raise [%here] (fun () -> Hq.iter hq ~f:(fun _ -> add 13));
+  require_does_raise (fun () -> Hq.iter hq ~f:(fun _ -> add 13));
   [%expect
     {| (Failure "It is an error to modify a Hash_queue.t while iterating over it.") |}];
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Hq.iter hq ~f:(fun _ -> ignore (Hq.remove hq "foo" : [ `No_such_key | `Ok ])));
   [%expect
     {| (Failure "It is an error to modify a Hash_queue.t while iterating over it.") |}];
@@ -137,7 +137,7 @@ let%expect_test "enqueue_front, enqueue_
   for i = 1 to n do
     Hq.enqueue_front_exn hq2 (string_of_int i) i
   done;
-  require [%here] ([%compare.equal: int list] (Hq.to_list hq2) (Hq.to_list hq))
+  require ([%compare.equal: int list] (Hq.to_list hq2) (Hq.to_list hq))
 ;;
 
 let test_enqueue_fn (back_or_front : [ `back | `front ]) enqueue_fn =
@@ -222,7 +222,8 @@ let%expect_test "dequeue_back, dequeue_b
   for _ = 1 to 10 do
     print_s [%sexp (Hq.dequeue_back_exn hq : int)]
   done;
-  [%expect {|
+  [%expect
+    {|
     1
     2
     3
@@ -326,7 +327,8 @@ let%expect_test "[replace_or_enqueue_bac
   Hq.replace_or_enqueue_back hq "key1" "value1";
   Hq.replace_or_enqueue_back hq "key2" "value2";
   print_s [%sexp (hq : string Hq.t)];
-  [%expect {|
+  [%expect
+    {|
     ((key1 value1)
      (key2 value2))
     |}]
@@ -339,7 +341,8 @@ let%expect_test "[replace_or_enqueue_fro
   Hq.replace_or_enqueue_front hq "key1" "value1";
   Hq.replace_or_enqueue_front hq "key2" "value2";
   print_s [%sexp (hq : string Hq.t)];
-  [%expect {|
+  [%expect
+    {|
     ((key2 value2)
      (key1 value1))
     |}]
@@ -370,7 +373,7 @@ let%expect_test "[replace_or_enqueue] ra
   =
   let hq = Hq.create () in
   Hq.replace_or_enqueue_front hq "key1" "value1";
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Hq.iter hq ~f:(fun _ -> Hq.replace_or_enqueue_front hq "key2" "value2"));
   [%expect
     {| (Failure "It is an error to modify a Hash_queue.t while iterating over it.") |}]
Index: core-0.17.1/core/test/test_hexdump.ml
===================================================================
--- core-0.17.1.orig/core/test/test_hexdump.ml
+++ core-0.17.1/core/test/test_hexdump.ml
@@ -3,7 +3,7 @@ open Expect_test_helpers_core
 
 let require_same here (name1, string1) (name2, string2) =
   require
-    here
+    ~here
     (String.equal string1 string2)
     ~if_false_then_print_s:
       (lazy
Index: core-0.17.1/core/test/test_host_and_port.ml
===================================================================
--- core-0.17.1.orig/core/test/test_host_and_port.ml
+++ core-0.17.1/core/test/test_host_and_port.ml
@@ -3,7 +3,6 @@ open! Import
 
 let%expect_test "validate sexp grammar" =
   require_ok
-    [%here]
     (Sexp_grammar_validation.validate_grammar
        (module struct
          type t = Host_and_port.Stable.V1.t [@@deriving quickcheck, sexp, sexp_grammar]
Index: core-0.17.1/core/test/test_identifiable.ml
===================================================================
--- core-0.17.1.orig/core/test/test_identifiable.ml
+++ core-0.17.1/core/test/test_identifiable.ml
@@ -30,9 +30,9 @@ let%test_module _ =
 
       let incr ?(by = 1) t counter =
         t
-          := Core.Map.update !t counter ~f:(function
-               | None -> by
-               | Some i -> i + by)
+        := Core.Map.update !t counter ~f:(function
+             | None -> by
+             | Some i -> i + by)
       ;;
 
       let check location =
@@ -55,8 +55,8 @@ let%test_module _ =
       [@@deriving bin_io, compare, hash, sexp]
 
       include Sexpable.To_stringable (struct
-        type nonrec t = t [@@deriving sexp]
-      end)
+          type nonrec t = t [@@deriving sexp]
+        end)
 
       let incr ?by counter = Counts.incr Counts.actual counter ?by
 
Index: core-0.17.1/core/test/test_map.ml
===================================================================
--- core-0.17.1.orig/core/test/test_map.ml
+++ core-0.17.1/core/test/test_map.ml
@@ -5,7 +5,7 @@ open! Map
 let%expect_test "Tree.add duplicate does not allocate" =
   let tree = Tree.of_alist_exn ~comparator:Int.comparator [ 1, 1; 2, 2 ] in
   let result =
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       Tree.add ~comparator:Int.comparator tree ~key:2 ~data:2)
   in
   print_s [%sexp (result : _ Map_intf.Or_duplicate.t)];
@@ -15,12 +15,11 @@ let%expect_test "Tree.add duplicate does
 let%expect_test "t_of_sexp raises on duplicate key" =
   let no_dup_sexp = Sexp.of_string "((a 1) (b 2) (c 3) (d 4))" in
   require_equal
-    [%here]
     (module Sexp)
     no_dup_sexp
     ([%sexp_of: int String.Map.t] ([%of_sexp: int String.Map.t] no_dup_sexp));
   let dup_sexp = Sexp.of_string "((a 1) (b 2) (a 3) (d 4))" in
-  require_does_raise [%here] (fun () -> [%of_sexp: int String.Map.t] dup_sexp);
+  require_does_raise (fun () -> [%of_sexp: int String.Map.t] dup_sexp);
   [%expect {| (Of_sexp_error "Map.t_of_sexp_direct: duplicate key" (invalid_sexp a)) |}]
 ;;
 
@@ -30,12 +29,11 @@ let%expect_test "bin_read_t raises on du
   for n = 0 to max_n do
     let m1 = Int.Map.of_alist_exn (List.init n ~f:(fun x -> x, succ x)) in
     let pos = Int.Map.bin_write_t Int.bin_write_t bstr ~pos:0 m1 in
-    require_equal [%here] (module Int) pos ((2 * n) + 1);
+    require_equal (module Int) pos ((2 * n) + 1);
     let pos_ref = ref 0 in
     let m2 = Int.Map.bin_read_t Int.bin_read_t bstr ~pos_ref in
-    require_equal [%here] (module Int) !pos_ref ((2 * n) + 1);
+    require_equal (module Int) !pos_ref ((2 * n) + 1);
     require_equal
-      [%here]
       (module struct
         type t = int Int.Map.t [@@deriving equal, sexp_of]
       end)
@@ -46,10 +44,9 @@ let%expect_test "bin_read_t raises on du
       bstr.{1} <- 'x';
       bstr.{3} <- 'x';
       pos_ref := 0;
-      require_does_raise [%here] (fun () ->
-        Int.Map.bin_read_t Int.bin_read_t bstr ~pos_ref);
+      require_does_raise (fun () -> Int.Map.bin_read_t Int.bin_read_t bstr ~pos_ref);
       [%expect {| (Failure "Map.bin_read_t: duplicate element in map") |}];
-      require_equal [%here] (module Int) !pos_ref ((2 * n) + 1))
+      require_equal (module Int) !pos_ref ((2 * n) + 1))
   done
 ;;
 
@@ -92,13 +89,12 @@ let%expect_test "Symmetric_diff_element.
 let%expect_test _ =
   let open Expect_test_helpers_core in
   print_and_check_stable_type
-    [%here]
     (module struct
       type t = int Map.M(Int).t [@@deriving bin_io, compare, sexp]
     end)
     ([ []; [ 1 ]; [ 1; 2 ]; [ 1; 2; 3 ] ]
      |> List.map ~f:(fun xs ->
-          Map.of_alist_exn (module Int) (xs |> List.map ~f:(fun x -> x, x + 1))));
+       Map.of_alist_exn (module Int) (xs |> List.map ~f:(fun x -> x, x + 1))));
   [%expect
     {|
     (bin_shape_digest ed73a010af8ffc32cab7411d6be2d676)
@@ -121,10 +117,8 @@ let%expect_test "remove does not allocat
   (* This is a regression test. Previously this no-op remove allocated 16 words.
 
      Ideally, we wouldn't allocate the pair returned by [Tree0.remove] either. *)
-  Expect_test_helpers_core.require_allocation_does_not_exceed
-    (Minor_words 3)
-    [%here]
-    (fun () -> ignore (Sys.opaque_identity (Map.remove map1 2) : string Map.M(Int).t))
+  Expect_test_helpers_core.require_allocation_does_not_exceed (Minor_words 3) (fun () ->
+    ignore (Sys.opaque_identity (Map.remove map1 2) : string Map.M(Int).t))
 ;;
 
 let%expect_test "[map_keys]" =
Index: core-0.17.1/core/test/test_map_interface.ml
===================================================================
--- core-0.17.1.orig/core/test/test_map_interface.ml
+++ core-0.17.1/core/test/test_map_interface.ml
@@ -8,24 +8,24 @@ module _ : sig
 
     include
       Creators_and_accessors_generic
-        with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-        with type ('a, 'b, 'c) tree := ('a, 'b, 'c) t
-        with type 'c cmp := 'c
-        with type 'k key := 'k
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) t
+      with type 'c cmp := 'c
+      with type 'k key := 'k
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
   end
 
   type ('a, 'b, 'c) t
 
   include
     Creators_and_accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
-      with type ('a, 'cmp, 'z) access_options := ('a, 'cmp, 'z) Without_comparator.t
-      with type ('a, 'cmp, 'z) create_options :=
-        ('a, 'cmp, 'z) Map_intf.With_first_class_module.t
-      with type 'k key := 'k
-      with type 'c cmp := 'c
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
+    with type ('a, 'cmp, 'z) access_options := ('a, 'cmp, 'z) Without_comparator.t
+    with type ('a, 'cmp, 'z) create_options :=
+      ('a, 'cmp, 'z) Map_intf.With_first_class_module.t
+    with type 'k key := 'k
+    with type 'c cmp := 'c
 end =
   Map
Index: core-0.17.1/core/test/test_maybe_bound.ml
===================================================================
--- core-0.17.1.orig/core/test/test_maybe_bound.ml
+++ core-0.17.1/core/test/test_maybe_bound.ml
@@ -50,7 +50,6 @@ let%test_module "[As_lower_bound.compare
     let test_compare compare bound1 bound2 ok =
       let comparison = compare bound1 bound2 in
       require
-        [%here]
         (ok comparison)
         ~if_false_then_print_s:
           (lazy
@@ -83,7 +82,7 @@ let%test_module "[As_lower_bound.compare
             let compare = Ord.compare in
             if As_lower_bound.compare compare t1 t2 <= 0
                && is_lower_bound t2 ~of_:a ~compare
-            then require [%here] (is_lower_bound t1 ~of_:a ~compare))))
+            then require (is_lower_bound t1 ~of_:a ~compare))))
     ;;
 
     let%expect_test "relationship between [As_upper_bound.compare] and [is_upper_bound]" =
@@ -93,7 +92,7 @@ let%test_module "[As_lower_bound.compare
             let compare = Ord.compare in
             if As_upper_bound.compare compare t1 t2 <= 0
                && is_upper_bound t1 ~of_:a ~compare
-            then require [%here] (is_upper_bound t2 ~of_:a ~compare))))
+            then require (is_upper_bound t2 ~of_:a ~compare))))
     ;;
   end)
 ;;
Index: core-0.17.1/core/test/test_md5.ml
===================================================================
--- core-0.17.1.orig/core/test/test_md5.ml
+++ core-0.17.1/core/test/test_md5.ml
@@ -17,38 +17,38 @@ let%expect_test "digest_bin_prot" =
 
 let%test_module "Md5.As_binary_string.V1" =
   (module Stable_unit_test.Make (struct
-    include As_binary_string.Stable.V1
+      include As_binary_string.Stable.V1
 
-    let equal = [%compare.equal: t]
+      let equal = [%compare.equal: t]
 
-    let tests =
-      [ ( digest_string ""
-        , {|"\212\029\140\217\143\000\178\004\233\128\t\152\236\248B~"|}
-        , "\016\212\029\140\217\143\000\178\004\233\128\t\152\236\248B~" )
-      ; ( digest_string "x"
-        , {|"\157\212\228a&\140\1284\245\200VN\021\\g\166"|}
-        , "\016\157\212\228a&\140\1284\245\200VN\021\\g\166" )
-      ]
-    ;;
-  end))
+      let tests =
+        [ ( digest_string ""
+          , {|"\212\029\140\217\143\000\178\004\233\128\t\152\236\248B~"|}
+          , "\016\212\029\140\217\143\000\178\004\233\128\t\152\236\248B~" )
+        ; ( digest_string "x"
+          , {|"\157\212\228a&\140\1284\245\200VN\021\\g\166"|}
+          , "\016\157\212\228a&\140\1284\245\200VN\021\\g\166" )
+        ]
+      ;;
+    end))
 ;;
 
 let%test_module "Md5.V1" =
   (module Stable_unit_test.Make (struct
-    include Stable.V1
+      include Stable.V1
 
-    let equal = [%compare.equal: t]
+      let equal = [%compare.equal: t]
 
-    let tests =
-      [ ( digest_string ""
-        , "d41d8cd98f00b204e9800998ecf8427e"
-        , "\212\029\140\217\143\000\178\004\233\128\t\152\236\248B~" )
-      ; ( digest_string "x"
-        , "9dd4e461268c8034f5c8564e155c67a6"
-        , "\157\212\228a&\140\1284\245\200VN\021\\g\166" )
-      ]
-    ;;
-  end))
+      let tests =
+        [ ( digest_string ""
+          , "d41d8cd98f00b204e9800998ecf8427e"
+          , "\212\029\140\217\143\000\178\004\233\128\t\152\236\248B~" )
+        ; ( digest_string "x"
+          , "9dd4e461268c8034f5c8564e155c67a6"
+          , "\157\212\228a&\140\1284\245\200VN\021\\g\166" )
+        ]
+      ;;
+    end))
 ;;
 
 let%test_unit "Md5.digest_file_blocking" =
Index: core-0.17.1/core/test/test_memo.ml
===================================================================
--- core-0.17.1.orig/core/test/test_memo.ml
+++ core-0.17.1/core/test/test_memo.ml
@@ -5,10 +5,7 @@ open! Memo
 let%expect_test "general" =
   let f x = x * x in
   let memo_f = Memo.general f in
-  quickcheck_m
-    [%here]
-    (module Int)
-    ~f:(fun x -> require_equal [%here] (module Int) (f x) (memo_f x))
+  quickcheck_m (module Int) ~f:(fun x -> require_equal (module Int) (f x) (memo_f x))
 ;;
 
 let%test_module "lru" =
@@ -70,7 +67,8 @@ let%test_module "comparable" =
     let%expect_test "Ensure no re computation" =
       let { Env.should_raise; f } = Env.create () in
       printf "%d" (f 5);
-      [%expect {|
+      [%expect
+        {|
         ("Computing value" (i 5))
         6
         |}];
Index: core-0.17.1/core/test/test_modes.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_modes.ml
@@ -0,0 +1,104 @@
+open! Core
+open Expect_test_helpers_core
+
+let single_example_string = "Az1_ \000\255"
+let example_chars = String.to_list single_example_string
+
+let example_strings =
+  List.init
+    (String.length single_example_string + 1)
+    ~f:(fun n -> String.prefix single_example_string n)
+;;
+
+module type Type = sig
+  type 'a t [@@deriving bin_io, compare, sexp, stable_witness]
+
+  val wrap : 'a -> 'a t
+end
+
+let test (module Type : Type) ~expect =
+  (* Test [Type] to see conversions. *)
+  print_and_check_stable_type
+    (module struct
+      type t = Char.Stable.V1.t Type.t [@@deriving bin_io, compare, sexp]
+    end)
+    (List.map ~f:Type.wrap example_chars);
+  print_and_check_stable_type
+    (module struct
+      type t = String.Stable.V1.t Type.t [@@deriving bin_io, compare, sexp]
+    end)
+    (List.map ~f:Type.wrap example_strings);
+  expect ();
+  (* Now test without [Type] using the same [[%expect]] block to see that behavior and
+     bin-shape are unchanged. *)
+  print_and_check_stable_type
+    (module struct
+      type t = Char.Stable.V1.t [@@deriving bin_io, compare, sexp]
+    end)
+    example_chars;
+  print_and_check_stable_type
+    (module struct
+      type t = String.Stable.V1.t [@@deriving bin_io, compare, sexp]
+    end)
+    example_strings;
+  expect ()
+;;
+
+module _ : module type of struct
+  include Modes.Stable
+end [@remove_aliases] = struct
+  module Global = struct
+    module V1 = struct
+      type 'a t = 'a Modes.Stable.Global.V1.t
+      [@@deriving bin_io, compare, sexp, stable_witness]
+
+      let map = Modes.Stable.Global.V1.map
+
+      let%expect_test _ =
+        test
+          (module struct
+            include Modes.Stable.Global.V1
+
+            let wrap = Modes.Global.wrap
+          end)
+          ~expect:(fun () ->
+            [%expect
+              {|
+              (bin_shape_digest 84610d32d63dcff5c93f1033ec8cb1d5)
+              ((sexp   A)
+               (bin_io A))
+              ((sexp   z)
+               (bin_io z))
+              ((sexp   1)
+               (bin_io 1))
+              ((sexp   _)
+               (bin_io _))
+              ((sexp   " ")
+               (bin_io " "))
+              ((sexp   "\000")
+               (bin_io "\000"))
+              ((sexp   "\255")
+               (bin_io "\255"))
+              (bin_shape_digest d9a8da25d5656b016fb4dbdc2e4197fb)
+              ((sexp   "")
+               (bin_io "\000"))
+              ((sexp   A)
+               (bin_io "\001A"))
+              ((sexp   Az)
+               (bin_io "\002Az"))
+              ((sexp   Az1)
+               (bin_io "\003Az1"))
+              ((sexp   Az1_)
+               (bin_io "\004Az1_"))
+              ((sexp   "Az1_ ")
+               (bin_io "\005Az1_ "))
+              ((sexp   "Az1_ \000")
+               (bin_io "\006Az1_ \000"))
+              ((sexp   "Az1_ \000\255")
+               (bin_io "\007Az1_ \000\255"))
+              |}]);
+        [%expect {| |}]
+      ;;
+    end
+  end
+end
Index: core-0.17.1/core/test/test_month.ml
===================================================================
--- core-0.17.1.orig/core/test/test_month.ml
+++ core-0.17.1/core/test/test_month.ml
@@ -4,32 +4,32 @@ open! Month
 
 let%test_module "Month.V1" =
   (module Stable_unit_test.Make (struct
-    include Stable.V1
+      include Stable.V1
 
-    let equal t1 t2 = Int.( = ) 0 (compare t1 t2)
+      let equal t1 t2 = Int.( = ) 0 (compare t1 t2)
 
-    let tests =
-      let module V = Variant in
-      let c rank sexp bin_io tests variant =
-        assert (Int.( = ) variant.V.rank rank);
-        (variant.V.constructor, sexp, bin_io) :: tests
-      in
-      Variants.fold
-        ~init:[]
-        ~jan:(c 0 "Jan" "\000")
-        ~feb:(c 1 "Feb" "\001")
-        ~mar:(c 2 "Mar" "\002")
-        ~apr:(c 3 "Apr" "\003")
-        ~may:(c 4 "May" "\004")
-        ~jun:(c 5 "Jun" "\005")
-        ~jul:(c 6 "Jul" "\006")
-        ~aug:(c 7 "Aug" "\007")
-        ~sep:(c 8 "Sep" "\008")
-        ~oct:(c 9 "Oct" "\009")
-        ~nov:(c 10 "Nov" "\010")
-        ~dec:(c 11 "Dec" "\011")
-    ;;
-  end))
+      let tests =
+        let module V = Variant in
+        let c rank sexp bin_io tests variant =
+          assert (Int.( = ) variant.V.rank rank);
+          (variant.V.constructor, sexp, bin_io) :: tests
+        in
+        Variants.fold
+          ~init:[]
+          ~jan:(c 0 "Jan" "\000")
+          ~feb:(c 1 "Feb" "\001")
+          ~mar:(c 2 "Mar" "\002")
+          ~apr:(c 3 "Apr" "\003")
+          ~may:(c 4 "May" "\004")
+          ~jun:(c 5 "Jun" "\005")
+          ~jul:(c 6 "Jul" "\006")
+          ~aug:(c 7 "Aug" "\007")
+          ~sep:(c 8 "Sep" "\008")
+          ~oct:(c 9 "Oct" "\009")
+          ~nov:(c 10 "Nov" "\010")
+          ~dec:(c 11 "Dec" "\011")
+      ;;
+    end))
 ;;
 
 let%test _ = Int.( = ) (List.length all) 12
@@ -54,7 +54,7 @@ let%test _ = shift Sep 1 = Oct
 let%test _ = shift Sep (-1) = Aug
 
 let%expect_test "validate sexp grammar" =
-  Sexp_grammar_validation.validate_grammar (module Month) |> require_ok [%here];
+  Sexp_grammar_validation.validate_grammar (module Month) |> require_ok;
   [%expect
     {|
     (Variant
Index: core-0.17.1/core/test/test_nothing.ml
===================================================================
--- core-0.17.1.orig/core/test/test_nothing.ml
+++ core-0.17.1/core/test/test_nothing.ml
@@ -2,7 +2,7 @@ open! Core
 open! Import
 
 let%expect_test "t_of_sexp" =
-  require_does_raise [%here] (fun () -> Nothing.t_of_sexp (Sexp.List []));
+  require_does_raise (fun () -> Nothing.t_of_sexp (Sexp.List []));
   [%expect
     {|
     (Of_sexp_error
@@ -16,7 +16,7 @@ let%test_module "Stable.V1" =
     module Nothing = Nothing.Stable.V1
 
     let%expect_test "t_of_sexp" =
-      require_does_raise [%here] (fun () -> Nothing.t_of_sexp (Sexp.List []));
+      require_does_raise (fun () -> Nothing.t_of_sexp (Sexp.List []));
       [%expect
         {|
         (Of_sexp_error
Index: core-0.17.1/core/test/test_option.ml
===================================================================
--- core-0.17.1.orig/core/test/test_option.ml
+++ core-0.17.1/core/test/test_option.ml
@@ -27,7 +27,7 @@ let%test_module "shrinker" =
 
 let%expect_test "unsafe_value" =
   let test x =
-    require [%here] (phys_equal x (Optional_syntax.Optional_syntax.unsafe_value (Some x)))
+    require (phys_equal x (Optional_syntax.Optional_syntax.unsafe_value (Some x)))
   in
   test 5;
   [%expect {| |}];
Index: core-0.17.1/core/test/test_percent.ml
===================================================================
--- core-0.17.1.orig/core/test/test_percent.ml
+++ core-0.17.1/core/test/test_percent.ml
@@ -2,29 +2,31 @@ open! Core
 open! Expect_test_helpers_core
 open! Percent
 
-module Stable_unit_test (T : sig
-  type t = Percent.t
-
-  include Binable with type t := t
-  include Sexpable with type t := t
-end) (Version : sig
-  val v : int
-end) =
+module Stable_unit_test
+    (T : sig
+       type t = Percent.t
+
+       include Binable with type t := t
+       include Sexpable with type t := t
+     end)
+    (Version : sig
+       val v : int
+     end) =
 Stable_unit_test.Make (struct
-  include T
+    include T
 
-  let equal = equal
+    let equal = equal
 
-  let tests =
-    [ of_mult 0.375, "37.5%", "\000\000\000\000\000\000\216?"
-    ; of_mult 4.5, "4.5x", "\000\000\000\000\000\000\018@"
-    ; of_mult 0.0002, "2bp", "-C\028\235\2266*?"
-    ; ( of_mult 0.000075
-      , (if Int.(Version.v < 3) then "0.75bp" else "7.5E-1bp")
-      , "a2U0*\169\019?" )
-    ]
-  ;;
-end)
+    let tests =
+      [ of_mult 0.375, "37.5%", "\000\000\000\000\000\000\216?"
+      ; of_mult 4.5, "4.5x", "\000\000\000\000\000\000\018@"
+      ; of_mult 0.0002, "2bp", "-C\028\235\2266*?"
+      ; ( of_mult 0.000075
+        , (if Int.(Version.v < 3) then "0.75bp" else "7.5E-1bp")
+        , "a2U0*\169\019?" )
+      ]
+    ;;
+  end)
 
 let%test_module "Percent.V1.Bin_shape_same_as_float" =
   (module Stable_unit_test
@@ -189,7 +191,6 @@ let%test_unit _ =
 
 let%expect_test _ =
   print_and_check_comparable_sexps
-    [%here]
     (module Percent)
     [ Percent.zero; Percent.of_bp 15.; Percent.of_percentage 15.; Percent.of_mult 15. ];
   [%expect
@@ -241,7 +242,7 @@ let%expect_test "generator" =
 let%expect_test ("to_mult and of_mult no boxing in arrays" [@tags "fast-flambda"]) =
   let float_arr = Array.init 1 ~f:(fun i -> Float.of_int i) in
   let percent_arr = Array.create ~len:1 Percent.zero in
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     percent_arr.(0) <- Percent.of_mult float_arr.(0);
     float_arr.(0) <- Percent.to_mult percent_arr.(0))
 ;;
@@ -258,7 +259,8 @@ let%expect_test "always-percentage forma
   in
   let cases = [ "0x"; "3.2bp"; "5x"; "75%" ] in
   List.iter ~f cases;
-  [%expect {|
+  [%expect
+    {|
     0x -> 0%
     3.2bp -> 0.032%
     5x -> 500%
@@ -441,14 +443,15 @@ let%expect_test "Percent.Map serializati
 let%expect_test "nans and infs" =
   [ Float.nan; Float.infinity; Float.neg_infinity ]
   |> List.iter ~f:(fun p ->
-       let p = Percent.of_mult p in
-       let s1 = Percent.to_string p in
-       let s2 = Percent.Stable.V3.to_string p in
-       printf "%s | %s\n" s1 s2;
-       let p1 = Percent.of_string_allow_nan_and_inf s1 in
-       let p2 = Percent.Stable.V3.of_string_allow_nan_and_inf s2 in
-       assert (Percent.((is_nan p1 && is_nan p2) || p1 = p2)));
-  [%expect {|
+    let p = Percent.of_mult p in
+    let s1 = Percent.to_string p in
+    let s2 = Percent.Stable.V3.to_string p in
+    printf "%s | %s\n" s1 s2;
+    let p1 = Percent.of_string_allow_nan_and_inf s1 in
+    let p2 = Percent.Stable.V3.of_string_allow_nan_and_inf s2 in
+    assert (Percent.((is_nan p1 && is_nan p2) || p1 = p2)));
+  [%expect
+    {|
     NANbp | NANx
     INFx | INFx
     -INFx | -INFx
@@ -468,9 +471,9 @@ let%expect_test "nans and infs" =
   ; "-Inf%"
   ]
   |> List.iter ~f:(fun s ->
-       let p1 = Percent.of_string_allow_nan_and_inf s in
-       let p2 = Percent.Stable.V3.of_string_allow_nan_and_inf s in
-       assert (Percent.((is_nan p1 && is_nan p2) || p1 = p2)))
+    let p1 = Percent.of_string_allow_nan_and_inf s in
+    let p2 = Percent.Stable.V3.of_string_allow_nan_and_inf s in
+    assert (Percent.((is_nan p1 && is_nan p2) || p1 = p2)))
 ;;
 
 let%expect_test "slow_more_accurate" =
@@ -499,7 +502,8 @@ let%expect_test "slow_more_accurate" =
   ; Percent.to_bp_slow_more_accurate
   ]
   |> List.iter ~f:(fun f -> printf !"%{Float}\n" (f p));
-  [%expect {|
+  [%expect
+    {|
     57.199999999999996
     5719.9999999999991
     57.2
@@ -542,11 +546,11 @@ let%expect_test "parse errors" =
     ; "-infinity%"
     ]
     ~f:(fun s ->
-    let s1 =
-      try Percent.of_string s |> Percent.to_string_round_trippable with
-      | exn -> Exn.to_string_mach exn
-    in
-    printf "%s\n====\n" s1);
+      let s1 =
+        try Percent.of_string s |> Percent.to_string_round_trippable with
+        | exn -> Exn.to_string_mach exn
+      in
+      printf "%s\n====\n" s1);
   [%expect
     {|
     (Failure"Percent.of_string: must end in x, %, or bp: +34.27")
Index: core-0.17.1/core/test/test_printf.ml
===================================================================
--- core-0.17.1.orig/core/test/test_printf.ml
+++ core-0.17.1/core/test/test_printf.ml
@@ -21,7 +21,7 @@ let%expect_test "collect_to_string - try
   [%expect {| |}];
   print_s [%sexp (output : string)];
   [%expect {| inside |}];
-  Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+  Expect_test_helpers_base.require_does_raise (fun () ->
     (Set_once.get_exn captured_printf [%here]) "outside");
   [%expect {| "[printf] used after [collect_to_string] returned" |}]
 ;;
Index: core-0.17.1/core/test/test_queue.ml
===================================================================
--- core-0.17.1.orig/core/test/test_queue.ml
+++ core-0.17.1/core/test/test_queue.ml
@@ -2,41 +2,41 @@ open! Core
 
 let%test_module _ =
   (module (
-             struct
-               include Base.Queue
-               (* Base.Queue is tested separately. Here we test the additions from Core. *)
-
-               open Core.Queue
-
-               type nonrec 'a t = 'a t [@@deriving bin_io]
-
-               let binary_search = binary_search
-               let binary_search_segmented = binary_search_segmented
-
-               (* Tested where instantiated using [Test_binary_searchable.Make1_and_test] *)
-
-               module Stable = struct
-                 module V1 = Stable.V1
-
-                 include Stable_unit_test.Make (struct
-                   type nonrec t = int V1.t [@@deriving sexp, bin_io, compare]
-
-                   let equal = [%compare.equal: t]
-
-                   let tests =
-                     let manipulated = Queue.of_list [ 0; 3; 6; 1 ] in
-                     ignore (Queue.dequeue_exn manipulated : int);
-                     ignore (Queue.dequeue_exn manipulated : int);
-                     Queue.enqueue manipulated 4;
-                     [ Queue.of_list [], "()", "\000"
-                     ; Queue.of_list [ 1; 2; 6; 4 ], "(1 2 6 4)", "\004\001\002\006\004"
-                     ; manipulated, "(6 1 4)", "\003\006\001\004"
-                     ]
-                   ;;
-                 end)
-               end
-             end
-             (* This signature is here to remind us to update the unit tests whenever we
+  struct
+    include Base.Queue
+    (* Base.Queue is tested separately. Here we test the additions from Core. *)
+
+    open Core.Queue
+
+    type nonrec 'a t = 'a t [@@deriving bin_io, quickcheck]
+
+    let binary_search = binary_search
+    let binary_search_segmented = binary_search_segmented
+
+    (* Tested where instantiated using [Test_binary_searchable.Make1_and_test] *)
+
+    module Stable = struct
+      module V1 = Stable.V1
+
+      include Stable_unit_test.Make (struct
+          type nonrec t = int V1.t [@@deriving sexp, bin_io, compare]
+
+          let equal = [%compare.equal: t]
+
+          let tests =
+            let manipulated = Queue.of_list [ 0; 3; 6; 1 ] in
+            ignore (Queue.dequeue_exn manipulated : int);
+            ignore (Queue.dequeue_exn manipulated : int);
+            Queue.enqueue manipulated 4;
+            [ Queue.of_list [], "()", "\000"
+            ; Queue.of_list [ 1; 2; 6; 4 ], "(1 2 6 4)", "\004\001\002\006\004"
+            ; manipulated, "(6 1 4)", "\003\006\001\004"
+            ]
+          ;;
+        end)
+    end
+  end
+  (* This signature is here to remind us to update the unit tests whenever we
       change [Queue]. *) :
-               module type of Queue))
+    module type of Queue))
 ;;
Index: core-0.17.1/core/test/test_quickcheck_signature.ml
===================================================================
--- core-0.17.1.orig/core/test/test_quickcheck_signature.ml
+++ core-0.17.1/core/test/test_quickcheck_signature.ml
@@ -1,11 +1,11 @@
 open! Core
 
 module Foo (X : sig
-  type t
+    type t
 
-  include Comparable.S with type t := t
-  include Quickcheckable with type t := t
-end) =
+    include Comparable.S with type t := t
+    include Quickcheckable with type t := t
+  end) =
 struct
   type t1 = Set.M(X).t [@@deriving quickcheck]
   type t2 = unit Map.M(X).t [@@deriving quickcheck]
Index: core-0.17.1/core/test/test_quickcheck_signature.mli
===================================================================
--- core-0.17.1.orig/core/test/test_quickcheck_signature.mli
+++ core-0.17.1/core/test/test_quickcheck_signature.mli
@@ -3,11 +3,11 @@ open! Core
 (*_ Check that the signature generated by deriving quickcheck is able to unify with the
   corresponding implementation. *)
 module Foo (X : sig
-  type t
+    type t
 
-  include Comparable.S with type t := t
-  include Quickcheckable with type t := t
-end) : sig
+    include Comparable.S with type t := t
+    include Quickcheckable with type t := t
+  end) : sig
   type t1 = Set.M(X).t [@@deriving quickcheck]
   type t2 = unit Map.M(X).t [@@deriving quickcheck]
 end
Index: core-0.17.1/core/test/test_sequence.ml
===================================================================
--- core-0.17.1.orig/core/test/test_sequence.ml
+++ core-0.17.1/core/test/test_sequence.ml
@@ -129,7 +129,7 @@ let%expect_test "merge_all" =
     |}];
   (* During a Quickcheck test we want to bail out after a single failure. *)
   let require_exn here ?if_false_then_print_s bool =
-    require here bool ?if_false_then_print_s;
+    require ~here bool ?if_false_then_print_s;
     if not bool then raise_s [%message "failed on random input"]
   in
   let quickcheck_generator =
Index: core-0.17.1/core/test/test_set_interface.ml
===================================================================
--- core-0.17.1.orig/core/test/test_set_interface.ml
+++ core-0.17.1/core/test/test_set_interface.ml
@@ -8,27 +8,27 @@ module _ : sig
 
     include
       Creators_and_accessors_generic
-        with type ('a, 'b) set := ('a, 'b) t
-        with type ('a, 'b) t := ('a, 'b) t
-        with type ('a, 'b) tree := ('a, 'b) t
-        with type 'a elt := 'a
-        with type 'c cmp := 'c
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
+      with type ('a, 'b) set := ('a, 'b) t
+      with type ('a, 'b) t := ('a, 'b) t
+      with type ('a, 'b) tree := ('a, 'b) t
+      with type 'a elt := 'a
+      with type 'c cmp := 'c
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
   end
 
   type ('a, 'b) t
 
   include
     Creators_and_accessors_generic
-      with type ('a, 'b) set := ('a, 'b) t
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) Tree.t
-      with type 'a elt := 'a
-      with type 'a cmp := 'a
-      with type ('a, 'cmp, 'z) create_options :=
-        ('a, 'cmp, 'z) Set_intf.With_first_class_module.t
-      with type ('a, 'cmp, 'z) access_options :=
-        ('a, 'cmp, 'z) Set_intf.Without_comparator.t
+    with type ('a, 'b) set := ('a, 'b) t
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) Tree.t
+    with type 'a elt := 'a
+    with type 'a cmp := 'a
+    with type ('a, 'cmp, 'z) create_options :=
+      ('a, 'cmp, 'z) Set_intf.With_first_class_module.t
+    with type ('a, 'cmp, 'z) access_options :=
+      ('a, 'cmp, 'z) Set_intf.Without_comparator.t
 end =
   Set
Index: core-0.17.1/core/test/test_set_once.ml
===================================================================
--- core-0.17.1.orig/core/test/test_set_once.ml
+++ core-0.17.1/core/test/test_set_once.ml
@@ -16,7 +16,7 @@ let test_serialization (module Format :
   let t1 = create () in
   let t2 = create () in
   set_exn t2 [%here] 13;
-  print_and_check_stable_type [%here] (module T) [ t1; t2 ]
+  print_and_check_stable_type (module T) [ t1; t2 ]
 ;;
 
 let%expect_test "[Stable.V1] serialization" =
@@ -74,7 +74,7 @@ let%expect_test "[get]" =
 let%expect_test "[get] doesn't allocate" =
   let t = create () in
   let check_get here =
-    ignore (require_no_allocation here (fun () -> get t) : int option)
+    ignore (require_no_allocation ~here (fun () -> get t) : int option)
   in
   check_get [%here];
   [%expect {| |}];
@@ -143,13 +143,15 @@ let%expect_test "[is_none], [is_some]" =
     print_s [%message "" ~is_none:(is_none t : bool) ~is_some:(is_some t : bool)]
   in
   show ();
-  [%expect {|
+  [%expect
+    {|
     ((is_none true)
      (is_some false))
     |}];
   set_exn t [%here] 13;
   show ();
-  [%expect {|
+  [%expect
+    {|
     ((is_none false)
      (is_some true))
     |}]
Index: core-0.17.1/core/test/test_sexp.ml
===================================================================
--- core-0.17.1.orig/core/test/test_sexp.ml
+++ core-0.17.1/core/test/test_sexp.ml
@@ -26,7 +26,7 @@ module _ = struct
   let t' = il_of_text (text t)
 
   let%expect_test _ =
-    require_equal [%here] (module IL) (value t') [ 3; 4 ];
+    require_equal (module IL) (value t') [ 3; 4 ];
     [%expect {| |}]
   ;;
 
@@ -36,17 +36,12 @@ module _ = struct
   ;;
 
   let%expect_test _ =
-    require_equal
-      [%here]
-      (module IL)
-      (value (t_of_sexp il_of_sexp (Atom "(3 4)")))
-      [ 3; 4 ];
+    require_equal (module IL) (value (t_of_sexp il_of_sexp (Atom "(3 4)"))) [ 3; 4 ];
     [%expect {| |}]
   ;;
 
   let%expect_test _ =
     require_equal
-      [%here]
       (module IL)
       [ 8; 9 ]
       (value (il_of_text ";this is a comment\n (8; foo\n 9)   \n "));
@@ -54,14 +49,13 @@ module _ = struct
   ;;
 
   let%expect_test _ =
-    require_does_raise [%here] (fun () -> il_of_text "(1 2 bla)");
+    require_does_raise (fun () -> il_of_text "(1 2 bla)");
     [%expect
       {| (Of_sexp_error :1:5 "int_of_sexp: (Failure int_of_string)" (invalid_sexp bla)) |}]
   ;;
 
   let%expect_test _ =
-    require_does_raise [%here] (fun () ->
-      t_of_sexp il_of_sexp (Sexp.of_string "\"(1 2 bla)\""));
+    require_does_raise (fun () -> t_of_sexp il_of_sexp (Sexp.of_string "\"(1 2 bla)\""));
     [%expect
       {| (Of_sexp_error :1:5 "int_of_sexp: (Failure int_of_string)" (invalid_sexp bla)) |}]
   ;;
Index: core-0.17.1/core/test/test_stable.ml
===================================================================
--- core-0.17.1.orig/core/test/test_stable.ml
+++ core-0.17.1/core/test/test_stable.ml
@@ -32,62 +32,67 @@ let%expect_test "older [int_of_sexp] sup
 module _ = struct
   let%test_module "Hashtbl.V1" =
     (module Stable_unit_test.Make_unordered_container (struct
-      module Hashable = Core_stable.Hashable.V1.Make (Int)
-      module Table = Hashable.Table
+        module Hashable = Core_stable.Hashable.V1.Make (Int)
+        module Table = Hashable.Table
+
+        type t = string Table.t [@@deriving sexp, bin_io]
+
+        let equal t1 t2 = Int.Table.equal String.equal t1 t2
+
+        let triple_table =
+          Int.Table.of_alist_exn ~size:16 [ 1, "foo"; 2, "bar"; 3, "baz" ]
+        ;;
+
+        let single_table = Int.Table.of_alist_exn [ 0, "foo" ]
+
+        module Test = Stable_unit_test.Unordered_container_test
+
+        let tests =
+          [ ( triple_table
+            , { Test.sexps = [ "(1 foo)"; "(2 bar)"; "(3 baz)" ]
+              ; bin_io_header = "\003"
+              ; bin_io_elements = [ "\001\003foo"; "\002\003bar"; "\003\003baz" ]
+              } )
+          ; ( Int.Table.create ()
+            , { Test.sexps = []; bin_io_header = "\000"; bin_io_elements = [] } )
+          ; ( single_table
+            , { Test.sexps = [ "(0 foo)" ]
+              ; bin_io_header = "\001"
+              ; bin_io_elements = [ "\000\003foo" ]
+              } )
+          ]
+        ;;
+      end))
+  ;;
+end
 
-      type t = string Table.t [@@deriving sexp, bin_io]
+let%test_module "Hash_set.V1" =
+  (module Stable_unit_test.Make_unordered_container (struct
+      module Hashable = Core_stable.Hashable.V1.Make (Int)
+      include Hashable.Hash_set
 
-      let equal t1 t2 = Int.Table.equal String.equal t1 t2
-      let triple_table = Int.Table.of_alist_exn ~size:16 [ 1, "foo"; 2, "bar"; 3, "baz" ]
-      let single_table = Int.Table.of_alist_exn [ 0, "foo" ]
+      let equal = Hash_set.equal
+      let int_list = List.init 10 ~f:Fn.id
+      let ten_set = Int.Hash_set.of_list ~size:32 int_list
+      let single_set = Int.Hash_set.of_list [ 0 ]
 
       module Test = Stable_unit_test.Unordered_container_test
 
       let tests =
-        [ ( triple_table
-          , { Test.sexps = [ "(1 foo)"; "(2 bar)"; "(3 baz)" ]
-            ; bin_io_header = "\003"
-            ; bin_io_elements = [ "\001\003foo"; "\002\003bar"; "\003\003baz" ]
+        [ ( ten_set
+          , { Test.sexps = List.init 10 ~f:Int.to_string
+            ; bin_io_header = "\010"
+            ; bin_io_elements =
+                List.init 10 ~f:(fun n -> Char.to_string (Char.of_int_exn n))
             } )
-        ; ( Int.Table.create ()
+        ; ( Int.Hash_set.create ()
           , { Test.sexps = []; bin_io_header = "\000"; bin_io_elements = [] } )
-        ; ( single_table
-          , { Test.sexps = [ "(0 foo)" ]
-            ; bin_io_header = "\001"
-            ; bin_io_elements = [ "\000\003foo" ]
-            } )
+        ; ( single_set
+          , { Test.sexps = [ "0" ]; bin_io_header = "\001"; bin_io_elements = [ "\000" ] }
+          )
         ]
       ;;
     end))
-  ;;
-end
-
-let%test_module "Hash_set.V1" =
-  (module Stable_unit_test.Make_unordered_container (struct
-    module Hashable = Core_stable.Hashable.V1.Make (Int)
-    include Hashable.Hash_set
-
-    let equal = Hash_set.equal
-    let int_list = List.init 10 ~f:Fn.id
-    let ten_set = Int.Hash_set.of_list ~size:32 int_list
-    let single_set = Int.Hash_set.of_list [ 0 ]
-
-    module Test = Stable_unit_test.Unordered_container_test
-
-    let tests =
-      [ ( ten_set
-        , { Test.sexps = List.init 10 ~f:Int.to_string
-          ; bin_io_header = "\010"
-          ; bin_io_elements =
-              List.init 10 ~f:(fun n -> Char.to_string (Char.of_int_exn n))
-          } )
-      ; ( Int.Hash_set.create ()
-        , { Test.sexps = []; bin_io_header = "\000"; bin_io_elements = [] } )
-      ; ( single_set
-        , { Test.sexps = [ "0" ]; bin_io_header = "\001"; bin_io_elements = [ "\000" ] } )
-      ]
-    ;;
-  end))
 ;;
 
 module _ = struct
@@ -97,21 +102,21 @@ module _ = struct
   end
 
   module Test (F : F) = Stable_unit_test.Make (struct
-    include F (Int)
+      include F (Int)
 
-    type nonrec t = string t [@@deriving sexp, bin_io]
+      type nonrec t = string t [@@deriving sexp, bin_io]
 
-    let equal = Map.equal String.equal
+      let equal = Map.equal String.equal
 
-    let tests =
-      [ ( Int.Map.of_alist_exn [ 1, "foo"; 2, "bar"; 3, "baz" ]
-        , "((1 foo) (2 bar) (3 baz))"
-        , "\003\001\003foo\002\003bar\003\003baz" )
-      ; Int.Map.empty, "()", "\000"
-      ; Int.Map.singleton 0 "foo", "((0 foo))", "\001\000\003foo"
-      ]
-    ;;
-  end)
+      let tests =
+        [ ( Int.Map.of_alist_exn [ 1, "foo"; 2, "bar"; 3, "baz" ]
+          , "((1 foo) (2 bar) (3 baz))"
+          , "\003\001\003foo\002\003bar\003\003baz" )
+        ; Int.Map.empty, "()", "\000"
+        ; Int.Map.singleton 0 "foo", "((0 foo))", "\001\000\003foo"
+        ]
+      ;;
+    end)
 
   let%test_module "Map.V1" = (module Test (Map.Stable.V1.Make))
 
@@ -132,19 +137,19 @@ module _ = struct
   end
 
   module Test (F : F) = Stable_unit_test.Make (struct
-    include F (Int)
+      include F (Int)
 
-    let equal = Set.equal
+      let equal = Set.equal
 
-    let tests =
-      [ ( Int.Set.of_list (List.init 10 ~f:Fn.id)
-        , "(0 1 2 3 4 5 6 7 8 9)"
-        , "\010\000\001\002\003\004\005\006\007\008\009" )
-      ; Int.Set.empty, "()", "\000"
-      ; Int.Set.singleton 0, "(0)", "\001\000"
-      ]
-    ;;
-  end)
+      let tests =
+        [ ( Int.Set.of_list (List.init 10 ~f:Fn.id)
+          , "(0 1 2 3 4 5 6 7 8 9)"
+          , "\010\000\001\002\003\004\005\006\007\008\009" )
+        ; Int.Set.empty, "()", "\000"
+        ; Int.Set.singleton 0, "(0)", "\001\000"
+        ]
+      ;;
+    end)
 
   let%test_module "Set.V1" = (module Test (Set.Stable.V1.Make))
 
Index: core-0.17.1/core/test/test_staged.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_staged.ml
@@ -0,0 +1,10 @@
+open! Core
+
+(* Test both bindings of [stage]/[unstage] on locals. *)
+let%expect_test "local" =
+  let string = "printme" in
+  print_endline (String.globalize (Staged.unstage (Staged.stage string)));
+  [%expect {| printme |}];
+  print_endline (String.globalize (unstage (stage string)));
+  [%expect {| printme |}]
+;;
Index: core-0.17.1/core/test/test_staged.mli
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_staged.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
Index: core-0.17.1/core/test/test_string.ml
===================================================================
--- core-0.17.1.orig/core/test/test_string.ml
+++ core-0.17.1/core/test/test_string.ml
@@ -26,11 +26,11 @@ let%test_module "slice" =
 
 let%test_module "nget" =
   (module struct
-    let%expect_test _ = require_equal [%here] (module Char) (nget "hey" (-3)) 'h'
-    let%expect_test _ = require_equal [%here] (module Char) (nget "hey" 2) 'y'
+    let%expect_test _ = require_equal (module Char) (nget "hey" (-3)) 'h'
+    let%expect_test _ = require_equal (module Char) (nget "hey" 2) 'y'
 
     let%expect_test _ =
-      require_does_raise [%here] (fun () -> nget "hey" (-100));
+      require_does_raise (fun () -> nget "hey" (-100));
       [%expect {| (Invalid_argument "index out of bounds") |}]
     ;;
   end)
@@ -76,7 +76,8 @@ let%test_module "Verify reading/writing
 
     let%expect_test "sexp_of_t" =
       print_s [%sexp (table : string String.Stable.V1.Table.t)];
-      [%expect {|
+      [%expect
+        {|
         ((alpha beta)
          (delta gamma))
         |}]
@@ -90,13 +91,13 @@ let%test_module "Verify reading/writing
 ;;
 
 let%expect_test "Hashtbl.merge of String.Table and String.Stable.V1.Table" =
-  Expect_test_helpers_core.require_does_not_raise [%here] (fun () ->
+  Expect_test_helpers_core.require_does_not_raise (fun () ->
     let result =
       Hashtbl.merge
         (String.Table.t_of_sexp int_of_sexp [%sexp []])
         (String.Stable.V1.Table.t_of_sexp int_of_sexp [%sexp []])
         ~f:(fun ~key:_ x -> Some x)
     in
-    require [%here] (Hashtbl.is_empty result));
+    require (Hashtbl.is_empty result));
   [%expect {| |}]
 ;;
Index: core-0.17.1/core/test/test_string_id.ml
===================================================================
--- core-0.17.1.orig/core/test/test_string_id.ml
+++ core-0.17.1/core/test/test_string_id.ml
@@ -220,7 +220,8 @@ let%test_module "Verify reading/writing
 
     let%expect_test "sexp_of_t" =
       print_s [%sexp (table : t String_id.Stable.V1.Table.t)];
-      [%expect {|
+      [%expect
+        {|
         ((alpha beta)
          (delta gamma))
         |}]
Index: core-0.17.1/core/test/test_substring.ml
===================================================================
--- core-0.17.1.orig/core/test/test_substring.ml
+++ core-0.17.1/core/test/test_substring.ml
@@ -2,12 +2,13 @@ open! Core
 open Poly
 open! Import
 
-module Test (Base : sig
-  type t
-
-  val of_string : string -> t
-end)
-(Substring : Substring.S with type base = Base.t) : sig end = struct
+module Test
+    (Base : sig
+       type t
+
+       val of_string : string -> t
+     end)
+    (Substring : Substring.S with type base = Base.t) : sig end = struct
   open Substring
 
   let%test_module "get" =
@@ -139,18 +140,18 @@ let%test_module "quickcheck" =
         ~sexp_of:sexp_of_substring_for_test
         Substring.quickcheck_generator
         ~f:(fun sub ->
-        let base_len = Bytes.length (Substring.base sub) in
-        (* whole substring of nontrivial string *)
-        base_len > 0 && Substring.length sub = base_len);
+          let base_len = Bytes.length (Substring.base sub) in
+          (* whole substring of nontrivial string *)
+          base_len > 0 && Substring.length sub = base_len);
       Quickcheck.test_can_generate
         ~sexp_of:sexp_of_substring_for_test
         Substring.quickcheck_generator
         ~f:(fun sub ->
-        let pos = Substring.pos sub in
-        let len = Substring.length sub in
-        (* non-triviality: contains at least one character and excludes at least one
+          let pos = Substring.pos sub in
+          let len = Substring.length sub in
+          (* non-triviality: contains at least one character and excludes at least one
              character from each end *)
-        pos > 0 && len > 0 && pos + len < Bytes.length (Substring.base sub));
+          pos > 0 && len > 0 && pos + len < Bytes.length (Substring.base sub));
       [%expect ""]
     ;;
 
@@ -159,13 +160,13 @@ let%test_module "quickcheck" =
         ~sexp_of:sexp_of_substring_for_test
         Substring.quickcheck_generator
         ~f:(fun sub ->
-        [%test_result: bytes]
-          ~expect:
-            (Bytes.sub
-               (Substring.base sub)
-               ~pos:(Substring.pos sub)
-               ~len:(Substring.length sub))
-          (Bytes.of_string (Substring.to_string sub)))
+          [%test_result: bytes]
+            ~expect:
+              (Bytes.sub
+                 (Substring.base sub)
+                 ~pos:(Substring.pos sub)
+                 ~len:(Substring.length sub))
+            (Bytes.of_string (Substring.to_string sub)))
     ;;
 
     let%expect_test "sexp_of_t" =
@@ -173,14 +174,14 @@ let%test_module "quickcheck" =
         ~sexp_of:sexp_of_substring_for_test
         Substring.quickcheck_generator
         ~f:(fun sub ->
-        [%test_result: Sexp.t]
-          ~expect:
-            (Bytes.sub
-               (Substring.base sub)
-               ~pos:(Substring.pos sub)
-               ~len:(Substring.length sub)
-             |> Bytes.sexp_of_t)
-          (Substring.sexp_of_t sub))
+          [%test_result: Sexp.t]
+            ~expect:
+              (Bytes.sub
+                 (Substring.base sub)
+                 ~pos:(Substring.pos sub)
+                 ~len:(Substring.length sub)
+               |> Bytes.sexp_of_t)
+            (Substring.sexp_of_t sub))
     ;;
 
     let%expect_test "prefixes and suffixes" =
@@ -204,13 +205,14 @@ let%test_module "quickcheck" =
             ~sexp_of:[%sexp_of: substring_for_test * int]
             sub_and_n
             ~f:(fun (sub, n) ->
-            let str = Substring.to_string sub in
-            let via_str = Option.try_with (fun () -> f_str str n) in
-            let via_sub =
-              Option.try_with (fun () -> f_sub sub n) |> Option.map ~f:Substring.to_string
-            in
-            if Option.is_some via_str && Option.is_some via_sub
-            then [%test_result: string option] ~expect:via_str via_sub))
+              let str = Substring.to_string sub in
+              let via_str = Option.try_with (fun () -> f_str str n) in
+              let via_sub =
+                Option.try_with (fun () -> f_sub sub n)
+                |> Option.map ~f:Substring.to_string
+              in
+              if Option.is_some via_str && Option.is_some via_sub
+              then [%test_result: string option] ~expect:via_str via_sub))
     ;;
   end)
 ;;
Index: core-0.17.1/core/test/test_time.ml
===================================================================
--- core-0.17.1.orig/core/test/test_time.ml
+++ core-0.17.1/core/test/test_time.ml
@@ -18,7 +18,7 @@ let examples =
 ;;
 
 let%expect_test "Time.Stable.With_utc_sexp.V2" =
-  print_and_check_stable_type [%here] (module Time_float.Stable.With_utc_sexp.V2) examples;
+  print_and_check_stable_type (module Time_float.Stable.With_utc_sexp.V2) examples;
   [%expect
     {|
     (bin_shape_digest 1fd923acb2dd9c5d401ad5b08b1d40cd)
@@ -49,7 +49,6 @@ let span_examples =
 
 let%expect_test "Time.Stable.Span.V1" =
   print_and_check_stable_type
-    [%here]
     (module struct
       include Time_float.Stable.Span.V1
 
@@ -129,11 +128,7 @@ let%expect_test "Time.Stable.Span.V1" =
 ;;
 
 let%expect_test "Time.Stable.Span.V2" =
-  print_and_check_stable_type
-    [%here]
-    (module Time_float.Stable.Span.V2)
-    ~cr:Comment
-    span_examples;
+  print_and_check_stable_type (module Time_float.Stable.Span.V2) ~cr:Comment span_examples;
   [%expect
     {|
     (bin_shape_digest 1fd923acb2dd9c5d401ad5b08b1d40cd)
@@ -236,7 +231,7 @@ let%test_module "Time.Stable.Span.V3" =
     ;;
 
     let%expect_test "serialization tests" =
-      print_and_check_stable_type [%here] (module Time_float.Stable.Span.V3) span_examples;
+      print_and_check_stable_type (module Time_float.Stable.Span.V3) span_examples;
       [%expect
         {|
         (bin_shape_digest 1fd923acb2dd9c5d401ad5b08b1d40cd)
@@ -351,7 +346,6 @@ let%test_module "Time.Stable.Span.V3" =
 
     let%expect_test ("serialization tests for NaNs" [@tags "64-bits-only"]) =
       print_and_check_stable_type
-        [%here]
         (module Time_float.Stable.Span.V3)
         [ Time_float.Span.of_sec Float.nan
         ; Time_float.Span.of_sec Float.nan |> Time_float.Span.neg
@@ -375,7 +369,6 @@ let%test_module "Time.Stable.Span.V3" =
         let vn_error = Time_float.Span.abs (Time_float.Span.( - ) vn span) in
         let v3_error = Time_float.Span.abs (Time_float.Span.( - ) v3 span) in
         require
-          [%here]
           (Time_float.Span.( <= ) v3_error vn_error)
           ~if_false_then_print_s:
             (lazy
@@ -390,11 +383,24 @@ let%test_module "Time.Stable.Span.V3" =
                   (vn_error : Time_float.Span.t)
                   (v3_error : Time_float.Span.t)])
       in
-      quickcheck [%here] span_gen ~sexp_of:Time_float.Span.sexp_of_t ~f:(fun span ->
+      quickcheck span_gen ~sexp_of:Time_float.Span.sexp_of_t ~f:(fun span ->
         test "V1" (module Time_float.Stable.Span.V1) span;
         test "V2" (module Time_float.Stable.Span.V2) span);
       [%expect {| |}]
     ;;
+
+    let%test_unit "parts_default same as parts_31" =
+      let min = Float.of_int Int.min_value
+      and max = Float.of_int Int.max_value in
+      Quickcheck.test
+        (Float.gen_uniform_excl min max)
+        ~examples:[ Float.one_ulp `Up min; Float.one_ulp `Down max ]
+        ~sexp_of:[%sexp_of: float]
+        ~f:(fun fl ->
+          [%test_eq: Time_float.Span.Parts.t]
+            (Core_private.Span_float.Private.to_parts_default fl)
+            (Core_private.Span_float.Private.to_parts_31 fl))
+    ;;
   end)
 ;;
 
@@ -449,23 +455,21 @@ let%test_module "Span.to_string/of_strin
 
     let%expect_test "string round-trip is precise" =
       quickcheck
-        [%here]
         span_gen
         ~sexp_of:Time_float.Span.sexp_of_t
         ~examples:near_powers_of_10
         ~f:(fun span ->
-        let string = Time_float.Span.to_string span in
-        let round_trip = Time_float.Span.of_string string in
-        require
-          [%here]
-          (Time_float.Span.equal round_trip span)
-          ~if_false_then_print_s:
-            (lazy
-              [%message
-                "string round-trip is not precise"
-                  (span : Time_float.Span.t)
-                  (string : string)
-                  (round_trip : Time_float.Span.t)]));
+          let string = Time_float.Span.to_string span in
+          let round_trip = Time_float.Span.of_string string in
+          require
+            (Time_float.Span.equal round_trip span)
+            ~if_false_then_print_s:
+              (lazy
+                [%message
+                  "string round-trip is not precise"
+                    (span : Time_float.Span.t)
+                    (string : string)
+                    (round_trip : Time_float.Span.t)]));
       [%expect {| |}]
     ;;
 
@@ -490,31 +494,28 @@ let%test_module "Span.to_string/of_strin
         return (String.of_char_list list_with_underscores)
       in
       quickcheck
-        [%here]
         string_with_underscores_gen
         ~sexp_of:String.sexp_of_t
         ~f:(fun string_with_underscores ->
-        require_does_not_raise [%here] (fun () ->
-          let span = Time_float.Span.of_string string_with_underscores in
-          let string_without_underscores = Time_float.Span.to_string span in
-          let round_trip = Time_float.Span.of_string string_without_underscores in
-          require_equal
-            [%here]
-            (module Time_float.Span)
-            span
-            round_trip
-            ~if_false_then_print_s:(lazy [%message string_without_underscores]);
-          let string_with_underscores_removed =
-            String.filter string_with_underscores ~f:(function
-              | '_' -> false
-              | _ -> true)
-          in
-          require_equal
-            [%here]
-            (module String)
-            string_without_underscores
-            string_with_underscores_removed
-            ~if_false_then_print_s:(lazy [%sexp (span : Time_float.Span.t)])));
+          require_does_not_raise (fun () ->
+            let span = Time_float.Span.of_string string_with_underscores in
+            let string_without_underscores = Time_float.Span.to_string span in
+            let round_trip = Time_float.Span.of_string string_without_underscores in
+            require_equal
+              (module Time_float.Span)
+              span
+              round_trip
+              ~if_false_then_print_s:(lazy [%message string_without_underscores]);
+            let string_with_underscores_removed =
+              String.filter string_with_underscores ~f:(function
+                | '_' -> false
+                | _ -> true)
+            in
+            require_equal
+              (module String)
+              string_without_underscores
+              string_with_underscores_removed
+              ~if_false_then_print_s:(lazy [%sexp (span : Time_float.Span.t)])));
       [%expect {| |}]
     ;;
 
@@ -548,9 +549,9 @@ let%test_module "Span.to_string/of_strin
       float_gen_uniform_exponent ~min_exponent ~max_exponent
       |> Quickcheck.Generator.map ~f:Time_float.Span.of_sec
       |> Quickcheck.Generator.filter ~f:(fun span ->
-           let magnitude = Time_float.Span.abs span in
-           Time_float.Span.( > ) magnitude magnitude_low
-           && Time_float.Span.( < ) magnitude magnitude_high)
+        let magnitude = Time_float.Span.abs span in
+        Time_float.Span.( > ) magnitude magnitude_low
+        && Time_float.Span.( < ) magnitude magnitude_high)
     ;;
 
     let test_part_magnitudes ~magnitude_low ~magnitude_high ~allow_abnormal_frac =
@@ -580,7 +581,7 @@ let%test_module "Span.to_string/of_strin
         let magnitudes_and_units =
           String.to_list string
           |> List.group ~break:(fun a b ->
-               Bool.( <> ) (is_float_char a) (is_float_char b))
+            Bool.( <> ) (is_float_char a) (is_float_char b))
           |> List.map ~f:String.of_char_list
         in
         parts_of_list magnitudes_and_units
@@ -598,16 +599,11 @@ let%test_module "Span.to_string/of_strin
       let quickcheck_generator = bounded_span_gen ~magnitude_low ~magnitude_high in
       let test_count = ref 0 in
       let abnormal_count = ref 0 in
-      quickcheck
-        [%here]
-        quickcheck_generator
-        ~sexp_of:Time_float.Span.sexp_of_t
-        ~f:(fun span ->
+      quickcheck quickcheck_generator ~sexp_of:Time_float.Span.sexp_of_t ~f:(fun span ->
         let seconds = Time_float.Span.to_sec span in
         let ulp = Float.one_ulp `Up seconds -. seconds in
         let string = Time_float.Span.to_string span in
         require
-          [%here]
           (Time_float.Span.of_string string = span)
           ~if_false_then_print_s:
             (lazy
@@ -630,12 +626,10 @@ let%test_module "Span.to_string/of_strin
           List.fold parts ~init:false ~f:(fun has_abnormal (magnitude, unit_of_time) ->
             let open Float.O in
             require
-              [%here]
               (not has_abnormal)
               ~if_false_then_print_s:
                 (lazy [%message "abnormal span part not last" (string : string)]);
             require
-              [%here]
               (magnitude > 0.)
               ~if_false_then_print_s:
                 (lazy
@@ -648,25 +642,24 @@ let%test_module "Span.to_string/of_strin
               ~default:false
               (upper_bound unit_of_time)
               ~f:(fun upper_bound ->
-              (* we tolerate one abnormality where the very last part is exactly at
+                (* we tolerate one abnormality where the very last part is exactly at
                      the upper bound *)
-              if magnitude = upper_bound
-              then true
-              else (
-                require
-                  [%here]
-                  (magnitude < upper_bound)
-                  ~if_false_then_print_s:
-                    (lazy
-                      [%message
-                        "magnitude out of bounds"
-                          (string : string)
-                          (seconds : float)
-                          (ulp : float)
-                          (magnitude : float)
-                          (upper_bound : float)
-                          (unit_of_time : Unit_of_time.t)]);
-                false)))
+                if magnitude = upper_bound
+                then true
+                else (
+                  require
+                    (magnitude < upper_bound)
+                    ~if_false_then_print_s:
+                      (lazy
+                        [%message
+                          "magnitude out of bounds"
+                            (string : string)
+                            (seconds : float)
+                            (ulp : float)
+                            (magnitude : float)
+                            (upper_bound : float)
+                            (unit_of_time : Unit_of_time.t)]);
+                  false)))
         in
         incr test_count;
         if is_abnormal then incr abnormal_count);
@@ -795,10 +788,10 @@ let%test_module "Span.to_string/of_strin
         |> List.map ~f:String.of_char_list
       in
       let test ?cr suffix =
-        quickcheck [%here] ?cr span_gen ~sexp_of:Time_float.Span.sexp_of_t ~f:(fun span ->
+        quickcheck ?cr span_gen ~sexp_of:Time_float.Span.sexp_of_t ~f:(fun span ->
           let string = Time_float.Span.to_string span in
           let strings = split string in
-          require [%here] ?cr (List.count strings ~f:(String.equal suffix) <= 1))
+          require ?cr (List.count strings ~f:(String.equal suffix) <= 1))
       in
       (* For very large values (ULP >> 1s), we can see days appear twice, once very large
          and once smaller by several orders of magnitude. Note that the specific example
@@ -840,7 +833,6 @@ let%expect_test "Span.to_parts + Span.cr
     let round_trip = Time_float.Span.create ~sign ~hr ~min ~sec ~ms ~us ~ns () in
     let abs_diff = Time_float.Span.abs (Time_float.Span.( - ) span round_trip) in
     require
-      [%here]
       (Time_float.Span.( < ) abs_diff Time_float.Span.nanosecond)
       ~if_false_then_print_s:
         (lazy
@@ -914,7 +906,6 @@ let%expect_test "Ofday.to_parts + Ofday.
     let round_trip = Time_float.Ofday.create ~hr ~min ~sec ~ms ~us ~ns () in
     let abs_diff = Time_float.Span.abs (Time_float.Ofday.diff ofday round_trip) in
     require
-      [%here]
       (Time_float.Span.( < ) abs_diff Time_float.Span.nanosecond)
       ~if_false_then_print_s:
         (lazy
@@ -974,13 +965,15 @@ let%expect_test "time zone offset parsin
     |}];
   test "2000-01-01 12:34:56.789012-23:00";
   test "2000-01-01 12:34:56.789012-23";
-  [%expect {|
+  [%expect
+    {|
     2000-01-02 11:34:56.789012Z
     2000-01-02 11:34:56.789012Z
     |}];
   test "2000-01-01 12:34:56.789012-24:00";
   test "2000-01-01 12:34:56.789012-24";
-  [%expect {|
+  [%expect
+    {|
     2000-01-02 12:34:56.789012Z
     2000-01-02 12:34:56.789012Z
     |}]
@@ -988,7 +981,7 @@ let%expect_test "time zone offset parsin
 
 let%expect_test "time zone invalid offset parsing" =
   let test here string =
-    require_does_raise here (fun () -> Time_float.of_string_with_utc_offset string)
+    require_does_raise ~here (fun () -> Time_float.of_string_with_utc_offset string)
   in
   test [%here] "2000-01-01 12:34:56.789012-0:";
   test [%here] "2000-01-01 12:34:56.789012-00:";
@@ -1055,7 +1048,7 @@ let%expect_test "time zone invalid offse
 
 let%expect_test "of_string_iso8601_extended" =
   let success string =
-    require_does_not_raise [%here] (fun () ->
+    require_does_not_raise (fun () ->
       printf
         "%s <-- %s\n"
         (Time_float.Ofday.to_string (Time_float.Ofday.of_string_iso8601_extended string))
@@ -1133,11 +1126,9 @@ let%expect_test "of_string_iso8601_exten
     | exception Invalid_argument message -> print_endline message
     | exception exn ->
       (* This is not necessarily an error, we may just need to update this test. *)
-      print_cr [%here] [%message "unexpected exception" (exn : exn)]
+      print_cr [%message "unexpected exception" (exn : exn)]
     | ofday ->
-      print_cr
-        [%here]
-        [%message "did not raise" (string : string) (ofday : Time_float.Ofday.t)]
+      print_cr [%message "did not raise" (string : string) (ofday : Time_float.Ofday.t)]
   in
   List.iter
     ~f:failure
@@ -1309,44 +1300,44 @@ module _ = struct
 
     let%test_module "Span.V1" =
       (module Stable_unit_test.Make (struct
-        include V1
+          include V1
 
-        let equal t1 t2 = Int.( = ) 0 (compare t1 t2)
+          let equal t1 t2 = Int.( = ) 0 (compare t1 t2)
 
-        let tests =
-          let span = of_sec in
-          [ span 99e-12, "9.9e-08ms", "\018\006\211\115\129\054\219\061"
-          ; span 1.2e-9, "1.2e-06ms", "\076\206\097\227\167\157\020\062"
-          ; span 0.000001, "0.001ms", "\141\237\181\160\247\198\176\062"
-          ; span 0.707, "707ms", "\057\180\200\118\190\159\230\063"
-          ; span 42., "42s", "\000\000\000\000\000\000\069\064"
-          ; span 1234.56, "20.576m", "\010\215\163\112\061\074\147\064"
-          ; span 39_996., "11.11h", "\000\000\000\000\128\135\227\064"
-          ; span 80000006.4, "925.926d", "\154\153\153\025\208\018\147\065"
-          ]
-        ;;
-      end))
+          let tests =
+            let span = of_sec in
+            [ span 99e-12, "9.9e-08ms", "\018\006\211\115\129\054\219\061"
+            ; span 1.2e-9, "1.2e-06ms", "\076\206\097\227\167\157\020\062"
+            ; span 0.000001, "0.001ms", "\141\237\181\160\247\198\176\062"
+            ; span 0.707, "707ms", "\057\180\200\118\190\159\230\063"
+            ; span 42., "42s", "\000\000\000\000\000\000\069\064"
+            ; span 1234.56, "20.576m", "\010\215\163\112\061\074\147\064"
+            ; span 39_996., "11.11h", "\000\000\000\000\128\135\227\064"
+            ; span 80000006.4, "925.926d", "\154\153\153\025\208\018\147\065"
+            ]
+          ;;
+        end))
     ;;
 
     let%test_module "Span.V2" =
       (module Stable_unit_test.Make (struct
-        include V2
+          include V2
 
-        let equal t1 t2 = Int.( = ) 0 (compare t1 t2)
+          let equal t1 t2 = Int.( = ) 0 (compare t1 t2)
 
-        let tests =
-          let span = of_sec in
-          [ span 99e-12, "0.098999999999999991ns", "\018\006\211\115\129\054\219\061"
-          ; span 1.2e-9, "1.2ns", "\076\206\097\227\167\157\020\062"
-          ; span 0.000001, "1us", "\141\237\181\160\247\198\176\062"
-          ; span 0.707, "707ms", "\057\180\200\118\190\159\230\063"
-          ; span 42., "42s", "\000\000\000\000\000\000\069\064"
-          ; span 1234.56, "20.576m", "\010\215\163\112\061\074\147\064"
-          ; span 39_996., "11.11h", "\000\000\000\000\128\135\227\064"
-          ; span 80000006.4, "925.926d", "\154\153\153\025\208\018\147\065"
-          ]
-        ;;
-      end))
+          let tests =
+            let span = of_sec in
+            [ span 99e-12, "0.098999999999999991ns", "\018\006\211\115\129\054\219\061"
+            ; span 1.2e-9, "1.2ns", "\076\206\097\227\167\157\020\062"
+            ; span 0.000001, "1us", "\141\237\181\160\247\198\176\062"
+            ; span 0.707, "707ms", "\057\180\200\118\190\159\230\063"
+            ; span 42., "42s", "\000\000\000\000\000\000\069\064"
+            ; span 1234.56, "20.576m", "\010\215\163\112\061\074\147\064"
+            ; span 39_996., "11.11h", "\000\000\000\000\128\135\227\064"
+            ; span 80000006.4, "925.926d", "\154\153\153\025\208\018\147\065"
+            ]
+          ;;
+        end))
     ;;
   end
 
@@ -1417,12 +1408,12 @@ let%expect_test "times with implicit zon
   let test f = show_raise (fun () -> print_endline (Time_float.to_string_utc (f ()))) in
   test (fun () ->
     Time_float.Stable.With_utc_sexp.V2.t_of_sexp (Sexp.of_string "(2013-10-07 09:30)"));
-  [%expect {|
+  [%expect
+    {|
     2013-10-07 09:30:00.000000Z
     "did not raise"
     |}];
-  require_does_raise [%here] (fun () ->
-    Time_float.of_string_with_utc_offset "2013-10-07 09:30");
+  require_does_raise (fun () -> Time_float.of_string_with_utc_offset "2013-10-07 09:30");
   [%expect
     {|
     (time.ml.Make.Time_of_string
@@ -1432,9 +1423,8 @@ let%expect_test "times with implicit zon
 ;;
 
 let%expect_test "quickcheck should generate serializable times" =
-  require_does_not_raise [%here] (fun () ->
+  require_does_not_raise (fun () ->
     quickcheck_m
-      [%here]
       (module struct
         type t = Time_float.t [@@deriving quickcheck]
 
@@ -1452,7 +1442,6 @@ let%expect_test "regression test: [to_of
   let zone = Time_float.Zone.utc in
   quickcheck_m
     ~cr:CR_soon
-    [%here]
     (module struct
       include Time_float.Stable.With_utc_sexp.V2
 
Index: core-0.17.1/core/test/test_time_ns.ml
===================================================================
--- core-0.17.1.orig/core/test/test_time_ns.ml
+++ core-0.17.1/core/test/test_time_ns.ml
@@ -38,7 +38,7 @@ let randomly_round quickcheck_generator
 ;;
 
 let quickcheck here quickcheck_generator f =
-  require_does_not_raise here (fun () ->
+  require_does_not_raise ~here (fun () ->
     Quickcheck.test
       quickcheck_generator
       ~f
@@ -55,7 +55,6 @@ let%expect_test "Time_ns.Span.Stable.V1"
   let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
   (* stable checks for values that round-trip *)
   print_and_check_stable_int63able_type
-    [%here]
     (module V)
     [ make 0L
     ; make 1_000L
@@ -91,11 +90,7 @@ let%expect_test "Time_ns.Span.Stable.V1"
      (int63  1))
     |}];
   (* stable checks for values that do not precisely round-trip *)
-  print_and_check_stable_int63able_type
-    [%here]
-    (module V)
-    ~cr:Comment
-    [ make 11_275_440_000L ];
+  print_and_check_stable_int63able_type (module V) ~cr:Comment [ make 11_275_440_000L ];
   [%expect
     {|
     (bin_shape_digest 2b528f4b22f08e28876ffe0239315ac2)
@@ -142,22 +137,20 @@ let%test_module "Time_ns.Span.Stable.V2"
 
     let%expect_test "round-trip" =
       Expect_test_helpers_core.quickcheck
-        [%here]
         ~sexp_of:Time_ns.Span.sexp_of_t
         ~examples:span_examples
         span_gen
         ~f:(fun span ->
-        let rt = V.t_of_sexp (V.sexp_of_t span) in
-        require_equal [%here] (module Time_ns.Span) span rt;
-        let rt = V.of_int63_exn (V.to_int63 span) in
-        require_equal [%here] (module Time_ns.Span) span rt);
+          let rt = V.t_of_sexp (V.sexp_of_t span) in
+          require_equal (module Time_ns.Span) span rt;
+          let rt = V.of_int63_exn (V.to_int63 span) in
+          require_equal (module Time_ns.Span) span rt);
       [%expect {| |}]
     ;;
 
     let%expect_test "stability" =
       let make int64 = V.of_int63_exn (Int63.of_int64_exn int64) in
       print_and_check_stable_int63able_type
-        [%here]
         (module V)
         [ make 0L
         ; make 1L
@@ -272,7 +265,6 @@ let%test_module "Time_ns.Alternate_sexp
           Time_ns.Alternate_sexp.t_of_sexp (Time_ns.Alternate_sexp.sexp_of_t time_ns)
         in
         require
-          [%here]
           (Time_ns.equal time_ns round_trip)
           ~if_false_then_print_s:
             (lazy
@@ -301,7 +293,6 @@ let%test_module "Time_ns.Alternate_sexp
             (Time_ns.Option.Alternate_sexp.sexp_of_t time_ns_opt)
         in
         require
-          [%here]
           (Time_ns.Option.equal time_ns_opt round_trip)
           ~if_false_then_print_s:
             (lazy
@@ -335,7 +326,6 @@ let%test_module "Time_ns.Alternate_sexp
 
     let%expect_test "validate sexp grammar" =
       require_ok
-        [%here]
         (Sexp_grammar_validation.validate_grammar
            (module struct
              include Time_ns.Alternate_sexp
@@ -433,7 +423,6 @@ let%test_module "Time_ns.Span rounding"
 
     let%expect_test "quickcheck rounding" =
       quickcheck_m
-        [%here]
         (module struct
           type t = Time_ns.Span.t * Unit_of_time.t * Rounding_direction.t
           [@@deriving sexp_of]
@@ -465,18 +454,13 @@ let%test_module "Time_ns.Span rounding"
             [%lazy_message
               "" (to_multiple_of : t) (rounded : t) (expect : t) (remainder_ns : Int63.t)]
           in
-          require_equal
-            [%here]
-            (module Time_ns.Span)
-            rounded
-            expect
-            ~if_false_then_print_s;
-          require [%here] (abs (span - rounded) < to_multiple_of) ~if_false_then_print_s;
-          require [%here] (Int63.equal remainder_ns Int63.zero) ~if_false_then_print_s;
+          require_equal (module Time_ns.Span) rounded expect ~if_false_then_print_s;
+          require (abs (span - rounded) < to_multiple_of) ~if_false_then_print_s;
+          require (Int63.equal remainder_ns Int63.zero) ~if_false_then_print_s;
           match dir with
-          | Up -> require [%here] (rounded >= span) ~if_false_then_print_s
-          | Down -> require [%here] (rounded <= span) ~if_false_then_print_s
-          | Zero -> require [%here] (abs rounded <= abs span) ~if_false_then_print_s
+          | Up -> require (rounded >= span) ~if_false_then_print_s
+          | Down -> require (rounded <= span) ~if_false_then_print_s
+          | Zero -> require (abs rounded <= abs span) ~if_false_then_print_s
           | Nearest -> ());
       [%expect {| |}]
     ;;
@@ -513,7 +497,7 @@ let%expect_test "Stable.Alternate_sexp.V
     ; Time_ns.max_value_for_1us_rounding
     ]
   in
-  print_and_check_stable_type [%here] (module Time_ns.Stable.Alternate_sexp.V1) times;
+  print_and_check_stable_type (module Time_ns.Stable.Alternate_sexp.V1) times;
   [%expect
     {|
     (bin_shape_digest 2b528f4b22f08e28876ffe0239315ac2)
@@ -544,7 +528,6 @@ let%expect_test "Stable.Alternate_sexp.V
     |}];
   let option_times = Time_ns.Option.none :: List.map times ~f:Time_ns.Option.some in
   print_and_check_stable_type
-    [%here]
     (module Time_ns.Stable.Option.Alternate_sexp.V1)
     option_times;
   [%expect
@@ -577,7 +560,7 @@ let%test_module "Ofday" =
   (module struct
     let%expect_test "of_string_iso8601_extended" =
       let success string =
-        require_does_not_raise [%here] (fun () ->
+        require_does_not_raise (fun () ->
           printf
             "%s <-- %s\n"
             (Time_ns.Ofday.to_string (Time_ns.Ofday.of_string_iso8601_extended string))
@@ -654,9 +637,7 @@ let%test_module "Ofday" =
         match Time_ns.Ofday.of_string_iso8601_extended string with
         | exception exn -> print_endline (Exn.to_string exn)
         | ofday ->
-          print_cr
-            [%here]
-            [%message "did not raise" (string : string) (ofday : Time_ns.Ofday.t)]
+          print_cr [%message "did not raise" (string : string) (ofday : Time_ns.Ofday.t)]
       in
       List.iter
         ~f:failure
@@ -718,7 +699,6 @@ let%test_module "Ofday" =
         match result with
         | Error _ ->
           require
-            [%here]
             should_be_error
             ~if_false_then_print_s:
               (lazy
@@ -728,7 +708,6 @@ let%test_module "Ofday" =
                     (non_positive_span : bool)])
         | Ok list ->
           require
-            [%here]
             (not should_be_error)
             ~if_false_then_print_s:
               (lazy
@@ -737,11 +716,9 @@ let%test_module "Ofday" =
                     (crossed_bounds : bool)
                     (non_positive_span : bool)]);
           require
-            [%here]
             (List.is_sorted list ~compare:Ofday.compare)
             ~if_false_then_print_s:(lazy [%message "not sorted"]);
           require
-            [%here]
             (List.for_all list ~f:(fun ofday ->
                Ofday.( >= ) ofday start && Ofday.( <= ) ofday stop))
             ~if_false_then_print_s:(lazy [%message "exceeds bounds"])
@@ -812,7 +789,6 @@ let%test_module "Ofday" =
           Span.( >= ) (Span.abs span) Span.second)
       in
       Expect_test_helpers_base.quickcheck
-        [%here]
         [%quickcheck.generator: [%custom span_gen] * Ofday.t * Ofday.t]
         ~sexp_of:[%sexp_of: Span.t * Ofday.t * Ofday.t]
         ~f:(fun (span, start, stop) -> test ~verbose:false span start stop);
@@ -947,7 +923,7 @@ module _ = struct
         print_s
           [%sexp
             (to_parts (create ~sign:Neg ~hr:2 ~min:3 ~sec:4 ~ms:5 ~us:6 ~ns:7 ())
-              : Parts.t)];
+             : Parts.t)];
         [%expect
           {|
           ((sign Neg)
@@ -1173,7 +1149,7 @@ let%test_module "next_multiple" =
 ;;
 
 let%expect_test "times with implicit zones" =
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Time_ns.Stable.Alternate_sexp.V1.t_of_sexp (Sexp.Atom "2013-10-07 09:30:00"));
   [%expect
     {|
@@ -1181,7 +1157,7 @@ let%expect_test "times with implicit zon
       (Invalid_argument "String.chop_suffix_exn \"09:30:00\" \"Z\"")
       (invalid_sexp "2013-10-07 09:30:00"))
     |}];
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Time_ns.Alternate_sexp.t_of_sexp (Sexp.Atom "2013-10-07 09:30:00"));
   [%expect
     {|
@@ -1213,13 +1189,9 @@ let%expect_test "Ofday.to_microsecond_st
   ; Time_ns.Ofday.start_of_next_day
   ]
   |> List.iter ~f:(fun ofday ->
-       let string = Time_ns.Ofday.to_microsecond_string ofday in
-       print_endline string;
-       require_equal
-         [%here]
-         (module Time_ns.Ofday)
-         (Time_ns.Ofday.of_string string)
-         (round ofday));
+    let string = Time_ns.Ofday.to_microsecond_string ofday in
+    print_endline string;
+    require_equal (module Time_ns.Ofday) (Time_ns.Ofday.of_string string) (round ofday));
   [%expect
     {|
     00:00:00.000000
@@ -1299,7 +1271,7 @@ let%expect_test "time zone offset parsin
 
 let%expect_test "time zone invalid offset parsing" =
   let test here string =
-    require_does_raise here (fun () -> Time_ns.of_string_with_utc_offset string)
+    require_does_raise ~here (fun () -> Time_ns.of_string_with_utc_offset string)
   in
   test [%here] "2000-01-01 12:34:56.789012345-0:";
   test [%here] "2000-01-01 12:34:56.789012345-00:";
@@ -1516,7 +1488,6 @@ let%expect_test "sub_saturating" =
 
 let%expect_test "[to_ofday] never returns 24:00" =
   quickcheck_m
-    [%here]
     (module struct
       include struct
         type t = Time_ns.t [@@deriving quickcheck]
@@ -1536,7 +1507,6 @@ let%expect_test "approximate conversions
   let test to_precise to_approx =
     (* show that conversion can be imprecise *)
     quickcheck_m
-      [%here]
       ~cr:Comment
       (module Time_ns.Span)
       ~f:(fun span ->
@@ -1546,7 +1516,6 @@ let%expect_test "approximate conversions
         then (
           let diff = approx -. precise in
           print_cr
-            [%here]
             ~cr:Comment
             [%message
               "result can be imprecise"
@@ -1556,7 +1525,6 @@ let%expect_test "approximate conversions
                 (diff : float)]));
     (* check that imprecision is at most 1 ULP *)
     quickcheck_m
-      [%here]
       (module Time_ns.Span)
       ~f:(fun span ->
         let precise = to_precise span in
@@ -1566,7 +1534,6 @@ let%expect_test "approximate conversions
         then (
           let diff = approx -. precise in
           print_cr
-            [%here]
             [%message
               "imprecision can exceed 1 ULP"
                 (span : Time_ns.Span.t)
Index: core-0.17.1/core/test/test_timezone.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_timezone.ml
@@ -0,0 +1,656 @@
+open! Core
+open! Import
+
+(* [init] is a noop in javascript, so this is expected to not work. It will only fail
+   with [Private.Zone_cache.find], which only checks the cache and shouldn't be used
+   directly anyway. *)
+let%expect_test (_ [@tags "no-js"]) =
+  let open Timezone.Private.Zone_cache in
+  init ();
+  let result = Option.is_some (find "America/New_York") in
+  (* keep this test from contaminating tests later in the file *)
+  the_one_and_only.full <- false;
+  Hashtbl.clear the_one_and_only.table;
+  require result
+;;
+
+let%expect_test (_ [@tags "js-only"]) =
+  let public_find = Timezone.find in
+  let open Timezone.Private.Zone_cache in
+  (* This test is a dual to the one above that shows that [init] is a noop and how the
+     behavior differs between native and web contexts. *)
+  init ();
+  require_none [%sexp_of: Timezone.t] (find "America/New_York");
+  let () =
+    require (Hashtbl.is_empty the_one_and_only.table);
+    require_some (public_find "America/New_York");
+    (* keep this test from contaminating tests later in the file *)
+    Hashtbl.clear the_one_and_only.table
+  in
+  require (not the_one_and_only.full)
+;;
+
+let%expect_test "Zone.V1" =
+  print_and_check_stable_type
+    ~cr:Comment
+    (module Timezone.Stable.V1)
+    (List.concat
+       [ List.map ~f:Timezone.find_exn [ "nyc"; "ldn"; "hkg"; "tyo"; "chi"; "UTC"; "GMT" ]
+       ; List.map
+           ~f:(fun hours -> Time_float.Zone.of_utc_offset ~hours)
+           [ 0; 1; -1; 24; -24 ]
+       ; (* these time zones only round-trip via [Stable.Full_data] *)
+         [ Time_float.Zone.of_utc_offset_explicit_name ~name:"my zone" ~hours:1
+         ; Time_float.Zone.of_utc_offset_in_seconds_round_down
+             (Time_float.Span.of_string "-3h2m1s")
+         ; Time_float.Zone.add_offset_in_seconds_round_down
+             (Timezone.find_exn "hkg")
+             ~name:"hkg+1"
+             ~span:Time_float.Span.hour
+         ]
+       ]);
+  [%expect
+    {|
+    (bin_shape_digest d9a8da25d5656b016fb4dbdc2e4197fb)
+    ((sexp   America/New_York)
+     (bin_io "\016America/New_York"))
+    ((sexp   Europe/London)
+     (bin_io "\rEurope/London"))
+    ((sexp   Asia/Hong_Kong)
+     (bin_io "\014Asia/Hong_Kong"))
+    ((sexp   Asia/Tokyo)
+     (bin_io "\nAsia/Tokyo"))
+    ((sexp   America/Chicago)
+     (bin_io "\015America/Chicago"))
+    ((sexp   UTC)
+     (bin_io "\003UTC"))
+    ((sexp   GMT)
+     (bin_io "\003GMT"))
+    ((sexp   UTC)
+     (bin_io "\003UTC"))
+    ((sexp   UTC+1)
+     (bin_io "\005UTC+1"))
+    ((sexp   UTC-1)
+     (bin_io "\005UTC-1"))
+    ((sexp   UTC+24)
+     (bin_io "\006UTC+24"))
+    ((sexp   UTC-24)
+     (bin_io "\006UTC-24"))
+    (* require-failed: lib/core/test/test_timezone.ml:LINE:COL. *)
+    ("unexpectedly raised" (
+      Of_sexp_error
+      "Timezone.t_of_sexp: (\"unknown zone\" (zone \"my zone\"))"
+      (invalid_sexp "my zone")))
+    (* require-failed: lib/core/test/test_timezone.ml:LINE:COL. *)
+    ("unexpectedly raised" (
+      Of_sexp_error
+      "Timezone.t_of_sexp: (Failure \"Int.of_string: \\\"3:02:01\\\"\")"
+      (invalid_sexp UTC-3:02:01)))
+    (* require-failed: lib/core/test/test_timezone.ml:LINE:COL. *)
+    ("unexpectedly raised" (
+      Of_sexp_error
+      "Timezone.t_of_sexp: (\"unknown zone\" (zone hkg+1))"
+      (invalid_sexp hkg+1)))
+    |}];
+  require_does_not_raise (fun () ->
+    ignore (Timezone.Stable.V1.t_of_sexp (Atom "Local") : Timezone.t))
+;;
+
+module Common_dates = struct
+  let mkt ?(year = 2013) month day hr min =
+    let ofday_mins = (hr * 60) + min in
+    let ofday =
+      Time_float.Span.of_sec (Float.of_int (ofday_mins * 60))
+      |> Time_float.Ofday.of_span_since_start_of_day_exn
+    in
+    let date = Date.create_exn ~y:year ~m:month ~d:day in
+    Time_float.of_date_ofday date ofday ~zone:Timezone.utc
+  ;;
+
+  let bst_start = mkt ~year:2013 Mar 31 01 00, Time_float.Span.hour
+  let bst_end = mkt ~year:2013 Oct 27 01 00, Time_float.Span.(neg hour)
+  let bst_start_2014 = mkt ~year:2014 Mar 30 01 00, Time_float.Span.hour
+end
+
+let%test_module "differences in abbreviations between native and js" =
+  (module struct
+    open Common_dates
+
+    let print_abbrev ~zone ~time =
+      let time_in_seconds =
+        time
+        |> Time_float.to_span_since_epoch
+        |> Time_float.Span.to_int63_seconds_round_down_exn
+        |> Timezone.Time_in_seconds.Span.of_int63_seconds
+        |> Timezone.Time_in_seconds.of_span_since_epoch
+      in
+      let index = Timezone.index zone time_in_seconds in
+      print_endline (Timezone.index_abbreviation_exn zone index)
+    ;;
+
+    let%expect_test ("bst-start native" [@tags "no-js"]) =
+      print_abbrev ~zone:(Timezone.find_exn "Europe/London") ~time:(fst bst_start);
+      [%expect {| BST |}]
+    ;;
+
+    let%expect_test ("bst-start javascript" [@tags "js-only"]) =
+      print_abbrev ~zone:(Timezone.find_exn "Europe/London") ~time:(fst bst_start);
+      [%expect {| |}]
+    ;;
+
+    let%expect_test ("bst-end native" [@tags "no-js"]) =
+      print_abbrev ~zone:(Timezone.find_exn "Europe/London") ~time:(fst bst_end);
+      [%expect {| GMT |}]
+    ;;
+
+    let%expect_test ("bst-end javascript" [@tags "js-only"]) =
+      print_abbrev ~zone:(Timezone.find_exn "Europe/London") ~time:(fst bst_end);
+      [%expect {| |}]
+    ;;
+  end)
+;;
+
+let%test_module "next_clock_shift, prev_clock_shift" =
+  (module struct
+    open Common_dates
+
+    let%expect_test "UTC" =
+      Time_float.Zone.next_clock_shift Timezone.utc ~strictly_after:(mkt Jan 01 12 00)
+      |> require_none [%sexp_of: Time_float.t * Time_float.Span.t];
+      Time_float.Zone.prev_clock_shift Timezone.utc ~at_or_before:(mkt Jan 01 12 00)
+      |> require_none [%sexp_of: Time_float.t * Time_float.Span.t]
+    ;;
+
+    let expect_next strictly_after next =
+      [%test_result: (Time_float.t * Time_float.Span.t) option]
+        ~expect:(Some next)
+        (Time_float.Zone.next_clock_shift
+           (Timezone.find_exn "Europe/London")
+           ~strictly_after)
+    ;;
+
+    let expect_prev at_or_before prev =
+      [%test_result: (Time_float.t * Time_float.Span.t) option]
+        ~expect:(Some prev)
+        (Time_float.Zone.prev_clock_shift
+           (Timezone.find_exn "Europe/London")
+           ~at_or_before)
+    ;;
+
+    let expect_between time prev next =
+      expect_prev time prev;
+      expect_next time next
+    ;;
+
+    let%expect_test "outside BST" = expect_next (mkt Jan 01 12 00) bst_start
+    let%expect_test "just before BST start" = expect_next (mkt Mar 31 00 59) bst_start
+    let%expect_test "on BST start time" = expect_next (mkt Mar 31 01 00) bst_end
+
+    let%expect_test "just after BST start" =
+      expect_between (mkt Mar 31 01 01) bst_start bst_end
+    ;;
+
+    let%expect_test "inside BST" = expect_between (mkt Jun 01 12 00) bst_start bst_end
+
+    let%expect_test "just before BST end" =
+      expect_between (mkt Oct 27 00 59) bst_start bst_end
+    ;;
+
+    let%expect_test "BST end time" =
+      expect_between (mkt Oct 27 01 00) bst_end bst_start_2014
+    ;;
+
+    let%expect_test "just after BST end" =
+      expect_between (mkt Oct 27 01 01) bst_end bst_start_2014
+    ;;
+  end)
+;;
+
+let%test_module "clock shift stuff" =
+  (module struct
+    (* Some stuff to make [%test_result: t] failures look nicer. Notice that a bug in
+       [to_date_ofday] could cause this thing to lie. *)
+    type time = Time_float.t [@@deriving compare]
+
+    let sexp_of_time t =
+      let d, o = Time_float.to_date_ofday t ~zone:Timezone.utc in
+      [%sexp_of: Date.t * Time_float.Ofday.t * Timezone.t] (d, o, Timezone.utc)
+    ;;
+
+    type to_date_ofday_ambiguity =
+      [ `Only
+      | `Also_at of time
+      | `Also_skipped of Date.t * Time_float.Ofday.t
+      ]
+    [@@deriving compare, sexp_of]
+
+    type of_date_ofday_result =
+      [ `Once of time
+      | `Twice of time * time
+      | `Never of time
+      ]
+    [@@deriving compare, sexp_of]
+
+    let zone = Timezone.find_exn "Europe/London"
+
+    let mkt month day hr min =
+      let ofday =
+        Time_float.Span.of_sec (60. *. ((Float.of_int hr *. 60.) +. Float.of_int min))
+        |> Time_float.Ofday.of_span_since_start_of_day_exn
+      in
+      let date = Date.create_exn ~y:2013 ~m:month ~d:day in
+      Time_float.of_date_ofday date ofday ~zone:Timezone.utc
+    ;;
+
+    let simple_case ?(zone = zone) date ofday time =
+      [%test_result: of_date_ofday_result]
+        ~expect:(`Once time)
+        (Time_float.of_date_ofday_precise ~zone date ofday);
+      [%test_result: Date.t * Time_float.Ofday.t * to_date_ofday_ambiguity]
+        ~expect:(date, ofday, `Only)
+        (Time_float.to_date_ofday_precise ~zone time)
+    ;;
+
+    let skipped_this_time date ofday skipped_at =
+      [%test_result: of_date_ofday_result]
+        ~expect:(`Never skipped_at)
+        (Time_float.of_date_ofday_precise ~zone date ofday);
+      let time = Time_float.of_date_ofday ~zone date ofday in
+      let d, o, a = Time_float.to_date_ofday_precise ~zone time in
+      [%test_result: Date.t] ~expect:date d;
+      let diff = Time_float.Ofday.diff o ofday in
+      [%test_result: Time_float.Span.t] ~expect:Time_float.Span.hour diff;
+      [%test_result: to_date_ofday_ambiguity] ~expect:(`Also_skipped (date, ofday)) a
+    ;;
+
+    let skipped_prev_time date ofday time =
+      [%test_result: of_date_ofday_result]
+        ~expect:(`Once time)
+        (Time_float.of_date_ofday_precise ~zone date ofday);
+      let d, o, a = Time_float.to_date_ofday_precise ~zone time in
+      [%test_result: Date.t] ~expect:date d;
+      [%test_result: Time_float.Ofday.t] ~expect:ofday o;
+      [%test_result: to_date_ofday_ambiguity]
+        ~expect:
+          (`Also_skipped
+            (date, Option.value_exn (Time_float.Ofday.sub o Time_float.Span.hour)))
+        a
+    ;;
+
+    let repeated_time date ofday ~first =
+      let second = Time_float.add first Time_float.Span.hour in
+      [%test_result: of_date_ofday_result]
+        ~expect:(`Twice (first, second))
+        (Time_float.of_date_ofday_precise ~zone date ofday);
+      [%test_result: Date.t * Time_float.Ofday.t * to_date_ofday_ambiguity]
+        ~expect:(date, ofday, `Also_at second)
+        (Time_float.to_date_ofday_precise ~zone first);
+      [%test_result: Date.t * Time_float.Ofday.t * to_date_ofday_ambiguity]
+        ~expect:(date, ofday, `Also_at first)
+        (Time_float.to_date_ofday_precise ~zone second)
+    ;;
+
+    let ( ^: ) hr min = Time_float.Ofday.create ~hr ~min ()
+    let outside_bst = Date.of_string "2013-01-01"
+    let inside_bst = Date.of_string "2013-06-01"
+
+    let%expect_test "of_date_ofday_precise, outside BST" =
+      simple_case outside_bst (12 ^: 00) (mkt Jan 01 12 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, inside BST" =
+      simple_case inside_bst (12 ^: 00) (mkt Jun 01 11 00)
+    ;;
+
+    let bst_start = Date.of_string "2013-03-31"
+    let bst_end = Date.of_string "2013-10-27"
+
+    let%expect_test "of_date_ofday_precise, just before skipped hour" =
+      simple_case bst_start (00 ^: 59) (mkt Mar 31 00 59)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, start of skipped hour" =
+      skipped_this_time bst_start (01 ^: 00) (mkt Mar 31 01 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, during skipped hour" =
+      skipped_this_time bst_start (01 ^: 30) (mkt Mar 31 01 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, end of skipped hour" =
+      skipped_prev_time bst_start (02 ^: 00) (mkt Mar 31 01 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, just after skipped hour" =
+      skipped_prev_time bst_start (02 ^: 01) (mkt Mar 31 01 01)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, later after skipped hour" =
+      simple_case bst_start (03 ^: 00) (mkt Mar 31 02 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, just before repeated hour" =
+      simple_case bst_end (00 ^: 59) (mkt Oct 26 23 59)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, start of repeated hour" =
+      repeated_time bst_end (01 ^: 00) ~first:(mkt Oct 27 00 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, during repeated hour" =
+      repeated_time bst_end (01 ^: 30) ~first:(mkt Oct 27 00 30)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, end of repeated hour" =
+      simple_case bst_end (02 ^: 00) (mkt Oct 27 02 00)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, after repeated hour" =
+      simple_case bst_end (02 ^: 01) (mkt Oct 27 02 01)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, time zone with no transitions" =
+      simple_case
+        (Date.of_string "2013-01-01")
+        (12 ^: 00)
+        (mkt Jan 01 04 00)
+        ~zone:(Timezone.of_utc_offset ~hours:8)
+    ;;
+
+    let%expect_test "of_date_ofday_precise, time zone with no recent transitions" =
+      (* The Hong Kong time zone observed daylight savings from 1941 to 1979, but not
+         since, so the zone arithmetic for recent dates hits boundary cases. *)
+      simple_case
+        (Date.of_string "2013-01-01")
+        (12 ^: 00)
+        (mkt Jan 01 04 00)
+        ~zone:(Timezone.find_exn "Asia/Hong_Kong")
+    ;;
+  end)
+;;
+
+let%expect_test "grammar" =
+  Sexp_grammar_validation.validate_grammar
+    (module struct
+      include Timezone
+
+      let quickcheck_generator =
+        Timezone.init ();
+        Quickcheck.Generator.of_list (Timezone.initialized_zones () |> List.map ~f:snd)
+      ;;
+
+      let quickcheck_shrinker = [%quickcheck.shrinker: _]
+    end)
+  |> Expect_test_helpers_core.require_ok;
+  [%expect
+    {| (Tagged ((key sexp_grammar.type_name) (value Timezone.t) (grammar String))) |}]
+;;
+
+let%expect_test "UTC survives round trip" =
+  let test ?cr zone =
+    require_does_not_raise ?cr (fun () ->
+      print_s [%sexp (Time_float.utc_offset Time_float.epoch ~zone : Time_float.Span.t)])
+  in
+  test Time_float.Zone.utc;
+  [%expect {| 0s |}];
+  let zone =
+    Time_float.Zone.utc
+    |> Binable.to_string (module Time_float.Stable.Zone.Full_data.V1)
+    |> Binable.of_string (module Time_float.Stable.Zone.Full_data.V1)
+  in
+  test zone;
+  [%expect {| 0s |}]
+;;
+
+let%expect_test "time zone construction" =
+  let utc time = [%sexp (Time_float.to_string_abs time ~zone:Timezone.utc : string)] in
+  let transitions_of zone =
+    let start = Time_float.of_string "2024-01-01 00:00:00Z" in
+    let until = Time_float.of_string "2025-01-01 00:00:00Z" in
+    let[@tail_mod_cons] rec loop index =
+      match Timezone.index_has_next_clock_shift zone index with
+      | false -> []
+      | true ->
+        let time = Time_float.Zone.index_next_clock_shift_time_exn zone index in
+        (match Time_float.( < ) time until with
+         | false -> []
+         | true -> time :: loop (Timezone.Index.next index))
+    in
+    List.concat [ [ start ]; loop (Time_float.Zone.index zone start); [ until ] ]
+  in
+  let test maybe_zone =
+    let initial_zone = Option.value maybe_zone ~default:Timezone.utc in
+    let offset ?name span_string =
+      let span = Time_float.Span.of_string span_string in
+      match maybe_zone with
+      | None -> Time_float.Zone.of_utc_offset_in_seconds_round_down ?name span
+      | Some zone ->
+        Time_float.Zone.add_offset_in_seconds_round_down
+          zone
+          ~name:(Option.value name ~default:(Timezone.name zone ^ span_string))
+          ~span
+    in
+    let zones =
+      [ initial_zone
+      ; offset "+0s"
+      ; offset "+1h"
+      ; offset "-1h"
+      ; offset "+30s"
+      ; offset "-30s"
+      ; offset "+30.1s"
+      ; offset "-30.1s"
+      ; offset "+30m" ~name:"one half hour"
+      ]
+    in
+    let initial_transitions = transitions_of initial_zone in
+    List.iter zones ~f:(fun zone ->
+      let transitions = transitions_of zone in
+      require
+        ([%equal: Time_float.t list] transitions initial_transitions)
+        ~if_false_then_print_s:
+          [%lazy_message
+            "UTC times at which DST transitions occur are inconsistent"
+              (zone : Timezone.t)
+              ~original:(List.map ~f:utc initial_transitions : Sexp.t list)
+              ~modified:(List.map ~f:utc transitions : Sexp.t list)]);
+    let zones_with_utc =
+      if Option.is_none maybe_zone then zones else Timezone.utc :: zones
+    in
+    List.iter initial_transitions ~f:(fun time ->
+      List.map zones_with_utc ~f:(fun zone ->
+        [%sexp
+          { zone : Timezone.t; time = (Time_float.to_string_abs time ~zone : string) }])
+      |> Expectable.print)
+  in
+  (* We see UTC twice because [of_utc_offset_in_seconds_round_down Span.zero = UTC]. *)
+  test None;
+  [%expect
+    {|
+    ┌───────────────┬─────────────────────────────────────┐
+    │ zone          │ time                                │
+    ├───────────────┼─────────────────────────────────────┤
+    │ UTC           │ 2024-01-01 00:00:00.000000Z         │
+    │ UTC           │ 2024-01-01 00:00:00.000000Z         │
+    │ UTC+1         │ 2024-01-01 01:00:00.000000+01:00    │
+    │ UTC-1         │ 2023-12-31 23:00:00.000000-01:00    │
+    │ UTC+0:00:30   │ 2024-01-01 00:00:30.000000+00:00:30 │
+    │ UTC-0:00:30   │ 2023-12-31 23:59:30.000000-00:00:30 │
+    │ UTC+0:00:30   │ 2024-01-01 00:00:30.000000+00:00:30 │
+    │ UTC-0:00:31   │ 2023-12-31 23:59:29.000000-00:00:31 │
+    │ one half hour │ 2024-01-01 00:30:00.000000+00:30    │
+    └───────────────┴─────────────────────────────────────┘
+
+    ┌───────────────┬─────────────────────────────────────┐
+    │ zone          │ time                                │
+    ├───────────────┼─────────────────────────────────────┤
+    │ UTC           │ 2025-01-01 00:00:00.000000Z         │
+    │ UTC           │ 2025-01-01 00:00:00.000000Z         │
+    │ UTC+1         │ 2025-01-01 01:00:00.000000+01:00    │
+    │ UTC-1         │ 2024-12-31 23:00:00.000000-01:00    │
+    │ UTC+0:00:30   │ 2025-01-01 00:00:30.000000+00:00:30 │
+    │ UTC-0:00:30   │ 2024-12-31 23:59:30.000000-00:00:30 │
+    │ UTC+0:00:30   │ 2025-01-01 00:00:30.000000+00:00:30 │
+    │ UTC-0:00:31   │ 2024-12-31 23:59:29.000000-00:00:31 │
+    │ one half hour │ 2025-01-01 00:30:00.000000+00:30    │
+    └───────────────┴─────────────────────────────────────┘
+    |}];
+  test (Some (Timezone.find_exn "Asia/Hong_Kong"));
+  [%expect
+    {|
+    ┌──────────────────────┬─────────────────────────────────────┐
+    │ zone                 │ time                                │
+    ├──────────────────────┼─────────────────────────────────────┤
+    │ UTC                  │ 2024-01-01 00:00:00.000000Z         │
+    │ Asia/Hong_Kong       │ 2024-01-01 08:00:00.000000+08:00    │
+    │ Asia/Hong_Kong+0s    │ 2024-01-01 08:00:00.000000+08:00    │
+    │ Asia/Hong_Kong+1h    │ 2024-01-01 09:00:00.000000+09:00    │
+    │ Asia/Hong_Kong-1h    │ 2024-01-01 07:00:00.000000+07:00    │
+    │ Asia/Hong_Kong+30s   │ 2024-01-01 08:00:30.000000+08:00:30 │
+    │ Asia/Hong_Kong-30s   │ 2024-01-01 07:59:30.000000+07:59:30 │
+    │ Asia/Hong_Kong+30.1s │ 2024-01-01 08:00:30.000000+08:00:30 │
+    │ Asia/Hong_Kong-30.1s │ 2024-01-01 07:59:29.000000+07:59:29 │
+    │ one half hour        │ 2024-01-01 08:30:00.000000+08:30    │
+    └──────────────────────┴─────────────────────────────────────┘
+
+    ┌──────────────────────┬─────────────────────────────────────┐
+    │ zone                 │ time                                │
+    ├──────────────────────┼─────────────────────────────────────┤
+    │ UTC                  │ 2025-01-01 00:00:00.000000Z         │
+    │ Asia/Hong_Kong       │ 2025-01-01 08:00:00.000000+08:00    │
+    │ Asia/Hong_Kong+0s    │ 2025-01-01 08:00:00.000000+08:00    │
+    │ Asia/Hong_Kong+1h    │ 2025-01-01 09:00:00.000000+09:00    │
+    │ Asia/Hong_Kong-1h    │ 2025-01-01 07:00:00.000000+07:00    │
+    │ Asia/Hong_Kong+30s   │ 2025-01-01 08:00:30.000000+08:00:30 │
+    │ Asia/Hong_Kong-30s   │ 2025-01-01 07:59:30.000000+07:59:30 │
+    │ Asia/Hong_Kong+30.1s │ 2025-01-01 08:00:30.000000+08:00:30 │
+    │ Asia/Hong_Kong-30.1s │ 2025-01-01 07:59:29.000000+07:59:29 │
+    │ one half hour        │ 2025-01-01 08:30:00.000000+08:30    │
+    └──────────────────────┴─────────────────────────────────────┘
+    |}];
+  test (Some (Timezone.find_exn "Europe/London"));
+  [%expect
+    {|
+    ┌─────────────────────┬─────────────────────────────────────┐
+    │ zone                │ time                                │
+    ├─────────────────────┼─────────────────────────────────────┤
+    │ UTC                 │ 2024-01-01 00:00:00.000000Z         │
+    │ Europe/London       │ 2024-01-01 00:00:00.000000Z         │
+    │ Europe/London+0s    │ 2024-01-01 00:00:00.000000Z         │
+    │ Europe/London+1h    │ 2024-01-01 01:00:00.000000+01:00    │
+    │ Europe/London-1h    │ 2023-12-31 23:00:00.000000-01:00    │
+    │ Europe/London+30s   │ 2024-01-01 00:00:30.000000+00:00:30 │
+    │ Europe/London-30s   │ 2023-12-31 23:59:30.000000-00:00:30 │
+    │ Europe/London+30.1s │ 2024-01-01 00:00:30.000000+00:00:30 │
+    │ Europe/London-30.1s │ 2023-12-31 23:59:29.000000-00:00:31 │
+    │ one half hour       │ 2024-01-01 00:30:00.000000+00:30    │
+    └─────────────────────┴─────────────────────────────────────┘
+
+    ┌─────────────────────┬─────────────────────────────────────┐
+    │ zone                │ time                                │
+    ├─────────────────────┼─────────────────────────────────────┤
+    │ UTC                 │ 2024-03-31 01:00:00.000000Z         │
+    │ Europe/London       │ 2024-03-31 02:00:00.000000+01:00    │
+    │ Europe/London+0s    │ 2024-03-31 02:00:00.000000+01:00    │
+    │ Europe/London+1h    │ 2024-03-31 03:00:00.000000+02:00    │
+    │ Europe/London-1h    │ 2024-03-31 01:00:00.000000Z         │
+    │ Europe/London+30s   │ 2024-03-31 02:00:30.000000+01:00:30 │
+    │ Europe/London-30s   │ 2024-03-31 01:59:30.000000+00:59:30 │
+    │ Europe/London+30.1s │ 2024-03-31 02:00:30.000000+01:00:30 │
+    │ Europe/London-30.1s │ 2024-03-31 01:59:29.000000+00:59:29 │
+    │ one half hour       │ 2024-03-31 02:30:00.000000+01:30    │
+    └─────────────────────┴─────────────────────────────────────┘
+
+    ┌─────────────────────┬─────────────────────────────────────┐
+    │ zone                │ time                                │
+    ├─────────────────────┼─────────────────────────────────────┤
+    │ UTC                 │ 2024-10-27 01:00:00.000000Z         │
+    │ Europe/London       │ 2024-10-27 01:00:00.000000Z         │
+    │ Europe/London+0s    │ 2024-10-27 01:00:00.000000Z         │
+    │ Europe/London+1h    │ 2024-10-27 02:00:00.000000+01:00    │
+    │ Europe/London-1h    │ 2024-10-27 00:00:00.000000-01:00    │
+    │ Europe/London+30s   │ 2024-10-27 01:00:30.000000+00:00:30 │
+    │ Europe/London-30s   │ 2024-10-27 00:59:30.000000-00:00:30 │
+    │ Europe/London+30.1s │ 2024-10-27 01:00:30.000000+00:00:30 │
+    │ Europe/London-30.1s │ 2024-10-27 00:59:29.000000-00:00:31 │
+    │ one half hour       │ 2024-10-27 01:30:00.000000+00:30    │
+    └─────────────────────┴─────────────────────────────────────┘
+
+    ┌─────────────────────┬─────────────────────────────────────┐
+    │ zone                │ time                                │
+    ├─────────────────────┼─────────────────────────────────────┤
+    │ UTC                 │ 2025-01-01 00:00:00.000000Z         │
+    │ Europe/London       │ 2025-01-01 00:00:00.000000Z         │
+    │ Europe/London+0s    │ 2025-01-01 00:00:00.000000Z         │
+    │ Europe/London+1h    │ 2025-01-01 01:00:00.000000+01:00    │
+    │ Europe/London-1h    │ 2024-12-31 23:00:00.000000-01:00    │
+    │ Europe/London+30s   │ 2025-01-01 00:00:30.000000+00:00:30 │
+    │ Europe/London-30s   │ 2024-12-31 23:59:30.000000-00:00:30 │
+    │ Europe/London+30.1s │ 2025-01-01 00:00:30.000000+00:00:30 │
+    │ Europe/London-30.1s │ 2024-12-31 23:59:29.000000-00:00:31 │
+    │ one half hour       │ 2025-01-01 00:30:00.000000+00:30    │
+    └─────────────────────┴─────────────────────────────────────┘
+    |}];
+  test (Some (Timezone.find_exn "America/New_York"));
+  [%expect
+    {|
+    ┌────────────────────────┬─────────────────────────────────────┐
+    │ zone                   │ time                                │
+    ├────────────────────────┼─────────────────────────────────────┤
+    │ UTC                    │ 2024-01-01 00:00:00.000000Z         │
+    │ America/New_York       │ 2023-12-31 19:00:00.000000-05:00    │
+    │ America/New_York+0s    │ 2023-12-31 19:00:00.000000-05:00    │
+    │ America/New_York+1h    │ 2023-12-31 20:00:00.000000-04:00    │
+    │ America/New_York-1h    │ 2023-12-31 18:00:00.000000-06:00    │
+    │ America/New_York+30s   │ 2023-12-31 19:00:30.000000-04:59:30 │
+    │ America/New_York-30s   │ 2023-12-31 18:59:30.000000-05:00:30 │
+    │ America/New_York+30.1s │ 2023-12-31 19:00:30.000000-04:59:30 │
+    │ America/New_York-30.1s │ 2023-12-31 18:59:29.000000-05:00:31 │
+    │ one half hour          │ 2023-12-31 19:30:00.000000-04:30    │
+    └────────────────────────┴─────────────────────────────────────┘
+
+    ┌────────────────────────┬─────────────────────────────────────┐
+    │ zone                   │ time                                │
+    ├────────────────────────┼─────────────────────────────────────┤
+    │ UTC                    │ 2024-03-10 07:00:00.000000Z         │
+    │ America/New_York       │ 2024-03-10 03:00:00.000000-04:00    │
+    │ America/New_York+0s    │ 2024-03-10 03:00:00.000000-04:00    │
+    │ America/New_York+1h    │ 2024-03-10 04:00:00.000000-03:00    │
+    │ America/New_York-1h    │ 2024-03-10 02:00:00.000000-05:00    │
+    │ America/New_York+30s   │ 2024-03-10 03:00:30.000000-03:59:30 │
+    │ America/New_York-30s   │ 2024-03-10 02:59:30.000000-04:00:30 │
+    │ America/New_York+30.1s │ 2024-03-10 03:00:30.000000-03:59:30 │
+    │ America/New_York-30.1s │ 2024-03-10 02:59:29.000000-04:00:31 │
+    │ one half hour          │ 2024-03-10 03:30:00.000000-03:30    │
+    └────────────────────────┴─────────────────────────────────────┘
+
+    ┌────────────────────────┬─────────────────────────────────────┐
+    │ zone                   │ time                                │
+    ├────────────────────────┼─────────────────────────────────────┤
+    │ UTC                    │ 2024-11-03 06:00:00.000000Z         │
+    │ America/New_York       │ 2024-11-03 01:00:00.000000-05:00    │
+    │ America/New_York+0s    │ 2024-11-03 01:00:00.000000-05:00    │
+    │ America/New_York+1h    │ 2024-11-03 02:00:00.000000-04:00    │
+    │ America/New_York-1h    │ 2024-11-03 00:00:00.000000-06:00    │
+    │ America/New_York+30s   │ 2024-11-03 01:00:30.000000-04:59:30 │
+    │ America/New_York-30s   │ 2024-11-03 00:59:30.000000-05:00:30 │
+    │ America/New_York+30.1s │ 2024-11-03 01:00:30.000000-04:59:30 │
+    │ America/New_York-30.1s │ 2024-11-03 00:59:29.000000-05:00:31 │
+    │ one half hour          │ 2024-11-03 01:30:00.000000-04:30    │
+    └────────────────────────┴─────────────────────────────────────┘
+
+    ┌────────────────────────┬─────────────────────────────────────┐
+    │ zone                   │ time                                │
+    ├────────────────────────┼─────────────────────────────────────┤
+    │ UTC                    │ 2025-01-01 00:00:00.000000Z         │
+    │ America/New_York       │ 2024-12-31 19:00:00.000000-05:00    │
+    │ America/New_York+0s    │ 2024-12-31 19:00:00.000000-05:00    │
+    │ America/New_York+1h    │ 2024-12-31 20:00:00.000000-04:00    │
+    │ America/New_York-1h    │ 2024-12-31 18:00:00.000000-06:00    │
+    │ America/New_York+30s   │ 2024-12-31 19:00:30.000000-04:59:30 │
+    │ America/New_York-30s   │ 2024-12-31 18:59:30.000000-05:00:30 │
+    │ America/New_York+30.1s │ 2024-12-31 19:00:30.000000-04:59:30 │
+    │ America/New_York-30.1s │ 2024-12-31 18:59:29.000000-05:00:31 │
+    │ one half hour          │ 2024-12-31 19:30:00.000000-04:30    │
+    └────────────────────────┴─────────────────────────────────────┘
+    |}]
+;;
Index: core-0.17.1/core/test/test_timezone.mli
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_timezone.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
Index: core-0.17.1/core/test/test_timezone_full_data_protocol.ml
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_timezone_full_data_protocol.ml
@@ -0,0 +1,1270 @@
+open! Core
+open! Import
+
+let%expect_test "Time.Stable.Zone.Full_data.V1" =
+  let sample =
+    Time_float.Zone.input_tz_file
+      ~zonename:"Sample Time Zone"
+      ~filename:"sample_time_zone_file"
+  in
+  Ref.set_temporarily sexp_style Sexp_style.simple_pretty ~f:(fun () ->
+    print_and_check_stable_type
+      (module Time_float.Stable.Zone.Full_data.V1)
+      [ Time_float.Zone.utc
+      ; Time_float.Zone.of_utc_offset ~hours:(-24)
+      ; Time_float.Zone.of_utc_offset_explicit_name ~name:"my zone" ~hours:1
+      ; Time_float.Zone.of_utc_offset_in_seconds_round_down
+          (Time_float.Span.of_string "-3h2m1s")
+      ; sample
+      ; Time_float.Zone.add_offset_in_seconds_round_down
+          sample
+          ~name:"offset sample"
+          ~span:Time_float.Span.hour
+      ]);
+  [%expect
+    {|
+    (bin_shape_digest 819b3454610960b488fbed8a9e63887c)
+    ((sexp
+      ((name UTC)
+       (original_filename ())
+       (digest ())
+       (transitions ())
+       (last_regime_index 0)
+       (default_local_time_type
+        ((utc_offset_in_seconds 0) (is_dst false) (abbrv UTC)))
+       (leap_seconds ())))
+     (bin_io "\003UTC\000\000\000\000\000\000\003UTC\000"))
+    ((sexp
+      ((name UTC-24)
+       (original_filename ())
+       (digest ())
+       (transitions ())
+       (last_regime_index 0)
+       (default_local_time_type
+        ((utc_offset_in_seconds -86_400) (is_dst false) (abbrv UTC-24)))
+       (leap_seconds ())))
+     (bin_io "\006UTC-24\000\000\000\000\253\128\174\254\255\000\006UTC-24\000"))
+    ((sexp
+      ((name "my zone")
+       (original_filename ())
+       (digest ())
+       (transitions ())
+       (last_regime_index 0)
+       (default_local_time_type
+        ((utc_offset_in_seconds 3_600) (is_dst false) (abbrv "my zone")))
+       (leap_seconds ())))
+     (bin_io "\007my zone\000\000\000\000\254\016\014\000\007my zone\000"))
+    ((sexp
+      ((name UTC-3:02:01)
+       (original_filename ())
+       (digest ())
+       (transitions ())
+       (last_regime_index 0)
+       (default_local_time_type
+        ((utc_offset_in_seconds -10_921) (is_dst false) (abbrv UTC-3:02:01)))
+       (leap_seconds ())))
+     (bin_io "\011UTC-3:02:01\000\000\000\000\254W\213\000\011UTC-3:02:01\000"))
+    ((sexp
+      ((name "Sample Time Zone")
+       (original_filename (sample_time_zone_file))
+       (digest ("\228\2028\0165\163Kz\133!\132\204\r\216\155\170"))
+       (transitions
+        (((start_time_in_seconds_since_epoch -2_717_650_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_633_280_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_615_140_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_601_830_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_583_690_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_570_381_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_551_636_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_536_512_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_523_210_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_504_458_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_491_760_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_473_008_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_459_706_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_441_558_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_428_256_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_410_109_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_396_807_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_378_659_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_365_357_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_347_210_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_333_908_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_315_155_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_301_853_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_283_706_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_270_404_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_252_256_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_238_954_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_220_806_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_207_504_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_189_357_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_176_055_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_157_302_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_144_605_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_125_853_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_112_551_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_094_403_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_081_101_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_062_954_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_049_652_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_031_504_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_018_202_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_000_054_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -986_752_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -968_000_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -955_303_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -936_550_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -923_248_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -905_101_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -891_799_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -880_218_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EWT))))
+         ((start_time_in_seconds_since_epoch -769_395_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EPT))))
+         ((start_time_in_seconds_since_epoch -765_396_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -747_248_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -733_946_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -715_798_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -702_496_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -684_349_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -671_047_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -652_899_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -639_597_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -620_845_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -608_148_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -589_395_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -576_093_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -557_946_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -544_644_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -526_496_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -513_194_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -495_046_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -481_744_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -463_597_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -447_271_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -431_542_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -415_821_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -400_093_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -384_372_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -368_643_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -352_922_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -337_194_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -321_472_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -305_744_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -289_418_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -273_690_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -257_968_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -242_240_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -226_519_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -210_790_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -195_069_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -179_341_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -163_620_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -147_891_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -131_565_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -116_442_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -100_116_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -84_387_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -68_666_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -52_938_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -37_216_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -21_488_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -5_767_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 9_961_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 25_682_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 41_410_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 57_736_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 73_465_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 89_186_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 104_914_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 120_636_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 126_687_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 152_085_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 162_370_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 183_535_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 199_263_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 215_589_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 230_713_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 247_039_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 262_767_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 278_488_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 294_217_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 309_938_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 325_666_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 341_388_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 357_116_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 372_837_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 388_566_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 404_892_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 420_015_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 436_341_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 452_070_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 467_791_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 483_519_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 499_240_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 514_969_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 530_690_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 544_604_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 562_140_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 576_054_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 594_194_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 607_503_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 625_644_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 638_953_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 657_093_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 671_007_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 688_543_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 702_457_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 719_992_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 733_906_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 752_047_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 765_356_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 783_496_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 796_806_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 814_946_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 828_860_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 846_396_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 860_310_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 877_845_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 891_759_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 909_295_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 923_209_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 941_349_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 954_658_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 972_799_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 986_108_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_004_248_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_018_162_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_035_698_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_049_612_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_067_148_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_081_062_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_099_202_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_112_511_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_130_652_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_143_961_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_162_101_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_173_596_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_194_156_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_205_046_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_225_605_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_236_495_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_257_055_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_268_550_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_289_109_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_299_999_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_320_559_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_331_449_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_352_008_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_362_898_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_383_458_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_394_348_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_414_908_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_425_798_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_446_357_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_457_852_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_478_412_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_489_302_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_509_861_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_520_751_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_541_311_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_552_201_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_572_760_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_583_650_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_604_210_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_615_705_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_636_264_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_647_154_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_667_714_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_678_604_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_699_164_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_710_054_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_730_613_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_741_503_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_762_063_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_772_953_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_793_512_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_805_007_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_825_567_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_836_457_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_857_016_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_867_906_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_888_466_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_899_356_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_919_916_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_930_806_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_951_365_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_962_860_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_983_420_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_994_310_000)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_014_869_600)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_025_759_600)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_046_319_200)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_057_209_200)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_077_768_800)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_088_658_800)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_109_218_400)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_120_108_400)
+          (new_regime ((utc_offset_in_seconds -14_400) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_140_668_000)
+          (new_regime
+           ((utc_offset_in_seconds -18_000) (is_dst false) (abbrv EST))))))
+       (last_regime_index 0)
+       (default_local_time_type
+        ((utc_offset_in_seconds -17_762) (is_dst false) (abbrv LMT)))
+       (leap_seconds ())))
+     (bin_io
+      "\016Sample Time Zone\001\021sample_time_zone_file\001\016\228\2028\0165\163Kz\133!\132\204\r\216\155\170\254\236\000\252\144\240\003^\255\255\255\255\254\176\185\000\003EST\253p\030\166\158\254\192\199\001\003EDT\253`\235\186\159\254\176\185\000\003EST\253p\000\134\160\254\192\199\001\003EDT\253`\205\154\161\254\176\185\000\003EST\253p\226e\162\254\192\199\001\003EDT\253\224\233\131\163\254\176\185\000\003EST\253p\174j\164\254\192\199\001\003EDT\253`\1675\165\254\176\185\000\003EST\253\240\202S\166\254\192\199\001\003EDT\253`\137\021\167\254\176\185\000\003EST\253\240\1723\168\254\192\199\001\003EDT\253\224\165\254\168\254\176\185\000\003EST\253\240\142\019\170\254\192\199\001\003EDT\253\224\135\222\170\254\176\185\000\003EST\253\240p\243\171\254\192\199\001\003EDT\253\224i\190\172\254\176\185\000\003EST\253\240R\211\173\254\192\199\001\003EDT\253\224K\158\174\254\176\185\000\003EST\253\2404\179\175\254\192\199\001\003EDT\253\224-~\176\254\176\185\000\003EST\253pQ\156\177\254\192\199\001\003EDT\253`Jg\178\254\176\185\000\003EST\253p3|\179\254\192\199\001\003EDT\253`,G\180\254\176\185\000\003EST\253p\021\\\181\254\192\199\001\003EDT\253`\014'\182\254\176\185\000\003EST\253p\247;\183\254\192\199\001\003EDT\253`\240\006\184\254\176\185\000\003EST\253p\217\027\185\254\192\199\001\003EDT\253`\210\230\185\254\176\185\000\003EST\253\240\245\004\187\254\192\199\001\003EDT\253`\180\198\187\254\176\185\000\003EST\253\240\215\228\188\254\192\199\001\003EDT\253\224\208\175\189\254\176\185\000\003EST\253\240\185\196\190\254\192\199\001\003EDT\253\224\178\143\191\254\176\185\000\003EST\253\240\155\164\192\254\192\199\001\003EDT\253\224\148o\193\254\176\185\000\003EST\253\240}\132\194\254\192\199\001\003EDT\253\224vO\195\254\176\185\000\003EST\253\240_d\196\254\192\199\001\003EDT\253\224X/\197\254\176\185\000\003EST\253p|M\198\254\192\199\001\003EDT\253\224:\015\199\254\176\185\000\003EST\253p^-\200\254\192\199\001\003EDT\253`W\248\200\254\176\185\000\003EST\253p@\r\202\254\192\199\001\003EDT\253`9\216\202\254\176\185\000\003EST\253p\240\136\203\254\192\199\001\003EWT\253p\244#\210\254\192\199\001\003EPT\253\224\251`\210\254\176\185\000\003EST\253\240\228u\211\254\192\199\001\003EDT\253\224\221@\212\254\176\185\000\003EST\253\240\198U\213\254\192\199\001\003EDT\253\224\191 \214\254\176\185\000\003EST\253\240\1685\215\254\192\199\001\003EDT\253\224\161\000\216\254\176\185\000\003EST\253\240\138\021\217\254\192\199\001\003EDT\253\224\131\224\217\254\176\185\000\003EST\253p\167\254\218\254\192\199\001\003EDT\253\224e\192\219\254\176\185\000\003EST\253p\137\222\220\254\192\199\001\003EDT\253`\130\169\221\254\176\185\000\003EST\253pk\190\222\254\192\199\001\003EDT\253`d\137\223\254\176\185\000\003EST\253pM\158\224\254\192\199\001\003EDT\253`Fi\225\254\176\185\000\003EST\253p/~\226\254\192\199\001\003EDT\253`(I\227\254\176\185\000\003EST\253p\017^\228\254\192\199\001\003EDT\253\224.W\229\254\176\185\000\003EST\253\240-G\230\254\192\199\001\003EDT\253\224\0167\231\254\176\185\000\003EST\253\240\015'\232\254\192\199\001\003EDT\253\224\242\022\233\254\176\185\000\003EST\253\240\241\006\234\254\192\199\001\003EDT\253\224\212\246\234\254\176\185\000\003EST\253\240\211\230\235\254\192\199\001\003EDT\253\224\182\214\236\254\176\185\000\003EST\253\240\181\198\237\254\192\199\001\003EDT\253`\211\191\238\254\176\185\000\003EST\253p\210\175\239\254\192\199\001\003EDT\253`\181\159\240\254\176\185\000\003EST\253p\180\143\241\254\192\199\001\003EDT\253`\151\127\242\254\176\185\000\003EST\253p\150o\243\254\192\199\001\003EDT\253`y_\244\254\176\185\000\003EST\253pxO\245\254\192\199\001\003EDT\253`[?\246\254\176\185\000\003EST\253pZ/\247\254\192\199\001\003EDT\253\224w(\248\254\176\185\000\003EST\253p<\015\249\254\192\199\001\003EDT\253\224Y\b\250\254\176\185\000\003EST\253\240X\248\250\254\192\199\001\003EDT\253\224;\232\251\254\176\185\000\003EST\253\240:\216\252\254\192\199\001\003EDT\253\224\029\200\253\254\176\185\000\003EST\253\240\028\184\254\254\192\199\001\003EDT\253\224\255\167\255\254\176\185\000\003EST\253\240\254\151\000\254\192\199\001\003EDT\253\224\225\135\001\254\176\185\000\003EST\253\240\224w\002\254\192\199\001\003EDT\253`\254p\003\254\176\185\000\003EST\253p\253`\004\254\192\199\001\003EDT\253`\224P\005\254\176\185\000\003EST\253p\223@\006\254\192\199\001\003EDT\253`\1940\007\254\176\185\000\003EST\253p\025\141\007\254\192\199\001\003EDT\253`\164\016\t\254\176\185\000\003EST\253\240\148\173\t\254\192\199\001\003EDT\253`\134\240\n\254\176\185\000\003EST\253p\133\224\011\254\192\199\001\003EDT\253\224\162\217\012\254\176\185\000\003EST\253pg\192\r\254\192\199\001\003EDT\253\224\132\185\014\254\176\185\000\003EST\253\240\131\169\015\254\192\199\001\003EDT\253\224f\153\016\254\176\185\000\003EST\253\240e\137\017\254\192\199\001\003EDT\253\224Hy\018\254\176\185\000\003EST\253\240Gi\019\254\192\199\001\003EDT\253\224*Y\020\254\176\185\000\003EST\253\240)I\021\254\192\199\001\003EDT\253\224\0129\022\254\176\185\000\003EST\253\240\011)\023\254\192\199\001\003EDT\253`)\"\024\254\176\185\000\003EST\253\240\237\b\025\254\192\199\001\003EDT\253`\011\002\026\254\176\185\000\003EST\253p\n\242\026\254\192\199\001\003EDT\253`\237\225\027\254\176\185\000\003EST\253p\236\209\028\254\192\199\001\003EDT\253`\207\193\029\254\176\185\000\003EST\253p\206\177\030\254\192\199\001\003EDT\253`\177\161\031\254\176\185\000\003EST\253\240\000v \254\192\199\001\003EDT\253`\147\129!\254\176\185\000\003EST\253\240\226U\"\254\192\199\001\003EDT\253\224\175j#\254\176\185\000\003EST\253\240\1965$\254\192\199\001\003EDT\253\224\145J%\254\176\185\000\003EST\253\240\166\021&\254\192\199\001\003EDT\253\224s*'\254\176\185\000\003EST\253p\195\254'\254\192\199\001\003EDT\253\224U\n)\254\176\185\000\003EST\253p\165\222)\254\192\199\001\003EDT\253\2247\234*\254\176\185\000\003EST\253p\135\190+\254\192\199\001\003EDT\253`T\211,\254\176\185\000\003EST\253pi\158-\254\192\199\001\003EDT\253`6\179.\254\176\185\000\003EST\253pK~/\254\192\199\001\003EDT\253`\024\1470\254\176\185\000\003EST\253\240gg1\254\192\199\001\003EDT\253`\250r2\254\176\185\000\003EST\253\240IG3\254\192\199\001\003EDT\253`\220R4\254\176\185\000\003EST\253\240+'5\254\192\199\001\003EDT\253`\19026\254\176\185\000\003EST\253\240\r\0077\254\192\199\001\003EDT\253\224\218\0278\254\176\185\000\003EST\253\240\239\2308\254\192\199\001\003EDT\253\224\188\2519\254\176\185\000\003EST\253\240\209\198:\254\192\199\001\003EDT\253\224\158\219;\254\176\185\000\003EST\253p\238\175<\254\192\199\001\003EDT\253\224\128\187=\254\176\185\000\003EST\253p\208\143>\254\192\199\001\003EDT\253\224b\155?\254\176\185\000\003EST\253p\178o@\254\192\199\001\003EDT\253`\127\132A\254\176\185\000\003EST\253p\148OB\254\192\199\001\003EDT\253`adC\254\176\185\000\003EST\253pv/D\254\192\199\001\003EDT\253`CDE\254\176\185\000\003EST\253\240\168\243E\254\192\199\001\003EDT\253\224_-G\254\176\185\000\003EST\253\240\138\211G\254\192\199\001\003EDT\253\224A\rI\254\176\185\000\003EST\253\240l\179I\254\192\199\001\003EDT\253\224#\237J\254\176\185\000\003EST\253p\137\156K\254\192\199\001\003EDT\253`@\214L\254\176\185\000\003EST\253pk|M\254\192\199\001\003EDT\253`\"\182N\254\176\185\000\003EST\253pM\\O\254\192\199\001\003EDT\253`\004\150P\254\176\185\000\003EST\253p/<Q\254\192\199\001\003EDT\253`\230uR\254\176\185\000\003EST\253p\017\028S\254\192\199\001\003EDT\253`\200UT\254\176\185\000\003EST\253p\243\251T\254\192\199\001\003EDT\253`\1705V\254\176\185\000\003EST\253\240\015\229V\254\192\199\001\003EDT\253\224\198\030X\254\176\185\000\003EST\253\240\241\196X\254\192\199\001\003EDT\253\224\168\254Y\254\176\185\000\003EST\253\240\211\164Z\254\192\199\001\003EDT\253\224\138\222[\254\176\185\000\003EST\253\240\181\132\\\254\192\199\001\003EDT\253\224l\190]\254\176\185\000\003EST\253\240\151d^\254\192\199\001\003EDT\253\224N\158_\254\176\185\000\003EST\253p\180M`\254\192\199\001\003EDT\253`k\135a\254\176\185\000\003EST\253p\150-b\254\192\199\001\003EDT\253`Mgc\254\176\185\000\003EST\253px\rd\254\192\199\001\003EDT\253`/Ge\254\176\185\000\003EST\253pZ\237e\254\192\199\001\003EDT\253`\017'g\254\176\185\000\003EST\253p<\205g\254\192\199\001\003EDT\253`\243\006i\254\176\185\000\003EST\253p\030\173i\254\192\199\001\003EDT\253`\213\230j\254\176\185\000\003EST\253\240:\150k\254\192\199\001\003EDT\253\224\241\207l\254\176\185\000\003EST\253\240\028vm\254\192\199\001\003EDT\253\224\211\175n\254\176\185\000\003EST\253\240\254Uo\254\192\199\001\003EDT\253\224\181\143p\254\176\185\000\003EST\253\240\2245q\254\192\199\001\003EDT\253\224\151or\254\176\185\000\003EST\253\240\194\021s\254\192\199\001\003EDT\253\224yOt\254\176\185\000\003EST\253p\223\254t\254\192\199\001\003EDT\253`\1508v\254\176\185\000\003EST\253p\193\222v\254\192\199\001\003EDT\253`x\024x\254\176\185\000\003EST\253p\163\190x\254\192\199\001\003EDT\253`Z\248y\254\176\185\000\003EST\253p\133\158z\254\192\199\001\003EDT\253`<\216{\254\176\185\000\003EST\253pg~|\254\192\199\001\003EDT\253`\030\184}\254\176\185\000\003EST\253pI^~\254\192\199\001\003EDT\253`\000\152\127\254\176\185\000\003EST\000\254\158\186\000\003LMT\000"))
+    ((sexp
+      ((name "offset sample")
+       (original_filename ())
+       (digest ())
+       (transitions
+        (((start_time_in_seconds_since_epoch -2_717_650_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_633_280_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_615_140_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_601_830_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_583_690_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_570_381_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_551_636_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_536_512_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_523_210_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_504_458_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_491_760_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_473_008_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_459_706_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_441_558_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_428_256_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_410_109_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_396_807_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_378_659_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_365_357_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_347_210_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_333_908_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_315_155_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_301_853_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_283_706_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_270_404_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_252_256_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_238_954_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_220_806_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_207_504_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_189_357_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_176_055_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_157_302_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_144_605_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_125_853_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_112_551_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_094_403_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_081_101_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_062_954_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_049_652_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_031_504_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -1_018_202_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -1_000_054_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -986_752_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -968_000_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -955_303_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -936_550_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -923_248_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -905_101_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -891_799_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -880_218_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EWT))))
+         ((start_time_in_seconds_since_epoch -769_395_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EPT))))
+         ((start_time_in_seconds_since_epoch -765_396_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -747_248_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -733_946_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -715_798_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -702_496_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -684_349_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -671_047_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -652_899_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -639_597_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -620_845_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -608_148_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -589_395_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -576_093_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -557_946_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -544_644_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -526_496_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -513_194_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -495_046_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -481_744_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -463_597_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -447_271_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -431_542_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -415_821_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -400_093_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -384_372_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -368_643_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -352_922_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -337_194_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -321_472_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -305_744_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -289_418_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -273_690_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -257_968_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -242_240_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -226_519_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -210_790_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -195_069_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -179_341_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -163_620_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -147_891_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -131_565_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -116_442_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -100_116_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -84_387_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -68_666_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -52_938_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -37_216_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch -21_488_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch -5_767_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 9_961_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 25_682_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 41_410_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 57_736_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 73_465_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 89_186_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 104_914_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 120_636_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 126_687_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 152_085_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 162_370_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 183_535_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 199_263_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 215_589_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 230_713_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 247_039_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 262_767_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 278_488_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 294_217_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 309_938_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 325_666_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 341_388_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 357_116_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 372_837_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 388_566_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 404_892_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 420_015_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 436_341_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 452_070_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 467_791_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 483_519_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 499_240_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 514_969_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 530_690_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 544_604_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 562_140_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 576_054_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 594_194_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 607_503_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 625_644_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 638_953_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 657_093_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 671_007_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 688_543_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 702_457_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 719_992_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 733_906_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 752_047_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 765_356_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 783_496_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 796_806_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 814_946_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 828_860_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 846_396_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 860_310_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 877_845_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 891_759_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 909_295_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 923_209_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 941_349_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 954_658_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 972_799_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 986_108_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_004_248_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_018_162_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_035_698_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_049_612_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_067_148_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_081_062_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_099_202_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_112_511_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_130_652_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_143_961_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_162_101_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_173_596_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_194_156_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_205_046_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_225_605_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_236_495_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_257_055_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_268_550_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_289_109_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_299_999_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_320_559_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_331_449_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_352_008_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_362_898_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_383_458_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_394_348_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_414_908_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_425_798_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_446_357_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_457_852_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_478_412_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_489_302_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_509_861_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_520_751_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_541_311_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_552_201_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_572_760_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_583_650_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_604_210_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_615_705_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_636_264_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_647_154_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_667_714_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_678_604_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_699_164_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_710_054_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_730_613_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_741_503_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_762_063_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_772_953_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_793_512_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_805_007_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_825_567_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_836_457_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_857_016_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_867_906_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_888_466_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_899_356_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_919_916_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_930_806_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_951_365_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_962_860_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 1_983_420_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 1_994_310_000)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_014_869_600)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_025_759_600)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_046_319_200)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_057_209_200)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_077_768_800)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_088_658_800)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_109_218_400)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))
+         ((start_time_in_seconds_since_epoch 2_120_108_400)
+          (new_regime ((utc_offset_in_seconds -10_800) (is_dst true) (abbrv EDT))))
+         ((start_time_in_seconds_since_epoch 2_140_668_000)
+          (new_regime
+           ((utc_offset_in_seconds -14_400) (is_dst false) (abbrv EST))))))
+       (last_regime_index 0)
+       (default_local_time_type
+        ((utc_offset_in_seconds -14_162) (is_dst false) (abbrv LMT)))
+       (leap_seconds ())))
+     (bin_io
+      "\roffset sample\000\000\254\236\000\252\144\240\003^\255\255\255\255\254\192\199\000\003EST\253p\030\166\158\254\208\213\001\003EDT\253`\235\186\159\254\192\199\000\003EST\253p\000\134\160\254\208\213\001\003EDT\253`\205\154\161\254\192\199\000\003EST\253p\226e\162\254\208\213\001\003EDT\253\224\233\131\163\254\192\199\000\003EST\253p\174j\164\254\208\213\001\003EDT\253`\1675\165\254\192\199\000\003EST\253\240\202S\166\254\208\213\001\003EDT\253`\137\021\167\254\192\199\000\003EST\253\240\1723\168\254\208\213\001\003EDT\253\224\165\254\168\254\192\199\000\003EST\253\240\142\019\170\254\208\213\001\003EDT\253\224\135\222\170\254\192\199\000\003EST\253\240p\243\171\254\208\213\001\003EDT\253\224i\190\172\254\192\199\000\003EST\253\240R\211\173\254\208\213\001\003EDT\253\224K\158\174\254\192\199\000\003EST\253\2404\179\175\254\208\213\001\003EDT\253\224-~\176\254\192\199\000\003EST\253pQ\156\177\254\208\213\001\003EDT\253`Jg\178\254\192\199\000\003EST\253p3|\179\254\208\213\001\003EDT\253`,G\180\254\192\199\000\003EST\253p\021\\\181\254\208\213\001\003EDT\253`\014'\182\254\192\199\000\003EST\253p\247;\183\254\208\213\001\003EDT\253`\240\006\184\254\192\199\000\003EST\253p\217\027\185\254\208\213\001\003EDT\253`\210\230\185\254\192\199\000\003EST\253\240\245\004\187\254\208\213\001\003EDT\253`\180\198\187\254\192\199\000\003EST\253\240\215\228\188\254\208\213\001\003EDT\253\224\208\175\189\254\192\199\000\003EST\253\240\185\196\190\254\208\213\001\003EDT\253\224\178\143\191\254\192\199\000\003EST\253\240\155\164\192\254\208\213\001\003EDT\253\224\148o\193\254\192\199\000\003EST\253\240}\132\194\254\208\213\001\003EDT\253\224vO\195\254\192\199\000\003EST\253\240_d\196\254\208\213\001\003EDT\253\224X/\197\254\192\199\000\003EST\253p|M\198\254\208\213\001\003EDT\253\224:\015\199\254\192\199\000\003EST\253p^-\200\254\208\213\001\003EDT\253`W\248\200\254\192\199\000\003EST\253p@\r\202\254\208\213\001\003EDT\253`9\216\202\254\192\199\000\003EST\253p\240\136\203\254\208\213\001\003EWT\253p\244#\210\254\208\213\001\003EPT\253\224\251`\210\254\192\199\000\003EST\253\240\228u\211\254\208\213\001\003EDT\253\224\221@\212\254\192\199\000\003EST\253\240\198U\213\254\208\213\001\003EDT\253\224\191 \214\254\192\199\000\003EST\253\240\1685\215\254\208\213\001\003EDT\253\224\161\000\216\254\192\199\000\003EST\253\240\138\021\217\254\208\213\001\003EDT\253\224\131\224\217\254\192\199\000\003EST\253p\167\254\218\254\208\213\001\003EDT\253\224e\192\219\254\192\199\000\003EST\253p\137\222\220\254\208\213\001\003EDT\253`\130\169\221\254\192\199\000\003EST\253pk\190\222\254\208\213\001\003EDT\253`d\137\223\254\192\199\000\003EST\253pM\158\224\254\208\213\001\003EDT\253`Fi\225\254\192\199\000\003EST\253p/~\226\254\208\213\001\003EDT\253`(I\227\254\192\199\000\003EST\253p\017^\228\254\208\213\001\003EDT\253\224.W\229\254\192\199\000\003EST\253\240-G\230\254\208\213\001\003EDT\253\224\0167\231\254\192\199\000\003EST\253\240\015'\232\254\208\213\001\003EDT\253\224\242\022\233\254\192\199\000\003EST\253\240\241\006\234\254\208\213\001\003EDT\253\224\212\246\234\254\192\199\000\003EST\253\240\211\230\235\254\208\213\001\003EDT\253\224\182\214\236\254\192\199\000\003EST\253\240\181\198\237\254\208\213\001\003EDT\253`\211\191\238\254\192\199\000\003EST\253p\210\175\239\254\208\213\001\003EDT\253`\181\159\240\254\192\199\000\003EST\253p\180\143\241\254\208\213\001\003EDT\253`\151\127\242\254\192\199\000\003EST\253p\150o\243\254\208\213\001\003EDT\253`y_\244\254\192\199\000\003EST\253pxO\245\254\208\213\001\003EDT\253`[?\246\254\192\199\000\003EST\253pZ/\247\254\208\213\001\003EDT\253\224w(\248\254\192\199\000\003EST\253p<\015\249\254\208\213\001\003EDT\253\224Y\b\250\254\192\199\000\003EST\253\240X\248\250\254\208\213\001\003EDT\253\224;\232\251\254\192\199\000\003EST\253\240:\216\252\254\208\213\001\003EDT\253\224\029\200\253\254\192\199\000\003EST\253\240\028\184\254\254\208\213\001\003EDT\253\224\255\167\255\254\192\199\000\003EST\253\240\254\151\000\254\208\213\001\003EDT\253\224\225\135\001\254\192\199\000\003EST\253\240\224w\002\254\208\213\001\003EDT\253`\254p\003\254\192\199\000\003EST\253p\253`\004\254\208\213\001\003EDT\253`\224P\005\254\192\199\000\003EST\253p\223@\006\254\208\213\001\003EDT\253`\1940\007\254\192\199\000\003EST\253p\025\141\007\254\208\213\001\003EDT\253`\164\016\t\254\192\199\000\003EST\253\240\148\173\t\254\208\213\001\003EDT\253`\134\240\n\254\192\199\000\003EST\253p\133\224\011\254\208\213\001\003EDT\253\224\162\217\012\254\192\199\000\003EST\253pg\192\r\254\208\213\001\003EDT\253\224\132\185\014\254\192\199\000\003EST\253\240\131\169\015\254\208\213\001\003EDT\253\224f\153\016\254\192\199\000\003EST\253\240e\137\017\254\208\213\001\003EDT\253\224Hy\018\254\192\199\000\003EST\253\240Gi\019\254\208\213\001\003EDT\253\224*Y\020\254\192\199\000\003EST\253\240)I\021\254\208\213\001\003EDT\253\224\0129\022\254\192\199\000\003EST\253\240\011)\023\254\208\213\001\003EDT\253`)\"\024\254\192\199\000\003EST\253\240\237\b\025\254\208\213\001\003EDT\253`\011\002\026\254\192\199\000\003EST\253p\n\242\026\254\208\213\001\003EDT\253`\237\225\027\254\192\199\000\003EST\253p\236\209\028\254\208\213\001\003EDT\253`\207\193\029\254\192\199\000\003EST\253p\206\177\030\254\208\213\001\003EDT\253`\177\161\031\254\192\199\000\003EST\253\240\000v \254\208\213\001\003EDT\253`\147\129!\254\192\199\000\003EST\253\240\226U\"\254\208\213\001\003EDT\253\224\175j#\254\192\199\000\003EST\253\240\1965$\254\208\213\001\003EDT\253\224\145J%\254\192\199\000\003EST\253\240\166\021&\254\208\213\001\003EDT\253\224s*'\254\192\199\000\003EST\253p\195\254'\254\208\213\001\003EDT\253\224U\n)\254\192\199\000\003EST\253p\165\222)\254\208\213\001\003EDT\253\2247\234*\254\192\199\000\003EST\253p\135\190+\254\208\213\001\003EDT\253`T\211,\254\192\199\000\003EST\253pi\158-\254\208\213\001\003EDT\253`6\179.\254\192\199\000\003EST\253pK~/\254\208\213\001\003EDT\253`\024\1470\254\192\199\000\003EST\253\240gg1\254\208\213\001\003EDT\253`\250r2\254\192\199\000\003EST\253\240IG3\254\208\213\001\003EDT\253`\220R4\254\192\199\000\003EST\253\240+'5\254\208\213\001\003EDT\253`\19026\254\192\199\000\003EST\253\240\r\0077\254\208\213\001\003EDT\253\224\218\0278\254\192\199\000\003EST\253\240\239\2308\254\208\213\001\003EDT\253\224\188\2519\254\192\199\000\003EST\253\240\209\198:\254\208\213\001\003EDT\253\224\158\219;\254\192\199\000\003EST\253p\238\175<\254\208\213\001\003EDT\253\224\128\187=\254\192\199\000\003EST\253p\208\143>\254\208\213\001\003EDT\253\224b\155?\254\192\199\000\003EST\253p\178o@\254\208\213\001\003EDT\253`\127\132A\254\192\199\000\003EST\253p\148OB\254\208\213\001\003EDT\253`adC\254\192\199\000\003EST\253pv/D\254\208\213\001\003EDT\253`CDE\254\192\199\000\003EST\253\240\168\243E\254\208\213\001\003EDT\253\224_-G\254\192\199\000\003EST\253\240\138\211G\254\208\213\001\003EDT\253\224A\rI\254\192\199\000\003EST\253\240l\179I\254\208\213\001\003EDT\253\224#\237J\254\192\199\000\003EST\253p\137\156K\254\208\213\001\003EDT\253`@\214L\254\192\199\000\003EST\253pk|M\254\208\213\001\003EDT\253`\"\182N\254\192\199\000\003EST\253pM\\O\254\208\213\001\003EDT\253`\004\150P\254\192\199\000\003EST\253p/<Q\254\208\213\001\003EDT\253`\230uR\254\192\199\000\003EST\253p\017\028S\254\208\213\001\003EDT\253`\200UT\254\192\199\000\003EST\253p\243\251T\254\208\213\001\003EDT\253`\1705V\254\192\199\000\003EST\253\240\015\229V\254\208\213\001\003EDT\253\224\198\030X\254\192\199\000\003EST\253\240\241\196X\254\208\213\001\003EDT\253\224\168\254Y\254\192\199\000\003EST\253\240\211\164Z\254\208\213\001\003EDT\253\224\138\222[\254\192\199\000\003EST\253\240\181\132\\\254\208\213\001\003EDT\253\224l\190]\254\192\199\000\003EST\253\240\151d^\254\208\213\001\003EDT\253\224N\158_\254\192\199\000\003EST\253p\180M`\254\208\213\001\003EDT\253`k\135a\254\192\199\000\003EST\253p\150-b\254\208\213\001\003EDT\253`Mgc\254\192\199\000\003EST\253px\rd\254\208\213\001\003EDT\253`/Ge\254\192\199\000\003EST\253pZ\237e\254\208\213\001\003EDT\253`\017'g\254\192\199\000\003EST\253p<\205g\254\208\213\001\003EDT\253`\243\006i\254\192\199\000\003EST\253p\030\173i\254\208\213\001\003EDT\253`\213\230j\254\192\199\000\003EST\253\240:\150k\254\208\213\001\003EDT\253\224\241\207l\254\192\199\000\003EST\253\240\028vm\254\208\213\001\003EDT\253\224\211\175n\254\192\199\000\003EST\253\240\254Uo\254\208\213\001\003EDT\253\224\181\143p\254\192\199\000\003EST\253\240\2245q\254\208\213\001\003EDT\253\224\151or\254\192\199\000\003EST\253\240\194\021s\254\208\213\001\003EDT\253\224yOt\254\192\199\000\003EST\253p\223\254t\254\208\213\001\003EDT\253`\1508v\254\192\199\000\003EST\253p\193\222v\254\208\213\001\003EDT\253`x\024x\254\192\199\000\003EST\253p\163\190x\254\208\213\001\003EDT\253`Z\248y\254\192\199\000\003EST\253p\133\158z\254\208\213\001\003EDT\253`<\216{\254\192\199\000\003EST\253pg~|\254\208\213\001\003EDT\253`\030\184}\254\192\199\000\003EST\253pI^~\254\208\213\001\003EDT\253`\000\152\127\254\192\199\000\003EST\000\254\174\200\000\003LMT\000"))
+    |}]
+;;
Index: core-0.17.1/core/test/test_timezone_full_data_protocol.mli
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_timezone_full_data_protocol.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
Index: core-0.17.1/core/test/test_timezone_js_loader.ml
===================================================================
--- core-0.17.1.orig/core/test/test_timezone_js_loader.ml
+++ core-0.17.1/core/test/test_timezone_js_loader.ml
@@ -37,7 +37,7 @@ let%expect_test ("attempt to use from ja
   [%expect {| platform supported |}]
 ;;
 
-let%expect_test ("disable javascript support" [@tags "js-only"]) =
+let%expect_test ("disable javascript support" [@tags "js-only", "no-wasm"]) =
   Exn.protect
     ~f:(fun () ->
       Timezone_js_loader.For_testing.disable ();
@@ -46,6 +46,18 @@ let%expect_test ("disable javascript sup
     ~finally:Timezone_js_loader.For_testing.enable
 ;;
 
+let%expect_test ("disable wasm support (and it remains supported)" [@tags
+                                                                     "js-only"
+                                                                     , "wasm-only"])
+  =
+  Exn.protect
+    ~f:(fun () ->
+      Timezone_js_loader.For_testing.disable ();
+      print_result_kind "America/New_York";
+      [%expect {| platform supported |}])
+    ~finally:Timezone_js_loader.For_testing.enable
+;;
+
 let load_exn zone =
   match Timezone_js_loader.load zone with
   | Ok result -> result
Index: core-0.17.1/core/test/test_uchar.ml
===================================================================
--- core-0.17.1.orig/core/test/test_uchar.ml
+++ core-0.17.1/core/test/test_uchar.ml
@@ -3,7 +3,6 @@ open Expect_test_helpers_core
 
 let%expect_test "Stable.V1" =
   print_and_check_stable_type
-    [%here]
     (module Uchar.Stable.V1)
     [ Uchar.min_value (* 0x0000 *)
     ; Uchar.of_scalar_exn 0x007F
Index: core-0.17.1/core/test/test_union_find.ml
===================================================================
--- core-0.17.1.orig/core/test/test_union_find.ml
+++ core-0.17.1/core/test/test_union_find.ml
@@ -126,5 +126,5 @@ let%test_unit "balanced" =
 
 let%expect_test "[get] of a root does not allocate" =
   let t = create () in
-  require_no_allocation [%here] (fun () -> get t)
+  require_no_allocation (fun () -> get t)
 ;;
Index: core-0.17.1/core/test/test_unit.ml
===================================================================
--- core-0.17.1.orig/core/test/test_unit.ml
+++ core-0.17.1/core/test/test_unit.ml
@@ -19,10 +19,10 @@ let bin_prot_test
 ;;
 
 module Make (M : sig
-  type t = unit [@@deriving bin_io]
+    type t = unit [@@deriving bin_io]
 
-  val expected_size : int
-end) =
+    val expected_size : int
+  end) =
 struct
   let%test_unit "size" = [%test_result: int] (M.bin_size_t ()) ~expect:M.expected_size
 
@@ -60,20 +60,20 @@ struct
 end
 
 include Make (struct
-  include Unit.Stable.V1
+    include Unit.Stable.V1
 
-  let expected_size = 1
-end)
+    let expected_size = 1
+  end)
 
 include Make (struct
-  include Unit.Stable.V2
+    include Unit.Stable.V2
 
-  let expected_size = 0
-end)
+    let expected_size = 0
+  end)
 
 (* Should work like V1 *)
 include Make (struct
-  type t = unit [@@deriving bin_io]
+    type t = unit [@@deriving bin_io]
 
-  let expected_size = 1
-end)
+    let expected_size = 1
+  end)
Index: core-0.17.1/core/test/test_validate_bound.ml
===================================================================
--- core-0.17.1.orig/core/test/test_validate_bound.ml
+++ core-0.17.1/core/test/test_validate_bound.ml
@@ -39,7 +39,8 @@ let%expect_test "inf/nan" =
       ]
   in
   print res;
-  [%expect {|
+  [%expect
+    {|
     (bar.nan "value is NaN")
     (bar.inf "value is infinite")
     |}]
Index: core-0.17.1/core/test/test_validated.ml
===================================================================
--- core-0.17.1.orig/core/test/test_validated.ml
+++ core-0.17.1/core/test/test_validated.ml
@@ -25,7 +25,6 @@ let for_all (type a) raw_fn validated_fn
     let expected = raw_fn raw in
     let actual = validated_fn (V.create_exn raw) in
     require
-      [%here]
       (Output.equal expected actual)
       ~if_false_then_print_s:
         (lazy
@@ -42,7 +41,6 @@ let for_all2 (type a) raw_fn validated_f
       let expected = raw_fn raw1 raw2 in
       let actual = validated_fn (V.create_exn raw1) (V.create_exn raw2) in
       require
-        [%here]
         (Output.equal expected actual)
         ~if_false_then_print_s:
           (lazy
@@ -99,10 +97,10 @@ let%test_module _ =
     let does_raise = Exn.does_raise
 
     module M = Make (struct
-      let here = [%here]
+        let here = [%here]
 
-      include Positive_int
-    end)
+        include Positive_int
+      end)
 
     open M
 
@@ -135,18 +133,18 @@ let%test_module _ =
     ;;
 
     module M1 = Make_binable (struct
-      let here = [%here]
-      let validate_binio_deserialization = true
+        let here = [%here]
+        let validate_binio_deserialization = true
 
-      include Positive_int
-    end)
+        include Positive_int
+      end)
 
     module M2 = Make_binable (struct
-      let here = [%here]
-      let validate_binio_deserialization = false
+        let here = [%here]
+        let validate_binio_deserialization = false
 
-      include Positive_int
-    end)
+        include Positive_int
+      end)
 
     let int = 0
     let string = Binable.to_string (module Int) int
Index: core-0.17.1/core/test/test_zone.ml
===================================================================
--- core-0.17.1.orig/core/test/test_zone.ml
+++ /dev/null
@@ -1,1238 +0,0 @@
-open! Core
-open! Import
-
-let%expect_test "UTC survives round trip" =
-  let test ?cr zone =
-    require_does_not_raise [%here] ?cr (fun () ->
-      print_s [%sexp (Time_float.utc_offset Time_float.epoch ~zone : Time_float.Span.t)])
-  in
-  test Time_float.Zone.utc;
-  [%expect {| 0s |}];
-  let zone =
-    Time_float.Zone.utc
-    |> Binable.to_string (module Time_float.Stable.Zone.Full_data.V1)
-    |> Binable.of_string (module Time_float.Stable.Zone.Full_data.V1)
-  in
-  test zone;
-  [%expect {| 0s |}]
-;;
-
-let%expect_test "Time.Stable.Zone.Full_data.V1" =
-  print_and_check_stable_type
-    [%here]
-    (module Time_float.Stable.Zone.Full_data.V1)
-    [ Time_float.Zone.utc
-    ; Time_float.Zone.input_tz_file
-        ~zonename:"Sample Time Zone"
-        ~filename:"sample_time_zone_file"
-    ];
-  [%expect
-    {|
-    (bin_shape_digest 819b3454610960b488fbed8a9e63887c)
-    ((sexp (
-       (name UTC)
-       (original_filename ())
-       (digest            ())
-       (transitions       ())
-       (last_regime_index 0)
-       (default_local_time_type (
-         (utc_offset_in_seconds 0)
-         (is_dst                false)
-         (abbrv                 UTC)))
-       (leap_seconds ())))
-     (bin_io "\003UTC\000\000\000\000\000\000\003UTC\000"))
-    ((sexp (
-       (name "Sample Time Zone")
-       (original_filename (sample_time_zone_file))
-       (digest ("\228\2028\0165\163Kz\133!\132\204\r\216\155\170"))
-       (transitions (
-         ((start_time_in_seconds_since_epoch -2_717_650_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_633_280_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_615_140_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_601_830_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_583_690_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_570_381_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_551_636_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_536_512_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_523_210_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_504_458_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_491_760_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_473_008_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_459_706_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_441_558_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_428_256_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_410_109_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_396_807_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_378_659_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_365_357_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_347_210_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_333_908_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_315_155_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_301_853_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_283_706_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_270_404_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_252_256_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_238_954_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_220_806_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_207_504_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_189_357_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_176_055_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_157_302_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_144_605_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_125_853_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_112_551_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_094_403_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_081_101_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_062_954_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_049_652_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_031_504_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -1_018_202_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -1_000_054_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -986_752_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -968_000_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -955_303_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -936_550_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -923_248_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -905_101_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -891_799_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -880_218_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EWT))))
-         ((start_time_in_seconds_since_epoch -769_395_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EPT))))
-         ((start_time_in_seconds_since_epoch -765_396_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -747_248_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -733_946_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -715_798_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -702_496_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -684_349_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -671_047_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -652_899_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -639_597_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -620_845_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -608_148_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -589_395_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -576_093_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -557_946_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -544_644_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -526_496_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -513_194_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -495_046_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -481_744_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -463_597_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -447_271_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -431_542_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -415_821_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -400_093_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -384_372_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -368_643_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -352_922_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -337_194_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -321_472_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -305_744_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -289_418_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -273_690_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -257_968_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -242_240_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -226_519_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -210_790_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -195_069_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -179_341_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -163_620_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -147_891_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -131_565_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -116_442_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -100_116_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -84_387_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -68_666_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -52_938_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -37_216_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch -21_488_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch -5_767_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 9_961_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 25_682_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 41_410_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 57_736_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 73_465_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 89_186_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 104_914_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 120_636_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 126_687_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 152_085_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 162_370_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 183_535_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 199_263_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 215_589_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 230_713_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 247_039_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 262_767_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 278_488_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 294_217_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 309_938_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 325_666_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 341_388_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 357_116_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 372_837_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 388_566_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 404_892_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 420_015_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 436_341_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 452_070_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 467_791_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 483_519_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 499_240_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 514_969_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 530_690_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 544_604_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 562_140_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 576_054_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 594_194_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 607_503_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 625_644_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 638_953_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 657_093_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 671_007_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 688_543_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 702_457_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 719_992_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 733_906_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 752_047_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 765_356_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 783_496_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 796_806_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 814_946_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 828_860_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 846_396_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 860_310_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 877_845_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 891_759_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 909_295_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 923_209_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 941_349_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 954_658_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 972_799_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 986_108_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_004_248_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_018_162_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_035_698_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_049_612_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_067_148_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_081_062_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_099_202_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_112_511_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_130_652_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_143_961_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_162_101_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_173_596_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_194_156_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_205_046_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_225_605_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_236_495_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_257_055_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_268_550_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_289_109_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_299_999_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_320_559_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_331_449_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_352_008_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_362_898_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_383_458_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_394_348_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_414_908_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_425_798_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_446_357_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_457_852_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_478_412_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_489_302_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_509_861_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_520_751_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_541_311_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_552_201_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_572_760_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_583_650_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_604_210_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_615_705_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_636_264_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_647_154_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_667_714_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_678_604_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_699_164_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_710_054_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_730_613_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_741_503_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_762_063_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_772_953_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_793_512_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_805_007_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_825_567_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_836_457_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_857_016_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_867_906_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_888_466_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_899_356_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_919_916_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_930_806_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_951_365_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_962_860_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 1_983_420_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 1_994_310_000)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 2_014_869_600)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 2_025_759_600)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 2_046_319_200)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 2_057_209_200)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 2_077_768_800)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 2_088_658_800)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 2_109_218_400)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))
-         ((start_time_in_seconds_since_epoch 2_120_108_400)
-          (new_regime (
-            (utc_offset_in_seconds -14_400)
-            (is_dst                true)
-            (abbrv                 EDT))))
-         ((start_time_in_seconds_since_epoch 2_140_668_000)
-          (new_regime (
-            (utc_offset_in_seconds -18_000)
-            (is_dst                false)
-            (abbrv                 EST))))))
-       (last_regime_index 0)
-       (default_local_time_type (
-         (utc_offset_in_seconds -17_762)
-         (is_dst                false)
-         (abbrv                 LMT)))
-       (leap_seconds ())))
-     (bin_io
-      "\016Sample Time Zone\001\021sample_time_zone_file\001\016\228\2028\0165\163Kz\133!\132\204\r\216\155\170\254\236\000\252\144\240\003^\255\255\255\255\254\176\185\000\003EST\253p\030\166\158\254\192\199\001\003EDT\253`\235\186\159\254\176\185\000\003EST\253p\000\134\160\254\192\199\001\003EDT\253`\205\154\161\254\176\185\000\003EST\253p\226e\162\254\192\199\001\003EDT\253\224\233\131\163\254\176\185\000\003EST\253p\174j\164\254\192\199\001\003EDT\253`\1675\165\254\176\185\000\003EST\253\240\202S\166\254\192\199\001\003EDT\253`\137\021\167\254\176\185\000\003EST\253\240\1723\168\254\192\199\001\003EDT\253\224\165\254\168\254\176\185\000\003EST\253\240\142\019\170\254\192\199\001\003EDT\253\224\135\222\170\254\176\185\000\003EST\253\240p\243\171\254\192\199\001\003EDT\253\224i\190\172\254\176\185\000\003EST\253\240R\211\173\254\192\199\001\003EDT\253\224K\158\174\254\176\185\000\003EST\253\2404\179\175\254\192\199\001\003EDT\253\224-~\176\254\176\185\000\003EST\253pQ\156\177\254\192\199\001\003EDT\253`Jg\178\254\176\185\000\003EST\253p3|\179\254\192\199\001\003EDT\253`,G\180\254\176\185\000\003EST\253p\021\\\181\254\192\199\001\003EDT\253`\014'\182\254\176\185\000\003EST\253p\247;\183\254\192\199\001\003EDT\253`\240\006\184\254\176\185\000\003EST\253p\217\027\185\254\192\199\001\003EDT\253`\210\230\185\254\176\185\000\003EST\253\240\245\004\187\254\192\199\001\003EDT\253`\180\198\187\254\176\185\000\003EST\253\240\215\228\188\254\192\199\001\003EDT\253\224\208\175\189\254\176\185\000\003EST\253\240\185\196\190\254\192\199\001\003EDT\253\224\178\143\191\254\176\185\000\003EST\253\240\155\164\192\254\192\199\001\003EDT\253\224\148o\193\254\176\185\000\003EST\253\240}\132\194\254\192\199\001\003EDT\253\224vO\195\254\176\185\000\003EST\253\240_d\196\254\192\199\001\003EDT\253\224X/\197\254\176\185\000\003EST\253p|M\198\254\192\199\001\003EDT\253\224:\015\199\254\176\185\000\003EST\253p^-\200\254\192\199\001\003EDT\253`W\248\200\254\176\185\000\003EST\253p@\r\202\254\192\199\001\003EDT\253`9\216\202\254\176\185\000\003EST\253p\240\136\203\254\192\199\001\003EWT\253p\244#\210\254\192\199\001\003EPT\253\224\251`\210\254\176\185\000\003EST\253\240\228u\211\254\192\199\001\003EDT\253\224\221@\212\254\176\185\000\003EST\253\240\198U\213\254\192\199\001\003EDT\253\224\191 \214\254\176\185\000\003EST\253\240\1685\215\254\192\199\001\003EDT\253\224\161\000\216\254\176\185\000\003EST\253\240\138\021\217\254\192\199\001\003EDT\253\224\131\224\217\254\176\185\000\003EST\253p\167\254\218\254\192\199\001\003EDT\253\224e\192\219\254\176\185\000\003EST\253p\137\222\220\254\192\199\001\003EDT\253`\130\169\221\254\176\185\000\003EST\253pk\190\222\254\192\199\001\003EDT\253`d\137\223\254\176\185\000\003EST\253pM\158\224\254\192\199\001\003EDT\253`Fi\225\254\176\185\000\003EST\253p/~\226\254\192\199\001\003EDT\253`(I\227\254\176\185\000\003EST\253p\017^\228\254\192\199\001\003EDT\253\224.W\229\254\176\185\000\003EST\253\240-G\230\254\192\199\001\003EDT\253\224\0167\231\254\176\185\000\003EST\253\240\015'\232\254\192\199\001\003EDT\253\224\242\022\233\254\176\185\000\003EST\253\240\241\006\234\254\192\199\001\003EDT\253\224\212\246\234\254\176\185\000\003EST\253\240\211\230\235\254\192\199\001\003EDT\253\224\182\214\236\254\176\185\000\003EST\253\240\181\198\237\254\192\199\001\003EDT\253`\211\191\238\254\176\185\000\003EST\253p\210\175\239\254\192\199\001\003EDT\253`\181\159\240\254\176\185\000\003EST\253p\180\143\241\254\192\199\001\003EDT\253`\151\127\242\254\176\185\000\003EST\253p\150o\243\254\192\199\001\003EDT\253`y_\244\254\176\185\000\003EST\253pxO\245\254\192\199\001\003EDT\253`[?\246\254\176\185\000\003EST\253pZ/\247\254\192\199\001\003EDT\253\224w(\248\254\176\185\000\003EST\253p<\015\249\254\192\199\001\003EDT\253\224Y\b\250\254\176\185\000\003EST\253\240X\248\250\254\192\199\001\003EDT\253\224;\232\251\254\176\185\000\003EST\253\240:\216\252\254\192\199\001\003EDT\253\224\029\200\253\254\176\185\000\003EST\253\240\028\184\254\254\192\199\001\003EDT\253\224\255\167\255\254\176\185\000\003EST\253\240\254\151\000\254\192\199\001\003EDT\253\224\225\135\001\254\176\185\000\003EST\253\240\224w\002\254\192\199\001\003EDT\253`\254p\003\254\176\185\000\003EST\253p\253`\004\254\192\199\001\003EDT\253`\224P\005\254\176\185\000\003EST\253p\223@\006\254\192\199\001\003EDT\253`\1940\007\254\176\185\000\003EST\253p\025\141\007\254\192\199\001\003EDT\253`\164\016\t\254\176\185\000\003EST\253\240\148\173\t\254\192\199\001\003EDT\253`\134\240\n\254\176\185\000\003EST\253p\133\224\011\254\192\199\001\003EDT\253\224\162\217\012\254\176\185\000\003EST\253pg\192\r\254\192\199\001\003EDT\253\224\132\185\014\254\176\185\000\003EST\253\240\131\169\015\254\192\199\001\003EDT\253\224f\153\016\254\176\185\000\003EST\253\240e\137\017\254\192\199\001\003EDT\253\224Hy\018\254\176\185\000\003EST\253\240Gi\019\254\192\199\001\003EDT\253\224*Y\020\254\176\185\000\003EST\253\240)I\021\254\192\199\001\003EDT\253\224\0129\022\254\176\185\000\003EST\253\240\011)\023\254\192\199\001\003EDT\253`)\"\024\254\176\185\000\003EST\253\240\237\b\025\254\192\199\001\003EDT\253`\011\002\026\254\176\185\000\003EST\253p\n\242\026\254\192\199\001\003EDT\253`\237\225\027\254\176\185\000\003EST\253p\236\209\028\254\192\199\001\003EDT\253`\207\193\029\254\176\185\000\003EST\253p\206\177\030\254\192\199\001\003EDT\253`\177\161\031\254\176\185\000\003EST\253\240\000v \254\192\199\001\003EDT\253`\147\129!\254\176\185\000\003EST\253\240\226U\"\254\192\199\001\003EDT\253\224\175j#\254\176\185\000\003EST\253\240\1965$\254\192\199\001\003EDT\253\224\145J%\254\176\185\000\003EST\253\240\166\021&\254\192\199\001\003EDT\253\224s*'\254\176\185\000\003EST\253p\195\254'\254\192\199\001\003EDT\253\224U\n)\254\176\185\000\003EST\253p\165\222)\254\192\199\001\003EDT\253\2247\234*\254\176\185\000\003EST\253p\135\190+\254\192\199\001\003EDT\253`T\211,\254\176\185\000\003EST\253pi\158-\254\192\199\001\003EDT\253`6\179.\254\176\185\000\003EST\253pK~/\254\192\199\001\003EDT\253`\024\1470\254\176\185\000\003EST\253\240gg1\254\192\199\001\003EDT\253`\250r2\254\176\185\000\003EST\253\240IG3\254\192\199\001\003EDT\253`\220R4\254\176\185\000\003EST\253\240+'5\254\192\199\001\003EDT\253`\19026\254\176\185\000\003EST\253\240\r\0077\254\192\199\001\003EDT\253\224\218\0278\254\176\185\000\003EST\253\240\239\2308\254\192\199\001\003EDT\253\224\188\2519\254\176\185\000\003EST\253\240\209\198:\254\192\199\001\003EDT\253\224\158\219;\254\176\185\000\003EST\253p\238\175<\254\192\199\001\003EDT\253\224\128\187=\254\176\185\000\003EST\253p\208\143>\254\192\199\001\003EDT\253\224b\155?\254\176\185\000\003EST\253p\178o@\254\192\199\001\003EDT\253`\127\132A\254\176\185\000\003EST\253p\148OB\254\192\199\001\003EDT\253`adC\254\176\185\000\003EST\253pv/D\254\192\199\001\003EDT\253`CDE\254\176\185\000\003EST\253\240\168\243E\254\192\199\001\003EDT\253\224_-G\254\176\185\000\003EST\253\240\138\211G\254\192\199\001\003EDT\253\224A\rI\254\176\185\000\003EST\253\240l\179I\254\192\199\001\003EDT\253\224#\237J\254\176\185\000\003EST\253p\137\156K\254\192\199\001\003EDT\253`@\214L\254\176\185\000\003EST\253pk|M\254\192\199\001\003EDT\253`\"\182N\254\176\185\000\003EST\253pM\\O\254\192\199\001\003EDT\253`\004\150P\254\176\185\000\003EST\253p/<Q\254\192\199\001\003EDT\253`\230uR\254\176\185\000\003EST\253p\017\028S\254\192\199\001\003EDT\253`\200UT\254\176\185\000\003EST\253p\243\251T\254\192\199\001\003EDT\253`\1705V\254\176\185\000\003EST\253\240\015\229V\254\192\199\001\003EDT\253\224\198\030X\254\176\185\000\003EST\253\240\241\196X\254\192\199\001\003EDT\253\224\168\254Y\254\176\185\000\003EST\253\240\211\164Z\254\192\199\001\003EDT\253\224\138\222[\254\176\185\000\003EST\253\240\181\132\\\254\192\199\001\003EDT\253\224l\190]\254\176\185\000\003EST\253\240\151d^\254\192\199\001\003EDT\253\224N\158_\254\176\185\000\003EST\253p\180M`\254\192\199\001\003EDT\253`k\135a\254\176\185\000\003EST\253p\150-b\254\192\199\001\003EDT\253`Mgc\254\176\185\000\003EST\253px\rd\254\192\199\001\003EDT\253`/Ge\254\176\185\000\003EST\253pZ\237e\254\192\199\001\003EDT\253`\017'g\254\176\185\000\003EST\253p<\205g\254\192\199\001\003EDT\253`\243\006i\254\176\185\000\003EST\253p\030\173i\254\192\199\001\003EDT\253`\213\230j\254\176\185\000\003EST\253\240:\150k\254\192\199\001\003EDT\253\224\241\207l\254\176\185\000\003EST\253\240\028vm\254\192\199\001\003EDT\253\224\211\175n\254\176\185\000\003EST\253\240\254Uo\254\192\199\001\003EDT\253\224\181\143p\254\176\185\000\003EST\253\240\2245q\254\192\199\001\003EDT\253\224\151or\254\176\185\000\003EST\253\240\194\021s\254\192\199\001\003EDT\253\224yOt\254\176\185\000\003EST\253p\223\254t\254\192\199\001\003EDT\253`\1508v\254\176\185\000\003EST\253p\193\222v\254\192\199\001\003EDT\253`x\024x\254\176\185\000\003EST\253p\163\190x\254\192\199\001\003EDT\253`Z\248y\254\176\185\000\003EST\253p\133\158z\254\192\199\001\003EDT\253`<\216{\254\176\185\000\003EST\253pg~|\254\192\199\001\003EDT\253`\030\184}\254\176\185\000\003EST\253pI^~\254\192\199\001\003EDT\253`\000\152\127\254\176\185\000\003EST\000\254\158\186\000\003LMT\000"))
-    |}]
-;;
Index: core-0.17.1/core/test/type_immediacy_conv_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/type_immediacy_conv_unit_tests.ml
+++ core-0.17.1/core/test/type_immediacy_conv_unit_tests.ml
@@ -364,15 +364,14 @@ let%test_module _ =
       in
       let conv = get_conv M.typerep_of_t in
       Expect_test_helpers_core.require
-        [%here]
         ~cr:CR_someday
         (test_convertibles conv [ { M.foo = () }, 0 ])
         ~if_false_then_print_s:(lazy [%message "zero should convert"]);
       Expect_test_helpers_core.require
-        [%here]
         (test_inconvertible_ints conv no_int_but_zero_converts)
         ~if_false_then_print_s:(lazy [%message "non-zero should not convert"]);
-      [%expect {|
+      [%expect
+        {|
         "zero should convert"
         |}]
     ;;
@@ -436,15 +435,14 @@ let%test_module _ =
       in
       let conv = get_conv M.typerep_of_t in
       Expect_test_helpers_core.require
-        [%here]
         ~cr:CR_someday
         (test_convertibles conv [ M.Foo (), 0 ])
         ~if_false_then_print_s:(lazy [%message "zero should convert"]);
       Expect_test_helpers_core.require
-        [%here]
         (test_inconvertible_ints conv no_int_but_zero_converts)
         ~if_false_then_print_s:(lazy [%message "non-zero should not convert"]);
-      [%expect {|
+      [%expect
+        {|
         "zero should convert"
         |}]
     ;;
Index: core-0.17.1/core/test/type_immediacy_witness_unit_tests.ml
===================================================================
--- core-0.17.1.orig/core/test/type_immediacy_witness_unit_tests.ml
+++ core-0.17.1/core/test/type_immediacy_witness_unit_tests.ml
@@ -76,7 +76,6 @@ let%test_module _ =
       | _, _, _ ->
         Expect_test_helpers_base.print_cr
           ?cr
-          [%here]
           [%message
             "The immediacy of the values did not match the Type_immediacy"
               (type_immediacy : dest)
@@ -222,7 +221,6 @@ let%test_module _ =
           (lazy
             [%message
               "Unboxed container types should have the immediacy of their contained type"])
-        [%here]
     ;;
 
     let require_boxed ?cr =
@@ -230,7 +228,6 @@ let%test_module _ =
         ?cr
         ~if_false_then_print_s:
           (lazy [%message "Boxed container types should never be immediate"])
-        [%here]
     ;;
 
     let require_maybe_boxed ?cr =
@@ -242,7 +239,6 @@ let%test_module _ =
               "Unboxing may be the default depending on compiler settings. Type \
                immediacy for unboxable types that are not explicitly unboxed or boxed \
                should be unknown."])
-        [%here]
     ;;
 
     let%expect_test _ =
@@ -262,7 +258,8 @@ let%test_module _ =
       require_self_consistent M.typerep_of_t [ { M.foo = () } ];
       check_n M.typerep_of_t [ { M.foo = () } ] |> require_boxed ~cr:CR_someday;
       check_u M.typerep_of_t [ { M.foo = () } ] |> require_maybe_boxed;
-      [%expect {|
+      [%expect
+        {|
         "Boxed container types should never be immediate"
         |}]
     ;;
@@ -386,7 +383,8 @@ let%test_module _ =
       require_self_consistent M.typerep_of_t [ M.Foo () ];
       check_n M.typerep_of_t [ M.Foo () ] |> require_boxed ~cr:CR_someday;
       check_u M.typerep_of_t [ M.Foo () ] |> require_maybe_boxed;
-      [%expect {|
+      [%expect
+        {|
         "Boxed container types should never be immediate"
         |}]
     ;;
@@ -544,7 +542,7 @@ let%test_module _ =
         type 'a t = 'a lazy_t [@@deriving typerep]
       end
       in
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         let module _ = Type_immediacy.Sometimes.For_all_parameters_S1 (M) in
         ());
       [%expect
@@ -552,7 +550,7 @@ let%test_module _ =
         (Failure
          "type type_immediacy_witness_unit_tests.ml.t is not independent of its arguments")
         |}];
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         let module _ = Type_immediacy.Never.For_all_parameters_S1 (M) in
         ());
       [%expect
@@ -560,7 +558,7 @@ let%test_module _ =
         (Failure
          "type type_immediacy_witness_unit_tests.ml.t is not independent of its arguments")
         |}];
-      require_does_raise [%here] (fun () ->
+      require_does_raise (fun () ->
         let module _ = Type_immediacy.Always.For_all_parameters_S1 (M) in
         ());
       [%expect
Index: core-0.17.1/filename_base/src/filename_base.ml
===================================================================
--- core-0.17.1.orig/filename_base/src/filename_base.ml
+++ core-0.17.1/filename_base/src/filename_base.ml
@@ -2,16 +2,16 @@ open! Base
 
 include (
   String :
-    sig
-      type t = string [@@deriving compare, hash, sexp, sexp_grammar]
+  sig
+    type t = string [@@deriving compare, hash, sexp, sexp_grammar]
 
-      include
-        Comparable.S
-          with type t := t
-          with type comparator_witness = String.comparator_witness
+    include
+      Comparable.S
+      with type t := t
+      with type comparator_witness = String.comparator_witness
 
-      val comparator : (t, comparator_witness) Comparator.t
-    end)
+    val comparator : (t, comparator_witness) Comparator.t
+  end)
 
 include struct
   open Stdlib.Filename
Index: core-0.17.1/filename_base/src/filename_base.mli
===================================================================
--- core-0.17.1.orig/filename_base/src/filename_base.mli
+++ core-0.17.1/filename_base/src/filename_base.mli
@@ -157,16 +157,16 @@ val quote : string -> string
 val arg_type : [ `Use_Filename_unix ] [@@deprecated "[since 2021-04] Use [Filename_unix]"]
 
 val create_arg_type : [ `Use_Filename_unix ]
-  [@@deprecated "[since 2021-04] Use [Filename_unix]"]
+[@@deprecated "[since 2021-04] Use [Filename_unix]"]
 
 val open_temp_file : [ `Use_Filename_unix ]
-  [@@deprecated "[since 2021-04] Use [Filename_unix]"]
+[@@deprecated "[since 2021-04] Use [Filename_unix]"]
 
 val open_temp_file_fd : [ `Use_Filename_unix ]
-  [@@deprecated "[since 2021-04] Use [Filename_unix]"]
+[@@deprecated "[since 2021-04] Use [Filename_unix]"]
 
 val realpath : [ `Use_Filename_unix ] [@@deprecated "[since 2021-04] Use [Filename_unix]"]
 val temp_dir : [ `Use_Filename_unix ] [@@deprecated "[since 2021-04] Use [Filename_unix]"]
 
 val temp_file : [ `Use_Filename_unix ]
-  [@@deprecated "[since 2021-04] Use [Filename_unix]"]
+[@@deprecated "[since 2021-04] Use [Filename_unix]"]
Index: core-0.17.1/filename_base/test/test_filename.ml
===================================================================
--- core-0.17.1.orig/filename_base/test/test_filename.ml
+++ core-0.17.1/filename_base/test/test_filename.ml
@@ -12,8 +12,7 @@ let%expect_test "concat" =
     ; "a/.", "./", "a/"
     ; "a///././/./.", ".///././/././/b", "a/b"
     ]
-    ~f:(fun (p1, p2, expected) ->
-      require_equal [%here] (module String) (p1 ^/ p2) expected);
+    ~f:(fun (p1, p2, expected) -> require_equal (module String) (p1 ^/ p2) expected);
   [%expect {| |}]
 ;;
 
@@ -72,7 +71,7 @@ let%expect_test "V1" =
     ; "././."
     ]
   in
-  print_and_check_stable_type [%here] (module Stable.V1) examples;
+  print_and_check_stable_type (module Stable.V1) examples;
   [%expect
     {|
     (bin_shape_digest d9a8da25d5656b016fb4dbdc2e4197fb)
@@ -133,13 +132,13 @@ let%expect_test "of_absolute_exn" =
   assert (relative_to "/a/d/e" = "../../b/c");
   [%expect {| |}];
   (* raises if either argument is a relative path *)
-  require_does_raise [%here] (fun () -> of_absolute_exn "/a/b/c" ~relative_to:"./d/e/f");
+  require_does_raise (fun () -> of_absolute_exn "/a/b/c" ~relative_to:"./d/e/f");
   [%expect
     {|
     ("Filename.of_absolute_exn: [~relative_to] must be an absolute path"
      (relative_to ./d/e/f))
     |}];
-  require_does_raise [%here] (fun () -> of_absolute_exn "./a/b/c" ~relative_to:"/d/e/f");
+  require_does_raise (fun () -> of_absolute_exn "./a/b/c" ~relative_to:"/d/e/f");
   [%expect
     {|
     ("Filename.of_absolute_exn: first argument must be an absolute path"
Index: core-0.17.1/heap_block/heap_block.ml
===================================================================
--- core-0.17.1.orig/heap_block/heap_block.ml
+++ core-0.17.1/heap_block/heap_block.ml
@@ -3,7 +3,7 @@ open! Base
 type 'a t = 'a [@@deriving sexp_of]
 
 external is_heap_block : Stdlib.Obj.t -> bool = "core_heap_block_is_heap_block"
-  [@@noalloc]
+[@@noalloc]
 
 let is_ok v = is_heap_block (Stdlib.Obj.repr v)
 let create v = if is_ok v then Some v else None
Index: core-0.17.1/heap_block/runtime.wat
===================================================================
--- /dev/null
+++ core-0.17.1/heap_block/runtime.wat
@@ -0,0 +1,26 @@
+;; imported from https://github.com/ocaml-wasm/wasm_of_ocaml/issues/5
+(module
+   (import "env" "lazy_tag" (global $lazy_tag i32))
+   (import "env" "forward_tag" (global $forward_tag i32))
+
+   (type $block (array (mut (ref eq))))
+
+   (func (export "core_heap_block_is_heap_block")
+      (param (ref eq)) (result (ref eq))
+      (local $tag i32)
+      (drop (block $not_block (result (ref eq))
+         (local.set $tag
+            (i31.get_u
+               (ref.cast (ref i31)
+               (array.get $block
+                  (br_on_cast_fail $not_block (ref eq) (ref $block)
+                     (local.get 0))
+                  (i32.const 0)))))
+         (return
+            (ref.i31
+               (i32.eqz
+                  (i32.or
+                     (i32.eq (local.get $tag) (global.get $lazy_tag))
+                     (i32.eq (local.get $tag) (global.get $forward_tag))))))))
+      (ref.i31 (i32.const 0)))
+)
Index: core-0.17.1/univ_map/src/univ_map.ml
===================================================================
--- core-0.17.1.orig/univ_map/src/univ_map.ml
+++ core-0.17.1/univ_map/src/univ_map.ml
@@ -3,9 +3,10 @@ include Univ_map_intf
 module Uid = Type_equal.Id.Uid
 
 module Make1
-  (Key : Key) (Data : sig
-    type ('s, 'a) t [@@deriving sexp_of]
-  end) =
+    (Key : Key)
+    (Data : sig
+       type ('s, 'a) t [@@deriving sexp_of]
+     end) =
 struct
   (* A wrapper for the [Key] module that adds a dynamic check to [Key.type_id].
 
@@ -26,7 +27,7 @@ struct
             (if Ppx_inline_test_lib.am_running
              then Sexp.Atom "<uid>"
              else Type_equal.Id.Uid.sexp_of_t (Type_equal.Id.uid type_id)
-              : Sexp.t)
+             : Sexp.t)
         }]
     ;;
 
@@ -149,9 +150,10 @@ struct
 end
 
 module Make
-  (Key : Key) (Data : sig
-    type 'a t [@@deriving sexp_of]
-  end) =
+    (Key : Key)
+    (Data : sig
+       type 'a t [@@deriving sexp_of]
+     end) =
 struct
   module M =
     Make1
@@ -230,10 +232,10 @@ struct
 end
 
 module Merge1
-  (Key : Key)
-  (Input1_data : Data1)
-  (Input2_data : Data1)
-  (Output_data : Data1) =
+    (Key : Key)
+    (Input1_data : Data1)
+    (Input2_data : Data1)
+    (Output_data : Data1) =
 struct
   type ('s1, 's2, 's3) f =
     { f :
Index: core-0.17.1/univ_map/src/univ_map_intf.ml
===================================================================
--- core-0.17.1.orig/univ_map/src/univ_map_intf.ml
+++ core-0.17.1/univ_map/src/univ_map_intf.ml
@@ -130,7 +130,11 @@ module type Univ_map = sig
   module Make1 (Key : Key) (Data : Data1) :
     S1 with type ('s, 'a) data = ('s, 'a) Data.t and module Key = Key
 
-  module Merge (Key : Key) (Input1_data : Data) (Input2_data : Data) (Output_data : Data) : sig
+  module Merge
+      (Key : Key)
+      (Input1_data : Data)
+      (Input2_data : Data)
+      (Output_data : Data) : sig
     type f =
       { f :
           'a.
@@ -151,10 +155,10 @@ module type Univ_map = sig
   end
 
   module Merge1
-    (Key : Key)
-    (Input1_data : Data1)
-    (Input2_data : Data1)
-    (Output_data : Data1) : sig
+      (Key : Key)
+      (Input1_data : Data1)
+      (Input2_data : Data1)
+      (Output_data : Data1) : sig
     type ('s1, 's2, 's3) f =
       { f :
           'a.
Index: core-0.17.1/univ_map/test/dune
===================================================================
--- core-0.17.1.orig/univ_map/test/dune
+++ core-0.17.1/univ_map/test/dune
@@ -1,5 +1,5 @@
 (library
  (name univ_map_test)
- (libraries base stdio univ_map)
+ (libraries base parsexp stdio univ_map)
  (preprocess
   (pps ppx_jane)))
Index: core-0.17.1/univ_map/test/test_univ_map.ml
===================================================================
--- core-0.17.1.orig/univ_map/test/test_univ_map.ml
+++ core-0.17.1/univ_map/test/test_univ_map.ml
@@ -19,7 +19,7 @@ let%test_module _ =
         (change t key ~f:(function
            | None -> assert false
            | o -> o)
-          : t);
+         : t);
       match find t key with
       | None -> assert false
       | Some v' -> assert (phys_equal data v')
@@ -103,15 +103,14 @@ let%test_module _ =
           ints
           |> List.rev
           |> List.map ~f:(fun int ->
-               Packed.T
-                 ( Type_equal.Id.create ~name:("key" ^ Int.to_string int) [%sexp_of: int]
-                 , int ))
+            Packed.T
+              (Type_equal.Id.create ~name:("key" ^ Int.to_string int) [%sexp_of: int], int))
           |> of_alist_exn
           |> to_alist
           |> List.map ~f:(fun (Packed.T (type_id, a)) ->
-               let type_id_name = Type_equal.Id.name type_id in
-               let sexp_of_a = Type_equal.Id.to_sexp type_id in
-               [%sexp (type_id_name : string), (a : a)])
+            let type_id_name = Type_equal.Id.name type_id in
+            let sexp_of_a = Type_equal.Id.to_sexp type_id in
+            [%sexp (type_id_name : string), (a : a)])
         in
         Stdio.print_s [%sexp (sexps : Sexp.t list)]
       in
@@ -153,7 +152,7 @@ let%expect_test "specified key module" =
     [%sexp
       (Or_error.try_with (fun () ->
          U_incorrect.find (U_incorrect.of_alist_exn [ T (Foo, 3); T (Bar, "three") ]) Foo)
-        : int option Or_error.t)];
+       : int option Or_error.t)];
   [%expect
     {|
     (Error
@@ -188,7 +187,7 @@ let%expect_test "specified key module" =
   Stdio.print_s
     [%sexp
       (U_correct.find (U_correct.of_alist_exn [ T (Foo, 3); T (Bar, "three") ]) Foo
-        : int option)];
+       : int option)];
   [%expect {| (3) |}]
 ;;
 
Index: core-0.17.1/validate/src/validate.ml
===================================================================
--- core-0.17.1.orig/validate/src/validate.ml
+++ core-0.17.1/validate/src/validate.ml
@@ -59,7 +59,7 @@ let result_fail t =
     "validation errors"
     (List.map t ~f:(fun { path; error } -> path_string path, error))
     [%sexp_of: (string * Error.t) List.t]
-  [@@cold]
+[@@cold]
 ;;
 
 (** [result] is carefully implemented so that it can be inlined -- calling [result_fail],
Index: core-0.17.1/validate/src/validate.mli
===================================================================
--- core-0.17.1.orig/validate/src/validate.mli
+++ core-0.17.1/validate/src/validate.mli
@@ -140,7 +140,7 @@ val field_folder
 val field_direct_folder
   :  'a check
   -> (t list -> ([> `Read ], 'record, 'a) Field.t_with_perm -> 'record -> 'a -> t list)
-     Staged.t
+       Staged.t
 
 (** Combines a list of validation functions into one that does all validations. *)
 val all : 'a check list -> 'a check
Index: core-0.17.1/validate/test/test_validate.ml
===================================================================
--- core-0.17.1.orig/validate/test/test_validate.ml
+++ core-0.17.1/validate/test/test_validate.ml
@@ -52,7 +52,8 @@ let%expect_test "Validate.all" =
        ; (fun _ -> fail "c")
        ]
        ());
-  [%expect {|
+  [%expect
+    {|
     ("" a)
     ("" b)
     ("" c)
@@ -73,7 +74,8 @@ let two_errors = of_list [ fail "foo"; f
 
 let%expect_test _ =
   print (first_failure two_errors (fail "snoo"));
-  [%expect {|
+  [%expect
+    {|
     ("" foo)
     ("" bar)
     |}]
@@ -113,15 +115,15 @@ let%expect_test "typical use of Validate
     Fields.Direct.fold t ~init:[] ~x:validate_x |> Validate.of_list |> Validate.result
   in
   let t = { x = true } in
-  require_no_allocation [%here] (fun () -> ignore (validate t : unit Or_error.t))
+  require_no_allocation (fun () -> ignore (validate t : unit Or_error.t))
 ;;
 
 let%expect_test "Validate.all doesn't allocate on success" =
   let checks = List.init 5 ~f:(Fn.const Validate.pass_bool) in
-  require_no_allocation [%here] (fun () -> ignore (Validate.all checks true : Validate.t))
+  require_no_allocation (fun () -> ignore (Validate.all checks true : Validate.t))
 ;;
 
 let%expect_test "Validate.combine doesn't allocate on success" =
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     ignore (Validate.combine Validate.pass Validate.pass : Validate.t))
 ;;
Index: core-0.17.1/core/test/test_modes.mli
===================================================================
--- /dev/null
+++ core-0.17.1/core/test/test_modes.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
Index: core-0.17.1/core/test/test_zone.mli
===================================================================
--- core-0.17.1.orig/core/test/test_zone.mli
+++ /dev/null
@@ -1 +0,0 @@
-(*_ This signature is deliberately empty. *)
