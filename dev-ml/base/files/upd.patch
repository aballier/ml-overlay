From 5154f5d8e98bac7b23acbd143f72529f9658f3bb Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Tue, 13 Aug 2024 20:53:43 +0100
Subject: [PATCH] v0.17~preview.129.36+325

---
 generate/dune                                 |    2 +-
 generate/generate_pow_overflow_bounds.ml      |   28 +-
 generate/zarith.ml                            |    4 +
 hash_types/src/base_internalhash_types.ml     |   42 +-
 hash_types/src/runtime.wat                    |   78 +
 hash_types/test/test_immediate.ml             |    3 +-
 lint/ppx_base_lint.ml                         |   18 +-
 ppx/README.md                                 |    6 +
 ppx/src/dune                                  |    6 +
 ppx/src/ppx_base_internal.ml                  |   79 +
 ppx/src/ppx_base_internal.mli                 |    6 +
 ppx/test/dune                                 |    0
 ppx/test/test.mlt                             |   29 +
 src/applicative.ml                            |  113 +-
 src/applicative_intf.ml                       |  119 +-
 src/array.ml                                  |   69 +-
 src/array.mli                                 |   13 +-
 src/array0.ml                                 |   34 +-
 src/avltree.ml                                |    4 +-
 src/base.ml                                   |   40 +-
 src/binary_search.ml                          |   18 +-
 src/binary_searchable.ml                      |   18 +-
 src/binary_searchable_intf.ml                 |    2 +-
 src/blit.ml                                   |   47 +-
 src/blit_intf.ml                              |   70 +-
 src/bool.ml                                   |    8 +-
 src/bool.mli                                  |    2 +-
 src/bool0.ml                                  |    2 +-
 src/bool0.mli                                 |    2 +-
 src/buffer.ml                                 |   48 +-
 src/buffer_intf.ml                            |    9 +
 src/bytes.ml                                  |   20 +-
 src/bytes0.ml                                 |  178 +-
 src/char.ml                                   |    6 +-
 src/char.mli                                  |    2 +-
 src/comparable.ml                             |  100 +-
 src/comparable_intf.ml                        |   82 +-
 src/comparator.ml                             |   80 +-
 src/comparator.mli                            |   72 +-
 src/comparisons.ml                            |   34 +-
 src/container.ml                              |   50 +-
 src/container_intf.ml                         |   22 +-
 src/dictionary_immutable_intf.ml              |  585 +++--
 src/dictionary_mutable_intf.ml                |  300 +--
 src/dune                                      |    7 +-
 src/either.ml                                 |  134 +-
 src/either0.ml                                |   36 +-
 src/error.ml                                  |   23 +-
 src/exn.ml                                    |   16 +-
 src/float.ml                                  |  630 +++--
 src/float.mli                                 |  240 +-
 src/float0.ml                                 |  150 +-
 src/float_stubs.c                             |   24 +
 src/floatable.ml                              |    7 +
 src/globalize.ml                              |    4 +-
 src/hash.ml                                   |   33 +-
 src/hash_intf.ml                              |   18 +-
 src/hash_set.ml                               |   20 +-
 src/hash_set_intf.ml                          |   22 +-
 src/hash_stubs.c                              |   12 +-
 src/hashtbl.ml                                |   33 +-
 src/hashtbl_intf.ml                           |  324 +--
 src/import.ml                                 |    1 +
 src/import0.ml                                |  282 +-
 src/indexed_container.ml                      |   60 +-
 src/indexed_container_intf.ml                 |   32 +-
 src/info.ml                                   |   10 +-
 src/info_intf.ml                              |   44 +-
 src/int.ml                                    |  134 +-
 src/int32.ml                                  |  141 +-
 src/int63.ml                                  |   47 +-
 src/int63_emul.ml                             |  128 +-
 src/int63_emul.mli                            |   12 +-
 src/int64.ml                                  |  149 +-
 src/int64.mli                                 |    8 +-
 src/int_conversions.ml                        |   16 +-
 src/int_intf.ml                               |   22 +-
 src/int_math.ml                               |    2 +-
 src/int_math_stubs.c                          |  122 +-
 src/int_string_conversions.ml                 |   74 +-
 src/int_string_conversions.mli                |   62 +-
 src/lazy.ml                                   |   12 +-
 src/linked_queue.ml                           |   16 +-
 src/list.ml                                   |   72 +-
 src/map.ml                                    |  238 +-
 src/map_intf.ml                               |  742 ++----
 src/maybe_bound.ml                            |   24 +-
 src/modes.ml                                  |  136 +
 src/modes.mli                                 |    1 +
 src/modes_intf.ml                             |  248 ++
 src/monad.ml                                  |  112 +-
 src/monad_intf.ml                             |   74 +-
 src/nativeint.ml                              |  146 +-
 src/nothing.ml                                |    6 +-
 src/obj_array.ml                              |   30 +-
 src/obj_local.ml                              |   10 +-
 src/option.ml                                 |  152 +-
 src/option.mli                                |   46 +
 src/option_array.ml                           |   26 +-
 src/or_error.ml                               |   22 +-
 src/ordered_collection_common0.ml             |    6 +-
 src/ordered_collection_common0.mli            |    2 +-
 src/ordering.ml                               |   12 +-
 src/popcount.ml                               |   48 +-
 src/ppx_hash_lib.ml                           |   65 +-
 src/pretty_printer.ml                         |   20 +-
 src/pretty_printer.mli                        |   14 +-
 src/queue.ml                                  |   42 +-
 src/queue_intf.ml                             |    2 +-
 src/random.ml                                 |    2 +-
 src/random.mli                                |    5 +-
 src/ref.ml                                    |   60 +-
 src/replace_polymorphic_compare.ml            |  243 ++
 src/replace_polymorphic_compare.mli           |    1 +
 src/replace_polymorphic_compare_intf.ml       |   39 +
 src/result.ml                                 |   94 +-
 src/runtime.js                                |  114 +-
 src/runtime.wat                               |  195 ++
 src/sequence.ml                               |  143 +-
 src/set.ml                                    |   84 +-
 src/set_intf.ml                               |  266 +-
 src/sexp.ml                                   |    6 +-
 src/sexp.mli                                  |    2 +-
 src/sexpable.ml                               |   59 +-
 src/sexpable.mli                              |   59 +-
 src/sign0.ml                                  |   12 +-
 src/sign_or_nan.ml                            |   11 +-
 src/source_code_position.ml                   |   25 +-
 src/source_code_position.mli                  |   10 +
 src/source_code_position0.ml                  |   12 +-
 src/stack.ml                                  |   14 +-
 src/staged.ml                                 |    6 +-
 src/staged.mli                                |    4 +-
 src/string.ml                                 |  266 +-
 src/string_intf.ml                            |  109 +-
 src/stringable.ml                             |    7 +
 src/sys.mli                                   |    6 +-
 src/sys0.ml                                   |    4 +-
 src/t.ml                                      |    6 +-
 src/type_equal.ml                             |   94 +-
 src/type_equal_intf.ml                        |   52 +-
 src/uchar.ml                                  |   90 +-
 src/uchar_intf.ml                             |    6 +-
 src/uniform_array.ml                          |   44 +-
 src/uniform_array.mli                         |    1 -
 src/variant.mli                               |    2 +-
 src/word_size.ml                              |    2 +-
 test/allocation/bin/dune                      |    2 +-
 .../bin/test_option_array_allocation.ml       |    4 +-
 test/allocation/dune                          |    3 +-
 test/allocation/test_array_allocation.ml      |   12 +-
 test/allocation/test_char_allocation.ml       |    2 +-
 test/allocation/test_float_allocation.ml      |    2 +-
 test/allocation/test_hashtbl_allocation.ml    |   13 +-
 test/allocation/test_list_allocation.ml       |    8 +-
 test/allocation/test_modes_allocation.ml      |  103 +
 test/allocation/test_modes_allocation.mli     |    1 +
 test/allocation/test_option_allocation.ml     |  143 ++
 test/allocation/test_option_allocation.mli    |    1 +
 test/allocation/test_string_allocation.ml     |   39 +-
 test/allocation/test_type_equal_allocation.ml |    3 +-
 test/avltree_unit_tests.ml                    |  816 +++---
 test/coverage/helpers/adjustable.ml           |   21 +
 test/coverage/helpers/adjustable.mli          |    1 +
 test/coverage/helpers/adjustable_intf.ml      |   19 +
 .../helpers/base_test_coverage_helpers.ml     |    6 +
 test/coverage/helpers/data.ml                 |   37 +
 test/coverage/helpers/data.mli                |    1 +
 test/coverage/helpers/data_intf.ml            |   39 +
 test/coverage/helpers/dune                    |    5 +
 test/coverage/helpers/func.ml                 |  124 +
 test/coverage/helpers/func.mli                |    1 +
 test/coverage/helpers/func_intf.ml            |   59 +
 test/coverage/helpers/memo.ml                 |   32 +
 test/coverage/helpers/memo.mli                |    1 +
 test/coverage/helpers/memo_intf.ml            |   30 +
 test/coverage/helpers/overrides.ml            |   37 +
 test/coverage/helpers/overrides.mli           |   32 +
 test/coverage/helpers/stats.ml                |   45 +
 test/coverage/helpers/stats.mli               |   14 +
 .../map/base_test_coverage_map.ml}            |    0
 test/coverage/map/constructor.ml              | 1959 ++++++++++++++
 test/coverage/map/constructor.mli             |    1 +
 test/coverage/map/constructor_intf.ml         |   21 +
 test/coverage/map/dune                        |    6 +
 .../map}/functor.ml                           | 1890 +++++++-------
 .../map}/functor.mli                          |    0
 test/coverage/map/functor_intf.ml             |  137 +
 test/coverage/map/instances.ml                |   64 +
 test/coverage/map/instances.mli               |    1 +
 test/coverage/map/instances_intf.ml           |   52 +
 .../map}/test_all.ml                          |  131 +-
 .../map}/test_all.mli                         |    0
 test/coverage/map/test_poly_accessors.ml      |    9 +
 test/coverage/map/test_poly_accessors.mli     |    1 +
 test/coverage/map/test_poly_creators.ml       |    9 +
 test/coverage/map/test_poly_creators.mli      |    1 +
 test/coverage/map/test_poly_transformers.ml   |    9 +
 test/coverage/map/test_poly_transformers.mli  |    1 +
 test/coverage/map/test_toplevel_accessors.ml  |    9 +
 test/coverage/map/test_toplevel_accessors.mli |    1 +
 test/coverage/map/test_toplevel_creators.ml   |    9 +
 test/coverage/map/test_toplevel_creators.mli  |    1 +
 .../map/test_toplevel_transformers.ml         |   10 +
 .../map/test_toplevel_transformers.mli        |    1 +
 test/coverage/map/test_tree_accessors.ml      |    9 +
 test/coverage/map/test_tree_accessors.mli     |    1 +
 test/coverage/map/test_tree_creators.ml       |    9 +
 test/coverage/map/test_tree_creators.mli      |    1 +
 test/coverage/map/test_tree_transformers.ml   |    9 +
 test/coverage/map/test_tree_transformers.mli  |    1 +
 .../map/test_using_comparator_accessors.ml    |   10 +
 .../map/test_using_comparator_accessors.mli   |    1 +
 .../map/test_using_comparator_creators.ml     |   10 +
 .../map/test_using_comparator_creators.mli    |    1 +
 .../map/test_using_comparator_transformers.ml |   11 +
 .../test_using_comparator_transformers.mli    |    1 +
 test/coverage/set/base_test_coverage_set.ml   |    1 +
 test/coverage/set/constructor.ml              |  990 +++++++
 test/coverage/set/constructor.mli             |    1 +
 test/coverage/set/constructor_intf.ml         |   17 +
 .../{map_full_interface => coverage/set}/dune |    4 +-
 test/coverage/set/functor.ml                  |  946 +++++++
 test/coverage/set/functor.mli                 |    1 +
 test/coverage/set/functor_intf.ml             |  135 +
 test/coverage/set/instances.ml                |   64 +
 test/coverage/set/instances.mli               |    1 +
 test/coverage/set/instances_intf.ml           |   59 +
 test/coverage/set/test_all.ml                 |  305 +++
 test/coverage/set/test_all.mli                |    5 +
 test/coverage/set/test_poly_accessors.ml      |    9 +
 test/coverage/set/test_poly_accessors.mli     |    1 +
 test/coverage/set/test_poly_creators.ml       |    9 +
 test/coverage/set/test_poly_creators.mli      |    1 +
 test/coverage/set/test_poly_transformers.ml   |    9 +
 test/coverage/set/test_poly_transformers.mli  |    1 +
 test/coverage/set/test_toplevel_accessors.ml  |    9 +
 test/coverage/set/test_toplevel_accessors.mli |    1 +
 test/coverage/set/test_toplevel_creators.ml   |    9 +
 test/coverage/set/test_toplevel_creators.mli  |    1 +
 .../set/test_toplevel_transformers.ml         |   10 +
 .../set/test_toplevel_transformers.mli        |    1 +
 test/coverage/set/test_tree_accessors.ml      |    9 +
 test/coverage/set/test_tree_accessors.mli     |    1 +
 test/coverage/set/test_tree_creators.ml       |    9 +
 test/coverage/set/test_tree_creators.mli      |    1 +
 test/coverage/set/test_tree_transformers.ml   |    9 +
 test/coverage/set/test_tree_transformers.mli  |    1 +
 .../set/test_using_comparator_accessors.ml    |   10 +
 .../set/test_using_comparator_accessors.mli   |    1 +
 .../set/test_using_comparator_creators.ml     |   10 +
 .../set/test_using_comparator_creators.mli    |    1 +
 .../set/test_using_comparator_transformers.ml |   11 +
 .../test_using_comparator_transformers.mli    |    1 +
 test/dune                                     |    4 +-
 test/hashtbl_tests.ml                         |    8 +-
 test/helpers/test_container.ml                |   74 +-
 test/helpers/test_container.mli               |   70 +-
 test/import.ml                                |    2 +-
 test/map_full_interface/functor_intf.ml       |  130 -
 test/map_full_interface/test_poly.ml          |   15 -
 test/map_full_interface/test_poly.mli         |    1 -
 test/map_full_interface/test_poly_intf.ml     |   22 -
 test/map_full_interface/test_toplevel.ml      |   15 -
 test/map_full_interface/test_toplevel.mli     |    1 -
 test/map_full_interface/test_toplevel_intf.ml |   22 -
 test/map_full_interface/test_tree.ml          |   15 -
 test/map_full_interface/test_tree.mli         |    1 -
 test/map_full_interface/test_tree_intf.ml     |   22 -
 .../test_using_comparator.ml                  |   15 -
 .../test_using_comparator.mli                 |    1 -
 .../test_using_comparator_intf.ml             |   22 -
 test/test_applicative.ml                      |   40 +-
 test/test_array.ml                            |   48 +-
 test/test_array_local.mlt                     |    4 +-
 test/test_base_containers_mono.ml             |    2 +-
 test/test_blit.ml                             |   20 +-
 test/test_bytes.ml                            |    3 +-
 test/test_char.ml                             |    3 +-
 test/test_clz_ctz.ml                          |  104 +-
 test/test_compare.ml                          |    3 +-
 test/test_container_module_types.ml           |   24 +-
 test/test_dictionary_module_types.ml          |  152 +-
 test/test_either.ml                           |   12 +-
 test/test_error.ml                            |    6 +-
 test/test_exn_reraise.ml                      |   21 +-
 test/test_exported_int_conversions.ml         |   22 +-
 test/test_float.ml                            |  110 +-
 test/test_globalize_lib.ml                    |   17 +-
 test/test_hash_set.ml                         |   14 +-
 test/test_hashtbl.ml                          |   23 +-
 test/test_identifiable.ml                     |    6 +-
 test/test_indexed_container.ml                |   39 +-
 test/test_info.ml                             |    5 +-
 test/test_int.ml                              |   79 +-
 test/test_int32.ml                            |   16 +-
 test/test_int63.ml                            |   36 +-
 test/test_int63_emul.ml                       |    2 +-
 test/test_int64.ml                            |   16 +-
 test/test_int_conversions.ml                  |   24 +-
 test/test_int_math.ml                         |   25 +-
 test/test_lazy.ml                             |    6 +-
 test/test_list.ml                             |   71 +-
 test/test_map.ml                              |  162 +-
 test/test_map_and_set_internals.ml            | 1983 ++++++++++++++
 test/test_map_and_set_internals.mli           |    1 +
 test/test_map_interface.ml                    |   14 +-
 test/test_map_traversal.ml                    |   10 +-
 test/test_minmax.ml                           |   25 +-
 test/test_nativeint.ml                        |   16 +-
 test/test_obj_array.ml                        |   80 +
 test/test_obj_array.mli                       |    1 +
 test/test_option.ml                           |   37 +-
 test/test_option_array.ml                     |    4 +-
 test/test_or_error.ml                         |    2 +-
 test/test_popcount.ml                         |   24 +-
 test/test_pp.ml                               |   18 +-
 test/test_ppx_compare_lib.ml                  |    1 -
 test/test_queue.ml                            | 2283 ++++++++---------
 test/test_random.ml                           |    4 +-
 test/test_ref.ml                              |   19 +-
 test/test_result.ml                           |   10 +-
 test/test_sequence.ml                         |   12 +-
 test/test_set.ml                              |    4 +-
 test/test_set_interface.ml                    |   16 +-
 test/test_sexpable.ml                         |   26 +-
 test/test_sign.ml                             |    2 +-
 test/test_sign_or_nan.ml                      |    5 +-
 test/test_source_code_position.ml             |    8 +
 test/test_string.ml                           |  119 +-
 test/test_type_equal.ml                       |   92 +-
 test/test_uniform_array.ml                    |  182 +-
 332 files changed, 17176 insertions(+), 8082 deletions(-)
 create mode 100644 generate/zarith.ml
 create mode 100644 hash_types/src/runtime.wat
 create mode 100644 ppx/README.md
 create mode 100644 ppx/src/dune
 create mode 100644 ppx/src/ppx_base_internal.ml
 create mode 100644 ppx/src/ppx_base_internal.mli
 create mode 100644 ppx/test/dune
 create mode 100644 ppx/test/test.mlt
 create mode 100644 src/float_stubs.c
 create mode 100644 src/modes.ml
 create mode 100644 src/modes.mli
 create mode 100644 src/modes_intf.ml
 create mode 100644 src/replace_polymorphic_compare.ml
 create mode 100644 src/replace_polymorphic_compare.mli
 create mode 100644 src/replace_polymorphic_compare_intf.ml
 create mode 100644 src/runtime.wat
 create mode 100644 test/allocation/test_modes_allocation.ml
 create mode 100644 test/allocation/test_modes_allocation.mli
 create mode 100644 test/allocation/test_option_allocation.ml
 create mode 100644 test/allocation/test_option_allocation.mli
 create mode 100644 test/coverage/helpers/adjustable.ml
 create mode 100644 test/coverage/helpers/adjustable.mli
 create mode 100644 test/coverage/helpers/adjustable_intf.ml
 create mode 100644 test/coverage/helpers/base_test_coverage_helpers.ml
 create mode 100644 test/coverage/helpers/data.ml
 create mode 100644 test/coverage/helpers/data.mli
 create mode 100644 test/coverage/helpers/data_intf.ml
 create mode 100644 test/coverage/helpers/dune
 create mode 100644 test/coverage/helpers/func.ml
 create mode 100644 test/coverage/helpers/func.mli
 create mode 100644 test/coverage/helpers/func_intf.ml
 create mode 100644 test/coverage/helpers/memo.ml
 create mode 100644 test/coverage/helpers/memo.mli
 create mode 100644 test/coverage/helpers/memo_intf.ml
 create mode 100644 test/coverage/helpers/overrides.ml
 create mode 100644 test/coverage/helpers/overrides.mli
 create mode 100644 test/coverage/helpers/stats.ml
 create mode 100644 test/coverage/helpers/stats.mli
 rename test/{map_full_interface/base_test_map_full_interface.ml => coverage/map/base_test_coverage_map.ml} (100%)
 create mode 100644 test/coverage/map/constructor.ml
 create mode 100644 test/coverage/map/constructor.mli
 create mode 100644 test/coverage/map/constructor_intf.ml
 create mode 100644 test/coverage/map/dune
 rename test/{map_full_interface => coverage/map}/functor.ml (57%)
 rename test/{map_full_interface => coverage/map}/functor.mli (100%)
 create mode 100644 test/coverage/map/functor_intf.ml
 create mode 100644 test/coverage/map/instances.ml
 create mode 100644 test/coverage/map/instances.mli
 create mode 100644 test/coverage/map/instances_intf.ml
 rename test/{map_full_interface => coverage/map}/test_all.ml (67%)
 rename test/{map_full_interface => coverage/map}/test_all.mli (100%)
 create mode 100644 test/coverage/map/test_poly_accessors.ml
 create mode 100644 test/coverage/map/test_poly_accessors.mli
 create mode 100644 test/coverage/map/test_poly_creators.ml
 create mode 100644 test/coverage/map/test_poly_creators.mli
 create mode 100644 test/coverage/map/test_poly_transformers.ml
 create mode 100644 test/coverage/map/test_poly_transformers.mli
 create mode 100644 test/coverage/map/test_toplevel_accessors.ml
 create mode 100644 test/coverage/map/test_toplevel_accessors.mli
 create mode 100644 test/coverage/map/test_toplevel_creators.ml
 create mode 100644 test/coverage/map/test_toplevel_creators.mli
 create mode 100644 test/coverage/map/test_toplevel_transformers.ml
 create mode 100644 test/coverage/map/test_toplevel_transformers.mli
 create mode 100644 test/coverage/map/test_tree_accessors.ml
 create mode 100644 test/coverage/map/test_tree_accessors.mli
 create mode 100644 test/coverage/map/test_tree_creators.ml
 create mode 100644 test/coverage/map/test_tree_creators.mli
 create mode 100644 test/coverage/map/test_tree_transformers.ml
 create mode 100644 test/coverage/map/test_tree_transformers.mli
 create mode 100644 test/coverage/map/test_using_comparator_accessors.ml
 create mode 100644 test/coverage/map/test_using_comparator_accessors.mli
 create mode 100644 test/coverage/map/test_using_comparator_creators.ml
 create mode 100644 test/coverage/map/test_using_comparator_creators.mli
 create mode 100644 test/coverage/map/test_using_comparator_transformers.ml
 create mode 100644 test/coverage/map/test_using_comparator_transformers.mli
 create mode 100644 test/coverage/set/base_test_coverage_set.ml
 create mode 100644 test/coverage/set/constructor.ml
 create mode 100644 test/coverage/set/constructor.mli
 create mode 100644 test/coverage/set/constructor_intf.ml
 rename test/{map_full_interface => coverage/set}/dune (54%)
 create mode 100644 test/coverage/set/functor.ml
 create mode 100644 test/coverage/set/functor.mli
 create mode 100644 test/coverage/set/functor_intf.ml
 create mode 100644 test/coverage/set/instances.ml
 create mode 100644 test/coverage/set/instances.mli
 create mode 100644 test/coverage/set/instances_intf.ml
 create mode 100644 test/coverage/set/test_all.ml
 create mode 100644 test/coverage/set/test_all.mli
 create mode 100644 test/coverage/set/test_poly_accessors.ml
 create mode 100644 test/coverage/set/test_poly_accessors.mli
 create mode 100644 test/coverage/set/test_poly_creators.ml
 create mode 100644 test/coverage/set/test_poly_creators.mli
 create mode 100644 test/coverage/set/test_poly_transformers.ml
 create mode 100644 test/coverage/set/test_poly_transformers.mli
 create mode 100644 test/coverage/set/test_toplevel_accessors.ml
 create mode 100644 test/coverage/set/test_toplevel_accessors.mli
 create mode 100644 test/coverage/set/test_toplevel_creators.ml
 create mode 100644 test/coverage/set/test_toplevel_creators.mli
 create mode 100644 test/coverage/set/test_toplevel_transformers.ml
 create mode 100644 test/coverage/set/test_toplevel_transformers.mli
 create mode 100644 test/coverage/set/test_tree_accessors.ml
 create mode 100644 test/coverage/set/test_tree_accessors.mli
 create mode 100644 test/coverage/set/test_tree_creators.ml
 create mode 100644 test/coverage/set/test_tree_creators.mli
 create mode 100644 test/coverage/set/test_tree_transformers.ml
 create mode 100644 test/coverage/set/test_tree_transformers.mli
 create mode 100644 test/coverage/set/test_using_comparator_accessors.ml
 create mode 100644 test/coverage/set/test_using_comparator_accessors.mli
 create mode 100644 test/coverage/set/test_using_comparator_creators.ml
 create mode 100644 test/coverage/set/test_using_comparator_creators.mli
 create mode 100644 test/coverage/set/test_using_comparator_transformers.ml
 create mode 100644 test/coverage/set/test_using_comparator_transformers.mli
 delete mode 100644 test/map_full_interface/functor_intf.ml
 delete mode 100644 test/map_full_interface/test_poly.ml
 delete mode 100644 test/map_full_interface/test_poly.mli
 delete mode 100644 test/map_full_interface/test_poly_intf.ml
 delete mode 100644 test/map_full_interface/test_toplevel.ml
 delete mode 100644 test/map_full_interface/test_toplevel.mli
 delete mode 100644 test/map_full_interface/test_toplevel_intf.ml
 delete mode 100644 test/map_full_interface/test_tree.ml
 delete mode 100644 test/map_full_interface/test_tree.mli
 delete mode 100644 test/map_full_interface/test_tree_intf.ml
 delete mode 100644 test/map_full_interface/test_using_comparator.ml
 delete mode 100644 test/map_full_interface/test_using_comparator.mli
 delete mode 100644 test/map_full_interface/test_using_comparator_intf.ml
 create mode 100644 test/test_map_and_set_internals.ml
 create mode 100644 test/test_map_and_set_internals.mli
 create mode 100644 test/test_obj_array.ml
 create mode 100644 test/test_obj_array.mli

diff --git a/generate/dune b/generate/dune
index 94a1b6be..efcd36a9 100644
--- a/generate/dune
+++ b/generate/dune
@@ -1,5 +1,5 @@
 (executables
  (modes byte exe)
  (names generate_pow_overflow_bounds)
- (libraries num)
+ (libraries zarith)
  (preprocess no_preprocessing))
diff --git a/generate/generate_pow_overflow_bounds.ml b/generate/generate_pow_overflow_bounds.ml
index c9e7c2f8..2a881a08 100644
--- a/generate/generate_pow_overflow_bounds.ml
+++ b/generate/generate_pow_overflow_bounds.ml
@@ -4,6 +4,7 @@
 (* This module generates lookup tables to detect integer overflow when calculating integer
    exponents.  At index [e], [table.[e]^e] will not overflow, but [(table[e] + 1)^e]
    will. *)
+module Z = Zarith.Z
 
 type mode =
   | Normal
@@ -28,19 +29,6 @@ let oc, mode =
   | _ -> failwith "bad command line arguments"
 ;;
 
-module Big_int = struct
-  include Big_int
-
-  let ( > ) = gt_big_int
-  let ( <= ) = le_big_int
-  let ( ^ ) = power_big_int_positive_int
-  let ( - ) = sub_big_int
-  let ( + ) = add_big_int
-  let one = unit_big_int
-  let sqrt = sqrt_big_int
-  let to_string = string_of_big_int
-end
-
 module Array = StdLabels.Array
 
 type generated_type =
@@ -52,16 +40,16 @@ type generated_type =
 let max_big_int_for_bits bits =
   let shift = bits - 1 in
   (* sign bit *)
-  Big_int.(shift_left_big_int one shift - one)
+  Z.(shift_left one shift - one)
 ;;
 
 let safe_to_print_as_int =
   let int31_max = max_big_int_for_bits 31 in
-  fun x -> Big_int.(x <= int31_max)
+  fun x -> x <= int31_max
 ;;
 
 let format_entry typ b =
-  let s = Big_int.to_string b in
+  let s = Z.to_string b in
   match typ with
   | Int ->
     if safe_to_print_as_int b then s else Printf.sprintf "Stdlib.Int64.to_int %sL" s
@@ -99,16 +87,16 @@ let generate_negative_bounds = function
 ;;
 
 let highest_base exponent max_val =
-  let open Big_int in
+  let open Z in
   match exponent with
   | 0 | 1 -> max_val
   | 2 -> sqrt max_val
   | _ ->
     let rec search possible_base =
-      if possible_base ^ exponent > max_val
+      if possible_base ** exponent > max_val
       then (
         let res = possible_base - one in
-        assert (res ^ exponent <= max_val);
+        assert (res ** exponent <= max_val);
         res)
       else search (possible_base + one)
     in
@@ -128,7 +116,7 @@ let gen_array ~typ ~bits ~sign ~indent =
   let bounds =
     match sign with
     | Pos -> pos_bounds
-    | Neg -> Array.map pos_bounds ~f:Big_int.minus_big_int
+    | Neg -> Array.map pos_bounds ~f:Z.( ~- )
   in
   pr "[| %s" (format_entry typ bounds.(0));
   for i = 1 to Array.length bounds - 1 do
diff --git a/generate/zarith.ml b/generate/zarith.ml
new file mode 100644
index 00000000..b40264e5
--- /dev/null
+++ b/generate/zarith.ml
@@ -0,0 +1,4 @@
+module Big_int_Z = Big_int_Z
+module Q = Q
+module Z = Z
+module Zarith_version = Zarith_version
diff --git a/hash_types/src/base_internalhash_types.ml b/hash_types/src/base_internalhash_types.ml
index df4eef65..16826655 100644
--- a/hash_types/src/base_internalhash_types.ml
+++ b/hash_types/src/base_internalhash_types.ml
@@ -1,18 +1,42 @@
-(** [state] is defined as a subtype of [int] using the [private] keyword. This makes it an
-    opaque type for most purposes, and tells the compiler that the type is immediate. *)
-type state = private int
-
 type seed = int
 type hash_value = int
 
-external create_seeded : seed -> state = "%identity" [@@noalloc]
+(* The main non-64-bit systems we are planning to support are JavaScript and WebAssembly.
+   js_of_ocaml is treated as a 32-bit platform with 32-bit native integers. All of the
+   external [caml_hash*] implementations are all written assuming these 32-bit native ints
+   and so using Int32 on the [Non_immediate] path allows for this change to be a runtime
+   noop for native and JavaScript. If we were to make this something like [Int63], which
+   intuitively feels like a more consistent choice, we would have to change the
+   implementations of all of these pretty foundational hash functions in both js and wasm. *)
+include Sys.Immediate64.Make (Int) (Int32)
+
+type state = t
+
+let compare_state (x : state) (y : state) : hash_value =
+  match repr with
+  | Immediate -> Int.compare x y
+  | Non_immediate -> Int32.compare x y
+;;
+
+let state_to_string (x : state) : string =
+  match repr with
+  | Immediate -> Int.to_string x
+  | Non_immediate -> Int32.to_string x
+;;
+
+let create_seeded (x : int) : state =
+  match repr with
+  | Immediate -> x
+  | Non_immediate -> Int32.of_int x
+;;
 
+(* onicole: On a 32-bit backend such as Wasm, these functions may allocate. *)
 external fold_int64
   :  state
   -> (int64[@unboxed])
   -> state
   = "Base_internalhash_fold_int64" "Base_internalhash_fold_int64_unboxed"
-  [@@noalloc]
+[@@noalloc]
 
 external fold_int : state -> int -> state = "Base_internalhash_fold_int" [@@noalloc]
 
@@ -21,10 +45,10 @@ external fold_float
   -> (float[@unboxed])
   -> state
   = "Base_internalhash_fold_float" "Base_internalhash_fold_float_unboxed"
-  [@@noalloc]
+[@@noalloc]
 
 external fold_string : state -> string -> state = "Base_internalhash_fold_string"
-  [@@noalloc]
+[@@noalloc]
 
 external get_hash_value : state -> hash_value = "Base_internalhash_get_hash_value"
-  [@@noalloc]
+[@@noalloc]
diff --git a/hash_types/src/runtime.wat b/hash_types/src/runtime.wat
new file mode 100644
index 00000000..7e5cf2da
--- /dev/null
+++ b/hash_types/src/runtime.wat
@@ -0,0 +1,78 @@
+(module
+   (import "env" "Int32_val" (func $Int32_val (param (ref eq)) (result i32)))
+   (import "env" "Int64_val" (func $Int64_val (param (ref eq)) (result i64)))
+   (import "env" "Double_val"
+      (func $Double_val (param (ref eq)) (result f64)))
+   (import "env" "caml_copy_int32"
+      (func $caml_copy_int32 (param $i i32) (result (ref eq))))
+   (import "env" "caml_hash_mix_int"
+      (func $caml_hash_mix_int (param i32) (param i32) (result i32)))
+   (import "env" "caml_hash_mix_int64"
+      (func $caml_hash_mix_int64 (param i32) (param i64) (result i32)))
+   (import "env" "caml_hash_mix_double"
+      (func $caml_hash_mix_double (param i32) (param f64) (result i32)))
+   (import "env" "caml_hash_mix_string"
+      (func $caml_hash_mix_string
+         (param i32) (param (ref $string)) (result i32)))
+   (import "env" "caml_hash_mix_final"
+      (func $caml_hash_mix_final (param i32) (result i32)))
+
+   (type $string (array (mut i8)))
+   (type $compare
+      (func (param (ref eq)) (param (ref eq)) (param i32) (result i32)))
+   (type $hash
+      (func (param (ref eq)) (result i32)))
+   (type $fixed_length (struct (field $bsize_32 i32) (field $bsize_64 i32)))
+   (type $serialize
+      (func (param (ref eq)) (param (ref eq)) (result i32) (result i32)))
+   (type $deserialize (func (param (ref eq)) (result (ref eq)) (result i32)))
+   (type $dup (func (param (ref eq)) (result (ref eq))))
+   (type $custom_operations
+      (struct
+         (field $id (ref $string))
+         (field $compare (ref null $compare))
+         (field $compare_ext (ref null $compare))
+         (field $hash (ref null $hash))
+         (field $fixed_length (ref null $fixed_length))
+         (field $serialize (ref null $serialize))
+         (field $deserialize (ref null $deserialize))
+         (field $dup (ref null $dup))))
+   (type $custom (sub (struct (field (ref $custom_operations)))))
+   (type $int32
+      (sub final $custom (struct (field (ref $custom_operations)) (field i32))))
+
+   (func (export "Base_internalhash_fold_int64")
+      (param $st (ref eq)) (param $i (ref eq)) (result (ref eq))
+      (call $caml_copy_int32
+         (call $caml_hash_mix_int64
+            (call $Int32_val (local.get $st))
+            (call $Int64_val (local.get $i)))))
+
+   (func (export "Base_internalhash_fold_int")
+      (param $st (ref eq)) (param $i (ref eq)) (result (ref eq))
+      (call $caml_copy_int32
+         (call $caml_hash_mix_int
+            (call $Int32_val (local.get $st))
+            (i31.get_s (ref.cast (ref i31) (local.get $i))))))
+
+   (func (export "Base_internalhash_fold_float")
+      (param $st (ref eq)) (param $f (ref eq)) (result (ref eq))
+      (call $caml_copy_int32
+         (call $caml_hash_mix_double
+            (call $Int32_val (local.get $st))
+            (call $Double_val (local.get $f)))))
+
+   (func (export "Base_internalhash_fold_string")
+      (param $st (ref eq)) (param $s (ref eq)) (result (ref eq))
+      (call $caml_copy_int32
+         (call $caml_hash_mix_string
+            (call $Int32_val (local.get $st))
+            (ref.cast (ref $string) (local.get $s)))))
+
+   (func (export "Base_internalhash_get_hash_value")
+      (param $st (ref eq)) (result (ref eq))
+      (ref.i31
+         (i32.and
+            (call $caml_hash_mix_final (call $Int32_val (local.get $st)))
+            (i32.const 0x3FFFFFFF))))
+)
diff --git a/hash_types/test/test_immediate.ml b/hash_types/test/test_immediate.ml
index 9aaea81b..e0edf3ba 100644
--- a/hash_types/test/test_immediate.ml
+++ b/hash_types/test/test_immediate.ml
@@ -2,8 +2,7 @@ open! Base
 open! Import
 
 let%expect_test "[Base.Hash.state] is still immediate" =
-  require_no_allocation [%here] (fun () ->
-    ignore (Sys.opaque_identity (Base.Hash.create ())));
+  require_no_allocation (fun () -> ignore (Sys.opaque_identity (Base.Hash.create ())));
   [%expect {| |}]
 ;;
 
diff --git a/lint/ppx_base_lint.ml b/lint/ppx_base_lint.ml
index e0502492..ab2e1c03 100644
--- a/lint/ppx_base_lint.ml
+++ b/lint/ppx_base_lint.ml
@@ -25,7 +25,7 @@ let zero_modules () =
   |> Array.to_list
   |> List.filter ~f:(fun fn -> Stdlib.Filename.check_suffix fn "0.ml")
   |> List.map ~f:(fun fn ->
-       String.capitalize (String.sub fn ~pos:0 ~len:(String.length fn - 4)))
+    String.capitalize (String.sub fn ~pos:0 ~len:(String.length fn - 4)))
   |> Set.of_list (module String)
 ;;
 
@@ -114,14 +114,14 @@ let check current_module =
         let expansion =
           Ppx_cold.expand_cold_attribute attr
           |> List.map ~f:(fun a ->
-               { a with
-                 attr_name =
-                   { a.attr_name with
-                     txt =
-                       String.chop_prefix a.attr_name.txt ~prefix:"ocaml."
-                       |> Option.value ~default:a.attr_name.txt
-                   }
-               })
+            { a with
+              attr_name =
+                { a.attr_name with
+                  txt =
+                    String.chop_prefix a.attr_name.txt ~prefix:"ocaml."
+                    |> Option.value ~default:a.attr_name.txt
+                }
+            })
         in
         let is_part_of_expansion attr =
           List.exists expansion ~f:(fun a ->
diff --git a/ppx/README.md b/ppx/README.md
new file mode 100644
index 00000000..3b67388e
--- /dev/null
+++ b/ppx/README.md
@@ -0,0 +1,6 @@
+# ppx_base_internal
+
+This ppx is intended only for use inside Base itself, to help write certain repeated code
+patterns. It is not designed for use in other contexts. For example, it may refer to
+internal names like `Bool0`, or be specialized to use cases in `Base` that are not
+applicable to other code.
diff --git a/ppx/src/dune b/ppx/src/dune
new file mode 100644
index 00000000..ec1e4e5e
--- /dev/null
+++ b/ppx/src/dune
@@ -0,0 +1,6 @@
+(library
+ (name ppx_base_internal)
+ (kind ppx_deriver)
+ (libraries base ppxlib)
+ (preprocess
+  (pps ppxlib.metaquot)))
diff --git a/ppx/src/ppx_base_internal.ml b/ppx/src/ppx_base_internal.ml
new file mode 100644
index 00000000..5afa9060
--- /dev/null
+++ b/ppx/src/ppx_base_internal.ml
@@ -0,0 +1,79 @@
+open! Base
+open Ppxlib
+
+module Specialize_polymorphic_compare = struct
+  let signature ~loc =
+    [%sig:
+      [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+      external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+      external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+      external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+      external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+      external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+      external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+      external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+      external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+      external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+      external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+      val ascending : t -> t -> int
+      val descending : t -> t -> int
+      val max : t -> t -> t
+      val min : t -> t -> t]
+  ;;
+
+  let structure ~loc =
+    [%str
+      [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+      external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+      external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+      external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+      external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+      external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+      external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+      external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+      external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+      external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+      external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+      let ascending x y = compare x y
+      let descending x y = compare y x
+      let max x y = Bool0.select (x >= y) x y
+      let min x y = Bool0.select (x <= y) x y]
+  ;;
+
+  let check_decl decl =
+    match core_type_of_type_declaration decl with
+    | [%type: t] -> Ok ()
+    | _ ->
+      Error
+        (Location.Error.to_extension
+           (Location.Error.createf
+              ~loc:decl.ptype_loc
+              "deriving specialize_polymorphic_compare: expected [type t], no other name \
+               or parameters"))
+  ;;
+
+  let sig_type_decl =
+    Deriving.Generator.V2.make_noarg (fun ~ctxt:_ (_, decls) ->
+      List.concat_map decls ~f:(fun decl ->
+        let loc = decl.ptype_loc in
+        match check_decl decl with
+        | Ok () -> signature ~loc
+        | Error ext -> [ Ast_builder.Default.psig_extension ~loc ext [] ]))
+  ;;
+
+  let str_type_decl =
+    Deriving.Generator.V2.make_noarg (fun ~ctxt:_ (_, decls) ->
+      List.concat_map decls ~f:(fun decl ->
+        let loc = decl.ptype_loc in
+        match check_decl decl with
+        | Ok () -> structure ~loc
+        | Error ext -> [ Ast_builder.Default.pstr_extension ~loc ext [] ]))
+  ;;
+
+  let deriver =
+    Deriving.add "specialize_polymorphic_compare" ~sig_type_decl ~str_type_decl
+  ;;
+end
diff --git a/ppx/src/ppx_base_internal.mli b/ppx/src/ppx_base_internal.mli
new file mode 100644
index 00000000..53ff3606
--- /dev/null
+++ b/ppx/src/ppx_base_internal.mli
@@ -0,0 +1,6 @@
+open! Base
+open Ppxlib
+
+module Specialize_polymorphic_compare : sig
+  val deriver : Deriving.t
+end
diff --git a/ppx/test/dune b/ppx/test/dune
new file mode 100644
index 00000000..e69de29b
diff --git a/ppx/test/test.mlt b/ppx/test/test.mlt
new file mode 100644
index 00000000..a0cdf015
--- /dev/null
+++ b/ppx/test/test.mlt
@@ -0,0 +1,29 @@
+type t [@@deriving specialize_polymorphic_compare]
+
+[%%expect
+  {|
+Line _, characters _-_:
+Error (warning 22 [preprocessor]): ppx_base_internal: intended only for use inside Base
+
+Line _, characters _-_:
+Error: Unbound module Bool0
+Hint: Did you mean Bool?
+|}]
+
+type 'a t [@@deriving specialize_polymorphic_compare]
+
+[%%expect
+  {|
+Line _, characters _-_:
+Error: deriving specialize_polymorphic_compare: expected [type t], no other
+       name or parameters
+|}]
+
+type foo [@@deriving specialize_polymorphic_compare]
+
+[%%expect
+  {|
+Line _, characters _-_:
+Error: deriving specialize_polymorphic_compare: expected [type t], no other
+       name or parameters
+|}]
diff --git a/src/applicative.ml b/src/applicative.ml
index f6577982..7d374bbf 100644
--- a/src/applicative.ml
+++ b/src/applicative.ml
@@ -65,22 +65,23 @@ module Make3 (X : Basic3) : S3 with type ('a, 'd, 'e) t := ('a, 'd, 'e) X.t = st
 end
 
 module Make2 (X : Basic2) : S2 with type ('a, 'e) t := ('a, 'e) X.t = Make3 (struct
-  include X
+    include X
 
-  type ('a, 'd, 'e) t = ('a, 'd) X.t
-end)
+    type ('a, 'd, 'e) t = ('a, 'd) X.t
+  end)
 
 module Make (X : Basic) : S with type 'a t := 'a X.t = Make2 (struct
-  include X
+    include X
 
-  type ('a, 'e) t = 'a X.t
-end)
+    type ('a, 'e) t = 'a X.t
+  end)
 
 module Make_let_syntax3
-  (X : For_let_syntax3) (Intf : sig
-    module type S
-  end)
-  (Impl : Intf.S) =
+    (X : For_let_syntax3)
+    (Intf : sig
+       module type S
+     end)
+    (Impl : Intf.S) =
 struct
   module Let_syntax = struct
     include X
@@ -93,10 +94,11 @@ struct
 end
 
 module Make_let_syntax2
-  (X : For_let_syntax2) (Intf : sig
-    module type S
-  end)
-  (Impl : Intf.S) =
+    (X : For_let_syntax2)
+    (Intf : sig
+       module type S
+     end)
+    (Impl : Intf.S) =
   Make_let_syntax3
     (struct
       include X
@@ -107,10 +109,11 @@ module Make_let_syntax2
     (Impl)
 
 module Make_let_syntax
-  (X : For_let_syntax) (Intf : sig
-    module type S
-  end)
-  (Impl : Intf.S) =
+    (X : For_let_syntax)
+    (Intf : sig
+       module type S
+     end)
+    (Impl : Intf.S) =
   Make_let_syntax2
     (struct
       include X
@@ -158,17 +161,17 @@ end
 
 module Make2_using_map2 (X : Basic2_using_map2) :
   S2 with type ('a, 'e) t := ('a, 'e) X.t = Make3_using_map2 (struct
-  include X
+    include X
 
-  type ('a, 'd, 'e) t = ('a, 'd) X.t
-end)
+    type ('a, 'd, 'e) t = ('a, 'd) X.t
+  end)
 
 module Make_using_map2 (X : Basic_using_map2) : S with type 'a t := 'a X.t =
 Make2_using_map2 (struct
-  include X
+    include X
 
-  type ('a, 'e) t = 'a X.t
-end)
+    type ('a, 'e) t = 'a X.t
+  end)
 
 module Make3_using_map2_local (X : Basic3_using_map2_local) :
   S3_local with type ('a, 'd, 'e) t := ('a, 'd, 'e) X.t = struct
@@ -207,66 +210,66 @@ end
 
 module Make2_using_map2_local (X : Basic2_using_map2_local) :
   S2_local with type ('a, 'e) t := ('a, 'e) X.t = Make3_using_map2_local (struct
-  include X
+    include X
 
-  type ('a, 'd, 'e) t = ('a, 'd) X.t
-end)
+    type ('a, 'd, 'e) t = ('a, 'd) X.t
+  end)
 
 module Make_using_map2_local (X : Basic_using_map2_local) :
   S_local with type 'a t := 'a X.t = Make2_using_map2_local (struct
-  include X
+    include X
 
-  type ('a, 'e) t = 'a X.t
-end)
+    type ('a, 'e) t = 'a X.t
+  end)
 
 module Of_monad2 (M : Monad.S2) : S2 with type ('a, 'e) t := ('a, 'e) M.t = Make2 (struct
-  type ('a, 'e) t = ('a, 'e) M.t
+    type ('a, 'e) t = ('a, 'e) M.t
 
-  let return = M.return
-  let apply mf mx = M.bind mf ~f:(fun f -> M.map mx ~f)
-  let map = `Custom M.map
-end)
+    let return = M.return
+    let apply mf mx = M.bind mf ~f:(fun f -> M.map mx ~f)
+    let map = `Custom M.map
+  end)
 
 module Of_monad (M : Monad.S) : S with type 'a t := 'a M.t = Of_monad2 (struct
-  include M
+    include M
 
-  type ('a, _) t = 'a M.t
-end)
+    type ('a, _) t = 'a M.t
+  end)
 
 module Compose (F : S) (G : S) : S with type 'a t = 'a F.t G.t = struct
   type 'a t = 'a F.t G.t
 
   include Make (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let return a = G.return (F.return a)
-    let apply tf tx = G.apply (G.map ~f:F.apply tf) tx
-    let custom_map t ~f = G.map ~f:(F.map ~f) t
-    let map = `Custom custom_map
-  end)
+      let return a = G.return (F.return a)
+      let apply tf tx = G.apply (G.map ~f:F.apply tf) tx
+      let custom_map t ~f = G.map ~f:(F.map ~f) t
+      let map = `Custom custom_map
+    end)
 end
 
 module Pair (F : S) (G : S) : S with type 'a t = 'a F.t * 'a G.t = struct
   type 'a t = 'a F.t * 'a G.t
 
   include Make (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let return a = F.return a, G.return a
-    let apply tf tx = F.apply (fst tf) (fst tx), G.apply (snd tf) (snd tx)
-    let custom_map t ~f = F.map ~f (fst t), G.map ~f (snd t)
-    let map = `Custom custom_map
-  end)
+      let return a = F.return a, G.return a
+      let apply tf tx = F.apply (fst tf) (fst tx), G.apply (snd tf) (snd tx)
+      let custom_map t ~f = F.map ~f (fst t), G.map ~f (snd t)
+      let map = `Custom custom_map
+    end)
 end
 
 module Ident = struct
   type 'a t = 'a
 
   include Make_using_map2_local (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let return = Fn.id
-    let map2 a b ~f = f a b
-    let map = `Custom (fun a ~f -> f a)
-  end)
+      let return = Fn.id
+      let map2 a b ~f = f a b
+      let map = `Custom (fun a ~f -> f a)
+    end)
 end
diff --git a/src/applicative_intf.ml b/src/applicative_intf.ml
index 60c49a77..e6617e5e 100644
--- a/src/applicative_intf.ml
+++ b/src/applicative_intf.ml
@@ -99,13 +99,13 @@ end
 
 module type For_let_syntax =
   For_let_syntax_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type For_let_syntax_local =
   For_let_syntax_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type S_gen = sig
   include For_let_syntax_gen
@@ -125,17 +125,17 @@ end
 
 module type S =
   S_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
-     and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
+   and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
 
 module type S_local =
   S_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
-     and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
+   and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
 
 module type Let_syntax = sig
   type 'a t
@@ -217,19 +217,19 @@ module type For_let_syntax2_gen = sig
 
   include
     Applicative_infix2_gen
-      with type ('a, 'e) t := ('a, 'e) t
-       and type ('a, 'b) fn := ('a, 'b) fn
+    with type ('a, 'e) t := ('a, 'e) t
+     and type ('a, 'b) fn := ('a, 'b) fn
 end
 
 module type For_let_syntax2 =
   For_let_syntax2_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type For_let_syntax2_local =
   For_let_syntax2_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type S2_gen = sig
   include For_let_syntax2_gen
@@ -251,23 +251,23 @@ module type S2_gen = sig
 
   module Applicative_infix :
     Applicative_infix2_gen
-      with type ('a, 'e) t := ('a, 'e) t
-       and type ('a, 'b) fn := ('a, 'b) fn
+    with type ('a, 'e) t := ('a, 'e) t
+     and type ('a, 'b) fn := ('a, 'b) fn
 end
 
 module type S2 =
   S2_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
-     and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
+   and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
 
 module type S2_local =
   S2_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
-     and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
+   and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
 
 module type Let_syntax2 = sig
   type ('a, 'e) t
@@ -349,19 +349,19 @@ module type For_let_syntax3_gen = sig
 
   include
     Applicative_infix3_gen
-      with type ('a, 'd, 'e) t := ('a, 'd, 'e) t
-       and type ('a, 'b) fn := ('a, 'b) fn
+    with type ('a, 'd, 'e) t := ('a, 'd, 'e) t
+     and type ('a, 'b) fn := ('a, 'b) fn
 end
 
 module type For_let_syntax3 =
   For_let_syntax3_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type For_let_syntax3_local =
   For_let_syntax3_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type S3_gen = sig
   include For_let_syntax3_gen
@@ -387,23 +387,23 @@ module type S3_gen = sig
 
   module Applicative_infix :
     Applicative_infix3_gen
-      with type ('a, 'd, 'e) t := ('a, 'd, 'e) t
-       and type ('a, 'b) fn := ('a, 'b) fn
+    with type ('a, 'd, 'e) t := ('a, 'd, 'e) t
+     and type ('a, 'b) fn := ('a, 'b) fn
 end
 
 module type S3 =
   S3_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
-     and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
+   and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
 
 module type S3_local =
   S3_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
-     and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b, 'c) fun2 := 'a -> 'b -> 'c
+   and type ('a, 'b, 'c, 'd) fun3 := 'a -> 'b -> 'c -> 'd
 
 module type Let_syntax3 = sig
   type ('a, 'd, 'e) t
@@ -475,27 +475,30 @@ module type Applicative = sig
   module Make3 (X : Basic3) : S3 with type ('a, 'd, 'e) t := ('a, 'd, 'e) X.t
 
   module Make_let_syntax
-    (X : For_let_syntax) (Intf : sig
-      module type S
-    end)
-    (Impl : Intf.S) :
+      (X : For_let_syntax)
+      (Intf : sig
+         module type S
+       end)
+      (Impl : Intf.S) :
     Let_syntax with type 'a t := 'a X.t with module Open_on_rhs_intf := Intf
 
   module Make_let_syntax2
-    (X : For_let_syntax2) (Intf : sig
-      module type S
-    end)
-    (Impl : Intf.S) :
+      (X : For_let_syntax2)
+      (Intf : sig
+         module type S
+       end)
+      (Impl : Intf.S) :
     Let_syntax2 with type ('a, 'e) t := ('a, 'e) X.t with module Open_on_rhs_intf := Intf
 
   module Make_let_syntax3
-    (X : For_let_syntax3) (Intf : sig
-      module type S
-    end)
-    (Impl : Intf.S) :
+      (X : For_let_syntax3)
+      (Intf : sig
+         module type S
+       end)
+      (Impl : Intf.S) :
     Let_syntax3
-      with type ('a, 'd, 'e) t := ('a, 'd, 'e) X.t
-      with module Open_on_rhs_intf := Intf
+    with type ('a, 'd, 'e) t := ('a, 'd, 'e) X.t
+    with module Open_on_rhs_intf := Intf
 
   module Make_using_map2 (X : Basic_using_map2) : S with type 'a t := 'a X.t
 
diff --git a/src/array.ml b/src/array.ml
index 9f250974..577ae908 100644
--- a/src/array.ml
+++ b/src/array.ml
@@ -48,12 +48,12 @@ let t_sexp_grammar : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_gramma
    - http://www.sorting-algorithms.com/quick-sort-3-way *)
 
 module Sorter (S : sig
-  type 'a t
+    type 'a t
 
-  val get : 'a t -> int -> 'a
-  val set : 'a t -> int -> 'a -> unit
-  val length : 'a t -> int
-end) =
+    val get : 'a t -> int -> 'a
+    val set : 'a t -> int -> 'a -> unit
+    val length : 'a t -> int
+  end) =
 struct
   include S
 
@@ -293,12 +293,12 @@ end
 [@@inline]
 
 module Sort = Sorter (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let get = unsafe_get
-  let set = unsafe_set
-  let length = length
-end)
+    let get = unsafe_get
+    let set = unsafe_set
+    let length = length
+  end)
 
 let sort = Sort.sort
 let of_array t = t
@@ -329,6 +329,11 @@ let is_sorted_strictly t ~compare =
   !result
 ;;
 
+(* This implementation initializes the output only once, based on the primitive
+   [caml_array_sub]. Other approaches, like [init] or [map], first initialize with a fixed
+   value, then blit from the source. *)
+let copy t = sub t ~pos:0 ~len:(length t)
+
 let merge a1 a2 ~compare =
   let l1 = Array.length a1 in
   let l2 = Array.length a2 in
@@ -364,7 +369,7 @@ let merge a1 a2 ~compare =
     merged)
 ;;
 
-let copy_matrix = map ~f:copy
+let copy_matrix tt = map ~f:copy tt
 
 let folding_map t ~init ~f =
   let acc = ref init in
@@ -553,7 +558,7 @@ let filter_opt t = filter_map t ~f:Fn.id
 
 let raise_length_mismatch name n1 n2 =
   invalid_argf "length mismatch in %s: %d <> %d" name n1 n2 ()
-  [@@cold] [@@inline never] [@@local never] [@@specialise never]
+[@@cold] [@@inline never] [@@local never] [@@specialise never]
 ;;
 
 let check_length2_exn name t1 t2 =
@@ -851,7 +856,8 @@ let partitioni_tf t ~f =
 
 let partition_map t ~f = partition_mapi t ~f:(fun _ x -> f x) [@nontail]
 let partition_tf t ~f = partitioni_tf t ~f:(fun _ x -> f x) [@nontail]
-let last t = t.(length t - 1)
+let last_exn t = t.(length t - 1)
+let last = last_exn
 
 (* Convert to a sequence but does not attempt to protect against modification
    in the array. *)
@@ -898,29 +904,30 @@ let transpose_exn tt =
   | Some tt' -> tt'
 ;;
 
-include Binary_searchable.Make1 (struct
-  type nonrec 'a t = 'a t
-
-  let get = get
-  let length = length
-end)
+let map t ~f = map t ~f
 
-include Blit.Make1 (struct
-  type nonrec 'a t = 'a t
+include Binary_searchable.Make1 (struct
+    type nonrec 'a t = 'a t
 
-  let length = length
+    let get = get
+    let length = length
+  end)
 
-  let create_like ~len t =
-    if len = 0
-    then [||]
-    else (
-      assert (length t > 0);
-      create ~len t.(0))
-  ;;
+let blito ~src ?(src_pos = 0) ?(src_len = length src - src_pos) ~dst ?(dst_pos = 0) () =
+  blit ~src ~src_pos ~len:src_len ~dst ~dst_pos
+;;
 
-  let unsafe_blit = unsafe_blit
-end)
+let subo ?(pos = 0) ?len src =
+  sub
+    src
+    ~pos
+    ~len:
+      (match len with
+       | Some i -> i
+       | None -> length src - pos)
+;;
 
+let sub t ~pos ~len = sub t ~pos ~len
 let invariant invariant_a t = iter t ~f:invariant_a
 
 module Private = struct
diff --git a/src/array.mli b/src/array.mli
index 35e42aaf..3aa35b92 100644
--- a/src/array.mli
+++ b/src/array.mli
@@ -261,7 +261,8 @@ val unzip : ('a * 'b) t -> 'a t * 'b t
     List.sort *)
 val sorted_copy : 'a t -> compare:('a -> 'a -> int) -> 'a t
 
-val last : 'a t -> 'a
+val last : 'a t -> 'a [@@deprecated "[since 2024-07] This was renamed to [last_exn]"]
+val last_exn : 'a t -> 'a
 val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
 val equal__local : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
 
@@ -303,12 +304,12 @@ module Private : sig
   end
 
   module Sorter (S : sig
-    type 'a t
+      type 'a t
 
-    val get : 'a t -> int -> 'a
-    val set : 'a t -> int -> 'a -> unit
-    val length : 'a t -> int
-  end) : sig
+      val get : 'a t -> int -> 'a
+      val set : 'a t -> int -> 'a -> unit
+      val length : 'a t -> int
+    end) : sig
     val sort : ?pos:int -> ?len:int -> 'a S.t -> compare:('a -> 'a -> int) -> unit
   end
 end
diff --git a/src/array0.ml b/src/array0.ml
index 6acb31e0..1a8fa613 100644
--- a/src/array0.ml
+++ b/src/array0.ml
@@ -48,6 +48,10 @@ module Array = struct
     -> len:int
     -> unit
     = "caml_array_blit"
+
+  external unsafe_fill : 'a array -> int -> int -> 'a -> unit = "caml_array_fill"
+  external unsafe_sub : 'a array -> int -> int -> 'a array = "caml_array_sub"
+  external concat : 'a array list -> 'a array = "caml_array_concat"
 end
 
 include Array
@@ -71,10 +75,24 @@ let create_float_uninitialized ~len =
 ;;
 
 let append = Stdlib.Array.append
-let blit = Stdlib.Array.blit
-let concat = Stdlib.Array.concat
-let copy = Stdlib.Array.copy
-let fill = Stdlib.Array.fill
+
+let blit ~src ~src_pos ~dst ~dst_pos ~len =
+  Ordered_collection_common0.check_pos_len_exn
+    ~pos:src_pos
+    ~len
+    ~total_length:(length src);
+  Ordered_collection_common0.check_pos_len_exn
+    ~pos:dst_pos
+    ~len
+    ~total_length:(length dst);
+  unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len
+;;
+
+let fill a ~pos ~len v =
+  if pos < 0 || len < 0 || pos > length a - len
+  then invalid_arg "Array.fill"
+  else unsafe_fill a pos len v
+;;
 
 let init len ~(f : _ -> _) =
   if len = 0
@@ -91,7 +109,13 @@ let init len ~(f : _ -> _) =
 
 let make_matrix = Stdlib.Array.make_matrix
 let of_list = Stdlib.Array.of_list
-let sub = Stdlib.Array.sub
+
+let sub a ~pos ~len =
+  if pos < 0 || len < 0 || pos > length a - len
+  then invalid_arg "Array.sub"
+  else unsafe_sub a pos len
+;;
+
 let to_list = Stdlib.Array.to_list
 
 let fold t ~init ~(f : _ -> _ -> _) =
diff --git a/src/avltree.ml b/src/avltree.ml
index f89f2b06..575517b1 100644
--- a/src/avltree.ml
+++ b/src/avltree.ml
@@ -129,7 +129,7 @@ let balance tree =
           | Empty | Leaf _ -> assert false
           | Node
               ({ left = lr_left; key = _; value = _; height = _; right = lr_right } as
-              lr_node) ->
+               lr_node) ->
             left_node.right <- lr_left;
             root_node.left <- lr_right;
             lr_node.right <- tree;
@@ -163,7 +163,7 @@ let balance tree =
           | Empty | Leaf _ -> assert false
           | Node
               ({ left = rl_left; key = _; value = _; height = _; right = rl_right } as
-              rl_node) ->
+               rl_node) ->
             right_node.left <- rl_right;
             root_node.right <- rl_left;
             rl_node.left <- tree;
diff --git a/src/base.ml b/src/base.ml
index bdc22337..111ac689 100644
--- a/src/base.ml
+++ b/src/base.ml
@@ -124,6 +124,7 @@ module Lazy = Lazy
 module List = List
 module Map = Map
 module Maybe_bound = Maybe_bound
+module Modes = Modes
 module Monad = Monad
 module Nativeint = Nativeint
 module Nothing = Nothing
@@ -180,6 +181,7 @@ end
 module Exported_for_specific_uses = struct
   module Fieldslib = Fieldslib
   module Globalize = Globalize
+  module Obj_array = Obj_array
   module Obj_local = Obj_local
   module Ppx_compare_lib = Ppx_compare_lib
   module Ppx_enumerate_lib = Ppx_enumerate_lib
@@ -221,8 +223,8 @@ module Export = struct
     Array.sexp_of_t
   ;;
 
-  let array_sexp_grammar :
-        'a. 'a Sexplib0.Sexp_grammar.t -> 'a array Sexplib0.Sexp_grammar.t
+  let array_sexp_grammar
+    : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a array Sexplib0.Sexp_grammar.t
     =
     fun _'a_sexp_grammar -> Array.t_sexp_grammar _'a_sexp_grammar
   ;;
@@ -410,12 +412,12 @@ module Export = struct
     List.globalize
   ;;
 
-  let hash_fold_list :
-        'a.
-        (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
-        -> Ppx_hash_lib.Std.Hash.state
-        -> 'a list
-        -> Ppx_hash_lib.Std.Hash.state
+  let hash_fold_list
+    : 'a.
+    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
+    -> Ppx_hash_lib.Std.Hash.state
+    -> 'a list
+    -> Ppx_hash_lib.Std.Hash.state
     =
     List.hash_fold_t
   ;;
@@ -428,8 +430,8 @@ module Export = struct
     List.sexp_of_t
   ;;
 
-  let list_sexp_grammar :
-        'a. 'a Sexplib0.Sexp_grammar.t -> 'a list Sexplib0.Sexp_grammar.t
+  let list_sexp_grammar
+    : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a list Sexplib0.Sexp_grammar.t
     =
     fun _'a_sexp_grammar -> List.t_sexp_grammar _'a_sexp_grammar
   ;;
@@ -502,12 +504,12 @@ module Export = struct
     Option.globalize
   ;;
 
-  let hash_fold_option :
-        'a.
-        (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
-        -> Ppx_hash_lib.Std.Hash.state
-        -> 'a option
-        -> Ppx_hash_lib.Std.Hash.state
+  let hash_fold_option
+    : 'a.
+    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
+    -> Ppx_hash_lib.Std.Hash.state
+    -> 'a option
+    -> Ppx_hash_lib.Std.Hash.state
     =
     Option.hash_fold_t
   ;;
@@ -520,8 +522,8 @@ module Export = struct
     Option.sexp_of_t
   ;;
 
-  let option_sexp_grammar :
-        'a. 'a Sexplib0.Sexp_grammar.t -> 'a option Sexplib0.Sexp_grammar.t
+  let option_sexp_grammar
+    : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a option Sexplib0.Sexp_grammar.t
     =
     fun _'a_sexp_grammar -> Option.t_sexp_grammar _'a_sexp_grammar
   ;;
@@ -700,6 +702,8 @@ include Export
 
 include Container_intf.Export (** @inline *)
 
+include Modes.Export (** @inline *)
+
 exception Not_found_s = Not_found_s
 
 (* We perform these side effects here because we want them to run for any code that uses
diff --git a/src/binary_search.ml b/src/binary_search.ml
index 02a2406c..0d6b0e45 100644
--- a/src/binary_search.ml
+++ b/src/binary_search.ml
@@ -83,11 +83,9 @@ let binary_search
   =
   match how with
   | `Last_strictly_less_than ->
-    find_last_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v < 0) [@nontail
-                                                                                     ]
+    find_last_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v < 0)
   | `Last_less_than_or_equal_to ->
-    find_last_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v <= 0) [@nontail
-                                                                                      ]
+    find_last_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v <= 0)
   | `First_equal_to ->
     (match
        find_first_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v >= 0)
@@ -101,11 +99,9 @@ let binary_search
      | Some x when compare (get t x) v = 0 -> Some x
      | None | Some _ -> None)
   | `First_greater_than_or_equal_to ->
-    find_first_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v >= 0) [@nontail
-                                                                                       ]
+    find_first_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v >= 0)
   | `First_strictly_greater_than ->
-    find_first_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v > 0) [@nontail
-                                                                                      ]
+    find_first_satisfying ?pos ?len t ~get ~length ~pred:(fun x -> compare x v > 0)
 ;;
 
 let binary_search_segmented ?pos ?len t ~length ~get ~segment_of how =
@@ -116,8 +112,6 @@ let binary_search_segmented ?pos ?len t ~length ~get ~segment_of how =
   in
   let is_right x = not (is_left x) in
   match how with
-  | `Last_on_left ->
-    find_last_satisfying ?pos ?len t ~length ~get ~pred:is_left [@nontail]
-  | `First_on_right ->
-    find_first_satisfying ?pos ?len t ~length ~get ~pred:is_right [@nontail]
+  | `Last_on_left -> find_last_satisfying ?pos ?len t ~length ~get ~pred:is_left
+  | `First_on_right -> find_first_satisfying ?pos ?len t ~length ~get ~pred:is_right
 ;;
diff --git a/src/binary_searchable.ml b/src/binary_searchable.ml
index 539dfb96..3de24e65 100644
--- a/src/binary_searchable.ml
+++ b/src/binary_searchable.ml
@@ -23,16 +23,16 @@ module Make_gen (T : Arg) = struct
 end
 
 module Make (T : Indexable) = Make_gen (struct
-  include T
+    include T
 
-  type 'a elt = T.elt
-  type 'a t = T.t
-end)
+    type 'a elt = T.elt
+    type 'a t = T.t
+  end)
 
 module Make1 (T : Indexable1) = Make_gen (struct
-  type 'a elt = 'a
-  type 'a t = 'a T.t
+    type 'a elt = 'a
+    type 'a t = 'a T.t
 
-  let get = T.get
-  let length = T.length
-end)
+    let get = T.get
+    let length = T.length
+  end)
diff --git a/src/binary_searchable_intf.ml b/src/binary_searchable_intf.ml
index 581ef18c..a03f1a9c 100644
--- a/src/binary_searchable_intf.ml
+++ b/src/binary_searchable_intf.ml
@@ -40,7 +40,7 @@ module Which_target_by_key = struct
      ; `First_greater_than_or_equal_to
      ; `First_strictly_greater_than
      ]
-      : t list)
+     : t list)
   ;;
 
   [@@@end]
diff --git a/src/blit.ml b/src/blit.ml
index 78d00379..d05bf71d 100644
--- a/src/blit.ml
+++ b/src/blit.ml
@@ -8,12 +8,13 @@ module type Sequence_gen = sig
 end
 
 module Make_gen
-  (Src : Sequence_gen) (Dst : sig
-    include Sequence_gen
+    (Src : Sequence_gen)
+    (Dst : sig
+       include Sequence_gen
 
-    val create_like : len:int -> 'a Src.t -> 'a t
-    val unsafe_blit : ('a Src.t, 'a t) blit
-  end) =
+       val create_like : len:int -> 'a Src.t -> 'a t
+       val unsafe_blit : ('a Src.t, 'a t) blit
+     end) =
 struct
   let unsafe_blit = Dst.unsafe_blit
 
@@ -62,21 +63,21 @@ struct
 end
 
 module Make1 (Sequence : sig
-  include Sequence_gen
+    include Sequence_gen
 
-  val create_like : len:int -> 'a t -> 'a t
-  val unsafe_blit : ('a t, 'a t) blit
-end) =
+    val create_like : len:int -> 'a t -> 'a t
+    val unsafe_blit : ('a t, 'a t) blit
+  end) =
   Make_gen (Sequence) (Sequence)
 
 module Make1_generic (Sequence : Sequence1) = Make_gen (Sequence) (Sequence)
 
 module Make (Sequence : sig
-  include Sequence
+    include Sequence
 
-  val create : len:int -> t
-  val unsafe_blit : (t, t) blit
-end) =
+    val create : len:int -> t
+    val unsafe_blit : (t, t) blit
+  end) =
 struct
   module Sequence = struct
     type 'a t = Sequence.t
@@ -92,12 +93,13 @@ struct
 end
 
 module Make_distinct
-  (Src : Sequence) (Dst : sig
-    include Sequence
+    (Src : Sequence)
+    (Dst : sig
+       include Sequence
 
-    val create : len:int -> t
-    val unsafe_blit : (Src.t, t) blit
-  end) =
+       val create : len:int -> t
+       val unsafe_blit : (Src.t, t) blit
+     end) =
   Make_gen
     (struct
       type 'a t = Src.t
@@ -116,10 +118,11 @@ module Make_distinct
       let unsafe_blit = unsafe_blit
     end)
 
-module Make_to_string (T : sig
-  type t
-end)
-(To_bytes : S_distinct with type src := T.t with type dst := bytes) =
+module Make_to_string
+    (T : sig
+       type t
+     end)
+    (To_bytes : S_distinct with type src := T.t with type dst := bytes) =
 struct
   open To_bytes
 
diff --git a/src/blit_intf.ml b/src/blit_intf.ml
index 05690699..45161762 100644
--- a/src/blit_intf.ml
+++ b/src/blit_intf.ml
@@ -35,6 +35,20 @@ type ('src, 'dst) subo =
   -> 'src
   -> 'dst
 
+(** Like [blit], but not allowing [local_] values (on compilers supporting modes). *)
+type ('src, 'dst) blit_global =
+  src:'src -> src_pos:int -> dst:'dst -> dst_pos:int -> len:int -> unit
+
+(** Like [blito], but not allowing [local_] values (on compilers supporting modes). *)
+type ('src, 'dst) blito_global =
+  src:'src -> ?src_pos:int -> ?src_len:int -> dst:'dst -> ?dst_pos:int -> unit -> unit
+
+(** Like [sub], but not allowing [local_] values (on compilers supporting modes). *)
+type ('src, 'dst) sub_global = 'src -> pos:int -> len:int -> 'dst
+
+(** Like [subo], but not allowing [local_] values (on compilers supporting modes). *)
+type ('src, 'dst) subo_global = ?pos:int -> ?len:int -> 'src -> 'dst
+
 (*_ These are not implemented less-general-in-terms-of-more-general because odoc produces
   unreadable documentation in that case, with or without [inline] on [include]. *)
 
@@ -69,6 +83,17 @@ module type S_distinct = sig
   val subo : (src, dst) subo
 end
 
+module type S_distinct_global = sig
+  type src
+  type dst
+
+  val blit : (src, dst) blit_global
+  val blito : (src, dst) blito_global
+  val unsafe_blit : (src, dst) blit_global
+  val sub : (src, dst) sub_global
+  val subo : (src, dst) subo_global
+end
+
 module type S1_distinct = sig
   type 'a src
   type 'a dst
@@ -87,6 +112,13 @@ module type S_to_string = sig
   val subo : (t, string) subo
 end
 
+module type S_to_string_global = sig
+  type t
+
+  val sub : (t, string) sub_global
+  val subo : (t, string) subo_global
+end
+
 (** Users of modules matching the blit signatures [S], [S1], and [S1_distinct] only need
     to understand the code above.  The code below is only for those that need to implement
     modules that match those signatures. *)
@@ -115,12 +147,18 @@ module type Blit = sig
   type nonrec ('src, 'dst) blito = ('src, 'dst) blito
   type nonrec ('src, 'dst) sub = ('src, 'dst) sub
   type nonrec ('src, 'dst) subo = ('src, 'dst) subo
+  type nonrec ('src, 'dst) blit_global = ('src, 'dst) blit_global
+  type nonrec ('src, 'dst) blito_global = ('src, 'dst) blito_global
+  type nonrec ('src, 'dst) sub_global = ('src, 'dst) sub_global
+  type nonrec ('src, 'dst) subo_global = ('src, 'dst) subo_global
 
   module type S = S
   module type S1 = S1
   module type S_distinct = S_distinct
+  module type S_distinct_global = S_distinct_global
   module type S1_distinct = S1_distinct
   module type S_to_string = S_to_string
+  module type S_to_string_global = S_to_string_global
   module type Sequence = Sequence
   module type Sequence1 = Sequence1
 
@@ -143,25 +181,27 @@ module type Blit = sig
 
   (** [Make] is for blitting between two values of the same monomorphic type. *)
   module Make (Sequence : sig
-    include Sequence
-
-    val create : len:int -> t
-    val unsafe_blit : (t, t) blit
-  end) : S with type t := Sequence.t
-
-  (** [Make_distinct] is for blitting between values of distinct monomorphic types. *)
-  module Make_distinct
-    (Src : Sequence) (Dst : sig
       include Sequence
 
       val create : len:int -> t
-      val unsafe_blit : (Src.t, t) blit
-    end) : S_distinct with type src := Src.t with type dst := Dst.t
+      val unsafe_blit : (t, t) blit
+    end) : S with type t := Sequence.t
 
-  module Make_to_string (T : sig
-    type t
-  end)
-  (To_bytes : S_distinct with type src := T.t with type dst := bytes) :
+  (** [Make_distinct] is for blitting between values of distinct monomorphic types. *)
+  module Make_distinct
+      (Src : Sequence)
+      (Dst : sig
+         include Sequence
+
+         val create : len:int -> t
+         val unsafe_blit : (Src.t, t) blit
+       end) : S_distinct with type src := Src.t with type dst := Dst.t
+
+  module Make_to_string
+      (T : sig
+         type t
+       end)
+      (To_bytes : S_distinct with type src := T.t with type dst := bytes) :
     S_to_string with type t := T.t
 
   (** [Make1] is for blitting between two values of the same polymorphic type. *)
diff --git a/src/bool.ml b/src/bool.ml
index 91393bfa..8fb804a5 100644
--- a/src/bool.ml
+++ b/src/bool.ml
@@ -40,11 +40,11 @@ include T
 include Comparator.Make (T)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = "Base.Bool"
-end)
+    let to_string = to_string
+    let module_name = "Base.Bool"
+  end)
 
 (* Open replace_polymorphic_compare after including functor instantiations so they do not
    shadow its definitions. This is here so that efficient versions of the comparison
diff --git a/src/bool.mli b/src/bool.mli
index 43ed752e..47c7fea3 100644
--- a/src/bool.mli
+++ b/src/bool.mli
@@ -31,7 +31,7 @@ external select
   -> ('a[@local_opt])
   -> ('a[@local_opt])
   = "caml_csel_value"
-  [@@noalloc] [@@no_effects] [@@no_coeffects] [@@builtin]
+[@@noalloc] [@@no_effects] [@@no_coeffects] [@@builtin]
 
 module Non_short_circuiting : sig
   (** Non-short circuiting and branch-free boolean operators.
diff --git a/src/bool0.ml b/src/bool0.ml
index 0994b685..0ebd4c4c 100644
--- a/src/bool0.ml
+++ b/src/bool0.ml
@@ -4,4 +4,4 @@ external select
   -> ('a[@local_opt])
   -> ('a[@local_opt])
   = "caml_csel_value"
-  [@@noalloc] [@@no_effects] [@@no_coeffects] [@@builtin]
+[@@noalloc] [@@no_effects] [@@no_coeffects] [@@builtin]
diff --git a/src/bool0.mli b/src/bool0.mli
index 0994b685..0ebd4c4c 100644
--- a/src/bool0.mli
+++ b/src/bool0.mli
@@ -4,4 +4,4 @@ external select
   -> ('a[@local_opt])
   -> ('a[@local_opt])
   = "caml_csel_value"
-  [@@noalloc] [@@no_effects] [@@no_coeffects] [@@builtin]
+[@@noalloc] [@@no_effects] [@@no_coeffects] [@@builtin]
diff --git a/src/buffer.ml b/src/buffer.ml
index 12a85b4f..98065eea 100644
--- a/src/buffer.ml
+++ b/src/buffer.ml
@@ -1,4 +1,5 @@
 open! Import
+open Modes.Export
 include Buffer_intf
 include Stdlib.Buffer
 
@@ -6,31 +7,48 @@ let contents_bytes = to_bytes
 let add_substring t s ~pos ~len = add_substring t s pos len
 let add_subbytes t s ~pos ~len = add_subbytes t s pos len
 let sexp_of_t t = sexp_of_string (contents t)
-let caml_buffer_length = (Stdlib.Obj.magic (Stdlib.Buffer.length : t -> int) : t -> int)
-
-let caml_buffer_blit =
-  (Stdlib.Obj.magic
-     (Stdlib.Buffer.blit : Stdlib.Buffer.t -> int -> Bytes.t -> int -> int -> unit)
-    : Stdlib.Buffer.t -> int -> Bytes.t -> int -> int -> unit)
-;;
 
 module To_bytes =
   Blit.Make_distinct
     (struct
-      type nonrec t = t
+      type nonrec t = t Modes.Global.t
 
-      let length = caml_buffer_length
+      let length t = length t.global
     end)
     (struct
-      type t = Bytes.t
+      type t = Bytes.t Modes.Global.t
 
-      let create ~len = Bytes.create len
-      let length = Bytes.length
+      let create ~len = { global = Bytes.create len }
+      let length t = Bytes.length t.global
 
       let unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
-        caml_buffer_blit src src_pos dst dst_pos len
+        blit src.global src_pos dst.global dst_pos len
       ;;
     end)
 
-include To_bytes
-module To_string = Blit.Make_to_string (Stdlib.Buffer) (To_bytes)
+let blit ~src ~src_pos ~dst ~dst_pos ~len =
+  To_bytes.blit ~src:{ global = src } ~src_pos ~dst:{ global = dst } ~dst_pos ~len
+;;
+
+let blito ~src ?src_pos ?src_len ~dst ?dst_pos () =
+  To_bytes.blito ~src:{ global = src } ?src_pos ?src_len ~dst:{ global = dst } ?dst_pos ()
+;;
+
+let unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
+  To_bytes.unsafe_blit ~src:{ global = src } ~src_pos ~dst:{ global = dst } ~dst_pos ~len
+;;
+
+let sub t ~pos ~len = (To_bytes.sub { global = t } ~pos ~len).global
+let subo ?pos ?len t = (To_bytes.subo ?pos ?len { global = t }).global
+
+module To_string = struct
+  let sub t ~pos ~len =
+    let bytes = sub t ~pos ~len in
+    Bytes.unsafe_to_string ~no_mutation_while_string_reachable:bytes
+  ;;
+
+  let subo ?pos ?len t =
+    let bytes = subo ?pos ?len t in
+    Bytes.unsafe_to_string ~no_mutation_while_string_reachable:bytes
+  ;;
+end
diff --git a/src/buffer_intf.ml b/src/buffer_intf.ml
index 2818cdc4..e127bb86 100644
--- a/src/buffer_intf.ml
+++ b/src/buffer_intf.ml
@@ -79,4 +79,13 @@ module type Buffer = sig
   (** Buffers using strings as underlying storage medium: *)
 
   include S with type t = Stdlib.Buffer.t (** @open *)
+
+  (** [Buffer.t] does not support [local_], even on compilers supporting modes. *)
+
+  (** @open *)
+  include Blit.S_distinct_global with type src := t and type dst := bytes
+
+  (** For compilers supporting modes: [Buffer] does not support [To_string.sub*] for
+      local values. Other implementations of [S], such as [Core.Bigbuffer], do. *)
+  module To_string : Blit.S_to_string_global with type t := t
 end
diff --git a/src/bytes.ml b/src/bytes.ml
index 0c2e534f..0d2447f4 100644
--- a/src/bytes.ml
+++ b/src/bytes.ml
@@ -23,10 +23,10 @@ end
 include T
 
 module To_bytes = Blit.Make (struct
-  include T
+    include T
 
-  let create ~len = create len
-end)
+    let create ~len = create len
+  end)
 
 include To_bytes
 include Comparator.Make (T)
@@ -65,9 +65,17 @@ let init n ~f =
   t
 ;;
 
+let rec unsafe_set_char_list t l i =
+  match l with
+  | [] -> ()
+  | c :: l ->
+    unsafe_set t i c;
+    unsafe_set_char_list t l (i + 1)
+;;
+
 let of_char_list l =
   let t = create (List.length l) in
-  List.iteri l ~f:(fun i c -> set t i c);
+  unsafe_set_char_list t l 0;
   t
 ;;
 
@@ -80,7 +88,7 @@ let to_list t =
   loop t (length t - 1) []
 ;;
 
-let to_array t = Array.init (length t) ~f:(fun i -> unsafe_get t i)
+let to_array t = Array.init (length t) ~f:(fun i -> unsafe_get t i) [@nontail]
 let map t ~f = map t ~f
 let mapi t ~f = mapi t ~f
 
@@ -150,7 +158,7 @@ let contains ?pos ?len t char =
     Int_replace_polymorphic_compare.( < ) i last
     && (Char.equal (get t i) char || loop (i + 1))
   in
-  loop pos
+  loop pos [@nontail]
 ;;
 
 module Utf8 = struct
diff --git a/src/bytes0.ml b/src/bytes0.ml
index a9dfc6cc..abb81f47 100644
--- a/src/bytes0.ml
+++ b/src/bytes0.ml
@@ -15,6 +15,7 @@
    ocamldep from mistakenly causing a file to depend on [Base.Bytes]. *)
 
 open! Import0
+module Char = Char0
 module Uchar = Uchar0
 module Sys = Sys0
 
@@ -51,7 +52,7 @@ module Primitives = struct
     -> len:int
     -> unit
     = "caml_blit_string"
-    [@@noalloc]
+  [@@noalloc]
 
   external unsafe_get_int64
     :  (bytes[@local_opt])
@@ -99,21 +100,146 @@ let max_length = Sys.max_string_length
 let blit = Stdlib.Bytes.blit
 let blit_string = Stdlib.Bytes.blit_string
 let compare = Stdlib.Bytes.compare
-let copy = Stdlib.Bytes.copy
 let create = Stdlib.Bytes.create
-let set_uchar_utf_8 = Stdlib.Bytes.set_utf_8_uchar
-let set_uchar_utf_16le = Stdlib.Bytes.set_utf_16le_uchar
-let set_uchar_utf_16be = Stdlib.Bytes.set_utf_16be_uchar
-
-let set_utf_32_uchar ~set_int32 bytes idx uchar =
-  Uchar.to_int uchar
-  |> Int_conversions.int_to_int32_trunc (* should never have anything to truncate *)
-  |> set_int32 bytes idx;
-  4
-;;
 
-let set_uchar_utf_32le = set_utf_32_uchar ~set_int32:Stdlib.Bytes.set_int32_le
-let set_uchar_utf_32be = set_utf_32_uchar ~set_int32:Stdlib.Bytes.set_int32_be
+include struct
+  open struct
+    external unsafe_set_uint8 : bytes -> int -> int -> unit = "%bytes_unsafe_set"
+    external unsafe_set_uint16_ne : bytes -> int -> int -> unit = "%caml_bytes_set16u"
+    external set_int8 : bytes -> int -> int -> unit = "%bytes_safe_set"
+    external set_int32_ne : bytes -> int -> int32 -> unit = "%caml_bytes_set32"
+    external swap16 : int -> int = "%bswap16"
+    external swap32 : int32 -> int32 = "%bswap_int32"
+
+    let set_uint8 = set_int8
+
+    let unsafe_set_uint16_le b i x =
+      if Sys.big_endian
+      then unsafe_set_uint16_ne b i (swap16 x)
+      else unsafe_set_uint16_ne b i x
+    ;;
+
+    let unsafe_set_uint16_be b i x =
+      if Sys.big_endian
+      then unsafe_set_uint16_ne b i x
+      else unsafe_set_uint16_ne b i (swap16 x)
+    ;;
+
+    let set_int32_le b i x =
+      if Sys.big_endian then set_int32_ne b i (swap32 x) else set_int32_ne b i x
+    ;;
+
+    let set_int32_be b i x =
+      if not Sys.big_endian then set_int32_ne b i (swap32 x) else set_int32_ne b i x
+    ;;
+  end
+
+  let set_uchar_utf_8 b i u =
+    let set = unsafe_set_uint8 in
+    let max = length b - 1 in
+    match Uchar.to_int u with
+    | u when u < 0 -> assert false
+    | u when u <= 0x007F ->
+      set_uint8 b i u;
+      1
+    | u when u <= 0x07FF ->
+      let last = i + 1 in
+      if last > max
+      then 0
+      else (
+        set_uint8 b i (0xC0 lor (u lsr 6));
+        set b last (0x80 lor (u land 0x3F));
+        2)
+    | u when u <= 0xFFFF ->
+      let last = i + 2 in
+      if last > max
+      then 0
+      else (
+        set_uint8 b i (0xE0 lor (u lsr 12));
+        set b (i + 1) (0x80 lor ((u lsr 6) land 0x3F));
+        set b last (0x80 lor (u land 0x3F));
+        3)
+    | u when u <= 0x10FFFF ->
+      let last = i + 3 in
+      if last > max
+      then 0
+      else (
+        set_uint8 b i (0xF0 lor (u lsr 18));
+        set b (i + 1) (0x80 lor ((u lsr 12) land 0x3F));
+        set b (i + 2) (0x80 lor ((u lsr 6) land 0x3F));
+        set b last (0x80 lor (u land 0x3F));
+        4)
+    | _ -> assert false
+  ;;
+
+  let set_uchar_utf_16le b i u =
+    let set = unsafe_set_uint16_le in
+    let max = length b - 1 in
+    if i < 0 || i > max
+    then invalid_arg "index out of bounds"
+    else (
+      match Uchar.to_int u with
+      | u when u < 0 -> assert false
+      | u when u <= 0xFFFF ->
+        let last = i + 1 in
+        if last > max
+        then 0
+        else (
+          set b i u;
+          2)
+      | u when u <= 0x10FFFF ->
+        let last = i + 3 in
+        if last > max
+        then 0
+        else (
+          let u' = u - 0x10000 in
+          let hi = 0xD800 lor (u' lsr 10) in
+          let lo = 0xDC00 lor (u' land 0x3FF) in
+          set b i hi;
+          set b (i + 2) lo;
+          4)
+      | _ -> assert false)
+  ;;
+
+  let set_uchar_utf_16be b i u =
+    let set = unsafe_set_uint16_be in
+    let max = length b - 1 in
+    if i < 0 || i > max
+    then invalid_arg "index out of bounds"
+    else (
+      match Uchar.to_int u with
+      | u when u < 0 -> assert false
+      | u when u <= 0xFFFF ->
+        let last = i + 1 in
+        if last > max
+        then 0
+        else (
+          set b i u;
+          2)
+      | u when u <= 0x10FFFF ->
+        let last = i + 3 in
+        if last > max
+        then 0
+        else (
+          let u' = u - 0x10000 in
+          let hi = 0xD800 lor (u' lsr 10) in
+          let lo = 0xDC00 lor (u' land 0x3FF) in
+          set b i hi;
+          set b (i + 2) lo;
+          4)
+      | _ -> assert false)
+  ;;
+
+  let set_utf_32_uchar ~set_int32 bytes idx uchar =
+    Uchar.to_int uchar
+    |> Int_conversions.int_to_int32_trunc (* should never have anything to truncate *)
+    |> set_int32 bytes idx;
+    4
+  ;;
+
+  let set_uchar_utf_32le = set_utf_32_uchar ~set_int32:set_int32_le
+  let set_uchar_utf_32be = set_utf_32_uchar ~set_int32:set_int32_be
+end
 
 external unsafe_create_local : int -> bytes = "Base_unsafe_create_local_bytes" [@@noalloc]
 
@@ -122,13 +248,22 @@ let create_local len =
   unsafe_create_local len
 ;;
 
-let fill = Stdlib.Bytes.fill
+external unsafe_fill : bytes -> pos:int -> len:int -> char -> unit = "caml_fill_bytes"
+[@@noalloc]
+
+let fill t ~pos ~len c =
+  if pos < 0 || len < 0 || pos > length t - len
+  then invalid_arg "Bytes.fill"
+  else unsafe_fill t ~pos ~len c
+;;
+
 let make = Stdlib.Bytes.make
+let empty = Stdlib.Bytes.empty
 
 let map t ~(f : _ -> _) =
   let l = length t in
   if l = 0
-  then t
+  then empty
   else (
     let r = create l in
     for i = 0 to l - 1 do
@@ -140,7 +275,7 @@ let map t ~(f : _ -> _) =
 let mapi t ~(f : _ -> _ -> _) =
   let l = length t in
   if l = 0
-  then t
+  then empty
   else (
     let r = create l in
     for i = 0 to l - 1 do
@@ -159,7 +294,7 @@ external unsafe_blit
   -> len:int
   -> unit
   = "caml_blit_bytes"
-  [@@noalloc]
+[@@noalloc]
 
 let to_string = Stdlib.Bytes.to_string
 let of_string = Stdlib.Bytes.of_string
@@ -173,3 +308,10 @@ external unsafe_of_string_promise_no_mutation
   :  (string[@local_opt])
   -> (bytes[@local_opt])
   = "%bytes_of_string"
+
+let copy src =
+  let len = length src in
+  let dst = create len in
+  unsafe_blit ~src ~src_pos:0 ~dst ~dst_pos:0 ~len;
+  dst
+;;
diff --git a/src/char.ml b/src/char.ml
index 9bb893f4..510e801b 100644
--- a/src/char.ml
+++ b/src/char.ml
@@ -35,10 +35,10 @@ end
 include T
 
 include Identifiable.Make (struct
-  include T
+    include T
 
-  let module_name = "Base.Char"
-end)
+    let module_name = "Base.Char"
+  end)
 
 let pp fmt c = Stdlib.Format.fprintf fmt "%C" c
 
diff --git a/src/char.mli b/src/char.mli
index 044afab0..75d881eb 100644
--- a/src/char.mli
+++ b/src/char.mli
@@ -62,7 +62,7 @@ val is_alphanum : t -> bool
 (** ' ' - '~' *)
 val is_print : t -> bool
 
-(** ' ' or '\t' or '\r' or '\n' *)
+(** ' ' or '\t' or '\r' or '\n' or '\011' (vertical tab) or '\012' (form feed) *)
 val is_whitespace : t -> bool
 
 (** Returns [Some i] if [is_digit c] and [None] otherwise. *)
diff --git a/src/comparable.ml b/src/comparable.ml
index e55dca76..f5a17dcc 100644
--- a/src/comparable.ml
+++ b/src/comparable.ml
@@ -2,14 +2,14 @@ open! Import
 include Comparable_intf
 
 module With_zero (T : sig
-  type t [@@deriving_inline compare]
+    type t [@@deriving_inline compare]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
 
-  [@@@end]
+    [@@@end]
 
-  val zero : t
-end) =
+    val zero : t
+  end) =
 struct
   open T
 
@@ -21,12 +21,12 @@ struct
 end
 
 module Poly (T : sig
-  type t [@@deriving_inline sexp_of]
+    type t [@@deriving_inline sexp_of]
 
-  val sexp_of_t : t -> Sexplib0.Sexp.t
+    val sexp_of_t : t -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) =
+    [@@@end]
+  end) =
 struct
   module Replace_polymorphic_compare = struct
     type t = T.t [@@deriving_inline sexp_of]
@@ -41,7 +41,7 @@ struct
   include Poly
 
   let between t ~low ~high = low <= t && t <= high
-  let clamp_unchecked t ~min ~max = if t < min then min else if t <= max then t else max
+  let clamp_unchecked t ~min:min_ ~max:max_ = max min_ (min max_ t)
 
   let clamp_exn t ~min ~max =
     assert (min <= max);
@@ -72,16 +72,16 @@ let geq cmp a b = cmp a b >= 0
 let leq cmp a b = cmp a b <= 0
 let equal cmp a b = cmp a b = 0
 let not_equal cmp a b = cmp a b <> 0
-let min cmp t t' = if leq cmp t t' then t else t'
-let max cmp t t' = if geq cmp t t' then t else t'
+let min cmp t t' = Bool0.select (leq cmp t t') t t'
+let max cmp t t' = Bool0.select (geq cmp t t') t t'
 
 module Infix (T : sig
-  type t [@@deriving_inline compare]
+    type t [@@deriving_inline compare]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
 
-  [@@@end]
-end) : Infix with type t := T.t = struct
+    [@@@end]
+  end) : Infix with type t := T.t = struct
   let ( > ) a b = gt T.compare a b
   let ( < ) a b = lt T.compare a b
   let ( >= ) a b = geq T.compare a b
@@ -92,12 +92,12 @@ end
 [@@inline always]
 
 module Comparisons (T : sig
-  type t [@@deriving_inline compare]
+    type t [@@deriving_inline compare]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
 
-  [@@@end]
-end) : Comparisons with type t := T.t = struct
+    [@@@end]
+  end) : Comparisons with type t := T.t = struct
   include Infix (T)
 
   let compare = T.compare
@@ -108,14 +108,14 @@ end
 [@@inline always]
 
 module Make_using_comparator (T : sig
-  type t [@@deriving_inline sexp_of]
+    type t [@@deriving_inline sexp_of]
 
-  val sexp_of_t : t -> Sexplib0.Sexp.t
+    val sexp_of_t : t -> Sexplib0.Sexp.t
 
-  [@@@end]
+    [@@@end]
 
-  include Comparator.S with type t := t
-end) : S with type t := T.t and type comparator_witness = T.comparator_witness = struct
+    include Comparator.S with type t := t
+  end) : S with type t := T.t and type comparator_witness = T.comparator_witness = struct
   module T = struct
     include T
 
@@ -129,7 +129,7 @@ end) : S with type t := T.t and type comparator_witness = T.comparator_witness =
   let ascending = compare
   let descending t t' = compare t' t
   let between t ~low ~high = low <= t && t <= high
-  let clamp_unchecked t ~min ~max = if t < min then min else if t <= max then t else max
+  let clamp_unchecked t ~min:min_ ~max:max_ = max min_ (min max_ t)
 
   let clamp_exn t ~min ~max =
     assert (min <= max);
@@ -148,43 +148,45 @@ end) : S with type t := T.t and type comparator_witness = T.comparator_witness =
 end
 
 module Make (T : sig
-  type t [@@deriving_inline compare, sexp_of]
+    type t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
 
-  val sexp_of_t : t -> Sexplib0.Sexp.t
+    val sexp_of_t : t -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) =
+    [@@@end]
+  end) =
 Make_using_comparator [@inlined hint] (struct
-  include T
-  include Comparator.Make (T)
-end)
+    include T
+    include Comparator.Make (T)
+  end)
 
-module Inherit (C : sig
-  type t [@@deriving_inline compare]
+module Inherit
+    (C : sig
+       type t [@@deriving_inline compare]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+       include Ppx_compare_lib.Comparable.S with type t := t
 
-  [@@@end]
-end) (T : sig
-  type t [@@deriving_inline sexp_of]
+       [@@@end]
+     end)
+    (T : sig
+       type t [@@deriving_inline sexp_of]
 
-  val sexp_of_t : t -> Sexplib0.Sexp.t
+       val sexp_of_t : t -> Sexplib0.Sexp.t
 
-  [@@@end]
+       [@@@end]
 
-  val component : t -> C.t
-end) =
+       val component : t -> C.t
+     end) =
 Make (struct
-  type t = T.t [@@deriving_inline sexp_of]
+    type t = T.t [@@deriving_inline sexp_of]
 
-  let sexp_of_t = (T.sexp_of_t : t -> Sexplib0.Sexp.t)
+    let sexp_of_t = (T.sexp_of_t : t -> Sexplib0.Sexp.t)
 
-  [@@@end]
+    [@@@end]
 
-  let compare t t' = C.compare (T.component t) (T.component t')
-end)
+    let compare t t' = C.compare (T.component t) (T.component t')
+  end)
 
 (* compare [x] and [y] lexicographically using functions in the list [cmps] *)
 let lexicographic cmps x y =
diff --git a/src/comparable_intf.ml b/src/comparable_intf.ml
index 30bd0b00..2d1056e6 100644
--- a/src/comparable_intf.ml
+++ b/src/comparable_intf.ml
@@ -1,7 +1,9 @@
 open! Import
 
 module type Infix = Comparisons.Infix
+module type Infix_with_zero_alloc = Comparisons.Infix_with_zero_alloc
 module type Comparisons = Comparisons.S
+module type Comparisons_with_zero_alloc = Comparisons.S_with_zero_alloc
 
 module Sign = Sign0 (** @canonical Base.Sign *)
 
@@ -142,8 +144,10 @@ module type Comparable = sig
       ]} *)
 
   module type Infix = Infix
+  module type Infix_with_zero_alloc = Infix_with_zero_alloc
   module type S = S
   module type Comparisons = Comparisons
+  module type Comparisons_with_zero_alloc = Comparisons_with_zero_alloc
   module type With_compare = With_compare
   module type With_zero = With_zero
 
@@ -153,77 +157,79 @@ module type Comparable = sig
       without need for the [sexp_of_t] required by [Make*] (see below). *)
 
   module Infix (T : sig
-    type t [@@deriving_inline compare]
+      type t [@@deriving_inline compare]
 
-    include Ppx_compare_lib.Comparable.S with type t := t
+      include Ppx_compare_lib.Comparable.S with type t := t
 
-    [@@@end]
-  end) : Infix with type t := T.t
+      [@@@end]
+    end) : Infix with type t := T.t
 
   module Comparisons (T : sig
-    type t [@@deriving_inline compare]
+      type t [@@deriving_inline compare]
 
-    include Ppx_compare_lib.Comparable.S with type t := t
+      include Ppx_compare_lib.Comparable.S with type t := t
 
-    [@@@end]
-  end) : Comparisons with type t := T.t
+      [@@@end]
+    end) : Comparisons with type t := T.t
 
   (** Inherit comparability from a component. *)
-  module Inherit (C : sig
-    type t [@@deriving_inline compare]
+  module Inherit
+      (C : sig
+         type t [@@deriving_inline compare]
 
-    include Ppx_compare_lib.Comparable.S with type t := t
+         include Ppx_compare_lib.Comparable.S with type t := t
 
-    [@@@end]
-  end) (T : sig
-    type t [@@deriving_inline sexp_of]
+         [@@@end]
+       end)
+      (T : sig
+         type t [@@deriving_inline sexp_of]
 
-    val sexp_of_t : t -> Sexplib0.Sexp.t
+         val sexp_of_t : t -> Sexplib0.Sexp.t
 
-    [@@@end]
+         [@@@end]
 
-    val component : t -> C.t
-  end) : S with type t := T.t
+         val component : t -> C.t
+       end) : S with type t := T.t
 
   module Make (T : sig
-    type t [@@deriving_inline compare, sexp_of]
+      type t [@@deriving_inline compare, sexp_of]
 
-    include Ppx_compare_lib.Comparable.S with type t := t
+      include Ppx_compare_lib.Comparable.S with type t := t
 
-    val sexp_of_t : t -> Sexplib0.Sexp.t
+      val sexp_of_t : t -> Sexplib0.Sexp.t
 
-    [@@@end]
-  end) : S with type t := T.t
+      [@@@end]
+    end) : S with type t := T.t
 
   module Make_using_comparator (T : sig
-    type t [@@deriving_inline sexp_of]
+      type t [@@deriving_inline sexp_of]
 
-    val sexp_of_t : t -> Sexplib0.Sexp.t
+      val sexp_of_t : t -> Sexplib0.Sexp.t
 
-    [@@@end]
+      [@@@end]
 
-    include Comparator.S with type t := t
-  end) : S with type t := T.t with type comparator_witness := T.comparator_witness
+      include Comparator.S with type t := t
+    end) : S with type t := T.t with type comparator_witness := T.comparator_witness
 
   module Poly (T : sig
-    type t [@@deriving_inline sexp_of]
+      type t [@@deriving_inline sexp_of]
 
-    val sexp_of_t : t -> Sexplib0.Sexp.t
+      val sexp_of_t : t -> Sexplib0.Sexp.t
 
-    [@@@end]
-  end) : S with type t := T.t
+      [@@@end]
+    end) : S with type t := T.t
 
   module With_zero (T : sig
-    type t [@@deriving_inline compare, sexp_of]
+      type t [@@deriving_inline compare, sexp_of]
 
-    include Ppx_compare_lib.Comparable.S with type t := t
+      include Ppx_compare_lib.Comparable.S with type t := t
 
-    val sexp_of_t : t -> Sexplib0.Sexp.t
+      val sexp_of_t : t -> Sexplib0.Sexp.t
 
-    [@@@end]
+      [@@@end]
 
-    val zero : t
-  end) : sig
+      val zero : t
+    end) : sig
     include With_zero with type t := T.t
   end
 end
diff --git a/src/comparator.ml b/src/comparator.ml
index 30209876..528c20a4 100644
--- a/src/comparator.ml
+++ b/src/comparator.ml
@@ -62,14 +62,14 @@ module S_to_S1 (S : S) = struct
 end
 
 module Make (M : sig
-  type t [@@deriving_inline compare, sexp_of]
+    type t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
 
-  val sexp_of_t : t -> Sexplib0.Sexp.t
+    val sexp_of_t : t -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) =
+    [@@@end]
+  end) =
 struct
   include M
 
@@ -79,11 +79,11 @@ struct
 end
 
 module Make1 (M : sig
-  type 'a t
+    type 'a t
 
-  val compare : 'a t -> 'a t -> int
-  val sexp_of_t : 'a t -> Sexp.t
-end) =
+    val compare : 'a t -> 'a t -> int
+    val sexp_of_t : 'a t -> Sexp.t
+  end) =
 struct
   type comparator_witness
 
@@ -94,11 +94,11 @@ module Poly = struct
   type 'a t = 'a
 
   include Make1 (struct
-    type 'a t = 'a
+      type 'a t = 'a
 
-    let compare = Poly.compare
-    let sexp_of_t _ = Sexp.Atom "_"
-  end)
+      let compare = Poly.compare
+      let sexp_of_t _ = Sexp.Atom "_"
+    end)
 end
 
 module type Derived = sig
@@ -109,14 +109,14 @@ module type Derived = sig
 end
 
 module Derived (M : sig
-  type 'a t [@@deriving_inline compare, sexp_of]
+    type 'a t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
+    include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
 
-  val sexp_of_t : ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t
+    val sexp_of_t : ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) =
+    [@@@end]
+  end) =
 struct
   type !'cmp comparator_witness
 
@@ -136,18 +136,18 @@ module type Derived2 = sig
 end
 
 module Derived2 (M : sig
-  type ('a, 'b) t [@@deriving_inline compare, sexp_of]
+    type ('a, 'b) t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S2 with type ('a, 'b) t := ('a, 'b) t
+    include Ppx_compare_lib.Comparable.S2 with type ('a, 'b) t := ('a, 'b) t
 
-  val sexp_of_t
-    :  ('a -> Sexplib0.Sexp.t)
-    -> ('b -> Sexplib0.Sexp.t)
-    -> ('a, 'b) t
-    -> Sexplib0.Sexp.t
+    val sexp_of_t
+      :  ('a -> Sexplib0.Sexp.t)
+      -> ('b -> Sexplib0.Sexp.t)
+      -> ('a, 'b) t
+      -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) =
+    [@@@end]
+  end) =
 struct
   type (!'cmp_a, !'cmp_b) comparator_witness
 
@@ -168,11 +168,11 @@ module type Derived_phantom = sig
 end
 
 module Derived_phantom (M : sig
-  type ('a, 'b) t
+    type ('a, 'b) t
 
-  val compare : ('a -> 'a -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
-  val sexp_of_t : ('a -> Sexp.t) -> ('a, _) t -> Sexp.t
-end) =
+    val compare : ('a -> 'a -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
+    val sexp_of_t : ('a -> Sexp.t) -> ('a, _) t -> Sexp.t
+  end) =
 struct
   type 'cmp_a comparator_witness
 
@@ -192,17 +192,17 @@ module type Derived2_phantom = sig
 end
 
 module Derived2_phantom (M : sig
-  type ('a, 'b, 'c) t
+    type ('a, 'b, 'c) t
 
-  val compare
-    :  ('a -> 'a -> int)
-    -> ('b -> 'b -> int)
-    -> ('a, 'b, 'c) t
-    -> ('a, 'b, 'c) t
-    -> int
+    val compare
+      :  ('a -> 'a -> int)
+      -> ('b -> 'b -> int)
+      -> ('a, 'b, 'c) t
+      -> ('a, 'b, 'c) t
+      -> int
 
-  val sexp_of_t : ('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b, _) t -> Sexp.t
-end) =
+    val sexp_of_t : ('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b, _) t -> Sexp.t
+  end) =
 struct
   type (!'cmp_a, !'cmp_b) comparator_witness
 
diff --git a/src/comparator.mli b/src/comparator.mli
index a3fa35e7..007246ab 100644
--- a/src/comparator.mli
+++ b/src/comparator.mli
@@ -61,25 +61,25 @@ module S_to_S1 (S : S) :
 (** [Make] creates a [comparator] value and its phantom [comparator_witness] type for a
     nullary type. *)
 module Make (M : sig
-  type t [@@deriving_inline compare, sexp_of]
+    type t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
 
-  val sexp_of_t : t -> Sexplib0.Sexp.t
+    val sexp_of_t : t -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) : S with type t := M.t
+    [@@@end]
+  end) : S with type t := M.t
 
 (** [Make1] creates a [comparator] value and its phantom [comparator_witness] type for a
     unary type.  It takes a [compare] and [sexp_of_t] that have
     non-standard types because the [Comparator.t] type doesn't allow passing in
     additional values for the type argument. *)
 module Make1 (M : sig
-  type 'a t
+    type 'a t
 
-  val compare : 'a t -> 'a t -> int
-  val sexp_of_t : _ t -> Sexp.t
-end) : S1 with type 'a t := 'a M.t
+    val compare : 'a t -> 'a t -> int
+    val sexp_of_t : _ t -> Sexp.t
+  end) : S1 with type 'a t := 'a M.t
 
 module type Derived = sig
   type 'a t
@@ -91,14 +91,14 @@ end
 (** [Derived] creates a [comparator] function that constructs a comparator for the type
     ['a t] given a comparator for the type ['a]. *)
 module Derived (M : sig
-  type 'a t [@@deriving_inline compare, sexp_of]
+    type 'a t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
+    include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
 
-  val sexp_of_t : ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t
+    val sexp_of_t : ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) : Derived with type 'a t := 'a M.t
+    [@@@end]
+  end) : Derived with type 'a t := 'a M.t
 
 module type Derived2 = sig
   type ('a, 'b) t
@@ -113,18 +113,18 @@ end
 (** [Derived2] creates a [comparator] function that constructs a comparator for the type
     [('a, 'b) t] given comparators for the type ['a] and ['b]. *)
 module Derived2 (M : sig
-  type ('a, 'b) t [@@deriving_inline compare, sexp_of]
+    type ('a, 'b) t [@@deriving_inline compare, sexp_of]
 
-  include Ppx_compare_lib.Comparable.S2 with type ('a, 'b) t := ('a, 'b) t
+    include Ppx_compare_lib.Comparable.S2 with type ('a, 'b) t := ('a, 'b) t
 
-  val sexp_of_t
-    :  ('a -> Sexplib0.Sexp.t)
-    -> ('b -> Sexplib0.Sexp.t)
-    -> ('a, 'b) t
-    -> Sexplib0.Sexp.t
+    val sexp_of_t
+      :  ('a -> Sexplib0.Sexp.t)
+      -> ('b -> Sexplib0.Sexp.t)
+      -> ('a, 'b) t
+      -> Sexplib0.Sexp.t
 
-  [@@@end]
-end) : Derived2 with type ('a, 'b) t := ('a, 'b) M.t
+    [@@@end]
+  end) : Derived2 with type ('a, 'b) t := ('a, 'b) M.t
 
 module type Derived_phantom = sig
   type ('a, 'b) t
@@ -138,11 +138,11 @@ end
 (** [Derived_phantom] creates a [comparator] function that constructs a comparator for the
     type [('a, 'b) t] given a comparator for the type ['a]. *)
 module Derived_phantom (M : sig
-  type ('a, 'b) t
+    type ('a, 'b) t
 
-  val compare : ('a -> 'a -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
-  val sexp_of_t : ('a -> Sexp.t) -> ('a, _) t -> Sexp.t
-end) : Derived_phantom with type ('a, 'b) t := ('a, 'b) M.t
+    val compare : ('a -> 'a -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
+    val sexp_of_t : ('a -> Sexp.t) -> ('a, _) t -> Sexp.t
+  end) : Derived_phantom with type ('a, 'b) t := ('a, 'b) M.t
 
 module type Derived2_phantom = sig
   type ('a, 'b, 'c) t
@@ -157,14 +157,14 @@ end
 (** [Derived2_phantom] creates a [comparator] function that constructs a comparator for the
     type [('a, 'b, 'c) t] given a comparator for the types ['a] and ['b]. *)
 module Derived2_phantom (M : sig
-  type ('a, 'b, 'c) t
+    type ('a, 'b, 'c) t
 
-  val compare
-    :  ('a -> 'a -> int)
-    -> ('b -> 'b -> int)
-    -> ('a, 'b, 'c) t
-    -> ('a, 'b, 'c) t
-    -> int
+    val compare
+      :  ('a -> 'a -> int)
+      -> ('b -> 'b -> int)
+      -> ('a, 'b, 'c) t
+      -> ('a, 'b, 'c) t
+      -> int
 
-  val sexp_of_t : ('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b, _) t -> Sexp.t
-end) : Derived2_phantom with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
+    val sexp_of_t : ('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b, _) t -> Sexp.t
+  end) : Derived2_phantom with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
diff --git a/src/comparisons.ml b/src/comparisons.ml
index 8339f968..63d1d900 100644
--- a/src/comparisons.ml
+++ b/src/comparisons.ml
@@ -29,7 +29,7 @@ module type S = sig
   val max : t -> t -> t
 end
 
-module type S_with_local_opt = sig
+module type Infix_with_local_opt = sig
   type t
 
   external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
@@ -40,6 +40,38 @@ module type S_with_local_opt = sig
   external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
   external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
   external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+end
+
+module type S_with_local_opt = sig
+  include Infix_with_local_opt
+
   val min : t -> t -> t
   val max : t -> t -> t
+  val min_local : t -> t -> t
+  val max_local : t -> t -> t
+end
+
+module type Infix_with_zero_alloc = sig
+  type t
+
+  val ( >= ) : t -> t -> bool [@@zero_alloc]
+  val ( <= ) : t -> t -> bool [@@zero_alloc]
+  val ( = ) : t -> t -> bool [@@zero_alloc]
+  val ( > ) : t -> t -> bool [@@zero_alloc]
+  val ( < ) : t -> t -> bool [@@zero_alloc]
+  val ( <> ) : t -> t -> bool [@@zero_alloc]
+end
+
+module type S_with_zero_alloc = sig
+  include Infix_with_zero_alloc
+
+  val equal : t -> t -> bool [@@zero_alloc]
+
+  (** [compare t1 t2] returns 0 if [t1] is equal to [t2], a negative integer if [t1] is
+      less than [t2], and a positive integer if [t1] is greater than [t2]. *)
+  val compare : t -> t -> int
+  [@@zero_alloc]
+
+  val min : t -> t -> t [@@zero_alloc]
+  val max : t -> t -> t [@@zero_alloc]
 end
diff --git a/src/container.ml b/src/container.ml
index e9686881..d5053587 100644
--- a/src/container.ml
+++ b/src/container.ml
@@ -104,8 +104,8 @@ let to_array ~length ~iter c =
 
 module Make_gen (T : Make_gen_arg) :
   Generic
-    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-     and type 'a elt := 'a T.elt = struct
+  with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+   and type 'a elt := 'a T.elt = struct
   let fold = T.fold
 
   let iter =
@@ -138,29 +138,29 @@ end
 
 module Make (T : Make_arg) = struct
   include Make_gen (struct
-    include T
+      include T
 
-    type ('a, _, _) t = 'a T.t
-    type 'a elt = 'a
-  end)
+      type ('a, _, _) t = 'a T.t
+      type 'a elt = 'a
+    end)
 end
 
 module Make0 (T : Make0_arg) = struct
   include Make_gen (struct
-    include T
+      include T
 
-    type ('a, _, _) t = T.t
-    type 'a elt = T.Elt.t
-  end)
+      type ('a, _, _) t = T.t
+      type 'a elt = T.Elt.t
+    end)
 
   let mem t x = mem t x ~equal:T.Elt.equal
 end
 
 module Make_gen_with_creators (T : Make_gen_with_creators_arg) :
   Generic_with_creators
-    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-     and type 'a elt := 'a T.elt
-     and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat =
+  with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+   and type 'a elt := 'a T.elt
+   and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat =
 struct
   include Make_gen (T)
 
@@ -205,26 +205,26 @@ end
 
 module Make_with_creators (T : Make_with_creators_arg) = struct
   include Make_gen_with_creators (struct
-    include T
+      include T
 
-    type ('a, _, _) t = 'a T.t
-    type 'a elt = 'a
-    type ('a, _, _) concat = 'a T.t
+      type ('a, _, _) t = 'a T.t
+      type 'a elt = 'a
+      type ('a, _, _) concat = 'a T.t
 
-    let concat_of_array = of_array
-  end)
+      let concat_of_array = of_array
+    end)
 end
 
 module Make0_with_creators (T : Make0_with_creators_arg) = struct
   include Make_gen_with_creators (struct
-    include T
+      include T
 
-    type ('a, _, _) t = T.t
-    type 'a elt = T.Elt.t
-    type ('a, _, _) concat = 'a list
+      type ('a, _, _) t = T.t
+      type 'a elt = T.Elt.t
+      type ('a, _, _) concat = 'a list
 
-    let concat_of_array = Array.to_list
-  end)
+      let concat_of_array = Array.to_list
+    end)
 
   let mem t x = mem t x ~equal:T.Elt.equal
 end
diff --git a/src/container_intf.ml b/src/container_intf.ml
index e9ff98aa..d6cda96e 100644
--- a/src/container_intf.ml
+++ b/src/container_intf.ml
@@ -631,9 +631,9 @@ module type Make_with_creators_arg = sig
 
   include
     Make_common_with_creators_arg
-      with type ('a, _, _) t := 'a t
-       and type 'a elt := 'a
-       and type ('a, _, _) concat := 'a t
+    with type ('a, _, _) t := 'a t
+     and type 'a elt := 'a
+     and type ('a, _, _) concat := 'a t
 end
 
 module type Make0_with_creators_arg = sig
@@ -647,9 +647,9 @@ module type Make0_with_creators_arg = sig
 
   include
     Make_common_with_creators_arg
-      with type ('a, _, _) t := t
-       and type 'a elt := Elt.t
-       and type ('a, _, _) concat := 'a list
+    with type ('a, _, _) t := t
+     and type 'a elt := Elt.t
+     and type ('a, _, _) concat := 'a list
 end
 
 module type Derived = sig
@@ -758,8 +758,8 @@ module type Container = sig
 
   module Make_gen (T : Make_gen_arg) :
     Generic
-      with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-       and type 'a elt := 'a T.elt
+    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+     and type 'a elt := 'a T.elt
 
   module Make_with_creators (T : Make_with_creators_arg) :
     S1_with_creators with type 'a t := 'a T.t
@@ -769,7 +769,7 @@ module type Container = sig
 
   module Make_gen_with_creators (T : Make_gen_with_creators_arg) :
     Generic_with_creators
-      with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-       and type 'a elt := 'a T.elt
-       and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat
+    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+     and type 'a elt := 'a T.elt
+     and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat
 end
diff --git a/src/dictionary_immutable_intf.ml b/src/dictionary_immutable_intf.ml
index 755f94a7..21a148a2 100644
--- a/src/dictionary_immutable_intf.ml
+++ b/src/dictionary_immutable_intf.ml
@@ -48,110 +48,23 @@ module Definitions = struct
     (** Produces the current value, or absence thereof, for a given key. *)
     val find
       : ( ('key, 'data, 'phantom) t -> 'key key -> 'data option
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [find]. Raises if there is no value for the given key. *)
     val find_exn
       : (('key, 'data, 'phantom) t -> 'key key -> 'data, 'key, 'data, 'phantom) accessor
 
-    (** Adds a key/value pair for a key the dictionary does not contain, or reports a
-        duplicate. *)
-    val add
-      : ( ('key, 'data, 'phantom) t
-          -> key:'key key
-          -> data:'data
-          -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate ]
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Like [add]. Raises on duplicates. *)
-    val add_exn
-      : ( ('key, 'data, 'phantom) t
-          -> key:'key key
-          -> data:'data
-          -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Adds or replaces a key/value pair in the dictionary. *)
-    val set
-      : ( ('key, 'data, 'phantom) t
-          -> key:'key key
-          -> data:'data
-          -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Removes any value for the given key. *)
-    val remove
-      : ( ('key, 'data, 'phantom) t -> 'key key -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Adds, replaces, or removes the value for a given key, depending on its current
-        value or lack thereof. *)
-    val change
-      : ( ('key, 'data, 'phantom) t
-          -> 'key key
-          -> f:('data option -> 'data option)
-          -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Adds or replaces the value for a given key, depending on its current value or
-        lack thereof. *)
-    val update
-      : ( ('key, 'data, 'phantom) t
-          -> 'key key
-          -> f:('data option -> 'data)
-          -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Adds [data] to the existing key/value pair for [key]. Interprets a missing key as
-        having an empty list. *)
-    val add_multi
-      : ( ('key, 'data list, 'phantom) t
-          -> key:'key key
-          -> data:'data
-          -> ('key, 'data list, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Removes one element from the existing key/value pair for [key]. Removes the key
-        entirely if the new list is empty. *)
-    val remove_multi
-      : ( ('key, 'data list, 'phantom) t -> 'key key -> ('key, 'data list, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
     (** Produces the list associated with the corresponding key. Interprets a missing
         key as having an empty list. *)
     val find_multi
       : ( ('key, 'data list, 'phantom) t -> 'key key -> 'data list
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Combines every value in the dictionary. *)
     val fold
@@ -201,7 +114,7 @@ module Definitions = struct
     val sumi
       :  (module Container.Summable with type t = 'a)
       -> ('key, 'data, _) t
-      -> f:(key:'key -> data:'data -> 'a)
+      -> f:(key:'key key -> data:'data -> 'a)
       -> 'a
 
     (** Produces the key/value pair with the smallest key if non-empty. *)
@@ -225,6 +138,173 @@ module Definitions = struct
     (** Calls [f] for every key/value pair. *)
     val iteri : ('key, 'data, _) t -> f:(key:'key key -> data:'data -> unit) -> unit
 
+    (** Computes a sequence of differences between two dictionaries. *)
+    val symmetric_diff
+      : ( ('key, 'data, 'phantom) t
+          -> ('key, 'data, 'phantom) t
+          -> data_equal:('data -> 'data -> bool)
+          -> ('key key * [ `Left of 'data | `Right of 'data | `Unequal of 'data * 'data ])
+               Sequence.t
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
+
+    (** Folds over the result of [symmetric_diff]. May be more performant. *)
+    val fold_symmetric_diff
+      : ( ('key, 'data, 'phantom) t
+          -> ('key, 'data, 'phantom) t
+          -> data_equal:('data -> 'data -> bool)
+          -> init:'acc
+          -> f:
+               ('acc
+                -> 'key key
+                   * [ `Left of 'data | `Right of 'data | `Unequal of 'data * 'data ]
+                -> 'acc)
+          -> 'acc
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
+  end
+
+  module type Accessors1 = sig
+    type key
+    type 'data t
+
+    (** @inline *)
+    include
+      Accessors
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) accessor := 'fn
+  end
+
+  module type Accessors2 = sig
+    type ('key, 'data) t
+    type ('fn, 'key, 'data) accessor
+
+    (** @inline *)
+    include
+      Accessors
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+  end
+
+  module type Accessors3 = sig
+    type ('key, 'data, 'phantom) t
+    type ('fn, 'key, 'data, 'phantom) accessor
+
+    (** @inline *)
+    include
+      Accessors
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) accessor :=
+        ('fn, 'key, 'data, 'phantom) accessor
+  end
+
+  module type Transformers = sig
+    (** The type of keys. This will be ['key] for polymorphic dictionaries, or some fixed
+        type for dictionaries with monomorphic keys. *)
+    type 'key key
+
+    (** Dictionaries. Their keys have type ['key key]. Each key's associated value has
+        type ['data]. The dictionary may be distinguished by a ['phantom] type. *)
+    type ('key, 'data, 'phantom) t
+
+    (** Transformer functions ['fn] that operate on [('key, 'data, 'phantom) t]. May take
+        extra arguments before ['fn], such as a comparison function. *)
+    type ('fn, 'key, 'data, 'phantom) transformer
+
+    (** Adds a key/value pair for a key the dictionary does not contain, or reports a
+        duplicate. *)
+    val add
+      : ( ('key, 'data, 'phantom) t
+          -> key:'key key
+          -> data:'data
+          -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate ]
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Like [add]. Raises on duplicates. *)
+    val add_exn
+      : ( ('key, 'data, 'phantom) t
+          -> key:'key key
+          -> data:'data
+          -> ('key, 'data, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Adds or replaces a key/value pair in the dictionary. *)
+    val set
+      : ( ('key, 'data, 'phantom) t
+          -> key:'key key
+          -> data:'data
+          -> ('key, 'data, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Removes any value for the given key. *)
+    val remove
+      : ( ('key, 'data, 'phantom) t -> 'key key -> ('key, 'data, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Adds, replaces, or removes the value for a given key, depending on its current
+        value or lack thereof. *)
+    val change
+      : ( ('key, 'data, 'phantom) t
+          -> 'key key
+          -> f:('data option -> 'data option)
+          -> ('key, 'data, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Adds or replaces the value for a given key, depending on its current value or
+        lack thereof. *)
+    val update
+      : ( ('key, 'data, 'phantom) t
+          -> 'key key
+          -> f:('data option -> 'data)
+          -> ('key, 'data, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Adds [data] to the existing key/value pair for [key]. Interprets a missing key as
+        having an empty list. *)
+    val add_multi
+      : ( ('key, 'data list, 'phantom) t
+          -> key:'key key
+          -> data:'data
+          -> ('key, 'data list, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
+    (** Removes one element from the existing key/value pair for [key]. Removes the key
+        entirely if the new list is empty. *)
+    val remove_multi
+      : ( ('key, 'data list, 'phantom) t -> 'key key -> ('key, 'data list, 'phantom) t
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
+
     (** Transforms every value. *)
     val map
       :  ('key, 'data1, 'phantom) t
@@ -297,10 +377,10 @@ module Definitions = struct
         dictionary of all [Ok] values if none are [Error]. *)
     val combine_errors
       : ( ('key, 'data Or_error.t, 'phantom) t -> ('key, 'data, 'phantom) t Or_error.t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
 
     (** Splits the [fst] and [snd] components of values associated with keys into separate
         dictionaries. *)
@@ -319,10 +399,10 @@ module Definitions = struct
                 -> [ `Left of 'data1 | `Right of 'data2 | `Both of 'data1 * 'data2 ]
                 -> 'data3 option)
           -> ('key, 'data3, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
 
     (** Merges two dictionaries with the same type of data and disjoint sets of keys.
         Raises if any keys overlap. *)
@@ -330,10 +410,10 @@ module Definitions = struct
       : ( ('key, 'data, 'phantom) t
           -> ('key, 'data, 'phantom) t
           -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
 
     (** Merges two dictionaries by traversing only the smaller of the two. Adds key/value
         pairs missing from the larger dictionary, and [combine]s duplicate values. *)
@@ -342,76 +422,47 @@ module Definitions = struct
           -> ('key, 'data, 'phantom) t
           -> combine:(key:'key key -> 'data -> 'data -> 'data)
           -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Computes a sequence of differences between two dictionaries. *)
-    val symmetric_diff
-      : ( ('key, 'data, 'phantom) t
-          -> ('key, 'data, 'phantom) t
-          -> data_equal:('data -> 'data -> bool)
-          -> ('key key * [ `Left of 'data | `Right of 'data | `Unequal of 'data * 'data ])
-             Sequence.t
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
-
-    (** Folds over the result of [symmetric_diff]. May be more performant. *)
-    val fold_symmetric_diff
-      : ( ('key, 'data, 'phantom) t
-          -> ('key, 'data, 'phantom) t
-          -> data_equal:('data -> 'data -> bool)
-          -> init:'acc
-          -> f:
-               ('acc
-                -> 'key key
-                   * [ `Left of 'data | `Right of 'data | `Unequal of 'data * 'data ]
-                -> 'acc)
-          -> 'acc
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          transformer
   end
 
-  module type Accessors1 = sig
+  module type Transformers1 = sig
     type key
     type 'data t
 
     (** @inline *)
     include
-      Accessors
-        with type (_, 'data, _) t := 'data t
-         and type _ key := key
-         and type ('fn, _, _, _) accessor := 'fn
+      Transformers
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) transformer := 'fn
   end
 
-  module type Accessors2 = sig
+  module type Transformers2 = sig
     type ('key, 'data) t
-    type ('fn, 'key, 'data) accessor
+    type ('fn, 'key, 'data) transformer
 
     (** @inline *)
     include
-      Accessors
-        with type ('key, 'data, _) t := ('key, 'data) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+      Transformers
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) transformer := ('fn, 'key, 'data) transformer
   end
 
-  module type Accessors3 = sig
+  module type Transformers3 = sig
     type ('key, 'data, 'phantom) t
-    type ('fn, 'key, 'data, 'phantom) accessor
+    type ('fn, 'key, 'data, 'phantom) transformer
 
     (** @inline *)
     include
-      Accessors
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, 'phantom) accessor :=
-          ('fn, 'key, 'data, 'phantom) accessor
+      Transformers
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) transformer :=
+        ('fn, 'key, 'data, 'phantom) transformer
   end
 
   module type Creators = sig
@@ -439,34 +490,34 @@ module Definitions = struct
     val of_alist
       : ( ('key key * 'data) list
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_key of 'key key ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Returns a [Result.t]. *)
     val of_alist_or_error
       : ( ('key key * 'data) list -> ('key, 'data, 'phantom) t Or_error.t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Raises on duplicates. *)
     val of_alist_exn
       : ( ('key key * 'data) list -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Produces a dictionary mapping each key to a list of associated values. *)
     val of_alist_multi
       : ( ('key key * 'data) list -> ('key, 'data list, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Produces a dictionary using each key/value pair. Combines all values for a given
         key with [init] using [f]. *)
@@ -475,10 +526,10 @@ module Definitions = struct
           -> init:'acc
           -> f:('acc -> 'data -> 'acc)
           -> ('key, 'acc, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Produces a dictionary using each key/value pair. Combines multiple values for a
         given key using [f]. *)
@@ -486,43 +537,43 @@ module Definitions = struct
       : ( ('key key * 'data) list
           -> f:('data -> 'data -> 'data)
           -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Consumes a sequence. *)
     val of_sequence
       : ( ('key key * 'data) Sequence.t
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_key of 'key key ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_or_error]. Consumes a sequence. *)
     val of_sequence_or_error
       : ( ('key key * 'data) Sequence.t -> ('key, 'data, 'phantom) t Or_error.t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_exn]. Consumes a sequence. *)
     val of_sequence_exn
       : ( ('key key * 'data) Sequence.t -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_multi]. Consumes a sequence. *)
     val of_sequence_multi
       : ( ('key key * 'data) Sequence.t -> ('key, 'data list, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_fold]. Consumes a sequence. *)
     val of_sequence_fold
@@ -530,73 +581,73 @@ module Definitions = struct
           -> init:'c
           -> f:('c -> 'data -> 'c)
           -> ('key, 'c, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_reduce]. Consumes a sequence. *)
     val of_sequence_reduce
       : ( ('key key * 'data) Sequence.t
           -> f:('data -> 'data -> 'data)
           -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Consume values for which keys can be computed. *)
     val of_list_with_key
       : ( 'data list
           -> get_key:('data -> 'key key)
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_key of 'key key ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_or_error]. Consume values for which keys can be computed. *)
     val of_list_with_key_or_error
       : ( 'data list -> get_key:('data -> 'key key) -> ('key, 'data, 'phantom) t Or_error.t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_exn]. Consume values for which keys can be computed. *)
     val of_list_with_key_exn
       : ( 'data list -> get_key:('data -> 'key key) -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_multi]. Consume values for which keys can be computed. *)
     val of_list_with_key_multi
       : ( 'data list -> get_key:('data -> 'key key) -> ('key, 'data list, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Produces a dictionary of all key/value pairs that [iteri] passes to [~f]. Fails if
         a duplicate key is found. *)
     val of_iteri
       : ( iteri:(f:(key:'key key -> data:'data -> unit) -> unit)
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_key of 'key key ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_iteri]. Raises on duplicate key. *)
     val of_iteri_exn
       : ( iteri:(f:(key:'key key -> data:'data -> unit) -> unit)
           -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
   end
 
   module type Creators1 = sig
@@ -606,9 +657,9 @@ module Definitions = struct
     (** @inline *)
     include
       Creators
-        with type (_, 'data, _) t := 'data t
-         and type _ key := key
-         and type ('fn, _, _, _) creator := 'fn
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) creator := 'fn
   end
 
   module type Creators2 = sig
@@ -618,9 +669,9 @@ module Definitions = struct
     (** @inline *)
     include
       Creators
-        with type ('key, 'data, _) t := ('key, 'data) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
   end
 
   module type Creators3 = sig
@@ -630,10 +681,10 @@ module Definitions = struct
     (** @inline *)
     include
       Creators
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, 'phantom) creator :=
-          ('fn, 'key, 'data, 'phantom) creator
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) creator :=
+        ('fn, 'key, 'data, 'phantom) creator
   end
 
   module type S = sig
@@ -645,18 +696,26 @@ module Definitions = struct
     (** @inline *)
     include
       Accessors
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key key
-         and type ('fn, 'key, 'data, 'phantom) accessor :=
-          ('fn, 'key, 'data, 'phantom) accessor
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key key
+       and type ('fn, 'key, 'data, 'phantom) accessor :=
+        ('fn, 'key, 'data, 'phantom) accessor
+
+    (** @inline *)
+    include
+      Transformers
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key key
+       and type ('fn, 'key, 'data, 'phantom) transformer :=
+        ('fn, 'key, 'data, 'phantom) accessor
 
     (** @inline *)
     include
       Creators
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key key
-         and type ('fn, 'key, 'data, 'phantom) creator :=
-          ('fn, 'key, 'data, 'phantom) creator
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key key
+       and type ('fn, 'key, 'data, 'phantom) creator :=
+        ('fn, 'key, 'data, 'phantom) creator
   end
 
   module type S1 = sig
@@ -666,10 +725,10 @@ module Definitions = struct
     (** @inline *)
     include
       S
-        with type (_, 'data, _) t := 'data t
-         and type _ key := key
-         and type ('fn, _, _, _) accessor := 'fn
-         and type ('fn, _, _, _) creator := 'fn
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) accessor := 'fn
+       and type ('fn, _, _, _) creator := 'fn
   end
 
   module type S2 = sig
@@ -680,10 +739,10 @@ module Definitions = struct
     (** @inline *)
     include
       S
-        with type ('key, 'data, _) t := ('key, 'data) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
-         and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+       and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
   end
 
   module type S3 = sig
@@ -694,12 +753,12 @@ module Definitions = struct
     (** @inline *)
     include
       S
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, 'phantom) accessor :=
-          ('fn, 'key, 'data, 'phantom) accessor
-         and type ('fn, 'key, 'data, 'phantom) creator :=
-          ('fn, 'key, 'data, 'phantom) creator
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) accessor :=
+        ('fn, 'key, 'data, 'phantom) accessor
+       and type ('fn, 'key, 'data, 'phantom) creator :=
+        ('fn, 'key, 'data, 'phantom) creator
   end
 end
 
diff --git a/src/dictionary_mutable_intf.ml b/src/dictionary_mutable_intf.ml
index f37eb283..eb7375ae 100644
--- a/src/dictionary_mutable_intf.ml
+++ b/src/dictionary_mutable_intf.ml
@@ -59,10 +59,10 @@ module Definitions = struct
     (** Produces the current value, or absence thereof, for a given key. *)
     val find
       : ( ('key, 'data, 'phantom) t -> 'key key -> 'data option
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [find]. Raises if there is no value for the given key. *)
     val find_exn
@@ -71,18 +71,18 @@ module Definitions = struct
     (** Like [find]. Adds the value [default ()] if none exists, then returns it. *)
     val find_or_add
       : ( ('key, 'data, 'phantom) t -> 'key key -> default:(unit -> 'data) -> 'data
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [find]. Adds [default key] if no value exists. *)
     val findi_or_add
       : ( ('key, 'data, 'phantom) t -> 'key key -> default:('key key -> 'data) -> 'data
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [find]. Calls [if_found data] if a value exists, or [if_not_found key]
         otherwise. Avoids allocation [Some]. *)
@@ -92,10 +92,10 @@ module Definitions = struct
           -> if_found:('data -> 'c)
           -> if_not_found:('key key -> 'c)
           -> 'c
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [findi]. Calls [if_found ~key ~data] if a value exists. *)
     val findi_and_call
@@ -104,44 +104,44 @@ module Definitions = struct
           -> if_found:(key:'key key -> data:'data -> 'c)
           -> if_not_found:('key key -> 'c)
           -> 'c
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [find]. Removes the value for [key], if any, from the dictionary before
         returning it. *)
     val find_and_remove
       : ( ('key, 'data, 'phantom) t -> 'key key -> 'data option
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Adds a key/value pair for a key the dictionary does not contain, or reports a
         duplicate. *)
     val add
       : ( ('key, 'data, 'phantom) t -> key:'key key -> data:'data -> [ `Ok | `Duplicate ]
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [add]. Raises on duplicates. *)
     val add_exn
       : ( ('key, 'data, 'phantom) t -> key:'key key -> data:'data -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Adds or replaces a key/value pair in the dictionary. *)
     val set
       : ( ('key, 'data, 'phantom) t -> key:'key key -> data:'data -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Removes any value for the given key. *)
     val remove
@@ -151,19 +151,19 @@ module Definitions = struct
         value or lack thereof. *)
     val change
       : ( ('key, 'data, 'phantom) t -> 'key key -> f:('data option -> 'data option) -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Adds or replaces the value for a given key, depending on its current value or
         lack thereof. *)
     val update
       : ( ('key, 'data, 'phantom) t -> 'key key -> f:('data option -> 'data) -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Like [update]. Returns the new value. *)
     val update_and_return
@@ -180,10 +180,10 @@ module Definitions = struct
           -> ('key, int, 'phantom) t
           -> 'key key
           -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Subtracts [by] from the value for [key], default 0 if [key] is absent. May remove
         [key] if the result is [0], depending on [remove_if_zero]. *)
@@ -193,19 +193,19 @@ module Definitions = struct
           -> ('key, int, 'phantom) t
           -> 'key key
           -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Adds [data] to the existing key/value pair for [key]. Interprets a missing key as
         having an empty list. *)
     val add_multi
       : ( ('key, 'data list, 'phantom) t -> key:'key key -> data:'data -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Removes one element from the existing key/value pair for [key]. Removes the key
         entirely if the new list is empty. *)
@@ -216,10 +216,10 @@ module Definitions = struct
         key as having an empty list. *)
     val find_multi
       : ( ('key, 'data list, 'phantom) t -> 'key key -> 'data list
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
 
     (** Combines every value in the dictionary. *)
     val fold
@@ -390,10 +390,10 @@ module Definitions = struct
                 -> [ `Left of 'data1 | `Right of 'data2 | `Both of 'data1 * 'data2 ]
                 -> 'data3 option)
           -> ('key, 'data3, 'phantom) t
-        , 'key
-        , 'data3
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data3
+          , 'phantom )
+          accessor
 
     (** Merges two dictionaries by traversing [src] and adding to [dst]. Computes the
         effect on [dst] of each key/value pair in [src] using [f]. *)
@@ -402,10 +402,10 @@ module Definitions = struct
           -> dst:('key, 'data2, 'phantom) t
           -> f:(key:'key key -> 'data1 -> 'data2 option -> 'data2 Merge_into_action.t)
           -> unit
-        , 'key
-        , 'data
-        , 'phantom )
-        accessor
+          , 'key
+          , 'data
+          , 'phantom )
+          accessor
   end
 
   module type Accessors1 = sig
@@ -414,9 +414,9 @@ module Definitions = struct
 
     include
       Accessors
-        with type (_, 'data, _) t := 'data t
-         and type _ key := key
-         and type ('fn, _, _, _) accessor := 'fn
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) accessor := 'fn
   end
 
   module type Accessors2 = sig
@@ -425,9 +425,9 @@ module Definitions = struct
 
     include
       Accessors
-        with type ('key, 'data, _) t := ('key, 'data) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
   end
 
   module type Accessors3 = sig
@@ -436,10 +436,10 @@ module Definitions = struct
 
     include
       Accessors
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, 'phantom) accessor :=
-          ('fn, 'key, 'data, 'phantom) accessor
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) accessor :=
+        ('fn, 'key, 'data, 'phantom) accessor
   end
 
   module type Creators = sig
@@ -463,44 +463,44 @@ module Definitions = struct
     val of_alist
       : ( ('key key * 'data) list
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_key of 'key key ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. On failure, provides all duplicate keys instead of a single
         representative. *)
     val of_alist_report_all_dups
       : ( ('key key * 'data) list
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_keys of 'key key list ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Returns a [Result.t]. *)
     val of_alist_or_error
       : ( ('key key * 'data) list -> ('key, 'data, 'phantom) t Or_error.t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Raises on duplicates. *)
     val of_alist_exn
       : ( ('key key * 'data) list -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Produces a dictionary mapping each key to a list of associated values. *)
     val of_alist_multi
       : ( ('key key * 'data) list -> ('key, 'data list, 'phantom) t
-        , 'key
-        , 'data list
-        , 'phantom )
-        creator
+          , 'key
+          , 'data list
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Consume a list of elements for which key/value pairs can be
         computed. *)
@@ -509,36 +509,36 @@ module Definitions = struct
           -> get_data:('a -> 'data)
           -> 'a list
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_keys of 'key key list ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist]. Consume values for which keys can be computed. *)
     val create_with_key
       : ( get_key:('data -> 'key key)
           -> 'data list
           -> [ `Ok of ('key, 'data, 'phantom) t | `Duplicate_keys of 'key key list ]
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_or_error]. Consume values for which keys can be computed. *)
     val create_with_key_or_error
       : ( get_key:('data -> 'key key) -> 'data list -> ('key, 'data, 'phantom) t Or_error.t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [of_alist_exn]. Consume values for which keys can be computed. *)
     val create_with_key_exn
       : ( get_key:('data -> 'key key) -> 'data list -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
 
     (** Like [create_mapped]. Multiple values for a key are [combine]d rather than
         producing an error. *)
@@ -548,10 +548,10 @@ module Definitions = struct
           -> combine:('data -> 'data -> 'data)
           -> 'a list
           -> ('key, 'data, 'phantom) t
-        , 'key
-        , 'data
-        , 'phantom )
-        creator
+          , 'key
+          , 'data
+          , 'phantom )
+          creator
   end
 
   module type Creators1 = sig
@@ -561,9 +561,9 @@ module Definitions = struct
     (** @inline *)
     include
       Creators
-        with type (_, 'data, _) t := 'data t
-         and type _ key := key
-         and type ('fn, _, _, _) creator := 'fn
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) creator := 'fn
   end
 
   module type Creators2 = sig
@@ -573,9 +573,9 @@ module Definitions = struct
     (** @inline *)
     include
       Creators
-        with type ('key, 'data, _) t := ('key, 'data) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
   end
 
   module type Creators3 = sig
@@ -585,10 +585,10 @@ module Definitions = struct
     (** @inline *)
     include
       Creators
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, 'phantom) creator :=
-          ('fn, 'key, 'data, 'phantom) creator
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) creator :=
+        ('fn, 'key, 'data, 'phantom) creator
   end
 
   module type S = sig
@@ -600,18 +600,18 @@ module Definitions = struct
     (** @inline *)
     include
       Accessors
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key key
-         and type ('fn, 'key, 'data, 'phantom) accessor :=
-          ('fn, 'key, 'data, 'phantom) accessor
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key key
+       and type ('fn, 'key, 'data, 'phantom) accessor :=
+        ('fn, 'key, 'data, 'phantom) accessor
 
     (** @inline *)
     include
       Creators
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key key
-         and type ('fn, 'key, 'data, 'phantom) creator :=
-          ('fn, 'key, 'data, 'phantom) creator
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key key
+       and type ('fn, 'key, 'data, 'phantom) creator :=
+        ('fn, 'key, 'data, 'phantom) creator
   end
 
   module type S1 = sig
@@ -621,10 +621,10 @@ module Definitions = struct
     (** @inline *)
     include
       S
-        with type (_, 'data, _) t := 'data t
-         and type _ key := key
-         and type ('fn, _, _, _) accessor := 'fn
-         and type ('fn, _, _, _) creator := 'fn
+      with type (_, 'data, _) t := 'data t
+       and type _ key := key
+       and type ('fn, _, _, _) accessor := 'fn
+       and type ('fn, _, _, _) creator := 'fn
   end
 
   module type S2 = sig
@@ -635,10 +635,10 @@ module Definitions = struct
     (** @inline *)
     include
       S
-        with type ('key, 'data, _) t := ('key, 'data) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
-         and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
+      with type ('key, 'data, _) t := ('key, 'data) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+       and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
   end
 
   module type S3 = sig
@@ -649,12 +649,12 @@ module Definitions = struct
     (** @inline *)
     include
       S
-        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-         and type 'key key := 'key
-         and type ('fn, 'key, 'data, 'phantom) accessor :=
-          ('fn, 'key, 'data, 'phantom) accessor
-         and type ('fn, 'key, 'data, 'phantom) creator :=
-          ('fn, 'key, 'data, 'phantom) creator
+      with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+       and type 'key key := 'key
+       and type ('fn, 'key, 'data, 'phantom) accessor :=
+        ('fn, 'key, 'data, 'phantom) accessor
+       and type ('fn, 'key, 'data, 'phantom) creator :=
+        ('fn, 'key, 'data, 'phantom) creator
   end
 end
 
diff --git a/src/dune b/src/dune
index 489530d7..894e0967 100644
--- a/src/dune
+++ b/src/dune
@@ -16,7 +16,8 @@
 (library
  (foreign_stubs
   (language c)
-  (names bytes_stubs exn_stubs int_math_stubs hash_stubs obj_stubs am_testing)
+  (names bytes_stubs exn_stubs float_stubs int_math_stubs hash_stubs
+    obj_stubs am_testing)
   (flags
    :standard
    -D_LARGEFILE64_SOURCE
@@ -30,8 +31,8 @@
    ocaml_intrinsics_kernel)
  (preprocess no_preprocessing)
  (lint
-  (pps ppx_base ppx_base_lint -check-doc-comments -type-conv-keep-w32=both
-    -apply=js_style,base_lint,type_conv,cold))
+  (pps ppx_base ppx_base_internal ppx_base_lint -check-doc-comments
+    -type-conv-keep-w32=both -apply=js_style,base_lint,deriving))
  (js_of_ocaml
   (javascript_files runtime.js)))
 
diff --git a/src/either.ml b/src/either.ml
index dc959784..0ee7ce17 100644
--- a/src/either.ml
+++ b/src/either.ml
@@ -63,21 +63,21 @@ module Focus = struct
 end
 
 module Make_focused (M : sig
-  type (+'a, +'b) t
+    type (+'a, +'b) t
 
-  val return : 'a -> ('a, _) t
-  val other : 'b -> (_, 'b) t
-  val focus : ('a, 'b) t -> ('a, 'b) Focus.t
+    val return : 'a -> ('a, _) t
+    val other : 'b -> (_, 'b) t
+    val focus : ('a, 'b) t -> ('a, 'b) Focus.t
 
-  val combine
-    :  ('a, 'd) t
-    -> ('b, 'd) t
-    -> f:('a -> 'b -> 'c)
-    -> other:('d -> 'd -> 'd)
-    -> ('c, 'd) t
+    val combine
+      :  ('a, 'd) t
+      -> ('b, 'd) t
+      -> f:('a -> 'b -> 'c)
+      -> other:('d -> 'd -> 'd)
+      -> ('c, 'd) t
 
-  val bind : ('a, 'b) t -> f:('a -> ('c, 'b) t) -> ('c, 'b) t
-end) =
+    val bind : ('a, 'b) t -> f:('a -> ('c, 'b) t) -> ('c, 'b) t
+  end) =
 struct
   include M
   open With_return
@@ -88,24 +88,24 @@ struct
   ;;
 
   include Monad.Make2_local (struct
-    type nonrec ('a, 'b) t = ('a, 'b) t
+      type nonrec ('a, 'b) t = ('a, 'b) t
 
-    let return = return
-    let bind = bind
-    let map = `Custom map
-  end)
+      let return = return
+      let bind = bind
+      let map = `Custom map
+    end)
 
   module App = Applicative.Make2_using_map2_local (struct
-    type nonrec ('a, 'b) t = ('a, 'b) t
+      type nonrec ('a, 'b) t = ('a, 'b) t
 
-    let return = return
-    let map = `Custom map
+      let return = return
+      let map = `Custom map
 
-    let map2 : ('a, 'x) t -> ('b, 'x) t -> f:('a -> 'b -> 'c) -> ('c, 'x) t =
-      fun t1 t2 ~f ->
-      bind t1 ~f:(fun x -> bind t2 ~f:(fun y -> return (f x y)) [@nontail]) [@nontail]
-    ;;
-  end)
+      let map2 : ('a, 'x) t -> ('b, 'x) t -> f:('a -> 'b -> 'c) -> ('c, 'x) t =
+        fun t1 t2 ~f ->
+        bind t1 ~f:(fun x -> bind t2 ~f:(fun y -> return (f x y)) [@nontail]) [@nontail]
+      ;;
+    end)
 
   include App
 
@@ -163,58 +163,58 @@ struct
 end
 
 module First = Make_focused (struct
-  type nonrec ('a, 'b) t = ('a, 'b) t
+    type nonrec ('a, 'b) t = ('a, 'b) t
 
-  let return = first
-  let other = second
+    let return = first
+    let other = second
 
-  let focus t : _ Focus.t =
-    match t with
-    | First x -> Focus { value = x }
-    | Second y -> Other { value = y }
-  ;;
+    let focus t : _ Focus.t =
+      match t with
+      | First x -> Focus { value = x }
+      | Second y -> Other { value = y }
+    ;;
 
-  let combine t1 t2 ~f ~other =
-    match t1, t2 with
-    | First x, First y -> First (f x y)
-    | Second x, Second y -> Second (other x y)
-    | Second x, _ | _, Second x -> Second x
-  ;;
+    let combine t1 t2 ~f ~other =
+      match t1, t2 with
+      | First x, First y -> First (f x y)
+      | Second x, Second y -> Second (other x y)
+      | Second x, _ | _, Second x -> Second x
+    ;;
 
-  let bind t ~f =
-    match t with
-    | First x -> f x
-    (* Reuse the value in order to avoid allocation. *)
-    | Second _ as y -> y
-  ;;
-end)
+    let bind t ~f =
+      match t with
+      | First x -> f x
+      (* Reuse the value in order to avoid allocation. *)
+      | Second _ as y -> y
+    ;;
+  end)
 
 module Second = Make_focused (struct
-  type nonrec ('a, 'b) t = ('b, 'a) t
+    type nonrec ('a, 'b) t = ('b, 'a) t
 
-  let return = second
-  let other = first
+    let return = second
+    let other = first
 
-  let focus t : _ Focus.t =
-    match t with
-    | Second x -> Focus { value = x }
-    | First y -> Other { value = y }
-  ;;
+    let focus t : _ Focus.t =
+      match t with
+      | Second x -> Focus { value = x }
+      | First y -> Other { value = y }
+    ;;
 
-  let combine t1 t2 ~f ~other =
-    match t1, t2 with
-    | Second x, Second y -> Second (f x y)
-    | First x, First y -> First (other x y)
-    | First x, _ | _, First x -> First x
-  ;;
+    let combine t1 t2 ~f ~other =
+      match t1, t2 with
+      | Second x, Second y -> Second (f x y)
+      | First x, First y -> First (other x y)
+      | First x, _ | _, First x -> First x
+    ;;
 
-  let bind t ~f =
-    match t with
-    | Second x -> f x
-    (* Reuse the value in order to avoid allocation, like [First.bind] above. *)
-    | First _ as y -> y
-  ;;
-end)
+    let bind t ~f =
+      match t with
+      | Second x -> f x
+      (* Reuse the value in order to avoid allocation, like [First.bind] above. *)
+      | First _ as y -> y
+    ;;
+  end)
 
 module Export = struct
   type ('f, 's) _either = ('f, 's) t =
diff --git a/src/either0.ml b/src/either0.ml
index 3efd97b9..746e2fa1 100644
--- a/src/either0.ml
+++ b/src/either0.ml
@@ -5,8 +5,8 @@ type ('f, 's) t =
   | Second of 's
 [@@deriving_inline compare ~localize, hash, sexp, sexp_grammar]
 
-let compare__local :
-      'f 's. ('f -> 'f -> int) -> ('s -> 's -> int) -> ('f, 's) t -> ('f, 's) t -> int
+let compare__local
+  : 'f 's. ('f -> 'f -> int) -> ('s -> 's -> int) -> ('f, 's) t -> ('f, 's) t -> int
   =
   fun _cmp__f _cmp__s a__007_ b__008_ ->
   if Stdlib.( == ) a__007_ b__008_
@@ -19,8 +19,8 @@ let compare__local :
     | Second _a__011_, Second _b__012_ -> _cmp__s _a__011_ _b__012_)
 ;;
 
-let compare :
-      'f 's. ('f -> 'f -> int) -> ('s -> 's -> int) -> ('f, 's) t -> ('f, 's) t -> int
+let compare
+  : 'f 's. ('f -> 'f -> int) -> ('s -> 's -> int) -> ('f, 's) t -> ('f, 's) t -> int
   =
   fun _cmp__f _cmp__s a__001_ b__002_ ->
   if Stdlib.( == ) a__001_ b__002_
@@ -53,9 +53,9 @@ let hash_fold_t
     _hash_fold_s hsv _a0
 ;;
 
-let t_of_sexp :
-      'f 's.
-      (Sexplib0.Sexp.t -> 'f) -> (Sexplib0.Sexp.t -> 's) -> Sexplib0.Sexp.t -> ('f, 's) t
+let t_of_sexp
+  : 'f 's.
+  (Sexplib0.Sexp.t -> 'f) -> (Sexplib0.Sexp.t -> 's) -> Sexplib0.Sexp.t -> ('f, 's) t
   =
   fun (type f__029_ s__030_)
     :  ((Sexplib0.Sexp.t -> f__029_) -> (Sexplib0.Sexp.t -> s__030_) -> Sexplib0.Sexp.t
@@ -94,12 +94,16 @@ let t_of_sexp :
       Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__017_ sexp__016_
     | Sexplib0.Sexp.List [] as sexp__016_ ->
       Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__017_ sexp__016_
-    | sexp__016_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__017_ sexp__016_
+    | sexp__016_ ->
+      Sexplib0.Sexp_conv_error.unexpected_stag
+        error_source__017_
+        [ "First"; "Second" ]
+        sexp__016_
 ;;
 
-let sexp_of_t :
-      'f 's.
-      ('f -> Sexplib0.Sexp.t) -> ('s -> Sexplib0.Sexp.t) -> ('f, 's) t -> Sexplib0.Sexp.t
+let sexp_of_t
+  : 'f 's.
+  ('f -> Sexplib0.Sexp.t) -> ('s -> Sexplib0.Sexp.t) -> ('f, 's) t -> Sexplib0.Sexp.t
   =
   fun (type f__037_ s__038_)
     :  ((f__037_ -> Sexplib0.Sexp.t) -> (s__038_ -> Sexplib0.Sexp.t)
@@ -113,11 +117,11 @@ let sexp_of_t :
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Second"; res0__036_ ]
 ;;
 
-let t_sexp_grammar :
-      'f 's.
-      'f Sexplib0.Sexp_grammar.t
-      -> 's Sexplib0.Sexp_grammar.t
-      -> ('f, 's) t Sexplib0.Sexp_grammar.t
+let t_sexp_grammar
+  : 'f 's.
+  'f Sexplib0.Sexp_grammar.t
+  -> 's Sexplib0.Sexp_grammar.t
+  -> ('f, 's) t Sexplib0.Sexp_grammar.t
   =
   fun _'f_sexp_grammar _'s_sexp_grammar ->
   { untyped =
diff --git a/src/error.ml b/src/error.ml
index e82588ea..29140354 100644
--- a/src/error.ml
+++ b/src/error.ml
@@ -6,14 +6,25 @@ open! Import
 include Info
 
 let t_sexp_grammar : t Sexplib0.Sexp_grammar.t = { untyped = Any "Error.t" }
-let[@cold] raise t = raise (to_exn t)
-let[@cold] raise_s sexp = raise (create_s sexp)
+let[@cold] [@inline never] [@local never] [@specialise never] raise t = raise (to_exn t)
+
+let[@cold] [@inline never] [@local never] [@specialise never] raise_s sexp =
+  raise (create_s sexp)
+;;
+
+(* Tailcalls to raising functions are to be avoided, as the stack traces are much worse.
+   Instead, we try really hard to inline wrapper functions that just perform non-tail
+   calls to the raising functions. That way, even if a call to [Error.raise] appears
+   in tail position, the post-inlining result doesn't perform a tail call.
+*)
+let[@inline always] raise t = raise t [@nontail]
+let[@inline always] raise_s sexp = raise_s sexp [@nontail]
 let to_info t = t
 let of_info t = t
 
 include Pretty_printer.Register_pp (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let module_name = "Base.Error"
-  let pp = pp
-end)
+    let module_name = "Base.Error"
+    let pp = pp
+  end)
diff --git a/src/exn.ml b/src/exn.ml
index 794a9bcd..3b31f346 100644
--- a/src/exn.ml
+++ b/src/exn.ml
@@ -100,16 +100,16 @@ let does_raise (type a) (f : unit -> a) =
 ;;
 
 include Pretty_printer.Register_pp (struct
-  type t = exn
+    type t = exn
 
-  let pp ppf t =
-    match sexp_of_exn_opt t with
-    | Some sexp -> Sexp.pp_hum ppf sexp
-    | None -> Stdlib.Format.pp_print_string ppf (Stdlib.Printexc.to_string t)
-  ;;
+    let pp ppf t =
+      match sexp_of_exn_opt t with
+      | Some sexp -> Sexp.pp_hum ppf sexp
+      | None -> Stdlib.Format.pp_print_string ppf (Stdlib.Printexc.to_string t)
+    ;;
 
-  let module_name = "Base.Exn"
-end)
+    let module_name = "Base.Exn"
+  end)
 
 let print_with_backtrace exc raw_backtrace =
   Stdlib.Format.eprintf "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@." pp exc;
diff --git a/src/float.ml b/src/float.ml
index 7462a12a..8bfa8e30 100644
--- a/src/float.ml
+++ b/src/float.ml
@@ -23,30 +23,145 @@ module T = struct
 
   [@@@end]
 
-  let hashable : t Hashable.t = { hash; compare; sexp_of_t }
   let compare = Float_replace_polymorphic_compare.compare
+  let hashable : t Hashable.t = { hash; compare; sexp_of_t }
 end
 
 include T
 include Comparator.Make (T)
 
-(* Open replace_polymorphic_compare after including functor instantiations so they do not
-   shadow its definitions. This is here so that efficient versions of the comparison
-   functions are available within this module. *)
+(* We include type-specific [Replace_polymorphic_compare] at the end, after including
+   functor application that could shadow its definitions. This is here so that efficient
+   versions of the comparison functions are exported by this module. *)
 open Float_replace_polymorphic_compare
 
+external ceil : (t[@local_opt]) -> t = "caml_ceil_float" "ceil" [@@unboxed] [@@noalloc]
+external floor : (t[@local_opt]) -> t = "caml_floor_float" "floor" [@@unboxed] [@@noalloc]
+
+external mod_float : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_fmod_float" "fmod"
+[@@unboxed] [@@noalloc]
+
+external float_of_string : (string[@local_opt]) -> t = "caml_float_of_string"
+
+let float_of_string_opt s =
+  try Some (float_of_string s) with
+  | Failure _ -> None
+;;
+
+let nan = Stdlib.nan
+let infinity = Stdlib.infinity
+let neg_infinity = Stdlib.neg_infinity
+let max_finite_value = Stdlib.max_float
+let epsilon_float = Stdlib.epsilon_float
+
+external classify_float
+  :  (t[@unboxed] [@local_opt])
+  -> Stdlib.fpclass
+  = "caml_classify_float" "caml_classify_float_unboxed"
+[@@noalloc]
+
+external trunc : (t[@local_opt]) -> t = "caml_trunc_float" "caml_trunc"
+[@@unboxed] [@@noalloc]
+
+let is_finite t = t -. t = 0.
+let is_integer x = x = trunc x && is_finite x
+
+external frexp : (t[@local_opt]) -> t * int = "caml_frexp_float"
+
+external ldexp
+  :  (t[@unboxed] [@local_opt])
+  -> (int[@untagged])
+  -> (t[@unboxed])
+  = "caml_ldexp_float" "caml_ldexp_float_unboxed"
+[@@noalloc]
+
+external log10 : (t[@local_opt]) -> t = "caml_log10_float" "log10" [@@unboxed] [@@noalloc]
+
+external log2 : (t[@local_opt]) -> t = "caml_log2_float" "caml_log2"
+[@@unboxed] [@@noalloc]
+
+external expm1 : (t[@local_opt]) -> t = "caml_expm1_float" "caml_expm1"
+[@@unboxed] [@@noalloc]
+
+external log1p : (t[@local_opt]) -> t = "caml_log1p_float" "caml_log1p"
+[@@unboxed] [@@noalloc]
+
+external copysign
+  :  (t[@local_opt])
+  -> (t[@local_opt])
+  -> t
+  = "caml_copysign_float" "caml_copysign"
+[@@unboxed] [@@noalloc]
+
+external cos : (t[@local_opt]) -> t = "caml_cos_float" "cos" [@@unboxed] [@@noalloc]
+external sin : (t[@local_opt]) -> t = "caml_sin_float" "sin" [@@unboxed] [@@noalloc]
+external tan : (t[@local_opt]) -> t = "caml_tan_float" "tan" [@@unboxed] [@@noalloc]
+external acos : (t[@local_opt]) -> t = "caml_acos_float" "acos" [@@unboxed] [@@noalloc]
+external asin : (t[@local_opt]) -> t = "caml_asin_float" "asin" [@@unboxed] [@@noalloc]
+external atan : (t[@local_opt]) -> t = "caml_atan_float" "atan" [@@unboxed] [@@noalloc]
+
+external acosh : (t[@local_opt]) -> t = "caml_acosh_float" "caml_acosh"
+[@@unboxed] [@@noalloc]
+
+external asinh : (t[@local_opt]) -> t = "caml_asinh_float" "caml_asinh"
+[@@unboxed] [@@noalloc]
+
+external atanh : (t[@local_opt]) -> t = "caml_atanh_float" "caml_atanh"
+[@@unboxed] [@@noalloc]
+
+external atan2 : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_atan2_float" "atan2"
+[@@unboxed] [@@noalloc]
+
+external hypot : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_hypot_float" "caml_hypot"
+[@@unboxed] [@@noalloc]
+
+external cosh : (t[@local_opt]) -> t = "caml_cosh_float" "cosh" [@@unboxed] [@@noalloc]
+external sinh : (t[@local_opt]) -> t = "caml_sinh_float" "sinh" [@@unboxed] [@@noalloc]
+external tanh : (t[@local_opt]) -> t = "caml_tanh_float" "tanh" [@@unboxed] [@@noalloc]
+external sqrt : (t[@local_opt]) -> t = "caml_sqrt_float" "sqrt" [@@unboxed] [@@noalloc]
+external exp : (t[@local_opt]) -> t = "caml_exp_float" "exp" [@@unboxed] [@@noalloc]
+external log : (t[@local_opt]) -> t = "caml_log_float" "log" [@@unboxed] [@@noalloc]
+
+(* X86 docs say:
+
+   If only one value is a NaN (SNaN or QNaN) for this instruction, the second source
+   operand, either a NaN or a valid floating-point value
+   is written to the result.
+
+   So we have to be VERY careful how we use these!
+
+   These intrinsics were copied from [Ocaml_intrinsics] to avoid build deps we don't want
+*)
+module Intrinsics_with_weird_nan_behavior = struct
+  let[@inline always] min a b = Ocaml_intrinsics_kernel.Float.min a b
+  let[@inline always] max a b = Ocaml_intrinsics_kernel.Float.max a b
+end
+
+let clamp_unchecked
+  ~(to_clamp_maybe_nan : float)
+  ~min_which_is_not_nan
+  ~max_which_is_not_nan
+  =
+  (* We want to propagate nans; as per the x86 docs, this means we have to use them as the
+     _second_ argument. *)
+  let t_maybe_nan =
+    Intrinsics_with_weird_nan_behavior.max min_which_is_not_nan to_clamp_maybe_nan
+  in
+  Intrinsics_with_weird_nan_behavior.min max_which_is_not_nan t_maybe_nan
+;;
+
 let invariant (_ : t) = ()
 let to_float x = x
 let of_float x = x
 
 let of_string s =
   try float_of_string s with
-  | _ -> invalid_argf "Float.of_string %s" s ()
+  | _ -> invalid_argf "Float.of_string %s" (globalize_string s) ()
 ;;
 
 let of_string_opt = float_of_string_opt
 
-external format_float : string -> float -> string = "caml_format_float"
+external format_float : string -> t -> string = "caml_format_float"
 
 (* Stolen from [pervasives.ml].  Adds a "." at the end if needed.  It is in
    [pervasives.mli], but it also says not to use it directly, so we copy and paste the
@@ -186,12 +301,12 @@ let minus_one = -1.
 let pi = 0x3.243F6A8885A308D313198A2E037073
 let sqrt_pi = 0x1.C5BF891B4EF6AA79C3B0520D5DB938
 let sqrt_2pi = 0x2.81B263FEC4E0B2CAF9483F5CE459DC
-let euler = 0x0.93C467E37DB0C7A4D1BE3F810152CB
+let euler_gamma_constant = 0x0.93C467E37DB0C7A4D1BE3F810152CB
 let of_int = Int.to_float
 let to_int = Int.of_float
 let of_int63 i = Int63.to_float i
-let of_int64 i = Stdlib.Int64.to_float i
-let to_int64 = Stdlib.Int64.of_float
+let of_int64 i = Int64.to_float i
+let to_int64 = Int64.of_float
 let iround_lbound = lower_bound_for_int Int.num_bits
 let iround_ubound = upper_bound_for_int Int.num_bits
 
@@ -335,7 +450,7 @@ let iround_nearest_exn_32 t =
   then (
     let t' = add_half_for_round_nearest t in
     if t' <= iround_ubound
-    then Int.of_float_unchecked t'
+    then Int.of_float_unchecked t' [@nontail]
     else invalid_argf "Float.iround_nearest_exn: argument (%f) is too large" (box t) ())
   else (
     let t' = floor (t +. 0.5) in
@@ -348,7 +463,7 @@ let[@ocaml.inline always] iround_nearest_exn_64 t =
   if t >= 0.
   then
     if t < round_nearest_ub
-    then Int.of_float_unchecked (add_half_for_round_nearest t)
+    then Int.of_float_unchecked (add_half_for_round_nearest t) [@nontail]
     else if t <= iround_ubound
     then Int.of_float_unchecked t
     else invalid_argf "Float.iround_nearest_exn: argument (%f) is too large" (box t) ()
@@ -366,15 +481,19 @@ let iround_nearest_exn =
   | W32 -> iround_nearest_exn_32
 ;;
 
+(* We must redefine [iround_nearest_exn] to look like a function so the compiler can infer
+   that it is [@zero_alloc]. *)
+let[@inline] iround_nearest_exn t = iround_nearest_exn t
+
 (* The following [iround_exn] and [iround] functions are slower than the ones above.
    Their equivalence to those functions is tested in the unit tests below. *)
 
 let[@inline] iround_exn ?(dir = `Nearest) t =
   match dir with
-  | `Zero -> iround_towards_zero_exn t
-  | `Nearest -> iround_nearest_exn t
-  | `Up -> iround_up_exn t
-  | `Down -> iround_down_exn t
+  | `Zero -> iround_towards_zero_exn t [@nontail]
+  | `Nearest -> iround_nearest_exn t [@nontail]
+  | `Up -> iround_up_exn t [@nontail]
+  | `Down -> iround_down_exn t [@nontail]
 ;;
 
 let iround ?(dir = `Nearest) t =
@@ -383,38 +502,27 @@ let iround ?(dir = `Nearest) t =
 ;;
 
 let is_inf t = 1. /. t = 0.
-let is_finite t = t -. t = 0.
 
-let min_inan (x : t) y =
-  if is_nan y then x else if is_nan x then y else if x < y then x else y
-;;
-
-let max_inan (x : t) y =
-  if is_nan y then x else if is_nan x then y else if x > y then x else y
-;;
-
-let add = ( +. )
-let sub = ( -. )
-let neg = ( ~-. )
-let abs = abs_float
-let scale = ( *. )
-let square x = x *. x
+external add : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+external sub : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+external neg : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
+external abs : (t[@local_opt]) -> (t[@local_opt]) = "%absfloat"
+external scale : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
 
 module Parts : sig
   type t
 
   val fractional : t -> float
   val integral : t -> float
-  val modf : float -> t
 end = struct
   type t = float * float
 
   let fractional t = fst t
   let integral t = snd t
-  let modf = modf
 end
 
-let modf = Parts.modf
+external modf : (t[@local_opt]) -> Parts.t = "caml_modf_float"
+
 let round_down = floor
 let round_up = ceil
 let round_towards_zero t = if t >= 0. then round_down t else round_up t
@@ -422,15 +530,15 @@ let round_towards_zero t = if t >= 0. then round_down t else round_up t
 (* see the comment above [round_nearest_lb] and [round_nearest_ub] for an explanation *)
 let[@ocaml.inline] round_nearest_inline t =
   if t > round_nearest_lb && t < round_nearest_ub
-  then floor (add_half_for_round_nearest t)
-  else t +. 0.
+  then floor (add_half_for_round_nearest t) [@nontail]
+  else box t
 ;;
 
 let round_nearest t = (round_nearest_inline [@ocaml.inlined always]) t
 
 let round_nearest_half_to_even t =
   if t <= round_nearest_lb || t >= round_nearest_ub
-  then t +. 0.
+  then box t
   else (
     let floor = floor t in
     (* [ceil_or_succ = if t is an integer then t +. 1. else ceil t].  Faster than [ceil]. *)
@@ -456,18 +564,11 @@ let int63_round_up_exn t =
     let t' = ceil t in
     if t' <= int63_round_ubound
     then Int63.of_float_unchecked t'
-    else
-      invalid_argf
-        "Float.int63_round_up_exn: argument (%f) is too large"
-        (Float0.box t)
-        ())
+    else invalid_argf "Float.int63_round_up_exn: argument (%f) is too large" (box t) ())
   else if t >= int63_round_lbound
   then Int63.of_float_unchecked t
   else
-    invalid_argf
-      "Float.int63_round_up_exn: argument (%f) is too small or NaN"
-      (Float0.box t)
-      ()
+    invalid_argf "Float.int63_round_up_exn: argument (%f) is too small or NaN" (box t) ()
 ;;
 
 let int63_round_down_exn t =
@@ -475,11 +576,7 @@ let int63_round_down_exn t =
   then
     if t <= int63_round_ubound
     then Int63.of_float_unchecked t
-    else
-      invalid_argf
-        "Float.int63_round_down_exn: argument (%f) is too large"
-        (Float0.box t)
-        ()
+    else invalid_argf "Float.int63_round_down_exn: argument (%f) is too large" (box t) ()
   else (
     let t' = floor t in
     if t' >= int63_round_lbound
@@ -487,7 +584,7 @@ let int63_round_down_exn t =
     else
       invalid_argf
         "Float.int63_round_down_exn: argument (%f) is too small or NaN"
-        (Float0.box t)
+        (box t)
         ())
 ;;
 
@@ -523,10 +620,10 @@ let int63_round_nearest_exn =
 
 let round ?(dir = `Nearest) t =
   match dir with
-  | `Nearest -> round_nearest t
-  | `Down -> round_down t
-  | `Up -> round_up t
-  | `Zero -> round_towards_zero t
+  | `Nearest -> round_nearest t [@nontail]
+  | `Down -> round_down t [@nontail]
+  | `Up -> round_up t [@nontail]
+  | `Zero -> round_towards_zero t [@nontail]
 ;;
 
 module Class = struct
@@ -565,8 +662,11 @@ module Class = struct
      | Sexplib0.Sexp.List [] as sexp__006_ ->
        Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__007_ sexp__006_
      | sexp__006_ ->
-       Sexplib0.Sexp_conv_error.unexpected_stag error_source__007_ sexp__006_
-      : Sexplib0.Sexp.t -> t)
+       Sexplib0.Sexp_conv_error.unexpected_stag
+         error_source__007_
+         [ "Infinite"; "Nan"; "Normal"; "Subnormal"; "Zero" ]
+         sexp__006_
+     : Sexplib0.Sexp.t -> t)
   ;;
 
   let sexp_of_t =
@@ -576,7 +676,7 @@ module Class = struct
      | Normal -> Sexplib0.Sexp.Atom "Normal"
      | Subnormal -> Sexplib0.Sexp.Atom "Subnormal"
      | Zero -> Sexplib0.Sexp.Atom "Zero"
-      : t -> Sexplib0.Sexp.t)
+     : t -> Sexplib0.Sexp.t)
   ;;
 
   let (t_sexp_grammar : t Sexplib0.Sexp_grammar.t) =
@@ -631,7 +731,9 @@ let to_string_hum ?delimiter ?(decimals = 3) ?strip_zero ?(explicit_plus = false
   | Class.Nan -> "nan"
   | Class.Normal | Class.Subnormal | Class.Zero ->
     let s =
-      if explicit_plus then sprintf "%+.*f" decimals f else sprintf "%.*f" decimals f
+      if explicit_plus
+      then sprintf "%+.*f" decimals (globalize f)
+      else sprintf "%.*f" decimals (globalize f)
     in
     insert_underscores s ?delimiter ?strip_zero
 ;;
@@ -739,11 +841,11 @@ let to_padded_compact_string_custom t ?(prefix = "") ~kilo ~mega ~giga ~tera ?pe
       then conv tera t 100_000_000_000.
       else (
         match peta with
-        | None -> sprintf "%s%.1e" prefix t
+        | None -> sprintf "%s%.1e" prefix (globalize t)
         | Some peta ->
           if t < 999.95E15
           then conv peta t 100_000_000_000_000.
-          else sprintf "%s%.1e" prefix t)
+          else sprintf "%s%.1e" prefix (globalize t))
     in
     if t >= 0. then go t else "-" ^ go ~-.t
 ;;
@@ -764,13 +866,10 @@ let int_pow x n =
   if n = 0
   then 1.
   else (
-    (* Using [x +. (-0.)] on the following line convinces the compiler to avoid a certain
+    (* Using [box x] on the following line convinces the compiler to avoid a certain
        boxing (that would result in allocation in each iteration).  Soon, the compiler
-       shouldn't need this "hint" to avoid the boxing.  The reason we add -0 rather than 0
-       is that [x +. (-0.)] is apparently always the same as [x], whereas [x +. 0.] is
-       not, in that it sends [-0.] to [0.].  This makes a difference because we want
-       [int_pow (-0.) (-1)] to return neg_infinity just like [-0. ** -1.] would.  *)
-    let x = ref (x +. -0.) in
+       shouldn't need this "hint" to avoid the boxing. *)
+    let x = ref (box x) in
     let n = ref n in
     let accum = ref 1. in
     if !n < 0
@@ -798,66 +897,203 @@ let int_pow x n =
     !x *. !accum)
 ;;
 
-let round_gen x ~how =
-  if x = 0.
-  then 0.
-  else if not (is_finite x)
-  then x
-  else (
-    (* Significant digits and decimal digits. *)
-    let sd, dd =
-      match how with
-      | `significant_digits sd ->
-        let dd = sd - to_int (round_up (log10 (abs x))) in
-        sd, dd
-      | `decimal_digits dd ->
-        let sd = dd + to_int (round_up (log10 (abs x))) in
-        sd, dd
-    in
-    let open Int_replace_polymorphic_compare in
-    if sd < 0
-    then 0.
-    else if sd >= 17
+(* [( *. )] is already mode-polymorphic so it doesn't make sense to functorize these, plus
+   their implementation is trivial anyway. *)
+let square x = x *. x
+let square_local x = x *. x
+
+(* The desired behavior here is to propagate a nan if either argument is nan. Because
+   the first comparison will always return false if either argument is nan, it suffices
+   to check if x is nan. Then, when x is nan or both x and y are nan, we return x = nan;
+   and when y is nan but not x, we return y = nan.
+
+   There are various ways to implement these functions.  The benchmark below shows a few
+   different versions.  This benchmark was run over an array of random floats (none of
+   which are nan).
+
+   ┌────────────────────────────────────────────────┬──────────┐
+   │ Name                                           │ Time/Run │
+   ├────────────────────────────────────────────────┼──────────┤
+   │ if is_nan x then x else if x < y then x else y │   2.42us │
+   │ if is_nan x || x < y then x else y             │   2.02us │
+   │ if x < y || is_nan x then x else y             │   1.88us │
+   └────────────────────────────────────────────────┴──────────┘
+
+   The benchmark below was run when x > y is always true (again, no nan values).
+
+   ┌────────────────────────────────────────────────┬──────────┐
+   │ Name                                           │ Time/Run │
+   ├────────────────────────────────────────────────┼──────────┤
+   │ if is_nan x then x else if x < y then x else y │   2.83us │
+   │ if is_nan x || x < y then x else y             │   1.97us │
+   │ if x < y || is_nan x then x else y             │   1.56us │
+   └────────────────────────────────────────────────┴──────────┘
+*)
+let min, min_local =
+  let open
+    Modes.Global.Poly_fn2 (T) (T) (T)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y =
+             let x' = W.unwrap x
+             and y' = W.unwrap y in
+             if x' < y' || is_nan x' then x else y
+           ;;
+         end) in
+  fn_global, fn_local
+;;
+
+let max, max_local =
+  let open
+    Modes.Global.Poly_fn2 (T) (T) (T)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y =
+             let x' = W.unwrap x
+             and y' = W.unwrap y in
+             if x' > y' || is_nan x' then x else y
+           ;;
+         end) in
+  fn_global, fn_local
+;;
+
+let min_inan, min_inan_local =
+  let open
+    Modes.Global.Poly_fn2 (T) (T) (T)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y =
+             let x' = W.unwrap x
+             and y' = W.unwrap y in
+             if is_nan y' then x else if is_nan x' then y else if x' < y' then x else y
+           ;;
+         end) in
+  fn_global, fn_local
+;;
+
+let max_inan, max_inan_local =
+  let open
+    Modes.Global.Poly_fn2 (T) (T) (T)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y =
+             let x' = W.unwrap x
+             and y' = W.unwrap y in
+             if is_nan y' then x else if is_nan x' then y else if x' > y' then x else y
+           ;;
+         end) in
+  fn_global, fn_local
+;;
+
+module Round_gen (W : Modes.Global.Wrapper) = struct
+  let round_gen x ~how =
+    let x' = W.unwrap x in
+    if x' = 0.
+    then W.wrap 0.
+    else if not (is_finite x')
     then x
     else (
-      (* Choose the order that is exactly representable as a float. Small positive
-         integers are, but their inverses in most cases are not. *)
-      let abs_dd = Int.abs dd in
-      if abs_dd > 22 || sd >= 16
-         (* 10**22 is exactly representable as a float, but 10**23 is not, so use the slow
-         path.  Similarly, if we need 16 significant digits in the result, then the integer
-         [round_nearest (x <op> order)] might not be exactly representable as a float, since
-         for some ranges we only have 15 digits of precision guaranteed.
-
-         That said, we are still rounding twice here:
-
-         1) first time when rounding [x *. order] or [x /. order] to the nearest float
-         (just the normal way floating-point multiplication or division works),
-
-         2) second time when applying [round_nearest_half_to_even] to the result of the
-         above operation
-
-         So for arguments within an ulp from a tie we might still produce an off-by-one
-         result. *)
-      then of_string (sprintf "%.*g" sd x)
+      (* Significant digits and decimal digits. *)
+      let sd, dd =
+        match how with
+        | `significant_digits sd ->
+          let dd = sd - to_int (round_up (log10 (abs x'))) in
+          sd, dd
+        | `decimal_digits dd ->
+          let sd = dd + to_int (round_up (log10 (abs x'))) in
+          sd, dd
+      in
+      let open Int_replace_polymorphic_compare in
+      if sd < 0
+      then W.wrap 0.
+      else if sd >= 17
+      then x
       else (
-        let order = int_pow 10. abs_dd in
-        if dd >= 0
-        then round_nearest_half_to_even (x *. order) /. order
-        else round_nearest_half_to_even (x /. order) *. order)))
+        (* Choose the order that is exactly representable as a float. Small positive
+             integers are, but their inverses in most cases are not. *)
+        let abs_dd = Int.abs dd in
+        if abs_dd > 22 || sd >= 16
+           (* 10**22 is exactly representable as a float, but 10**23 is not, so use the slow
+              path.  Similarly, if we need 16 significant digits in the result, then the integer
+              [round_nearest (x <op> order)] might not be exactly representable as a float, since
+              for some ranges we only have 15 digits of precision guaranteed.
+
+              That said, we are still rounding twice here:
+
+              1) first time when rounding [x *. order] or [x /. order] to the nearest float
+              (just the normal way floating-point multiplication or division works),
+
+              2) second time when applying [round_nearest_half_to_even] to the result of the
+              above operation
+
+              So for arguments within an ulp from a tie we might still produce an off-by-one
+              result. *)
+        then W.wrap (of_string (sprintf "%.*g" sd (globalize x')))
+        else (
+          let order = int_pow 10. abs_dd in
+          if dd >= 0
+          then W.wrap (round_nearest_half_to_even (x' *. order) /. order)
+          else W.wrap (round_nearest_half_to_even (x' /. order) *. order))))
+  ;;
+end
+
+let round_significant, round_significant_local =
+  let open
+    Modes.Global.Poly_fn2 (T) (Int) (T)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           open Round_gen (W)
+
+           let fn x significant_digits =
+             let significant_digits = W.unwrap significant_digits in
+             if Int_replace_polymorphic_compare.( <= ) significant_digits 0
+             then
+               invalid_argf
+                 "Float.round_significant: invalid argument significant_digits:%d"
+                 significant_digits
+                 ()
+             else round_gen x ~how:(`significant_digits significant_digits)
+           ;;
+         end) in
+  fn_global, fn_local
 ;;
 
-let round_significant x ~significant_digits =
-  if Int_replace_polymorphic_compare.( <= ) significant_digits 0
-  then
-    invalid_argf
-      "Float.round_significant: invalid argument significant_digits:%d"
-      significant_digits
-      ()
-  else round_gen x ~how:(`significant_digits significant_digits)
+let round_decimal, round_decimal_local =
+  let open
+    Modes.Global.Poly_fn2 (T) (Int) (T)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           open Round_gen (W)
+
+           let fn x decimal_digits =
+             round_gen x ~how:(`decimal_digits (W.unwrap decimal_digits))
+           ;;
+         end) in
+  fn_global, fn_local
 ;;
 
-let round_decimal x ~decimal_digits = round_gen x ~how:(`decimal_digits decimal_digits)
+let[@inline] round_significant x ~significant_digits =
+  round_significant x significant_digits
+;;
+
+let[@inline] round_significant_local x ~significant_digits =
+  round_significant_local x significant_digits
+;;
+
+let[@inline] round_decimal x ~decimal_digits = round_decimal x decimal_digits
+let[@inline] round_decimal_local x ~decimal_digits = round_decimal_local x decimal_digits
 let between t ~low ~high = low <= t && t <= high
 
 let clamp_exn t ~min ~max =
@@ -886,13 +1122,22 @@ let clamp t ~min ~max =
          [ "min", T.sexp_of_t min; "max", T.sexp_of_t max ])
 ;;
 
-let ( + ) = ( +. )
-let ( - ) = ( -. )
-let ( * ) = ( *. )
-let ( ** ) = ( ** )
-let ( / ) = ( /. )
-let ( % ) = ( %. )
-let ( ~- ) = ( ~-. )
+external ( + ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+external ( - ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+external ( * ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+external ( / ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%divfloat"
+
+external ( % )
+  :  (t[@local_opt])
+  -> (t[@local_opt])
+  -> t
+  = "Base_caml_modf_positive_float_exn" "Base_caml_modf_positive_float_unboxed_exn"
+[@@unboxed]
+
+external ( ** ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_power_float" "pow"
+[@@unboxed] [@@noalloc]
+
+external ( ~- ) : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
 
 let[@inline] sign_exn t : Sign.t =
   if t > 0.
@@ -901,7 +1146,8 @@ let[@inline] sign_exn t : Sign.t =
   then Neg
   else if t = 0.
   then Zero
-  else Error.raise_s (Sexp.message "Float.sign_exn of NAN" [ "", sexp_of_t t ])
+  else
+    Error.raise_s (Sexp.message "Float.sign_exn of NAN" [ "", sexp_of_t (globalize t) ])
 ;;
 
 let sign_or_nan t : Sign_or_nan.t =
@@ -909,8 +1155,8 @@ let sign_or_nan t : Sign_or_nan.t =
 ;;
 
 let ieee_negative t =
-  let bits = Stdlib.Int64.bits_of_float t in
-  Poly.(bits < Stdlib.Int64.zero)
+  let bits = Int64.bits_of_float t in
+  Int64.O.(bits < zero)
 ;;
 
 let exponent_bits = 11
@@ -921,15 +1167,14 @@ let mantissa_mask = Int63.(shift_left one mantissa_bits - one)
 let mantissa_mask64 = Int63.to_int64 mantissa_mask
 
 let ieee_exponent t =
-  let bits = Stdlib.Int64.bits_of_float t in
-  Int64.(bit_and (shift_right_logical bits mantissa_bits) exponent_mask64)
-  |> Stdlib.Int64.to_int
+  let bits = Int64.bits_of_float t in
+  Int64.to_int_trunc Int64.O.((bits lsr mantissa_bits) land exponent_mask64)
 ;;
 
 let ieee_mantissa t =
-  let bits = Stdlib.Int64.bits_of_float t in
+  let bits = Int64.bits_of_float t in
   (* This is safe because mantissa_mask64 < Int63.max_value *)
-  (Int63.of_int64_trunc [@inlined]) Stdlib.Int64.(logand bits mantissa_mask64)
+  (Int63.of_int64_trunc [@inlined]) Int64.O.(bits land mantissa_mask64)
 ;;
 
 let create_ieee_exn ~negative ~exponent ~mantissa =
@@ -953,7 +1198,7 @@ let create_ieee_exn ~negative ~exponent ~mantissa =
 ;;
 
 let create_ieee ~negative ~exponent ~mantissa =
-  Or_error.try_with (fun () -> create_ieee_exn ~negative ~exponent ~mantissa)
+  Or_error.try_with (fun () -> create_ieee_exn ~negative ~exponent ~mantissa) [@nontail]
 ;;
 
 module Terse = struct
@@ -967,10 +1212,10 @@ module Terse = struct
 end
 
 include Comparable.With_zero (struct
-  include T
+    include T
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 (* These are partly here as a performance hack to avoid some boxing we're getting with
    the versions we get from [With_zero].  They also make [Float.is_negative nan] and
@@ -982,38 +1227,58 @@ let is_negative t = t < 0.
 let is_non_positive t = t <= 0.
 
 include Pretty_printer.Register (struct
-  include T
+    include T
 
-  let module_name = "Base.Float"
-  let to_string = to_string
-end)
+    let module_name = "Base.Float"
+    let to_string = to_string
+  end)
 
 module O = struct
-  let ( + ) = ( + )
-  let ( - ) = ( - )
-  let ( * ) = ( * )
-  let ( / ) = ( / )
-  let ( % ) = ( % )
-  let ( ~- ) = ( ~- )
-  let ( ** ) = ( ** )
-
-  include (Float_replace_polymorphic_compare : Comparisons.Infix with type t := t)
-
-  let abs = abs
-  let neg = neg
+  external ( + ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+  external ( - ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+  external ( * ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+  external ( / ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%divfloat"
+
+  external ( % )
+    :  (t[@local_opt])
+    -> (t[@local_opt])
+    -> t
+    = "Base_caml_modf_positive_float_exn" "Base_caml_modf_positive_float_unboxed_exn"
+  [@@unboxed]
+
+  external ( ~- ) : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
+
+  external ( ** ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_power_float" "pow"
+  [@@unboxed] [@@noalloc]
+
+  include (
+    Float_replace_polymorphic_compare : Comparisons.Infix_with_local_opt with type t := t)
+
+  external abs : (t[@local_opt]) -> (t[@local_opt]) = "%absfloat"
+  external neg : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
+
   let zero = zero
   let of_int = of_int
   let of_float x = x
 end
 
 module O_dot = struct
-  let ( *. ) = ( * )
-  let ( +. ) = ( + )
-  let ( -. ) = ( - )
-  let ( /. ) = ( / )
-  let ( %. ) = ( % )
-  let ( ~-. ) = ( ~- )
-  let ( **. ) = ( ** )
+  external ( +. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+  external ( -. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+  external ( *. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+  external ( /. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%divfloat"
+
+  external ( %. )
+    :  (t[@local_opt])
+    -> (t[@local_opt])
+    -> t
+    = "Base_caml_modf_positive_float_exn" "Base_caml_modf_positive_float_unboxed_exn"
+  [@@unboxed]
+
+  external ( ~-. ) : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
+
+  external ( **. ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_power_float" "pow"
+  [@@unboxed] [@@noalloc]
 end
 
 module Private = struct
@@ -1028,40 +1293,17 @@ module Private = struct
   let iround_nearest_exn_64 = iround_nearest_exn_64
 end
 
+module Shadow = struct
+  (* These functions specifically replace defaults in replace_polymorphic_compare. *)
+  let min = min
+  let max = max
+  let min_local = min_local
+  let max_local = max_local
+end
+
 (* Include type-specific [Replace_polymorphic_compare] at the end, after
    including functor application that could shadow its definitions. This is
    here so that efficient versions of the comparison functions are exported by
    this module. *)
 include Float_replace_polymorphic_compare
-
-(* These functions specifically replace defaults in replace_polymorphic_compare.
-
-   The desired behavior here is to propagate a nan if either argument is nan. Because the
-   first comparison will always return false if either argument is nan, it suffices to
-   check if x is nan. Then, when x is nan or both x and y are nan, we return x = nan; and
-   when y is nan but not x, we return y = nan.
-
-   There are various ways to implement these functions.  The benchmark below shows a few
-   different versions.  This benchmark was run over an array of random floats (none of
-   which are nan).
-
-   ┌────────────────────────────────────────────────┬──────────┐
-   │ Name                                           │ Time/Run │
-   ├────────────────────────────────────────────────┼──────────┤
-   │ if is_nan x then x else if x < y then x else y │   2.42us │
-   │ if is_nan x || x < y then x else y             │   2.02us │
-   │ if x < y || is_nan x then x else y             │   1.88us │
-   └────────────────────────────────────────────────┴──────────┘
-
-   The benchmark below was run when x > y is always true (again, no nan values).
-
-   ┌────────────────────────────────────────────────┬──────────┐
-   │ Name                                           │ Time/Run │
-   ├────────────────────────────────────────────────┼──────────┤
-   │ if is_nan x then x else if x < y then x else y │   2.83us │
-   │ if is_nan x || x < y then x else y             │   1.97us │
-   │ if x < y || is_nan x then x else y             │   1.56us │
-   └────────────────────────────────────────────────┴──────────┘
-*)
-let min (x : t) y = if x < y || is_nan x then x else y
-let max (x : t) y = if x > y || is_nan x then x else y
+include Shadow
diff --git a/src/float.mli b/src/float.mli
index 6d0fdf92..2cc84ea8 100644
--- a/src/float.mli
+++ b/src/float.mli
@@ -23,6 +23,7 @@ include Floatable.S with type t := t
 
 include Identifiable.S with type t := t
 
+val of_string : string -> t
 val of_string_opt : string -> t option
 
 include Comparable.With_zero with type t := t
@@ -55,7 +56,7 @@ val sqrt_pi : t
 val sqrt_2pi : t
 
 (** Euler-Mascheroni constant (γ). *)
-val euler : t
+val euler_gamma_constant : t
 
 (** The difference between 1.0 and the smallest exactly representable floating-point
     number greater than 1.0.  That is:
@@ -141,7 +142,7 @@ val to_int64 : t -> int64
 val round : ?dir:[ `Zero | `Nearest | `Up | `Down ] -> t -> t
 
 val iround : ?dir:[ `Zero | `Nearest | `Up | `Down ] -> t -> int option
-val iround_exn : ?dir:[ `Zero | `Nearest | `Up | `Down ] -> t -> int
+val iround_exn : ?dir:[ `Zero | `Nearest | `Up | `Down ] -> t -> int [@@zero_alloc]
 val round_towards_zero : t -> t
 val round_down : t -> t
 val round_up : t -> t
@@ -156,10 +157,10 @@ val iround_towards_zero : t -> int option
 val iround_down : t -> int option
 val iround_up : t -> int option
 val iround_nearest : t -> int option
-val iround_towards_zero_exn : t -> int
-val iround_down_exn : t -> int
-val iround_up_exn : t -> int
-val iround_nearest_exn : t -> int
+val iround_towards_zero_exn : t -> int [@@zero_alloc]
+val iround_down_exn : t -> int [@@zero_alloc]
+val iround_up_exn : t -> int [@@zero_alloc]
+val iround_nearest_exn : t -> int [@@zero_alloc]
 val int63_round_down_exn : t -> Int63.t
 val int63_round_up_exn : t -> Int63.t
 val int63_round_nearest_exn : t -> Int63.t
@@ -233,7 +234,12 @@ val int63_round_ubound : t
     example above.
 
 *)
-val round_significant : float -> significant_digits:int -> float
+val round_significant : t -> significant_digits:int -> t
+
+(** [round_significant] might return its input, so we provide [round_significant_local]
+    for operating over locally-allocated values. However, if its input is rounded to a
+    different value, this will always be heap-allocated (when boxed). *)
+val round_significant_local : t -> significant_digits:int -> t
 
 (** [round_decimal x ~decimal_digits:n] rounds [x] to the nearest [10**(-n)]. For positive
     [n] it is meant to be equivalent to [sprintf "%.*f" n x |> Float.of_string], but
@@ -242,7 +248,10 @@ val round_significant : float -> significant_digits:int -> float
     All the considerations mentioned in [round_significant] apply (both functions use the
     same code path).
 *)
-val round_decimal : float -> decimal_digits:int -> float
+val round_decimal : t -> decimal_digits:int -> t
+
+(** See [round_significant_local]. *)
+val round_decimal_local : t -> decimal_digits:int -> t
 
 val is_nan : t -> bool
 
@@ -261,9 +270,16 @@ val is_integer : t -> bool
 
 val min_inan : t -> t -> t
 val max_inan : t -> t -> t
-val ( + ) : t -> t -> t
-val ( - ) : t -> t -> t
-val ( / ) : t -> t -> t
+
+(** [min_inan_local] and [max_inan_local] are like [min_inan] and [max_inan], but
+    returning one of two local values. *)
+
+val min_inan_local : t -> t -> t
+val max_inan_local : t -> t -> t
+external ( + ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+external ( - ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+external ( * ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+external ( / ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%divfloat"
 
 (** In analogy to Int.( % ), ( % ):
     - always produces non-negative (or NaN) result
@@ -273,24 +289,30 @@ val ( / ) : t -> t -> t
 
     Other cases: (a % Infinity) = a when 0 <= a < Infinity, (a % Infinity) = Infinity when
     -Infinity < a < 0, (+/- Infinity % a) = NaN, (a % 0) = NaN. *)
-val ( % ) : t -> t -> t
+external ( % )
+  :  (t[@local_opt])
+  -> (t[@local_opt])
+  -> t
+  = "Base_caml_modf_positive_float_exn" "Base_caml_modf_positive_float_unboxed_exn"
+[@@unboxed]
 
-val ( * ) : t -> t -> t
-val ( ** ) : t -> t -> t
-val ( ~- ) : t -> t
+external ( ** ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_power_float" "pow"
+[@@unboxed] [@@noalloc]
+
+external ( ~- ) : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
 
 (** Returns the fractional part and the whole (i.e., integer) part. For example, [modf
     (-3.14)] returns [{ fractional = -0.14; integral = -3.; }]! *)
 module Parts : sig
-  type outer
-  type t
+    type outer
+    type t
 
-  val fractional : t -> outer
-  val integral : t -> outer
-end
-with type outer := t
+    val fractional : t -> outer
+    val integral : t -> outer
+  end
+  with type outer := t
 
-val modf : t -> Parts.t
+external modf : (t[@local_opt]) -> Parts.t = "caml_modf_float"
 
 (** [mod_float x y] returns a result with the same sign as [x].  It returns [nan] if [y]
     is [0].  It is basically
@@ -302,33 +324,43 @@ val modf : t -> Parts.t
     {[ let mod_float x y = x -. floor(x/.y) *. y ]}
 
     and therefore resembles [mod] on integers more than [%]. *)
-val mod_float : t -> t -> t
+external mod_float : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_fmod_float" "fmod"
+[@@unboxed] [@@noalloc]
 
 (** {6 Ordinary functions for arithmetic operations}
 
     These are for modules that inherit from [t], since the infix operators are more
     convenient. *)
-val add : t -> t -> t
+external add : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
 
-val sub : t -> t -> t
-val neg : t -> t
-val scale : t -> t -> t
-val abs : t -> t
+external sub : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+external neg : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
+external scale : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+external abs : (t[@local_opt]) -> (t[@local_opt]) = "%absfloat"
 
 (** A sub-module designed to be opened to make working with floats more convenient.  *)
 module O : sig
-  val ( + ) : t -> t -> t
-  val ( - ) : t -> t -> t
-  val ( * ) : t -> t -> t
-  val ( / ) : t -> t -> t
-  val ( % ) : t -> t -> t
-  val ( ** ) : t -> t -> t
-  val ( ~- ) : t -> t
-
-  include Comparisons.Infix with type t := t
-
-  val abs : t -> t
-  val neg : t -> t
+  external ( + ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+  external ( - ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+  external ( * ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+  external ( / ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%divfloat"
+
+  external ( % )
+    :  (t[@local_opt])
+    -> (t[@local_opt])
+    -> t
+    = "Base_caml_modf_positive_float_exn" "Base_caml_modf_positive_float_unboxed_exn"
+  [@@unboxed]
+
+  external ( ** ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_power_float" "pow"
+  [@@unboxed] [@@noalloc]
+
+  external ( ~- ) : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
+
+  include Comparisons.Infix_with_local_opt with type t := t
+
+  external abs : (t[@local_opt]) -> (t[@local_opt]) = "%absfloat"
+  external neg : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
   val zero : t
   val of_int : int -> t
   val of_float : float -> t
@@ -337,13 +369,22 @@ end
 (** Similar to [O], except that operators are suffixed with a dot, allowing one to have
     both int and float operators in scope simultaneously. *)
 module O_dot : sig
-  val ( +. ) : t -> t -> t
-  val ( -. ) : t -> t -> t
-  val ( *. ) : t -> t -> t
-  val ( /. ) : t -> t -> t
-  val ( %. ) : t -> t -> t
-  val ( **. ) : t -> t -> t
-  val ( ~-. ) : t -> t
+  external ( +. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%addfloat"
+  external ( -. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%subfloat"
+  external ( *. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%mulfloat"
+  external ( /. ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%divfloat"
+
+  external ( %. )
+    :  (t[@local_opt])
+    -> (t[@local_opt])
+    -> t
+    = "Base_caml_modf_positive_float_exn" "Base_caml_modf_positive_float_unboxed_exn"
+  [@@unboxed]
+
+  external ( **. ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_power_float" "pow"
+  [@@unboxed] [@@noalloc]
+
+  external ( ~-. ) : (t[@local_opt]) -> (t[@local_opt]) = "%negfloat"
 end
 
 (** [to_string x] builds a string [s] representing the float [x] that guarantees the round
@@ -461,119 +502,132 @@ val int_pow : t -> int -> t
 (** [square x] returns [x *. x]. *)
 val square : t -> t
 
+(** [square_local x] returns [x *. x], locally-allocated. *)
+val square_local : t -> t
+
 (** [ldexp x n] returns [x *. 2 ** n] *)
-val ldexp : t -> int -> t
+external ldexp
+  :  (t[@unboxed] [@local_opt])
+  -> (int[@untagged])
+  -> (t[@unboxed])
+  = "caml_ldexp_float" "caml_ldexp_float_unboxed"
+[@@noalloc]
 
 (** [frexp f] returns the pair of the significant and the exponent of [f]. When [f] is
     zero, the significant [x] and the exponent [n] of [f] are equal to zero. When [f] is
     non-zero, they are defined by [f = x *. 2 ** n] and [0.5 <= x < 1.0]. *)
-val frexp : t -> t * int
+external frexp : (t[@local_opt]) -> t * int = "caml_frexp_float"
 
 (** Base 10 logarithm. *)
-external log10 : t -> t = "caml_log10_float" "log10"
-  [@@unboxed] [@@noalloc]
+external log10 : (t[@local_opt]) -> t = "caml_log10_float" "log10"
+[@@unboxed] [@@noalloc]
 
 (** Base 2 logarithm. *)
-external log2 : t -> t = "caml_log2_float" "caml_log2"
-  [@@unboxed] [@@noalloc]
+external log2 : (t[@local_opt]) -> t = "caml_log2_float" "caml_log2"
+[@@unboxed] [@@noalloc]
 
 (** [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results even if [x] is
     close to [0.0]. *)
-external expm1 : t -> t = "caml_expm1_float" "caml_expm1"
-  [@@unboxed] [@@noalloc]
+external expm1 : (t[@local_opt]) -> t = "caml_expm1_float" "caml_expm1"
+[@@unboxed] [@@noalloc]
 
 (** [log1p x] computes [log(1.0 +. x)] (natural logarithm), giving numerically-accurate
     results even if [x] is close to [0.0]. *)
-external log1p : t -> t = "caml_log1p_float" "caml_log1p"
-  [@@unboxed] [@@noalloc]
+external log1p : (t[@local_opt]) -> t = "caml_log1p_float" "caml_log1p"
+[@@unboxed] [@@noalloc]
 
 (** [copysign x y] returns a float whose absolute value is that of [x] and whose sign is
     that of [y].  If [x] is [nan], returns [nan].  If [y] is [nan], returns either [x] or
     [-. x], but it is not specified which. *)
-external copysign : t -> t -> t = "caml_copysign_float" "caml_copysign"
-  [@@unboxed] [@@noalloc]
+external copysign
+  :  (t[@local_opt])
+  -> (t[@local_opt])
+  -> t
+  = "caml_copysign_float" "caml_copysign"
+[@@unboxed] [@@noalloc]
 
 (** Cosine.  Argument is in radians. *)
-external cos : t -> t = "caml_cos_float" "cos"
-  [@@unboxed] [@@noalloc]
+external cos : (t[@local_opt]) -> t = "caml_cos_float" "cos"
+[@@unboxed] [@@noalloc]
 
 (** Sine.  Argument is in radians. *)
-external sin : t -> t = "caml_sin_float" "sin"
-  [@@unboxed] [@@noalloc]
+external sin : (t[@local_opt]) -> t = "caml_sin_float" "sin"
+[@@unboxed] [@@noalloc]
 
 (** Tangent.  Argument is in radians. *)
-external tan : t -> t = "caml_tan_float" "tan"
-  [@@unboxed] [@@noalloc]
+external tan : (t[@local_opt]) -> t = "caml_tan_float" "tan"
+[@@unboxed] [@@noalloc]
 
 (** Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].  Result is in
     radians and is between [0.0] and [pi]. *)
-external acos : t -> t = "caml_acos_float" "acos"
-  [@@unboxed] [@@noalloc]
+external acos : (t[@local_opt]) -> t = "caml_acos_float" "acos"
+[@@unboxed] [@@noalloc]
 
 (** Arc sine.  The argument must fall within the range [[-1.0, 1.0]].  Result is in
     radians and is between [-pi/2] and [pi/2]. *)
-external asin : t -> t = "caml_asin_float" "asin"
-  [@@unboxed] [@@noalloc]
+external asin : (t[@local_opt]) -> t = "caml_asin_float" "asin"
+[@@unboxed] [@@noalloc]
 
 (** Arc tangent.  Result is in radians and is between [-pi/2] and [pi/2]. *)
-external atan : t -> t = "caml_atan_float" "atan"
-  [@@unboxed] [@@noalloc]
+external atan : (t[@local_opt]) -> t = "caml_atan_float" "atan"
+[@@unboxed] [@@noalloc]
 
 (** [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x] and [y] are used to
     determine the quadrant of the result.  Result is in radians and is between [-pi] and
     [pi]. *)
-external atan2 : t -> t -> t = "caml_atan2_float" "atan2"
-  [@@unboxed] [@@noalloc]
+external atan2 : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_atan2_float" "atan2"
+[@@unboxed] [@@noalloc]
 
 (** [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length of the hypotenuse of
     a right-angled triangle with sides of length [x] and [y], or, equivalently, the
     distance of the point [(x,y)] to origin. *)
-external hypot : t -> t -> t = "caml_hypot_float" "caml_hypot"
-  [@@unboxed] [@@noalloc]
+external hypot : (t[@local_opt]) -> (t[@local_opt]) -> t = "caml_hypot_float" "caml_hypot"
+[@@unboxed] [@@noalloc]
 
 (** Hyperbolic cosine.  Argument is in radians. *)
-external cosh : t -> t = "caml_cosh_float" "cosh"
-  [@@unboxed] [@@noalloc]
+external cosh : (t[@local_opt]) -> t = "caml_cosh_float" "cosh"
+[@@unboxed] [@@noalloc]
 
 (** Hyperbolic sine.  Argument is in radians. *)
-external sinh : t -> t = "caml_sinh_float" "sinh"
-  [@@unboxed] [@@noalloc]
+external sinh : (t[@local_opt]) -> t = "caml_sinh_float" "sinh"
+[@@unboxed] [@@noalloc]
 
 (** Hyperbolic tangent.  Argument is in radians. *)
-external tanh : t -> t = "caml_tanh_float" "tanh"
-  [@@unboxed] [@@noalloc]
+external tanh : (t[@local_opt]) -> t = "caml_tanh_float" "tanh"
+[@@unboxed] [@@noalloc]
 
 (** Hyperbolic arc cosine.  The argument must fall within the range
     [[1.0, inf]].
     Result is in radians and is between [0.0] and [inf].
 *)
-external acosh : float -> float = "caml_acosh_float" "caml_acosh"
-  [@@unboxed] [@@noalloc]
+external acosh : (t[@local_opt]) -> t = "caml_acosh_float" "caml_acosh"
+[@@unboxed] [@@noalloc]
 
 (** Hyperbolic arc sine.  The argument and result range over the entire
     real line.
     Result is in radians.
 *)
-external asinh : float -> float = "caml_asinh_float" "caml_asinh"
-  [@@unboxed] [@@noalloc]
+external asinh : (t[@local_opt]) -> t = "caml_asinh_float" "caml_asinh"
+[@@unboxed] [@@noalloc]
 
 (** Hyperbolic arc tangent.  The argument must fall within the range
     [[-1.0, 1.0]].
     Result is in radians and ranges over the entire real line.
 *)
-external atanh : float -> float = "caml_atanh_float" "caml_atanh"
-  [@@unboxed] [@@noalloc]
+external atanh : (t[@local_opt]) -> t = "caml_atanh_float" "caml_atanh"
+[@@unboxed] [@@noalloc]
 
 (** Square root. *)
-external sqrt : t -> t = "caml_sqrt_float" "sqrt"
-  [@@unboxed] [@@noalloc]
+external sqrt : (t[@local_opt]) -> t = "caml_sqrt_float" "sqrt"
+[@@unboxed] [@@noalloc]
 
 (** Exponential. *)
-external exp : t -> t = "caml_exp_float" "exp" [@@unboxed] [@@noalloc]
+external exp : (t[@local_opt]) -> t = "caml_exp_float" "exp"
+[@@unboxed] [@@noalloc]
 
 (** Natural logarithm. *)
-external log : t -> t = "caml_log_float" "log"
-  [@@unboxed] [@@noalloc]
+external log : (t[@local_opt]) -> t = "caml_log_float" "log"
+[@@unboxed] [@@noalloc]
 
 (** Excluding nan the floating-point "number line" looks like:
     {v
@@ -613,7 +667,7 @@ val classify : t -> Class.t
   [Comparable.With_zero]. *)
 
 val sign : t -> Sign.t
-  [@@deprecated "[since 2016-01] Replace [sign] with [robust_sign] or [sign_exn]"]
+[@@deprecated "[since 2016-01] Replace [sign] with [robust_sign] or [sign_exn]"]
 
 (** The sign of a float.  Both [-0.] and [0.] map to [Zero].  Raises on nan.  All other
     values map to [Neg] or [Pos]. *)
diff --git a/src/float0.ml b/src/float0.ml
index 9ccd8666..324bd57f 100644
--- a/src/float0.ml
+++ b/src/float0.ml
@@ -5,95 +5,6 @@ open! Import
    functions are available within this module. *)
 open! Float_replace_polymorphic_compare
 
-let ceil = Stdlib.ceil
-let floor = Stdlib.floor
-let mod_float = Stdlib.mod_float
-let modf = Stdlib.modf
-let float_of_string = Stdlib.float_of_string
-let float_of_string_opt = Stdlib.float_of_string_opt
-let nan = Stdlib.nan
-let infinity = Stdlib.infinity
-let neg_infinity = Stdlib.neg_infinity
-let max_finite_value = Stdlib.max_float
-let epsilon_float = Stdlib.epsilon_float
-let classify_float = Stdlib.classify_float
-let abs_float = Stdlib.abs_float
-let is_integer = Stdlib.Float.is_integer
-let ( ** ) = Stdlib.( ** )
-
-let ( %. ) a b =
-  (* Raise in case of a negative modulus, as does Int.( % ). *)
-  if b < 0.
-  then Printf.invalid_argf "%f %% %f in float0.ml: modulus should be positive" a b ();
-  let m = Stdlib.mod_float a b in
-  (* Produce a non-negative result in analogy with Int.( % ). *)
-  if m < 0. then m +. b else m
-;;
-
-(* The bits of INRIA's [Stdlib] that we just want to expose in [Float]. Most are
-   already deprecated in [Stdlib], and eventually all of them should be. *)
-include (
-  struct
-    include Stdlib
-    include Stdlib.Float
-  end :
-    sig
-      external frexp : float -> float * int = "caml_frexp_float"
-
-      external ldexp
-        :  (float[@unboxed])
-        -> (int[@untagged])
-        -> (float[@unboxed])
-        = "caml_ldexp_float" "caml_ldexp_float_unboxed"
-        [@@noalloc]
-
-      external log10 : float -> float = "caml_log10_float" "log10" [@@unboxed] [@@noalloc]
-
-      external log2 : float -> float = "caml_log2_float" "caml_log2"
-        [@@unboxed] [@@noalloc]
-
-      external expm1 : float -> float = "caml_expm1_float" "caml_expm1"
-        [@@unboxed] [@@noalloc]
-
-      external log1p : float -> float = "caml_log1p_float" "caml_log1p"
-        [@@unboxed] [@@noalloc]
-
-      external copysign : float -> float -> float = "caml_copysign_float" "caml_copysign"
-        [@@unboxed] [@@noalloc]
-
-      external cos : float -> float = "caml_cos_float" "cos" [@@unboxed] [@@noalloc]
-      external sin : float -> float = "caml_sin_float" "sin" [@@unboxed] [@@noalloc]
-      external tan : float -> float = "caml_tan_float" "tan" [@@unboxed] [@@noalloc]
-      external acos : float -> float = "caml_acos_float" "acos" [@@unboxed] [@@noalloc]
-      external asin : float -> float = "caml_asin_float" "asin" [@@unboxed] [@@noalloc]
-      external atan : float -> float = "caml_atan_float" "atan" [@@unboxed] [@@noalloc]
-
-      external acosh : float -> float = "caml_acosh_float" "caml_acosh"
-        [@@unboxed] [@@noalloc]
-
-      external asinh : float -> float = "caml_asinh_float" "caml_asinh"
-        [@@unboxed] [@@noalloc]
-
-      external atanh : float -> float = "caml_atanh_float" "caml_atanh"
-        [@@unboxed] [@@noalloc]
-
-      external atan2 : float -> float -> float = "caml_atan2_float" "atan2"
-        [@@unboxed] [@@noalloc]
-
-      external hypot : float -> float -> float = "caml_hypot_float" "caml_hypot"
-        [@@unboxed] [@@noalloc]
-
-      external cosh : float -> float = "caml_cosh_float" "cosh" [@@unboxed] [@@noalloc]
-      external sinh : float -> float = "caml_sinh_float" "sinh" [@@unboxed] [@@noalloc]
-      external tanh : float -> float = "caml_tanh_float" "tanh" [@@unboxed] [@@noalloc]
-      external sqrt : float -> float = "caml_sqrt_float" "sqrt" [@@unboxed] [@@noalloc]
-      external exp : float -> float = "caml_exp_float" "exp" [@@unboxed] [@@noalloc]
-      external log : float -> float = "caml_log_float" "log" [@@unboxed] [@@noalloc]
-    end)
-
-(* We need this indirection because these are exposed as "val" instead of "external" *)
-let frexp = frexp
-let ldexp = ldexp
 let is_nan x = (x : float) <> x
 
 (* An order-preserving bijection between all floats except for NaNs, and 99.95% of
@@ -106,7 +17,9 @@ let is_nan x = (x : float) <> x
    modern standard computers (i.e., implementing IEEE 754), one may in practice safely
    assume that the endianness is the same for floating point numbers as for integers"
    (http://en.wikipedia.org/wiki/Endianness#Floating-point_and_endianness).
-*)
+
+   N.b. the calls to [globalize_float] are no-ops at runtime since the float is unboxed
+   and then consumed by [bits_of_float], so the compiler knows not to re-box it. *)
 let to_int64_preserve_order t =
   if is_nan t
   then None
@@ -114,16 +27,18 @@ let to_int64_preserve_order t =
   then (* also includes -0. *)
     Some 0L
   else if t > 0.
-  then Some (Stdlib.Int64.bits_of_float t)
-  else Some (Stdlib.Int64.neg (Stdlib.Int64.bits_of_float (-.t)))
+  then Some (Stdlib.Int64.bits_of_float (globalize_float t))
+  else Some (Stdlib.Int64.neg (Stdlib.Int64.bits_of_float (globalize_float (-.t))))
 ;;
 
 let to_int64_preserve_order_exn x = Option.value_exn (to_int64_preserve_order x)
 
+(* N.b. the calls to [globalize_int64] are no-ops at runtime since the int64 is unboxed
+   and then consumed by [float_of_bits], so the compiler knows not to re-box it. *)
 let of_int64_preserve_order x =
   if Int64_replace_polymorphic_compare.( >= ) x 0L
-  then Stdlib.Int64.float_of_bits x
-  else ~-.(Stdlib.Int64.float_of_bits (Stdlib.Int64.neg x))
+  then Stdlib.Int64.float_of_bits (globalize_int64 x)
+  else ~-.(Stdlib.Int64.float_of_bits (globalize_int64 (Stdlib.Int64.neg x)))
 ;;
 
 let one_ulp dir t =
@@ -191,42 +106,15 @@ let lower_bound_for_int num_bits =
     min_int_as_float)
 ;;
 
-(* X86 docs say:
-
-   If only one value is a NaN (SNaN or QNaN) for this instruction, the second source
-   operand, either a NaN or a valid floating-point value
-   is written to the result.
-
-   So we have to be VERY careful how we use these!
-
-   These intrinsics were copied from [Ocaml_intrinsics] to avoid build deps we don't want
-*)
-module Intrinsics_with_weird_nan_behavior = struct
-  let[@inline always] min a b = Ocaml_intrinsics_kernel.Float.min a b
-  let[@inline always] max a b = Ocaml_intrinsics_kernel.Float.max a b
-end
-
-let clamp_unchecked
-  ~(to_clamp_maybe_nan : float)
-  ~min_which_is_not_nan
-  ~max_which_is_not_nan
-  =
-  (* We want to propagate nans; as per the x86 docs, this means we have to use them as the
-     _second_ argument. *)
-  let t_maybe_nan =
-    Intrinsics_with_weird_nan_behavior.max min_which_is_not_nan to_clamp_maybe_nan
-  in
-  Intrinsics_with_weird_nan_behavior.min max_which_is_not_nan t_maybe_nan
-;;
-
 let box =
-  (* Prevent potential constant folding of [+. 0.] in the near ocamlopt future. *)
-  let x = Sys0.opaque_identity 0. in
-  fun f -> f +. x
+  (* Prevent potential constant folding of [+. 0.] in the near ocamlopt future. The reason
+     we add -0 rather than 0 is that [x +. (-0.)] is apparently always the same as [x],
+     whereas [x +. 0.] is not, in that it sends [-0.] to [0.].
+
+     N.b. the call to [globalize_float] is a no-op at runtime since the float is unboxed
+     and then consumed by addition, so the compiler knows not to re-box it. The
+     implementation of flambda's heuristics is such that an arithmetic operation is
+     necessary for the behavior we want; it is insufficient to simply globalize it. *)
+  let x = Sys0.opaque_identity ~-.0. in
+  fun f -> globalize_float f +. x
 ;;
-
-(* Include type-specific [Replace_polymorphic_compare] at the end, after
-   including functor application that could shadow its definitions. This is
-   here so that efficient versions of the comparison functions are exported by
-   this module. *)
-include Float_replace_polymorphic_compare
diff --git a/src/float_stubs.c b/src/float_stubs.c
new file mode 100644
index 00000000..0f1a10ee
--- /dev/null
+++ b/src/float_stubs.c
@@ -0,0 +1,24 @@
+#include <math.h>
+#include <stdio.h>
+#include <caml/fail.h>
+#include <caml/alloc.h>
+
+#define MAX_EXCEPTION_MESSAGE_LENGTH 256
+
+double Base_caml_modf_positive_float_unboxed_exn(double a, double b) {
+  // Raise in case of a negative modulus, as does Int.( % ).
+  if (b < 0) {
+    char exception_message[MAX_EXCEPTION_MESSAGE_LENGTH];
+    sprintf(exception_message, "%.17g %% %.17g in float.ml: modulus should be positive",
+            a, b);
+    caml_invalid_argument(exception_message);
+  }
+  double m = fmod(a, b);
+  // Produce a non-negative result in analogy with Int.( % ).
+  return (m < 0) ? (m + b) : m;
+}
+
+CAMLprim value Base_caml_modf_positive_float_exn(value a, value b) {
+  return caml_copy_double(
+      Base_caml_modf_positive_float_unboxed_exn(Double_val(a), Double_val(b)));
+}
diff --git a/src/floatable.ml b/src/floatable.ml
index 92b42471..792dfd39 100644
--- a/src/floatable.ml
+++ b/src/floatable.ml
@@ -8,3 +8,10 @@ module type S = sig
   val of_float : float -> t
   val to_float : t -> float
 end
+
+module type S_local_input = sig
+  type t
+
+  val of_float : float -> t
+  val to_float : t -> float
+end
diff --git a/src/globalize.ml b/src/globalize.ml
index 671d6daa..f08d9c0d 100644
--- a/src/globalize.ml
+++ b/src/globalize.ml
@@ -25,9 +25,9 @@ external globalize_array' : 'a array -> 'a array = "caml_obj_dup"
 
 let globalize_array _ a = globalize_array' a
 
-let rec globalize_list f = function
+let[@tail_mod_cons] rec globalize_list f = function
   | [] -> []
-  | x :: xs -> f x :: globalize_list f xs
+  | x :: xs -> f x :: (globalize_list [@tailcall]) f xs
 ;;
 
 let globalize_option f = function
diff --git a/src/hash.ml b/src/hash.ml
index cb194fb8..c0c55e08 100644
--- a/src/hash.ml
+++ b/src/hash.ml
@@ -21,15 +21,14 @@
 open! Import0
 module Array = Array0
 module Char = Char0
-module Int = Int0
 module List = List0
 include Hash_intf
 
 (** Builtin folding-style hash functions, abstracted over [Hash_intf.S] *)
 module Folding (Hash : Hash_intf.S) :
   Hash_intf.Builtin_intf
-    with type state = Hash.state
-     and type hash_value = Hash.hash_value = struct
+  with type state = Hash.state
+   and type hash_value = Hash.hash_value = struct
   type state = Hash.state
   type hash_value = Hash.hash_value
   type 'a folder = state -> 'a -> state
@@ -117,9 +116,9 @@ end
 
 module F (Hash : Hash_intf.S) :
   Hash_intf.Full
-    with type hash_value = Hash.hash_value
-     and type state = Hash.state
-     and type seed = Hash.seed = struct
+  with type hash_value = Hash.hash_value
+   and type state = Hash.state
+   and type seed = Hash.seed = struct
   include Hash
 
   type 'a folder = state -> 'a -> state
@@ -137,19 +136,19 @@ end
 module Internalhash : sig
   include
     Hash_intf.S
-      with type state = Base_internalhash_types.state
-      (* We give a concrete type for [state], albeit only partially exposed (see
+    with type state = Base_internalhash_types.state
+    (* We give a concrete type for [state], albeit only partially exposed (see
         Base_internalhash_types), so that it unifies with the same type in [Base_boot],
         and to allow optimizations for the immediate type. *)
-       and type seed = Base_internalhash_types.seed
-       and type hash_value = Base_internalhash_types.hash_value
+     and type seed = Base_internalhash_types.seed
+     and type hash_value = Base_internalhash_types.hash_value
 
   external fold_int64
     :  state
     -> (int64[@unboxed])
     -> state
     = "Base_internalhash_fold_int64" "Base_internalhash_fold_int64_unboxed"
-    [@@noalloc]
+  [@@noalloc]
 
   external fold_int : state -> int -> state = "Base_internalhash_fold_int" [@@noalloc]
 
@@ -158,13 +157,13 @@ module Internalhash : sig
     -> (float[@unboxed])
     -> state
     = "Base_internalhash_fold_float" "Base_internalhash_fold_float_unboxed"
-    [@@noalloc]
+  [@@noalloc]
 
   external fold_string : state -> string -> state = "Base_internalhash_fold_string"
-    [@@noalloc]
+  [@@noalloc]
 
   external get_hash_value : state -> hash_value = "Base_internalhash_get_hash_value"
-    [@@noalloc]
+  [@@noalloc]
 end = struct
   let description = "internalhash"
 
@@ -174,8 +173,8 @@ end = struct
   let reset ?(seed = 0) _t = create_seeded seed
 
   module For_tests = struct
-    let compare_state (a : state) (b : state) = compare (a :> int) (b :> int)
-    let state_to_string (state : state) = Int.to_string (state :> int)
+    let compare_state = Base_internalhash_types.compare_state
+    let state_to_string = Base_internalhash_types.state_to_string
   end
 end
 
@@ -226,7 +225,7 @@ module T = struct
       :  (float[@unboxed])
       -> int
       = "Base_hash_double" "Base_hash_double_unboxed"
-      [@@noalloc]
+    [@@noalloc]
 
     let hash_unit () = 0
   end
diff --git a/src/hash_intf.ml b/src/hash_intf.ml
index 7717ee5c..704a3c10 100644
--- a/src/hash_intf.ml
+++ b/src/hash_intf.ml
@@ -128,9 +128,9 @@ module type Full = sig
 
   module Builtin :
     Builtin_intf
-      with type state := state
-       and type 'a folder := 'a folder
-       and type hash_value := hash_value
+    with type state := state
+     and type 'a folder := 'a folder
+     and type hash_value := hash_value
 
   (** [run ?seed folder x] runs [folder] on [x] in a newly allocated hash-state,
       initialized using optional [seed] or a default-seed.
@@ -147,9 +147,9 @@ module type Hash = sig
 
   module F (Hash : S) :
     Full
-      with type hash_value = Hash.hash_value
-       and type state = Hash.state
-       and type seed = Hash.seed
+    with type hash_value = Hash.hash_value
+     and type state = Hash.state
+     and type seed = Hash.seed
 
   (** The code of [ppx_hash] is agnostic to the choice of hash algorithm that is
       used. However, it is not currently possible to mix various choices of hash algorithms
@@ -189,7 +189,7 @@ module type Hash = sig
   (** @open *)
   include
     Full
-      with type state = Base_internalhash_types.state
-       and type seed = Base_internalhash_types.seed
-       and type hash_value = Base_internalhash_types.hash_value
+    with type state = Base_internalhash_types.state
+     and type seed = Base_internalhash_types.seed
+     and type hash_value = Base_internalhash_types.hash_value
 end
diff --git a/src/hash_set.ml b/src/hash_set.ml
index 4cf7d1d0..1c562523 100644
--- a/src/hash_set.ml
+++ b/src/hash_set.ml
@@ -130,18 +130,18 @@ let t_of_sexp m e_of_sexp sexp =
 ;;
 
 module Creators (Elt : sig
-  type 'a t
+    type 'a t
 
-  val hashable : 'a t Hashable.t
-end) : sig
+    val hashable : 'a t Hashable.t
+  end) : sig
   val t_of_sexp : (Sexp.t -> 'a Elt.t) -> Sexp.t -> 'a Elt.t t
 
   include
     Creators_generic
-      with type 'a t := 'a Elt.t t
-      with type 'a elt := 'a Elt.t
-      with type ('elt, 'z) create_options :=
-        ('elt, 'z) create_options_without_first_class_module
+    with type 'a t := 'a Elt.t t
+    with type 'a elt := 'a Elt.t
+    with type ('elt, 'z) create_options :=
+      ('elt, 'z) create_options_without_first_class_module
 end = struct
   let create ?growth_allowed ?size () =
     create ?growth_allowed ?size (Hashable.to_key Elt.hashable)
@@ -161,10 +161,10 @@ module Poly = struct
   let hashable = poly_hashable
 
   include Creators (struct
-    type 'a t = 'a
+      type 'a t = 'a
 
-    let hashable = hashable
-  end)
+      let hashable = hashable
+    end)
 
   include Accessors
 
diff --git a/src/hash_set_intf.ml b/src/hash_set_intf.ml
index cb29cc0f..83f3798e 100644
--- a/src/hash_set_intf.ml
+++ b/src/hash_set_intf.ml
@@ -180,27 +180,27 @@ module type Hash_set = sig
 
     include
       Creators_generic
-        with type 'a t := 'a t
-        with type 'a elt = 'a
-        with type ('key, 'z) create_options :=
-          ('key, 'z) create_options_without_first_class_module
+      with type 'a t := 'a t
+      with type 'a elt = 'a
+      with type ('key, 'z) create_options :=
+        ('key, 'z) create_options_without_first_class_module
 
     include Accessors with type 'a t := 'a t with type 'a elt := 'a elt
   end
 
   module Creators (Elt : sig
-    type 'a t
+      type 'a t
 
-    val hashable : 'a t Hashable.t
-  end) : sig
+      val hashable : 'a t Hashable.t
+    end) : sig
     val t_of_sexp : (Sexp.t -> 'a Elt.t) -> Sexp.t -> 'a Elt.t t
 
     include
       Creators_generic
-        with type 'a t := 'a Elt.t t
-        with type 'a elt := 'a Elt.t
-        with type ('elt, 'z) create_options :=
-          ('elt, 'z) create_options_without_first_class_module
+      with type 'a t := 'a Elt.t t
+      with type 'a elt := 'a Elt.t
+      with type ('elt, 'z) create_options :=
+        ('elt, 'z) create_options_without_first_class_module
   end
 
   include For_deriving with type 'a t := 'a t
diff --git a/src/hash_stubs.c b/src/hash_stubs.c
index e8f8c294..7017e472 100644
--- a/src/hash_stubs.c
+++ b/src/hash_stubs.c
@@ -3,12 +3,12 @@
 #include <stdint.h>
 
 /* Final mix and return from the hash.c implementation from INRIA */
-#define FINAL_MIX_AND_RETURN(h)                                                \
-  h ^= h >> 16;                                                                \
-  h *= 0x85ebca6b;                                                             \
-  h ^= h >> 13;                                                                \
-  h *= 0xc2b2ae35;                                                             \
-  h ^= h >> 16;                                                                \
+#define FINAL_MIX_AND_RETURN(h)                                                          \
+  h ^= h >> 16;                                                                          \
+  h *= 0x85ebca6b;                                                                       \
+  h ^= h >> 13;                                                                          \
+  h *= 0xc2b2ae35;                                                                       \
+  h ^= h >> 16;                                                                          \
   return Val_int(h & 0x3FFFFFFFU);
 
 CAMLprim value Base_hash_string(value string) {
diff --git a/src/hashtbl.ml b/src/hashtbl.ml
index f493040d..63af8a79 100644
--- a/src/hashtbl.ml
+++ b/src/hashtbl.ml
@@ -143,11 +143,14 @@ let add_exn t ~key ~data =
 ;;
 
 let clear t =
-  ensure_mutation_allowed t;
-  for i = 0 to Array.length t.table - 1 do
-    t.table.(i) <- Avltree.empty
-  done;
-  t.length <- 0
+  if t.length = 0
+  then ()
+  else (
+    ensure_mutation_allowed t;
+    for i = 0 to Array.length t.table - 1 do
+      t.table.(i) <- Avltree.empty
+    done;
+    t.length <- 0)
 ;;
 
 let find_and_call t key ~if_found ~if_not_found =
@@ -790,20 +793,20 @@ module Accessors = struct
 end
 
 module Creators (Key : sig
-  type 'a t
+    type 'a t
 
-  val hashable : 'a t Hashable.t
-end) : sig
+    val hashable : 'a t Hashable.t
+  end) : sig
   type ('a, 'b) t_ = ('a Key.t, 'b) t
 
   val t_of_sexp : (Sexp.t -> 'a Key.t) -> (Sexp.t -> 'b) -> Sexp.t -> ('a, 'b) t_
 
   include
     Creators_generic
-      with type ('a, 'b) t := ('a, 'b) t_
-      with type 'a key := 'a Key.t
-      with type ('key, 'data, 'a) create_options :=
-        ('key, 'data, 'a) create_options_without_first_class_module
+    with type ('a, 'b) t := ('a, 'b) t_
+    with type 'a key := 'a Key.t
+    with type ('key, 'data, 'a) create_options :=
+      ('key, 'data, 'a) create_options_without_first_class_module
 end = struct
   let hashable = Key.hashable
 
@@ -859,10 +862,10 @@ module Poly = struct
   let capacity = capacity
 
   include Creators (struct
-    type 'a t = 'a
+      type 'a t = 'a
 
-    let hashable = hashable
-  end)
+      let hashable = hashable
+    end)
 
   include Accessors
 
diff --git a/src/hashtbl_intf.ml b/src/hashtbl_intf.ml
index adb781af..3484b23d 100644
--- a/src/hashtbl_intf.ml
+++ b/src/hashtbl_intf.ml
@@ -27,49 +27,20 @@ module type Accessors = sig
   type ('a, 'b) t
   type 'a key
 
+  (** Attempting to modify ([set], [remove], etc.) the hashtable during iteration ([fold],
+      [iter], [iter_keys], [iteri]) will raise an exception. *)
+
   (** @inline *)
   include
     Dictionary_mutable.Accessors
-      with type 'key key := 'key key
-       and type ('key, 'data, _) t := ('key, 'data) t
-       and type ('fn, _, _, _) accessor := 'fn
+    with type 'key key := 'key key
+     and type ('key, 'data, _) t := ('key, 'data) t
+     and type ('fn, _, _, _) accessor := 'fn
 
   val sexp_of_key : ('a, _) t -> 'a key -> Sexp.t
-  val clear : (_, _) t -> unit
-  val copy : ('a, 'b) t -> ('a, 'b) t
-
-  (** Attempting to modify ([set], [remove], etc.) the hashtable during iteration ([fold],
-      [iter], [iter_keys], [iteri]) will raise an exception. *)
-  val fold : ('a, 'b) t -> init:'acc -> f:(key:'a key -> data:'b -> 'acc -> 'acc) -> 'acc
-
-  val iter_keys : ('a, _) t -> f:('a key -> unit) -> unit
-  val iter : (_, 'b) t -> f:('b -> unit) -> unit
-
-  (** Iterates over both keys and values.
-
-      Example:
-
-      {v
-      let h = Hashtbl.of_alist_exn (module Int) [(1, 4); (5, 6)] in
-      Hashtbl.iteri h ~f:(fun ~key ~data ->
-        print_endline (Printf.sprintf "%d-%d" key data));;
-      1-4
-      5-6
-      - : unit = ()
-      v} *)
-  val iteri : ('a, 'b) t -> f:(key:'a key -> data:'b -> unit) -> unit
-
-  val existsi : ('a, 'b) t -> f:(key:'a key -> data:'b -> bool) -> bool
-  val exists : (_, 'b) t -> f:('b -> bool) -> bool
-  val for_alli : ('a, 'b) t -> f:(key:'a key -> data:'b -> bool) -> bool
-  val for_all : (_, 'b) t -> f:('b -> bool) -> bool
-  val counti : ('a, 'b) t -> f:(key:'a key -> data:'b -> bool) -> int
-  val count : (_, 'b) t -> f:('b -> bool) -> int
-  val length : (_, _) t -> int
   val capacity : _ t -> int
-  val is_empty : (_, _) t -> bool
-  val mem : ('a, _) t -> 'a key -> bool
-  val remove : ('a, _) t -> 'a key -> unit
+
+  (** We redeclare [choose*] below to add implementation-specific notes on performance. *)
 
   (** Choose an arbitrary key/value pair of a hash table. Returns [None] if [t] is empty.
 
@@ -105,109 +76,6 @@ module type Accessors = sig
     -> ('a, 'b) t
     -> 'a key * 'b
 
-  (** Sets the given [key] to [data]. *)
-  val set : ('a, 'b) t -> key:'a key -> data:'b -> unit
-
-  (** [add] and [add_exn] leave the table unchanged if the key was already present. *)
-  val add : ('a, 'b) t -> key:'a key -> data:'b -> [ `Ok | `Duplicate ]
-
-  val add_exn : ('a, 'b) t -> key:'a key -> data:'b -> unit
-
-  (** [change t key ~f] changes [t]'s value for [key] to be [f (find t key)]. *)
-  val change : ('a, 'b) t -> 'a key -> f:('b option -> 'b option) -> unit
-
-  (** [update t key ~f] is [change t key ~f:(fun o -> Some (f o))]. *)
-  val update : ('a, 'b) t -> 'a key -> f:('b option -> 'b) -> unit
-
-  (** [update_and_return t key ~f] is [update], but returns the result of [f o]. *)
-  val update_and_return : ('a, 'b) t -> 'a key -> f:('b option -> 'b) -> 'b
-
-  (** [map t f] returns a new table with values replaced by the result of applying [f]
-      to the current values.
-
-      Example:
-
-      {v
-      let h = Hashtbl.of_alist_exn (module Int) [(1, 4); (5, 6)] in
-      let h' = Hashtbl.map h ~f:(local_ (fun x -> x * 2)) in
-      Hashtbl.to_alist h';;
-      - : (int * int) list = [(5, 12); (1, 8)]
-      v} *)
-  val map : ('a, 'b) t -> f:('b -> 'c) -> ('a, 'c) t
-
-  (** Like [map], but the function [f] takes both key and data as arguments. *)
-  val mapi : ('a, 'b) t -> f:(key:'a key -> data:'b -> 'c) -> ('a, 'c) t
-
-  (** Returns a new table by filtering the given table's values by [f]: the keys for which
-      [f] applied to the current value returns [Some] are kept, and those for which it
-      returns [None] are discarded.
-
-      Example:
-
-      {v
-      let h = Hashtbl.of_alist_exn (module Int) [(1, 4); (5, 6)] in
-      Hashtbl.filter_map h ~f:(local_ (fun x -> if x > 5 then Some x else None))
-      |> Hashtbl.to_alist;;
-      - : (int * int) list = [(5, 6)]
-      v} *)
-  val filter_map : ('a, 'b) t -> f:('b -> 'c option) -> ('a, 'c) t
-
-  (** Like [filter_map], but the function [f] takes both key and data as arguments. *)
-  val filter_mapi : ('a, 'b) t -> f:(key:'a key -> data:'b -> 'c option) -> ('a, 'c) t
-
-  val filter_keys : ('a, 'b) t -> f:('a key -> bool) -> ('a, 'b) t
-  val filter : ('a, 'b) t -> f:('b -> bool) -> ('a, 'b) t
-  val filteri : ('a, 'b) t -> f:(key:'a key -> data:'b -> bool) -> ('a, 'b) t
-
-  (** Returns new tables with bound values partitioned by [f] applied to the bound
-      values. *)
-  val partition_map : ('a, 'b) t -> f:('b -> ('c, 'd) Either.t) -> ('a, 'c) t * ('a, 'd) t
-
-  (** Like [partition_map], but the function [f] takes both key and data as arguments. *)
-  val partition_mapi
-    :  ('a, 'b) t
-    -> f:(key:'a key -> data:'b -> ('c, 'd) Either.t)
-    -> ('a, 'c) t * ('a, 'd) t
-
-  (** Returns a pair of tables [(t1, t2)], where [t1] contains all the elements of the
-      initial table which satisfy the predicate [f], and [t2] contains the rest. *)
-  val partition_tf : ('a, 'b) t -> f:('b -> bool) -> ('a, 'b) t * ('a, 'b) t
-
-  (** Like [partition_tf], but the function [f] takes both key and data as arguments. *)
-  val partitioni_tf
-    :  ('a, 'b) t
-    -> f:(key:'a key -> data:'b -> bool)
-    -> ('a, 'b) t * ('a, 'b) t
-
-  (** [find_or_add t k ~default] returns the data associated with key [k] if it is in the
-      table [t], and otherwise assigns [k] the value returned by [default ()]. *)
-  val find_or_add : ('a, 'b) t -> 'a key -> default:(unit -> 'b) -> 'b
-
-  (** Like [find_or_add] but [default] takes the key as an argument. *)
-  val findi_or_add : ('a, 'b) t -> 'a key -> default:('a key -> 'b) -> 'b
-
-  (** [find t k] returns [Some] (the current binding) of [k] in [t], or [None] if no such
-      binding exists. *)
-  val find : ('a, 'b) t -> 'a key -> 'b option
-
-  (** [find_exn t k] returns the current binding of [k] in [t], or raises [Stdlib.Not_found]
-      or [Not_found_s] if no such binding exists. *)
-  val find_exn : ('a, 'b) t -> 'a key -> 'b
-
-  (** [find_and_call t k ~if_found ~if_not_found]
-
-      is equivalent to:
-
-      [match find t k with Some v -> if_found v | None -> if_not_found k]
-
-      except that it doesn't allocate the option. *)
-  val find_and_call
-    :  ('a, 'b) t
-    -> 'a key
-    -> if_found:('b -> 'c)
-    -> if_not_found:('a key -> 'c)
-    -> 'c
-
   (** Just like [find_and_call], but takes an extra argument which is passed to [if_found]
       and [if_not_found], so that the client code can avoid allocating closures or using
       refs to pass this additional information.  This function is only useful in code
@@ -229,13 +97,6 @@ module type Accessors = sig
     -> if_not_found:('a key -> 'd -> 'e -> 'c)
     -> 'c
 
-  val findi_and_call
-    :  ('a, 'b) t
-    -> 'a key
-    -> if_found:(key:'a key -> data:'b -> 'c)
-    -> if_not_found:('a key -> 'c)
-    -> 'c
-
   val findi_and_call1
     :  ('a, 'b) t
     -> 'a key
@@ -253,91 +114,12 @@ module type Accessors = sig
     -> if_not_found:('a key -> 'd -> 'e -> 'c)
     -> 'c
 
-  (** [find_and_remove t k] returns Some (the current binding) of k in t and removes it,
-      or None is no such binding exists. *)
-  val find_and_remove : ('a, 'b) t -> 'a key -> 'b option
-
-  (** Merges two hashtables.
-
-      The result of [merge f h1 h2] has as keys the set of all [k] in the union of the
-      sets of keys of [h1] and [h2] for which [d(k)] is not None, where:
-
-      d(k) =
-      - [f ~key:k (`Left d1)]
-        if [k] in [h1] maps to d1, and [h2] does not have data for [k];
-
-      - [f ~key:k (`Right d2)]
-        if [k] in [h2] maps to d2, and [h1] does not have data for [k];
-
-      - [f ~key:k (`Both (d1, d2))]
-        otherwise, where [k] in [h1] maps to [d1] and [k] in [h2] maps to [d2].
-
-      Each key [k] is mapped to a single piece of data [x], where [d(k) = Some x].
-
-      Example:
-
-      {v
-      let h1 = Hashtbl.of_alist_exn (module Int) [(1, 5); (2, 3232)] in
-      let h2 = Hashtbl.of_alist_exn (module Int) [(1, 3)] in
-      Hashtbl.merge h1 h2 ~f:(fun ~key:_ -> function
-        | `Left x -> Some (`Left x)
-        | `Right x -> Some (`Right x)
-        | `Both (x, y) -> if x=y then None else Some (`Both (x,y))
-      ) |> Hashtbl.to_alist;;
-      - : (int * [> `Both of int * int | `Left of int | `Right of int ]) list =
-      [(2, `Left 3232); (1, `Both (5, 3))]
-      v} *)
-  val merge
-    :  ('k, 'a) t
-    -> ('k, 'b) t
-    -> f:(key:'k key -> [ `Left of 'a | `Right of 'b | `Both of 'a * 'b ] -> 'c option)
-    -> ('k, 'c) t
-
-  (** Every [key] in [src] will be removed or set in [dst] according to the return value
-      of [f]. *)
-  val merge_into
-    :  src:('k, 'a) t
-    -> dst:('k, 'b) t
-    -> f:(key:'k key -> 'a -> 'b option -> 'b Dictionary_mutable.Merge_into_action.t)
-    -> unit
-
-  (** Returns the list of all keys for given hashtable. *)
-  val keys : ('a, _) t -> 'a key list
-
-  (** Returns the list of all data for given hashtable. *)
-  val data : (_, 'b) t -> 'b list
-
-  (** [filter_inplace t ~f] removes all the elements from [t] that don't satisfy [f]. *)
-  val filter_keys_inplace : ('a, _) t -> f:('a key -> bool) -> unit
-
-  val filter_inplace : (_, 'b) t -> f:('b -> bool) -> unit
-  val filteri_inplace : ('a, 'b) t -> f:(key:'a key -> data:'b -> bool) -> unit
-
-  (** [map_inplace t ~f] applies [f] to all elements in [t], transforming them in
-      place. *)
-  val map_inplace : (_, 'b) t -> f:('b -> 'b) -> unit
-
-  val mapi_inplace : ('a, 'b) t -> f:(key:'a key -> data:'b -> 'b) -> unit
-
-  (** [filter_map_inplace] combines the effects of [map_inplace] and [filter_inplace]. *)
-  val filter_map_inplace : (_, 'b) t -> f:('b -> 'b option) -> unit
-
-  val filter_mapi_inplace : ('a, 'b) t -> f:(key:'a key -> data:'b -> 'b option) -> unit
-
   (** [equal f t1 t2] and [similar f t1 t2] both return true iff [t1] and [t2] have the
       same keys and for all keys [k], [f (find_exn t1 k) (find_exn t2 k)].  [equal] and
       [similar] only differ in their types. *)
   val equal : ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
 
   val similar : ('b1 -> 'b2 -> bool) -> ('a, 'b1) t -> ('a, 'b2) t -> bool
-
-  (** Returns the list of all (key, data) pairs for given hashtable. *)
-  val to_alist : ('a, 'b) t -> ('a key * 'b) list
-
-  (** [remove_if_zero]'s default is [false]. *)
-  val incr : ?by:int -> ?remove_if_zero:bool -> ('a, int) t -> 'a key -> unit
-
-  val decr : ?by:int -> ?remove_if_zero:bool -> ('a, int) t -> 'a key -> unit
 end
 
 module type Multi = sig
@@ -377,71 +159,9 @@ module type Creators_generic = sig
   (** @inline *)
   include
     Dictionary_mutable.Creators
-      with type 'key key := 'key key
-       and type ('key, 'data, _) t := ('key, 'data) t
-       and type ('fn, 'key, 'data, _) creator := ('key key, 'data, 'fn) create_options
-
-  val create : ('a key, 'b, unit -> ('a, 'b) t) create_options
-
-  val of_alist
-    : ( 'a key
-      , 'b
-      , ('a key * 'b) list -> [ `Ok of ('a, 'b) t | `Duplicate_key of 'a key ] )
-      create_options
-
-  val of_alist_report_all_dups
-    : ( 'a key
-      , 'b
-      , ('a key * 'b) list -> [ `Ok of ('a, 'b) t | `Duplicate_keys of 'a key list ] )
-      create_options
-
-  val of_alist_or_error
-    : ('a key, 'b, ('a key * 'b) list -> ('a, 'b) t Or_error.t) create_options
-
-  val of_alist_exn : ('a key, 'b, ('a key * 'b) list -> ('a, 'b) t) create_options
-
-  val of_alist_multi
-    : ('a key, 'b list, ('a key * 'b) list -> ('a, 'b list) t) create_options
-
-  (** {[ create_mapped get_key get_data [x1,...,xn]
-         = of_alist [get_key x1, get_data x1; ...; get_key xn, get_data xn] ]} *)
-  val create_mapped
-    : ( 'a key
-      , 'b
-      , get_key:('r -> 'a key)
-        -> get_data:('r -> 'b)
-        -> 'r list
-        -> [ `Ok of ('a, 'b) t | `Duplicate_keys of 'a key list ] )
-      create_options
-
-  (** {[ create_with_key ~get_key [x1,...,xn]
-         = of_alist [get_key x1, x1; ...; get_key xn, xn] ]} *)
-  val create_with_key
-    : ( 'a key
-      , 'r
-      , get_key:('r -> 'a key)
-        -> 'r list
-        -> [ `Ok of ('a, 'r) t | `Duplicate_keys of 'a key list ] )
-      create_options
-
-  val create_with_key_or_error
-    : ( 'a key
-      , 'r
-      , get_key:('r -> 'a key) -> 'r list -> ('a, 'r) t Or_error.t )
-      create_options
-
-  val create_with_key_exn
-    : ('a key, 'r, get_key:('r -> 'a key) -> 'r list -> ('a, 'r) t) create_options
-
-  val group
-    : ( 'a key
-      , 'b
-      , get_key:('r -> 'a key)
-        -> get_data:('r -> 'b)
-        -> combine:('b -> 'b -> 'b)
-        -> 'r list
-        -> ('a, 'b) t )
-      create_options
+    with type 'key key := 'key key
+     and type ('key, 'data, _) t := ('key, 'data) t
+     and type ('fn, 'key, 'data, _) creator := ('key key, 'data, 'fn) create_options
 end
 
 module type Creators = sig
@@ -660,10 +380,10 @@ module type S_poly = sig
 
   include
     Creators_generic
-      with type ('a, 'b) t := ('a, 'b) t
-      with type 'a key = 'a
-      with type ('key, 'data, 'z) create_options :=
-        ('key, 'data, 'z) create_options_without_first_class_module
+    with type ('a, 'b) t := ('a, 'b) t
+    with type 'a key = 'a
+    with type ('key, 'data, 'z) create_options :=
+      ('key, 'data, 'z) create_options_without_first_class_module
 
   include Accessors with type ('a, 'b) t := ('a, 'b) t with type 'a key := 'a key
   include Multi with type ('a, 'b) t := ('a, 'b) t with type 'a key := 'a key
@@ -815,20 +535,20 @@ module type Hashtbl = sig
   type nonrec ('key, 'data, 'z) create_options = ('key, 'data, 'z) create_options
 
   module Creators (Key : sig
-    type 'a t
+      type 'a t
 
-    val hashable : 'a t Hashable.t
-  end) : sig
+      val hashable : 'a t Hashable.t
+    end) : sig
     type ('a, 'b) t_ = ('a Key.t, 'b) t
 
     val t_of_sexp : (Sexp.t -> 'a Key.t) -> (Sexp.t -> 'b) -> Sexp.t -> ('a, 'b) t_
 
     include
       Creators_generic
-        with type ('a, 'b) t := ('a, 'b) t_
-        with type 'a key := 'a Key.t
-        with type ('key, 'data, 'a) create_options :=
-          ('key, 'data, 'a) create_options_without_first_class_module
+      with type ('a, 'b) t := ('a, 'b) t_
+      with type 'a key := 'a Key.t
+      with type ('key, 'data, 'a) create_options :=
+        ('key, 'data, 'a) create_options_without_first_class_module
   end
 
   module Poly : S_poly with type ('a, 'b) t = ('a, 'b) t
diff --git a/src/import.ml b/src/import.ml
index eb1215d3..63d27702 100644
--- a/src/import.ml
+++ b/src/import.ml
@@ -1,4 +1,5 @@
 include Import0
+include T
 include Sexplib0.Sexp_conv
 include Hash.Builtin
 include Ppx_compare_lib.Builtin
diff --git a/src/import0.ml b/src/import0.ml
index ab44ed57..b3b2f075 100644
--- a/src/import0.ml
+++ b/src/import0.ml
@@ -66,262 +66,48 @@ external ignore : _ -> unit = "%ignore"
 
 let ( != ) = Stdlib.( != )
 let ( * ) = Stdlib.( * )
-let ( ** ) = Stdlib.( ** )
-let ( *. ) = Stdlib.( *. )
-let ( + ) = Stdlib.( + )
-let ( +. ) = Stdlib.( +. )
-let ( - ) = Stdlib.( - )
-let ( -. ) = Stdlib.( -. )
-let ( / ) = Stdlib.( / )
-let ( /. ) = Stdlib.( /. )
-
-module Poly = Poly0 (** @canonical Base.Poly *)
-
-module Int_replace_polymorphic_compare = struct
-  (* Declared as externals so that the compiler skips the caml_apply_X wrapping even when
-     compiling without cross library inlining. *)
-  external ( = ) : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%equal"
-  external ( <> ) : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%notequal"
-  external ( < ) : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%lessthan"
-  external ( > ) : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%greaterthan"
-  external ( <= ) : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%lessequal"
-  external ( >= ) : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%greaterequal"
-  external compare : (int[@local_opt]) -> (int[@local_opt]) -> int = "%compare"
-  external compare__local : (int[@local_opt]) -> (int[@local_opt]) -> int = "%compare"
-  external equal : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%equal"
-  external equal__local : (int[@local_opt]) -> (int[@local_opt]) -> bool = "%equal"
-
-  let ascending (x : int) y = compare x y
-  let descending (x : int) y = compare y x
-  let max (x : int) y = Bool0.select (x >= y) x y
-  let min (x : int) y = Bool0.select (x <= y) x y
-end
-
-include Int_replace_polymorphic_compare
-
-module Int32_replace_polymorphic_compare = struct
-  let ( < ) (x : Stdlib.Int32.t) y = Poly.( < ) x y
-  let ( <= ) (x : Stdlib.Int32.t) y = Poly.( <= ) x y
-  let ( <> ) (x : Stdlib.Int32.t) y = Poly.( <> ) x y
-  let ( = ) (x : Stdlib.Int32.t) y = Poly.( = ) x y
-  let ( > ) (x : Stdlib.Int32.t) y = Poly.( > ) x y
-  let ( >= ) (x : Stdlib.Int32.t) y = Poly.( >= ) x y
-  let ascending (x : Stdlib.Int32.t) y = Poly.ascending x y
-  let descending (x : Stdlib.Int32.t) y = Poly.descending x y
-  let compare (x : Stdlib.Int32.t) y = Poly.compare x y
-  let compare__local (x : Stdlib.Int32.t) y = Poly.compare x y
-  let equal (x : Stdlib.Int32.t) y = Poly.equal x y
-  let equal__local (x : Stdlib.Int32.t) y = Poly.equal x y
-  let max (x : Stdlib.Int32.t) y = Bool0.select (x >= y) x y
-  let min (x : Stdlib.Int32.t) y = Bool0.select (x <= y) x y
-end
-
-module Int64_replace_polymorphic_compare = struct
-  (* Declared as externals so that the compiler skips the caml_apply_X wrapping even when
-     compiling without cross library inlining. *)
-  external ( = )
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%equal"
-
-  external ( <> )
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%notequal"
-
-  external ( < )
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%lessthan"
-
-  external ( > )
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%greaterthan"
-
-  external ( <= )
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%lessequal"
 
-  external ( >= )
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%greaterequal"
+external ( ** )
+  :  (float[@local_opt])
+  -> (float[@local_opt])
+  -> float
+  = "caml_power_float" "pow"
+[@@unboxed] [@@noalloc]
 
-  external compare
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> int
-    = "%compare"
-
-  external compare__local
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> int
-    = "%compare"
-
-  external equal
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%equal"
-
-  external equal__local
-    :  (Stdlib.Int64.t[@local_opt])
-    -> (Stdlib.Int64.t[@local_opt])
-    -> bool
-    = "%equal"
-
-  let ascending (x : Stdlib.Int64.t) y = Poly.ascending x y
-  let descending (x : Stdlib.Int64.t) y = Poly.descending x y
-  let max (x : Stdlib.Int64.t) y = Bool0.select (x >= y) x y
-  let min (x : Stdlib.Int64.t) y = Bool0.select (x <= y) x y
-end
+external ( *. )
+  :  (float[@local_opt])
+  -> (float[@local_opt])
+  -> (float[@local_opt])
+  = "%mulfloat"
 
-module Nativeint_replace_polymorphic_compare = struct
-  let ( < ) (x : Stdlib.Nativeint.t) y = Poly.( < ) x y
-  let ( <= ) (x : Stdlib.Nativeint.t) y = Poly.( <= ) x y
-  let ( <> ) (x : Stdlib.Nativeint.t) y = Poly.( <> ) x y
-  let ( = ) (x : Stdlib.Nativeint.t) y = Poly.( = ) x y
-  let ( > ) (x : Stdlib.Nativeint.t) y = Poly.( > ) x y
-  let ( >= ) (x : Stdlib.Nativeint.t) y = Poly.( >= ) x y
-  let ascending (x : Stdlib.Nativeint.t) y = Poly.ascending x y
-  let descending (x : Stdlib.Nativeint.t) y = Poly.descending x y
-  let compare (x : Stdlib.Nativeint.t) y = Poly.compare x y
-  let compare__local (x : Stdlib.Nativeint.t) y = Poly.compare x y
-  let equal (x : Stdlib.Nativeint.t) y = Poly.equal x y
-  let equal__local (x : Stdlib.Nativeint.t) y = Poly.equal x y
-  let max (x : Stdlib.Nativeint.t) y = Bool0.select (x >= y) x y
-  let min (x : Stdlib.Nativeint.t) y = Bool0.select (x <= y) x y
-end
-
-module Bool_replace_polymorphic_compare = struct
-  let ( < ) (x : bool) y = Poly.( < ) x y
-  let ( <= ) (x : bool) y = Poly.( <= ) x y
-  let ( <> ) (x : bool) y = Poly.( <> ) x y
-  let ( = ) (x : bool) y = Poly.( = ) x y
-  let ( > ) (x : bool) y = Poly.( > ) x y
-  let ( >= ) (x : bool) y = Poly.( >= ) x y
-  let ascending (x : bool) y = Poly.ascending x y
-  let descending (x : bool) y = Poly.descending x y
-  let compare (x : bool) y = Poly.compare x y
-  let compare__local (x : bool) y = Poly.compare x y
-  let equal (x : bool) y = Poly.equal x y
-  let equal__local (x : bool) y = Poly.equal x y
-  let max (x : bool) y = Bool0.select (x >= y) x y
-  let min (x : bool) y = Bool0.select (x <= y) x y
-end
-
-module Char_replace_polymorphic_compare = struct
-  let ( < ) (x : char) y = Poly.( < ) x y
-  let ( <= ) (x : char) y = Poly.( <= ) x y
-  let ( <> ) (x : char) y = Poly.( <> ) x y
-  let ( = ) (x : char) y = Poly.( = ) x y
-  let ( > ) (x : char) y = Poly.( > ) x y
-  let ( >= ) (x : char) y = Poly.( >= ) x y
-  let ascending (x : char) y = Poly.ascending x y
-  let descending (x : char) y = Poly.descending x y
-  let compare (x : char) y = Poly.compare x y
-  let compare__local (x : char) y = Poly.compare x y
-  let equal (x : char) y = Poly.equal x y
-  let equal__local (x : char) y = Poly.equal x y
-  let max (x : char) y = Bool0.select (x >= y) x y
-  let min (x : char) y = Bool0.select (x <= y) x y
-end
-
-module Uchar_replace_polymorphic_compare = struct
-  open struct
-    external i : (Stdlib.Uchar.t[@local_opt]) -> int = "%identity"
-  end
-
-  let ( < ) (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.( < ) (i x) (i y)
-  let ( <= ) (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.( <= ) (i x) (i y)
-  let ( <> ) (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.( <> ) (i x) (i y)
-  let ( = ) (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.( = ) (i x) (i y)
-  let ( > ) (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.( > ) (i x) (i y)
-  let ( >= ) (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.( >= ) (i x) (i y)
-
-  let ascending (x : Stdlib.Uchar.t) y =
-    Int_replace_polymorphic_compare.ascending (i x) (i y)
-  ;;
-
-  let descending (x : Stdlib.Uchar.t) y =
-    Int_replace_polymorphic_compare.descending (i x) (i y)
-  ;;
-
-  let compare (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.compare (i x) (i y)
-  let equal (x : Stdlib.Uchar.t) y = Int_replace_polymorphic_compare.equal (i x) (i y)
+let ( + ) = Stdlib.( + )
 
-  let compare__local (x : Stdlib.Uchar.t) y =
-    Int_replace_polymorphic_compare.compare__local (i x) (i y)
-  ;;
+external ( +. )
+  :  (float[@local_opt])
+  -> (float[@local_opt])
+  -> (float[@local_opt])
+  = "%addfloat"
 
-  let equal__local (x : Stdlib.Uchar.t) y =
-    Int_replace_polymorphic_compare.equal__local (i x) (i y)
-  ;;
+let ( - ) = Stdlib.( - )
 
-  let max (x : Stdlib.Uchar.t) y = Bool0.select (x >= y) x y
-  let min (x : Stdlib.Uchar.t) y = Bool0.select (x <= y) x y
-end
+external ( -. )
+  :  (float[@local_opt])
+  -> (float[@local_opt])
+  -> (float[@local_opt])
+  = "%subfloat"
 
-module Float_replace_polymorphic_compare = struct
-  external ( < ) : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%lessthan"
-  external ( <= ) : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%lessequal"
-  external ( <> ) : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%notequal"
-  external ( = ) : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%equal"
-  external ( > ) : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%greaterthan"
-  external ( >= ) : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%greaterequal"
-  external equal : (float[@local_opt]) -> (float[@local_opt]) -> bool = "%equal"
-  external compare : (float[@local_opt]) -> (float[@local_opt]) -> int = "%compare"
+let ( / ) = Stdlib.( / )
 
-  let ascending (x : float) y = Poly.ascending x y
-  let descending (x : float) y = Poly.descending x y
-  let compare__local (x : float) y = Poly.compare x y
-  let equal__local (x : float) y = Poly.equal x y
-  let max (x : float) y = Bool0.select (x >= y) x y
-  let min (x : float) y = Bool0.select (x <= y) x y
-end
+external ( /. )
+  :  (float[@local_opt])
+  -> (float[@local_opt])
+  -> (float[@local_opt])
+  = "%divfloat"
 
-module String_replace_polymorphic_compare = struct
-  let ( < ) (x : string) y = Poly.( < ) x y
-  let ( <= ) (x : string) y = Poly.( <= ) x y
-  let ( <> ) (x : string) y = Poly.( <> ) x y
-  let ( = ) (x : string) y = Poly.( = ) x y
-  let ( > ) (x : string) y = Poly.( > ) x y
-  let ( >= ) (x : string) y = Poly.( >= ) x y
-  let ascending (x : string) y = Poly.ascending x y
-  let descending (x : string) y = Poly.descending x y
-  let compare (x : string) y = Poly.compare x y
-  let compare__local (x : string) y = Poly.compare x y
-  let equal (x : string) y = Poly.equal x y
-  let equal__local (x : string) y = Poly.equal x y
-  let max (x : string) y = Bool0.select (x >= y) x y
-  let min (x : string) y = Bool0.select (x <= y) x y
-end
+module Poly = Poly0 (** @canonical Base.Poly *)
 
-module Bytes_replace_polymorphic_compare = struct
-  let ( < ) (x : bytes) y = Poly.( < ) x y
-  let ( <= ) (x : bytes) y = Poly.( <= ) x y
-  let ( <> ) (x : bytes) y = Poly.( <> ) x y
-  let ( = ) (x : bytes) y = Poly.( = ) x y
-  let ( > ) (x : bytes) y = Poly.( > ) x y
-  let ( >= ) (x : bytes) y = Poly.( >= ) x y
-  let ascending (x : bytes) y = Poly.ascending x y
-  let descending (x : bytes) y = Poly.descending x y
-  let compare (x : bytes) y = Poly.compare x y
-  let compare__local (x : bytes) y = Poly.compare x y
-  let equal (x : bytes) y = Poly.equal x y
-  let equal__local (x : bytes) y = Poly.equal x y
-  let max (x : bytes) y = Bool0.select (x >= y) x y
-  let min (x : bytes) y = Bool0.select (x <= y) x y
-end
+include Replace_polymorphic_compare
+include Int_replace_polymorphic_compare
 
 (* This needs to be defined as an external so that the compiler can specialize it as a
    direct set or caml_modify. *)
@@ -335,7 +121,9 @@ external ref : 'a -> ('a ref[@local_opt]) = "%makemutable"
 let ( @ ) = Stdlib.( @ )
 let ( ^ ) = Stdlib.( ^ )
 let ( ~- ) = Stdlib.( ~- )
-let ( ~-. ) = Stdlib.( ~-. )
+
+external ( ~-. ) : (float[@local_opt]) -> (float[@local_opt]) = "%negfloat"
+
 let ( asr ) = Stdlib.( asr )
 let ( land ) = Stdlib.( land )
 let lnot = Stdlib.lnot
diff --git a/src/indexed_container.ml b/src/indexed_container.ml
index 66e987f1..d2167211 100644
--- a/src/indexed_container.ml
+++ b/src/indexed_container.ml
@@ -9,7 +9,7 @@ let[@inline always] iteri ~fold t ~f =
     (fold t ~init:0 ~f:(fun i x ->
        f i x;
        i + 1)
-      : int)
+     : int)
 ;;
 
 let foldi ~fold t ~init ~f =
@@ -54,13 +54,13 @@ let findi ~iteri c ~f =
 (* Allows [Make_gen] to share a [Container.Generic] implementation with, e.g.,
    [Container.Make_gen_with_creators]. *)
 module Make_gen_with_container
-  (T : Make_gen_arg)
-  (C : Container.Generic
+    (T : Make_gen_arg)
+    (C : Container.Generic
          with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
           and type 'a elt := 'a T.elt) :
   Generic
-    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-     and type 'a elt := 'a T.elt = struct
+  with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+   and type 'a elt := 'a T.elt = struct
   include C
 
   let iteri =
@@ -85,8 +85,8 @@ end
 
 module Make_gen (T : Make_gen_arg) :
   Generic
-    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-     and type 'a elt := 'a T.elt = struct
+  with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+   and type 'a elt := 'a T.elt = struct
   module C = Container.Make_gen (T)
   include C
   include Make_gen_with_container (T) (C)
@@ -95,30 +95,30 @@ end
 
 module Make (T : Make_arg) = struct
   include Make_gen (struct
-    include T
+      include T
 
-    type ('a, _, _) t = 'a T.t
-    type 'a elt = 'a
-  end)
+      type ('a, _, _) t = 'a T.t
+      type 'a elt = 'a
+    end)
 end
 [@@inline always]
 
 module Make0 (T : Make0_arg) = struct
   include Make_gen (struct
-    include T
+      include T
 
-    type (_, _, _) t = T.t
-    type 'a elt = T.Elt.t
-  end)
+      type (_, _, _) t = T.t
+      type 'a elt = T.Elt.t
+    end)
 
   let mem t x = mem t x ~equal:T.Elt.equal
 end
 
 module Make_gen_with_creators (T : Make_gen_with_creators_arg) :
   Generic_with_creators
-    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-     and type 'a elt := 'a T.elt
-     and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat =
+  with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+   and type 'a elt := 'a T.elt
+   and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat =
 struct
   module C = Container.Make_gen_with_creators (T)
   include C
@@ -156,26 +156,26 @@ end
 
 module Make_with_creators (T : Make_with_creators_arg) = struct
   include Make_gen_with_creators (struct
-    include T
+      include T
 
-    type ('a, _, _) t = 'a T.t
-    type 'a elt = 'a
-    type ('a, _, _) concat = 'a T.t
+      type ('a, _, _) t = 'a T.t
+      type 'a elt = 'a
+      type ('a, _, _) concat = 'a T.t
 
-    let concat_of_array = of_array
-  end)
+      let concat_of_array = of_array
+    end)
 end
 
 module Make0_with_creators (T : Make0_with_creators_arg) = struct
   include Make_gen_with_creators (struct
-    include T
+      include T
 
-    type (_, _, _) t = T.t
-    type 'a elt = T.Elt.t
-    type ('a, _, _) concat = 'a list
+      type (_, _, _) t = T.t
+      type 'a elt = T.Elt.t
+      type ('a, _, _) concat = 'a list
 
-    let concat_of_array = Array.to_list
-  end)
+      let concat_of_array = Array.to_list
+    end)
 
   let mem t x = mem t x ~equal:T.Elt.equal
 end
diff --git a/src/indexed_container_intf.ml b/src/indexed_container_intf.ml
index 1ba9b4c1..c8431301 100644
--- a/src/indexed_container_intf.ml
+++ b/src/indexed_container_intf.ml
@@ -101,8 +101,8 @@ module type Generic_with_creators = sig
 
   include
     Generic
-      with type 'a elt := 'a elt
-       and type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) t
+    with type 'a elt := 'a elt
+     and type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) t
 
   val init : int -> f:(int -> 'a elt) -> ('a, _, _) t
   val mapi : ('a, 'p1, 'p2) t -> f:(int -> 'a elt -> 'b elt) -> ('b, 'p1, 'p2) t
@@ -156,9 +156,9 @@ module type Make_gen_with_creators_arg = sig
 
   include
     Make_common_with_creators_arg
-      with type ('a, 'p1, 'p2) t := ('a, 'p1, 'p2) t
-       and type 'a elt := 'a elt
-       and type ('a, 'p1, 'p2) concat := ('a, 'p1, 'p2) concat
+    with type ('a, 'p1, 'p2) t := ('a, 'p1, 'p2) t
+     and type 'a elt := 'a elt
+     and type ('a, 'p1, 'p2) concat := ('a, 'p1, 'p2) concat
 end
 
 module type Make_with_creators_arg = sig
@@ -166,9 +166,9 @@ module type Make_with_creators_arg = sig
 
   include
     Make_common_with_creators_arg
-      with type ('a, _, _) t := 'a t
-       and type 'a elt := 'a
-       and type ('a, _, _) concat := 'a t
+    with type ('a, _, _) t := 'a t
+     and type 'a elt := 'a
+     and type ('a, _, _) concat := 'a t
 end
 
 module type Make0_with_creators_arg = sig
@@ -176,9 +176,9 @@ module type Make0_with_creators_arg = sig
 
   include
     Make_common_with_creators_arg
-      with type ('a, _, _) t := t
-       and type 'a elt := Elt.t
-       and type ('a, _, _) concat := 'a list
+    with type ('a, _, _) t := t
+     and type 'a elt := Elt.t
+     and type ('a, _, _) concat := 'a list
 end
 
 module type Derived = sig
@@ -221,8 +221,8 @@ module type Indexed_container = sig
 
   module Make_gen (T : Make_gen_arg) :
     Generic
-      with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-       and type 'a elt := 'a T.elt
+    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+     and type 'a elt := 'a T.elt
 
   module Make_with_creators (T : Make_with_creators_arg) :
     S1_with_creators with type 'a t := 'a T.t
@@ -232,7 +232,7 @@ module type Indexed_container = sig
 
   module Make_gen_with_creators (T : Make_gen_with_creators_arg) :
     Generic_with_creators
-      with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
-       and type 'a elt := 'a T.elt
-       and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat
+    with type ('a, 'phantom1, 'phantom2) t := ('a, 'phantom1, 'phantom2) T.t
+     and type 'a elt := 'a T.elt
+     and type ('a, 'phantom1, 'phantom2) concat := ('a, 'phantom1, 'phantom2) T.concat
 end
diff --git a/src/info.ml b/src/info.ml
index 2fafed3d..3fd118bc 100644
--- a/src/info.ml
+++ b/src/info.ml
@@ -57,7 +57,7 @@ module Message = struct
        let res0__031_ = sexp_of_t arg0__029_
        and res1__032_ = sexp_of_string arg1__030_ in
        Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "With_backtrace"; res0__031_; res1__032_ ]
-      : t -> Sexplib0.Sexp.t)
+     : t -> Sexplib0.Sexp.t)
   ;;
 
   [@@@end]
@@ -287,11 +287,11 @@ let of_exn ?backtrace exn =
 ;;
 
 include Pretty_printer.Register_pp (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let module_name = "Base.Info"
-  let pp ppf t = Stdlib.Format.pp_print_string ppf (to_string_hum t)
-end)
+    let module_name = "Base.Info"
+    let pp ppf t = Stdlib.Format.pp_print_string ppf (to_string_hum t)
+  end)
 
 module Internal_repr = struct
   include Message
diff --git a/src/info_intf.ml b/src/info_intf.ml
index 5737c1ed..8e6e19e3 100644
--- a/src/info_intf.ml
+++ b/src/info_intf.ml
@@ -122,30 +122,30 @@ module type S = sig
   val pp : Formatter.t -> t -> unit
 
   module Internal_repr : sig
-    type info = t
+      type info = t
 
-    (** The internal representation.  It is exposed so that we can write efficient
+      (** The internal representation.  It is exposed so that we can write efficient
         serializers outside of this module. *)
-    type t =
-      | Could_not_construct of Sexp.t
-      | String of string
-      | Exn of exn
-      | Sexp of Sexp.t
-      | Tag_sexp of string * Sexp.t * Source_code_position0.t option
-      | Tag_t of string * t
-      | Tag_arg of string * Sexp.t * t
-      | Of_list of int option * t list
-      | With_backtrace of t * string (** The second argument is the backtrace *)
-    [@@deriving_inline sexp_of]
-
-    val sexp_of_t : t -> Sexplib0.Sexp.t
-
-    [@@@end]
-
-    val of_info : info -> t
-    val to_info : t -> info
-  end
-  with type info := t
+      type t =
+        | Could_not_construct of Sexp.t
+        | String of string
+        | Exn of exn
+        | Sexp of Sexp.t
+        | Tag_sexp of string * Sexp.t * Source_code_position0.t option
+        | Tag_t of string * t
+        | Tag_arg of string * Sexp.t * t
+        | Of_list of int option * t list
+        | With_backtrace of t * string (** The second argument is the backtrace *)
+      [@@deriving_inline sexp_of]
+
+      val sexp_of_t : t -> Sexplib0.Sexp.t
+
+      [@@@end]
+
+      val of_info : info -> t
+      val to_info : t -> info
+    end
+    with type info := t
 end
 
 module type Info = sig
diff --git a/src/int.ml b/src/int.ml
index f61fa80e..4a948d8c 100644
--- a/src/int.ml
+++ b/src/int.ml
@@ -35,7 +35,7 @@ end
 let num_bits = Int_conversions.num_bits_int
 let float_lower_bound = Float0.lower_bound_for_int num_bits
 let float_upper_bound = Float0.upper_bound_for_int num_bits
-let to_float = Stdlib.float_of_int
+let to_float = (Stdlib.float_of_int :> int -> _)
 let of_float_unchecked = Stdlib.int_of_float
 
 let of_float f =
@@ -57,46 +57,46 @@ include T
 include Comparator.Make (T)
 
 include Comparable.With_zero (struct
-  include T
+    include T
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 module Conv = Int_conversions
 include Int_string_conversions.Make (T)
 
 include Int_string_conversions.Make_hex (struct
-  open Int_replace_polymorphic_compare
+    open Int_replace_polymorphic_compare
 
-  type t = int [@@deriving_inline compare ~localize, hash]
+    type t = int [@@deriving_inline compare ~localize, hash]
 
-  let compare__local = (compare_int__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let compare__local = (compare_int__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
 
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_int
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_int
 
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_int in
-    fun x -> func x
-  ;;
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_int in
+      fun x -> func x
+    ;;
 
-  [@@@end]
+    [@@@end]
 
-  let zero = zero
-  let neg = ( ~- )
-  let ( < ) = ( < )
-  let to_string i = Printf.sprintf "%x" i
-  let of_string s = Stdlib.Scanf.sscanf s "%x" Fn.id
-  let module_name = "Base.Int.Hex"
-end)
+    let zero = zero
+    let neg = ( ~- )
+    let ( < ) = ( < )
+    let to_string i = Printf.sprintf "%x" i
+    let of_string s = Stdlib.Scanf.sscanf s "%x" Fn.id
+    let module_name = "Base.Int.Hex"
+  end)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = "Base.Int"
-end)
+    let to_string = to_string
+    let module_name = "Base.Int"
+  end)
 
 (* Open replace_polymorphic_compare after including functor instantiations so
    they do not shadow its definitions. This is here so that efficient versions
@@ -206,20 +206,8 @@ module Pow2 = struct
     x land (x - 1) = 0
   ;;
 
-  (* C stubs for int clz and ctz to use the CLZ/BSR/CTZ/BSF instruction where possible *)
-  external clz
-    :  (* Note that we pass the tagged int here. See int_math_stubs.c for details on why
-          this is correct. *)
-       int
-    -> (int[@untagged])
-    = "Base_int_math_int_clz" "Base_int_math_int_clz_untagged"
-    [@@noalloc]
-
-  external ctz
-    :  (int[@untagged])
-    -> (int[@untagged])
-    = "Base_int_math_int_ctz" "Base_int_math_int_ctz_untagged"
-    [@@noalloc]
+  let clz = Ocaml_intrinsics_kernel.Int.count_leading_zeros
+  let ctz = Ocaml_intrinsics_kernel.Int.count_trailing_zeros
 
   (** Hacker's Delight Second Edition p106 *)
   let floor_log2 i =
@@ -241,31 +229,31 @@ let sign = Sign.of_int
 let popcount = Popcount.int_popcount
 
 include Int_string_conversions.Make_binary (struct
-  type t = int [@@deriving_inline compare ~localize, equal ~localize, hash]
-
-  let compare__local = (compare_int__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
-  let equal__local = (equal_int__local : t -> t -> bool)
-  let equal = (fun a b -> equal__local a b : t -> t -> bool)
-
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_int
-
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_int in
-    fun x -> func x
-  ;;
-
-  [@@@end]
-
-  let ( land ) = ( land )
-  let ( lsr ) = ( lsr )
-  let clz = clz
-  let num_bits = num_bits
-  let one = one
-  let to_int_exn = to_int_exn
-  let zero = zero
-end)
+    type t = int [@@deriving_inline compare ~localize, equal ~localize, hash]
+
+    let compare__local = (compare_int__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let equal__local = (equal_int__local : t -> t -> bool)
+    let equal = (fun a b -> equal__local a b : t -> t -> bool)
+
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_int
+
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_int in
+      fun x -> func x
+    ;;
+
+    [@@@end]
+
+    let ( land ) = ( land )
+    let ( lsr ) = ( lsr )
+    let clz = clz
+    let num_bits = num_bits
+    let one = one
+    let to_int_exn = to_int_exn
+    let zero = zero
+  end)
 
 module Pre_O = struct
   external ( + ) : (t[@local_opt]) -> (t[@local_opt]) -> t = "%addint"
@@ -290,16 +278,16 @@ module O = struct
   include Pre_O
 
   module F = Int_math.Make (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    include Pre_O
+      include Pre_O
 
-    let rem = rem
-    let to_float = to_float
-    let of_float = of_float
-    let of_string = T.of_string
-    let to_string = T.to_string
-  end)
+      let rem = rem
+      let to_float = to_float
+      let of_float = of_float
+      let of_string = T.of_string
+      let to_string = T.to_string
+    end)
 
   include F
 
diff --git a/src/int32.ml b/src/int32.ml
index 936f39c1..dde2b41b 100644
--- a/src/int32.ml
+++ b/src/int32.ml
@@ -54,13 +54,20 @@ let one = one
 let zero = zero
 let compare = compare
 let compare__local = Stdlib.compare
-let to_float = to_float
-let of_float_unchecked = of_float
+
+external to_float : int32 -> float = "caml_int32_to_float" "caml_int32_to_float_unboxed"
+[@@unboxed] [@@noalloc]
+
+external of_float_unchecked
+  :  float
+  -> int32
+  = "caml_int32_of_float" "caml_int32_of_float_unboxed"
+[@@unboxed] [@@noalloc]
 
 let of_float f =
   if Float_replace_polymorphic_compare.( >= ) f float_lower_bound
      && Float_replace_polymorphic_compare.( <= ) f float_upper_bound
-  then of_float f
+  then of_float_unchecked f
   else
     Printf.invalid_argf
       "Int32.of_float: argument (%f) is out of range or NaN"
@@ -69,10 +76,10 @@ let of_float f =
 ;;
 
 include Comparable.With_zero (struct
-  include T
+    include T
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 module Infix_compare = struct
   open Poly
@@ -197,18 +204,8 @@ module Pow2 = struct
     x land Stdlib.Int32.pred x = Stdlib.Int32.zero
   ;;
 
-  (* C stubs for int32 clz and ctz to use the CLZ/BSR/CTZ/BSF instruction where possible *)
-  external clz
-    :  (int32[@unboxed])
-    -> (int[@untagged])
-    = "Base_int_math_int32_clz" "Base_int_math_int32_clz_unboxed"
-    [@@noalloc]
-
-  external ctz
-    :  (int32[@unboxed])
-    -> (int[@untagged])
-    = "Base_int_math_int32_ctz" "Base_int_math_int32_ctz_unboxed"
-    [@@noalloc]
+  let clz = Ocaml_intrinsics_kernel.Int32.count_leading_zeros
+  let ctz = Ocaml_intrinsics_kernel.Int32.count_trailing_zeros
 
   (** Hacker's Delight Second Edition p106 *)
   let floor_log2 i =
@@ -235,62 +232,62 @@ include Pow2
 include Int_string_conversions.Make (T)
 
 include Int_string_conversions.Make_hex (struct
-  type t = int32 [@@deriving_inline compare ~localize, hash]
+    type t = int32 [@@deriving_inline compare ~localize, hash]
 
-  let compare__local = (compare_int32__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let compare__local = (compare_int32__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
 
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_int32
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_int32
 
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_int32 in
-    fun x -> func x
-  ;;
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_int32 in
+      fun x -> func x
+    ;;
 
-  [@@@end]
+    [@@@end]
 
-  let zero = zero
-  let neg = ( ~- )
-  let ( < ) = ( < )
-  let to_string i = Printf.sprintf "%lx" i
-  let of_string s = Stdlib.Scanf.sscanf s "%lx" Fn.id
-  let module_name = "Base.Int32.Hex"
-end)
+    let zero = zero
+    let neg = ( ~- )
+    let ( < ) = ( < )
+    let to_string i = Printf.sprintf "%lx" i
+    let of_string s = Stdlib.Scanf.sscanf s "%lx" Fn.id
+    let module_name = "Base.Int32.Hex"
+  end)
 
 include Int_string_conversions.Make_binary (struct
-  type t = int32 [@@deriving_inline compare ~localize, equal ~localize, hash]
-
-  let compare__local = (compare_int32__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
-  let equal__local = (equal_int32__local : t -> t -> bool)
-  let equal = (fun a b -> equal__local a b : t -> t -> bool)
-
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_int32
-
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_int32 in
-    fun x -> func x
-  ;;
-
-  [@@@end]
-
-  let ( land ) = ( land )
-  let ( lsr ) = ( lsr )
-  let clz = clz
-  let num_bits = num_bits
-  let one = one
-  let to_int_exn = to_int_exn
-  let zero = zero
-end)
+    type t = int32 [@@deriving_inline compare ~localize, equal ~localize, hash]
+
+    let compare__local = (compare_int32__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let equal__local = (equal_int32__local : t -> t -> bool)
+    let equal = (fun a b -> equal__local a b : t -> t -> bool)
+
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_int32
+
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_int32 in
+      fun x -> func x
+    ;;
+
+    [@@@end]
+
+    let ( land ) = ( land )
+    let ( lsr ) = ( lsr )
+    let clz = clz
+    let num_bits = num_bits
+    let one = one
+    let to_int_exn = to_int_exn
+    let zero = zero
+  end)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = "Base.Int32"
-end)
+    let to_string = to_string
+    let module_name = "Base.Int32"
+  end)
 
 module Pre_O = struct
   let ( + ) = ( + )
@@ -312,16 +309,16 @@ module O = struct
   include Pre_O
 
   include Int_math.Make (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    include Pre_O
+      include Pre_O
 
-    let rem = rem
-    let to_float = to_float
-    let of_float = of_float
-    let of_string = T.of_string
-    let to_string = T.to_string
-  end)
+      let rem = rem
+      let to_float = to_float
+      let of_float = of_float
+      let of_string = T.of_string
+      let to_string = T.to_string
+    end)
 
   let ( land ) = bit_and
   let ( lor ) = bit_or
diff --git a/src/int63.ml b/src/int63.ml
index efa5d796..d83df3dc 100644
--- a/src/int63.ml
+++ b/src/int63.ml
@@ -1,4 +1,5 @@
 open! Import
+module _ = Popcount
 
 let raise_s = Error.raise_s
 
@@ -7,29 +8,29 @@ include Sys0.Make_immediate64 (Int) (Int63_emul)
 
 module Backend = struct
   module type S = sig
-    type t
-
-    include Int_intf.S with type t := t
-
-    val of_int : int -> t
-    val to_int : t -> int option
-    val to_int_trunc : t -> int
-    val of_int32 : int32 -> t
-    val to_int32 : t -> Int32.t option
-    val to_int32_trunc : t -> Int32.t
-    val of_int64 : Int64.t -> t option
-    val of_int64_trunc : Int64.t -> t
-    val of_nativeint : nativeint -> t option
-    val to_nativeint : t -> nativeint option
-    val of_nativeint_trunc : nativeint -> t
-    val to_nativeint_trunc : t -> nativeint
-    val of_float_unchecked : float -> t
-    val repr : (t, t) Int63_emul.Repr.t
-    val bswap16 : t -> t
-    val bswap32 : t -> t
-    val bswap48 : t -> t
-  end
-  with type t := t
+      type t
+
+      include Int_intf.S with type t := t
+
+      val of_int : int -> t
+      val to_int : t -> int option
+      val to_int_trunc : t -> int
+      val of_int32 : int32 -> t
+      val to_int32 : t -> Int32.t option
+      val to_int32_trunc : t -> Int32.t
+      val of_int64 : Int64.t -> t option
+      val of_int64_trunc : Int64.t -> t
+      val of_nativeint : nativeint -> t option
+      val to_nativeint : t -> nativeint option
+      val of_nativeint_trunc : nativeint -> t
+      val to_nativeint_trunc : t -> nativeint
+      val of_float_unchecked : float -> t
+      val repr : (t, t) Int63_emul.Repr.t
+      val bswap16 : t -> t
+      val bswap32 : t -> t
+      val bswap48 : t -> t
+    end
+    with type t := t
 
   module Native = struct
     include Int
diff --git a/src/int63_emul.ml b/src/int63_emul.ml
index 6293fb45..0b49c55c 100644
--- a/src/int63_emul.ml
+++ b/src/int63_emul.ml
@@ -95,16 +95,18 @@ end = struct
   let wrap_exn x =
     (* Raises if the int64 value does not fit on int63. *)
     Conv.int64_fit_on_int63_exn x;
-    Stdlib.Int64.mul x 2L
+    Stdlib.Int64.mul (globalize x) 2L
   ;;
 
   let wrap x =
-    if Conv.int64_is_representable_as_int63 x then Some (Stdlib.Int64.mul x 2L) else None
+    if Conv.int64_is_representable_as_int63 x
+    then Some (Stdlib.Int64.mul (globalize x) 2L)
+    else None
   ;;
 
-  let wrap_modulo x = Stdlib.Int64.mul x 2L
-  let unwrap x = Stdlib.Int64.shift_right x 1
-  let unwrap_unsigned x = Stdlib.Int64.shift_right_logical x 1
+  let wrap_modulo x = Stdlib.Int64.mul (globalize x) 2L
+  let unwrap x = Stdlib.Int64.shift_right (globalize x) 1
+  let unwrap_unsigned x = Stdlib.Int64.shift_right_logical (globalize x) 1
 
   (* This does not use wrap or unwrap to avoid generating exceptions in the case of
      overflows. This is to preserve the semantics of int type on 64 bit architecture. *)
@@ -302,13 +304,13 @@ let floor_log2 = floor_log2
 let ceil_log2 = ceil_log2
 let clz = clz
 let ctz = ctz
-let to_float x = Stdlib.Int64.to_float (unwrap x)
-let of_float_unchecked x = wrap_modulo (Stdlib.Int64.of_float x)
+let to_float x = Int64.to_float (unwrap x)
+let of_float_unchecked x = wrap_modulo (Int64.of_float_unchecked x)
 
 let of_float t =
   let open Float_replace_polymorphic_compare in
   if t >= float_lower_bound && t <= float_upper_bound
-  then wrap_modulo (Stdlib.Int64.of_float t)
+  then of_float_unchecked t
   else
     Printf.invalid_argf
       "Int63.of_float: argument (%f) is out of range or NaN"
@@ -322,10 +324,10 @@ let of_int64_trunc = of_int64_trunc
 let to_int64 = to_int64
 
 include Comparable.With_zero (struct
-  include T
+    include T
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 let between t ~low ~high = low <= t && t <= high
 let clamp_unchecked t ~min:min_ ~max:max_ = min t max_ |> max min_
@@ -375,40 +377,40 @@ let to_nativeint_trunc x = Conv.int64_to_nativeint_trunc (unwrap x)
 include Int_string_conversions.Make (T)
 
 include Int_string_conversions.Make_hex (struct
-  type t = T.t [@@deriving_inline compare ~localize, hash]
+    type t = T.t [@@deriving_inline compare ~localize, hash]
 
-  let compare__local = (T.compare__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let compare__local = (T.compare__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
 
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    T.hash_fold_t
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      T.hash_fold_t
 
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = T.hash in
-    fun x -> func x
-  ;;
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = T.hash in
+      fun x -> func x
+    ;;
 
-  [@@@end]
+    [@@@end]
 
-  let zero = zero
-  let neg = ( ~- )
-  let ( < ) = ( < )
+    let zero = zero
+    let neg = ( ~- )
+    let ( < ) = ( < )
 
-  let to_string i =
-    (* the use of [unwrap_unsigned] here is important for the case of [min_value] *)
-    Printf.sprintf "%Lx" (unwrap_unsigned i)
-  ;;
+    let to_string i =
+      (* the use of [unwrap_unsigned] here is important for the case of [min_value] *)
+      Printf.sprintf "%Lx" (unwrap_unsigned i)
+    ;;
 
-  let of_string s = of_string ("0x" ^ s)
-  let module_name = "Base.Int63.Hex"
-end)
+    let of_string s = of_string ("0x" ^ s)
+    let module_name = "Base.Int63.Hex"
+  end)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string x = to_string x
-  let module_name = "Base.Int63"
-end)
+    let to_string x = to_string x
+    let module_name = "Base.Int63"
+  end)
 
 module Pre_O = struct
   let ( + ) = ( + )
@@ -430,16 +432,16 @@ module O = struct
   include Pre_O
 
   include Int_math.Make (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    include Pre_O
+      include Pre_O
 
-    let rem = rem
-    let to_float = to_float
-    let of_float = of_float
-    let of_string = T.of_string
-    let to_string = T.to_string
-  end)
+      let rem = rem
+      let to_float = to_float
+      let of_float = of_float
+      let of_string = T.of_string
+      let to_string = T.to_string
+    end)
 
   let ( land ) = bit_and
   let ( lor ) = bit_or
@@ -453,31 +455,31 @@ end
 include O
 
 include Int_string_conversions.Make_binary (struct
-  type t = T.t [@@deriving_inline compare ~localize, equal ~localize, hash]
+    type t = T.t [@@deriving_inline compare ~localize, equal ~localize, hash]
 
-  let compare__local = (T.compare__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
-  let equal__local = (T.equal__local : t -> t -> bool)
-  let equal = (fun a b -> equal__local a b : t -> t -> bool)
+    let compare__local = (T.compare__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let equal__local = (T.equal__local : t -> t -> bool)
+    let equal = (fun a b -> equal__local a b : t -> t -> bool)
 
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    T.hash_fold_t
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      T.hash_fold_t
 
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = T.hash in
-    fun x -> func x
-  ;;
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = T.hash in
+      fun x -> func x
+    ;;
 
-  [@@@end]
+    [@@@end]
 
-  let ( land ) = ( land )
-  let ( lsr ) = ( lsr )
-  let clz = clz
-  let num_bits = num_bits
-  let one = one
-  let to_int_exn = to_int_exn
-  let zero = zero
-end)
+    let ( land ) = ( land )
+    let ( lsr ) = ( lsr )
+    let clz = clz
+    let num_bits = num_bits
+    let one = one
+    let to_int_exn = to_int_exn
+    let zero = zero
+  end)
 
 (* [Int63] and [Int63.O] agree value-wise *)
 
diff --git a/src/int63_emul.mli b/src/int63_emul.mli
index 82190bb0..ec731135 100644
--- a/src/int63_emul.mli
+++ b/src/int63_emul.mli
@@ -34,12 +34,12 @@ module W : sig
 end
 
 module Repr : sig
-  type emulated = t
+    type emulated = t
 
-  type ('underlying_type, 'intermediate_type) t =
-    | Int : (int, int) t
-    | Int64 : (int64, emulated) t
-end
-with type emulated := t
+    type ('underlying_type, 'intermediate_type) t =
+      | Int : (int, int) t
+      | Int64 : (int64, emulated) t
+  end
+  with type emulated := t
 
 val repr : (t, t) Repr.t
diff --git a/src/int64.ml b/src/int64.ml
index e13d9500..a628bdd7 100644
--- a/src/int64.ml
+++ b/src/int64.ml
@@ -36,15 +36,15 @@ let float_upper_bound = Float0.upper_bound_for_int num_bits
 
 external float_of_bits
   :  (int64[@local_opt])
-  -> (float[@local_opt])
+  -> float
   = "caml_int64_float_of_bits" "caml_int64_float_of_bits_unboxed"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 external bits_of_float
   :  (float[@local_opt])
-  -> (int64[@local_opt])
+  -> int64
   = "caml_int64_bits_of_float" "caml_int64_bits_of_float_unboxed"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 let shift_right_logical = shift_right_logical
 let shift_right = shift_right
@@ -64,13 +64,20 @@ let neg = neg
 let minus_one = minus_one
 let one = one
 let zero = zero
-let to_float = to_float
-let of_float_unchecked = Stdlib.Int64.of_float
+
+external to_float : int64 -> float = "caml_int64_to_float" "caml_int64_to_float_unboxed"
+[@@unboxed] [@@noalloc]
+
+external of_float_unchecked
+  :  float
+  -> int64
+  = "caml_int64_of_float" "caml_int64_of_float_unboxed"
+[@@unboxed] [@@noalloc]
 
 let of_float f =
   if Float_replace_polymorphic_compare.( >= ) f float_lower_bound
      && Float_replace_polymorphic_compare.( <= ) f float_upper_bound
-  then Stdlib.Int64.of_float f
+  then of_float_unchecked f
   else
     Printf.invalid_argf
       "Int64.of_float: argument (%f) is out of range or NaN"
@@ -97,10 +104,10 @@ let[@inline always] bswap32 x =
 let[@inline always] bswap48 x = Stdlib.Int64.shift_right_logical (bswap64 x) 16
 
 include Comparable.With_zero (struct
-  include T
+    include T
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 (* Open replace_polymorphic_compare after including functor instantiations so they do not
    shadow its definitions. This is here so that efficient versions of the comparison
@@ -205,18 +212,8 @@ module Pow2 = struct
     x land Stdlib.Int64.pred x = Stdlib.Int64.zero
   ;;
 
-  (* C stubs for int clz and ctz to use the CLZ/BSR/CTZ/BSF instruction where possible *)
-  external clz
-    :  (int64[@unboxed])
-    -> (int[@untagged])
-    = "Base_int_math_int64_clz" "Base_int_math_int64_clz_unboxed"
-    [@@noalloc]
-
-  external ctz
-    :  (int64[@unboxed])
-    -> (int[@untagged])
-    = "Base_int_math_int64_ctz" "Base_int_math_int64_ctz_unboxed"
-    [@@noalloc]
+  let clz = Ocaml_intrinsics_kernel.Int64.count_leading_zeros
+  let ctz = Ocaml_intrinsics_kernel.Int64.count_trailing_zeros
 
   (** Hacker's Delight Second Edition p106 *)
   let floor_log2 i =
@@ -242,62 +239,62 @@ include Pow2
 include Int_string_conversions.Make (T)
 
 include Int_string_conversions.Make_hex (struct
-  type t = int64 [@@deriving_inline compare ~localize, hash]
+    type t = int64 [@@deriving_inline compare ~localize, hash]
 
-  let compare__local = (compare_int64__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let compare__local = (compare_int64__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
 
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_int64
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_int64
 
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_int64 in
-    fun x -> func x
-  ;;
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_int64 in
+      fun x -> func x
+    ;;
 
-  [@@@end]
+    [@@@end]
 
-  let zero = zero
-  let neg = neg
-  let ( < ) = ( < )
-  let to_string i = Printf.sprintf "%Lx" i
-  let of_string s = Stdlib.Scanf.sscanf s "%Lx" Fn.id
-  let module_name = "Base.Int64.Hex"
-end)
+    let zero = zero
+    let neg = neg
+    let ( < ) = ( < )
+    let to_string i = Printf.sprintf "%Lx" i
+    let of_string s = Stdlib.Scanf.sscanf s "%Lx" Fn.id
+    let module_name = "Base.Int64.Hex"
+  end)
 
 include Int_string_conversions.Make_binary (struct
-  type t = int64 [@@deriving_inline compare ~localize, equal ~localize, hash]
-
-  let compare__local = (compare_int64__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
-  let equal__local = (equal_int64__local : t -> t -> bool)
-  let equal = (fun a b -> equal__local a b : t -> t -> bool)
-
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_int64
-
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_int64 in
-    fun x -> func x
-  ;;
-
-  [@@@end]
-
-  let ( land ) = ( land )
-  let ( lsr ) = ( lsr )
-  let clz = clz
-  let num_bits = num_bits
-  let one = one
-  let to_int_exn = to_int_exn
-  let zero = zero
-end)
+    type t = int64 [@@deriving_inline compare ~localize, equal ~localize, hash]
+
+    let compare__local = (compare_int64__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let equal__local = (equal_int64__local : t -> t -> bool)
+    let equal = (fun a b -> equal__local a b : t -> t -> bool)
+
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_int64
+
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_int64 in
+      fun x -> func x
+    ;;
+
+    [@@@end]
+
+    let ( land ) = ( land )
+    let ( lsr ) = ( lsr )
+    let clz = clz
+    let num_bits = num_bits
+    let one = one
+    let to_int_exn = to_int_exn
+    let zero = zero
+  end)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = "Base.Int64"
-end)
+    let to_string = to_string
+    let module_name = "Base.Int64"
+  end)
 
 module Pre_O = struct
   external ( + ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%int64_add"
@@ -322,16 +319,16 @@ module O = struct
   include Pre_O
 
   include Int_math.Make (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    include Pre_O
+      include Pre_O
 
-    let rem = rem
-    let to_float = to_float
-    let of_float = of_float
-    let of_string = T.of_string
-    let to_string = T.to_string
-  end)
+      let rem = rem
+      let to_float = to_float
+      let of_float = of_float
+      let of_string = T.of_string
+      let to_string = T.to_string
+    end)
 
   external ( land ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%int64_and"
   external ( lor ) : (t[@local_opt]) -> (t[@local_opt]) -> (t[@local_opt]) = "%int64_or"
diff --git a/src/int64.mli b/src/int64.mli
index ecc94af6..48c8b47a 100644
--- a/src/int64.mli
+++ b/src/int64.mli
@@ -91,17 +91,17 @@ external to_nativeint_trunc
     C function call is chosen by the compiler. *)
 external bits_of_float
   :  (float[@local_opt])
-  -> (int64[@local_opt])
+  -> int64
   = "caml_int64_bits_of_float" "caml_int64_bits_of_float_unboxed"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 (** [float_of_bits] will always allocate its result on the heap unless the [_unboxed]
     C function call is chosen by the compiler. *)
 external float_of_bits
   :  (int64[@local_opt])
-  -> (float[@local_opt])
+  -> float
   = "caml_int64_float_of_bits" "caml_int64_float_of_bits_unboxed"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 (** {2 Byte swap operations}
 
diff --git a/src/int_conversions.ml b/src/int_conversions.ml
index e845c0d2..97ecf2ff 100644
--- a/src/int_conversions.ml
+++ b/src/int_conversions.ml
@@ -9,7 +9,7 @@ let convert_failure x a b to_string =
     b
     (to_string x)
     ()
-  [@@cold] [@@inline never] [@@local never] [@@specialise never]
+[@@cold] [@@inline never] [@@local never] [@@specialise never]
 ;;
 
 let num_bits_int = Sys.int_size_in_bits
@@ -71,9 +71,11 @@ let int32_to_int_exn x =
 
 (* int <-> int64 *)
 
-let[@cold] int64_to_int_failure x =
+let[@cold] [@inline never] [@local never] [@specialise never] int64_to_int_failure x =
   convert_failure
-    (Stdlib.Int64.add x 0L (* force int64 boxing to be here under flambda2 *))
+    (Stdlib.Int64.add
+       (globalize_int64 x)
+       0L (* force int64 boxing to be here under flambda2 *))
     "int64"
     "int"
     int64_to_string
@@ -86,7 +88,7 @@ let int64_to_int_trunc = Stdlib.Int64.to_int
 let int64_is_representable_as_int =
   let min = int_to_int64 Int.min_value in
   let max = int_to_int64 Int.max_value in
-  fun x -> compare_int64 min x <= 0 && compare_int64 x max <= 0
+  fun x -> compare_int64__local min x <= 0 && compare_int64__local x max <= 0
 ;;
 
 let int64_to_int x =
@@ -207,12 +209,14 @@ let int64_to_nativeint_exn x =
 
 (* int64 <-> int63 *)
 
-let int64_to_int63_failure x = convert_failure x "int64" "int63" int64_to_string
+let int64_to_int63_failure x =
+  convert_failure (globalize_int64 x) "int64" "int63" int64_to_string
+;;
 
 let int64_is_representable_as_int63 =
   let min = Stdlib.Int64.shift_right min_int64 1 in
   let max = Stdlib.Int64.shift_right max_int64 1 in
-  fun x -> compare_int64 min x <= 0 && compare_int64 x max <= 0
+  fun x -> compare_int64__local min x <= 0 && compare_int64__local x max <= 0
 ;;
 
 let int64_fit_on_int63_exn x =
diff --git a/src/int_intf.ml b/src/int_intf.ml
index d7711e03..a3a0f29f 100644
--- a/src/int_intf.ml
+++ b/src/int_intf.ml
@@ -37,6 +37,19 @@ module type Round = sig
   val round_nearest : t -> to_multiple_of:t -> t
 end
 
+(** Human-readable serialization. *)
+module type To_string_hum = sig
+  type t
+
+  val to_string_hum : ?delimiter:char -> t -> string
+
+  (** Alias for [to_string_hum] where a submodule is more convenient, for instance:
+      [%string "%{x#Int.Hum}"] *)
+  module Hum : sig
+    val to_string : ?delimiter:char -> t -> string
+  end
+end
+
 (** String format for integers, [to_string] / [sexp_of_t] direction only. Includes
     comparisons and hash functions for [[@@deriving]]. *)
 module type To_string_format = sig
@@ -51,7 +64,8 @@ module type To_string_format = sig
   [@@@end]
 
   val to_string : t -> string
-  val to_string_hum : ?delimiter:char -> t -> string
+
+  include To_string_hum with type t := t
 end
 
 (** String format for integers, including both [to_string] / [sexp_of_t] and [of_string] /
@@ -70,8 +84,7 @@ module type String_format = sig
   [@@@end]
 
   include Stringable.S with type t := t
-
-  val to_string_hum : ?delimiter:char -> t -> string
+  include To_string_hum with type t := t
 end
 
 (** Binary format for integers, unsigned and starting with [0b]. *)
@@ -97,7 +110,7 @@ module type S_common = sig
 
   [@@@end]
 
-  include Floatable.S with type t := t
+  include Floatable.S_local_input with type t := t
   include Intable.S with type t := t
   include Identifiable.S with type t := t
   include Comparable.With_zero with type t := t
@@ -458,4 +471,5 @@ module type Int = sig
   module type S_unbounded = S_unbounded
   module type String_format = String_format
   module type To_string_format = To_string_format
+  module type To_string_hum = To_string_hum
 end
diff --git a/src/int_math.ml b/src/int_math.ml
index a04cc055..d27b6985 100644
--- a/src/int_math.ml
+++ b/src/int_math.ml
@@ -12,7 +12,7 @@ external int_math_int64_pow
   -> int64
   -> int64
   = "Base_int_math_int64_pow_stub" "Base_int_math_int64_pow_stub_unboxed"
-  [@@unboxed] [@@noalloc]
+[@@unboxed] [@@noalloc]
 
 let int_pow base exponent =
   if exponent < 0 then negative_exponent ();
diff --git a/src/int_math_stubs.c b/src/int_math_stubs.c
index d128e41b..e7dbcb76 100644
--- a/src/int_math_stubs.c
+++ b/src/int_math_stubs.c
@@ -9,9 +9,6 @@
 
 #include <intrin.h>
 
-#define __builtin_popcountll __popcnt64
-#define __builtin_popcount __popcnt
-
 static int __inline __builtin_clz(uint32_t x) {
   int r = 0;
   _BitScanReverse(&r, x);
@@ -23,8 +20,7 @@ static int __inline __builtin_clzll(uint64_t x) {
 #ifdef _WIN64
   _BitScanReverse64(&r, x);
 #else
-  if (!_BitScanReverse(&r, (uint32_t)x) &&
-      _BitScanReverse(&r, (uint32_t)(x >> 32))) {
+  if (!_BitScanReverse(&r, (uint32_t)x) && _BitScanReverse(&r, (uint32_t)(x >> 32))) {
     r += 32;
   }
 #endif
@@ -75,122 +71,12 @@ CAMLprim value Base_int_math_int_pow_stub(value base, value exponent) {
   return (Val_long(int_pow(Long_val(base), Long_val(exponent))));
 }
 
-CAMLprim int64_t Base_int_math_int64_pow_stub_unboxed(int64_t base,
-                                                      int64_t exponent) {
+CAMLprim int64_t Base_int_math_int64_pow_stub_unboxed(int64_t base, int64_t exponent) {
   return int_pow(base, exponent);
 }
 
 CAMLprim value Base_int_math_int64_pow_stub(value base, value exponent) {
   CAMLparam2(base, exponent);
-  CAMLreturn(caml_copy_int64(Base_int_math_int64_pow_stub_unboxed(
-      Int64_val(base), Int64_val(exponent))));
-}
-
-/* This implementation is faster than [__builtin_popcount(v) - 1], even though
- * it seems more complicated.  The [&] clears the shifted sign bit after
- * [Long_val] or [Int_val]. */
-CAMLprim value Base_int_math_int_popcount(value v) {
-#ifdef ARCH_SIXTYFOUR
-  return Val_int(__builtin_popcountll(Long_val(v) & ~((uint64_t)1 << 63)));
-#else
-  return Val_int(__builtin_popcount(Int_val(v) & ~((uint32_t)1 << 31)));
-#endif
-}
-
-/* The specification of all below [clz] and [ctz] functions are undefined for [v
- * = 0]. */
-
-/*
- * For an int [x] in the [2n + 1] representation:
- *
- *   clz(x) = __builtin_clz(x >> 1) - 1
- *
- * If [x] is negative, then the macro [Int_val] would perform a arithmetic
- * shift right, rather than a logical shift right, and sign extend the number.
- * Therefore
- *
- *   __builtin_clz(Int_val(x))
- *
- *  would always be zero, so
- *
- *    clz(x) = __builtin_clz(Int_val(x)) - 1
- *
- *  would always be -1. This is not what we want.
- *
- *  The logical shift right adds a leading zero to the argument of
- *  __builtin_clz, which the -1 accounts for. Rather than adding the leading
- *  zero and subtracting, we can just compute the clz of the tagged
- *  representation, and that should be equivalent, while also handing negative
- *  inputs correctly (the result will now be 0).
- */
-intnat Base_int_math_int_clz_untagged(value v) {
-#ifdef ARCH_SIXTYFOUR
-  return __builtin_clzll(v);
-#else
-  return __builtin_clz(v);
-#endif
-}
-
-CAMLprim value Base_int_math_int_clz(value v) {
-  return Val_int(Base_int_math_int_clz_untagged(v));
-}
-
-intnat Base_int_math_int32_clz_unboxed(int32_t v) { return __builtin_clz(v); }
-
-CAMLprim value Base_int_math_int32_clz(value v) {
-  return Val_int(Base_int_math_int32_clz_unboxed(Int32_val(v)));
-}
-
-intnat Base_int_math_int64_clz_unboxed(int64_t v) { return __builtin_clzll(v); }
-
-CAMLprim value Base_int_math_int64_clz(value v) {
-  return Val_int(Base_int_math_int64_clz_unboxed(Int64_val(v)));
-}
-
-intnat Base_int_math_nativeint_clz_unboxed(intnat v) {
-#ifdef ARCH_SIXTYFOUR
-  return __builtin_clzll(v);
-#else
-  return __builtin_clz(v);
-#endif
-}
-
-CAMLprim value Base_int_math_nativeint_clz(value v) {
-  return Val_int(Base_int_math_nativeint_clz_unboxed(Nativeint_val(v)));
-}
-
-intnat Base_int_math_int_ctz_untagged(intnat v) {
-#ifdef ARCH_SIXTYFOUR
-  return __builtin_ctzll(v);
-#else
-  return __builtin_ctz(v);
-#endif
-}
-
-CAMLprim value Base_int_math_int_ctz(value v) {
-  return Val_int(Base_int_math_int_ctz_untagged(Int_val(v)));
-}
-
-intnat Base_int_math_int32_ctz_unboxed(int32_t v) { return __builtin_ctz(v); }
-
-CAMLprim value Base_int_math_int32_ctz(value v) {
-  return Val_int(Base_int_math_int32_ctz_unboxed(Int32_val(v)));
-}
-
-intnat Base_int_math_int64_ctz_unboxed(int64_t v) { return __builtin_ctzll(v); }
-
-CAMLprim value Base_int_math_int64_ctz(value v) {
-  return Val_int(Base_int_math_int64_ctz_unboxed(Int64_val(v)));
-}
-
-intnat Base_int_math_nativeint_ctz_unboxed(intnat v) {
-#ifdef ARCH_SIXTYFOUR
-  return __builtin_ctzll(v);
-#else
-  return __builtin_ctz(v);
-#endif
-}
-
-CAMLprim value Base_int_math_nativeint_ctz(value v) {
-  return Val_int(Base_int_math_nativeint_ctz_unboxed(Nativeint_val(v)));
+  CAMLreturn(caml_copy_int64(
+      Base_int_math_int64_pow_stub_unboxed(Int64_val(base), Int64_val(exponent))));
 }
diff --git a/src/int_string_conversions.ml b/src/int_string_conversions.ml
index 3717ab4d..9e64de7f 100644
--- a/src/int_string_conversions.ml
+++ b/src/int_string_conversions.ml
@@ -43,10 +43,10 @@ let insert_underscores input = insert_delimiter input ~delimiter:'_'
 let sexp_of_int_style = Sexp.of_int_style
 
 module Make (I : sig
-  type t
+    type t
 
-  val to_string : t -> string
-end) =
+    val to_string : t -> string
+  end) =
 struct
   open I
 
@@ -66,21 +66,21 @@ struct
 end
 
 module Make_hex (I : sig
-  type t [@@deriving_inline compare ~localize, hash]
+    type t [@@deriving_inline compare ~localize, hash]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
-  include Ppx_compare_lib.Comparable.S_local with type t := t
-  include Ppx_hash_lib.Hashable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S_local with type t := t
+    include Ppx_hash_lib.Hashable.S with type t := t
 
-  [@@@end]
+    [@@@end]
 
-  val to_string : t -> string
-  val of_string : string -> t
-  val zero : t
-  val ( < ) : t -> t -> bool
-  val neg : t -> t
-  val module_name : string
-end) =
+    val to_string : t -> string
+    val of_string : string -> t
+    val zero : t
+    val ( < ) : t -> t -> bool
+    val neg : t -> t
+    val module_name : string
+  end) =
 struct
   module T_hex = struct
     type t = I.t [@@deriving_inline compare ~localize, hash]
@@ -138,28 +138,32 @@ struct
   module Hex = struct
     include T_hex
     include Sexpable.Of_stringable (T_hex)
+
+    module Hum = struct
+      let to_string = to_string_hum
+    end
   end
 end
 
 module Make_binary (I : sig
-  type t [@@deriving_inline compare ~localize, equal ~localize, hash]
-
-  include Ppx_compare_lib.Comparable.S with type t := t
-  include Ppx_compare_lib.Comparable.S_local with type t := t
-  include Ppx_compare_lib.Equal.S with type t := t
-  include Ppx_compare_lib.Equal.S_local with type t := t
-  include Ppx_hash_lib.Hashable.S with type t := t
-
-  [@@@end]
-
-  val clz : t -> int
-  val ( lsr ) : t -> int -> t
-  val ( land ) : t -> t -> t
-  val to_int_exn : t -> int
-  val num_bits : int
-  val zero : t
-  val one : t
-end) =
+    type t [@@deriving_inline compare ~localize, equal ~localize, hash]
+
+    include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S_local with type t := t
+    include Ppx_compare_lib.Equal.S with type t := t
+    include Ppx_compare_lib.Equal.S_local with type t := t
+    include Ppx_hash_lib.Hashable.S with type t := t
+
+    [@@@end]
+
+    val clz : t -> int
+    val ( lsr ) : t -> int -> t
+    val ( land ) : t -> t -> t
+    val to_int_exn : t -> int
+    val num_bits : int
+    val zero : t
+    val one : t
+  end) =
 struct
   module Binary = struct
     type t = I.t [@@deriving_inline compare ~localize, hash]
@@ -197,5 +201,9 @@ struct
     ;;
 
     let sexp_of_t (t : t) : Sexp.t = Atom (to_string_hum t)
+
+    module Hum = struct
+      let to_string = to_string_hum
+    end
   end
 end
diff --git a/src/int_string_conversions.mli b/src/int_string_conversions.mli
index 0b958cc7..a64d4c78 100644
--- a/src/int_string_conversions.mli
+++ b/src/int_string_conversions.mli
@@ -1,9 +1,9 @@
 (** human-friendly string (and possibly sexp) conversions *)
 module Make (I : sig
-  type t
+    type t
 
-  val to_string : t -> string
-end) : sig
+    val to_string : t -> string
+  end) : sig
   val to_string_hum : ?delimiter:char (** defaults to ['_'] *) -> I.t -> string
   val sexp_of_t : I.t -> Sexp.t
 end
@@ -11,49 +11,49 @@ end
 (** in the output, [to_string], [of_string], [sexp_of_t], and [t_of_sexp] convert
     between [t] and signed hexadecimal with an optional "0x" or "0X" prefix. *)
 module Make_hex (I : sig
-  type t [@@deriving_inline compare ~localize, hash]
+    type t [@@deriving_inline compare ~localize, hash]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
-  include Ppx_compare_lib.Comparable.S_local with type t := t
-  include Ppx_hash_lib.Hashable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S_local with type t := t
+    include Ppx_hash_lib.Hashable.S with type t := t
 
-  [@@@end]
+    [@@@end]
 
-  (** [to_string] and [of_string] convert between [t] and unsigned,
+    (** [to_string] and [of_string] convert between [t] and unsigned,
         unprefixed hexadecimal.
         They must be able to handle all non-negative values and also
         [min_value]. [to_string min_value] must write a positive hex
         representation. *)
-  val to_string : t -> string
+    val to_string : t -> string
 
-  val of_string : string -> t
-  val zero : t
-  val ( < ) : t -> t -> bool
-  val neg : t -> t
-  val module_name : string
-end) : Int_intf.Hexable with type t := I.t
+    val of_string : string -> t
+    val zero : t
+    val ( < ) : t -> t -> bool
+    val neg : t -> t
+    val module_name : string
+  end) : Int_intf.Hexable with type t := I.t
 
 (** in the output, [to_string], [to_string_hum], and [sexp_of_t] convert [t] to an
     unsigned binary representation with an "0b" prefix. *)
 module Make_binary (I : sig
-  type t [@@deriving_inline compare ~localize, equal ~localize, hash]
+    type t [@@deriving_inline compare ~localize, equal ~localize, hash]
 
-  include Ppx_compare_lib.Comparable.S with type t := t
-  include Ppx_compare_lib.Comparable.S_local with type t := t
-  include Ppx_compare_lib.Equal.S with type t := t
-  include Ppx_compare_lib.Equal.S_local with type t := t
-  include Ppx_hash_lib.Hashable.S with type t := t
+    include Ppx_compare_lib.Comparable.S with type t := t
+    include Ppx_compare_lib.Comparable.S_local with type t := t
+    include Ppx_compare_lib.Equal.S with type t := t
+    include Ppx_compare_lib.Equal.S_local with type t := t
+    include Ppx_hash_lib.Hashable.S with type t := t
 
-  [@@@end]
+    [@@@end]
 
-  val clz : t -> int
-  val ( lsr ) : t -> int -> t
-  val ( land ) : t -> t -> t
-  val to_int_exn : t -> int
-  val num_bits : int
-  val one : t
-  val zero : t
-end) : Int_intf.Binaryable with type t := I.t
+    val clz : t -> int
+    val ( lsr ) : t -> int -> t
+    val ( land ) : t -> t -> t
+    val to_int_exn : t -> int
+    val num_bits : int
+    val one : t
+    val zero : t
+  end) : Int_intf.Binaryable with type t := I.t
 
 (** global ref affecting whether the [sexp_of_t] returned by [Make]
     is consistent with the [to_string] input or the [to_string_hum] output *)
diff --git a/src/lazy.ml b/src/lazy.ml
index 8d244cdb..f5c1e9d7 100644
--- a/src/lazy.ml
+++ b/src/lazy.ml
@@ -32,13 +32,13 @@ let hash_fold_t = Hash.Builtin.hash_fold_lazy_t
 let peek t = if is_val t then Some (force t) else None
 
 include Monad.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let return x = from_val x
-  let bind t ~f = lazy (force (f (force t)))
-  let map = map
-  let map = `Custom map
-end)
+    let return x = from_val x
+    let bind t ~f = lazy (force (f (force t)))
+    let map = map
+    let map = `Custom map
+  end)
 
 module T_unforcing = struct
   type nonrec 'a t = 'a t
diff --git a/src/linked_queue.ml b/src/linked_queue.ml
index f3ba30df..e5ee0d0c 100644
--- a/src/linked_queue.ml
+++ b/src/linked_queue.ml
@@ -15,14 +15,14 @@ let drain t ~f ~while_ =
 ;;
 
 module C = Indexed_container.Make (struct
-  type nonrec 'a t = 'a t
-
-  let fold = fold
-  let iter = `Custom iter
-  let length = `Custom length
-  let foldi = `Define_using_fold
-  let iteri = `Define_using_fold
-end)
+    type nonrec 'a t = 'a t
+
+    let fold = fold
+    let iter = `Custom iter
+    let length = `Custom length
+    let foldi = `Define_using_fold
+    let iteri = `Define_using_fold
+  end)
 
 let count = C.count
 let exists = C.exists
diff --git a/src/list.ml b/src/list.ml
index 5cd98e9d..aa158508 100644
--- a/src/list.ml
+++ b/src/list.ml
@@ -572,7 +572,7 @@ let iteri l ~f =
     (fold l ~init:0 ~f:(fun i x ->
        f i x;
        i + 1)
-      : int)
+     : int)
 ;;
 
 let foldi t ~init ~f =
@@ -935,20 +935,20 @@ module Cartesian_product = struct
 
   open struct
     module Applicative = Applicative.Make_using_map2 (struct
-      type 'a t = 'a list
+        type 'a t = 'a list
 
-      let return = return
-      let map = `Custom map
-      let map2 = map2
-    end)
+        let return = return
+        let map = `Custom map
+        let map2 = map2
+      end)
 
     module Monad = Monad.Make (struct
-      type 'a t = 'a list
+        type 'a t = 'a list
 
-      let return = return
-      let map = `Custom map
-      let bind = bind
-    end)
+        let return = return
+        let map = `Custom map
+        let bind = bind
+      end)
   end
 
   let all = Monad.all
@@ -1217,8 +1217,8 @@ module Assoc = struct
     fun _of_a__027_ -> _of_a__027_
   ;;
 
-  let value_sexp_grammar :
-        'a. 'a Sexplib0.Sexp_grammar.t -> 'a value Sexplib0.Sexp_grammar.t
+  let value_sexp_grammar
+    : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a value Sexplib0.Sexp_grammar.t
     =
     fun _'a_sexp_grammar ->
     { untyped =
@@ -1236,35 +1236,29 @@ module Assoc = struct
     (('a key * 'b value) list[@tag Sexplib0.Sexp_grammar.assoc_tag = List []])
   [@@deriving_inline sexp, sexp_grammar]
 
-  let t_of_sexp :
-        'a 'b.
-        (Sexplib0.Sexp.t -> 'a)
-        -> (Sexplib0.Sexp.t -> 'b)
-        -> Sexplib0.Sexp.t
-        -> ('a, 'b) t
+  let t_of_sexp
+    : 'a 'b.
+    (Sexplib0.Sexp.t -> 'a) -> (Sexplib0.Sexp.t -> 'b) -> Sexplib0.Sexp.t -> ('a, 'b) t
     =
     let error_source__036_ = "list.ml.Assoc.t" in
     fun _of_a__028_ _of_b__029_ x__037_ ->
       list_of_sexp
         (function
-         | Sexplib0.Sexp.List [ arg0__031_; arg1__032_ ] ->
-           let res0__033_ = key_of_sexp _of_a__028_ arg0__031_
-           and res1__034_ = value_of_sexp _of_b__029_ arg1__032_ in
-           res0__033_, res1__034_
-         | sexp__035_ ->
-           Sexplib0.Sexp_conv_error.tuple_of_size_n_expected
-             error_source__036_
-             2
-             sexp__035_)
+          | Sexplib0.Sexp.List [ arg0__031_; arg1__032_ ] ->
+            let res0__033_ = key_of_sexp _of_a__028_ arg0__031_
+            and res1__034_ = value_of_sexp _of_b__029_ arg1__032_ in
+            res0__033_, res1__034_
+          | sexp__035_ ->
+            Sexplib0.Sexp_conv_error.tuple_of_size_n_expected
+              error_source__036_
+              2
+              sexp__035_)
         x__037_
   ;;
 
-  let sexp_of_t :
-        'a 'b.
-        ('a -> Sexplib0.Sexp.t)
-        -> ('b -> Sexplib0.Sexp.t)
-        -> ('a, 'b) t
-        -> Sexplib0.Sexp.t
+  let sexp_of_t
+    : 'a 'b.
+    ('a -> Sexplib0.Sexp.t) -> ('b -> Sexplib0.Sexp.t) -> ('a, 'b) t -> Sexplib0.Sexp.t
     =
     fun _of_a__038_ _of_b__039_ x__044_ ->
     sexp_of_list
@@ -1275,11 +1269,11 @@ module Assoc = struct
       x__044_
   ;;
 
-  let t_sexp_grammar :
-        'a 'b.
-        'a Sexplib0.Sexp_grammar.t
-        -> 'b Sexplib0.Sexp_grammar.t
-        -> ('a, 'b) t Sexplib0.Sexp_grammar.t
+  let t_sexp_grammar
+    : 'a 'b.
+    'a Sexplib0.Sexp_grammar.t
+    -> 'b Sexplib0.Sexp_grammar.t
+    -> ('a, 'b) t Sexplib0.Sexp_grammar.t
     =
     fun _'a_sexp_grammar _'b_sexp_grammar ->
     { untyped =
diff --git a/src/map.ml b/src/map.ml
index 61e62561..8f714fa0 100644
--- a/src/map.ml
+++ b/src/map.ml
@@ -116,8 +116,8 @@ module Tree0 = struct
     | Node { left = _; key = _; data = _; right = _; height = h } -> h
   ;;
 
-  let invariants =
-    let in_range lower upper compare_key k =
+  let order_invariants =
+    let in_range ~lower ~upper compare_key k =
       (match lower with
        | None -> true
        | Some lower -> compare_key lower k < 0)
@@ -126,22 +126,33 @@ module Tree0 = struct
       | None -> true
       | Some upper -> compare_key k upper < 0
     in
-    let rec loop lower upper compare_key t =
+    let rec loop ~lower ~upper compare_key t =
       match t with
       | Empty -> true
-      | Leaf { key = k; data = _ } -> in_range lower upper compare_key k
-      | Node { left = l; key = k; data = _; right = r; height = h } ->
-        let hl = height l
-        and hr = height r in
-        abs (hl - hr) <= 2
-        && h = max hl hr + 1
-        && in_range lower upper compare_key k
-        && loop lower (Some k) compare_key l
-        && loop (Some k) upper compare_key r
+      | Leaf { key = k; data = _ } -> in_range ~lower ~upper compare_key k
+      | Node { left = l; key = k; data = _; right = r; height = _ } ->
+        in_range ~lower ~upper compare_key k
+        && loop ~lower ~upper:(Some k) compare_key l
+        && loop ~lower:(Some k) ~upper compare_key r
     in
-    fun t ~compare_key -> loop None None compare_key t
+    fun t ~compare_key -> loop ~lower:None ~upper:None compare_key t
   ;;
 
+  let rec balance_invariants t =
+    match t with
+    | Empty | Leaf _ -> true
+    | Node { left = l; key = _; data = _; right = r; height = h } ->
+      let hl = height l
+      and hr = height r in
+      abs (hl - hr) <= 2
+      && h = max hl hr + 1
+      && h > 1
+      && balance_invariants l
+      && balance_invariants r
+  ;;
+
+  let invariants t ~compare_key = order_invariants t ~compare_key && balance_invariants t
+
   (* preconditions: |height(l) - height(r)| <= 2, hl = height(l), hr = height(r) *)
   let[@inline] create_with_heights ~hl ~hr l x d r =
     if hl = 0 && hr = 0
@@ -494,13 +505,13 @@ module Tree0 = struct
           seq
           ~init:(with_length_global Build_increasing.empty 0)
           ~f:(fun { tree = builder; length } (key, data) ->
-          match Build_increasing.max_key builder with
-          | Some prev_key when compare_key prev_key key >= 0 ->
-            return (Or_error.error_string "of_increasing_sequence: non-increasing key")
-          | _ ->
-            with_length_global
-              (Build_increasing.add_unchecked builder ~key ~data)
-              (length + 1))
+            match Build_increasing.max_key builder with
+            | Some prev_key when compare_key prev_key key >= 0 ->
+              return (Or_error.error_string "of_increasing_sequence: non-increasing key")
+            | _ ->
+              with_length_global
+                (Build_increasing.add_unchecked builder ~key ~data)
+                (length + 1))
       in
       Ok (with_length_global (Build_increasing.to_tree_unchecked builder) length))
   ;;
@@ -1049,9 +1060,9 @@ module Tree0 = struct
         t
         ~init:(Build_increasing.empty, Build_increasing.empty)
         ~f:(fun ~key ~data (t1, t2) ->
-        match (f ~key ~data : _ Either.t) with
-        | First x -> Build_increasing.add_unchecked t1 ~key ~data:x, t2
-        | Second y -> t1, Build_increasing.add_unchecked t2 ~key ~data:y)
+          match (f ~key ~data : _ Either.t) with
+          | First x -> Build_increasing.add_unchecked t1 ~key ~data:x, t2
+          | Second y -> t1, Build_increasing.add_unchecked t2 ~key ~data:y)
     in
     Build_increasing.to_tree_unchecked t1, Build_increasing.to_tree_unchecked t2
   ;;
@@ -1450,13 +1461,13 @@ module Tree0 = struct
       foldable
       ~init:(with_length_global empty 0)
       ~f:(fun { tree = accum; length } (key, data) ->
-      let prev_data =
-        match find accum key ~compare_key with
-        | None -> init
-        | Some prev -> prev
-      in
-      let data = f prev_data data in
-      (set accum ~length ~key ~data ~compare_key |> globalize) [@nontail]) [@nontail]
+        let prev_data =
+          match find accum key ~compare_key with
+          | None -> init
+          | Some prev -> prev
+        in
+        let data = f prev_data data in
+        (set accum ~length ~key ~data ~compare_key |> globalize) [@nontail]) [@nontail]
   ;;
 
   module Of_foldable (M : Foldable) = struct
@@ -1469,13 +1480,13 @@ module Tree0 = struct
         foldable
         ~init:(with_length_global empty 0)
         ~f:(fun { tree = accum; length } (key, data) ->
-        let new_data =
-          match find accum key ~compare_key with
-          | None -> data
-          | Some prev -> f prev data
-        in
-        (set accum ~length ~key ~data:new_data ~compare_key |> globalize) [@nontail]) [@nontail
-                                                                                        ]
+          let new_data =
+            match find accum key ~compare_key with
+            | None -> data
+            | Some prev -> f prev data
+          in
+          (set accum ~length ~key ~data:new_data ~compare_key |> globalize) [@nontail]) [@nontail
+                                                                                          ]
     ;;
 
     let of_foldable foldable ~compare_key =
@@ -1485,12 +1496,12 @@ module Tree0 = struct
             foldable
             ~init:(with_length_global empty 0)
             ~f:(fun { tree = t; length } (key, data) ->
-            let ({ tree = _; length = length' } as acc) =
-              set ~length ~key ~data t ~compare_key
-            in
-            if length = length'
-            then r.return (`Duplicate_key key)
-            else globalize acc [@nontail])
+              let ({ tree = _; length = length' } as acc) =
+                set ~length ~key ~data t ~compare_key
+              in
+              if length = length'
+              then r.return (`Duplicate_key key)
+              else globalize acc [@nontail])
         in
         `Ok map)
     ;;
@@ -1523,12 +1534,12 @@ module Tree0 = struct
   end
 
   module Of_alist = Of_foldable (struct
-    let name = "alist"
+      let name = "alist"
 
-    type 'a t = 'a list
+      type 'a t = 'a list
 
-    let fold = List.fold
-  end)
+      let fold = List.fold
+    end)
 
   let of_alist_fold = Of_alist.of_foldable_fold
   let of_alist_reduce = Of_alist.of_foldable_reduce
@@ -1538,12 +1549,12 @@ module Tree0 = struct
   let of_alist_multi = Of_alist.of_foldable_multi
 
   module Of_sequence = Of_foldable (struct
-    let name = "sequence"
+      let name = "sequence"
 
-    type 'a t = 'a Sequence.t
+      type 'a t = 'a Sequence.t
 
-    let fold = Sequence.fold
-  end)
+      let fold = Sequence.fold
+    end)
 
   let of_sequence_fold = Of_sequence.of_foldable_fold
   let of_sequence_reduce = Of_sequence.of_foldable_reduce
@@ -1559,13 +1570,13 @@ module Tree0 = struct
           list
           ~init:(with_length_global empty 0)
           ~f:(fun { tree = t; length } data ->
-          let key = get_key data in
-          let ({ tree = _; length = new_length } as acc) =
-            set ~length ~key ~data t ~compare_key
-          in
-          if length = new_length
-          then r.return (`Duplicate_key key)
-          else globalize acc [@nontail])
+            let key = get_key data in
+            let ({ tree = _; length = new_length } as acc) =
+              set ~length ~key ~data t ~compare_key
+            in
+            if length = new_length
+            then r.return (`Duplicate_key key)
+            else globalize acc [@nontail])
       in
       `Ok map) [@nontail]
   ;;
@@ -1684,10 +1695,10 @@ module Tree0 = struct
         t_small
         ~init:(with_length_global t_large length_large)
         ~f:(fun ~key ~data:data' { tree = t; length } ->
-        (update t key ~length ~compare_key ~f:(function
-           | None -> data'
-           | Some data -> call combine ~key data data')
-         |> globalize) [@nontail]) [@nontail]
+          (update t key ~length ~compare_key ~f:(function
+             | None -> data'
+             | Some data -> call combine ~key data data')
+           |> globalize) [@nontail]) [@nontail]
     in
     let call f ~key x y = f ~key x y in
     let swap f ~key x y = f ~key y x in
@@ -1705,8 +1716,8 @@ module Tree0 = struct
       ~length2
       ~compare_key:comparator.compare
       ~combine:(fun ~key _ _ ->
-      Error.create "Map.merge_disjoint_exn: duplicate key" key comparator.sexp_of_t
-      |> Error.raise)
+        Error.create "Map.merge_disjoint_exn: duplicate key" key comparator.sexp_of_t
+        |> Error.raise)
   ;;
 
   module Closest_key_impl = struct
@@ -1731,16 +1742,16 @@ module Tree0 = struct
     ;;
 
     (* The type signature is explicit here to allow polymorphic recursion. *)
-    let rec loop :
-              'k 'v 'k_opt 'v_opt.
-              ('k, 'v) tree
-              -> [ `Greater_or_equal_to | `Greater_than | `Less_or_equal_to | `Less_than ]
-              -> 'k
-              -> compare_key:('k -> 'k -> int)
-              -> ('k, 'v, 'k_opt, 'v_opt) marker
-              -> 'k_opt
-              -> 'v_opt
-              -> ('k * 'v) option
+    let rec loop
+      : 'k 'v 'k_opt 'v_opt.
+      ('k, 'v) tree
+      -> [ `Greater_or_equal_to | `Greater_than | `Less_or_equal_to | `Less_than ]
+      -> 'k
+      -> compare_key:('k -> 'k -> int)
+      -> ('k, 'v, 'k_opt, 'v_opt) marker
+      -> 'k_opt
+      -> 'v_opt
+      -> ('k * 'v) option
       =
       fun t dir k ~compare_key found_marker found_key found_value ->
       match t with
@@ -1992,11 +2003,12 @@ module Tree0 = struct
            t1
            ~init:(with_length_global empty 0)
            ~f:(fun ~key ~data { tree = t2; length } ->
-           let key = f key in
-           try
-             add_exn_internal t2 ~length ~key ~data ~compare_key ~sexp_of_key |> globalize
-           with
-           | Duplicate -> return (`Duplicate_key key)))) [@nontail]
+             let key = f key in
+             try
+               add_exn_internal t2 ~length ~key ~data ~compare_key ~sexp_of_key
+               |> globalize
+             with
+             | Duplicate -> return (`Duplicate_key key)))) [@nontail]
   ;;
 
   let map_keys_exn t ~f ~comparator =
@@ -2013,26 +2025,26 @@ module Tree0 = struct
       outer_t
       ~init:(with_length_global empty 0)
       ~f:(fun ~key:outer_key ~data:inner_t acc ->
-      fold
-        inner_t
-        ~init:acc
-        ~f:(fun ~key:inner_key ~data { tree = acc; length = acc_len } ->
-        (update
-           acc
-           inner_key
-           ~length:acc_len
-           ~compare_key:inner_comparator.Comparator.compare
-           ~f:(function
-           | None -> with_length_global (singleton outer_key data) 1
-           | Some { tree = elt; length = elt_len } ->
-             (set
-                elt
-                ~key:outer_key
-                ~data
-                ~length:elt_len
-                ~compare_key:outer_comparator.Comparator.compare
-              |> globalize) [@nontail])
-         |> globalize) [@nontail]))
+        fold
+          inner_t
+          ~init:acc
+          ~f:(fun ~key:inner_key ~data { tree = acc; length = acc_len } ->
+            (update
+               acc
+               inner_key
+               ~length:acc_len
+               ~compare_key:inner_comparator.Comparator.compare
+               ~f:(function
+               | None -> with_length_global (singleton outer_key data) 1
+               | Some { tree = elt; length = elt_len } ->
+                 (set
+                    elt
+                    ~key:outer_key
+                    ~data
+                    ~length:elt_len
+                    ~compare_key:outer_comparator.Comparator.compare
+                  |> globalize) [@nontail])
+             |> globalize) [@nontail]))
   ;;
 
   module Make_applicative_traversals (A : Applicative.Lazy_applicative) = struct
@@ -3177,9 +3189,9 @@ let map_keys_exn m t ~f = Using_comparator.map_keys_exn ~comparator:(to_comparat
 let transpose_keys m t = Using_comparator.transpose_keys ~comparator:(to_comparator m) t
 
 module M (K : sig
-  type t
-  type comparator_witness
-end) =
+    type t
+    type comparator_witness
+  end) =
 struct
   type nonrec 'v t = (K.t, 'v, K.comparator_witness) t
 end
@@ -3337,3 +3349,25 @@ module Poly = struct
   let map_keys_exn t ~f = Using_comparator.map_keys_exn ~comparator t ~f
   let transpose_keys t = Using_comparator.transpose_keys ~comparator t
 end
+
+module Private = struct
+  module Tree = struct
+    type ('k, 'v) t = ('k, 'v) Tree0.t
+
+    let balance_invariants t = Tree0.balance_invariants t
+    let are_balanced t1 t2 = abs (Tree0.height t1 - Tree0.height t2) <= 2
+    let are_almost_balanced t1 t2 = abs (Tree0.height t1 - Tree0.height t2) <= 3
+
+    let expose t =
+      match (t : (_, _) Tree0.t) with
+      | Empty -> None
+      | Leaf { key; data } -> Some (Tree0.Empty, key, data, Tree0.Empty)
+      | Node { left; key; data; right; _ } -> Some (left, key, data, right)
+    ;;
+
+    let empty = Tree0.Empty
+    let create_if_balanced = Tree0.create
+    let create_if_almost_balanced = Tree0.bal
+    let create_even_if_completely_unbalanced = Tree0.join
+  end
+end
diff --git a/src/map_intf.ml b/src/map_intf.ml
index 761ae7a8..2402d9fd 100644
--- a/src/map_intf.ml
+++ b/src/map_intf.ml
@@ -55,8 +55,8 @@ module Symmetric_diff_element = struct
   type ('k, 'v) t = 'k * [ `Left of 'v | `Right of 'v | `Unequal of 'v * 'v ]
   [@@deriving_inline compare, equal, sexp, sexp_grammar]
 
-  let compare :
-        'k 'v. ('k -> 'k -> int) -> ('v -> 'v -> int) -> ('k, 'v) t -> ('k, 'v) t -> int
+  let compare
+    : 'k 'v. ('k -> 'k -> int) -> ('v -> 'v -> int) -> ('k, 'v) t -> ('k, 'v) t -> int
     =
     fun _cmp__k _cmp__v a__011_ b__012_ ->
     let t__013_, t__014_ = a__011_ in
@@ -79,9 +79,8 @@ module Symmetric_diff_element = struct
     | n -> n
   ;;
 
-  let equal :
-        'k 'v.
-        ('k -> 'k -> bool) -> ('v -> 'v -> bool) -> ('k, 'v) t -> ('k, 'v) t -> bool
+  let equal
+    : 'k 'v. ('k -> 'k -> bool) -> ('v -> 'v -> bool) -> ('k, 'v) t -> ('k, 'v) t -> bool
     =
     fun _cmp__k _cmp__v a__027_ b__028_ ->
     let t__029_, t__030_ = a__027_ in
@@ -101,12 +100,9 @@ module Symmetric_diff_element = struct
          | x, y -> Stdlib.( = ) x y))
   ;;
 
-  let t_of_sexp :
-        'k 'v.
-        (Sexplib0.Sexp.t -> 'k)
-        -> (Sexplib0.Sexp.t -> 'v)
-        -> Sexplib0.Sexp.t
-        -> ('k, 'v) t
+  let t_of_sexp
+    : 'k 'v.
+    (Sexplib0.Sexp.t -> 'k) -> (Sexplib0.Sexp.t -> 'v) -> Sexplib0.Sexp.t -> ('k, 'v) t
     =
     let error_source__057_ = "map_intf.ml.Symmetric_diff_element.t" in
     fun _of_k__043_ _of_v__044_ -> function
@@ -189,12 +185,9 @@ module Symmetric_diff_element = struct
         Sexplib0.Sexp_conv_error.tuple_of_size_n_expected error_source__057_ 2 sexp__071_
   ;;
 
-  let sexp_of_t :
-        'k 'v.
-        ('k -> Sexplib0.Sexp.t)
-        -> ('v -> Sexplib0.Sexp.t)
-        -> ('k, 'v) t
-        -> Sexplib0.Sexp.t
+  let sexp_of_t
+    : 'k 'v.
+    ('k -> Sexplib0.Sexp.t) -> ('v -> Sexplib0.Sexp.t) -> ('k, 'v) t -> Sexplib0.Sexp.t
     =
     fun _of_k__072_ _of_v__073_ (arg0__081_, arg1__082_) ->
     let res0__083_ = _of_k__072_ arg0__081_
@@ -216,11 +209,11 @@ module Symmetric_diff_element = struct
     Sexplib0.Sexp.List [ res0__083_; res1__084_ ]
   ;;
 
-  let t_sexp_grammar :
-        'k 'v.
-        'k Sexplib0.Sexp_grammar.t
-        -> 'v Sexplib0.Sexp_grammar.t
-        -> ('k, 'v) t Sexplib0.Sexp_grammar.t
+  let t_sexp_grammar
+    : 'k 'v.
+    'k Sexplib0.Sexp_grammar.t
+    -> 'v Sexplib0.Sexp_grammar.t
+    -> ('k, 'v) t Sexplib0.Sexp_grammar.t
     =
     fun _'k_sexp_grammar _'v_sexp_grammar ->
     { untyped =
@@ -274,13 +267,13 @@ module Merge_element = struct
     ]
   [@@deriving_inline compare, equal, sexp_of]
 
-  let compare :
-        'left 'right.
-        ('left -> 'left -> int)
-        -> ('right -> 'right -> int)
-        -> ('left, 'right) t
-        -> ('left, 'right) t
-        -> int
+  let compare
+    : 'left 'right.
+    ('left -> 'left -> int)
+    -> ('right -> 'right -> int)
+    -> ('left, 'right) t
+    -> ('left, 'right) t
+    -> int
     =
     fun _cmp__left _cmp__right a__085_ b__086_ ->
     if Stdlib.( == ) a__085_ b__086_
@@ -298,13 +291,13 @@ module Merge_element = struct
       | x, y -> Stdlib.compare x y)
   ;;
 
-  let equal :
-        'left 'right.
-        ('left -> 'left -> bool)
-        -> ('right -> 'right -> bool)
-        -> ('left, 'right) t
-        -> ('left, 'right) t
-        -> bool
+  let equal
+    : 'left 'right.
+    ('left -> 'left -> bool)
+    -> ('right -> 'right -> bool)
+    -> ('left, 'right) t
+    -> ('left, 'right) t
+    -> bool
     =
     fun _cmp__left _cmp__right a__097_ b__098_ ->
     if Stdlib.( == ) a__097_ b__098_
@@ -320,12 +313,12 @@ module Merge_element = struct
       | x, y -> Stdlib.( = ) x y)
   ;;
 
-  let sexp_of_t :
-        'left 'right.
-        ('left -> Sexplib0.Sexp.t)
-        -> ('right -> Sexplib0.Sexp.t)
-        -> ('left, 'right) t
-        -> Sexplib0.Sexp.t
+  let sexp_of_t
+    : 'left 'right.
+    ('left -> Sexplib0.Sexp.t)
+    -> ('right -> Sexplib0.Sexp.t)
+    -> ('left, 'right) t
+    -> Sexplib0.Sexp.t
     =
     fun _of_left__109_ _of_right__110_ -> function
     | `Left v__111_ ->
@@ -360,7 +353,7 @@ module Continue_or_stop = struct
     (function
      | Continue -> Sexplib0.Sexp.Atom "Continue"
      | Stop -> Sexplib0.Sexp.Atom "Stop"
-      : t -> Sexplib0.Sexp.t)
+     : t -> Sexplib0.Sexp.t)
   ;;
 
   [@@@end]
@@ -381,7 +374,7 @@ module Finished_or_unfinished = struct
     (function
      | Finished -> Sexplib0.Sexp.Atom "Finished"
      | Unfinished -> Sexplib0.Sexp.Atom "Unfinished"
-      : t -> Sexplib0.Sexp.t)
+     : t -> Sexplib0.Sexp.t)
   ;;
 
   [@@@end]
@@ -397,62 +390,11 @@ module type Accessors_generic = sig
   (** @inline *)
   include
     Dictionary_immutable.Accessors
-      with type 'key key := 'key key
-       and type ('key, 'data, 'cmp) t := ('key, 'data, 'cmp) t
-       and type ('fn, 'key, _, 'cmp) accessor := ('key, 'cmp, 'fn) access_options
+    with type 'key key := 'key key
+     and type ('key, 'data, 'cmp) t := ('key, 'data, 'cmp) t
+     and type ('fn, 'key, _, 'cmp) accessor := ('key, 'cmp, 'fn) access_options
 
   val invariants : ('k, 'cmp, ('k, 'v, 'cmp) t -> bool) access_options
-  val is_empty : (_, _, _) t -> bool
-  val length : (_, _, _) t -> int
-
-  val add
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> key:'k key -> data:'v -> ('k, 'v, 'cmp) t Or_duplicate.t )
-      access_options
-
-  val add_exn
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> key:'k key -> data:'v -> ('k, 'v, 'cmp) t )
-      access_options
-
-  val set
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> key:'k key -> data:'v -> ('k, 'v, 'cmp) t )
-      access_options
-
-  val add_multi
-    : ( 'k
-      , 'cmp
-      , ('k, 'v list, 'cmp) t -> key:'k key -> data:'v -> ('k, 'v list, 'cmp) t )
-      access_options
-
-  val remove_multi
-    : ('k, 'cmp, ('k, 'v list, 'cmp) t -> 'k key -> ('k, 'v list, 'cmp) t) access_options
-
-  val find_multi : ('k, 'cmp, ('k, 'v list, 'cmp) t -> 'k key -> 'v list) access_options
-
-  val change
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> 'k key -> f:('v option -> 'v option) -> ('k, 'v, 'cmp) t )
-      access_options
-
-  val update
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> 'k key -> f:('v option -> 'v) -> ('k, 'v, 'cmp) t )
-      access_options
-
-  val find : ('k, 'cmp, ('k, 'v, 'cmp) t -> 'k key -> 'v option) access_options
-  val find_exn : ('k, 'cmp, ('k, 'v, 'cmp) t -> 'k key -> 'v) access_options
-  val remove : ('k, 'cmp, ('k, 'v, 'cmp) t -> 'k key -> ('k, 'v, 'cmp) t) access_options
-  val mem : ('k, 'cmp, ('k, _, 'cmp) t -> 'k key -> bool) access_options
-  val iter_keys : ('k, _, _) t -> f:('k key -> unit) -> unit
-  val iter : (_, 'v, _) t -> f:('v -> unit) -> unit
-  val iteri : ('k, 'v, _) t -> f:(key:'k key -> data:'v -> unit) -> unit
 
   val iteri_until
     :  ('k, 'v, _) t
@@ -461,28 +403,12 @@ module type Accessors_generic = sig
 
   val iter2
     : ( 'k
-      , 'cmp
-      , ('k, 'v1, 'cmp) t
-        -> ('k, 'v2, 'cmp) t
-        -> f:(key:'k key -> data:('v1, 'v2) Merge_element.t -> unit)
-        -> unit )
-      access_options
-
-  val map : ('k, 'v1, 'cmp) t -> f:('v1 -> 'v2) -> ('k, 'v2, 'cmp) t
-  val mapi : ('k, 'v1, 'cmp) t -> f:(key:'k key -> data:'v1 -> 'v2) -> ('k, 'v2, 'cmp) t
-
-  val fold
-    :  ('k, 'v, _) t
-    -> init:'acc
-    -> f:(key:'k key -> data:'v -> 'acc -> 'acc)
-    -> 'acc
-
-  val fold_until
-    :  ('k, 'v, _) t
-    -> init:'acc
-    -> f:(key:'k key -> data:'v -> 'acc -> ('acc, 'final) Container.Continue_or_stop.t)
-    -> finish:('acc -> 'final)
-    -> 'final
+        , 'cmp
+        , ('k, 'v1, 'cmp) t
+          -> ('k, 'v2, 'cmp) t
+          -> f:(key:'k key -> data:('v1, 'v2) Merge_element.t -> unit)
+          -> unit )
+        access_options
 
   val fold_right
     :  ('k, 'v, _) t
@@ -492,242 +418,152 @@ module type Accessors_generic = sig
 
   val fold2
     : ( 'k
-      , 'cmp
-      , ('k, 'v1, 'cmp) t
-        -> ('k, 'v2, 'cmp) t
-        -> init:'acc
-        -> f:(key:'k key -> data:('v1, 'v2) Merge_element.t -> 'acc -> 'acc)
-        -> 'acc )
-      access_options
-
-  val filter_keys : ('k, 'v, 'cmp) t -> f:('k key -> bool) -> ('k, 'v, 'cmp) t
-  val filter : ('k, 'v, 'cmp) t -> f:('v -> bool) -> ('k, 'v, 'cmp) t
-  val filteri : ('k, 'v, 'cmp) t -> f:(key:'k key -> data:'v -> bool) -> ('k, 'v, 'cmp) t
-  val filter_map : ('k, 'v1, 'cmp) t -> f:('v1 -> 'v2 option) -> ('k, 'v2, 'cmp) t
-
-  val filter_mapi
-    :  ('k, 'v1, 'cmp) t
-    -> f:(key:'k key -> data:'v1 -> 'v2 option)
-    -> ('k, 'v2, 'cmp) t
-
-  val partition_mapi
-    :  ('k, 'v1, 'cmp) t
-    -> f:(key:'k key -> data:'v1 -> ('v2, 'v3) Either.t)
-    -> ('k, 'v2, 'cmp) t * ('k, 'v3, 'cmp) t
-
-  val partition_map
-    :  ('k, 'v1, 'cmp) t
-    -> f:('v1 -> ('v2, 'v3) Either.t)
-    -> ('k, 'v2, 'cmp) t * ('k, 'v3, 'cmp) t
-
-  val partitioni_tf
-    :  ('k, 'v, 'cmp) t
-    -> f:(key:'k key -> data:'v -> bool)
-    -> ('k, 'v, 'cmp) t * ('k, 'v, 'cmp) t
-
-  val partition_tf
-    :  ('k, 'v, 'cmp) t
-    -> f:('v -> bool)
-    -> ('k, 'v, 'cmp) t * ('k, 'v, 'cmp) t
-
-  val combine_errors
-    : ( 'k
-      , 'cmp
-      , ('k, 'v Or_error.t, 'cmp) t -> ('k, 'v, 'cmp) t Or_error.t )
-      access_options
-
-  val unzip : ('k, 'v1 * 'v2, 'cmp) t -> ('k, 'v1, 'cmp) t * ('k, 'v2, 'cmp) t
+        , 'cmp
+        , ('k, 'v1, 'cmp) t
+          -> ('k, 'v2, 'cmp) t
+          -> init:'acc
+          -> f:(key:'k key -> data:('v1, 'v2) Merge_element.t -> 'acc -> 'acc)
+          -> 'acc )
+        access_options
 
   val compare_direct
     : ( 'k
-      , 'cmp
-      , ('v -> 'v -> int) -> ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) t -> int )
-      access_options
+        , 'cmp
+        , ('v -> 'v -> int) -> ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) t -> int )
+        access_options
 
   val equal
     : ( 'k
-      , 'cmp
-      , ('v -> 'v -> bool) -> ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) t -> bool )
-      access_options
-
-  val keys : ('k, _, _) t -> 'k key list
-  val data : (_, 'v, _) t -> 'v list
+        , 'cmp
+        , ('v -> 'v -> bool) -> ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) t -> bool )
+        access_options
 
   val to_alist
     :  ?key_order:[ `Increasing | `Decreasing ]
     -> ('k, 'v, _) t
     -> ('k key * 'v) list
 
-  val merge
+  val fold_range_inclusive
     : ( 'k
-      , 'cmp
-      , ('k, 'v1, 'cmp) t
-        -> ('k, 'v2, 'cmp) t
-        -> f:(key:'k key -> ('v1, 'v2) Merge_element.t -> 'v3 option)
-        -> ('k, 'v3, 'cmp) t )
-      access_options
-
-  val merge_disjoint_exn
-    : ('k, 'cmp, ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) t -> ('k, 'v, 'cmp) t) access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> min:'k key
+          -> max:'k key
+          -> init:'acc
+          -> f:(key:'k key -> data:'v -> 'acc -> 'acc)
+          -> 'acc )
+        access_options
 
-  val merge_skewed
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> ('k, 'v, 'cmp) t
-        -> combine:(key:'k key -> 'v -> 'v -> 'v)
-        -> ('k, 'v, 'cmp) t )
-      access_options
-
-  val symmetric_diff
+  val range_to_alist
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> ('k, 'v, 'cmp) t
-        -> data_equal:('v -> 'v -> bool)
-        -> ('k key, 'v) Symmetric_diff_element.t Sequence.t )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t -> min:'k key -> max:'k key -> ('k key * 'v) list )
+        access_options
 
-  val fold_symmetric_diff
+  val closest_key
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> ('k, 'v, 'cmp) t
-        -> data_equal:('v -> 'v -> bool)
-        -> init:'acc
-        -> f:('acc -> ('k key, 'v) Symmetric_diff_element.t -> 'acc)
-        -> 'acc )
-      access_options
-
-  val min_elt : ('k, 'v, _) t -> ('k key * 'v) option
-  val min_elt_exn : ('k, 'v, _) t -> 'k key * 'v
-  val max_elt : ('k, 'v, _) t -> ('k key * 'v) option
-  val max_elt_exn : ('k, 'v, _) t -> 'k key * 'v
-  val for_all : ('k, 'v, _) t -> f:('v -> bool) -> bool
-  val for_alli : ('k, 'v, _) t -> f:(key:'k key -> data:'v -> bool) -> bool
-  val exists : ('k, 'v, _) t -> f:('v -> bool) -> bool
-  val existsi : ('k, 'v, _) t -> f:(key:'k key -> data:'v -> bool) -> bool
-  val count : ('k, 'v, _) t -> f:('v -> bool) -> int
-  val counti : ('k, 'v, _) t -> f:(key:'k key -> data:'v -> bool) -> int
-
-  val sum
-    :  (module Container.Summable with type t = 'a)
-    -> ('k, 'v, _) t
-    -> f:('v -> 'a)
-    -> 'a
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> [ `Greater_or_equal_to | `Greater_than | `Less_or_equal_to | `Less_than ]
+          -> 'k key
+          -> ('k key * 'v) option )
+        access_options
 
-  val sumi
-    :  (module Container.Summable with type t = 'a)
-    -> ('k, 'v, _) t
-    -> f:(key:'k key -> data:'v -> 'a)
-    -> 'a
-
-  val split
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> 'k key
-        -> ('k, 'v, 'cmp) t * ('k key * 'v) option * ('k, 'v, 'cmp) t )
-      access_options
+  val nth : ('k, 'v, 'cmp) t -> int -> ('k key * 'v) option
+  val nth_exn : ('k, 'v, 'cmp) t -> int -> 'k key * 'v
+  val rank : ('k, 'cmp, ('k, _, 'cmp) t -> 'k key -> int option) access_options
+  val to_tree : ('k, 'v, 'cmp) t -> ('k key, 'v, 'cmp) tree
 
-  val split_le_gt
+  val to_sequence
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> 'k key -> ('k, 'v, 'cmp) t * ('k, 'v, 'cmp) t )
-      access_options
+        , 'cmp
+        , ?order:[ `Increasing_key | `Decreasing_key ]
+          -> ?keys_greater_or_equal_to:'k key
+          -> ?keys_less_or_equal_to:'k key
+          -> ('k, 'v, 'cmp) t
+          -> ('k key * 'v) Sequence.t )
+        access_options
 
-  val split_lt_ge
+  val binary_search
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> 'k key -> ('k, 'v, 'cmp) t * ('k, 'v, 'cmp) t )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> compare:(key:'k key -> data:'v -> 'key -> int)
+          -> Binary_searchable.Which_target_by_key.t
+          -> 'key
+          -> ('k key * 'v) option )
+        access_options
 
-  val append
+  val binary_search_segmented
     : ( 'k
-      , 'cmp
-      , lower_part:('k, 'v, 'cmp) t
-        -> upper_part:('k, 'v, 'cmp) t
-        -> [ `Ok of ('k, 'v, 'cmp) t | `Overlapping_key_ranges ] )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> segment_of:(key:'k key -> data:'v -> [ `Left | `Right ])
+          -> Binary_searchable.Which_target_by_segment.t
+          -> ('k key * 'v) option )
+        access_options
 
-  val subrange
+  val binary_search_subrange
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> lower_bound:'k key Maybe_bound.t
-        -> upper_bound:'k key Maybe_bound.t
-        -> ('k, 'v, 'cmp) t )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> compare:(key:'k key -> data:'v -> 'bound -> int)
+          -> lower_bound:'bound Maybe_bound.t
+          -> upper_bound:'bound Maybe_bound.t
+          -> ('k, 'v, 'cmp) t )
+        access_options
+end
 
-  val fold_range_inclusive
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> min:'k key
-        -> max:'k key
-        -> init:'acc
-        -> f:(key:'k key -> data:'v -> 'acc -> 'acc)
-        -> 'acc )
-      access_options
+module type Transformers_generic = sig
+  type ('a, 'b, 'cmp) t
+  type ('a, 'b, 'cmp) tree
+  type 'a key
+  type 'cmp cmp
+  type ('a, 'cmp, 'z) access_options
 
-  val range_to_alist
-    : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t -> min:'k key -> max:'k key -> ('k key * 'v) list )
-      access_options
+  (** @inline *)
+  include
+    Dictionary_immutable.Transformers
+    with type 'key key := 'key key
+     and type ('key, 'data, 'cmp) t := ('key, 'data, 'cmp) t
+     and type ('fn, 'key, _, 'cmp) transformer := ('key, 'cmp, 'fn) access_options
 
-  val closest_key
+  val split
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> [ `Greater_or_equal_to | `Greater_than | `Less_or_equal_to | `Less_than ]
-        -> 'k key
-        -> ('k key * 'v) option )
-      access_options
-
-  val nth : ('k, 'v, 'cmp) t -> int -> ('k key * 'v) option
-  val nth_exn : ('k, 'v, 'cmp) t -> int -> 'k key * 'v
-  val rank : ('k, 'cmp, ('k, _, 'cmp) t -> 'k key -> int option) access_options
-  val to_tree : ('k, 'v, 'cmp) t -> ('k key, 'v, 'cmp) tree
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> 'k key
+          -> ('k, 'v, 'cmp) t * ('k key * 'v) option * ('k, 'v, 'cmp) t )
+        access_options
 
-  val to_sequence
+  val split_le_gt
     : ( 'k
-      , 'cmp
-      , ?order:[ `Increasing_key | `Decreasing_key ]
-        -> ?keys_greater_or_equal_to:'k key
-        -> ?keys_less_or_equal_to:'k key
-        -> ('k, 'v, 'cmp) t
-        -> ('k key * 'v) Sequence.t )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t -> 'k key -> ('k, 'v, 'cmp) t * ('k, 'v, 'cmp) t )
+        access_options
 
-  val binary_search
+  val split_lt_ge
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> compare:(key:'k key -> data:'v -> 'key -> int)
-        -> Binary_searchable.Which_target_by_key.t
-        -> 'key
-        -> ('k key * 'v) option )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t -> 'k key -> ('k, 'v, 'cmp) t * ('k, 'v, 'cmp) t )
+        access_options
 
-  val binary_search_segmented
+  val append
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> segment_of:(key:'k key -> data:'v -> [ `Left | `Right ])
-        -> Binary_searchable.Which_target_by_segment.t
-        -> ('k key * 'v) option )
-      access_options
+        , 'cmp
+        , lower_part:('k, 'v, 'cmp) t
+          -> upper_part:('k, 'v, 'cmp) t
+          -> [ `Ok of ('k, 'v, 'cmp) t | `Overlapping_key_ranges ] )
+        access_options
 
-  val binary_search_subrange
+  val subrange
     : ( 'k
-      , 'cmp
-      , ('k, 'v, 'cmp) t
-        -> compare:(key:'k key -> data:'v -> 'bound -> int)
-        -> lower_bound:'bound Maybe_bound.t
-        -> upper_bound:'bound Maybe_bound.t
-        -> ('k, 'v, 'cmp) t )
-      access_options
+        , 'cmp
+        , ('k, 'v, 'cmp) t
+          -> lower_bound:'k key Maybe_bound.t
+          -> upper_bound:'k key Maybe_bound.t
+          -> ('k, 'v, 'cmp) t )
+        access_options
 
   module Make_applicative_traversals (A : Applicative.Lazy_applicative) : sig
     val mapi
@@ -753,35 +589,32 @@ module type Creators_generic = sig
   (** @inline *)
   include
     Dictionary_immutable.Creators
-      with type 'key key := 'key key
-       and type ('key, 'data, 'cmp) t := ('key, 'data, 'cmp) t
-       and type ('fn, 'key, _, 'cmp) creator := ('key, 'cmp, 'fn) create_options
-
-  val empty : ('k, 'cmp, ('k, _, 'cmp) t) create_options
-  val singleton : ('k, 'cmp, 'k key -> 'v -> ('k, 'v, 'cmp) t) create_options
+    with type 'key key := 'key key
+     and type ('key, 'data, 'cmp) t := ('key, 'data, 'cmp) t
+     and type ('fn, 'key, _, 'cmp) creator := ('key, 'cmp, 'fn) create_options
 
   val map_keys
     : ( 'k2
-      , 'cmp2
-      , ('k1, 'v, 'cmp1) t
-        -> f:('k1 key -> 'k2 key)
-        -> [ `Ok of ('k2, 'v, 'cmp2) t | `Duplicate_key of 'k2 key ] )
-      create_options
+        , 'cmp2
+        , ('k1, 'v, 'cmp1) t
+          -> f:('k1 key -> 'k2 key)
+          -> [ `Ok of ('k2, 'v, 'cmp2) t | `Duplicate_key of 'k2 key ] )
+        create_options
 
   val map_keys_exn
     : ( 'k2
-      , 'cmp2
-      , ('k1, 'v, 'cmp1) t -> f:('k1 key -> 'k2 key) -> ('k2, 'v, 'cmp2) t )
-      create_options
+        , 'cmp2
+        , ('k1, 'v, 'cmp1) t -> f:('k1 key -> 'k2 key) -> ('k2, 'v, 'cmp2) t )
+        create_options
 
   val transpose_keys
     : ( 'k1
-      , 'cmp1
-      , ( 'k2
-        , 'cmp2
-        , ('k1, ('k2, 'a, 'cmp2) t, 'cmp1) t -> ('k2, ('k1, 'a, 'cmp1) t, 'cmp2) t )
-        create_options )
-      access_options
+        , 'cmp1
+        , ( 'k2
+            , 'cmp2
+            , ('k1, ('k2, 'a, 'cmp2) t, 'cmp1) t -> ('k2, ('k1, 'a, 'cmp1) t, 'cmp2) t )
+            create_options )
+        access_options
 
   val of_sorted_array
     : ('k, 'cmp, ('k key * 'v) array -> ('k, 'v, 'cmp) t Or_error.t) create_options
@@ -792,122 +625,29 @@ module type Creators_generic = sig
   val of_increasing_iterator_unchecked
     : ('k, 'cmp, len:int -> f:(int -> 'k key * 'v) -> ('k, 'v, 'cmp) t) create_options
 
-  val of_alist
-    : ( 'k
-      , 'cmp
-      , ('k key * 'v) list -> [ `Ok of ('k, 'v, 'cmp) t | `Duplicate_key of 'k key ] )
-      create_options
-
-  val of_alist_or_error
-    : ('k, 'cmp, ('k key * 'v) list -> ('k, 'v, 'cmp) t Or_error.t) create_options
-
-  val of_alist_exn : ('k, 'cmp, ('k key * 'v) list -> ('k, 'v, 'cmp) t) create_options
-
-  val of_alist_multi
-    : ('k, 'cmp, ('k key * 'v) list -> ('k, 'v list, 'cmp) t) create_options
-
-  val of_alist_fold
-    : ( 'k
-      , 'cmp
-      , ('k key * 'v1) list -> init:'v2 -> f:('v2 -> 'v1 -> 'v2) -> ('k, 'v2, 'cmp) t )
-      create_options
-
-  val of_alist_reduce
-    : ( 'k
-      , 'cmp
-      , ('k key * 'v) list -> f:('v -> 'v -> 'v) -> ('k, 'v, 'cmp) t )
-      create_options
-
   val of_increasing_sequence
     : ('k, 'cmp, ('k key * 'v) Sequence.t -> ('k, 'v, 'cmp) t Or_error.t) create_options
 
-  val of_sequence
-    : ( 'k
-      , 'cmp
-      , ('k key * 'v) Sequence.t -> [ `Ok of ('k, 'v, 'cmp) t | `Duplicate_key of 'k key ]
-      )
-      create_options
-
-  val of_sequence_or_error
-    : ('k, 'cmp, ('k key * 'v) Sequence.t -> ('k, 'v, 'cmp) t Or_error.t) create_options
-
-  val of_sequence_exn
-    : ('k, 'cmp, ('k key * 'v) Sequence.t -> ('k, 'v, 'cmp) t) create_options
-
-  val of_sequence_multi
-    : ('k, 'cmp, ('k key * 'v) Sequence.t -> ('k, 'v list, 'cmp) t) create_options
-
-  val of_sequence_fold
-    : ( 'k
-      , 'cmp
-      , ('k key * 'v1) Sequence.t
-        -> init:'v2
-        -> f:('v2 -> 'v1 -> 'v2)
-        -> ('k, 'v2, 'cmp) t )
-      create_options
-
-  val of_sequence_reduce
-    : ( 'k
-      , 'cmp
-      , ('k key * 'v) Sequence.t -> f:('v -> 'v -> 'v) -> ('k, 'v, 'cmp) t )
-      create_options
-
-  val of_list_with_key
-    : ( 'k
-      , 'cmp
-      , 'v list
-        -> get_key:('v -> 'k key)
-        -> [ `Ok of ('k, 'v, 'cmp) t | `Duplicate_key of 'k key ] )
-      create_options
-
-  val of_list_with_key_or_error
-    : ( 'k
-      , 'cmp
-      , 'v list -> get_key:('v -> 'k key) -> ('k, 'v, 'cmp) t Or_error.t )
-      create_options
-
-  val of_list_with_key_exn
-    : ('k, 'cmp, 'v list -> get_key:('v -> 'k key) -> ('k, 'v, 'cmp) t) create_options
-
-  val of_list_with_key_multi
-    : ( 'k
-      , 'cmp
-      , 'v list -> get_key:('v -> 'k key) -> ('k, 'v list, 'cmp) t )
-      create_options
-
   val of_list_with_key_fold
     : ( 'k
-      , 'cmp
-      , 'v list
-        -> get_key:('v -> 'k key)
-        -> init:'acc
-        -> f:('acc -> 'v -> 'acc)
-        -> ('k, 'acc, 'cmp) t )
-      create_options
+        , 'cmp
+        , 'v list
+          -> get_key:('v -> 'k key)
+          -> init:'acc
+          -> f:('acc -> 'v -> 'acc)
+          -> ('k, 'acc, 'cmp) t )
+        create_options
 
   val of_list_with_key_reduce
     : ( 'k
-      , 'cmp
-      , 'v list -> get_key:('v -> 'k key) -> f:('v -> 'v -> 'v) -> ('k, 'v, 'cmp) t )
-      create_options
-
-  val of_iteri
-    : ( 'k
-      , 'cmp
-      , iteri:(f:(key:'k key -> data:'v -> unit) -> unit)
-        -> [ `Ok of ('k, 'v, 'cmp) t | `Duplicate_key of 'k key ] )
-      create_options
-
-  val of_iteri_exn
-    : ( 'k
-      , 'cmp
-      , iteri:(f:(key:'k key -> data:'v -> unit) -> unit) -> ('k, 'v, 'cmp) t )
-      create_options
+        , 'cmp
+        , 'v list -> get_key:('v -> 'k key) -> f:('v -> 'v -> 'v) -> ('k, 'v, 'cmp) t )
+        create_options
 
   val of_tree : ('k, 'cmp, ('k key, 'v, 'cmp) tree -> ('k, 'v, 'cmp) t) create_options
 end
 
-module type Creators_and_accessors_generic = sig
+module type Creators_and_accessors_and_transformers_generic = sig
   type ('a, 'b, 'c) t
   type ('a, 'b, 'c) tree
   type 'a key
@@ -917,20 +657,28 @@ module type Creators_and_accessors_generic = sig
 
   include
     Creators_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
-      with type 'a key := 'a key
-      with type 'a cmp := 'a cmp
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a key
+    with type 'a cmp := 'a cmp
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) create_options
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+
+  include
+    Transformers_generic
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a key
+    with type 'a cmp := 'a cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
 
   include
     Accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
-      with type 'a key := 'a key
-      with type 'a cmp := 'a cmp
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) tree
+    with type 'a key := 'a key
+    with type 'a cmp := 'a cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
 end
 
 module type S_poly = sig
@@ -939,13 +687,13 @@ module type S_poly = sig
   type comparator_witness
 
   include
-    Creators_and_accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b) t
-      with type ('a, 'b, 'c) tree := ('a, 'b) tree
-      with type 'k key := 'k
-      with type 'c cmp := comparator_witness
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    Creators_and_accessors_and_transformers_generic
+    with type ('a, 'b, 'c) t := ('a, 'b) t
+    with type ('a, 'b, 'c) tree := ('a, 'b) tree
+    with type 'k key := 'k
+    with type 'c cmp := comparator_witness
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
 end
 
 module type For_deriving = sig
@@ -1888,9 +1636,9 @@ module type Map = sig
       - a comparator witness
       - a [hash_fold_t] function with the right type *)
   module M (K : sig
-    type t
-    type comparator_witness
-  end) : sig
+      type t
+      type comparator_witness
+    end) : sig
     type nonrec 'v t = (K.t, 'v, K.comparator_witness) t
   end
 
@@ -1938,13 +1686,13 @@ module type Map = sig
         -> ('k, 'v, 'cmp) t
 
       include
-        Creators_and_accessors_generic
-          with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-          with type ('a, 'b, 'c) tree := ('a, 'b, 'c) t
-          with type 'k key := 'k
-          with type 'c cmp := 'c
-          with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-          with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
+        Creators_and_accessors_and_transformers_generic
+        with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+        with type ('a, 'b, 'c) tree := ('a, 'b, 'c) t
+        with type 'k key := 'k
+        with type 'c cmp := 'c
+        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
 
       val empty_without_value_restriction : (_, _, _) t
 
@@ -1978,13 +1726,13 @@ module type Map = sig
     end
 
     include
-      Creators_and_accessors_generic
-        with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-        with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
-        with type 'k key := 'k
-        with type 'c cmp := 'c
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+      Creators_and_accessors_and_transformers_generic
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Tree.t
+      with type 'k key := 'k
+      with type 'c cmp := 'c
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
 
     val comparator : ('a, _, 'cmp) t -> ('a, 'cmp) Comparator.t
 
@@ -2003,10 +1751,10 @@ module type Map = sig
   (** A polymorphic Map. *)
   module Poly :
     S_poly
-      with type ('key, +'value) t = ('key, 'value, Comparator.Poly.comparator_witness) t
-       and type ('key, +'value) tree =
-        ('key, 'value, Comparator.Poly.comparator_witness) Using_comparator.Tree.t
-       and type comparator_witness = Comparator.Poly.comparator_witness
+    with type ('key, +'value) t = ('key, 'value, Comparator.Poly.comparator_witness) t
+     and type ('key, +'value) tree =
+      ('key, 'value, Comparator.Poly.comparator_witness) Using_comparator.Tree.t
+     and type comparator_witness = Comparator.Poly.comparator_witness
 
   (** Create a map from a tree using the given comparator. *)
   val of_tree
@@ -2028,6 +1776,36 @@ module type Map = sig
   module type For_deriving = For_deriving
   module type S_poly = S_poly
   module type Accessors_generic = Accessors_generic
-  module type Creators_and_accessors_generic = Creators_and_accessors_generic
+  module type Transformers_generic = Transformers_generic
+
+  module type Creators_and_accessors_and_transformers_generic =
+    Creators_and_accessors_and_transformers_generic
+
   module type Creators_generic = Creators_generic
+
+  (**/**)
+
+  module Private : sig
+    module Tree : sig
+      type ('k, 'v) t
+
+      val balance_invariants : ('k, 'v) t -> bool
+      val are_balanced : ('k, 'v) t -> ('k, 'v) t -> bool
+      val are_almost_balanced : ('k, 'v) t -> ('k, 'v) t -> bool
+      val expose : ('k, 'v) t -> (('k, 'v) t * 'k * 'v * ('k, 'v) t) option
+      val empty : ('k, 'v) t
+      val create_if_balanced : ('k, 'v) t -> 'k -> 'v -> ('k, 'v) t -> ('k, 'v) t
+      val create_if_almost_balanced : ('k, 'v) t -> 'k -> 'v -> ('k, 'v) t -> ('k, 'v) t
+
+      val create_even_if_completely_unbalanced
+        :  ('k, 'v) t
+        -> 'k
+        -> 'v
+        -> ('k, 'v) t
+        -> ('k, 'v) t
+    end
+  end
+  [@@alert
+    map_private
+      "These definitions are only for testing the internal implementation of Map."]
 end
diff --git a/src/maybe_bound.ml b/src/maybe_bound.ml
index 53242cee..1528c6be 100644
--- a/src/maybe_bound.ml
+++ b/src/maybe_bound.ml
@@ -33,7 +33,7 @@ let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t =
         (Sexplib0.Sexp.Atom (("incl" | "Incl") as _tag__009_) :: sexp_args__010_) as
       _sexp__008_ ->
       (match sexp_args__010_ with
-       | [ arg0__011_ ] ->
+       | arg0__011_ :: [] ->
          let res0__012_ = _of_a__003_ arg0__011_ in
          Incl res0__012_
        | _ ->
@@ -45,7 +45,7 @@ let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t =
         (Sexplib0.Sexp.Atom (("excl" | "Excl") as _tag__014_) :: sexp_args__015_) as
       _sexp__013_ ->
       (match sexp_args__015_ with
-       | [ arg0__016_ ] ->
+       | arg0__016_ :: [] ->
          let res0__017_ = _of_a__003_ arg0__016_ in
          Excl res0__017_
        | _ ->
@@ -64,7 +64,11 @@ let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t =
       Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__006_ sexp__005_
     | Sexplib0.Sexp.List [] as sexp__005_ ->
       Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__006_ sexp__005_
-    | sexp__005_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__006_ sexp__005_
+    | sexp__005_ ->
+      Sexplib0.Sexp_conv_error.unexpected_stag
+        error_source__006_
+        [ "Incl"; "Excl"; "Unbounded" ]
+        sexp__005_
 ;;
 
 let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t =
@@ -136,8 +140,12 @@ let interval_comparison_of_sexp =
      Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__033_ sexp__032_
    | Sexplib0.Sexp.List [] as sexp__032_ ->
      Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__033_ sexp__032_
-   | sexp__032_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__033_ sexp__032_
-    : Sexplib0.Sexp.t -> interval_comparison)
+   | sexp__032_ ->
+     Sexplib0.Sexp_conv_error.unexpected_stag
+       error_source__033_
+       [ "Below_lower_bound"; "In_range"; "Above_upper_bound" ]
+       sexp__032_
+   : Sexplib0.Sexp.t -> interval_comparison)
 ;;
 
 let sexp_of_interval_comparison =
@@ -145,7 +153,7 @@ let sexp_of_interval_comparison =
    | Below_lower_bound -> Sexplib0.Sexp.Atom "Below_lower_bound"
    | In_range -> Sexplib0.Sexp.Atom "In_range"
    | Above_upper_bound -> Sexplib0.Sexp.Atom "Above_upper_bound"
-    : interval_comparison -> Sexplib0.Sexp.t)
+   : interval_comparison -> Sexplib0.Sexp.t)
 ;;
 
 let (interval_comparison_sexp_grammar : interval_comparison Sexplib0.Sexp_grammar.t) =
@@ -167,7 +175,7 @@ let compare_interval_comparison__local =
 
 let compare_interval_comparison =
   (fun a b -> compare_interval_comparison__local a b
-    : interval_comparison -> interval_comparison -> int)
+   : interval_comparison -> interval_comparison -> int)
 ;;
 
 let (hash_fold_interval_comparison :
@@ -180,7 +188,7 @@ let (hash_fold_interval_comparison :
         | Below_lower_bound -> 0
         | In_range -> 1
         | Above_upper_bound -> 2)
-    : Ppx_hash_lib.Std.Hash.state -> interval_comparison -> Ppx_hash_lib.Std.Hash.state)
+   : Ppx_hash_lib.Std.Hash.state -> interval_comparison -> Ppx_hash_lib.Std.Hash.state)
 ;;
 
 let (hash_interval_comparison : interval_comparison -> Ppx_hash_lib.Std.Hash.hash_value) =
diff --git a/src/modes.ml b/src/modes.ml
new file mode 100644
index 00000000..dd9cebd6
--- /dev/null
+++ b/src/modes.ml
@@ -0,0 +1,136 @@
+open! Import
+
+module Global = struct
+  include Modes_intf.Definitions.Global
+
+  type 'a t = { global : 'a } [@@unboxed]
+
+  let compare__local compare a b = compare a.global b.global
+  let compare compare a b = compare__local compare a b
+  let equal__local equal a b = equal a.global b.global
+  let equal equal a b = equal__local equal a b
+  let hash_fold_t hash state t = hash state t.global
+  let t_of_sexp of_sexp sexp = { global = of_sexp sexp }
+  let sexp_of_t sexp_of t = sexp_of t.global
+
+  let t_sexp_grammar : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t =
+    Sexplib0.Sexp_grammar.coerce
+  ;;
+
+  let globalize _ { global } = { global }
+  let wrap global = { global }
+  let unwrap { global } = global
+  let map { global = x } ~f = { global = f x }
+
+  external wrap_list : 'a list -> 'a t list = "%identity"
+  external unwrap_list : ('a t list[@local_opt]) -> ('a list[@local_opt]) = "%identity"
+  external wrap_option : 'a option -> 'a t option = "%identity"
+
+  external unwrap_option
+    :  ('a t option[@local_opt])
+    -> ('a option[@local_opt])
+    = "%identity"
+
+  external wrap_either : ('a, 'b) Either.t -> ('a t, 'b t) Either.t = "%identity"
+
+  external unwrap_either
+    :  (('a t, 'b t) Either.t[@local_opt])
+    -> (('a, 'b) Either.t[@local_opt])
+    = "%identity"
+
+  external wrap_first : ('a, 'b) Either.t -> ('a t, 'b) Either.t = "%identity"
+
+  external unwrap_first
+    :  (('a t, 'b) Either.t[@local_opt])
+    -> (('a, 'b) Either.t[@local_opt])
+    = "%identity"
+
+  external wrap_second : ('a, 'b) Either.t -> ('a, 'b t) Either.t = "%identity"
+
+  external unwrap_second
+    :  (('a, 'b t) Either.t[@local_opt])
+    -> (('a, 'b) Either.t[@local_opt])
+    = "%identity"
+
+  external wrap_result : ('a, 'b) Result.t -> ('a t, 'b t) Result.t = "%identity"
+
+  external unwrap_result
+    :  (('a t, 'b t) Result.t[@local_opt])
+    -> (('a, 'b) Result.t[@local_opt])
+    = "%identity"
+
+  external wrap_ok : ('a, 'b) Result.t -> ('a t, 'b) Result.t = "%identity"
+
+  external unwrap_ok
+    :  (('a t, 'b) Result.t[@local_opt])
+    -> (('a, 'b) Result.t[@local_opt])
+    = "%identity"
+
+  external wrap_error : ('a, 'b) Result.t -> ('a, 'b t) Result.t = "%identity"
+
+  external unwrap_error
+    :  (('a, 'b t) Result.t[@local_opt])
+    -> (('a, 'b) Result.t[@local_opt])
+    = "%identity"
+
+  module Global_wrapper = struct
+    type nonrec 'a t = 'a t
+
+    let wrap = wrap
+    let unwrap = unwrap
+  end
+
+  module Local_wrapper = struct
+    type 'a t = 'a
+
+    let wrap = Fn.id
+    let unwrap = Fn.id
+  end
+
+  module Poly_fn1 (Input : T) (Output : T) (F : Wrapped_fn1(Input)(Output).S) :
+    Poly_fn1 with type input := Input.t and type output := Output.t = struct
+    module Global = F (Global_wrapper)
+    module Local = F (Local_wrapper)
+
+    let fn_global a = unwrap (Global.fn (wrap a)) [@nontail]
+    let fn_local = Local.fn
+  end
+
+  module Poly_fn2
+      (Input1 : T)
+      (Input2 : T)
+      (Output : T)
+      (F : Wrapped_fn2(Input1)(Input2)(Output).S) :
+    Poly_fn2
+    with type input1 := Input1.t
+     and type input2 := Input2.t
+     and type output := Output.t = struct
+    module Global = F (Global_wrapper)
+    module Local = F (Local_wrapper)
+
+    let fn_global a b = unwrap (Global.fn (wrap a) (wrap b)) [@nontail]
+    let fn_local = Local.fn
+  end
+
+  module Poly_fn3
+      (Input1 : T)
+      (Input2 : T)
+      (Input3 : T)
+      (Output : T)
+      (F : Wrapped_fn3(Input1)(Input2)(Input3)(Output).S) :
+    Poly_fn3
+    with type input1 := Input1.t
+     and type input2 := Input2.t
+     and type input3 := Input3.t
+     and type output := Output.t = struct
+    module Global = F (Global_wrapper)
+    module Local = F (Local_wrapper)
+
+    let fn_global a b c = unwrap (Global.fn (wrap a) (wrap b) (wrap c)) [@nontail]
+    let fn_local = Local.fn
+  end
+end
+
+module Export = struct
+  type 'a _global = 'a Global.t = { global : 'a } [@@unboxed]
+end
diff --git a/src/modes.mli b/src/modes.mli
new file mode 100644
index 00000000..4eed04c0
--- /dev/null
+++ b/src/modes.mli
@@ -0,0 +1 @@
+include Modes_intf.Modes (** @inline *)
diff --git a/src/modes_intf.ml b/src/modes_intf.ml
new file mode 100644
index 00000000..63254f88
--- /dev/null
+++ b/src/modes_intf.ml
@@ -0,0 +1,248 @@
+(** Modes are an experimental compiler feature, supported in the compiler branch found at:
+    https://github.com/ocaml-flambda/ocaml-jst
+
+    This module provides types that wrap a value in a different mode from its context. In
+    the standard OCaml compiler, these types are all no-op wrappers. *)
+
+open! Import
+
+module Definitions = struct
+  module Global = struct
+    (** Abstraction over modality. Used in [Wrapped_fn*] signatures, below.
+
+        Locality-polymorphic functions must be functorized over an arbitrary [Wrapper].
+        The [Poly_fn*] functors instantiate a function using ['a t = 'a] for the local
+        version and ['a t = Modes.Global.t] for the global version. *)
+    module type Wrapper = sig
+      type 'a t
+
+      val wrap : 'a -> 'a t
+      val unwrap : 'a t -> 'a
+    end
+
+    (** Locality-polymorphic 1-argument function. Passed to [Poly_fn1] functor, below. *)
+    module Wrapped_fn1 (Input : T) (Output : T) = struct
+      module type S = functor (W : Wrapper) -> sig
+        val fn : Input.t W.t -> Output.t W.t
+      end
+    end
+
+    (** Locality-polymorphic 2-argument function. Passed to [Poly_fn2] functor, below. *)
+    module Wrapped_fn2 (Input1 : T) (Input2 : T) (Output : T) = struct
+      module type S = functor (W : Wrapper) -> sig
+        val fn : Input1.t W.t -> Input2.t W.t -> Output.t W.t
+      end
+    end
+
+    (** Locality-polymorphic 3-argument function. Passed to [Poly_fn3] functor, below. *)
+    module Wrapped_fn3 (Input1 : T) (Input2 : T) (Input3 : T) (Output : T) = struct
+      module type S = functor (W : Wrapper) -> sig
+        val fn : Input1.t W.t -> Input2.t W.t -> Input3.t W.t -> Output.t W.t
+      end
+    end
+
+    (** Local and global 1-argument function. Provided by [Poly_fn1] functor, below. *)
+    module type Poly_fn1 = sig
+      type input
+      type output
+
+      val fn_local : input -> output
+      val fn_global : input -> output
+    end
+
+    (** Local and global 2-argument function. Provided by [Poly_fn2] functor, below. *)
+    module type Poly_fn2 = sig
+      type input1
+      type input2
+      type output
+
+      val fn_local : input1 -> input2 -> output
+      val fn_global : input1 -> input2 -> output
+    end
+
+    (** Local and global 3-argument function. Provided by [Poly_fn3] functor, below. *)
+    module type Poly_fn3 = sig
+      type input1
+      type input2
+      type input3
+      type output
+
+      val fn_local : input1 -> input2 -> input3 -> output
+      val fn_global : input1 -> input2 -> input3 -> output
+    end
+  end
+end
+
+module type Modes = sig
+  (** Wrap values in the [global_] mode, even in a [local_] context. *)
+  module Global : sig
+    include module type of struct
+      include Definitions.Global
+    end
+
+    type 'a t = { global : 'a }
+    [@@unboxed]
+    [@@deriving_inline compare ~localize, equal ~localize, hash, sexp, sexp_grammar]
+
+    include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
+    include Ppx_compare_lib.Comparable.S_local1 with type 'a t := 'a t
+    include Ppx_compare_lib.Equal.S1 with type 'a t := 'a t
+    include Ppx_compare_lib.Equal.S_local1 with type 'a t := 'a t
+    include Ppx_hash_lib.Hashable.S1 with type 'a t := 'a t
+    include Sexplib0.Sexpable.S1 with type 'a t := 'a t
+
+    val t_sexp_grammar : 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t
+
+    [@@@end]
+
+    (** Globalize a [t]. Takes an argument because [[%globalize]] will pass one for ['a],
+        but [globalize] is a no-op so it discards the argument. *)
+    val globalize : _ -> 'a t -> 'a t
+
+    (** Construct a [t]. Returns a global [t], which may be used as a local value. *)
+    val wrap : 'a -> 'a t
+
+    (** Access the contents of a [t]. Accepts a local [t], to which global values may be
+        passed. *)
+    val unwrap : 'a t -> 'a
+
+    (** Transform the contents of a [t]. Accepts a local [t], to which global values may
+        be passed. Returns a global [t], which may be used as a local value. *)
+    val map : 'a t -> f:('a -> 'b) -> 'b t
+
+    (** {2 Wrap and unwrap within other types}
+
+        It can be safe to wrap or unwrap a [Global.t] inside other types as a coercion
+        rather than a conversion, i.e. without copying any data. Since the type system
+        does not provide coercions for this, we provide explicit operations to convert as
+        a no-op. We export them as [external ... = "%identity"] to make this clear.
+
+        The [wrap_*] functions produce global values, which may be used as local values.
+
+        The [unwrap_*] functions produce local or global values, depending on which they
+        are passed. If used for globals, the result may be used as a local value. If used
+        for locals, the result must be local because the outer constructor may not be used
+        as a global value.
+
+        In general, it is safe to wrap or unwrap a type parameter ['a] in this way if the
+        wrapping and unwrapping do not pass through any arrow type. *)
+
+    (** Wrapping and unwrapping [List]. *)
+
+    external wrap_list : 'a list -> 'a t list = "%identity"
+    external unwrap_list : ('a t list[@local_opt]) -> ('a list[@local_opt]) = "%identity"
+
+    (** Wrapping and unwrapping [Option]. *)
+
+    external wrap_option : 'a option -> 'a t option = "%identity"
+
+    external unwrap_option
+      :  ('a t option[@local_opt])
+      -> ('a option[@local_opt])
+      = "%identity"
+
+    (** Wrapping and unwrapping [Either]. *)
+
+    external wrap_either : ('a, 'b) Either.t -> ('a t, 'b t) Either.t = "%identity"
+
+    external unwrap_either
+      :  (('a t, 'b t) Either.t[@local_opt])
+      -> (('a, 'b) Either.t[@local_opt])
+      = "%identity"
+
+    (** Wrapping and unwrapping [Either.First]. *)
+
+    external wrap_first : ('a, 'b) Either.t -> ('a t, 'b) Either.t = "%identity"
+
+    external unwrap_first
+      :  (('a t, 'b) Either.t[@local_opt])
+      -> (('a, 'b) Either.t[@local_opt])
+      = "%identity"
+
+    (** Wrapping and unwrapping [Either.Second]. *)
+
+    external wrap_second : ('a, 'b) Either.t -> ('a, 'b t) Either.t = "%identity"
+
+    external unwrap_second
+      :  (('a, 'b t) Either.t[@local_opt])
+      -> (('a, 'b) Either.t[@local_opt])
+      = "%identity"
+
+    (** Wrapping and unwrapping [Result]. *)
+
+    external wrap_result : ('a, 'b) Result.t -> ('a t, 'b t) Result.t = "%identity"
+
+    external unwrap_result
+      :  (('a t, 'b t) Result.t[@local_opt])
+      -> (('a, 'b) Result.t[@local_opt])
+      = "%identity"
+
+    (** Wrapping and unwrapping [Result.Ok]. *)
+
+    external wrap_ok : ('a, 'b) Result.t -> ('a t, 'b) Result.t = "%identity"
+
+    external unwrap_ok
+      :  (('a t, 'b) Result.t[@local_opt])
+      -> (('a, 'b) Result.t[@local_opt])
+      = "%identity"
+
+    (** Wrapping and unwrapping [Result.Error]. *)
+
+    external wrap_error : ('a, 'b) Result.t -> ('a, 'b t) Result.t = "%identity"
+
+    external unwrap_error
+      :  (('a, 'b t) Result.t[@local_opt])
+      -> (('a, 'b) Result.t[@local_opt])
+      = "%identity"
+
+    (** {2 Simulating mode polymorphism}
+
+        Until the mode extension to the OCaml compiler supports polymorphism over modes,
+        we have to simulate it by writing multiple instances of some functions. These
+        functors handle simple cases of local-vs-global versions of functions.
+
+        Given a function that is parameterized over the [Wrapper] signature above, these
+        functors provide two versions of the function, one that operates on and returns
+        local values, and one that operates on and returns global values.
+
+        Performance caveat:
+
+        The function implementation itself is only compiled once. Inputs it unwraps will
+        be local, and may need to be [globalize]d. Outputs it produces will be global, and
+        will be allocated on the heap. To avoid these performance concerns, you will need
+        to actually write two versions of the function. *)
+
+    (** Instantiate local and global versions of a 1-argument function. *)
+    module Poly_fn1 (Input : T) (Output : T) (F : Wrapped_fn1(Input)(Output).S) :
+      Poly_fn1 with type input := Input.t and type output := Output.t
+
+    (** Instantiate local and global versions of a 2-argument function. *)
+    module Poly_fn2
+        (Input1 : T)
+        (Input2 : T)
+        (Output : T)
+        (F : Wrapped_fn2(Input1)(Input2)(Output).S) :
+      Poly_fn2
+      with type input1 := Input1.t
+       and type input2 := Input2.t
+       and type output := Output.t
+
+    (** Instantiate local and global versions of a 3-argument function. *)
+    module Poly_fn3
+        (Input1 : T)
+        (Input2 : T)
+        (Input3 : T)
+        (Output : T)
+        (F : Wrapped_fn3(Input1)(Input2)(Input3)(Output).S) :
+      Poly_fn3
+      with type input1 := Input1.t
+       and type input2 := Input2.t
+       and type input3 := Input3.t
+       and type output := Output.t
+  end
+
+  (** Can be [open]ed or [include]d to bring field names into scope. *)
+  module Export : sig
+    type 'a _global = 'a Global.t = { global : 'a } [@@unboxed]
+  end
+end
diff --git a/src/monad.ml b/src/monad.ml
index d01f3b5d..a275a4d0 100644
--- a/src/monad.ml
+++ b/src/monad.ml
@@ -70,29 +70,29 @@ end
 
 module Make_indexed (M : Basic_indexed) :
   S_indexed with type ('a, 'i, 'j) t := ('a, 'i, 'j) M.t = Make_general (struct
-  include M
+    include M
 
-  type ('a, 'i, 'j, 'd, 'e) t = ('a, 'i, 'j) M.t
-end)
+    type ('a, 'i, 'j, 'd, 'e) t = ('a, 'i, 'j) M.t
+  end)
 
 module Make3 (M : Basic3) : S3 with type ('a, 'd, 'e) t := ('a, 'd, 'e) M.t =
 Make_general (struct
-  include M
+    include M
 
-  type ('a, 'i, 'j, 'd, 'e) t = ('a, 'd, 'e) M.t
-end)
+    type ('a, 'i, 'j, 'd, 'e) t = ('a, 'd, 'e) M.t
+  end)
 
 module Make2 (M : Basic2) : S2 with type ('a, 'd) t := ('a, 'd) M.t = Make_general (struct
-  include M
+    include M
 
-  type ('a, 'i, 'j, 'd, 'e) t = ('a, 'd) M.t
-end)
+    type ('a, 'i, 'j, 'd, 'e) t = ('a, 'd) M.t
+  end)
 
 module Make (M : Basic) : S with type 'a t := 'a M.t = Make_general (struct
-  include M
+    include M
 
-  type ('a, 'i, 'j, 'd, 'e) t = 'a M.t
-end)
+    type ('a, 'i, 'j, 'd, 'e) t = 'a M.t
+  end)
 
 module Make2_local (M : Basic2_local) = struct
   let bind = M.bind
@@ -162,42 +162,45 @@ end
 
 module Make_local (M : Basic_local) : S_local with type 'a t := 'a M.t =
 Make2_local (struct
-  include M
+    include M
 
-  type ('a, 'e) t = 'a M.t
-end)
+    type ('a, 'e) t = 'a M.t
+  end)
 
-module Of_monad_general (Monad : sig
-  type ('a, 'i, 'j, 'd, 'e) t
+module Of_monad_general
+    (Monad : sig
+       type ('a, 'i, 'j, 'd, 'e) t
 
-  val bind
-    :  ('a, 'i, 'j, 'd, 'e) t
-    -> f:('a -> ('b, 'j, 'k, 'd, 'e) t)
-    -> ('b, 'i, 'k, 'd, 'e) t
+       val bind
+         :  ('a, 'i, 'j, 'd, 'e) t
+         -> f:('a -> ('b, 'j, 'k, 'd, 'e) t)
+         -> ('b, 'i, 'k, 'd, 'e) t
 
-  val map : ('a, 'i, 'j, 'd, 'e) t -> f:('a -> 'b) -> ('b, 'i, 'j, 'd, 'e) t
-  val return : 'a -> ('a, 'i, 'i, 'd, 'e) t
-end) (M : sig
-  type ('a, 'i, 'j, 'd, 'e) t
+       val map : ('a, 'i, 'j, 'd, 'e) t -> f:('a -> 'b) -> ('b, 'i, 'j, 'd, 'e) t
+       val return : 'a -> ('a, 'i, 'i, 'd, 'e) t
+     end)
+    (M : sig
+       type ('a, 'i, 'j, 'd, 'e) t
 
-  val to_monad : ('a, 'i, 'j, 'd, 'e) t -> ('a, 'i, 'j, 'd, 'e) Monad.t
-  val of_monad : ('a, 'i, 'j, 'd, 'e) Monad.t -> ('a, 'i, 'j, 'd, 'e) t
-end) =
+       val to_monad : ('a, 'i, 'j, 'd, 'e) t -> ('a, 'i, 'j, 'd, 'e) Monad.t
+       val of_monad : ('a, 'i, 'j, 'd, 'e) Monad.t -> ('a, 'i, 'j, 'd, 'e) t
+     end) =
 Make_general (struct
-  type ('a, 'i, 'j, 'd, 'e) t = ('a, 'i, 'j, 'd, 'e) M.t
+    type ('a, 'i, 'j, 'd, 'e) t = ('a, 'i, 'j, 'd, 'e) M.t
 
-  let return a = M.of_monad (Monad.return a)
-  let bind t ~f = M.of_monad (Monad.bind (M.to_monad t) ~f:(fun a -> M.to_monad (f a)))
-  let map = `Custom (fun t ~f -> M.of_monad (Monad.map (M.to_monad t) ~f))
-end)
+    let return a = M.of_monad (Monad.return a)
+    let bind t ~f = M.of_monad (Monad.bind (M.to_monad t) ~f:(fun a -> M.to_monad (f a)))
+    let map = `Custom (fun t ~f -> M.of_monad (Monad.map (M.to_monad t) ~f))
+  end)
 
 module Of_monad_indexed
-  (Monad : S_indexed) (M : sig
-    type ('a, 'i, 'j) t
+    (Monad : S_indexed)
+    (M : sig
+       type ('a, 'i, 'j) t
 
-    val to_monad : ('a, 'i, 'j) t -> ('a, 'i, 'j) Monad.t
-    val of_monad : ('a, 'i, 'j) Monad.t -> ('a, 'i, 'j) t
-  end) =
+       val to_monad : ('a, 'i, 'j) t -> ('a, 'i, 'j) Monad.t
+       val of_monad : ('a, 'i, 'j) Monad.t -> ('a, 'i, 'j) t
+     end) =
   Of_monad_general
     (struct
       include Monad
@@ -211,12 +214,13 @@ module Of_monad_indexed
     end)
 
 module Of_monad3
-  (Monad : S3) (M : sig
-    type ('a, 'b, 'c) t
+    (Monad : S3)
+    (M : sig
+       type ('a, 'b, 'c) t
 
-    val to_monad : ('a, 'b, 'c) t -> ('a, 'b, 'c) Monad.t
-    val of_monad : ('a, 'b, 'c) Monad.t -> ('a, 'b, 'c) t
-  end) =
+       val to_monad : ('a, 'b, 'c) t -> ('a, 'b, 'c) Monad.t
+       val of_monad : ('a, 'b, 'c) Monad.t -> ('a, 'b, 'c) t
+     end) =
   Of_monad_general
     (struct
       include Monad
@@ -230,12 +234,13 @@ module Of_monad3
     end)
 
 module Of_monad2
-  (Monad : S2) (M : sig
-    type ('a, 'b) t
+    (Monad : S2)
+    (M : sig
+       type ('a, 'b) t
 
-    val to_monad : ('a, 'b) t -> ('a, 'b) Monad.t
-    val of_monad : ('a, 'b) Monad.t -> ('a, 'b) t
-  end) =
+       val to_monad : ('a, 'b) t -> ('a, 'b) Monad.t
+       val of_monad : ('a, 'b) Monad.t -> ('a, 'b) t
+     end) =
   Of_monad_general
     (struct
       include Monad
@@ -249,12 +254,13 @@ module Of_monad2
     end)
 
 module Of_monad
-  (Monad : S) (M : sig
-    type 'a t
+    (Monad : S)
+    (M : sig
+       type 'a t
 
-    val to_monad : 'a t -> 'a Monad.t
-    val of_monad : 'a Monad.t -> 'a t
-  end) =
+       val to_monad : 'a t -> 'a Monad.t
+       val of_monad : 'a Monad.t -> 'a t
+     end) =
   Of_monad_general
     (struct
       include Monad
diff --git a/src/monad_intf.ml b/src/monad_intf.ml
index 0361c848..27b81190 100644
--- a/src/monad_intf.ml
+++ b/src/monad_intf.ml
@@ -72,13 +72,13 @@ end
 
 module type Syntax =
   Syntax_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type Syntax_local =
   Syntax_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type S_without_syntax_gen = sig
   type 'a t
@@ -117,13 +117,13 @@ end
 
 module type S_without_syntax =
   S_without_syntax_gen
-    with type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b) fn := 'a -> 'b
+  with type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b) fn := 'a -> 'b
 
 module type S_without_syntax_local =
   S_without_syntax_gen
-    with type ('a, 'b) f_labeled_fn := f:'a -> 'b
-     and type ('a, 'b) fn := 'a -> 'b
+  with type ('a, 'b) f_labeled_fn := f:'a -> 'b
+   and type ('a, 'b) fn := 'a -> 'b
 
 module type S = sig
   type 'a t
@@ -198,13 +198,13 @@ end
 
 module type Syntax2 =
   Syntax2_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type Syntax2_local =
   Syntax2_gen
-    with type ('a, 'b) fn := 'a -> 'b
-     and type ('a, 'b) f_labeled_fn := f:'a -> 'b
+  with type ('a, 'b) fn := 'a -> 'b
+   and type ('a, 'b) f_labeled_fn := f:'a -> 'b
 
 module type S2_gen = sig
   (** The same as {!S} except the monad type has two arguments. The second is always just
@@ -219,9 +219,9 @@ module type S2_gen = sig
 
   include
     Syntax2_gen
-      with type ('a, 'e) t := ('a, 'e) t
-       and type ('a, 'b) fn := ('a, 'b) fn
-       and type ('a, 'b) f_labeled_fn := ('a, 'b) f_labeled_fn
+    with type ('a, 'e) t := ('a, 'e) t
+     and type ('a, 'b) fn := ('a, 'b) fn
+     and type ('a, 'b) f_labeled_fn := ('a, 'b) f_labeled_fn
 
   module Monad_infix :
     Infix2_gen with type ('a, 'e) t := ('a, 'e) t and type ('a, 'b) fn := ('a, 'b) fn
@@ -475,36 +475,40 @@ module type Monad = sig
           end)
       ]} *)
   module Of_monad
-    (Monad : S) (M : sig
-      type 'a t
+      (Monad : S)
+      (M : sig
+         type 'a t
 
-      val to_monad : 'a t -> 'a Monad.t
-      val of_monad : 'a Monad.t -> 'a t
-    end) : S with type 'a t := 'a M.t
+         val to_monad : 'a t -> 'a Monad.t
+         val of_monad : 'a Monad.t -> 'a t
+       end) : S with type 'a t := 'a M.t
 
   module Of_monad2
-    (Monad : S2) (M : sig
-      type ('a, 'b) t
+      (Monad : S2)
+      (M : sig
+         type ('a, 'b) t
 
-      val to_monad : ('a, 'b) t -> ('a, 'b) Monad.t
-      val of_monad : ('a, 'b) Monad.t -> ('a, 'b) t
-    end) : S2 with type ('a, 'b) t := ('a, 'b) M.t
+         val to_monad : ('a, 'b) t -> ('a, 'b) Monad.t
+         val of_monad : ('a, 'b) Monad.t -> ('a, 'b) t
+       end) : S2 with type ('a, 'b) t := ('a, 'b) M.t
 
   module Of_monad3
-    (Monad : S3) (M : sig
-      type ('a, 'b, 'c) t
+      (Monad : S3)
+      (M : sig
+         type ('a, 'b, 'c) t
 
-      val to_monad : ('a, 'b, 'c) t -> ('a, 'b, 'c) Monad.t
-      val of_monad : ('a, 'b, 'c) Monad.t -> ('a, 'b, 'c) t
-    end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
+         val to_monad : ('a, 'b, 'c) t -> ('a, 'b, 'c) Monad.t
+         val of_monad : ('a, 'b, 'c) Monad.t -> ('a, 'b, 'c) t
+       end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
 
   module Of_monad_indexed
-    (Monad : S_indexed) (M : sig
-      type ('a, 'i, 'j) t
+      (Monad : S_indexed)
+      (M : sig
+         type ('a, 'i, 'j) t
 
-      val to_monad : ('a, 'i, 'j) t -> ('a, 'i, 'j) Monad.t
-      val of_monad : ('a, 'i, 'j) Monad.t -> ('a, 'i, 'j) t
-    end) : S_indexed with type ('a, 'i, 'j) t := ('a, 'i, 'j) M.t
+         val to_monad : ('a, 'i, 'j) t -> ('a, 'i, 'j) Monad.t
+         val of_monad : ('a, 'i, 'j) Monad.t -> ('a, 'i, 'j) t
+       end) : S_indexed with type ('a, 'i, 'j) t := ('a, 'i, 'j) M.t
 
   (** An eager identity monad with functions heavily annotated with
       [@inlined] or [@inline hint].
diff --git a/src/nativeint.ml b/src/nativeint.ml
index f3a67e54..e2214949 100644
--- a/src/nativeint.ml
+++ b/src/nativeint.ml
@@ -32,46 +32,46 @@ include T
 include Comparator.Make (T)
 
 include Comparable.With_zero (struct
-  include T
+    include T
 
-  let zero = zero
-end)
+    let zero = zero
+  end)
 
 module Conv = Int_conversions
 include Int_string_conversions.Make (T)
 
 include Int_string_conversions.Make_hex (struct
-  open Nativeint_replace_polymorphic_compare
+    open Nativeint_replace_polymorphic_compare
 
-  type t = nativeint [@@deriving_inline compare ~localize, hash]
+    type t = nativeint [@@deriving_inline compare ~localize, hash]
 
-  let compare__local = (compare_nativeint__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let compare__local = (compare_nativeint__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
 
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_nativeint
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_nativeint
 
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_nativeint in
-    fun x -> func x
-  ;;
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_nativeint in
+      fun x -> func x
+    ;;
 
-  [@@@end]
+    [@@@end]
 
-  let zero = zero
-  let neg = neg
-  let ( < ) = ( < )
-  let to_string i = Printf.sprintf "%nx" i
-  let of_string s = Stdlib.Scanf.sscanf s "%nx" Fn.id
-  let module_name = "Base.Nativeint.Hex"
-end)
+    let zero = zero
+    let neg = neg
+    let ( < ) = ( < )
+    let to_string i = Printf.sprintf "%nx" i
+    let of_string s = Stdlib.Scanf.sscanf s "%nx" Fn.id
+    let module_name = "Base.Nativeint.Hex"
+  end)
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let to_string = to_string
-  let module_name = "Base.Nativeint"
-end)
+    let to_string = to_string
+    let module_name = "Base.Nativeint"
+  end)
 
 (* Open replace_polymorphic_compare after including functor instantiations so they do not
    shadow its definitions. This is here so that efficient versions of the comparison
@@ -99,13 +99,23 @@ let neg = neg
 let minus_one = minus_one
 let one = one
 let zero = zero
-let to_float = to_float
-let of_float_unchecked = of_float
+
+external to_float
+  :  nativeint
+  -> float
+  = "caml_nativeint_to_float" "caml_nativeint_to_float_unboxed"
+[@@unboxed] [@@noalloc]
+
+external of_float_unchecked
+  :  float
+  -> nativeint
+  = "caml_nativeint_of_float" "caml_nativeint_of_float_unboxed"
+[@@unboxed] [@@noalloc]
 
 let of_float f =
   if Float_replace_polymorphic_compare.( >= ) f float_lower_bound
      && Float_replace_polymorphic_compare.( <= ) f float_upper_bound
-  then of_float f
+  then of_float_unchecked f
   else
     Printf.invalid_argf
       "Nativeint.of_float: argument (%f) is out of range or NaN"
@@ -159,18 +169,8 @@ module Pow2 = struct
     x land Stdlib.Nativeint.pred x = 0n
   ;;
 
-  (* C stubs for nativeint clz and ctz to use the CLZ/BSR/CTZ/BSF instruction where possible *)
-  external clz
-    :  (nativeint[@unboxed])
-    -> (int[@untagged])
-    = "Base_int_math_nativeint_clz" "Base_int_math_nativeint_clz_unboxed"
-    [@@noalloc]
-
-  external ctz
-    :  (nativeint[@unboxed])
-    -> (int[@untagged])
-    = "Base_int_math_nativeint_ctz" "Base_int_math_nativeint_ctz_unboxed"
-    [@@noalloc]
+  let clz = Ocaml_intrinsics_kernel.Nativeint.count_leading_zeros
+  let ctz = Ocaml_intrinsics_kernel.Nativeint.count_trailing_zeros
 
   (** Hacker's Delight Second Edition p106 *)
   let floor_log2 i =
@@ -252,31 +252,31 @@ let pow b e = of_int_exn (Int_math.Private.int_pow (to_int_exn b) (to_int_exn e)
 let ( ** ) b e = pow b e
 
 include Int_string_conversions.Make_binary (struct
-  type t = nativeint [@@deriving_inline compare ~localize, equal ~localize, hash]
-
-  let compare__local = (compare_nativeint__local : t -> t -> int)
-  let compare = (fun a b -> compare__local a b : t -> t -> int)
-  let equal__local = (equal_nativeint__local : t -> t -> bool)
-  let equal = (fun a b -> equal__local a b : t -> t -> bool)
-
-  let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
-    hash_fold_nativeint
-
-  and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
-    let func = hash_nativeint in
-    fun x -> func x
-  ;;
-
-  [@@@end]
-
-  let ( land ) = ( land )
-  let ( lsr ) = ( lsr )
-  let clz = clz
-  let num_bits = num_bits
-  let one = one
-  let to_int_exn = to_int_exn
-  let zero = zero
-end)
+    type t = nativeint [@@deriving_inline compare ~localize, equal ~localize, hash]
+
+    let compare__local = (compare_nativeint__local : t -> t -> int)
+    let compare = (fun a b -> compare__local a b : t -> t -> int)
+    let equal__local = (equal_nativeint__local : t -> t -> bool)
+    let equal = (fun a b -> equal__local a b : t -> t -> bool)
+
+    let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
+      hash_fold_nativeint
+
+    and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
+      let func = hash_nativeint in
+      fun x -> func x
+    ;;
+
+    [@@@end]
+
+    let ( land ) = ( land )
+    let ( lsr ) = ( lsr )
+    let clz = clz
+    let num_bits = num_bits
+    let one = one
+    let to_int_exn = to_int_exn
+    let zero = zero
+  end)
 
 module Pre_O = struct
   let ( + ) = ( + )
@@ -298,16 +298,16 @@ module O = struct
   include Pre_O
 
   include Int_math.Make (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    include Pre_O
+      include Pre_O
 
-    let rem = rem
-    let to_float = to_float
-    let of_float = of_float
-    let of_string = T.of_string
-    let to_string = T.to_string
-  end)
+      let rem = rem
+      let to_float = to_float
+      let of_float = of_float
+      let of_string = T.of_string
+      let to_string = T.to_string
+    end)
 
   let ( land ) = bit_and
   let ( lor ) = bit_or
diff --git a/src/nothing.ml b/src/nothing.ml
index ec604043..e9fd8453 100644
--- a/src/nothing.ml
+++ b/src/nothing.ml
@@ -25,10 +25,10 @@ end
 include T
 
 include Identifiable.Make (struct
-  include T
+    include T
 
-  let module_name = "Base.Nothing"
-end)
+    let module_name = "Base.Nothing"
+  end)
 
 let must_be_none : t option -> unit = function
   | None -> ()
diff --git a/src/obj_array.ml b/src/obj_array.ml
index e0f0b786..10118af9 100644
--- a/src/obj_array.ml
+++ b/src/obj_array.ml
@@ -1,7 +1,6 @@
 open! Import
 module Int = Int0
 module String = String0
-module Array = Array0
 
 (* We maintain the property that all values of type [t] do not have the tag
    [double_array_tag].  Some functions below assume this in order to avoid testing the
@@ -41,8 +40,8 @@ let get t i =
   Stdlib.Obj.repr
     (* [Sys.opaque_identity] is required on the array because this code breaks the usual
        assumptions about array kinds that the Flambda 2 optimiser can see. *)
-    ((Sys.opaque_identity (Stdlib.Obj.magic (t : t) : not_a_float array)).(i)
-      : not_a_float)
+    ((Sys.opaque_identity (Obj_local.magic (t : t) : not_a_float array)).(i)
+     : not_a_float)
 ;;
 
 let[@inline always] unsafe_get t i =
@@ -52,7 +51,7 @@ let[@inline always] unsafe_get t i =
     (Array.unsafe_get
        (Sys.opaque_identity (Obj_local.magic (t : t) : not_a_float array))
        i
-      : not_a_float)
+     : not_a_float)
 ;;
 
 let[@inline always] unsafe_set_with_caml_modify t i obj =
@@ -69,8 +68,8 @@ let[@inline always] unsafe_set_with_caml_modify t i obj =
 
 let[@inline always] set_with_caml_modify t i obj =
   (* same as unsafe_set_with_caml_modify but safe *)
-  (Sys.opaque_identity (Stdlib.Obj.magic (t : t) : not_a_float array)).(i)
-    <- (Stdlib.Obj.obj (Sys.opaque_identity obj) : not_a_float)
+  (Sys.opaque_identity (Obj_local.magic (t : t) : not_a_float array)).(i)
+  <- (Stdlib.Obj.obj (Sys.opaque_identity obj) : not_a_float)
 ;;
 
 let[@inline always] unsafe_set_int_assuming_currently_int t i int =
@@ -181,17 +180,12 @@ let unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
 ;;
 
 include Blit.Make (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let create = create_zero
-  let length = length
-  let unsafe_blit = unsafe_blit
-end)
+    let create = create_zero
+    let length = length
+    let unsafe_blit = unsafe_blit
+  end)
 
-let copy src =
-  let dst = create_zero ~len:(length src) in
-  blito ~src ~dst ();
-  dst
-;;
-
-let sub = Array.sub
+let sub t ~pos ~len = Array.sub t ~pos ~len
+let copy = Array.copy
diff --git a/src/obj_local.ml b/src/obj_local.ml
index 779fa8de..ac38aaca 100644
--- a/src/obj_local.ml
+++ b/src/obj_local.ml
@@ -50,8 +50,12 @@ let stack_or_heap_of_sexp =
      Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__003_ sexp__002_
    | Sexplib0.Sexp.List [] as sexp__002_ ->
      Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__003_ sexp__002_
-   | sexp__002_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__003_ sexp__002_
-    : Sexplib0.Sexp.t -> stack_or_heap)
+   | sexp__002_ ->
+     Sexplib0.Sexp_conv_error.unexpected_stag
+       error_source__003_
+       [ "Immediate"; "Stack"; "Heap" ]
+       sexp__002_
+   : Sexplib0.Sexp.t -> stack_or_heap)
 ;;
 
 let sexp_of_stack_or_heap =
@@ -59,7 +63,7 @@ let sexp_of_stack_or_heap =
    | Immediate -> Sexplib0.Sexp.Atom "Immediate"
    | Stack -> Sexplib0.Sexp.Atom "Stack"
    | Heap -> Sexplib0.Sexp.Atom "Heap"
-    : stack_or_heap -> Sexplib0.Sexp.t)
+   : stack_or_heap -> Sexplib0.Sexp.t)
 ;;
 
 let compare_stack_or_heap = (Stdlib.compare : stack_or_heap -> stack_or_heap -> int)
diff --git a/src/option.ml b/src/option.ml
index bea5f676..84b31f32 100644
--- a/src/option.ml
+++ b/src/option.ml
@@ -1,61 +1,57 @@
 open! Import
+open Modes.Export
 
 include (
-  struct
-    type 'a t = 'a option
-    [@@deriving_inline compare ~localize, globalize, hash, sexp, sexp_grammar]
-
-    let compare__local : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int =
-      compare_option__local
-    ;;
+struct
+  type 'a t = 'a option
+  [@@deriving_inline compare ~localize, globalize, hash, sexp, sexp_grammar]
 
-    let compare : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int = compare_option
+  let compare__local : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int =
+    compare_option__local
+  ;;
 
-    let globalize : 'a. ('a -> 'a) -> 'a t -> 'a t =
-      fun (type a__009_) : ((a__009_ -> a__009_) -> a__009_ t -> a__009_ t) ->
-      globalize_option
-    ;;
+  let compare : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int = compare_option
 
-    let hash_fold_t :
-          'a.
-          (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
-          -> Ppx_hash_lib.Std.Hash.state
-          -> 'a t
-          -> Ppx_hash_lib.Std.Hash.state
-      =
-      hash_fold_option
-    ;;
+  let globalize : 'a. ('a -> 'a) -> 'a t -> 'a t =
+    fun (type a__009_) : ((a__009_ -> a__009_) -> a__009_ t -> a__009_ t) ->
+    globalize_option
+  ;;
 
-    let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t =
-      option_of_sexp
-    ;;
+  let hash_fold_t
+    : 'a.
+    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
+    -> Ppx_hash_lib.Std.Hash.state
+    -> 'a t
+    -> Ppx_hash_lib.Std.Hash.state
+    =
+    hash_fold_option
+  ;;
 
-    let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t =
-      sexp_of_option
-    ;;
+  let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t = option_of_sexp
+  let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t = sexp_of_option
 
-    let t_sexp_grammar : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t =
-      fun _'a_sexp_grammar -> option_sexp_grammar _'a_sexp_grammar
-    ;;
+  let t_sexp_grammar : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t =
+    fun _'a_sexp_grammar -> option_sexp_grammar _'a_sexp_grammar
+  ;;
 
-    [@@@end]
-  end :
-    sig
-      type 'a t = 'a option
-      [@@deriving_inline compare ~localize, globalize, hash, sexp, sexp_grammar]
+  [@@@end]
+end :
+sig
+  type 'a t = 'a option
+  [@@deriving_inline compare ~localize, globalize, hash, sexp, sexp_grammar]
 
-      include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
-      include Ppx_compare_lib.Comparable.S_local1 with type 'a t := 'a t
+  include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
+  include Ppx_compare_lib.Comparable.S_local1 with type 'a t := 'a t
 
-      val globalize : ('a -> 'a) -> 'a t -> 'a t
+  val globalize : ('a -> 'a) -> 'a t -> 'a t
 
-      include Ppx_hash_lib.Hashable.S1 with type 'a t := 'a t
-      include Sexplib0.Sexpable.S1 with type 'a t := 'a t
+  include Ppx_hash_lib.Hashable.S1 with type 'a t := 'a t
+  include Sexplib0.Sexpable.S1 with type 'a t := 'a t
 
-      val t_sexp_grammar : 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t
+  val t_sexp_grammar : 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t
 
-      [@@@end]
-    end)
+  [@@@end]
+end)
 
 type 'a t = 'a option =
   | None
@@ -71,18 +67,30 @@ let is_some = function
   | _ -> false
 ;;
 
-let value_map o ~default ~f =
+let value_map_local o ~default ~f =
   match o with
   | Some x -> f x
   | None -> default
 ;;
 
-let iter o ~f =
+let[@inline] value_map o ~default ~f =
+  (value_map_local
+     (Modes.Global.wrap_option o)
+     ~default:{ global = default }
+     ~f:(Modes.Global.map ~f))
+    .global
+;;
+
+let iter_local o ~f =
   match o with
   | None -> ()
   | Some a -> f a
 ;;
 
+let[@inline] iter o ~f =
+  iter_local (Modes.Global.wrap_option o) ~f:(fun x -> f x.global) [@nontail]
+;;
+
 let invariant f t = iter t ~f
 
 let call x ~f =
@@ -91,13 +99,17 @@ let call x ~f =
   | Some f -> f x
 ;;
 
-let value t ~default =
+let value_local t ~default =
   match t with
   | None -> default
   | Some x -> x
 ;;
 
-let value_exn ?here ?error ?message t =
+let[@inline] value t ~default =
+  (value_local (Modes.Global.wrap_option t) ~default:{ global = default }).global
+;;
+
+let value_local_exn ?here ?error ?message t =
   match t with
   | Some x -> x
   | None ->
@@ -119,18 +131,34 @@ let value_exn ?here ?error ?message t =
     Error.raise error
 ;;
 
-let value_or_thunk o ~default =
+let[@inline] value_exn ?here ?error ?message t =
+  (value_local_exn ?here ?error ?message (Modes.Global.wrap_option t)).global
+;;
+
+let value_or_thunk_local o ~default =
   match o with
   | Some x -> x
   | None -> default ()
 ;;
 
+let[@inline] value_or_thunk o ~default =
+  (value_or_thunk_local (Modes.Global.wrap_option o) ~default:(fun () ->
+     { global = default () }))
+    .global
+;;
+
 let to_array t =
   match t with
   | None -> [||]
   | Some x -> [| x |]
 ;;
 
+let to_list_local t =
+  match t with
+  | None -> []
+  | Some x -> [ x ]
+;;
+
 let to_list t =
   match t with
   | None -> []
@@ -194,6 +222,13 @@ let equal__local f t t' =
 ;;
 
 let some x = Some x
+let some_local x = Some x
+
+let first_some_local x y =
+  match x with
+  | Some _ -> x
+  | None -> y
+;;
 
 let first_some x y =
   match x with
@@ -201,7 +236,22 @@ let first_some x y =
   | None -> y
 ;;
 
+let first_some_thunk x y =
+  match x with
+  | Some _ -> x
+  | None -> y ()
+;;
+
+let first_some_thunk_local x y =
+  match x with
+  | Some _ -> x
+  | None -> y ()
+;;
+
+let some_if_local cond x = if cond then Some x else None
 let some_if cond x = if cond then Some x else None
+let some_if_thunk cond thunk = if cond then Some (thunk ()) else None
+let some_if_thunk_local cond thunk = if cond then Some (thunk ()) else None
 
 let merge a b ~f =
   match a, b with
@@ -227,6 +277,12 @@ let try_with_join f =
   | exception _ -> None
 ;;
 
+let map_local t ~f =
+  match t with
+  | None -> None
+  | Some a -> Some (f a)
+;;
+
 let map t ~f =
   match t with
   | None -> None
diff --git a/src/option.mli b/src/option.mli
index 34090683..42f2568a 100644
--- a/src/option.mli
+++ b/src/option.mli
@@ -70,6 +70,9 @@ include Monad.S_local with type 'a t := 'a t
 (** Extracts the underlying value if present, otherwise returns [default]. *)
 val value : 'a t -> default:'a -> 'a
 
+(** Like [value], but over a local [t]. *)
+val value_local : 'a t -> default:'a -> 'a
+
 (** Extracts the underlying value, or raises if there is no value present. The
     error raised can be augmented using the [~here], [~error], and [~message]
     optional arguments. *)
@@ -80,14 +83,31 @@ val value_exn
   -> 'a t
   -> 'a
 
+(** Like [value_exn], but over a local [t]. *)
+val value_local_exn
+  :  ?here:Source_code_position0.t
+  -> ?error:Error.t
+  -> ?message:string
+  -> 'a t
+  -> 'a
+
 (** Extracts the underlying value and applies [f] to it if present, otherwise returns
     [default]. *)
 val value_map : 'a t -> default:'b -> f:('a -> 'b) -> 'b
 
+(** Like [value_map], but over a local [t]. *)
+val value_map_local : 'a t -> default:'b -> f:('a -> 'b) -> 'b
+
 (** Extracts the underlying value if present, otherwise executes and returns the result of
     [default]. [default] is only executed if the underlying value is absent. *)
 val value_or_thunk : 'a t -> default:(unit -> 'a) -> 'a
 
+(** Like [value_or_thunk], but over a local [t]. *)
+val value_or_thunk_local : 'a t -> default:(unit -> 'a) -> 'a
+
+(** Like [map], but over a local [t]. *)
+val map_local : 'a t -> f:('a -> 'b) -> 'b t
+
 (** On [None], returns [init]. On [Some x], returns [f init x]. *)
 val fold : 'a t -> init:'acc -> f:('acc -> 'a -> 'acc) -> 'acc
 
@@ -97,6 +117,9 @@ val mem : 'a t -> 'a -> equal:('a -> 'a -> bool) -> bool
 val length : 'a t -> int
 val iter : 'a t -> f:('a -> unit) -> unit
 
+(** Like [iter], but over a local [t]. *)
+val iter_local : 'a t -> f:('a -> unit) -> unit
+
 (** On [None], returns [false]. On [Some x], returns [f x]. *)
 val exists : 'a t -> f:('a -> bool) -> bool
 
@@ -111,6 +134,7 @@ val find : 'a t -> f:('a -> bool) -> 'a option
 val find_map : 'a t -> f:('a -> 'b option) -> 'b option
 
 val to_list : 'a t -> 'a list
+val to_list_local : 'a t -> 'a list
 val to_array : 'a t -> 'a array
 
 (** [call x f] runs an optional function [~f] on the argument. *)
@@ -137,14 +161,36 @@ val try_with_join : (unit -> 'a t) -> 'a t
 (** Wraps the [Some] constructor as a function. *)
 val some : 'a -> 'a t
 
+(** Like [some], but over a local [t]. *)
+val some_local : 'a -> 'a t
+
 (** [first_some t1 t2] returns [t1] if it has an underlying value, or [t2]
     otherwise. *)
 val first_some : 'a t -> 'a t -> 'a t
 
+(** Like [first_some], but over local [t]s. *)
+val first_some_local : 'a t -> 'a t -> 'a t
+
+(** [first_some_thunk a b] is like [first_some], but it only computes [b ()] if [a] is
+    [None] *)
+val first_some_thunk : 'a t -> (unit -> 'a t) -> 'a t
+
+(** Like [first_some_thunk], but over local [t]s. *)
+val first_some_thunk_local : 'a t -> (unit -> 'a t) -> 'a t
+
 (** [some_if b x] converts a value [x] to [Some x] if [b], and [None]
     otherwise. *)
 val some_if : bool -> 'a -> 'a t
 
+(** Like [some_if], but over a local [t]. *)
+val some_if_local : bool -> 'a -> 'a t
+
+(** Like [some_if], but only computes [x ()] if [b] is true. *)
+val some_if_thunk : bool -> (unit -> 'a) -> 'a t
+
+(** Like [some_if_thunk], but over a local [t] *)
+val some_if_thunk_local : bool -> (unit -> 'a) -> 'a t
+
 (** {2 Predicates} *)
 
 (** [is_none t] returns true iff [t = None]. *)
diff --git a/src/option_array.ml b/src/option_array.ml
index 280d4f76..dac08821 100644
--- a/src/option_array.ml
+++ b/src/option_array.ml
@@ -173,15 +173,15 @@ let foldi input ~init ~f =
 let fold input ~init ~f = foldi input ~init ~f:(fun (_ : int) acc x -> f acc x) [@nontail]
 
 include Indexed_container.Make_gen (struct
-  type nonrec ('a, _, _) t = 'a t
-  type 'a elt = 'a option
+    type nonrec ('a, _, _) t = 'a t
+    type 'a elt = 'a option
 
-  let fold = fold
-  let foldi = `Custom foldi
-  let iter = `Custom iter
-  let iteri = `Custom iteri
-  let length = `Custom length
-end)
+    let fold = fold
+    let foldi = `Custom foldi
+    let iter = `Custom iter
+    let iteri = `Custom iteri
+    let length = `Custom length
+  end)
 
 let length = Uniform_array.length
 
@@ -214,12 +214,12 @@ let of_array_some array =
 let to_array t = Array.init (length t) ~f:(fun i -> unsafe_get t i)
 
 include Blit.Make1_generic (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let length = length
-  let create_like ~len _ = create ~len
-  let unsafe_blit = Uniform_array.unsafe_blit
-end)
+    let length = length
+    let create_like ~len _ = create ~len
+    let unsafe_blit = Uniform_array.unsafe_blit
+  end)
 
 let copy = Uniform_array.copy
 
diff --git a/src/or_error.ml b/src/or_error.ml
index 93e58ae9..2502cf47 100644
--- a/src/or_error.ml
+++ b/src/or_error.ml
@@ -28,12 +28,12 @@ let globalize : 'a. ('a -> 'a) -> 'a t -> 'a t =
   Result.globalize _globalize_a__026_ Error.globalize x__027_
 ;;
 
-let hash_fold_t :
-      'a.
-      (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
-      -> Ppx_hash_lib.Std.Hash.state
-      -> 'a t
-      -> Ppx_hash_lib.Std.Hash.state
+let hash_fold_t
+  : 'a.
+  (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state)
+  -> Ppx_hash_lib.Std.Hash.state
+  -> 'a t
+  -> Ppx_hash_lib.Std.Hash.state
   =
   fun _hash_fold_a hsv arg -> Result.hash_fold_t _hash_fold_a Error.hash_fold_t hsv arg
 ;;
@@ -76,12 +76,12 @@ let map2 a b ~f =
 ;;
 
 module For_applicative = Applicative.Make_using_map2_local (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let return = return
-  let map = `Custom map
-  let map2 = map2
-end)
+    let return = return
+    let map = `Custom map
+    let map2 = map2
+  end)
 
 let ( *> ) = For_applicative.( *> )
 let ( <* ) = For_applicative.( <* )
diff --git a/src/ordered_collection_common0.ml b/src/ordered_collection_common0.ml
index 4c92874d..fbe88c4a 100644
--- a/src/ordered_collection_common0.ml
+++ b/src/ordered_collection_common0.ml
@@ -1,6 +1,6 @@
 (* Split off to avoid a cyclic dependency with [Or_error]. *)
 
-open! Import
+open! Import0
 
 let invalid_argf = Printf.invalid_argf
 
@@ -11,7 +11,7 @@ let slow_check_pos_len_exn ~pos ~len ~total_length =
      possibility of overflow. *)
   if pos > total_length - len
   then invalid_argf "pos + len past end: %d + %d > %d" pos len total_length ()
-  [@@cold] [@@inline never] [@@local never] [@@specialise never]
+[@@cold] [@@inline never] [@@local never] [@@specialise never]
 ;;
 
 let check_pos_len_exn ~pos ~len ~total_length =
@@ -29,7 +29,7 @@ let check_pos_len_exn ~pos ~len ~total_length =
   let stop = pos + len in
   if pos lor len lor stop lor (total_length - stop) < 0
   then slow_check_pos_len_exn ~pos ~len ~total_length
-  [@@inline always]
+[@@inline always]
 ;;
 
 let get_pos_len_exn ?(pos = 0) ?len () ~total_length =
diff --git a/src/ordered_collection_common0.mli b/src/ordered_collection_common0.mli
index 5bd6e70d..5b8359c4 100644
--- a/src/ordered_collection_common0.mli
+++ b/src/ordered_collection_common0.mli
@@ -1,4 +1,4 @@
-open! Import
+open! Import0
 
 (** [get_pos_len_exn], and [check_pos_len_exn] are intended to be used
     by functions that take a sequence (array, string, bigstring, ...) and an optional
diff --git a/src/ordering.ml b/src/ordering.ml
index e980fc20..a7027035 100644
--- a/src/ordering.ml
+++ b/src/ordering.ml
@@ -17,7 +17,7 @@ let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.sta
         | Less -> 0
         | Equal -> 1
         | Greater -> 2)
-    : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
+   : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
 ;;
 
 let (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
@@ -47,8 +47,12 @@ let t_of_sexp =
      Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__005_ sexp__004_
    | Sexplib0.Sexp.List [] as sexp__004_ ->
      Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__005_ sexp__004_
-   | sexp__004_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__005_ sexp__004_
-    : Sexplib0.Sexp.t -> t)
+   | sexp__004_ ->
+     Sexplib0.Sexp_conv_error.unexpected_stag
+       error_source__005_
+       [ "Less"; "Equal"; "Greater" ]
+       sexp__004_
+   : Sexplib0.Sexp.t -> t)
 ;;
 
 let sexp_of_t =
@@ -56,7 +60,7 @@ let sexp_of_t =
    | Less -> Sexplib0.Sexp.Atom "Less"
    | Equal -> Sexplib0.Sexp.Atom "Equal"
    | Greater -> Sexplib0.Sexp.Atom "Greater"
-    : t -> Sexplib0.Sexp.t)
+   : t -> Sexplib0.Sexp.t)
 ;;
 
 let (t_sexp_grammar : t Sexplib0.Sexp_grammar.t) =
diff --git a/src/popcount.ml b/src/popcount.ml
index 77fd8dfb..7d2824ba 100644
--- a/src/popcount.ml
+++ b/src/popcount.ml
@@ -1,46 +1,6 @@
 open! Import
 
-(* C stub for int popcount to use the POPCNT instruction where possible *)
-external int_popcount : int -> int = "Base_int_math_int_popcount" [@@noalloc]
-
-(* To maintain javascript compatibility and enable unboxing, we implement popcount in
-   OCaml rather than use C stubs. Implementation adapted from:
-   https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation *)
-let int64_popcount =
-  let open Stdlib.Int64 in
-  let ( + ) = add in
-  let ( - ) = sub in
-  let ( * ) = mul in
-  let ( lsr ) = shift_right_logical in
-  let ( land ) = logand in
-  let m1 = 0x5555555555555555L in
-  (* 0b01010101... *)
-  let m2 = 0x3333333333333333L in
-  (* 0b00110011... *)
-  let m4 = 0x0f0f0f0f0f0f0f0fL in
-  (* 0b00001111... *)
-  let h01 = 0x0101010101010101L in
-  (* 1 bit set per byte *)
-  fun [@inline] x ->
-    (* gather the bit count for every pair of bits *)
-    let x = x - ((x lsr 1) land m1) in
-    (* gather the bit count for every 4 bits *)
-    let x = (x land m2) + ((x lsr 2) land m2) in
-    (* gather the bit count for every byte *)
-    let x = (x + (x lsr 4)) land m4 in
-    (* sum the bit counts in the top byte and shift it down *)
-    to_int ((x * h01) lsr 56)
-;;
-
-let int32_popcount =
-  (* On 64-bit systems, this is faster than implementing using [int32] arithmetic. *)
-  let mask = 0xffff_ffffL in
-  fun [@inline] x -> int64_popcount (Stdlib.Int64.logand (Stdlib.Int64.of_int32 x) mask)
-;;
-
-let nativeint_popcount =
-  match Stdlib.Nativeint.size with
-  | 32 -> fun [@inline] x -> int32_popcount (Stdlib.Nativeint.to_int32 x)
-  | 64 -> fun [@inline] x -> int64_popcount (Stdlib.Int64.of_nativeint x)
-  | _ -> assert false
-;;
+let int_popcount = Ocaml_intrinsics_kernel.Int.count_set_bits
+let int64_popcount = Ocaml_intrinsics_kernel.Int64.count_set_bits
+let int32_popcount = Ocaml_intrinsics_kernel.Int32.count_set_bits
+let nativeint_popcount = Ocaml_intrinsics_kernel.Nativeint.count_set_bits
diff --git a/src/ppx_hash_lib.ml b/src/ppx_hash_lib.ml
index 84ae88ab..9f05e660 100644
--- a/src/ppx_hash_lib.ml
+++ b/src/ppx_hash_lib.ml
@@ -3,35 +3,56 @@ module Std = struct
   module Hash = Hash (** @canonical Base.Hash *)
 end
 
-type 'a hash_fold = Std.Hash.state -> 'a -> Std.Hash.state
+(** The functor is exposed to make it possible to use ppx_hash with alternative
+      hash types without having to duplicate these definitions. *)
+module F (Types : sig
+    type hash_state
+    type hash_value
+  end) =
+struct
+  open Types
 
-module Hashable = struct
-  module type S = sig
-    type t
+  type 'a hash_fold = hash_state -> 'a -> hash_state
 
-    val hash_fold_t : t hash_fold
-    val hash : t -> Std.Hash.hash_value
-  end
+  module Hashable = struct
+    module type S_any = sig
+      type t
 
-  module type S1 = sig
-    type 'a t
+      val hash_fold_t : t hash_fold
+      val hash : t -> hash_value
+    end
 
-    val hash_fold_t : 'a hash_fold -> 'a t hash_fold
-  end
+    module type S = sig
+      type t
 
-  module type S2 = sig
-    type ('a, 'b) t
+      include S_any with type t := t
+    end
 
-    val hash_fold_t : 'a hash_fold -> 'b hash_fold -> ('a, 'b) t hash_fold
-  end
+    module type S1 = sig
+      type 'a t
+
+      val hash_fold_t : 'a hash_fold -> 'a t hash_fold
+    end
 
-  module type S3 = sig
-    type ('a, 'b, 'c) t
+    module type S2 = sig
+      type ('a, 'b) t
 
-    val hash_fold_t
-      :  'a hash_fold
-      -> 'b hash_fold
-      -> 'c hash_fold
-      -> ('a, 'b, 'c) t hash_fold
+      val hash_fold_t : 'a hash_fold -> 'b hash_fold -> ('a, 'b) t hash_fold
+    end
+
+    module type S3 = sig
+      type ('a, 'b, 'c) t
+
+      val hash_fold_t
+        :  'a hash_fold
+        -> 'b hash_fold
+        -> 'c hash_fold
+        -> ('a, 'b, 'c) t hash_fold
+    end
   end
 end
+
+include F (struct
+    type nonrec hash_state = Std.Hash.state
+    type nonrec hash_value = Std.Hash.hash_value
+  end)
diff --git a/src/pretty_printer.ml b/src/pretty_printer.ml
index 4007f788..f7b921bc 100644
--- a/src/pretty_printer.ml
+++ b/src/pretty_printer.ml
@@ -11,10 +11,10 @@ module type S = sig
 end
 
 module Register_pp (M : sig
-  include S
+    include S
 
-  val module_name : string
-end) =
+    val module_name : string
+  end) =
 struct
   include M
 
@@ -22,13 +22,13 @@ struct
 end
 
 module Register (M : sig
-  type t
+    type t
 
-  val module_name : string
-  val to_string : t -> string
-end) =
+    val module_name : string
+    val to_string : t -> string
+  end) =
 Register_pp (struct
-  include M
+    include M
 
-  let pp formatter t = Stdlib.Format.pp_print_string formatter (M.to_string t)
-end)
+    let pp formatter t = Stdlib.Format.pp_print_string formatter (M.to_string t)
+  end)
diff --git a/src/pretty_printer.mli b/src/pretty_printer.mli
index e8247a67..9bbac51c 100644
--- a/src/pretty_printer.mli
+++ b/src/pretty_printer.mli
@@ -35,19 +35,19 @@ end
     guarantee that one has the desired [pp] function at the same point where the [name] is
     added. *)
 module Register (M : sig
-  type t
+    type t
 
-  val module_name : string
-  val to_string : t -> string
-end) : S with type t := M.t
+    val module_name : string
+    val to_string : t -> string
+  end) : S with type t := M.t
 
 (** [Register_pp] is like [Register], but allows a custom [pp] function rather than using
     [to_string]. *)
 module Register_pp (M : sig
-  include S
+    include S
 
-  val module_name : string
-end) : S with type t := M.t
+    val module_name : string
+  end) : S with type t := M.t
 
 (** [register name] adds [name] to the list of pretty printers.  Use the [Register]
     functor if possible. *)
diff --git a/src/queue.ml b/src/queue.ml
index f26c639a..8a9cd06e 100644
--- a/src/queue.ml
+++ b/src/queue.ml
@@ -18,37 +18,37 @@ type 'a t =
 
 let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t =
   fun _of_a__001_
-      { num_mutations = num_mutations__003_
-      ; front = front__005_
-      ; mask = mask__007_
-      ; length = length__009_
-      ; elts = elts__011_
-      } ->
+    { num_mutations = num_mutations__003_
+    ; front = front__005_
+    ; mask = mask__007_
+    ; length = length__009_
+    ; elts = elts__011_
+    } ->
   let bnds__002_ = ([] : _ Stdlib.List.t) in
   let bnds__002_ =
     let arg__012_ = Option_array.sexp_of_t _of_a__001_ elts__011_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "elts"; arg__012_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   let bnds__002_ =
     let arg__010_ = sexp_of_int length__009_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "length"; arg__010_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   let bnds__002_ =
     let arg__008_ = sexp_of_int mask__007_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "mask"; arg__008_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   let bnds__002_ =
     let arg__006_ = sexp_of_int front__005_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "front"; arg__006_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   let bnds__002_ =
     let arg__004_ = sexp_of_int num_mutations__003_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "num_mutations"; arg__004_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   Sexplib0.Sexp.List bnds__002_
 ;;
@@ -97,7 +97,9 @@ let set t i a =
 let is_empty t = t.length = 0
 let length { length; _ } = length
 
-let[@cold] [@inline never] raise_mutation_during_iteration t =
+let[@cold] [@inline never] [@local never] [@specialise never] raise_mutation_during_iteration
+  t
+  =
   Error.raise_s
     (Sexp.message
        "mutation of queue during iteration"
@@ -396,14 +398,14 @@ let to_list t =
 ;;
 
 module C = Indexed_container.Make (struct
-  type nonrec 'a t = 'a t
-
-  let fold = fold
-  let iter = `Custom iter
-  let length = `Custom length
-  let foldi = `Custom foldi
-  let iteri = `Custom iteri
-end)
+    type nonrec 'a t = 'a t
+
+    let fold = fold
+    let iter = `Custom iter
+    let length = `Custom length
+    let foldi = `Custom foldi
+    let iteri = `Custom iteri
+  end)
 
 let count = C.count
 let exists = C.exists
diff --git a/src/queue_intf.ml b/src/queue_intf.ml
index f4a627b8..a8b36215 100644
--- a/src/queue_intf.ml
+++ b/src/queue_intf.ml
@@ -116,7 +116,7 @@ module type Queue = sig
   include Invariant.S1 with type 'a t := 'a t
 
   (** Create an empty queue. *)
-  val create : ?capacity:int (** default is [1]. *) -> unit -> _ t
+  val create : ?capacity:int (** default is [2]. *) -> unit -> _ t
 
   (** [last t] returns the most recently enqueued element in [t], if any. *)
   val last : 'a t -> 'a option
diff --git a/src/random.ml b/src/random.ml
index 0aa4d355..ddd3e82d 100644
--- a/src/random.ml
+++ b/src/random.ml
@@ -137,7 +137,7 @@ module State = struct
       (string_of_bound lower_bound)
       (string_of_bound upper_bound)
       ()
-    [@@cold] [@@inline never] [@@local never] [@@specialise never]
+  [@@cold] [@@inline never] [@@local never] [@@specialise never]
   ;;
 
   let int_incl =
diff --git a/src/random.mli b/src/random.mli
index 9f1f9431..42b49f69 100644
--- a/src/random.mli
+++ b/src/random.mli
@@ -38,8 +38,9 @@ val full_init : int array -> unit
     nondeterministic values, like in [Filename.temp_dir]. *)
 val self_init : ?allow_in_tests:bool -> unit -> unit
 
-(** Return 30 random bits in a nonnegative integer.  @before 3.12.0 used a different
-    algorithm (affects all the following functions) *)
+(** Return 30 random bits in a nonnegative integer.
+
+    @before 3.12.0 used a different algorithm (affects all the following functions) *)
 val bits : unit -> int
 
 (** [Random.bits64 ()] returns 64 random bits as an integer between
diff --git a/src/ref.ml b/src/ref.ml
index 6c83ccfc..bb915131 100644
--- a/src/ref.ml
+++ b/src/ref.ml
@@ -1,47 +1,45 @@
 open! Import
 
 include (
-  struct
-    type 'a t = 'a ref
-    [@@deriving_inline compare ~localize, equal ~localize, globalize, sexp, sexp_grammar]
+struct
+  type 'a t = 'a ref
+  [@@deriving_inline compare ~localize, equal ~localize, globalize, sexp, sexp_grammar]
 
-    let compare__local : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int = compare_ref__local
-    let compare : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int = compare_ref
-    let equal__local : 'a. ('a -> 'a -> bool) -> 'a t -> 'a t -> bool = equal_ref__local
-    let equal : 'a. ('a -> 'a -> bool) -> 'a t -> 'a t -> bool = equal_ref
+  let compare__local : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int = compare_ref__local
+  let compare : 'a. ('a -> 'a -> int) -> 'a t -> 'a t -> int = compare_ref
+  let equal__local : 'a. ('a -> 'a -> bool) -> 'a t -> 'a t -> bool = equal_ref__local
+  let equal : 'a. ('a -> 'a -> bool) -> 'a t -> 'a t -> bool = equal_ref
 
-    let globalize : 'a. ('a -> 'a) -> 'a t -> 'a t =
-      fun (type a__017_) : ((a__017_ -> a__017_) -> a__017_ t -> a__017_ t) ->
-      globalize_ref
-    ;;
+  let globalize : 'a. ('a -> 'a) -> 'a t -> 'a t =
+    fun (type a__017_) : ((a__017_ -> a__017_) -> a__017_ t -> a__017_ t) -> globalize_ref
+  ;;
 
-    let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t = ref_of_sexp
-    let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t = sexp_of_ref
+  let t_of_sexp : 'a. (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a t = ref_of_sexp
+  let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t = sexp_of_ref
 
-    let t_sexp_grammar : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t =
-      fun _'a_sexp_grammar -> ref_sexp_grammar _'a_sexp_grammar
-    ;;
+  let t_sexp_grammar : 'a. 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t =
+    fun _'a_sexp_grammar -> ref_sexp_grammar _'a_sexp_grammar
+  ;;
 
-    [@@@end]
-  end :
-    sig
-      type 'a t = 'a ref
-      [@@deriving_inline
-        compare ~localize, equal ~localize, globalize, sexp, sexp_grammar]
+  [@@@end]
+end :
+sig
+  type 'a t = 'a ref
+  [@@deriving_inline compare ~localize, equal ~localize, globalize, sexp, sexp_grammar]
 
-      include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
-      include Ppx_compare_lib.Comparable.S_local1 with type 'a t := 'a t
-      include Ppx_compare_lib.Equal.S1 with type 'a t := 'a t
-      include Ppx_compare_lib.Equal.S_local1 with type 'a t := 'a t
+  include Ppx_compare_lib.Comparable.S1 with type 'a t := 'a t
+  include Ppx_compare_lib.Comparable.S_local1 with type 'a t := 'a t
+  include Ppx_compare_lib.Equal.S1 with type 'a t := 'a t
+  include Ppx_compare_lib.Equal.S_local1 with type 'a t := 'a t
 
-      val globalize : ('a -> 'a) -> 'a t -> 'a t
+  val globalize : ('a -> 'a) -> 'a t -> 'a t
 
-      include Sexplib0.Sexpable.S1 with type 'a t := 'a t
+  include Sexplib0.Sexpable.S1 with type 'a t := 'a t
 
-      val t_sexp_grammar : 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t
+  val t_sexp_grammar : 'a Sexplib0.Sexp_grammar.t -> 'a t Sexplib0.Sexp_grammar.t
 
-      [@@@end]
-    end)
+  [@@@end]
+end)
 
 (* In the definition of [t], we do not have [[@@deriving compare, sexp]] because
    in general, syntax extensions tend to use the implementation when available rather than
diff --git a/src/replace_polymorphic_compare.ml b/src/replace_polymorphic_compare.ml
new file mode 100644
index 00000000..2c47b6db
--- /dev/null
+++ b/src/replace_polymorphic_compare.ml
@@ -0,0 +1,243 @@
+[@@@warning "-preprocessor"]
+
+include Replace_polymorphic_compare_intf
+
+module Bool_replace_polymorphic_compare = struct
+  type t = bool [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Bytes_replace_polymorphic_compare = struct
+  type t = bytes [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Char_replace_polymorphic_compare = struct
+  type t = char [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Float_replace_polymorphic_compare = struct
+  type t = float [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Int32_replace_polymorphic_compare = struct
+  type t = int32 [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Int64_replace_polymorphic_compare = struct
+  type t = int64 [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Int_replace_polymorphic_compare = struct
+  type t = int [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Nativeint_replace_polymorphic_compare = struct
+  type t = nativeint [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module String_replace_polymorphic_compare = struct
+  type t = string [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
+
+module Uchar_replace_polymorphic_compare = struct
+  type t = Stdlib.Uchar.t [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+
+  let ascending x y = compare x y
+  let descending x y = compare y x
+  let max x y = Bool0.select (x >= y) x y
+  let min x y = Bool0.select (x <= y) x y
+
+  [@@@end]
+end
diff --git a/src/replace_polymorphic_compare.mli b/src/replace_polymorphic_compare.mli
new file mode 100644
index 00000000..57024897
--- /dev/null
+++ b/src/replace_polymorphic_compare.mli
@@ -0,0 +1 @@
+include Replace_polymorphic_compare_intf.Replace_polymorphic_compare
diff --git a/src/replace_polymorphic_compare_intf.ml b/src/replace_polymorphic_compare_intf.ml
new file mode 100644
index 00000000..994af270
--- /dev/null
+++ b/src/replace_polymorphic_compare_intf.ml
@@ -0,0 +1,39 @@
+[@@@warning "-preprocessor"]
+
+module type S = sig
+  type t [@@deriving_inline specialize_polymorphic_compare]
+
+  [@@@ocaml.ppwarning "ppx_base_internal: intended only for use inside Base"]
+
+  external ( = ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external ( <> ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%notequal"
+  external ( < ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessthan"
+  external ( > ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterthan"
+  external ( <= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%lessequal"
+  external ( >= ) : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%greaterequal"
+  external compare : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external compare__local : (t[@local_opt]) -> (t[@local_opt]) -> int = "%compare"
+  external equal : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  external equal__local : (t[@local_opt]) -> (t[@local_opt]) -> bool = "%equal"
+  val ascending : t -> t -> int
+  val descending : t -> t -> int
+  val max : t -> t -> t
+  val min : t -> t -> t
+
+  [@@@end]
+end
+
+module type Replace_polymorphic_compare = sig
+  module type S = S
+
+  module Bool_replace_polymorphic_compare : S with type t := bool
+  module Bytes_replace_polymorphic_compare : S with type t := bytes
+  module Char_replace_polymorphic_compare : S with type t := char
+  module Float_replace_polymorphic_compare : S with type t := float
+  module Int32_replace_polymorphic_compare : S with type t := int32
+  module Int64_replace_polymorphic_compare : S with type t := int64
+  module Int_replace_polymorphic_compare : S with type t := int
+  module Nativeint_replace_polymorphic_compare : S with type t := nativeint
+  module String_replace_polymorphic_compare : S with type t := string
+  module Uchar_replace_polymorphic_compare : S with type t := Stdlib.Uchar.t
+end
diff --git a/src/result.ml b/src/result.ml
index d095d774..684293c7 100644
--- a/src/result.ml
+++ b/src/result.ml
@@ -6,9 +6,9 @@ type ('a, 'b) t = ('a, 'b) Stdlib.result =
   | Error of 'b
 [@@deriving_inline sexp, sexp_grammar, compare ~localize, equal ~localize, hash]
 
-let t_of_sexp :
-      'a 'b.
-      (Sexplib0.Sexp.t -> 'a) -> (Sexplib0.Sexp.t -> 'b) -> Sexplib0.Sexp.t -> ('a, 'b) t
+let t_of_sexp
+  : 'a 'b.
+  (Sexplib0.Sexp.t -> 'a) -> (Sexplib0.Sexp.t -> 'b) -> Sexplib0.Sexp.t -> ('a, 'b) t
   =
   fun (type a__017_ b__018_)
     :  ((Sexplib0.Sexp.t -> a__017_) -> (Sexplib0.Sexp.t -> b__018_) -> Sexplib0.Sexp.t
@@ -19,7 +19,7 @@ let t_of_sexp :
         (Sexplib0.Sexp.Atom (("ok" | "Ok") as _tag__008_) :: sexp_args__009_) as
       _sexp__007_ ->
       (match sexp_args__009_ with
-       | [ arg0__010_ ] ->
+       | arg0__010_ :: [] ->
          let res0__011_ = _of_a__001_ arg0__010_ in
          Ok res0__011_
        | _ ->
@@ -31,7 +31,7 @@ let t_of_sexp :
         (Sexplib0.Sexp.Atom (("error" | "Error") as _tag__013_) :: sexp_args__014_) as
       _sexp__012_ ->
       (match sexp_args__014_ with
-       | [ arg0__015_ ] ->
+       | arg0__015_ :: [] ->
          let res0__016_ = _of_b__002_ arg0__015_ in
          Error res0__016_
        | _ ->
@@ -47,12 +47,16 @@ let t_of_sexp :
       Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__005_ sexp__004_
     | Sexplib0.Sexp.List [] as sexp__004_ ->
       Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__005_ sexp__004_
-    | sexp__004_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__005_ sexp__004_
+    | sexp__004_ ->
+      Sexplib0.Sexp_conv_error.unexpected_stag
+        error_source__005_
+        [ "Ok"; "Error" ]
+        sexp__004_
 ;;
 
-let sexp_of_t :
-      'a 'b.
-      ('a -> Sexplib0.Sexp.t) -> ('b -> Sexplib0.Sexp.t) -> ('a, 'b) t -> Sexplib0.Sexp.t
+let sexp_of_t
+  : 'a 'b.
+  ('a -> Sexplib0.Sexp.t) -> ('b -> Sexplib0.Sexp.t) -> ('a, 'b) t -> Sexplib0.Sexp.t
   =
   fun (type a__025_ b__026_)
     :  ((a__025_ -> Sexplib0.Sexp.t) -> (b__026_ -> Sexplib0.Sexp.t)
@@ -66,11 +70,11 @@ let sexp_of_t :
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Error"; res0__024_ ]
 ;;
 
-let t_sexp_grammar :
-      'a 'b.
-      'a Sexplib0.Sexp_grammar.t
-      -> 'b Sexplib0.Sexp_grammar.t
-      -> ('a, 'b) t Sexplib0.Sexp_grammar.t
+let t_sexp_grammar
+  : 'a 'b.
+  'a Sexplib0.Sexp_grammar.t
+  -> 'b Sexplib0.Sexp_grammar.t
+  -> ('a, 'b) t Sexplib0.Sexp_grammar.t
   =
   fun _'a_sexp_grammar _'b_sexp_grammar ->
   { untyped =
@@ -92,8 +96,8 @@ let t_sexp_grammar :
   }
 ;;
 
-let compare__local :
-      'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
+let compare__local
+  : 'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
   =
   fun _cmp__a _cmp__b a__033_ b__034_ ->
   if Stdlib.( == ) a__033_ b__034_
@@ -106,8 +110,8 @@ let compare__local :
     | Error _a__037_, Error _b__038_ -> _cmp__b _a__037_ _b__038_)
 ;;
 
-let compare :
-      'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
+let compare
+  : 'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
   =
   fun _cmp__a _cmp__b a__027_ b__028_ ->
   if Stdlib.( == ) a__027_ b__028_
@@ -120,8 +124,8 @@ let compare :
     | Error _a__031_, Error _b__032_ -> _cmp__b _a__031_ _b__032_)
 ;;
 
-let equal__local :
-      'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
+let equal__local
+  : 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
   =
   fun _cmp__a _cmp__b a__045_ b__046_ ->
   if Stdlib.( == ) a__045_ b__046_
@@ -134,8 +138,8 @@ let equal__local :
     | Error _a__049_, Error _b__050_ -> _cmp__b _a__049_ _b__050_)
 ;;
 
-let equal :
-      'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
+let equal
+  : 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
   =
   fun _cmp__a _cmp__b a__039_ b__040_ ->
   if Stdlib.( == ) a__039_ b__040_
@@ -173,23 +177,23 @@ let hash_fold_t
 let globalize = globalize_result
 
 include Monad.Make2_local (struct
-  type nonrec ('a, 'b) t = ('a, 'b) t
+    type nonrec ('a, 'b) t = ('a, 'b) t
 
-  let bind x ~f =
-    match x with
-    | Error _ as x -> x
-    | Ok x -> f x
-  ;;
+    let bind x ~f =
+      match x with
+      | Error _ as x -> x
+      | Ok x -> f x
+    ;;
 
-  let map x ~f =
-    match x with
-    | Error _ as x -> x
-    | Ok x -> Ok (f x)
-  ;;
+    let map x ~f =
+      match x with
+      | Error _ as x -> x
+      | Ok x -> Ok (f x)
+    ;;
 
-  let map = `Custom map
-  let return x = Ok x
-end)
+    let map = `Custom map
+    let return x = Ok x
+  end)
 
 let invariant check_ok check_error t =
   match t with
@@ -207,17 +211,17 @@ let map_error t ~f =
 ;;
 
 module Error = Monad.Make2_local (struct
-  type nonrec ('a, 'b) t = ('b, 'a) t
+    type nonrec ('a, 'b) t = ('b, 'a) t
 
-  let bind x ~f =
-    match x with
-    | Ok _ as ok -> ok
-    | Error e -> f e
-  ;;
+    let bind x ~f =
+      match x with
+      | Ok _ as ok -> ok
+      | Error e -> f e
+    ;;
 
-  let map = `Custom map_error
-  let return e = Error e
-end)
+    let map = `Custom map_error
+    let return e = Error e
+  end)
 
 let is_ok = function
   | Ok _ -> true
diff --git a/src/runtime.js b/src/runtime.js
index 01341b4f..88bdbc63 100644
--- a/src/runtime.js
+++ b/src/runtime.js
@@ -1,10 +1,3 @@
-//Provides: Base_int_math_int_popcount const
-function Base_int_math_int_popcount(v) {
-  v = v - ((v >>> 1) & 0x55555555);
-  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
-  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
-}
-
 //Provides: Base_clear_caml_backtrace_pos const
 function Base_clear_caml_backtrace_pos(x) {
   return 0;
@@ -15,92 +8,6 @@ function Base_caml_exn_is_most_recent_exn(x) {
   return 1;
 }
 
-//Provides: Base_int_math_int32_clz const
-function Base_int_math_int32_clz(x) {
-  var n = 32;
-  var y;
-  y = x >> 16; if (y != 0) { n = n - 16; x = y; }
-  y = x >> 8; if (y != 0) { n = n - 8; x = y; }
-  y = x >> 4; if (y != 0) { n = n - 4; x = y; }
-  y = x >> 2; if (y != 0) { n = n - 2; x = y; }
-  y = x >> 1; if (y != 0) return n - 2;
-  return n - x;
-}
-
-//Provides: Base_int_math_int_clz const
-//Requires: Base_int_math_int32_clz
-function Base_int_math_int_clz(x) { return Base_int_math_int32_clz(x); }
-
-//Provides: Base_int_math_nativeint_clz const
-//Requires: Base_int_math_int32_clz
-function Base_int_math_nativeint_clz(x) { return Base_int_math_int32_clz(x); }
-
-//Provides: Base_int_math_int64_clz const
-//Requires: caml_int64_shift_right_unsigned, caml_int64_is_zero, caml_int64_to_int32
-function Base_int_math_int64_clz(x) {
-  var n = 64;
-  var y;
-  y = caml_int64_shift_right_unsigned(x, 32);
-  if (!caml_int64_is_zero(y)) { n = n - 32; x = y; }
-  y = caml_int64_shift_right_unsigned(x, 16);
-  if (!caml_int64_is_zero(y)) { n = n - 16; x = y; }
-  y = caml_int64_shift_right_unsigned(x, 8);
-  if (!caml_int64_is_zero(y)) { n = n - 8; x = y; }
-  y = caml_int64_shift_right_unsigned(x, 4);
-  if (!caml_int64_is_zero(y)) { n = n - 4; x = y; }
-  y = caml_int64_shift_right_unsigned(x, 2);
-  if (!caml_int64_is_zero(y)) { n = n - 2; x = y; }
-  y = caml_int64_shift_right_unsigned(x, 1);
-  if (!caml_int64_is_zero(y)) return n - 2;
-  return n - caml_int64_to_int32(x);
-}
-
-//Provides: Base_int_math_int32_ctz const
-function Base_int_math_int32_ctz(x) {
-  if (x === 0) { return 32; }
-  var n = 1;
-  if ((x & 0x0000FFFF) === 0) { n = n + 16; x = x >> 16; }
-  if ((x & 0x000000FF) === 0) { n = n + 8; x = x >> 8; }
-  if ((x & 0x0000000F) === 0) { n = n + 4; x = x >> 4; }
-  if ((x & 0x00000003) === 0) { n = n + 2; x = x >> 2; }
-  return n - (x & 1);
-}
-
-//Provides: Base_int_math_int_ctz const
-//Requires: Base_int_math_int32_ctz
-function Base_int_math_int_ctz(x) { return Base_int_math_int32_ctz(x); }
-
-//Provides: Base_int_math_nativeint_ctz const
-//Requires: Base_int_math_int32_ctz
-function Base_int_math_nativeint_ctz(x) { return Base_int_math_int32_ctz(x); }
-
-//Provides: Base_int_math_int64_ctz const
-//Requires: caml_int64_shift_right_unsigned, caml_int64_is_zero, caml_int64_to_int32
-//Requires: caml_int64_and, caml_int64_of_int32, caml_int64_create_lo_mi_hi
-function Base_int_math_int64_ctz(x) {
-  if (caml_int64_is_zero(x)) { return 64; }
-  var n = 1;
-  function is_zero(x) { return caml_int64_is_zero(x); }
-  function land(x, y) { return caml_int64_and(x, y); }
-  function small_int64(x) { return caml_int64_create_lo_mi_hi(x, 0, 0); }
-  if (is_zero(land(x, caml_int64_create_lo_mi_hi(0xFFFFFF, 0x0000FF, 0x0000)))) {
-    n = n + 32; x = caml_int64_shift_right_unsigned(x, 32);
-  }
-  if (is_zero(land(x, small_int64(0x00FFFF)))) {
-    n = n + 16; x = caml_int64_shift_right_unsigned(x, 16);
-  }
-  if (is_zero(land(x, small_int64(0x0000FF)))) {
-    n = n + 8; x = caml_int64_shift_right_unsigned(x, 8);
-  }
-  if (is_zero(land(x, small_int64(0x00000F)))) {
-    n = n + 4; x = caml_int64_shift_right_unsigned(x, 4);
-  }
-  if (is_zero(land(x, small_int64(0x000003)))) {
-    n = n + 2; x = caml_int64_shift_right_unsigned(x, 2);
-  }
-  return n - (caml_int64_to_int32(caml_int64_and(x, small_int64(0x000001))));
-}
-
 //Provides: Base_int_math_int_pow_stub const
 function Base_int_math_int_pow_stub(base, exponent) {
   var one = 1;
@@ -169,3 +76,24 @@ function caml_make_local_vect(v_len, v_elt) {
 function caml_dummy_obj_is_stack(x) {
   throw new Error(`BUG: this function should be unreachable; please report to compiler or base devs.`);
 }
+
+//Provides: caml_dummy_obj_is_stack
+function caml_dummy_obj_is_stack(x) {
+  throw new Error(`BUG: this function should be unreachable; please report to compiler or base devs.`);
+}
+
+//Provides: Base_caml_modf_positive_float_unboxed_exn
+//Requires: caml_invalid_argument
+function Base_caml_modf_positive_float_unboxed_exn(a, b) {
+  if (b < 0) {
+    caml_invalid_argument(`${a} % ${b} in float.ml: modulus should be positive`)
+  }
+  let m = a % b;
+  return m < 0 ? m + b : m;
+}
+
+//Provides: Base_caml_modf_positive_float_exn
+//Requires: Base_caml_modf_positive_float_unboxed_exn
+function Base_caml_modf_positive_float_exn(a, b) {
+  return Base_caml_modf_positive_float_unboxed_exn(a, b);
+}
diff --git a/src/runtime.wat b/src/runtime.wat
new file mode 100644
index 00000000..2da2e03b
--- /dev/null
+++ b/src/runtime.wat
@@ -0,0 +1,195 @@
+(module
+   (import "env" "caml_copy_int64"
+      (func $caml_copy_int64 (param i64) (result (ref eq))))
+   (import "env" "caml_copy_int32"
+      (func $caml_copy_int32 (param i32) (result (ref eq))))
+   (import "env" "Int64_val" (func $Int64_val (param (ref eq)) (result i64)))
+   (import "env" "Int32_val" (func $Int32_val (param (ref eq)) (result i32)))
+   (import "env" "caml_hash"
+      (func $caml_hash
+         (param (ref eq)) (param (ref eq)) (param (ref eq)) (param (ref eq))
+         (result (ref eq))))
+   (import "env" "caml_create_bytes"
+      (func $caml_create_bytes (param (ref eq)) (result (ref eq))))
+   (import "env" "caml_make_vect"
+      (func $caml_make_vect
+         (param (ref eq)) (param (ref eq)) (result (ref eq))))
+   (import "env" "Double_val"
+      (func $Double_val (param (ref eq)) (result f64)))
+   (import "env" "caml_hash_mix_string"
+      (func $caml_hash_mix_string (param i32 (ref $string)) (result i32)))
+   (import "env" "caml_hash_mix_final"
+      (func $caml_hash_mix_final (param i32) (result i32)))
+   (import "env" "caml_hash_mix_double"
+      (func $caml_hash_mix_double (param i32 f64) (result i32)))
+   (import "Math" "fmod"
+      (func $fmod (param f64) (param f64) (result f64)))
+   (import "env" "caml_invalid_argument"
+      (func $caml_invalid_argument (param (ref eq))))
+
+   (type $string (array (mut i8)))
+   (type $float (struct (field f64)))
+
+   (func (export "Base_int_math_int_popcount")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.popcnt (i31.get_u (ref.cast (ref i31) (local.get 0))))))
+
+   (func (export "Base_int_math_int_clz")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31
+         (i32.clz
+            (i32.or
+               (i32.shl
+                  (i31.get_s (ref.cast (ref i31) (local.get 0)))
+                  (i32.const 1))
+               (i32.const 1)))))
+
+   (export "Base_int_math_nativeint_clz" (func $Base_int_math_int32_clz))
+   (func $Base_int_math_int32_clz (export "Base_int_math_int32_clz")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.clz (call $Int32_val (local.get 0)))))
+
+   (func (export "Base_int_math_int64_clz")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.wrap_i64 (i64.clz (call $Int64_val (local.get 0))))))
+
+   (func (export "Base_int_math_int_ctz")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31
+         (i32.ctz (i31.get_s (ref.cast (ref i31) (local.get 0))))))
+
+   (export "Base_int_math_nativeint_ctz" (func $Base_int_math_int32_ctz))
+   (func $Base_int_math_int32_ctz (export "Base_int_math_int32_ctz")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.ctz (call $Int32_val (local.get 0)))))
+
+   (func (export "Base_int_math_int64_ctz")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31
+         (i32.wrap_i64
+            (i64.ctz (call $Int64_val (local.get 0))))))
+
+   (func (export "Base_int_math_int_pow_stub")
+      (param $vbase (ref eq)) (param $vexp (ref eq)) (result (ref eq))
+      (local $base i32) (local $exp i32) (local $res i32)
+      (local.set $base (i31.get_s (ref.cast (ref i31) (local.get $vbase))))
+      (local.set $exp (i31.get_s (ref.cast (ref i31) (local.get $vexp))))
+      (local.set $res (i32.const 1))
+      (loop $loop
+         (if (i32.ne (local.get $exp) (i32.const 0))
+            (then
+               (if (i32.and (local.get $exp) (i32.const 1))
+                  (then
+                     (local.set $res
+                        (i32.mul (local.get $res) (local.get $base)))))
+               (local.set $exp (i32.shr_u (local.get $exp) (i32.const 1)))
+               (local.set $base (i32.mul (local.get $base) (local.get $base)))
+               (br $loop))))
+      (ref.i31 (local.get $res)))
+
+   (func (export "Base_int_math_int64_pow_stub")
+      (param $vbase (ref eq)) (param $vexp (ref eq)) (result (ref eq))
+      (local $base i64) (local $exp i64) (local $res i64)
+      (local.set $base (call $Int64_val (local.get $vbase)))
+      (local.set $exp (call $Int64_val (local.get $vexp)))
+      (local.set $res (i64.const 1))
+      (loop $loop
+         (if (i64.ne (local.get $exp) (i64.const 0))
+            (then
+               (if (i32.wrap_i64 (i64.and (local.get $exp) (i64.const 1)))
+                  (then
+                     (local.set $res
+                        (i64.mul (local.get $res) (local.get $base)))))
+               (local.set $exp (i64.shr_u (local.get $exp) (i64.const 1)))
+               (local.set $base (i64.mul (local.get $base) (local.get $base)))
+               (br $loop))))
+      (return_call $caml_copy_int64 (local.get $res)))
+
+   (func (export "Base_clear_caml_backtrace_pos")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 0)))
+
+   (func (export "Base_caml_exn_is_most_recent_exn")
+      (param (ref eq)) (result (ref eq))
+      (ref.i31 (i32.const 1)))
+
+   (func (export "Base_hash_string") (param $s (ref eq)) (result (ref eq))
+      (local $h i32)
+      (local.set $h
+         (call $caml_hash_mix_string (i32.const 0)
+                                     (ref.cast (ref $string) (local.get $s))))
+      (ref.i31
+         (i32.and (call $caml_hash_mix_final (local.get $h))
+                  (i32.const 0x3FFFFFFF))))
+
+   (func (export "Base_hash_double") (param $d (ref eq)) (result (ref eq))
+      (local $h i32)
+      (local.set $h
+         (call $caml_hash_mix_double (i32.const 0)
+                                     (call $Double_val (local.get $d))))
+      (ref.i31
+         (i32.and (call $caml_hash_mix_final (local.get $h))
+                  (i32.const 0x3FFFFFFF))))
+
+   (global $Base_am_testing_flag (export "Base_am_testing_flag") (mut i32)
+      (i32.const 0))
+
+   (func (export "Base_am_testing") (param (ref eq)) (result (ref eq))
+      (ref.i31 (global.get $Base_am_testing_flag)))
+
+   (export "Base_unsafe_create_local_bytes" (func $caml_create_bytes))
+
+   (export "caml_make_local_vect" (func $caml_make_vect))
+
+   (data $modulus_positive "float.ml: modulus should be positive")
+
+   (func $modf_pos_u (param $a f64) (param $b f64) (result f64)
+      (local $m f64)
+      (if (f64.lt (local.get $b) (f64.const 0))
+         (then
+            (call $caml_invalid_argument
+               (array.new_data $string $modulus_positive
+                  (i32.const 0) (i32.const 36)))))
+      (local.set $m (call $fmod
+         (local.get $a)
+         (local.get $b)))
+      (if (result f64) (f64.lt (local.get $m) (f64.const 0))
+         (then (f64.add (local.get $m) (local.get $b)))
+         (else (local.get $m))))
+
+   (func $modf_pos (param $a (ref eq)) (param $b (ref eq)) (result (ref eq))
+      (struct.new $float (call $modf_pos_u
+         (call $Double_val (local.get $a))
+         (call $Double_val (local.get $b)))))
+
+   ;; The unboxed version of this function never gets called, but it needs to
+   ;; exist or else the wasm module won't validate. In JavaScript you can just not define
+   ;; these and there's no issue since the unboxed impl won't get called. There aren't a
+   ;; ton of instances of this that I can find, but in float.ml right under these you can
+   ;; see: `external ( ** ) : t -> t -> t = "caml_power_float" "pow" [@@unboxed] [@@noalloc]`
+   ;; and both caml_power_float and pow are handled in js_of_ocaml generate. I think the
+   ;; unique thing here is that this behavior doesn't align with existing primitives, so
+   ;; it'd be a larger set of changes to js_of_ocaml source to support directly there, and
+   ;; since these primitives are Base specific, it feels more appropriate to write here
+   ;; and include the unboxed version correctly working.
+   (export "Base_caml_modf_positive_float_unboxed_exn" (func $modf_pos_u))
+   (export "Base_caml_modf_positive_float_exn" (func $modf_pos))
+
+   (func (export "caml_float_min")
+      (param $x (ref eq)) (param $y (ref eq)) (result (ref eq))
+      (if (result (ref eq))
+          (f64.lt
+             (call $Double_val (local.get $x))
+             (call $Double_val (local.get $y)))
+         (then (local.get $x))
+         (else (local.get $y))))
+
+   (func (export "caml_float_max")
+      (param $x (ref eq)) (param $y (ref eq)) (result (ref eq))
+      (if (result (ref eq))
+          (f64.gt
+             (call $Double_val (local.get $x))
+             (call $Double_val (local.get $y)))
+         (then (local.get $x))
+         (else (local.get $y))))
+)
diff --git a/src/sequence.ml b/src/sequence.ml
index ecbba2a3..84825edd 100644
--- a/src/sequence.ml
+++ b/src/sequence.ml
@@ -15,12 +15,9 @@ module Step = struct
         }
   [@@deriving_inline sexp_of]
 
-  let sexp_of_t :
-        'a 's.
-        ('a -> Sexplib0.Sexp.t)
-        -> ('s -> Sexplib0.Sexp.t)
-        -> ('a, 's) t
-        -> Sexplib0.Sexp.t
+  let sexp_of_t
+    : 'a 's.
+    ('a -> Sexplib0.Sexp.t) -> ('s -> Sexplib0.Sexp.t) -> ('a, 's) t -> Sexplib0.Sexp.t
     =
     fun (type a__011_ s__012_)
       :  ((a__011_ -> Sexplib0.Sexp.t) -> (s__012_ -> Sexplib0.Sexp.t)
@@ -32,7 +29,7 @@ module Step = struct
       let bnds__003_ =
         let arg__005_ = _of_s__002_ state__004_ in
         (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "state"; arg__005_ ] :: bnds__003_
-          : _ Stdlib.List.t)
+         : _ Stdlib.List.t)
       in
       Sexplib0.Sexp.List (Sexplib0.Sexp.Atom "Skip" :: bnds__003_)
     | Yield { value = value__007_; state = state__009_ } ->
@@ -40,12 +37,12 @@ module Step = struct
       let bnds__006_ =
         let arg__010_ = _of_s__002_ state__009_ in
         (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "state"; arg__010_ ] :: bnds__006_
-          : _ Stdlib.List.t)
+         : _ Stdlib.List.t)
       in
       let bnds__006_ =
         let arg__008_ = _of_a__001_ value__007_ in
         (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "value"; arg__008_ ] :: bnds__006_
-          : _ Stdlib.List.t)
+         : _ Stdlib.List.t)
       in
       Sexplib0.Sexp.List (Sexplib0.Sexp.Atom "Yield" :: bnds__006_)
   ;;
@@ -459,12 +456,12 @@ let return x =
 ;;
 
 include Monad.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let map = `Custom map
-  let bind = bind
-  let return = return
-end)
+    let map = `Custom map
+    let bind = bind
+    let return = return
+  end)
 
 let nth s n =
   if n < 0
@@ -497,8 +494,8 @@ module Merge_with_duplicates_element = struct
     | Both of 'a * 'b
   [@@deriving_inline compare ~localize, equal ~localize, hash, sexp, sexp_grammar]
 
-  let compare__local :
-        'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
+  let compare__local
+    : 'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
     =
     fun _cmp__a _cmp__b a__023_ b__024_ ->
     if Stdlib.( == ) a__023_ b__024_
@@ -517,8 +514,8 @@ module Merge_with_duplicates_element = struct
          | n -> n))
   ;;
 
-  let compare :
-        'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
+  let compare
+    : 'a 'b. ('a -> 'a -> int) -> ('b -> 'b -> int) -> ('a, 'b) t -> ('a, 'b) t -> int
     =
     fun _cmp__a _cmp__b a__013_ b__014_ ->
     if Stdlib.( == ) a__013_ b__014_
@@ -537,9 +534,8 @@ module Merge_with_duplicates_element = struct
          | n -> n))
   ;;
 
-  let equal__local :
-        'a 'b.
-        ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
+  let equal__local
+    : 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
     =
     fun _cmp__a _cmp__b a__043_ b__044_ ->
     if Stdlib.( == ) a__043_ b__044_
@@ -556,9 +552,8 @@ module Merge_with_duplicates_element = struct
         Stdlib.( && ) (_cmp__a _a__049_ _b__050_) (_cmp__b _a__051_ _b__052_))
   ;;
 
-  let equal :
-        'a 'b.
-        ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
+  let equal
+    : 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a, 'b) t -> ('a, 'b) t -> bool
     =
     fun _cmp__a _cmp__b a__033_ b__034_ ->
     if Stdlib.( == ) a__033_ b__034_
@@ -602,12 +597,9 @@ module Merge_with_duplicates_element = struct
       _hash_fold_b hsv _a1
   ;;
 
-  let t_of_sexp :
-        'a 'b.
-        (Sexplib0.Sexp.t -> 'a)
-        -> (Sexplib0.Sexp.t -> 'b)
-        -> Sexplib0.Sexp.t
-        -> ('a, 'b) t
+  let t_of_sexp
+    : 'a 'b.
+    (Sexplib0.Sexp.t -> 'a) -> (Sexplib0.Sexp.t -> 'b) -> Sexplib0.Sexp.t -> ('a, 'b) t
     =
     fun (type a__076_ b__077_)
       :  ((Sexplib0.Sexp.t -> a__076_) -> (Sexplib0.Sexp.t -> b__077_) -> Sexplib0.Sexp.t
@@ -662,15 +654,15 @@ module Merge_with_duplicates_element = struct
       | Sexplib0.Sexp.List [] as sexp__056_ ->
         Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__057_ sexp__056_
       | sexp__056_ ->
-        Sexplib0.Sexp_conv_error.unexpected_stag error_source__057_ sexp__056_
+        Sexplib0.Sexp_conv_error.unexpected_stag
+          error_source__057_
+          [ "Left"; "Right"; "Both" ]
+          sexp__056_
   ;;
 
-  let sexp_of_t :
-        'a 'b.
-        ('a -> Sexplib0.Sexp.t)
-        -> ('b -> Sexplib0.Sexp.t)
-        -> ('a, 'b) t
-        -> Sexplib0.Sexp.t
+  let sexp_of_t
+    : 'a 'b.
+    ('a -> Sexplib0.Sexp.t) -> ('b -> Sexplib0.Sexp.t) -> ('a, 'b) t -> Sexplib0.Sexp.t
     =
     fun (type a__088_ b__089_)
       :  ((a__088_ -> Sexplib0.Sexp.t) -> (b__089_ -> Sexplib0.Sexp.t)
@@ -688,11 +680,11 @@ module Merge_with_duplicates_element = struct
       Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Both"; res0__086_; res1__087_ ]
   ;;
 
-  let t_sexp_grammar :
-        'a 'b.
-        'a Sexplib0.Sexp_grammar.t
-        -> 'b Sexplib0.Sexp_grammar.t
-        -> ('a, 'b) t Sexplib0.Sexp_grammar.t
+  let t_sexp_grammar
+    : 'a 'b.
+    'a Sexplib0.Sexp_grammar.t
+    -> 'b Sexplib0.Sexp_grammar.t
+    -> ('a, 'b) t Sexplib0.Sexp_grammar.t
     =
     fun _'a_sexp_grammar _'b_sexp_grammar ->
     { untyped =
@@ -905,18 +897,18 @@ let append s1 s2 =
       { state = `First_list s1
       ; next =
           (function
-           | `First_list s1 ->
-             (match next1 s1 with
-              | Done -> Skip { state = `Second_list s2 }
-              | Skip { state = s1 } -> Skip { state = `First_list s1 }
-              | Yield { value = a; state = s1 } ->
-                Yield { value = a; state = `First_list s1 })
-           | `Second_list s2 ->
-             (match next2 s2 with
-              | Done -> Done
-              | Skip { state = s2 } -> Skip { state = `Second_list s2 }
-              | Yield { value = a; state = s2 } ->
-                Yield { value = a; state = `Second_list s2 }))
+            | `First_list s1 ->
+              (match next1 s1 with
+               | Done -> Skip { state = `Second_list s2 }
+               | Skip { state = s1 } -> Skip { state = `First_list s1 }
+               | Yield { value = a; state = s1 } ->
+                 Yield { value = a; state = `First_list s1 })
+            | `Second_list s2 ->
+              (match next2 s2 with
+               | Done -> Done
+               | Skip { state = s2 } -> Skip { state = `Second_list s2 }
+               | Yield { value = a; state = s2 } ->
+                 Yield { value = a; state = `Second_list s2 }))
       }
 ;;
 
@@ -1134,13 +1126,14 @@ let drop_while s ~f =
       { state = `Dropping s
       ; next =
           (function
-           | `Dropping s ->
-             (match next s with
-              | Done -> Done
-              | Skip { state = s } -> Skip { state = `Dropping s }
-              | Yield { value = a; state = s } when f a -> Skip { state = `Dropping s }
-              | Yield { value = a; state = s } -> Yield { value = a; state = `Identity s })
-           | `Identity s -> lift_identity next s)
+            | `Dropping s ->
+              (match next s with
+               | Done -> Done
+               | Skip { state = s } -> Skip { state = `Dropping s }
+               | Yield { value = a; state = s } when f a -> Skip { state = `Dropping s }
+               | Yield { value = a; state = s } ->
+                 Yield { value = a; state = `Identity s })
+            | `Identity s -> lift_identity next s)
       }
 ;;
 
@@ -1151,8 +1144,8 @@ let shift_right s x =
       { state = `Consing (seed, x)
       ; next =
           (function
-           | `Consing (seed, x) -> Yield { value = x; state = `Identity seed }
-           | `Identity s -> lift_identity next s)
+            | `Consing (seed, x) -> Yield { value = x; state = `Identity seed }
+            | `Identity s -> lift_identity next s)
       }
 ;;
 
@@ -1170,18 +1163,18 @@ let intersperse s ~sep =
       { state = `Init s
       ; next =
           (function
-           | `Init s ->
-             (match next s with
-              | Done -> Done
-              | Skip { state = s } -> Skip { state = `Init s }
-              | Yield { value = a; state = s } -> Yield { value = a; state = `Running s })
-           | `Running s ->
-             (match next s with
-              | Done -> Done
-              | Skip { state = s } -> Skip { state = `Running s }
-              | Yield { value = a; state = s } ->
-                Yield { value = sep; state = `Putting (a, s) })
-           | `Putting (a, s) -> Yield { value = a; state = `Running s })
+            | `Init s ->
+              (match next s with
+               | Done -> Done
+               | Skip { state = s } -> Skip { state = `Init s }
+               | Yield { value = a; state = s } -> Yield { value = a; state = `Running s })
+            | `Running s ->
+              (match next s with
+               | Done -> Done
+               | Skip { state = s } -> Skip { state = `Running s }
+               | Yield { value = a; state = s } ->
+                 Yield { value = sep; state = `Putting (a, s) })
+            | `Putting (a, s) -> Yield { value = a; state = `Running s })
       }
 ;;
 
diff --git a/src/set.ml b/src/set.ml
index 66641ca7..86a584a9 100644
--- a/src/set.ml
+++ b/src/set.ml
@@ -47,8 +47,8 @@ module Tree0 = struct
     | Node { left = _; elt = _; right = _; height = _; size = s } -> s
   ;;
 
-  let invariants =
-    let in_range lower upper compare_elt v =
+  let order_invariants =
+    let in_range ~lower ~upper compare_elt v =
       (match lower with
        | None -> true
        | Some lower -> compare_elt lower v < 0)
@@ -57,23 +57,34 @@ module Tree0 = struct
       | None -> true
       | Some upper -> compare_elt v upper < 0
     in
-    let rec loop lower upper compare_elt t =
+    let rec loop ~lower ~upper compare_elt t =
       match t with
       | Empty -> true
-      | Leaf { elt = v } -> in_range lower upper compare_elt v
-      | Node { left = l; elt = v; right = r; height = h; size = n } ->
-        let hl = height l
-        and hr = height r in
-        abs (hl - hr) <= 2
-        && h = max hl hr + 1
-        && n = length l + length r + 1
-        && in_range lower upper compare_elt v
-        && loop lower (Some v) compare_elt l
-        && loop (Some v) upper compare_elt r
+      | Leaf { elt = v } -> in_range ~lower ~upper compare_elt v
+      | Node { left = l; elt = v; right = r; height = _; size = _ } ->
+        in_range ~lower ~upper compare_elt v
+        && loop ~lower ~upper:(Some v) compare_elt l
+        && loop ~lower:(Some v) ~upper compare_elt r
     in
-    fun t ~compare_elt -> loop None None compare_elt t
+    fun t ~compare_elt -> loop ~lower:None ~upper:None compare_elt t
+  ;;
+
+  let rec balance_invariants t =
+    match t with
+    | Empty | Leaf _ -> true
+    | Node { left = l; elt = _; right = r; height = h; size = n } ->
+      let hl = height l
+      and hr = height r in
+      abs (hl - hr) <= 2
+      && h = max hl hr + 1
+      && n = length l + length r + 1
+      && h > 1
+      && balance_invariants l
+      && balance_invariants r
   ;;
 
+  let invariants t ~compare_elt = order_invariants t ~compare_elt && balance_invariants t
+
   let is_empty = function
     | Empty -> true
     | Leaf { elt = _ } | Node _ -> false
@@ -473,21 +484,14 @@ module Tree0 = struct
       else (
         match s1, s2 with
         | Empty, t | t, Empty -> t
-        | Leaf { elt = v1 }, _ ->
-          union (Node { left = Empty; elt = v1; right = Empty; height = 1; size = 1 }) s2
-        | _, Leaf { elt = v2 } ->
-          union s1 (Node { left = Empty; elt = v2; right = Empty; height = 1; size = 1 })
+        | Leaf { elt = v1 }, _ -> add s2 v1 ~compare_elt
+        | _, Leaf { elt = v2 } -> add s1 v2 ~compare_elt
         | ( Node { left = l1; elt = v1; right = r1; height = h1; size = _ }
           , Node { left = l2; elt = v2; right = r2; height = h2; size = _ } ) ->
           if h1 >= h2
-          then
-            if h2 = 1
-            then add s1 v2 ~compare_elt
-            else (
-              let l2, _, r2 = split s2 v1 ~compare_elt in
-              join (union l1 l2) v1 (union r1 r2))
-          else if h1 = 1
-          then add s2 v1 ~compare_elt
+          then (
+            let l2, _, r2 = split s2 v1 ~compare_elt in
+            join (union l1 l2) v1 (union r1 r2))
           else (
             let l1, _, r1 = split s1 v2 ~compare_elt in
             join (union l1 l2) v2 (union r1 r2)))
@@ -1516,9 +1520,9 @@ let to_tree = Using_comparator.to_tree
 let of_tree m t = Using_comparator.of_tree ~comparator:(to_comparator m) t
 
 module M (Elt : sig
-  type t
-  type comparator_witness
-end) =
+    type t
+    type comparator_witness
+  end) =
 struct
   type nonrec t = (Elt.t, Elt.comparator_witness) t
 end
@@ -1614,3 +1618,25 @@ module Poly = struct
   let of_tree tree = { comparator; tree }
   let to_tree t = t.tree
 end
+
+module Private = struct
+  module Tree = struct
+    type 'a t = 'a Tree0.t
+
+    let balance_invariants t = Tree0.balance_invariants t
+    let are_balanced t1 t2 = abs (Tree0.height t1 - Tree0.height t2) <= 2
+    let are_almost_balanced t1 t2 = abs (Tree0.height t1 - Tree0.height t2) <= 3
+
+    let expose t =
+      match (t : _ Tree0.t) with
+      | Empty -> None
+      | Leaf { elt } -> Some (Tree0.Empty, elt, Tree0.Empty)
+      | Node { left; elt; right; _ } -> Some (left, elt, right)
+    ;;
+
+    let empty = Tree0.Empty
+    let create_if_balanced = Tree0.create
+    let create_if_almost_balanced = Tree0.bal
+    let create_even_if_completely_unbalanced = Tree0.join
+  end
+end
diff --git a/src/set_intf.ml b/src/set_intf.ml
index 14805549..a8c18fe1 100644
--- a/src/set_intf.ml
+++ b/src/set_intf.ml
@@ -41,17 +41,11 @@ module type Accessors_generic = sig
   (** override [Container]'s [mem] *)
   val mem : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> bool) access_options
 
-  val add : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t) access_options
-  val remove : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t) access_options
-  val union : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t) access_options
-  val inter : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t) access_options
-  val diff : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t) access_options
-
   val symmetric_diff
     : ( 'a
-      , 'cmp
-      , ('a, 'cmp) t -> ('a, 'cmp) t -> ('a elt, 'a elt) Either.t Sequence.t )
-      access_options
+        , 'cmp
+        , ('a, 'cmp) t -> ('a, 'cmp) t -> ('a elt, 'a elt) Either.t Sequence.t )
+        access_options
 
   val compare_direct : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> int) access_options
   val equal : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> bool) access_options
@@ -61,15 +55,15 @@ module type Accessors_generic = sig
   module Named : sig
     val is_subset
       : ( 'a
-        , 'cmp
-        , ('a, 'cmp) t Named.t -> of_:('a, 'cmp) t Named.t -> unit Or_error.t )
-        access_options
+          , 'cmp
+          , ('a, 'cmp) t Named.t -> of_:('a, 'cmp) t Named.t -> unit Or_error.t )
+          access_options
 
     val equal
       : ( 'a
-        , 'cmp
-        , ('a, 'cmp) t Named.t -> ('a, 'cmp) t Named.t -> unit Or_error.t )
-        access_options
+          , 'cmp
+          , ('a, 'cmp) t Named.t -> ('a, 'cmp) t Named.t -> unit Or_error.t )
+          access_options
   end
 
   val fold_until
@@ -83,15 +77,13 @@ module type Accessors_generic = sig
 
   val iter2
     : ( 'a
-      , 'cmp
-      , ('a, 'cmp) t
-        -> ('a, 'cmp) t
-        -> f:([ `Left of 'a elt | `Right of 'a elt | `Both of 'a elt * 'a elt ] -> unit)
-        -> unit )
-      access_options
+        , 'cmp
+        , ('a, 'cmp) t
+          -> ('a, 'cmp) t
+          -> f:([ `Left of 'a elt | `Right of 'a elt | `Both of 'a elt * 'a elt ] -> unit)
+          -> unit )
+        access_options
 
-  val filter : ('a, 'cmp) t -> f:('a elt -> bool) -> ('a, 'cmp) t
-  val partition_tf : ('a, 'cmp) t -> f:('a elt -> bool) -> ('a, 'cmp) t * ('a, 'cmp) t
   val elements : ('a, _) t -> 'a elt list
   val min_elt : ('a, _) t -> 'a elt option
   val min_elt_exn : ('a, _) t -> 'a elt
@@ -99,64 +91,80 @@ module type Accessors_generic = sig
   val max_elt_exn : ('a, _) t -> 'a elt
   val choose : ('a, _) t -> 'a elt option
   val choose_exn : ('a, _) t -> 'a elt
-
-  val split
-    : ( 'a
-      , 'cmp
-      , ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t * 'a elt option * ('a, 'cmp) t )
-      access_options
-
-  val split_le_gt
-    : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t * ('a, 'cmp) t) access_options
-
-  val split_lt_ge
-    : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t * ('a, 'cmp) t) access_options
-
-  val group_by : ('a, 'cmp) t -> equiv:('a elt -> 'a elt -> bool) -> ('a, 'cmp) t list
   val find_exn : ('a, _) t -> f:('a elt -> bool) -> 'a elt
   val nth : ('a, _) t -> int -> 'a elt option
-  val remove_index : ('a, 'cmp, ('a, 'cmp) t -> int -> ('a, 'cmp) t) access_options
   val to_tree : ('a, 'cmp) t -> ('a, 'cmp) tree
 
   val to_sequence
     : ( 'a
-      , 'cmp
-      , ?order:[ `Increasing | `Decreasing ]
-        -> ?greater_or_equal_to:'a elt
-        -> ?less_or_equal_to:'a elt
-        -> ('a, 'cmp) t
-        -> 'a elt Sequence.t )
-      access_options
+        , 'cmp
+        , ?order:[ `Increasing | `Decreasing ]
+          -> ?greater_or_equal_to:'a elt
+          -> ?less_or_equal_to:'a elt
+          -> ('a, 'cmp) t
+          -> 'a elt Sequence.t )
+        access_options
 
   val binary_search
     : ( 'a
-      , 'cmp
-      , ('a, 'cmp) t
-        -> compare:('a elt -> 'key -> int)
-        -> Binary_searchable.Which_target_by_key.t
-        -> 'key
-        -> 'a elt option )
-      access_options
+        , 'cmp
+        , ('a, 'cmp) t
+          -> compare:('a elt -> 'key -> int)
+          -> Binary_searchable.Which_target_by_key.t
+          -> 'key
+          -> 'a elt option )
+        access_options
 
   val binary_search_segmented
     : ( 'a
-      , 'cmp
-      , ('a, 'cmp) t
-        -> segment_of:('a elt -> [ `Left | `Right ])
-        -> Binary_searchable.Which_target_by_segment.t
-        -> 'a elt option )
-      access_options
+        , 'cmp
+        , ('a, 'cmp) t
+          -> segment_of:('a elt -> [ `Left | `Right ])
+          -> Binary_searchable.Which_target_by_segment.t
+          -> 'a elt option )
+        access_options
 
   val merge_to_sequence
     : ( 'a
-      , 'cmp
-      , ?order:[ `Increasing | `Decreasing ]
-        -> ?greater_or_equal_to:'a elt
-        -> ?less_or_equal_to:'a elt
-        -> ('a, 'cmp) t
-        -> ('a, 'cmp) t
-        -> ('a elt, 'a elt) Merge_to_sequence_element.t Sequence.t )
-      access_options
+        , 'cmp
+        , ?order:[ `Increasing | `Decreasing ]
+          -> ?greater_or_equal_to:'a elt
+          -> ?less_or_equal_to:'a elt
+          -> ('a, 'cmp) t
+          -> ('a, 'cmp) t
+          -> ('a elt, 'a elt) Merge_to_sequence_element.t Sequence.t )
+        access_options
+end
+
+module type Transformers_generic = sig
+  type ('a, 'cmp) t
+  type ('a, 'cmp) tree
+  type ('a, 'cmp, 'z) access_options
+  type 'elt elt
+  type 'cmp cmp
+
+  val add : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t) access_options
+  val remove : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t) access_options
+  val union : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t) access_options
+  val inter : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t) access_options
+  val diff : ('a, 'cmp, ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t) access_options
+  val filter : ('a, 'cmp) t -> f:('a elt -> bool) -> ('a, 'cmp) t
+  val partition_tf : ('a, 'cmp) t -> f:('a elt -> bool) -> ('a, 'cmp) t * ('a, 'cmp) t
+
+  val split
+    : ( 'a
+        , 'cmp
+        , ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t * 'a elt option * ('a, 'cmp) t )
+        access_options
+
+  val split_le_gt
+    : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t * ('a, 'cmp) t) access_options
+
+  val split_lt_ge
+    : ('a, 'cmp, ('a, 'cmp) t -> 'a elt -> ('a, 'cmp) t * ('a, 'cmp) t) access_options
+
+  val group_by : ('a, 'cmp) t -> equiv:('a elt -> 'a elt -> bool) -> ('a, 'cmp) t list
+  val remove_index : ('a, 'cmp, ('a, 'cmp) t -> int -> ('a, 'cmp) t) access_options
 end
 
 module type Creators_generic = sig
@@ -180,7 +188,7 @@ module type Creators_generic = sig
     : ('a, 'cmp, len:int -> f:(int -> 'a elt) -> ('a, 'cmp) t) create_options
 
   val stable_dedup_list : ('a, _, 'a elt list -> 'a elt list) create_options
-    [@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
+  [@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
 
   (** The types of [map] and [filter_map] are subtle.  The input set, [('a, _) set],
       reflects the fact that these functions take a set of *any* type, with any
@@ -199,27 +207,37 @@ module type Creators_generic = sig
   val of_tree : ('a, 'cmp, ('a, 'cmp) tree -> ('a, 'cmp) t) create_options
 end
 
-module type Creators_and_accessors_generic = sig
+module type Creators_and_accessors_and_transformers_generic = sig
   type ('elt, 'cmp) set
   type ('elt, 'cmp) t
   type ('elt, 'cmp) tree
   type 'elt elt
   type 'cmp cmp
+  type ('elt, 'cmp, 'fn) access_options
 
   include
     Accessors_generic
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) tree
-      with type 'a elt := 'a elt
-      with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt
+    with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
+
+  include
+    Transformers_generic
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt
+    with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) access_options
 
   include
     Creators_generic
-      with type ('a, 'b) set := ('a, 'b) set
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) tree
-      with type 'a elt := 'a elt
-      with type 'cmp cmp := 'cmp cmp
+    with type ('a, 'b) set := ('a, 'b) set
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) tree
+    with type 'a elt := 'a elt
+    with type 'cmp cmp := 'cmp cmp
 end
 
 module type S_poly = sig
@@ -229,14 +247,14 @@ module type S_poly = sig
   type comparator_witness
 
   include
-    Creators_and_accessors_generic
-      with type ('elt, 'cmp) set := ('elt, 'cmp) set
-      with type ('elt, 'cmp) t := 'elt t
-      with type ('elt, 'cmp) tree := 'elt tree
-      with type 'a elt := 'a
-      with type 'c cmp := comparator_witness
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    Creators_and_accessors_and_transformers_generic
+    with type ('elt, 'cmp) set := ('elt, 'cmp) set
+    with type ('elt, 'cmp) t := 'elt t
+    with type ('elt, 'cmp) tree := 'elt tree
+    with type 'a elt := 'a
+    with type 'c cmp := comparator_witness
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
 end
 
 module type For_deriving = sig
@@ -358,7 +376,7 @@ module type Set = sig
   val inter : ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t
 
   (** [diff t1 t2] computes the set difference [t1 - t2], i.e., the set containing all
-      elements in [t1] that are not in [t2].  [O(length t1 + length t2)]. *)
+      elements in [t1] that are not in [t2].  [O(length t1 * log(length t2))]. *)
   val diff : ('a, 'cmp) t -> ('a, 'cmp) t -> ('a, 'cmp) t
 
   (** [symmetric_diff t1 t2] returns a sequence of changes between [t1] and [t2]. It is
@@ -507,7 +525,7 @@ module type Set = sig
       of polymorphic comparison by instantiating the functor at a different implementation
       of [Comparator] and using the resulting [stable_dedup_list]. *)
   val stable_dedup_list : ('a, _) Comparator.Module.t -> 'a list -> 'a list
-    [@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
+  [@@deprecated "[since 2023-04] Use [List.stable_dedup] instead."]
 
   (** [map c t ~f] returns a new set created by applying [f] to every element in
       [t].  The returned set is based on the provided [comparator].  [O(n log n)]. *)
@@ -727,9 +745,9 @@ module type Set = sig
       doesn't (because there is no such thing as, say, String.sexp_of_comparator_witness,
       instead you would want to pass the comparator directly). *)
   module M (Elt : sig
-    type t
-    type comparator_witness
-  end) : sig
+      type t
+      type comparator_witness
+    end) : sig
     type nonrec t = (Elt.t, Elt.comparator_witness) t
   end
 
@@ -776,27 +794,27 @@ module type Set = sig
         -> ('elt, 'cmp) t
 
       include
-        Creators_and_accessors_generic
-          with type ('a, 'b) set := ('a, 'b) t
-          with type ('a, 'b) t := ('a, 'b) t
-          with type ('a, 'b) tree := ('a, 'b) t
-          with type 'a elt := 'a
-          with type 'c cmp := 'c
-          with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
-          with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
+        Creators_and_accessors_and_transformers_generic
+        with type ('a, 'b) set := ('a, 'b) t
+        with type ('a, 'b) t := ('a, 'b) t
+        with type ('a, 'b) tree := ('a, 'b) t
+        with type 'a elt := 'a
+        with type 'c cmp := 'c
+        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) With_comparator.t
 
       val empty_without_value_restriction : (_, _) t
     end
 
     include
-      Creators_and_accessors_generic
-        with type ('a, 'b) t := ('a, 'b) t
-        with type ('a, 'b) tree := ('a, 'b) Tree.t
-        with type ('a, 'b) set := ('a, 'b) t
-        with type 'a elt := 'a
-        with type 'c cmp := 'c
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
+      Creators_and_accessors_and_transformers_generic
+      with type ('a, 'b) t := ('a, 'b) t
+      with type ('a, 'b) tree := ('a, 'b) Tree.t
+      with type ('a, 'b) set := ('a, 'b) t
+      with type 'a elt := 'a
+      with type 'c cmp := 'c
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_comparator.t
 
     val comparator_s : ('a, 'cmp) t -> ('a, 'cmp) Comparator.Module.t
     val comparator : ('a, 'cmp) t -> ('a, 'cmp) Comparator.t
@@ -817,11 +835,11 @@ module type Set = sig
   (** A polymorphic Set. *)
   module Poly :
     S_poly
-      with type 'elt t = ('elt, Comparator.Poly.comparator_witness) t
-      with type comparator_witness := Comparator.Poly.comparator_witness
-      with type 'elt tree :=
-        ('elt, Comparator.Poly.comparator_witness) Using_comparator.Tree.t
-      with type ('elt, 'cmp) set := ('elt, 'cmp) t
+    with type 'elt t = ('elt, Comparator.Poly.comparator_witness) t
+    with type comparator_witness := Comparator.Poly.comparator_witness
+    with type 'elt tree :=
+      ('elt, Comparator.Poly.comparator_witness) Using_comparator.Tree.t
+    with type ('elt, 'cmp) set := ('elt, 'cmp) t
 
   (** {2 Modules and module types for extending [Set]}
 
@@ -834,7 +852,31 @@ module type Set = sig
   module type For_deriving = For_deriving
   module type S_poly = S_poly
   module type Accessors_generic = Accessors_generic
+  module type Transformers_generic = Transformers_generic
   module type Creators_generic = Creators_generic
-  module type Creators_and_accessors_generic = Creators_and_accessors_generic
+
+  module type Creators_and_accessors_and_transformers_generic =
+    Creators_and_accessors_and_transformers_generic
+
   module type Elt_plain = Elt_plain
+
+  (**/**)
+
+  module Private : sig
+    module Tree : sig
+      type 'a t
+
+      val balance_invariants : 'a t -> bool
+      val are_balanced : 'a t -> 'a t -> bool
+      val are_almost_balanced : 'a t -> 'a t -> bool
+      val expose : 'a t -> ('a t * 'a * 'a t) option
+      val empty : 'a t
+      val create_if_balanced : 'a t -> 'a -> 'a t -> 'a t
+      val create_if_almost_balanced : 'a t -> 'a -> 'a t -> 'a t
+      val create_even_if_completely_unbalanced : 'a t -> 'a -> 'a t -> 'a t
+    end
+  end
+  [@@alert
+    set_private
+      "These definitions are only for testing the internal implementation of Set."]
 end
diff --git a/src/sexp.ml b/src/sexp.ml
index db8679e9..29e0354a 100644
--- a/src/sexp.ml
+++ b/src/sexp.ml
@@ -20,7 +20,7 @@ let rec compare__local =
        | _, Atom _ -> 1
        | List _a__005_, List _b__006_ ->
          compare_list__local compare__local _a__005_ _b__006_)
-    : t -> t -> int)
+   : t -> t -> int)
 ;;
 
 let compare = (fun a b -> compare__local a b : t -> t -> int)
@@ -30,7 +30,7 @@ let rec (globalize : t -> t) =
      match x__009_ with
      | Atom arg__010_ -> Atom (globalize_string arg__010_)
      | List arg__011_ -> List (globalize_list globalize arg__011_)
-    : t -> t)
+   : t -> t)
 ;;
 
 let rec (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
@@ -44,7 +44,7 @@ let rec (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash
        let hsv = Ppx_hash_lib.Std.Hash.fold_int hsv 1 in
        let hsv = hsv in
        hash_fold_list hash_fold_t hsv _a0
-    : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
+   : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
 
 and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
   let func arg =
diff --git a/src/sexp.mli b/src/sexp.mli
index c2a4cfe5..6fd2ec3a 100644
--- a/src/sexp.mli
+++ b/src/sexp.mli
@@ -21,4 +21,4 @@ val invariant : t -> unit
     so that people can find it (e.g. with merlin), and learn what we recommend.  This
     [of_string] has type [unit] because we don't want it to be accidentally used. *)
 val of_string : unit
-  [@@deprecated "[since 2018-02] Use [Parsexp.Single.parse_string_exn]"]
+[@@deprecated "[since 2018-02] Use [Parsexp.Single.parse_string_exn]"]
diff --git a/src/sexpable.ml b/src/sexpable.ml
index 0ca3433c..3bb1d733 100644
--- a/src/sexpable.ml
+++ b/src/sexpable.ml
@@ -2,12 +2,13 @@ open! Import
 include Sexplib0.Sexpable
 
 module Of_sexpable
-  (Sexpable : S) (M : sig
-    type t
+    (Sexpable : S)
+    (M : sig
+       type t
 
-    val to_sexpable : t -> Sexpable.t
-    val of_sexpable : Sexpable.t -> t
-  end) : S with type t := M.t = struct
+       val to_sexpable : t -> Sexpable.t
+       val of_sexpable : Sexpable.t -> t
+     end) : S with type t := M.t = struct
   let t_of_sexp sexp =
     let s = Sexpable.t_of_sexp sexp in
     try M.of_sexpable s with
@@ -18,12 +19,13 @@ module Of_sexpable
 end
 
 module Of_sexpable1
-  (Sexpable : S1) (M : sig
-    type 'a t
+    (Sexpable : S1)
+    (M : sig
+       type 'a t
 
-    val to_sexpable : 'a t -> 'a Sexpable.t
-    val of_sexpable : 'a Sexpable.t -> 'a t
-  end) : S1 with type 'a t := 'a M.t = struct
+       val to_sexpable : 'a t -> 'a Sexpable.t
+       val of_sexpable : 'a Sexpable.t -> 'a t
+     end) : S1 with type 'a t := 'a M.t = struct
   let t_of_sexp a_of_sexp sexp =
     let s = Sexpable.t_of_sexp a_of_sexp sexp in
     try M.of_sexpable s with
@@ -34,12 +36,13 @@ module Of_sexpable1
 end
 
 module Of_sexpable2
-  (Sexpable : S2) (M : sig
-    type ('a, 'b) t
+    (Sexpable : S2)
+    (M : sig
+       type ('a, 'b) t
 
-    val to_sexpable : ('a, 'b) t -> ('a, 'b) Sexpable.t
-    val of_sexpable : ('a, 'b) Sexpable.t -> ('a, 'b) t
-  end) : S2 with type ('a, 'b) t := ('a, 'b) M.t = struct
+       val to_sexpable : ('a, 'b) t -> ('a, 'b) Sexpable.t
+       val of_sexpable : ('a, 'b) Sexpable.t -> ('a, 'b) t
+     end) : S2 with type ('a, 'b) t := ('a, 'b) M.t = struct
   let t_of_sexp a_of_sexp b_of_sexp sexp =
     let s = Sexpable.t_of_sexp a_of_sexp b_of_sexp sexp in
     try M.of_sexpable s with
@@ -52,12 +55,13 @@ module Of_sexpable2
 end
 
 module Of_sexpable3
-  (Sexpable : S3) (M : sig
-    type ('a, 'b, 'c) t
+    (Sexpable : S3)
+    (M : sig
+       type ('a, 'b, 'c) t
 
-    val to_sexpable : ('a, 'b, 'c) t -> ('a, 'b, 'c) Sexpable.t
-    val of_sexpable : ('a, 'b, 'c) Sexpable.t -> ('a, 'b, 'c) t
-  end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t = struct
+       val to_sexpable : ('a, 'b, 'c) t -> ('a, 'b, 'c) Sexpable.t
+       val of_sexpable : ('a, 'b, 'c) Sexpable.t -> ('a, 'b, 'c) t
+     end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t = struct
   let t_of_sexp a_of_sexp b_of_sexp c_of_sexp sexp =
     let s = Sexpable.t_of_sexp a_of_sexp b_of_sexp c_of_sexp sexp in
     try M.of_sexpable s with
@@ -69,16 +73,17 @@ module Of_sexpable3
   ;;
 end
 
-module Of_stringable (M : Stringable.S) : sig
-  type t [@@deriving_inline sexp_grammar]
+module Of_stringable
+    (M : Stringable.S) : sig
+    type t [@@deriving_inline sexp_grammar]
 
-  val t_sexp_grammar : t Sexplib0.Sexp_grammar.t
+    val t_sexp_grammar : t Sexplib0.Sexp_grammar.t
 
-  [@@@end]
+    [@@@end]
 
-  include S with type t := t
-end
-with type t := M.t = struct
+    include S with type t := t
+  end
+  with type t := M.t = struct
   let t_of_sexp sexp =
     match sexp with
     | Sexp.Atom s ->
diff --git a/src/sexpable.mli b/src/sexpable.mli
index 7e73dc7d..b6afc616 100644
--- a/src/sexpable.mli
+++ b/src/sexpable.mli
@@ -5,47 +5,52 @@ open! Import
 open! Sexplib0.Sexpable
 
 module Of_sexpable
-  (Sexpable : S) (M : sig
-    type t
+    (Sexpable : S)
+    (M : sig
+       type t
 
-    val to_sexpable : t -> Sexpable.t
-    val of_sexpable : Sexpable.t -> t
-  end) : S with type t := M.t
+       val to_sexpable : t -> Sexpable.t
+       val of_sexpable : Sexpable.t -> t
+     end) : S with type t := M.t
 
 module Of_sexpable1
-  (Sexpable : S1) (M : sig
-    type 'a t
+    (Sexpable : S1)
+    (M : sig
+       type 'a t
 
-    val to_sexpable : 'a t -> 'a Sexpable.t
-    val of_sexpable : 'a Sexpable.t -> 'a t
-  end) : S1 with type 'a t := 'a M.t
+       val to_sexpable : 'a t -> 'a Sexpable.t
+       val of_sexpable : 'a Sexpable.t -> 'a t
+     end) : S1 with type 'a t := 'a M.t
 
 module Of_sexpable2
-  (Sexpable : S2) (M : sig
-    type ('a, 'b) t
+    (Sexpable : S2)
+    (M : sig
+       type ('a, 'b) t
 
-    val to_sexpable : ('a, 'b) t -> ('a, 'b) Sexpable.t
-    val of_sexpable : ('a, 'b) Sexpable.t -> ('a, 'b) t
-  end) : S2 with type ('a, 'b) t := ('a, 'b) M.t
+       val to_sexpable : ('a, 'b) t -> ('a, 'b) Sexpable.t
+       val of_sexpable : ('a, 'b) Sexpable.t -> ('a, 'b) t
+     end) : S2 with type ('a, 'b) t := ('a, 'b) M.t
 
 module Of_sexpable3
-  (Sexpable : S3) (M : sig
-    type ('a, 'b, 'c) t
+    (Sexpable : S3)
+    (M : sig
+       type ('a, 'b, 'c) t
 
-    val to_sexpable : ('a, 'b, 'c) t -> ('a, 'b, 'c) Sexpable.t
-    val of_sexpable : ('a, 'b, 'c) Sexpable.t -> ('a, 'b, 'c) t
-  end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
+       val to_sexpable : ('a, 'b, 'c) t -> ('a, 'b, 'c) Sexpable.t
+       val of_sexpable : ('a, 'b, 'c) Sexpable.t -> ('a, 'b, 'c) t
+     end) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) M.t
 
-module Of_stringable (M : Stringable.S) : sig
-  type t [@@deriving_inline sexp_grammar]
+module Of_stringable
+    (M : Stringable.S) : sig
+    type t [@@deriving_inline sexp_grammar]
 
-  val t_sexp_grammar : t Sexplib0.Sexp_grammar.t
+    val t_sexp_grammar : t Sexplib0.Sexp_grammar.t
 
-  [@@@end]
+    [@@@end]
 
-  include S with type t := t
-end
-with type t := M.t
+    include S with type t := t
+  end
+  with type t := M.t
 
 (** New code should use the [[@@deriving sexp]] syntax directly. These module types ([S],
     [S1], [S2], and [S3]) are exported for backwards compatibility only.
diff --git a/src/sign0.ml b/src/sign0.ml
index ef34da2c..5dba5f4c 100644
--- a/src/sign0.ml
+++ b/src/sign0.ml
@@ -24,8 +24,12 @@ let t_of_sexp =
      Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__003_ sexp__002_
    | Sexplib0.Sexp.List [] as sexp__002_ ->
      Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__003_ sexp__002_
-   | sexp__002_ -> Sexplib0.Sexp_conv_error.unexpected_stag error_source__003_ sexp__002_
-    : Sexplib0.Sexp.t -> t)
+   | sexp__002_ ->
+     Sexplib0.Sexp_conv_error.unexpected_stag
+       error_source__003_
+       [ "Neg"; "Zero"; "Pos" ]
+       sexp__002_
+   : Sexplib0.Sexp.t -> t)
 ;;
 
 let sexp_of_t =
@@ -33,7 +37,7 @@ let sexp_of_t =
    | Neg -> Sexplib0.Sexp.Atom "Neg"
    | Zero -> Sexplib0.Sexp.Atom "Zero"
    | Pos -> Sexplib0.Sexp.Atom "Pos"
-    : t -> Sexplib0.Sexp.t)
+   : t -> Sexplib0.Sexp.t)
 ;;
 
 let (t_sexp_grammar : t Sexplib0.Sexp_grammar.t) =
@@ -60,7 +64,7 @@ let (hash_fold_t : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.sta
         | Neg -> 0
         | Zero -> 1
         | Pos -> 2)
-    : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
+   : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
 ;;
 
 let (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
diff --git a/src/sign_or_nan.ml b/src/sign_or_nan.ml
index b2a727b5..d00aed0f 100644
--- a/src/sign_or_nan.ml
+++ b/src/sign_or_nan.ml
@@ -28,8 +28,11 @@ module T = struct
      | Sexplib0.Sexp.List [] as sexp__002_ ->
        Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__003_ sexp__002_
      | sexp__002_ ->
-       Sexplib0.Sexp_conv_error.unexpected_stag error_source__003_ sexp__002_
-      : Sexplib0.Sexp.t -> t)
+       Sexplib0.Sexp_conv_error.unexpected_stag
+         error_source__003_
+         [ "Neg"; "Zero"; "Pos"; "Nan" ]
+         sexp__002_
+     : Sexplib0.Sexp.t -> t)
   ;;
 
   let sexp_of_t =
@@ -38,7 +41,7 @@ module T = struct
      | Zero -> Sexplib0.Sexp.Atom "Zero"
      | Pos -> Sexplib0.Sexp.Atom "Pos"
      | Nan -> Sexplib0.Sexp.Atom "Nan"
-      : t -> Sexplib0.Sexp.t)
+     : t -> Sexplib0.Sexp.t)
   ;;
 
   let (t_sexp_grammar : t Sexplib0.Sexp_grammar.t) =
@@ -66,7 +69,7 @@ module T = struct
           | Zero -> 1
           | Pos -> 2
           | Nan -> 3)
-      : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
+     : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
   ;;
 
   let (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
diff --git a/src/source_code_position.ml b/src/source_code_position.ml
index f23ecc50..bd2e7d28 100644
--- a/src/source_code_position.ml
+++ b/src/source_code_position.ml
@@ -1,20 +1,5 @@
 open! Import
-
-(* This is lifted out of [M] because [Source_code_position0] exports [String0]
-   as [String], which does not export a hash function. *)
-let hash_override { Stdlib.Lexing.pos_fname; pos_lnum; pos_bol; pos_cnum } =
-  String.hash pos_fname
-  lxor Int.hash pos_lnum
-  lxor Int.hash pos_bol
-  lxor Int.hash pos_cnum
-;;
-
-module M = struct
-  include Source_code_position0
-
-  let hash = hash_override
-end
-
+module M = Source_code_position0
 include M
 include Comparable.Make_using_comparator (M)
 
@@ -23,3 +8,11 @@ let equal__local a b = equal_int (compare__local a b) 0
 let of_pos (pos_fname, pos_lnum, pos_cnum, _) =
   { pos_fname; pos_lnum; pos_cnum; pos_bol = 0 }
 ;;
+
+let here_or_there ?(here = Stdlib.Lexing.dummy_pos) there =
+  match there with
+  | None -> here
+  | Some there -> there
+;;
+
+let is_dummy t = equal__local Stdlib.Lexing.dummy_pos t
diff --git a/src/source_code_position.mli b/src/source_code_position.mli
index 63728592..7925ce3b 100644
--- a/src/source_code_position.mli
+++ b/src/source_code_position.mli
@@ -30,3 +30,13 @@ val to_string : t -> string
 
 (** [of_pos Stdlib.__POS__] is like [[%here]] but without using ppx. *)
 val of_pos : string * int * int * int -> t
+
+(** [here_or_there (Some there)] returns [there]. [here_or_there None] returns [~here],
+    which may be defined implicitly on compilers supporting [[%call_pos]]. *)
+val here_or_there : ?here:Stdlib.Lexing.position -> t option -> t
+
+(** [is_dummy pos] returns true if [pos] is equal to [Stdlib.Lexing.dummy_pos]. 
+
+    [Stdlib.Lexing.dummy_pos] is a position guaranteed to be different from any valid
+    position. *)
+val is_dummy : t -> bool
diff --git a/src/source_code_position0.ml b/src/source_code_position0.ml
index d01a43b9..5f3465fa 100644
--- a/src/source_code_position0.ml
+++ b/src/source_code_position0.ml
@@ -25,7 +25,7 @@ module T = struct
                | n -> n)
             | n -> n)
          | n -> n)
-      : t -> t -> int)
+     : t -> t -> int)
   ;;
 
   let compare = (fun a b -> compare__local a b : t -> t -> int)
@@ -64,25 +64,25 @@ module T = struct
        let bnds__003_ =
          let arg__011_ = sexp_of_int pos_cnum__010_ in
          (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "pos_cnum"; arg__011_ ] :: bnds__003_
-           : _ Stdlib.List.t)
+          : _ Stdlib.List.t)
        in
        let bnds__003_ =
          let arg__009_ = sexp_of_int pos_bol__008_ in
          (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "pos_bol"; arg__009_ ] :: bnds__003_
-           : _ Stdlib.List.t)
+          : _ Stdlib.List.t)
        in
        let bnds__003_ =
          let arg__007_ = sexp_of_int pos_lnum__006_ in
          (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "pos_lnum"; arg__007_ ] :: bnds__003_
-           : _ Stdlib.List.t)
+          : _ Stdlib.List.t)
        in
        let bnds__003_ =
          let arg__005_ = sexp_of_string pos_fname__004_ in
          (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "pos_fname"; arg__005_ ] :: bnds__003_
-           : _ Stdlib.List.t)
+          : _ Stdlib.List.t)
        in
        Sexplib0.Sexp.List bnds__003_
-      : t -> Sexplib0.Sexp.t)
+     : t -> Sexplib0.Sexp.t)
   ;;
 
   [@@@end]
diff --git a/src/stack.ml b/src/stack.ml
index d27a24c2..d71f3c12 100644
--- a/src/stack.ml
+++ b/src/stack.ml
@@ -19,12 +19,12 @@ let sexp_of_t : 'a. ('a -> Sexplib0.Sexp.t) -> 'a t -> Sexplib0.Sexp.t =
   let bnds__002_ =
     let arg__006_ = Option_array.sexp_of_t _of_a__001_ elts__005_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "elts"; arg__006_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   let bnds__002_ =
     let arg__004_ = sexp_of_int length__003_ in
     (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "length"; arg__004_ ] :: bnds__002_
-      : _ Stdlib.List.t)
+     : _ Stdlib.List.t)
   in
   Sexplib0.Sexp.List bnds__002_
 ;;
@@ -76,12 +76,12 @@ let iter t ~f =
 ;;
 
 module C = Container.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let fold = fold
-  let iter = `Custom iter
-  let length = `Custom length
-end)
+    let fold = fold
+    let iter = `Custom iter
+    let length = `Custom length
+  end)
 
 let mem = C.mem
 let exists = C.exists
diff --git a/src/staged.ml b/src/staged.ml
index d4701652..12b99bcd 100644
--- a/src/staged.ml
+++ b/src/staged.ml
@@ -2,5 +2,7 @@ open! Import
 
 type 'a t = 'a
 
-let stage = Fn.id
-let unstage = Fn.id
+(* We define these primitives using ['a] instead of ['a t] as proof to ourselves that this
+   is a safe use of [%identity], since [external] provides no typechecking. *)
+external stage : ('a[@local_opt]) -> ('a[@local_opt]) = "%identity"
+external unstage : ('a[@local_opt]) -> ('a[@local_opt]) = "%identity"
diff --git a/src/staged.mli b/src/staged.mli
index a0b9f9c8..221e1e6b 100644
--- a/src/staged.mli
+++ b/src/staged.mli
@@ -38,5 +38,5 @@ open! Import
 
 type +'a t
 
-val stage : 'a -> 'a t
-val unstage : 'a t -> 'a
+external stage : ('a[@local_opt]) -> ('a t[@local_opt]) = "%identity"
+external unstage : ('a t[@local_opt]) -> ('a[@local_opt]) = "%identity"
diff --git a/src/string.ml b/src/string.ml
index 992eb749..72bb3c26 100644
--- a/src/string.ml
+++ b/src/string.ml
@@ -231,12 +231,12 @@ module Search_pattern0 = struct
       let matched_chars = ref 0 in
       for i = 1 to n - 1 do
         matched_chars
-          := kmp_internal_loop
-               ~matched_chars:!matched_chars
-               ~next_text_char:(unsafe_get pattern i)
-               ~pattern
-               ~kmp_array
-               ~char_equal;
+        := kmp_internal_loop
+             ~matched_chars:!matched_chars
+             ~next_text_char:(unsafe_get pattern i)
+             ~pattern
+             ~kmp_array
+             ~char_equal;
         Array.unsafe_set kmp_array i !matched_chars
       done);
     { pattern; case_sensitive; kmp_array }
@@ -256,12 +256,12 @@ module Search_pattern0 = struct
       while !j < n && !matched_chars < k do
         let next_text_char = unsafe_get text !j in
         matched_chars
-          := kmp_internal_loop
-               ~matched_chars:!matched_chars
-               ~next_text_char
-               ~pattern
-               ~kmp_array
-               ~char_equal;
+        := kmp_internal_loop
+             ~matched_chars:!matched_chars
+             ~next_text_char
+             ~pattern
+             ~kmp_array
+             ~char_equal;
         j := !j + 1
       done;
       if !matched_chars = k then !j - k else -1)
@@ -304,12 +304,12 @@ module Search_pattern0 = struct
         then (
           let next_text_char = unsafe_get text j in
           matched_chars
-            := kmp_internal_loop
-                 ~matched_chars:!matched_chars
-                 ~next_text_char
-                 ~pattern
-                 ~kmp_array
-                 ~char_equal)
+          := kmp_internal_loop
+               ~matched_chars:!matched_chars
+               ~next_text_char
+               ~pattern
+               ~kmp_array
+               ~char_equal)
       done;
       List.rev !found)
   ;;
@@ -394,7 +394,7 @@ module Search_pattern0 = struct
              (Stdlib.( && )
                 (equal_bool__local a__003_.case_sensitive b__004_.case_sensitive)
                 (equal_array__local equal_int__local a__003_.kmp_array b__004_.kmp_array))
-        : t -> t -> bool)
+       : t -> t -> bool)
     ;;
 
     let equal = (fun a b -> equal__local a b : t -> t -> bool)
@@ -408,21 +408,21 @@ module Search_pattern0 = struct
          let bnds__007_ =
            let arg__013_ = sexp_of_array sexp_of_int kmp_array__012_ in
            (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "kmp_array"; arg__013_ ] :: bnds__007_
-             : _ Stdlib.List.t)
+            : _ Stdlib.List.t)
          in
          let bnds__007_ =
            let arg__011_ = sexp_of_bool case_sensitive__010_ in
            (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "case_sensitive"; arg__011_ ]
             :: bnds__007_
-             : _ Stdlib.List.t)
+            : _ Stdlib.List.t)
          in
          let bnds__007_ =
            let arg__009_ = sexp_of_string pattern__008_ in
            (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "pattern"; arg__009_ ] :: bnds__007_
-             : _ Stdlib.List.t)
+            : _ Stdlib.List.t)
          in
          Sexplib0.Sexp.List bnds__007_
-        : t -> Sexplib0.Sexp.t)
+       : t -> Sexplib0.Sexp.t)
     ;;
 
     [@@@end]
@@ -675,24 +675,32 @@ let is_substring_at s ~pos ~substring =
   is_substring_at_gen s ~pos ~substring ~char_equal:Char.equal
 ;;
 
-let wrap_sub_n t n ~name ~pos ~len ~on_error =
-  if n < 0
+(** precondition: when [0 <= n <= length t], [~pos] and [~len] are both in-bounds *)
+let wrap_sub_n t n ~name ~pos ~len ~when_n_exceeds_length =
+  if n > length t
+  then when_n_exceeds_length
+  else if n < 0
   then invalid_arg (name ^ " expecting nonnegative argument")
-  else (
-    try sub t ~pos ~len with
-    | _ -> on_error)
+  else
+    (* The way arguments to this function are constructed (see usages below), the check
+       that [0 <= n <= length t] is sufficient to know that [pos] and [len] are
+       valid. Thus [sub] should not raise. *)
+    sub t ~pos ~len
 ;;
 
 let drop_prefix t n =
-  wrap_sub_n ~name:"drop_prefix" t n ~pos:n ~len:(length t - n) ~on_error:""
+  wrap_sub_n ~name:"drop_prefix" t n ~pos:n ~len:(length t - n) ~when_n_exceeds_length:""
 ;;
 
 let drop_suffix t n =
-  wrap_sub_n ~name:"drop_suffix" t n ~pos:0 ~len:(length t - n) ~on_error:""
+  wrap_sub_n ~name:"drop_suffix" t n ~pos:0 ~len:(length t - n) ~when_n_exceeds_length:""
 ;;
 
-let prefix t n = wrap_sub_n ~name:"prefix" t n ~pos:0 ~len:n ~on_error:t
-let suffix t n = wrap_sub_n ~name:"suffix" t n ~pos:(length t - n) ~len:n ~on_error:t
+let prefix t n = wrap_sub_n ~name:"prefix" t n ~pos:0 ~len:n ~when_n_exceeds_length:t
+
+let suffix t n =
+  wrap_sub_n ~name:"suffix" t n ~pos:(length t - n) ~len:n ~when_n_exceeds_length:t
+;;
 
 let lfindi ?(pos = 0) t ~f =
   let n = length t in
@@ -1892,13 +1900,13 @@ module Search_pattern = struct
 end
 
 module Make_utf (Format : sig
-  val codec_name : string
-  val module_name : string
-  val is_valid : t -> bool
-  val byte_length : Uchar.t -> int
-  val get_decode_result : t -> byte_pos:int -> Uchar.utf_decode
-  val set : bytes -> int -> Uchar.t -> int
-end) =
+    val codec_name : string
+    val module_name : string
+    val is_valid : t -> bool
+    val byte_length : Uchar.t -> int
+    val get_decode_result : t -> byte_pos:int -> Uchar.utf_decode
+    val set : bytes -> int -> Uchar.t -> int
+  end) =
 struct
   type elt = Uchar.t
   type t = string
@@ -1914,7 +1922,7 @@ struct
          Format.codec_name)
   ;;
 
-  let[@cold] raise_get t pos =
+  let[@cold] [@inline never] [@local never] [@specialise never] raise_get t pos =
     raise_s
       (Sexp.message (Lazy.force raise_get_message) [ "", Atom t; "pos", sexp_of_int pos ])
   ;;
@@ -1934,7 +1942,7 @@ struct
     concat [ Format.module_name; ".of_string: invalid "; codec_name ]
   ;;
 
-  let[@cold] raise_of_string string =
+  let[@cold] [@inline never] [@local never] [@specialise never] raise_of_string string =
     raise_s (Sexp.message raise_of_string_message [ "", Atom string ])
   ;;
 
@@ -1945,24 +1953,24 @@ struct
   ;;
 
   include Sexpable.Of_stringable (struct
-    type nonrec t = t
+      type nonrec t = t
 
-    let of_string = of_string
-    let to_string = to_string
-  end)
+      let of_string = of_string
+      let to_string = to_string
+    end)
 
   include Identifiable.Make (struct
-    type nonrec t = t
-
-    let compare = compare
-    let hash = hash
-    let hash_fold_t = hash_fold_t
-    let of_string = of_string
-    let to_string = to_string
-    let sexp_of_t = sexp_of_t
-    let t_of_sexp = t_of_sexp
-    let module_name = Format.module_name
-  end)
+      type nonrec t = t
+
+      let compare = compare
+      let hash = hash
+      let hash_fold_t = hash_fold_t
+      let of_string = of_string
+      let to_string = to_string
+      let sexp_of_t = sexp_of_t
+      let t_of_sexp = t_of_sexp
+      let module_name = Format.module_name
+    end)
 
   let to_sequence t =
     let open Int_replace_polymorphic_compare in
@@ -2039,21 +2047,21 @@ struct
   ;;
 
   module C = Indexed_container.Make0_with_creators (struct
-    module Elt = Uchar
-
-    type nonrec t = t
-
-    let fold = fold
-    let concat = concat
-    let of_list = of_list
-    let of_array = of_array
-    let init = `Define_using_of_array
-    let length = `Define_using_fold
-    let foldi = `Define_using_fold
-    let iter = `Define_using_fold
-    let iteri = `Define_using_fold
-    let concat_mapi = `Define_using_concat
-  end)
+      module Elt = Uchar
+
+      type nonrec t = t
+
+      let fold = fold
+      let concat = concat
+      let of_list = of_list
+      let of_array = of_array
+      let init = `Define_using_of_array
+      let length = `Define_using_fold
+      let foldi = `Define_using_fold
+      let iter = `Define_using_fold
+      let iteri = `Define_using_fold
+      let concat_mapi = `Define_using_concat
+    end)
 
   let append = C.append
   let concat_map = C.concat_map
@@ -2094,76 +2102,76 @@ struct
 end
 
 module Utf8 = Make_utf (struct
-  let codec_name = "UTF-8"
-  let module_name = "Base.String.Utf8"
-  let is_valid = is_valid_utf_8
-  let byte_length = Uchar.utf_8_byte_length
-  let get_decode_result = get_utf_8_uchar
-  let set = Bytes.set_uchar_utf_8
-end)
+    let codec_name = "UTF-8"
+    let module_name = "Base.String.Utf8"
+    let is_valid = is_valid_utf_8
+    let byte_length = Uchar.utf_8_byte_length
+    let get_decode_result = get_utf_8_uchar
+    let set = Bytes.set_uchar_utf_8
+  end)
 
 module Utf16le = Make_utf (struct
-  let codec_name = "UTF-16LE"
-  let module_name = "Base.String.Utf16le"
-  let is_valid = is_valid_utf_16le
-  let byte_length = Uchar.utf_16_byte_length
-  let get_decode_result = get_utf_16le_uchar
-  let set = Bytes.set_uchar_utf_16le
-end)
+    let codec_name = "UTF-16LE"
+    let module_name = "Base.String.Utf16le"
+    let is_valid = is_valid_utf_16le
+    let byte_length = Uchar.utf_16_byte_length
+    let get_decode_result = get_utf_16le_uchar
+    let set = Bytes.set_uchar_utf_16le
+  end)
 
 module Utf16be = Make_utf (struct
-  let codec_name = "UTF-16BE"
-  let module_name = "Base.String.Utf16be"
-  let is_valid = is_valid_utf_16be
-  let byte_length = Uchar.utf_16_byte_length
-  let get_decode_result = get_utf_16be_uchar
-  let set = Bytes.set_uchar_utf_16be
-end)
+    let codec_name = "UTF-16BE"
+    let module_name = "Base.String.Utf16be"
+    let is_valid = is_valid_utf_16be
+    let byte_length = Uchar.utf_16_byte_length
+    let get_decode_result = get_utf_16be_uchar
+    let set = Bytes.set_uchar_utf_16be
+  end)
 
 module Make_utf32 (Format : sig
-  val codec_name : string
-  val module_name : string
-  val get_decode_result : t -> byte_pos:int -> Uchar.utf_decode
-  val set : bytes -> int -> Uchar.t -> int
-end) =
+    val codec_name : string
+    val module_name : string
+    val get_decode_result : t -> byte_pos:int -> Uchar.utf_decode
+    val set : bytes -> int -> Uchar.t -> int
+  end) =
 Make_utf (struct
-  open Int_replace_polymorphic_compare
+    open Int_replace_polymorphic_compare
 
-  let byte_length _ = 4
-  let codec_name = Format.codec_name
-  let module_name = Format.module_name
-  let set = Format.set
-  let get_decode_result = Format.get_decode_result
-
-  let is_valid t =
-    let len = String.length t in
-    match len mod 4 with
-    | 0 ->
-      let rec loop byte_pos =
-        match byte_pos < len with
-        | false -> true
-        | true ->
-          let result = Format.get_decode_result t ~byte_pos in
-          Uchar.utf_decode_is_valid result && loop (byte_pos + 4)
-      in
-      loop 0 [@nontail]
-    | _ -> false
-  ;;
-end)
+    let byte_length _ = 4
+    let codec_name = Format.codec_name
+    let module_name = Format.module_name
+    let set = Format.set
+    let get_decode_result = Format.get_decode_result
+
+    let is_valid t =
+      let len = String.length t in
+      match len mod 4 with
+      | 0 ->
+        let rec loop byte_pos =
+          match byte_pos < len with
+          | false -> true
+          | true ->
+            let result = Format.get_decode_result t ~byte_pos in
+            Uchar.utf_decode_is_valid result && loop (byte_pos + 4)
+        in
+        loop 0 [@nontail]
+      | _ -> false
+    ;;
+  end)
 
 module Utf32le = Make_utf32 (struct
-  let codec_name = "UTF-32LE"
-  let module_name = "Base.String.Utf32le"
-  let get_decode_result = get_utf_32le_uchar
-  let set = Bytes.set_uchar_utf_32le
-end)
+    let codec_name = "UTF-32LE"
+    let module_name = "Base.String.Utf32le"
+    let get_decode_result = get_utf_32le_uchar
+    let set = Bytes.set_uchar_utf_32le
+  end)
 
 module Utf32be = Make_utf32 (struct
-  let codec_name = "UTF-32BE"
-  let module_name = "Base.String.Utf32be"
-  let get_decode_result = get_utf_32be_uchar
-  let set = Bytes.set_uchar_utf_32be
-end)
+    let codec_name = "UTF-32BE"
+    let module_name = "Base.String.Utf32be"
+    let get_decode_result = get_utf_32be_uchar
+    let set = Bytes.set_uchar_utf_32be
+  end)
 
 (* Include type-specific [Replace_polymorphic_compare] at the end, after
    including functor application that could shadow its definitions. This is
diff --git a/src/string_intf.ml b/src/string_intf.ml
index 155743ab..e570079d 100644
--- a/src/string_intf.ml
+++ b/src/string_intf.ml
@@ -69,10 +69,10 @@ module type Utf = sig
   (** [length] could be misinterpreted as counting bytes. We direct users to other,
       clearer options. *)
   val length : t -> int
-    [@@alert
-      length_in_uchars
-        "Use [length_in_uchars] to count unicode scalar values or [String.length] to \
-         count bytes"]
+  [@@alert
+    length_in_uchars
+      "Use [length_in_uchars] to count unicode scalar values or [String.length] to count \
+       bytes"]
 end
 
 (** Iterface for Unicode encodings, specialized for string representation. *)
@@ -94,12 +94,12 @@ module type String = sig
 
   [@@@end]
 
-  val sub : (t, t) Blit.sub
+  val sub : (t, t) Blit.sub_global
 
   (** [sub] with no bounds checking, and always returns a new copy *)
   val unsafe_sub : t -> pos:int -> len:int -> t
 
-  val subo : (t, t) Blit.subo
+  val subo : (t, t) Blit.subo_global
 
   include Indexed_container.S0_with_creators with type t := t with type elt = char
   include Identifiable.S with type t := t
@@ -251,14 +251,20 @@ module type String = sig
         E.g., [replace_all] internally calls [index_all ~may_overlap:false]. *)
     val index_all : t -> may_overlap:bool -> in_:string -> int list
 
-    (** Note that the result of [replace_all pattern ~in_:text ~with_:r] may still
-        contain [pattern], e.g.,
+    val replace_first : ?pos:int -> t -> in_:string -> with_:string -> string
+
+    (** [replace_all pattern ~in_:text ~with_:r] replaces every appearance of a [pattern]
+        in [text]. Surprisingly, the result can still contain [pattern] at the end, as
+        shown in the following example.
 
         {[
-          replace_all (create "bc") ~in_:"aabbcc" ~with_:"cb" = "aabcbc"
-        ]} *)
-    val replace_first : ?pos:int -> t -> in_:string -> with_:string -> string
+          # let pattern = String.Search_pattern.create "bc"
+          val pattern : String.Search_pattern.t = <abstr>
+          # String.Search_pattern.replace_all pattern ~in_:"aabbcc" ~with_:"cb"
+          - : string = "aabcbc"
+        ]}
 
+        which ends with ["bc"]!  *)
     val replace_all : t -> in_:string -> with_:string -> string
 
     (** Similar to [String.split] or [String.split_on_chars], but instead uses a given
@@ -318,7 +324,6 @@ module type String = sig
   val rev : t -> t
 
   (** [is_suffix s ~suffix] returns [true] if [s] ends with [suffix]. *)
-
   val is_suffix : t -> suffix:t -> bool
 
   (** [is_prefix s ~prefix] returns [true] if [s] starts with [prefix]. *)
@@ -469,18 +474,20 @@ module type String = sig
   val concat_array : ?sep:t -> t array -> t
 
   (** Builds a multiline text from a list of lines. Each line is terminated and then
-      concatenated. Equivalent to:
+      concatenated.
 
       {[
-        String.concat (List.map lines ~f:(fun line ->
-          line ^ if crlf then "\r\n" else "\n"))
+        # String.concat_lines ["one two"; "three four"; "five"]
+        - : string = "one two\nthree four\nfive\n"
+        # String.concat_lines ~crlf:true ["one two"; "three four"; "five"]
+        - : string = "one two\r\nthree four\r\nfive\r\n"
       ]}
   *)
   val concat_lines : ?crlf:bool (** default [false] *) -> string list -> string
 
   (** Slightly faster hash function on strings. *)
   external hash : t -> int = "Base_hash_string"
-    [@@noalloc]
+  [@@noalloc]
 
   (** Fast equality function on strings, doesn't use [compare_val]. *)
   val equal : t -> t -> bool
@@ -511,38 +518,84 @@ module type String = sig
       escapeworthy characters.  Escaping/unescaping using this module is more efficient than
       using Pcre. Benchmark code can be found in core/benchmarks/string_escaping.ml. *)
   module Escaping : sig
-    (** [escape_gen_exn escapeworthy_map escape_char] returns a function that will escape a
+    (** [escape_gen_exn escapeworthy_map escape_char] returns a (staged) function that will escape a
         string [s] as follows: if [(c1,c2)] is in [escapeworthy_map], then all occurrences
         of [c1] are replaced by [escape_char] concatenated to [c2].
 
         Raises an exception if [escapeworthy_map] is not one-to-one.  If [escape_char] is
-        not in [escapeworthy_map], then it will be escaped to itself.*)
+        not in [escapeworthy_map], then it will be escaped to itself.
+
+        Examples:
+
+        {[
+          # let escape = Staged.unstage (String.Escaping.escape_gen_exn ~escapeworthy_map:['a','b'; 'b','c'] ~escape_char:'!')
+          val escape : string -> string = <fun>
+          # escape "a!bcd";
+          - : string = "!b!!!ccd"
+          # escape "efgh";
+          - : string = "efgh"
+          # let escape = Staged.unstage (String.Escaping.escape_gen_exn ~escapeworthy_map:['a','b'; 'c','b'] ~escape_char:'!')
+          Exception:
+          ("escapeworthy_map not one-to-one" (c_from c) (c_to b)
+            (escapeworthy_map ((! !) (a b) (c b))))
+        ]}
+    *)
     val escape_gen_exn
       :  escapeworthy_map:(char * char) list
       -> escape_char:char
       -> (string -> string) Staged.t
 
+    (** Like {!escape_gen_exn}, but returns an [Or_error.t] when constructing the escaping
+        function, rather than raising. *)
     val escape_gen
       :  escapeworthy_map:(char * char) list
       -> escape_char:char
       -> (string -> string) Or_error.t
 
-    (** [escape ~escapeworthy ~escape_char s] is
+    (** A simpler version of {!escape_gen}.  In this function, any escaped character is
+        escaped to itself. I.e., if the escape character is ['!'] then escaping the
+        character ['a'] will generate ["!a"].
+
+        Duplicates will be removed from [escapeworthy], and the escape character is
+        implicitly considered escapeworthy, whether or not its on the list explicitly.
+
+        An example where we include the escape character explicitly as escapeworthy:
+
         {[
-          escape_gen_exn ~escapeworthy_map:(List.zip_exn escapeworthy escapeworthy)
-            ~escape_char
+          # let escape = Staged.unstage (String.Escaping.escape ~escapeworthy:['a';'b';'c';'!'] ~escape_char:'!')
+          val escape : string -> string = <fun>
+          # escape "abcd!ef"
+          - : string = "!a!b!cd!!ef"
         ]}
-        Duplicates and [escape_char] will be removed from [escapeworthy].  So, no
-        exception will be raised *)
+
+        And where we don't.
+
+        {[
+          # let escape = Staged.unstage (String.Escaping.escape ~escapeworthy:['a';'b';'c'] ~escape_char:'!')
+          val escape : string -> string = <fun>
+          # escape "abcd!ef"
+          - : string = "!a!b!cd!!ef"
+        ]}
+
+    *)
     val escape : escapeworthy:char list -> escape_char:char -> (string -> string) Staged.t
 
-    (** [unescape_gen_exn] is the inverse operation of [escape_gen_exn]. That is,
+    (** [unescape_gen_exn] is the inverse operation of [escape_gen_exn].
+
+        Example:
+
         {[
-          let escape = Staged.unstage (escape_gen_exn ~escapeworthy_map ~escape_char) in
-          let unescape = Staged.unstage (unescape_gen_exn ~escapeworthy_map ~escape_char) in
-          assert (s = unescape (escape s))
+          # let escapeworthy_map = ['a','b'; 'b','c'] and escape_char = '!'
+          val escapeworthy_map : (char * char) list = [('a', 'b'); ('b', 'c')]
+          val escape_char : char = '!'
+          # let escape = Staged.unstage (String.Escaping.escape_gen_exn ~escapeworthy_map ~escape_char)
+          val escape : string -> string = <fun>
+          # let unescape = Staged.unstage (String.Escaping.unescape_gen_exn ~escapeworthy_map ~escape_char)
+          val unescape : string -> string = <fun>
+          # unescape (escape "abc!de")
+          - : string = "abc!de"
         ]}
-        always succeed when ~escapeworthy_map is not causing exceptions. *)
+        *)
     val unescape_gen_exn
       :  escapeworthy_map:(char * char) list
       -> escape_char:char
diff --git a/src/stringable.ml b/src/stringable.ml
index f5efcd0c..1f87b7dd 100644
--- a/src/stringable.ml
+++ b/src/stringable.ml
@@ -8,3 +8,10 @@ module type S = sig
   val of_string : string -> t
   val to_string : t -> string
 end
+
+module type S_local_input = sig
+  type t
+
+  val of_string : string -> t
+  val to_string : t -> string
+end
diff --git a/src/sys.mli b/src/sys.mli
index d2fc75ce..949df619 100644
--- a/src/sys.mli
+++ b/src/sys.mli
@@ -13,9 +13,9 @@ val get_argv : unit -> string array
 (** A single result from [get_argv ()]. This value is indefinitely deprecated. It is kept
     for compatibility with {!Stdlib.Sys}. *)
 val argv : string array
-  [@@deprecated
-    "[since 2019-08] Use [Sys.get_argv] instead, which has the correct behavior when \
-     [caml_sys_modify_argv] is called."]
+[@@deprecated
+  "[since 2019-08] Use [Sys.get_argv] instead, which has the correct behavior when \
+   [caml_sys_modify_argv] is called."]
 
 (** [interactive] is set to [true] when being executed in the [ocaml] REPL, and [false]
     otherwise. *)
diff --git a/src/sys0.ml b/src/sys0.ml
index 7d4b5d51..2857f80c 100644
--- a/src/sys0.ml
+++ b/src/sys0.ml
@@ -34,8 +34,8 @@ let enable_runtime_warnings = Stdlib.Sys.enable_runtime_warnings
 let runtime_warnings_enabled = Stdlib.Sys.runtime_warnings_enabled
 
 module Make_immediate64
-  (Imm : Stdlib.Sys.Immediate64.Immediate)
-  (Non_imm : Stdlib.Sys.Immediate64.Non_immediate) =
+    (Imm : Stdlib.Sys.Immediate64.Immediate)
+    (Non_imm : Stdlib.Sys.Immediate64.Non_immediate) =
   Stdlib.Sys.Immediate64.Make (Imm) (Non_imm)
 
 let getenv_exn var =
diff --git a/src/t.ml b/src/t.ml
index 8a3eb380..17103efc 100644
--- a/src/t.ml
+++ b/src/t.ml
@@ -2,8 +2,6 @@
     module that matches a bare signature with just a type. This sometimes occurs in
     functor arguments and in interfaces. *)
 
-open! Import
-
 module type T = sig
   type t
 end
@@ -19,3 +17,7 @@ end
 module type T3 = sig
   type ('a, 'b, 'c) t
 end
+
+module type T4 = sig
+  type ('a, 'b, 'c, 'd) t
+end
diff --git a/src/type_equal.ml b/src/type_equal.ml
index d795ab0e..23d1c39e 100644
--- a/src/type_equal.ml
+++ b/src/type_equal.ml
@@ -2,9 +2,9 @@ open! Import
 
 type ('a, 'b) t = T : ('a, 'a) t [@@deriving_inline sexp_of]
 
-let sexp_of_t :
-      'a 'b.
-      ('a -> Sexplib0.Sexp.t) -> ('b -> Sexplib0.Sexp.t) -> ('a, 'b) t -> Sexplib0.Sexp.t
+let sexp_of_t
+  : 'a 'b.
+  ('a -> Sexplib0.Sexp.t) -> ('b -> Sexplib0.Sexp.t) -> ('a, 'b) t -> Sexplib0.Sexp.t
   =
   fun (type a__003_ b__004_)
     :  ((a__003_ -> Sexplib0.Sexp.t) -> (b__004_ -> Sexplib0.Sexp.t)
@@ -17,8 +17,8 @@ let sexp_of_t :
 type ('a, 'b) equal = ('a, 'b) t
 
 include Type_equal_intf.Type_equal_defns (struct
-  type ('a, 'b) t = ('a, 'b) equal
-end)
+    type ('a, 'b) t = ('a, 'b) equal
+  end)
 
 let refl = T
 let sym (type a b) (T : (a, b) t) : (b, a) t = T
@@ -26,15 +26,15 @@ let trans (type a b c) (T : (a, b) t) (T : (b, c) t) : (a, c) t = T
 let conv (type a b) (T : (a, b) t) (a : a) : b = a
 
 module Lift (X : sig
-  type 'a t
-end) =
+    type 'a t
+  end) =
 struct
   let lift (type a b) (T : (a, b) t) : (a X.t, b X.t) t = T
 end
 
 module Lift2 (X : sig
-  type ('a1, 'a2) t
-end) =
+    type ('a1, 'a2) t
+  end) =
 struct
   let lift (type a1 b1 a2 b2) (T : (a1, b1) t) (T : (a2, b2) t)
     : ((a1, a2) X.t, (b1, b2) X.t) t
@@ -44,8 +44,8 @@ struct
 end
 
 module Lift3 (X : sig
-  type ('a1, 'a2, 'a3) t
-end) =
+    type ('a1, 'a2, 'a3) t
+  end) =
 struct
   let lift (type a1 b1 a2 b2 a3 b3) (T : (a1, b1) t) (T : (a2, b2) t) (T : (a3, b3) t)
     : ((a1, a2, a3) X.t, (b1, b2, b3) X.t) t
@@ -54,6 +54,22 @@ struct
   ;;
 end
 
+module Lift4 (X : sig
+    type ('a1, 'a2, 'a3, 'a4) t
+  end) =
+struct
+  let lift
+    (type a1 b1 a2 b2 a3 b3 a4 b4)
+    (T : (a1, b1) t)
+    (T : (a2, b2) t)
+    (T : (a3, b3) t)
+    (T : (a4, b4) t)
+    : ((a1, a2, a3, a4) X.t, (b1, b2, b3, b4) X.t) t
+    =
+    T
+  ;;
+end
+
 let detuple2 (type a1 a2 b1 b2) (T : (a1 * a2, b1 * b2) t) : (a1, b1) t * (a2, b2) t =
   T, T
 ;;
@@ -79,7 +95,7 @@ module Id = struct
              (match compare_int _a__007_ _b__008_ with
               | 0 -> compare_list compare _a__009_ _b__010_
               | n -> n))
-        : t -> t -> int)
+       : t -> t -> int)
     ;;
 
     let rec (hash_fold_t :
@@ -94,7 +110,7 @@ module Id = struct
              hash_fold_int hsv _a0
            in
            hash_fold_list hash_fold_t hsv _a1
-        : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
+       : Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state)
 
     and (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
       let func arg =
@@ -110,17 +126,17 @@ module Id = struct
          let res0__015_ = sexp_of_int arg0__013_
          and res1__016_ = sexp_of_list sexp_of_t arg1__014_ in
          Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "T"; res0__015_; res1__016_ ]
-        : t -> Sexplib0.Sexp.t)
+       : t -> Sexplib0.Sexp.t)
     ;;
 
     [@@@end]
 
     include Comparable.Make (struct
-      type nonrec t = t
+        type nonrec t = t
 
-      let compare = compare
-      let sexp_of_t = sexp_of_t
-    end)
+        let compare = compare
+        let sexp_of_t = sexp_of_t
+      end)
 
     (* We use the extension constructor id for a [key] as the unique id for its type. *)
     let create (key : _ key) args =
@@ -189,8 +205,8 @@ module Id = struct
   ;;
 
   include Type_equal_intf.Type_equal_id_defns (struct
-    type nonrec 'a t = 'a t
-  end)
+      type nonrec 'a t = 'a t
+    end)
 
   module Create0 (T : Arg0) = struct
     type _ key += T0 : T.t key
@@ -295,6 +311,44 @@ module Id = struct
     ;;
   end
 
+  module Create4 (T : Arg4) = struct
+    type _ key += T4 : 'a key * 'b key * 'c key * 'd key -> ('a, 'b, 'c, 'd) T.t key
+
+    let type_equal_id
+      (type a b c d)
+      ((module A) : a t)
+      ((module B) : b t)
+      ((module C) : c t)
+      ((module D) : d t)
+      : (a, b, c, d) T.t t
+      =
+      (module struct
+        type t = (A.t, B.t, C.t, D.t) T.t
+
+        let id_name = T.name
+
+        let id_sexp =
+          Sexp.List [ Atom id_name; A.id_sexp; B.id_sexp; C.id_sexp; D.id_sexp ]
+        ;;
+
+        let sexp_of_t t = T.sexp_of_t A.sexp_of_t B.sexp_of_t C.sexp_of_t D.sexp_of_t t
+        let type_key = T4 (A.type_key, B.type_key, C.type_key, D.type_key)
+        let uid = Uid.create type_key [ A.uid; B.uid; C.uid; D.uid ]
+
+        let type_equal (type other) (otherkey : other key) : (t, other) equal option =
+          match otherkey with
+          | T4 (akey, bkey, ckey, dkey) ->
+            (match
+               A.type_equal akey, B.type_equal bkey, C.type_equal ckey, D.type_equal dkey
+             with
+             | Some T, Some T, Some T, Some T -> Some T
+             | None, _, _, _ | _, None, _, _ | _, _, None, _ | _, _, _, None -> None)
+          | _ -> None
+        ;;
+      end)
+    ;;
+  end
+
   let create (type a) ~name sexp_of_t =
     let module T =
       Create0 (struct
diff --git a/src/type_equal_intf.ml b/src/type_equal_intf.ml
index 41789cb6..ba3a00ef 100644
--- a/src/type_equal_intf.ml
+++ b/src/type_equal_intf.ml
@@ -62,6 +62,17 @@ module Type_equal_defns (Type_equal : T.T2) = struct
       -> (('a1, 'a2, 'a3) t, ('b1, 'b2, 'b3) t) Type_equal.t
   end
 
+  module type Lift4 = sig
+    type ('a, 'b, 'c, 'd) t
+
+    val lift
+      :  ('a1, 'b1) Type_equal.t
+      -> ('a2, 'b2) Type_equal.t
+      -> ('a3, 'b3) Type_equal.t
+      -> ('a4, 'b4) Type_equal.t
+      -> (('a1, 'a2, 'a3, 'a4) t, ('b1, 'b2, 'b3, 'b4) t) Type_equal.t
+  end
+
   (** [Injective] is an interface that states that a type is injective, where the type is
       viewed as a function from types to other types. It predates OCaml's support for
       explicit injectivity annotations in the type system.
@@ -152,8 +163,8 @@ module Type_equal_defns (Type_equal : T.T2) = struct
 end
 
 module Type_equal_id_defns (Id : sig
-  type 'a t
-end) =
+    type 'a t
+  end) =
 struct
   module type Arg0 = sig
     type t [@@deriving_inline sexp_of]
@@ -204,6 +215,22 @@ struct
     val name : string
   end
 
+  module type Arg4 = sig
+    type (!'a, !'b, !'c, !'d) t [@@deriving_inline sexp_of]
+
+    val sexp_of_t
+      :  ('a -> Sexplib0.Sexp.t)
+      -> ('b -> Sexplib0.Sexp.t)
+      -> ('c -> Sexplib0.Sexp.t)
+      -> ('d -> Sexplib0.Sexp.t)
+      -> ('a, 'b, 'c, 'd) t
+      -> Sexplib0.Sexp.t
+
+    [@@@end]
+
+    val name : string
+  end
+
   module type S0 = sig
     type t
 
@@ -227,6 +254,17 @@ struct
 
     val type_equal_id : 'a Id.t -> 'b Id.t -> 'c Id.t -> ('a, 'b, 'c) t Id.t
   end
+
+  module type S4 = sig
+    type ('a, 'b, 'c, 'd) t
+
+    val type_equal_id
+      :  'a Id.t
+      -> 'b Id.t
+      -> 'c Id.t
+      -> 'd Id.t
+      -> ('a, 'b, 'c, 'd) t Id.t
+  end
 end
 
 (**/**)
@@ -247,8 +285,8 @@ module type Type_equal = sig
 
   (** @inline *)
   include module type of Type_equal_defns (struct
-    type ('a, 'b) t = ('a, 'b) equal
-  end)
+      type ('a, 'b) t = ('a, 'b) equal
+    end)
 
   (** [refl], [sym], and [trans] construct proofs that type equality is reflexive,
       symmetric, and transitive. *)
@@ -291,6 +329,7 @@ module type Type_equal = sig
   module Lift (T : T1) : Lift with type 'a t := 'a T.t
   module Lift2 (T : T2) : Lift2 with type ('a, 'b) t := ('a, 'b) T.t
   module Lift3 (T : T3) : Lift3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) T.t
+  module Lift4 (T : T4) : Lift4 with type ('a, 'b, 'c, 'd) t := ('a, 'b, 'c, 'd) T.t
 
   (** [tuple2] and [detuple2] convert between equality on a 2-tuple and its components. *)
 
@@ -310,8 +349,8 @@ module type Type_equal = sig
 
     (** @inline *)
     include module type of Type_equal_id_defns (struct
-      type nonrec 'a t = 'a t
-    end)
+        type nonrec 'a t = 'a t
+      end)
 
     (** Every [Id.t] contains a unique id that is distinct from the [Uid.t] in any other
         [Id.t]. *)
@@ -359,5 +398,6 @@ module type Type_equal = sig
     module Create1 (T : Arg1) : S1 with type 'a t := 'a T.t
     module Create2 (T : Arg2) : S2 with type ('a, 'b) t := ('a, 'b) T.t
     module Create3 (T : Arg3) : S3 with type ('a, 'b, 'c) t := ('a, 'b, 'c) T.t
+    module Create4 (T : Arg4) : S4 with type ('a, 'b, 'c, 'd) t := ('a, 'b, 'c, 'd) T.t
   end
 end
diff --git a/src/uchar.ml b/src/uchar.ml
index bc737e23..7e9ae904 100644
--- a/src/uchar.ml
+++ b/src/uchar.ml
@@ -28,18 +28,18 @@ let t_sexp_grammar : t Sexplib0.Sexp_grammar.t =
 ;;
 
 include Pretty_printer.Register (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let module_name = module_name
-  let to_string = to_string_internal
-end)
+    let module_name = module_name
+    let to_string = to_string_internal
+  end)
 
 include Comparable.Make (struct
-  type nonrec t = t
+    type nonrec t = t
 
-  let compare = compare
-  let sexp_of_t = sexp_of_t
-end)
+    let compare = compare
+    let sexp_of_t = sexp_of_t
+  end)
 
 (* Open replace_polymorphic_compare after including functor instantiations so they do not
    shadow its definitions. This is here so that efficient versions of the comparison
@@ -118,12 +118,12 @@ module Decode_result = struct
 end
 
 module Make_utf (Format : sig
-  val codec_name : string
-  val module_name : string
-  val byte_length : t -> int
-  val get_decode_result : string -> byte_pos:int -> Decode_result.t
-  val set : bytes -> int -> t -> int
-end) : Utf = struct
+    val codec_name : string
+    val module_name : string
+    val byte_length : t -> int
+    val get_decode_result : string -> byte_pos:int -> Decode_result.t
+    val set : bytes -> int -> t -> int
+  end) : Utf = struct
   let codec_name = Format.codec_name
   let byte_length = Format.byte_length
 
@@ -139,7 +139,7 @@ end) : Utf = struct
     Format.module_name ^ ".of_string: expected a single Unicode character"
   ;;
 
-  let[@cold] raise_of_string string =
+  let[@cold] [@inline never] [@local never] [@specialise never] raise_of_string string =
     Error.raise_s (Sexp.message of_string_message [ "string", Atom string ])
   ;;
 
@@ -155,44 +155,44 @@ end) : Utf = struct
 end
 
 module Utf8 = Make_utf (struct
-  let codec_name = "UTF-8"
-  let module_name = "Base.Uchar.Utf8"
-  let byte_length = utf_8_byte_length
-  let get_decode_result = String.get_utf_8_uchar
-  let set = Bytes.set_uchar_utf_8
-end)
+    let codec_name = "UTF-8"
+    let module_name = "Base.Uchar.Utf8"
+    let byte_length = utf_8_byte_length
+    let get_decode_result = String.get_utf_8_uchar
+    let set = Bytes.set_uchar_utf_8
+  end)
 
 module Utf16le = Make_utf (struct
-  let codec_name = "UTF-16LE"
-  let module_name = "Base.Uchar.Utf16le"
-  let byte_length = utf_16_byte_length
-  let get_decode_result = String.get_utf_16le_uchar
-  let set = Bytes.set_uchar_utf_16le
-end)
+    let codec_name = "UTF-16LE"
+    let module_name = "Base.Uchar.Utf16le"
+    let byte_length = utf_16_byte_length
+    let get_decode_result = String.get_utf_16le_uchar
+    let set = Bytes.set_uchar_utf_16le
+  end)
 
 module Utf16be = Make_utf (struct
-  let codec_name = "UTF-16BE"
-  let module_name = "Base.Uchar.Utf16be"
-  let byte_length = utf_16_byte_length
-  let get_decode_result = String.get_utf_16be_uchar
-  let set = Bytes.set_uchar_utf_16be
-end)
+    let codec_name = "UTF-16BE"
+    let module_name = "Base.Uchar.Utf16be"
+    let byte_length = utf_16_byte_length
+    let get_decode_result = String.get_utf_16be_uchar
+    let set = Bytes.set_uchar_utf_16be
+  end)
 
 module Utf32le = Make_utf (struct
-  let codec_name = "UTF-32LE"
-  let module_name = "Base.Uchar.Utf32le"
-  let byte_length _ = 4
-  let get_decode_result = String.get_utf_32le_uchar
-  let set = Bytes.set_uchar_utf_32le
-end)
+    let codec_name = "UTF-32LE"
+    let module_name = "Base.Uchar.Utf32le"
+    let byte_length _ = 4
+    let get_decode_result = String.get_utf_32le_uchar
+    let set = Bytes.set_uchar_utf_32le
+  end)
 
 module Utf32be = Make_utf (struct
-  let codec_name = "UTF-32BE"
-  let module_name = "Base.Uchar.Utf32be"
-  let byte_length _ = 4
-  let get_decode_result = String.get_utf_32be_uchar
-  let set = Bytes.set_uchar_utf_32be
-end)
+    let codec_name = "UTF-32BE"
+    let module_name = "Base.Uchar.Utf32be"
+    let byte_length _ = 4
+    let get_decode_result = String.get_utf_32be_uchar
+    let set = Bytes.set_uchar_utf_32be
+  end)
 
 (* Include type-specific [Replace_polymorphic_compare] at the end, after
    including functor application that could shadow its definitions. This is
diff --git a/src/uchar_intf.ml b/src/uchar_intf.ml
index 400b2c80..ed0a9e48 100644
--- a/src/uchar_intf.ml
+++ b/src/uchar_intf.ml
@@ -82,11 +82,11 @@ module type Uchar = sig
 
   (** Number of bytes needed to represent [t] in UTF-8. *)
   val utf_8_byte_length : t -> int
-    [@@deprecated "[since 2023-11] use [Utf8.byte_length]"]
+  [@@deprecated "[since 2023-11] use [Utf8.byte_length]"]
 
   (** Number of bytes needed to represent [t] in UTF-16. *)
   val utf_16_byte_length : t -> int
-    [@@deprecated "[since 2023-11] use [Utf16le.byte_length] or [Utf16be.byte_length]"]
+  [@@deprecated "[since 2023-11] use [Utf16le.byte_length] or [Utf16be.byte_length]"]
 
   val min_value : t
   val max_value : t
@@ -101,7 +101,7 @@ module type Uchar = sig
   (** Result of decoding a UTF codec that may contain invalid encodings. *)
   module Decode_result : sig
     type t = Uchar0.utf_decode
-    [@@immediate] [@@deriving_inline compare, equal, hash, sexp_of]
+    [@@deriving_inline compare, equal, hash, sexp_of] [@@immediate]
 
     include Ppx_compare_lib.Comparable.S with type t := t
     include Ppx_compare_lib.Equal.S with type t := t
diff --git a/src/uniform_array.ml b/src/uniform_array.ml
index 44dd7343..c58d35c8 100644
--- a/src/uniform_array.ml
+++ b/src/uniform_array.ml
@@ -123,7 +123,7 @@ let fold t ~init ~f =
   !r
 ;;
 
-let to_list t = List.init ~f:(get t) (length t)
+let to_list t = List.init ~f:(fun i -> get t i) (length t)
 
 let of_list l =
   let len = List.length l in
@@ -224,7 +224,7 @@ let concat ts =
          set res (so_far + i) (get t i)
        done;
        so_far + len)
-      : int);
+     : int);
   res
 ;;
 
@@ -336,20 +336,20 @@ include
     end)
 
 include Blit.Make1 (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let length = length
+    let length = length
 
-  let create_like ~len t =
-    if len = 0
-    then empty
-    else (
-      assert (length t > 0);
-      create ~len (get t 0))
-  ;;
+    let create_like ~len t =
+      if len = 0
+      then empty
+      else (
+        assert (length t > 0);
+        create ~len (get t 0))
+    ;;
 
-  let unsafe_blit = unsafe_blit
-end)
+    let unsafe_blit = unsafe_blit
+  end)
 
 let min_elt t ~compare = Container.min_elt ~fold t ~compare
 let max_elt t ~compare = Container.max_elt ~fold t ~compare
@@ -380,18 +380,18 @@ let compare__local compare_elt a b =
 let compare compare_elt a b = compare__local compare_elt a b
 
 module Sort = Array.Private.Sorter (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let length = length
-  let get = unsafe_get
-  let set = unsafe_set
-end)
+    let length = length
+    let get t i = unsafe_get t i
+    let set t i x = unsafe_set t i x
+  end)
 
 let sort = Sort.sort
 
 include Binary_searchable.Make1 (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let length = length
-  let get = unsafe_get
-end)
+    let length = length
+    let get t i = unsafe_get t i
+  end)
diff --git a/src/uniform_array.mli b/src/uniform_array.mli
index c889b257..22dc43d2 100644
--- a/src/uniform_array.mli
+++ b/src/uniform_array.mli
@@ -28,7 +28,6 @@ val init : int -> f:(int -> 'a) -> 'a t
 val length : 'a t -> int
 val get : 'a t -> int -> 'a
 val unsafe_get : 'a t -> int -> 'a
-val unsafe_get_local : 'a t -> int -> 'a
 val set : 'a t -> int -> 'a -> unit
 val unsafe_set : 'a t -> int -> 'a -> unit
 val swap : _ t -> int -> int -> unit
diff --git a/src/variant.mli b/src/variant.mli
index ba0e7e2b..6f772f89 100644
--- a/src/variant.mli
+++ b/src/variant.mli
@@ -3,7 +3,7 @@
 
 type 'constructor t =
   { name : string
-      (** The position of the constructor in the type definition, starting from 0 *)
+  (** The position of the constructor in the type definition, starting from 0 *)
   ; rank : int
   ; constructor : 'constructor
   }
diff --git a/src/word_size.ml b/src/word_size.ml
index 91e80579..8da69468 100644
--- a/src/word_size.ml
+++ b/src/word_size.ml
@@ -10,7 +10,7 @@ let sexp_of_t =
   (function
    | W32 -> Sexplib0.Sexp.Atom "W32"
    | W64 -> Sexplib0.Sexp.Atom "W64"
-    : t -> Sexplib0.Sexp.t)
+   : t -> Sexplib0.Sexp.t)
 ;;
 
 [@@@end]
diff --git a/test/allocation/bin/dune b/test/allocation/bin/dune
index ff97ffd7..2dc35ca6 100644
--- a/test/allocation/bin/dune
+++ b/test/allocation/bin/dune
@@ -1,7 +1,7 @@
 (executables
  (modes byte exe)
  (names test_option_array_allocation)
- (libraries base expect_test_helpers_core compiler-libs.common
+ (libraries base core expect_test_helpers_core compiler-libs.common
    core_kernel.version_util)
  (ocamlopt_flags :standard -O3)
  (preprocess
diff --git a/test/allocation/bin/test_option_array_allocation.ml b/test/allocation/bin/test_option_array_allocation.ml
index 1df44f45..db5c5b9e 100644
--- a/test/allocation/bin/test_option_array_allocation.ml
+++ b/test/allocation/bin/test_option_array_allocation.ml
@@ -5,7 +5,7 @@ open Expect_test_helpers_core
 let () =
   let t = of_array [| None |] in
   assert (
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       match get t 0 with
       | None -> true
       | Some _ -> false))
@@ -44,7 +44,7 @@ let () =
     Config.flambda2 && Version_util.x_library_inlining
   in
   if compiler_eliminates_the_allocation
-  then assert (require_no_allocation [%here] get_some)
+  then assert (require_no_allocation get_some)
   else
     let module Gc = Core.Gc.For_testing in
     let _, { Gc.Allocation_report.minor_words_allocated; _ } =
diff --git a/test/allocation/dune b/test/allocation/dune
index 6782ae64..12c8916d 100644
--- a/test/allocation/dune
+++ b/test/allocation/dune
@@ -1,5 +1,6 @@
 (library
  (name base_test_allocation)
- (libraries async base expect_test_helpers_async expect_test_helpers_core)
+ (libraries async base expect_test_helpers_async expect_test_helpers_core
+   stdio)
  (preprocess
   (pps ppx_jane)))
diff --git a/test/allocation/test_array_allocation.ml b/test/allocation/test_array_allocation.ml
index e05a92ee..dd851f4d 100644
--- a/test/allocation/test_array_allocation.ml
+++ b/test/allocation/test_array_allocation.ml
@@ -2,14 +2,14 @@ open! Base
 open Expect_test_helpers_core
 
 let%expect_test "Array.sort [||] only allocates when computing bounds" =
-  require_allocation_does_not_exceed (Minor_words 3) [%here] (fun () ->
+  require_allocation_does_not_exceed (Minor_words 3) (fun () ->
     Array.sort ~compare:Int.compare [||]);
   [%expect {| |}]
 ;;
 
 let%expect_test "Array.sort [| 5; 2; 3; 4; 1 |] only allocates when computing bounds" =
   let arr = [| 5; 2; 3; 4; 1 |] in
-  require_allocation_does_not_exceed (Minor_words 3) [%here] (fun () ->
+  require_allocation_does_not_exceed (Minor_words 3) (fun () ->
     Array.sort ~compare:Int.compare arr);
   [%expect {| |}]
 ;;
@@ -17,16 +17,12 @@ let%expect_test "Array.sort [| 5; 2; 3; 4; 1 |] only allocates when computing bo
 let%expect_test "equal does not allocate" =
   let arr1 = [| 1; 2; 3; 4 |] in
   let arr2 = [| 1; 2; 4; 3 |] in
-  require
-    [%here]
-    (require_no_allocation [%here] (fun () -> not (Array.equal Int.equal arr1 arr2)));
+  require (require_no_allocation (fun () -> not (Array.equal Int.equal arr1 arr2)));
   [%expect {| |}]
 ;;
 
 let%expect_test "foldi does not allocate" =
   let arr = [| 1; 2; 3; 4 |] in
   let f i x y = i + x + y in
-  require
-    [%here]
-    (require_no_allocation [%here] (fun () -> 16 = Array.foldi ~init:0 ~f arr))
+  require (require_no_allocation (fun () -> 16 = Array.foldi ~init:0 ~f arr))
 ;;
diff --git a/test/allocation/test_char_allocation.ml b/test/allocation/test_char_allocation.ml
index e78cc5d3..8b76a651 100644
--- a/test/allocation/test_char_allocation.ml
+++ b/test/allocation/test_char_allocation.ml
@@ -4,7 +4,7 @@ open Expect_test_helpers_core
 let%expect_test _ =
   let x = Sys.opaque_identity 'a' in
   let y = Sys.opaque_identity 'b' in
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     ignore (Sys.opaque_identity (Char.Caseless.equal x y) : bool));
   [%expect {| |}]
 ;;
diff --git a/test/allocation/test_float_allocation.ml b/test/allocation/test_float_allocation.ml
index 208d2d37..cba68845 100644
--- a/test/allocation/test_float_allocation.ml
+++ b/test/allocation/test_float_allocation.ml
@@ -4,7 +4,7 @@ open Float
 
 let%expect_test "iround_nearest_exn noalloc" =
   let t = Sys.opaque_identity 205.414 in
-  Expect_test_helpers_core.require_no_allocation [%here] (fun () -> iround_nearest_exn t)
+  Expect_test_helpers_core.require_no_allocation (fun () -> iround_nearest_exn t)
   |> printf "%d\n";
   [%expect {| 205 |}]
 ;;
diff --git a/test/allocation/test_hashtbl_allocation.ml b/test/allocation/test_hashtbl_allocation.ml
index 54fbb03e..06729081 100644
--- a/test/allocation/test_hashtbl_allocation.ml
+++ b/test/allocation/test_hashtbl_allocation.ml
@@ -14,7 +14,7 @@ let%expect_test "find_and_call_1_and_2" =
       assert (a = x);
       assert (b = x * 7)
     in
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       for i = 0 to x do
         Hashtbl.find_and_call1 t i ~a:(i * 7) ~if_found ~if_not_found
       done);
@@ -26,7 +26,7 @@ let%expect_test "find_and_call_1_and_2" =
       assert (a = x);
       assert (b = x * 7)
     in
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       for i = 0 to x do
         Hashtbl.findi_and_call1 t i ~a:(i * 7) ~if_found ~if_not_found
       done);
@@ -39,7 +39,7 @@ let%expect_test "find_and_call_1_and_2" =
       assert (b = x * 7);
       assert (c = x * 14)
     in
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       for i = 0 to x do
         Hashtbl.find_and_call2 t i ~a:(i * 7) ~b:(i * 14) ~if_found ~if_not_found
       done);
@@ -53,7 +53,7 @@ let%expect_test "find_and_call_1_and_2" =
       assert (b = x * 7);
       assert (c = x * 14)
     in
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       for i = 0 to x do
         Hashtbl.findi_and_call2 t i ~a:(i * 7) ~b:(i * 14) ~if_found ~if_not_found
       done);
@@ -69,7 +69,8 @@ let%expect_test "find_and_call_1_and_2" =
   test 29;
   test 33;
   test 3133;
-  [%expect {|
+  [%expect
+    {|
     1
     3
     10
@@ -85,6 +86,6 @@ let%expect_test ("find_or_add shouldn't allocate" [@tags "no-js"]) =
   let default = Fn.const () in
   let t = Hashtbl.create (module Int) ~size:16 ~growth_allowed:false in
   Hashtbl.add_exn t ~key:100 ~data:();
-  require_no_allocation [%here] (fun () -> Hashtbl.find_or_add t 100 ~default);
+  require_no_allocation (fun () -> Hashtbl.find_or_add t 100 ~default);
   [%expect {| |}]
 ;;
diff --git a/test/allocation/test_list_allocation.ml b/test/allocation/test_list_allocation.ml
index 98483459..a9c9cf06 100644
--- a/test/allocation/test_list_allocation.ml
+++ b/test/allocation/test_list_allocation.ml
@@ -5,9 +5,7 @@ let%expect_test "is_prefix does not allocate" =
   let list = Sys.opaque_identity [ 1; 2; 3 ] in
   let prefix = Sys.opaque_identity [ 1; 2 ] in
   let equal = Int.equal in
-  let (_ : bool) =
-    require_no_allocation [%here] (fun () -> List.is_prefix list ~equal ~prefix)
-  in
+  let (_ : bool) = require_no_allocation (fun () -> List.is_prefix list ~equal ~prefix) in
   [%expect {| |}]
 ;;
 
@@ -15,8 +13,6 @@ let%expect_test "is_suffix does not allocate" =
   let list = Sys.opaque_identity [ 1; 2; 3 ] in
   let suffix = Sys.opaque_identity [ 2; 3 ] in
   let equal = Int.equal in
-  let (_ : bool) =
-    require_no_allocation [%here] (fun () -> List.is_suffix list ~equal ~suffix)
-  in
+  let (_ : bool) = require_no_allocation (fun () -> List.is_suffix list ~equal ~suffix) in
   [%expect {| |}]
 ;;
diff --git a/test/allocation/test_modes_allocation.ml b/test/allocation/test_modes_allocation.ml
new file mode 100644
index 00000000..83eab45e
--- /dev/null
+++ b/test/allocation/test_modes_allocation.ml
@@ -0,0 +1,103 @@
+open! Base
+open Expect_test_helpers_core
+
+module type S = sig
+  type t [@@deriving equal, globalize, sexp_of]
+end
+
+let test (type t) (module T : S with type t = t) global local =
+  let g = require_no_allocation global in
+  print_s [%sexp (g : T.t)];
+  let l = require_no_allocation_local local in
+  require_equal (module T) g ([%globalize: T.t] l)
+;;
+
+let%expect_test "Global.Poly_fn1" =
+  let open
+    Modes.Global.Poly_fn1 (Int) (Int)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x = W.wrap (Int.globalize (W.unwrap x) + 0)
+         end) in
+  test (module Int) (fun () -> fn_global 1) (fun () -> fn_local 1);
+  [%expect {| 1 |}]
+;;
+
+let%expect_test "Global.Poly_fn2" =
+  let open
+    Modes.Global.Poly_fn2 (Int) (Int) (Int)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y = W.wrap (Int.globalize (W.unwrap x) + Int.globalize (W.unwrap y))
+         end) in
+  test (module Int) (fun () -> fn_global 1 2) (fun () -> fn_local 1 2);
+  [%expect {| 3 |}]
+;;
+
+let%expect_test "Global.Poly_fn3" =
+  let open
+    Modes.Global.Poly_fn3 (Int) (Int) (Int) (Int)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y z =
+             W.wrap
+               (Int.globalize (W.unwrap x)
+                + Int.globalize (W.unwrap y)
+                + Int.globalize (W.unwrap z))
+           ;;
+         end) in
+  test (module Int) (fun () -> fn_global 1 2 3) (fun () -> fn_local 1 2 3);
+  [%expect {| 6 |}]
+;;
+
+let%expect_test ("Global.Poly_fn1" [@tags "fast-flambda2"]) =
+  let open
+    Modes.Global.Poly_fn1 (Float) (Float)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x = W.wrap (Float.globalize (W.unwrap x) +. 0.)
+         end) in
+  test (module Float) (fun () -> fn_global 1.) (fun () -> fn_local 1.);
+  [%expect {| 1 |}]
+;;
+
+let%expect_test ("Global.Poly_fn2" [@tags "fast-flambda2"]) =
+  let open
+    Modes.Global.Poly_fn2 (Float) (Float) (Float)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y =
+             W.wrap (Float.globalize (W.unwrap x) +. Float.globalize (W.unwrap y))
+           ;;
+         end) in
+  test (module Float) (fun () -> fn_global 1. 2.) (fun () -> fn_local 1. 2.);
+  [%expect {| 3 |}]
+;;
+
+let%expect_test ("Global.Poly_fn3" [@tags "fast-flambda2"]) =
+  let open
+    Modes.Global.Poly_fn3 (Float) (Float) (Float) (Float)
+      (functor
+         (W : Modes.Global.Wrapper)
+         ->
+         struct
+           let fn x y z =
+             W.wrap
+               (Float.globalize (W.unwrap x)
+                +. Float.globalize (W.unwrap y)
+                +. Float.globalize (W.unwrap z))
+           ;;
+         end) in
+  test (module Float) (fun () -> fn_global 1. 2. 3.) (fun () -> fn_local 1. 2. 3.);
+  [%expect {| 6 |}]
+;;
diff --git a/test/allocation/test_modes_allocation.mli b/test/allocation/test_modes_allocation.mli
new file mode 100644
index 00000000..74bb7298
--- /dev/null
+++ b/test/allocation/test_modes_allocation.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
diff --git a/test/allocation/test_option_allocation.ml b/test/allocation/test_option_allocation.ml
new file mode 100644
index 00000000..d7866fcc
--- /dev/null
+++ b/test/allocation/test_option_allocation.ml
@@ -0,0 +1,143 @@
+open! Base
+open Base_quickcheck.Export
+open Expect_test_helpers_core
+
+let%test_module "local mode vs global mode" =
+  (module struct
+    module type Input = sig
+      type t [@@deriving quickcheck, sexp_of]
+    end
+
+    module type Output = sig
+      type t [@@deriving equal, globalize, sexp_of]
+    end
+
+    let test
+      (type input output)
+      (module Input : Input with type t = input)
+      (module Output : Output with type t = output)
+      ~local:(fn_local : Input.t -> Output.t)
+      ~global:(fn_global : Input.t -> Output.t)
+      =
+      quickcheck_m
+        (module Input)
+        ~f:(fun input ->
+          require_equal
+            (module struct
+              type t = Output.t Or_error.t [@@deriving equal, sexp_of]
+            end)
+            (Or_error.try_with (fun () ->
+               [%globalize: Output.t]
+                 (require_no_allocation_local (fun () -> fn_local input)) [@nontail]))
+            (Or_error.try_with (fun () -> fn_global input)))
+    ;;
+
+    let%expect_test "value_local" =
+      test
+        ~local:(Option.value_local ~default:0)
+        ~global:(Option.value ~default:0)
+        (module struct
+          type t = int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "value_local_exn" =
+      test
+        ~local:Option.value_local_exn
+        ~global:Option.value_exn
+        (module struct
+          type t = int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "value_map_local" =
+      test
+        ~local:(Option.value_map_local ~f:(fun x -> x + 1) ~default:0)
+        ~global:(Option.value_map ~f:(fun x -> x + 1) ~default:0)
+        (module struct
+          type t = int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "value_or_thunk_local" =
+      test
+        ~local:(Option.value_or_thunk_local ~default:(fun () -> 0))
+        ~global:(Option.value_or_thunk ~default:(fun () -> 0))
+        (module struct
+          type t = int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "map_local" =
+      test
+        ~local:(Option.map_local ~f:(fun x -> x + 1))
+        ~global:(Option.map ~f:(fun x -> x + 1))
+        (module struct
+          type t = int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int option [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "to_list_local" =
+      test
+        ~local:Option.to_list_local
+        ~global:Option.to_list
+        (module struct
+          type t = int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int list [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "some_local" =
+      test
+        ~local:Option.some_local
+        ~global:Option.some
+        (module struct
+          type t = int [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int option [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "first_some_local" =
+      test
+        ~local:(fun (x, y) -> Option.first_some_local x y)
+        ~global:(fun (x, y) -> Option.first_some x y)
+        (module struct
+          type t = int option * int option [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int option [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+
+    let%expect_test "some_if_local" =
+      test
+        ~local:(fun (b, i) -> Option.some_if_local b i)
+        ~global:(fun (b, i) -> Option.some_if b i)
+        (module struct
+          type t = bool * int [@@deriving quickcheck, sexp_of]
+        end)
+        (module struct
+          type t = int option [@@deriving equal, globalize, sexp_of]
+        end)
+    ;;
+  end)
+;;
diff --git a/test/allocation/test_option_allocation.mli b/test/allocation/test_option_allocation.mli
new file mode 100644
index 00000000..74bb7298
--- /dev/null
+++ b/test/allocation/test_option_allocation.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
diff --git a/test/allocation/test_string_allocation.ml b/test/allocation/test_string_allocation.ml
index 7814a6d0..095c0f0f 100644
--- a/test/allocation/test_string_allocation.ml
+++ b/test/allocation/test_string_allocation.ml
@@ -4,7 +4,7 @@ open Expect_test_helpers_core
 let%expect_test _ =
   let x = Sys.opaque_identity "one string" in
   let y = Sys.opaque_identity "another" in
-  require_no_allocation [%here] (fun () ->
+  require_no_allocation (fun () ->
     ignore (Sys.opaque_identity (String.Caseless.equal x y) : bool));
   [%expect {| |}]
 ;;
@@ -12,7 +12,7 @@ let%expect_test _ =
 let%expect_test "empty substring" =
   let string = String.init 10 ~f:Char.of_int_exn in
   let test here f =
-    let substring = require_no_allocation here f in
+    let substring = require_no_allocation ~here f in
     assert (String.is_empty substring)
   in
   test [%here] (fun () -> String.sub string ~pos:0 ~len:0);
@@ -26,7 +26,7 @@ let%expect_test "empty substring" =
 let%expect_test "mem does not allocate" =
   let string = Sys.opaque_identity "abracadabra" in
   let char = Sys.opaque_identity 'd' in
-  require_no_allocation [%here] (fun () -> ignore (String.mem string char : bool));
+  require_no_allocation (fun () -> ignore (String.mem string char : bool));
   [%expect {| |}]
 ;;
 
@@ -34,8 +34,7 @@ let%expect_test "fold does not allocate" =
   let string = Sys.opaque_identity "abracadabra" in
   let char = Sys.opaque_identity 'd' in
   let f acc c = if Char.equal c char then true else acc in
-  require_no_allocation [%here] (fun () ->
-    ignore (String.fold string ~init:false ~f : bool));
+  require_no_allocation (fun () -> ignore (String.fold string ~init:false ~f : bool));
   [%expect {| |}]
 ;;
 
@@ -43,18 +42,14 @@ let%expect_test "foldi does not allocate" =
   let string = Sys.opaque_identity "abracadabra" in
   let char = Sys.opaque_identity 'd' in
   let f _i acc c = if Char.equal c char then true else acc in
-  require_no_allocation [%here] (fun () ->
-    ignore (String.foldi string ~init:false ~f : bool));
+  require_no_allocation (fun () -> ignore (String.foldi string ~init:false ~f : bool));
   [%expect {| |}]
 ;;
 
 let%test_module "common prefix and suffix" =
   (module struct
-    let require_int_equal a b ~message = require_equal [%here] (module Int) a b ~message
-
-    let require_string_equal a b ~message =
-      require_equal [%here] (module String) a b ~message
-    ;;
+    let require_int_equal a b ~message = require_equal (module Int) a b ~message
+    let require_string_equal a b ~message = require_equal (module String) a b ~message
 
     let simulate_common_length ~get_common2_length list =
       let rec loop acc prev list ~get_common2_length =
@@ -89,14 +84,12 @@ let%test_module "common prefix and suffix" =
         if not (String.is_empty common || List.mem list common ~equal:String.equal)
         then print_endline "(may allocate)"
         else (
-          ignore (require_no_allocation [%here] (fun () -> get_common list) : string);
+          ignore (require_no_allocation (fun () -> get_common list) : string);
           Option.iter (get_shortest_and_longest list) ~f:(fun (shortest, longest) ->
             ignore
-              (require_no_allocation [%here] (fun () -> get_common2 shortest longest)
-                : string);
+              (require_no_allocation (fun () -> get_common2 shortest longest) : string);
             ignore
-              (require_no_allocation [%here] (fun () -> get_common2 longest shortest)
-                : string))))
+              (require_no_allocation (fun () -> get_common2 longest shortest) : string))))
     ;;
 
     let test_prefix =
@@ -133,12 +126,14 @@ let%test_module "common prefix and suffix" =
 
     let%expect_test "doubleton, alloc" =
       test_prefix [ "hello"; "help"; "hex" ];
-      [%expect {|
+      [%expect
+        {|
         he
         (may allocate)
         |}];
       test_suffix [ "crest"; "zest"; "1st" ];
-      [%expect {|
+      [%expect
+        {|
         st
         (may allocate)
         |}]
@@ -153,12 +148,14 @@ let%test_module "common prefix and suffix" =
 
     let%expect_test "many, alloc" =
       test_prefix [ "this"; "that"; "the other"; "these"; "those"; "thy"; "thou" ];
-      [%expect {|
+      [%expect
+        {|
         th
         (may allocate)
         |}];
       test_suffix [ "fourth"; "fifth"; "sixth"; "seventh"; "eleventh"; "twelfth" ];
-      [%expect {|
+      [%expect
+        {|
         th
         (may allocate)
         |}]
diff --git a/test/allocation/test_type_equal_allocation.ml b/test/allocation/test_type_equal_allocation.ml
index c7d2fcd0..547ad7f6 100644
--- a/test/allocation/test_type_equal_allocation.ml
+++ b/test/allocation/test_type_equal_allocation.ml
@@ -4,6 +4,5 @@ open Expect_test_helpers_core
 let t1 = Type_equal.Id.create ~name:"t1" [%sexp_of: _]
 
 let%expect_test "Type_equal.Id.to_sexp allocation" =
-  require_no_allocation [%here] (fun () ->
-    ignore (Type_equal.Id.to_sexp t1 : 'a -> Sexp.t))
+  require_no_allocation (fun () -> ignore (Type_equal.Id.to_sexp t1 : 'a -> Sexp.t))
 ;;
diff --git a/test/avltree_unit_tests.ml b/test/avltree_unit_tests.ml
index d132df53..a7b03f7a 100644
--- a/test/avltree_unit_tests.ml
+++ b/test/avltree_unit_tests.ml
@@ -2,428 +2,400 @@ open! Import
 
 let%test_module _ =
   (module (
-             struct
-               open Avltree
-
-               type ('k, 'v) t = ('k, 'v) Avltree.t = private
-                 | Empty
-                 | Node of
-                     { mutable left : ('k, 'v) t
-                     ; key : 'k
-                     ; mutable value : 'v
-                     ; mutable height : int
-                     ; mutable right : ('k, 'v) t
-                     }
-                 | Leaf of
-                     { key : 'k
-                     ; mutable value : 'v
-                     }
-
-               module For_quickcheck = struct
-                 module Key = struct
-                   include Int
-
-                   type t = int [@@deriving quickcheck]
-
-                   let quickcheck_generator =
-                     Base_quickcheck.Generator.small_positive_or_zero_int
-                   ;;
-                 end
-
-                 module Data = struct
-                   include String
-
-                   type t = string [@@deriving quickcheck]
-
-                   let quickcheck_generator =
-                     Base_quickcheck.Generator.string_of
-                       Base_quickcheck.Generator.char_lowercase
-                   ;;
-                 end
-
-                 let compare = Key.compare
-
-                 module Constructor = struct
-                   type t =
-                     | Add of Key.t * Data.t
-                     | Replace of Key.t * Data.t
-                     | Remove of Key.t
-                   [@@deriving quickcheck, sexp_of]
-
-                   let apply_to_tree t tree =
-                     match t with
-                     | Add (key, data) ->
-                       add tree ~key ~data ~compare ~added:(ref false) ~replace:false
-                     | Replace (key, data) ->
-                       add tree ~key ~data ~compare ~added:(ref false) ~replace:true
-                     | Remove key -> remove tree key ~compare ~removed:(ref false)
-                   ;;
-
-                   let apply_to_map t map =
-                     match t with
-                     | Add (key, data) ->
-                       if Map.mem map key then map else Map.set map ~key ~data
-                     | Replace (key, data) -> Map.set map ~key ~data
-                     | Remove key -> Map.remove map key
-                   ;;
-                 end
-
-                 module Constructors = struct
-                   type t = Constructor.t list [@@deriving quickcheck, sexp_of]
-                 end
-
-                 let reify constructors =
-                   List.fold
-                     constructors
-                     ~init:(empty, Map.empty (module Key))
-                     ~f:(fun (t, map) constructor ->
-                       ( Constructor.apply_to_tree constructor t
-                       , Constructor.apply_to_map constructor map ))
-                 ;;
-
-                 let merge map1 map2 =
-                   Map.merge map1 map2 ~f:(fun ~key variant ->
-                     match variant with
-                     | `Left data | `Right data -> Some data
-                     | `Both (data1, data2) ->
-                       Error.raise_s
-                         [%message
-                           "duplicate data for key"
-                             (key : Key.t)
-                             (data1 : Data.t)
-                             (data2 : Data.t)])
-                 ;;
-
-                 let rec to_map = function
-                   | Empty -> Map.empty (module Key)
-                   | Leaf { key; value = data } -> Map.singleton (module Key) key data
-                   | Node { left; key; value = data; height = _; right } ->
-                     merge
-                       (Map.singleton (module Key) key data)
-                       (merge (to_map left) (to_map right))
-                 ;;
-               end
-
-               open For_quickcheck
-
-               let empty = empty
-
-               let%test_unit _ =
-                 match empty with
-                 | Empty -> ()
-                 | _ -> assert false
-               ;;
-
-               let is_empty = is_empty
-               let%test _ = is_empty empty
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: bool] (is_empty t) ~expect:(Map.is_empty map))
-               ;;
-
-               let invariant = invariant
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     invariant t ~compare;
-                     [%test_result: Data.t Map.M(Key).t] (to_map t) ~expect:map)
-               ;;
-
-               let add = add
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructor.t list * Key.t * Data.t * bool
-                     [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key, data, replace) ->
-                     let t, map = reify constructors in
-                     (* test [added], other aspects of [add] are tested via [reify] in the
+  struct
+    open Avltree
+
+    type ('k, 'v) t = ('k, 'v) Avltree.t = private
+      | Empty
+      | Node of
+          { mutable left : ('k, 'v) t
+          ; key : 'k
+          ; mutable value : 'v
+          ; mutable height : int
+          ; mutable right : ('k, 'v) t
+          }
+      | Leaf of
+          { key : 'k
+          ; mutable value : 'v
+          }
+
+    module For_quickcheck = struct
+      module Key = struct
+        include Int
+
+        type t = int [@@deriving quickcheck]
+
+        let quickcheck_generator = Base_quickcheck.Generator.small_positive_or_zero_int
+      end
+
+      module Data = struct
+        include String
+
+        type t = string [@@deriving quickcheck]
+
+        let quickcheck_generator =
+          Base_quickcheck.Generator.string_of Base_quickcheck.Generator.char_lowercase
+        ;;
+      end
+
+      let compare = Key.compare
+
+      module Constructor = struct
+        type t =
+          | Add of Key.t * Data.t
+          | Replace of Key.t * Data.t
+          | Remove of Key.t
+        [@@deriving quickcheck, sexp_of]
+
+        let apply_to_tree t tree =
+          match t with
+          | Add (key, data) ->
+            add tree ~key ~data ~compare ~added:(ref false) ~replace:false
+          | Replace (key, data) ->
+            add tree ~key ~data ~compare ~added:(ref false) ~replace:true
+          | Remove key -> remove tree key ~compare ~removed:(ref false)
+        ;;
+
+        let apply_to_map t map =
+          match t with
+          | Add (key, data) -> if Map.mem map key then map else Map.set map ~key ~data
+          | Replace (key, data) -> Map.set map ~key ~data
+          | Remove key -> Map.remove map key
+        ;;
+      end
+
+      module Constructors = struct
+        type t = Constructor.t list [@@deriving quickcheck, sexp_of]
+      end
+
+      let reify constructors =
+        List.fold
+          constructors
+          ~init:(empty, Map.empty (module Key))
+          ~f:(fun (t, map) constructor ->
+            ( Constructor.apply_to_tree constructor t
+            , Constructor.apply_to_map constructor map ))
+      ;;
+
+      let merge map1 map2 =
+        Map.merge map1 map2 ~f:(fun ~key variant ->
+          match variant with
+          | `Left data | `Right data -> Some data
+          | `Both (data1, data2) ->
+            Error.raise_s
+              [%message
+                "duplicate data for key" (key : Key.t) (data1 : Data.t) (data2 : Data.t)])
+      ;;
+
+      let rec to_map = function
+        | Empty -> Map.empty (module Key)
+        | Leaf { key; value = data } -> Map.singleton (module Key) key data
+        | Node { left; key; value = data; height = _; right } ->
+          merge (Map.singleton (module Key) key data) (merge (to_map left) (to_map right))
+      ;;
+    end
+
+    open For_quickcheck
+
+    let empty = empty
+
+    let%test_unit _ =
+      match empty with
+      | Empty -> ()
+      | _ -> assert false
+    ;;
+
+    let is_empty = is_empty
+    let%test _ = is_empty empty
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: bool] (is_empty t) ~expect:(Map.is_empty map))
+    ;;
+
+    let invariant = invariant
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          invariant t ~compare;
+          [%test_result: Data.t Map.M(Key).t] (to_map t) ~expect:map)
+    ;;
+
+    let add = add
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructor.t list * Key.t * Data.t * bool
+          [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key, data, replace) ->
+          let t, map = reify constructors in
+          (* test [added], other aspects of [add] are tested via [reify] in the
               [invariant] test above *)
-                     let added = ref false in
-                     let (_ : (Key.t, Data.t) t) =
-                       add t ~key ~data ~compare ~added ~replace
-                     in
-                     [%test_result: bool] !added ~expect:(not (Map.mem map key)))
-               ;;
-
-               let remove = remove
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key) ->
-                     let t, map = reify constructors in
-                     (* test [removed], other aspects of [remove] are tested via [reify] in the
+          let added = ref false in
+          let (_ : (Key.t, Data.t) t) = add t ~key ~data ~compare ~added ~replace in
+          [%test_result: bool] !added ~expect:(not (Map.mem map key)))
+    ;;
+
+    let remove = remove
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key) ->
+          let t, map = reify constructors in
+          (* test [removed], other aspects of [remove] are tested via [reify] in the
               [invariant] test above *)
-                     let removed = ref false in
-                     let (_ : (Key.t, Data.t) t) = remove t key ~compare ~removed in
-                     [%test_result: bool] !removed ~expect:(Map.mem map key))
-               ;;
-
-               let find = find
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key) ->
-                     let t, map = reify constructors in
-                     [%test_result: Data.t option]
-                       (find t key ~compare)
-                       ~expect:(Map.find map key))
-               ;;
-
-               let mem = mem
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key) ->
-                     let t, map = reify constructors in
-                     [%test_result: bool] (mem t key ~compare) ~expect:(Map.mem map key))
-               ;;
-
-               let first = first
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: (Key.t * Data.t) option]
-                       (first t)
-                       ~expect:(Map.min_elt map))
-               ;;
-
-               let last = last
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: (Key.t * Data.t) option]
-                       (last t)
-                       ~expect:(Map.max_elt map))
-               ;;
-
-               let find_and_call = find_and_call
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key) ->
-                     let t, map = reify constructors in
-                     [%test_result: [ `Found of Data.t | `Not_found of Key.t ]]
-                       (find_and_call
-                          t
-                          key
-                          ~compare
-                          ~if_found:(fun data -> `Found data)
-                          ~if_not_found:(fun key -> `Not_found key))
-                       ~expect:
-                         (match Map.find map key with
-                          | None -> `Not_found key
-                          | Some data -> `Found data))
-               ;;
-
-               let findi_and_call = findi_and_call
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key) ->
-                     let t, map = reify constructors in
-                     [%test_result: [ `Found of Key.t * Data.t | `Not_found of Key.t ]]
-                       (findi_and_call
-                          t
-                          key
-                          ~compare
-                          ~if_found:(fun ~key ~data -> `Found (key, data))
-                          ~if_not_found:(fun key -> `Not_found key))
-                       ~expect:
-                         (match Map.find map key with
-                          | None -> `Not_found key
-                          | Some data -> `Found (key, data)))
-               ;;
-
-               let find_and_call1 = find_and_call1
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t * int
-                     [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key, a) ->
-                     let t, map = reify constructors in
-                     [%test_result:
-                       [ `Found of Data.t * int | `Not_found of Key.t * int ]]
-                       (find_and_call1
-                          t
-                          key
-                          ~compare
-                          ~a
-                          ~if_found:(fun data a -> `Found (data, a))
-                          ~if_not_found:(fun key a -> `Not_found (key, a)))
-                       ~expect:
-                         (match Map.find map key with
-                          | None -> `Not_found (key, a)
-                          | Some data -> `Found (data, a)))
-               ;;
-
-               let findi_and_call1 = findi_and_call1
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t * int
-                     [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key, a) ->
-                     let t, map = reify constructors in
-                     [%test_result:
-                       [ `Found of Key.t * Data.t * int | `Not_found of Key.t * int ]]
-                       (findi_and_call1
-                          t
-                          key
-                          ~compare
-                          ~a
-                          ~if_found:(fun ~key ~data a -> `Found (key, data, a))
-                          ~if_not_found:(fun key a -> `Not_found (key, a)))
-                       ~expect:
-                         (match Map.find map key with
-                          | None -> `Not_found (key, a)
-                          | Some data -> `Found (key, data, a)))
-               ;;
-
-               let find_and_call2 = find_and_call2
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t * int * string
-                     [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key, a, b) ->
-                     let t, map = reify constructors in
-                     [%test_result:
-                       [ `Found of Data.t * int * string
-                       | `Not_found of Key.t * int * string
-                       ]]
-                       (find_and_call2
-                          t
-                          key
-                          ~compare
-                          ~a
-                          ~b
-                          ~if_found:(fun data a b -> `Found (data, a, b))
-                          ~if_not_found:(fun key a b -> `Not_found (key, a, b)))
-                       ~expect:
-                         (match Map.find map key with
-                          | None -> `Not_found (key, a, b)
-                          | Some data -> `Found (data, a, b)))
-               ;;
-
-               let findi_and_call2 = findi_and_call2
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module struct
-                     type t = Constructors.t * Key.t * int * string
-                     [@@deriving quickcheck, sexp_of]
-                   end)
-                   ~f:(fun (constructors, key, a, b) ->
-                     let t, map = reify constructors in
-                     [%test_result:
-                       [ `Found of Key.t * Data.t * int * string
-                       | `Not_found of Key.t * int * string
-                       ]]
-                       (findi_and_call2
-                          t
-                          key
-                          ~compare
-                          ~a
-                          ~b
-                          ~if_found:(fun ~key ~data a b -> `Found (key, data, a, b))
-                          ~if_not_found:(fun key a b -> `Not_found (key, a, b)))
-                       ~expect:
-                         (match Map.find map key with
-                          | None -> `Not_found (key, a, b)
-                          | Some data -> `Found (key, data, a, b)))
-               ;;
-
-               let iter = iter
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: (Key.t * Data.t) list]
-                       (let q = Queue.create () in
-                        iter t ~f:(fun ~key ~data -> Queue.enqueue q (key, data));
-                        Queue.to_list q)
-                       ~expect:(Map.to_alist map))
-               ;;
-
-               let mapi_inplace = mapi_inplace
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: (Key.t * Data.t) list]
-                       (mapi_inplace t ~f:(fun ~key:_ ~data -> data ^ data);
-                        fold t ~init:[] ~f:(fun ~key ~data acc -> (key, data) :: acc))
-                       ~expect:
-                         (Map.map map ~f:(fun data -> data ^ data)
-                          |> Map.to_alist
-                          |> List.rev))
-               ;;
-
-               let fold = fold
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: (Key.t * Data.t) list]
-                       (fold t ~init:[] ~f:(fun ~key ~data acc -> (key, data) :: acc))
-                       ~expect:(Map.to_alist map |> List.rev))
-               ;;
-
-               let choose_exn = choose_exn
-
-               let%test_unit _ =
-                 Base_quickcheck.Test.run_exn
-                   (module Constructors)
-                   ~f:(fun constructors ->
-                     let t, map = reify constructors in
-                     [%test_result: bool]
-                       (is_some (Option.try_with (fun () -> choose_exn t)))
-                       ~expect:(not (Map.is_empty map)))
-               ;;
-             end :
-               module type of Avltree))
+          let removed = ref false in
+          let (_ : (Key.t, Data.t) t) = remove t key ~compare ~removed in
+          [%test_result: bool] !removed ~expect:(Map.mem map key))
+    ;;
+
+    let find = find
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key) ->
+          let t, map = reify constructors in
+          [%test_result: Data.t option] (find t key ~compare) ~expect:(Map.find map key))
+    ;;
+
+    let mem = mem
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key) ->
+          let t, map = reify constructors in
+          [%test_result: bool] (mem t key ~compare) ~expect:(Map.mem map key))
+    ;;
+
+    let first = first
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: (Key.t * Data.t) option] (first t) ~expect:(Map.min_elt map))
+    ;;
+
+    let last = last
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: (Key.t * Data.t) option] (last t) ~expect:(Map.max_elt map))
+    ;;
+
+    let find_and_call = find_and_call
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key) ->
+          let t, map = reify constructors in
+          [%test_result: [ `Found of Data.t | `Not_found of Key.t ]]
+            (find_and_call
+               t
+               key
+               ~compare
+               ~if_found:(fun data -> `Found data)
+               ~if_not_found:(fun key -> `Not_found key))
+            ~expect:
+              (match Map.find map key with
+               | None -> `Not_found key
+               | Some data -> `Found data))
+    ;;
+
+    let findi_and_call = findi_and_call
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key) ->
+          let t, map = reify constructors in
+          [%test_result: [ `Found of Key.t * Data.t | `Not_found of Key.t ]]
+            (findi_and_call
+               t
+               key
+               ~compare
+               ~if_found:(fun ~key ~data -> `Found (key, data))
+               ~if_not_found:(fun key -> `Not_found key))
+            ~expect:
+              (match Map.find map key with
+               | None -> `Not_found key
+               | Some data -> `Found (key, data)))
+    ;;
+
+    let find_and_call1 = find_and_call1
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t * int [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key, a) ->
+          let t, map = reify constructors in
+          [%test_result: [ `Found of Data.t * int | `Not_found of Key.t * int ]]
+            (find_and_call1
+               t
+               key
+               ~compare
+               ~a
+               ~if_found:(fun data a -> `Found (data, a))
+               ~if_not_found:(fun key a -> `Not_found (key, a)))
+            ~expect:
+              (match Map.find map key with
+               | None -> `Not_found (key, a)
+               | Some data -> `Found (data, a)))
+    ;;
+
+    let findi_and_call1 = findi_and_call1
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t * int [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key, a) ->
+          let t, map = reify constructors in
+          [%test_result: [ `Found of Key.t * Data.t * int | `Not_found of Key.t * int ]]
+            (findi_and_call1
+               t
+               key
+               ~compare
+               ~a
+               ~if_found:(fun ~key ~data a -> `Found (key, data, a))
+               ~if_not_found:(fun key a -> `Not_found (key, a)))
+            ~expect:
+              (match Map.find map key with
+               | None -> `Not_found (key, a)
+               | Some data -> `Found (key, data, a)))
+    ;;
+
+    let find_and_call2 = find_and_call2
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t * int * string [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key, a, b) ->
+          let t, map = reify constructors in
+          [%test_result:
+            [ `Found of Data.t * int * string | `Not_found of Key.t * int * string ]]
+            (find_and_call2
+               t
+               key
+               ~compare
+               ~a
+               ~b
+               ~if_found:(fun data a b -> `Found (data, a, b))
+               ~if_not_found:(fun key a b -> `Not_found (key, a, b)))
+            ~expect:
+              (match Map.find map key with
+               | None -> `Not_found (key, a, b)
+               | Some data -> `Found (data, a, b)))
+    ;;
+
+    let findi_and_call2 = findi_and_call2
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module struct
+          type t = Constructors.t * Key.t * int * string [@@deriving quickcheck, sexp_of]
+        end)
+        ~f:(fun (constructors, key, a, b) ->
+          let t, map = reify constructors in
+          [%test_result:
+            [ `Found of Key.t * Data.t * int * string
+            | `Not_found of Key.t * int * string
+            ]]
+            (findi_and_call2
+               t
+               key
+               ~compare
+               ~a
+               ~b
+               ~if_found:(fun ~key ~data a b -> `Found (key, data, a, b))
+               ~if_not_found:(fun key a b -> `Not_found (key, a, b)))
+            ~expect:
+              (match Map.find map key with
+               | None -> `Not_found (key, a, b)
+               | Some data -> `Found (key, data, a, b)))
+    ;;
+
+    let iter = iter
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: (Key.t * Data.t) list]
+            (let q = Queue.create () in
+             iter t ~f:(fun ~key ~data -> Queue.enqueue q (key, data));
+             Queue.to_list q)
+            ~expect:(Map.to_alist map))
+    ;;
+
+    let mapi_inplace = mapi_inplace
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: (Key.t * Data.t) list]
+            (mapi_inplace t ~f:(fun ~key:_ ~data -> data ^ data);
+             fold t ~init:[] ~f:(fun ~key ~data acc -> (key, data) :: acc))
+            ~expect:(Map.map map ~f:(fun data -> data ^ data) |> Map.to_alist |> List.rev))
+    ;;
+
+    let fold = fold
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: (Key.t * Data.t) list]
+            (fold t ~init:[] ~f:(fun ~key ~data acc -> (key, data) :: acc))
+            ~expect:(Map.to_alist map |> List.rev))
+    ;;
+
+    let choose_exn = choose_exn
+
+    let%test_unit _ =
+      Base_quickcheck.Test.run_exn
+        (module Constructors)
+        ~f:(fun constructors ->
+          let t, map = reify constructors in
+          [%test_result: bool]
+            (is_some (Option.try_with (fun () -> choose_exn t)))
+            ~expect:(not (Map.is_empty map)))
+    ;;
+  end :
+    module type of Avltree))
 ;;
diff --git a/test/coverage/helpers/adjustable.ml b/test/coverage/helpers/adjustable.ml
new file mode 100644
index 00000000..0470504c
--- /dev/null
+++ b/test/coverage/helpers/adjustable.ml
@@ -0,0 +1,21 @@
+open! Base
+include Adjustable_intf.Definitions
+
+(* The following functions that generate unique values don't need to worry about integer
+   overflow because we generate integers with [Generator.small_positive_or_zero_int]. *)
+
+let rec unique_int n list =
+  if List.mem list n ~equal:( = ) then unique_int (n + 1) list else n
+;;
+
+let non_overlapping_ints list =
+  List.fold list ~init:[] ~f:(fun list n -> unique_int n list :: list) |> List.rev
+;;
+
+let unique (type a) (module A : S with type t = a) a list =
+  A.set a (unique_int (A.get a) (List.map ~f:A.get list))
+;;
+
+let non_overlapping (type a) (module A : S with type t = a) list =
+  List.map2_exn ~f:A.set list (non_overlapping_ints (List.map ~f:A.get list))
+;;
diff --git a/test/coverage/helpers/adjustable.mli b/test/coverage/helpers/adjustable.mli
new file mode 100644
index 00000000..e3d874ad
--- /dev/null
+++ b/test/coverage/helpers/adjustable.mli
@@ -0,0 +1 @@
+include Adjustable_intf.Adjustable
diff --git a/test/coverage/helpers/adjustable_intf.ml b/test/coverage/helpers/adjustable_intf.ml
new file mode 100644
index 00000000..2f3dfec6
--- /dev/null
+++ b/test/coverage/helpers/adjustable_intf.ml
@@ -0,0 +1,19 @@
+open! Base
+
+module Definitions = struct
+  module type S = sig
+    type t
+
+    val get : t -> int
+    val set : t -> int -> t
+  end
+end
+
+module type Adjustable = sig
+  include module type of struct
+    include Definitions
+  end
+
+  val unique : (module S with type t = 'a) -> 'a -> 'a list -> 'a
+  val non_overlapping : (module S with type t = 'a) -> 'a list -> 'a list
+end
diff --git a/test/coverage/helpers/base_test_coverage_helpers.ml b/test/coverage/helpers/base_test_coverage_helpers.ml
new file mode 100644
index 00000000..192a2213
--- /dev/null
+++ b/test/coverage/helpers/base_test_coverage_helpers.ml
@@ -0,0 +1,6 @@
+module Adjustable = Adjustable
+module Data = Data
+module Func = Func
+module Memo = Memo
+module Overrides = Overrides
+module Stats = Stats
diff --git a/test/coverage/helpers/data.ml b/test/coverage/helpers/data.ml
new file mode 100644
index 00000000..810bb338
--- /dev/null
+++ b/test/coverage/helpers/data.ml
@@ -0,0 +1,37 @@
+open! Base
+open Base_quickcheck
+open Overrides
+include Data_intf.Definitions
+
+module Int : S with type t = int = struct
+  type t = int [@@deriving compare, equal, quickcheck, sexp_of]
+
+  let to_int = Fn.id
+  let of_int = Fn.id
+  let combine_non_commutative a b = (a * 10) + b
+end
+
+module List (T : With_equal) = struct
+  type t = T.t list [@@deriving equal, sexp_of]
+end
+
+module Or_error (T : With_equal) = struct
+  type t = (T.t, (Error.t[@equal.ignore])) Result.t [@@deriving equal, sexp_of]
+end
+
+module Option (T : With_equal) = struct
+  type t = T.t option [@@deriving equal, sexp_of]
+end
+
+module Pair (T : With_quickcheck) = struct
+  type t = T.t * T.t [@@deriving equal, quickcheck, sexp_of]
+
+  let quickcheck_generator =
+    let open Base_quickcheck.Generator.Let_syntax in
+    match%bind Base_quickcheck.Generator.bool with
+    | true -> [%generator: t]
+    | false ->
+      let%map x = [%generator: T.t] in
+      x, x
+  ;;
+end
diff --git a/test/coverage/helpers/data.mli b/test/coverage/helpers/data.mli
new file mode 100644
index 00000000..04f7c0d4
--- /dev/null
+++ b/test/coverage/helpers/data.mli
@@ -0,0 +1 @@
+include Data_intf.Data
diff --git a/test/coverage/helpers/data_intf.ml b/test/coverage/helpers/data_intf.ml
new file mode 100644
index 00000000..aeafc729
--- /dev/null
+++ b/test/coverage/helpers/data_intf.ml
@@ -0,0 +1,39 @@
+open! Base
+
+module Definitions = struct
+  module type S = sig
+    type t [@@deriving compare, equal, quickcheck, sexp_of]
+
+    val to_int : t -> int
+    val of_int : int -> t
+    val combine_non_commutative : t -> t -> t
+  end
+
+  module type With_equal = sig
+    type t [@@deriving equal, sexp_of]
+  end
+
+  module type With_quickcheck = sig
+    type t [@@deriving equal, quickcheck, sexp_of]
+  end
+end
+
+module type Data = sig
+  include module type of struct
+    include Definitions
+  end
+
+  module Int : S with type t = int
+
+  (** Functor for [List] *)
+  module List (T : With_equal) : With_equal with type t = T.t list
+
+  (** Functor for [Or_error], ignoring error contents when comparing. *)
+  module Or_error (T : With_equal) : With_equal with type t = T.t Or_error.t
+
+  (** Functor for [Option] *)
+  module Option (T : With_equal) : With_equal with type t = T.t option
+
+  (** Functor for pairs of the same data, with quickcheck generation. *)
+  module Pair (T : With_quickcheck) : With_quickcheck with type t = T.t * T.t
+end
diff --git a/test/coverage/helpers/dune b/test/coverage/helpers/dune
new file mode 100644
index 00000000..2e979cbf
--- /dev/null
+++ b/test/coverage/helpers/dune
@@ -0,0 +1,5 @@
+(library
+ (name base_test_coverage_helpers)
+ (libraries base expect_test_helpers_core.expect_test_helpers_base stdio)
+ (preprocess
+  (pps ppx_jane)))
diff --git a/test/coverage/helpers/func.ml b/test/coverage/helpers/func.ml
new file mode 100644
index 00000000..1358afa0
--- /dev/null
+++ b/test/coverage/helpers/func.ml
@@ -0,0 +1,124 @@
+open! Base
+open Base_quickcheck
+open Overrides
+include Func_intf.Definitions
+
+(* Randomly generated functions with sexpable representations. Represented as an initial
+   output value and a set of transitions to new outputs at intervals along the inputs. The
+   transitions need not be sorted; the [apply] functions find the closest applicable
+   input. *)
+type ('input, 'output) t =
+  { initial : 'output
+  ; transitions : ('input * 'output) list
+  }
+[@@deriving equal, quickcheck, sexp_of]
+
+let inputs t = List.map t.transitions ~f:fst
+let outputs t = t.initial :: List.map t.transitions ~f:snd
+
+let map { initial; transitions } ~i ~o =
+  { initial = o initial
+  ; transitions = List.map transitions ~f:(fun (input, output) -> i input, o output)
+  }
+;;
+
+let apply (type a) t (module Input : With_compare with type t = a) x =
+  List.fold
+    ~init:(None, t.initial)
+    t.transitions
+    ~f:(fun (prev_input, prev_output) (input, output) ->
+      if Input.compare x input < 0
+      then prev_input, prev_output
+      else (
+        match prev_input with
+        | None -> Some input, output
+        | Some prev_input ->
+          if Input.compare prev_input input < 0
+          then Some input, output
+          else Some prev_input, prev_output))
+  |> snd
+;;
+
+let apply2 t m1 m2 x1 x2 =
+  let t = apply t m1 x1 in
+  apply t m2 x2
+;;
+
+let apply3 t m1 m2 m3 x1 x2 x3 =
+  let t = apply t m1 x1 in
+  let t = apply t m2 x2 in
+  apply t m3 x3
+;;
+
+(* Associate each (input,output) pair in [transitions] with the subset of [inputs] that
+   would be assigned that output. Also return unmatched values that would get the
+   [initial] output. *)
+let associate
+  (type a)
+  (module Input : With_compare with type t = a)
+  ~sorted_transitions:transitions
+  ~sorted_inputs:inputs
+  =
+  let rev_inputs, transitions =
+    List.fold_right
+      transitions
+      ~init:(List.rev inputs, [])
+      ~f:(fun (input, output) (inputs, transitions) ->
+        let matching, non_matching =
+          List.split_while inputs ~f:(fun i -> Input.compare i input >= 0)
+        in
+        non_matching, ((input, output), List.rev matching) :: transitions)
+  in
+  List.rev rev_inputs, transitions
+;;
+
+(* Assign every input a separate transition that will apply to only it. *)
+let split_transitions_by_input transitions =
+  List.concat_map transitions ~f:(fun ((maybe_input, output), inputs) ->
+    match inputs with
+    | [] | [ _ ] -> [ maybe_input, output ]
+    | _ :: _ :: _ ->
+      List.mapi inputs ~f:(fun i input ->
+        if i = 0 then maybe_input, output else Some input, output))
+;;
+
+(* Produce a version of [t] where each of [inputs] is assigned a different output. *)
+let injective
+  (type a b)
+  { initial; transitions }
+  (module Input : With_compare with type t = a)
+  (module Output : Adjustable.S with type t = b)
+  inputs
+  =
+  let inputs = List.dedup_and_sort inputs ~compare:Input.compare in
+  let transitions =
+    List.stable_sort transitions ~compare:(Comparable.lift Input.compare ~f:fst)
+  in
+  let transitions =
+    let inputs, transitions =
+      associate (module Input) ~sorted_transitions:transitions ~sorted_inputs:inputs
+    in
+    ((None, initial), inputs)
+    :: List.map transitions ~f:(fun ((input, output), inputs) ->
+      (Some input, output), inputs)
+  in
+  let transitions = split_transitions_by_input transitions in
+  let transitions =
+    Adjustable.non_overlapping
+      (module struct
+        type t = Input.t option * Output.t
+
+        let get (_, output) = Output.get output
+        let set (input, output) n = input, Output.set output n
+      end)
+      transitions
+  in
+  let initials, transitions =
+    List.partition_map transitions ~f:(function
+      | None, output -> First output
+      | Some input, output -> Second (input, output))
+  in
+  match initials with
+  | [] | _ :: _ :: _ -> assert false
+  | [ initial ] -> { initial; transitions }
+;;
diff --git a/test/coverage/helpers/func.mli b/test/coverage/helpers/func.mli
new file mode 100644
index 00000000..8587e078
--- /dev/null
+++ b/test/coverage/helpers/func.mli
@@ -0,0 +1 @@
+include Func_intf.Func
diff --git a/test/coverage/helpers/func_intf.ml b/test/coverage/helpers/func_intf.ml
new file mode 100644
index 00000000..caae5ee5
--- /dev/null
+++ b/test/coverage/helpers/func_intf.ml
@@ -0,0 +1,59 @@
+open! Base
+
+module Definitions = struct
+  module type With_compare = sig
+    type t [@@deriving compare, equal]
+  end
+end
+
+module type Func = sig
+  include module type of struct
+    include Definitions
+  end
+
+  type ('input, 'output) t =
+    { initial : 'output
+    ; transitions : ('input * 'output) list
+    }
+  [@@deriving equal, quickcheck, sexp_of]
+
+  val inputs : ('input, 'output) t -> 'input list
+  val outputs : ('input, 'output) t -> 'output list
+
+  val map
+    :  ('input1, 'output1) t
+    -> i:('input1 -> 'input2)
+    -> o:('output1 -> 'output2)
+    -> ('input2, 'output2) t
+
+  val apply
+    :  ('input, 'output) t
+    -> (module With_compare with type t = 'input)
+    -> 'input
+    -> 'output
+
+  val apply2
+    :  ('a, ('b, 'c) t) t
+    -> (module With_compare with type t = 'a)
+    -> (module With_compare with type t = 'b)
+    -> 'a
+    -> 'b
+    -> 'c
+
+  val apply3
+    :  ('a, ('b, ('c, 'd) t) t) t
+    -> (module With_compare with type t = 'a)
+    -> (module With_compare with type t = 'b)
+    -> (module With_compare with type t = 'c)
+    -> 'a
+    -> 'b
+    -> 'c
+    -> 'd
+
+  val injective
+    :  ('a, 'b) t
+    -> (module With_compare with type t = 'a)
+    -> (module Adjustable.S with type t = 'b)
+    -> 'a list
+    -> ('a, 'b) t
+end
diff --git a/test/coverage/helpers/memo.ml b/test/coverage/helpers/memo.ml
new file mode 100644
index 00000000..923e0eac
--- /dev/null
+++ b/test/coverage/helpers/memo.ml
@@ -0,0 +1,32 @@
+open! Base
+open Base_quickcheck
+open Expect_test_helpers_base
+include Memo_intf.Definitions
+
+let memoize generator =
+  Lazy.from_fun (fun () ->
+    let queue = Queue.create () in
+    Test.with_sample_exn generator ~f:(fun sequence ->
+      Sequence.iter sequence ~f:(Queue.enqueue queue));
+    Queue.to_list queue)
+;;
+
+let quickcheck_m
+  (type a)
+  ?(here = Stdlib.Lexing.dummy_pos)
+  ?cr
+  (module M : Memoized with type t = a)
+  ~f
+  =
+  quickcheck_m
+    ~here
+    ?cr
+    (module struct
+      type t = M.t [@@deriving quickcheck ~shrinker, sexp_of]
+
+      let quickcheck_generator = Generator.create (fun ~size:_ ~random:_ -> assert false)
+    end)
+    ~examples:(Lazy.force M.sample)
+    ~config:{ Test.default_config with test_count = 0 }
+    ~f
+;;
diff --git a/test/coverage/helpers/memo.mli b/test/coverage/helpers/memo.mli
new file mode 100644
index 00000000..0fd9346a
--- /dev/null
+++ b/test/coverage/helpers/memo.mli
@@ -0,0 +1 @@
+include Memo_intf.Memo
diff --git a/test/coverage/helpers/memo_intf.ml b/test/coverage/helpers/memo_intf.ml
new file mode 100644
index 00000000..b5ddb221
--- /dev/null
+++ b/test/coverage/helpers/memo_intf.ml
@@ -0,0 +1,30 @@
+open! Base
+open Base_quickcheck
+open Expect_test_helpers_base
+
+module Definitions = struct
+  module type Memoized = sig
+    type t [@@deriving quickcheck ~shrinker, sexp_of]
+
+    val sample : t list Lazy.t
+  end
+
+  module type Unmemoized = sig
+    type t [@@deriving quickcheck ~generator ~shrinker, sexp_of]
+  end
+end
+
+module type Memo = sig
+  include module type of struct
+    include Definitions
+  end
+
+  val memoize : 'a Generator.t -> 'a list Lazy.t
+
+  val quickcheck_m
+    :  ?here:Stdlib.Lexing.position
+    -> ?cr:CR.t
+    -> (module Memoized with type t = 'a)
+    -> f:('a -> unit)
+    -> unit
+end
diff --git a/test/coverage/helpers/overrides.ml b/test/coverage/helpers/overrides.ml
new file mode 100644
index 00000000..b127b4b9
--- /dev/null
+++ b/test/coverage/helpers/overrides.ml
@@ -0,0 +1,37 @@
+open! Base
+open Base_quickcheck
+
+let quickcheck_generator_int = Generator.small_strictly_positive_int
+
+(* We change the generator for lists to get larger lists. Instead of splitting the size
+     budget between the list's lengths and its element sizes, we generate those two
+     separately within the full size budget. *)
+let quickcheck_generator_list g =
+  Generator.small_positive_or_zero_int
+  |> Generator.bind ~f:(fun length -> Generator.list_with_length g ~length)
+;;
+
+module Either = struct
+  include Either
+
+  let quickcheck_generator = Generator.either
+  let quickcheck_observer = Observer.either
+  let quickcheck_shrinker = Shrinker.either
+end
+
+module Maybe_bound = struct
+  include Maybe_bound
+
+  type 'a t = 'a Maybe_bound.t =
+    | Incl of 'a
+    | Excl of 'a
+    | Unbounded
+  [@@deriving equal, quickcheck]
+
+  let to_list = function
+    | Incl x | Excl x -> [ x ]
+    | Unbounded -> []
+  ;;
+end
+
+let quickcheck_m = Memo.quickcheck_m
diff --git a/test/coverage/helpers/overrides.mli b/test/coverage/helpers/overrides.mli
new file mode 100644
index 00000000..55c033bc
--- /dev/null
+++ b/test/coverage/helpers/overrides.mli
@@ -0,0 +1,32 @@
+open! Base
+open Base_quickcheck
+open Expect_test_helpers_base
+open Memo_intf.Definitions
+
+module Either : sig
+  include module type of struct
+    include Base.Either
+  end
+
+  type ('a, 'b) t = ('a, 'b) Either.t [@@deriving quickcheck]
+end
+
+module Maybe_bound : sig
+  include module type of struct
+    include Base.Maybe_bound
+  end
+
+  type 'a t = 'a Maybe_bound.t [@@deriving equal, quickcheck]
+
+  val to_list : 'a t -> 'a list
+end
+
+val quickcheck_generator_int : int Generator.t
+val quickcheck_generator_list : 'a Generator.t -> 'a list Generator.t
+
+val quickcheck_m
+  :  ?here:Stdlib.Lexing.position
+  -> ?cr:CR.t
+  -> (module Memoized with type t = 'a)
+  -> f:('a -> unit)
+  -> unit
diff --git a/test/coverage/helpers/stats.ml b/test/coverage/helpers/stats.ml
new file mode 100644
index 00000000..601e94e3
--- /dev/null
+++ b/test/coverage/helpers/stats.ml
@@ -0,0 +1,45 @@
+open! Base
+
+type t = { sizes : int Queue.t } [@@unboxed]
+
+let create () = { sizes = Queue.create () }
+let add t size = Queue.enqueue t.sizes size
+let percentiles = [ 0; 50; 75; 90; 95; 99; 100 ]
+
+type row =
+  { percentile : int
+  ; size : int
+  ; count : int
+  }
+
+let print t =
+  let zeros, sizes = Queue.to_array t.sizes |> Array.partition_tf ~f:(( = ) 0) in
+  Array.sort sizes ~compare:Int.compare;
+  let rows =
+    if Array.is_empty sizes
+    then []
+    else
+      List.map percentiles ~f:(fun percentile ->
+        let len = Array.length sizes in
+        let size = len * percentile / 100 |> Int.min (len - 1) |> Array.get sizes in
+        let count =
+          match
+            Array.binary_search sizes ~compare `First_greater_than_or_equal_to size
+          with
+          | None -> 0
+          | Some index -> Array.length sizes - index
+        in
+        { percentile; size; count })
+      |> List.remove_consecutive_duplicates
+           ~equal:(Comparable.lift Int.equal ~f:(fun row -> row.size))
+           ~which_to_keep:`Last
+  in
+  Stdio.printf "  %% | size | count\n";
+  Stdio.printf "----+------+------\n";
+  if not (Array.is_empty zeros)
+  then Stdio.printf "  - |    0 | %5d\n" (Array.length zeros);
+  if not (Array.is_empty zeros || Array.is_empty sizes)
+  then Stdio.printf "----+------+------\n";
+  List.iter rows ~f:(fun { percentile; size; count } ->
+    Stdio.printf "%3d | %4d | %5d\n" percentile size count)
+;;
diff --git a/test/coverage/helpers/stats.mli b/test/coverage/helpers/stats.mli
new file mode 100644
index 00000000..01d47cb2
--- /dev/null
+++ b/test/coverage/helpers/stats.mli
@@ -0,0 +1,14 @@
+(** An inefficient, dead-simple implementation of percentile statistics. **)
+
+open! Base
+
+type t
+
+(** Create an empty [t]. *)
+val create : unit -> t
+
+(** Add a measurement. *)
+val add : t -> int -> unit
+
+(** Print out percentiles from [t]. *)
+val print : t -> unit
diff --git a/test/map_full_interface/base_test_map_full_interface.ml b/test/coverage/map/base_test_coverage_map.ml
similarity index 100%
rename from test/map_full_interface/base_test_map_full_interface.ml
rename to test/coverage/map/base_test_coverage_map.ml
diff --git a/test/coverage/map/constructor.ml b/test/coverage/map/constructor.ml
new file mode 100644
index 00000000..85cbed5b
--- /dev/null
+++ b/test/coverage/map/constructor.ml
@@ -0,0 +1,1959 @@
+open! Base
+open Base_quickcheck
+open Expect_test_helpers_base
+open Base_test_coverage_helpers
+open Functor_intf.Definitions
+open Overrides
+
+let sort_either_direction list ~compare =
+  match list with
+  | [] | [ _ ] -> list
+  | a :: b :: _ ->
+    if compare a b > 0
+    then List.sort list ~compare:(Comparable.reverse compare)
+    else List.sort list ~compare
+;;
+
+module Side = struct
+  type t =
+    | Left
+    | Right
+  [@@deriving equal, quickcheck, sexp_of]
+
+  let select t (a, b) =
+    match t with
+    | Left -> a
+    | Right -> b
+  ;;
+
+  let select3 t (a, _, b) =
+    match t with
+    | Left -> a
+    | Right -> b
+  ;;
+end
+
+module Constructor = struct
+  let rec_weight = 4.
+
+  type ('key, 'data) t =
+    | Empty
+    | Singleton of 'key * 'data
+    | Map_keys of ('key, 'key) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Map_keys_exn of ('key, 'key) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Of_sorted_array of ('key * 'data) list
+    | Of_sorted_array_unchecked of ('key * 'data) list
+    | Of_increasing_iterator_unchecked of ('key * 'data) list
+    | Of_increasing_sequence of ('key * 'data) list
+    | Of_alist of ('key * 'data) list
+    | Of_alist_or_error of ('key * 'data) list
+    | Of_alist_exn of ('key * 'data) list
+    | Of_alist_fold of 'data * ('data, ('data, 'data) Func.t) Func.t * ('key * 'data) list
+    | Of_alist_reduce of ('data, ('data, 'data) Func.t) Func.t * ('key * 'data) list
+    | Of_sequence of ('key * 'data) list
+    | Of_sequence_or_error of ('key * 'data) list
+    | Of_sequence_exn of ('key * 'data) list
+    | Of_sequence_fold of
+        'data * ('data, ('data, 'data) Func.t) Func.t * ('key * 'data) list
+    | Of_sequence_reduce of ('data, ('data, 'data) Func.t) Func.t * ('key * 'data) list
+    | Of_list_with_key of ('data, 'key) Func.t * 'data list
+    | Of_list_with_key_or_error of ('data, 'key) Func.t * 'data list
+    | Of_list_with_key_exn of ('data, 'key) Func.t * 'data list
+    | Of_list_with_key_fold of
+        'data * ('data, ('data, 'data) Func.t) Func.t * ('data, 'key) Func.t * 'data list
+    | Of_list_with_key_reduce of
+        ('data, ('data, 'data) Func.t) Func.t * ('data, 'key) Func.t * 'data list
+    | Of_iteri of ('key * 'data) list
+    | Of_iteri_exn of ('key * 'data) list
+    | Add of 'key * 'data * ('key, 'data) t [@weight rec_weight]
+    | Add_exn of 'key * 'data * ('key, 'data) t [@weight rec_weight]
+    | Set of 'key * 'data * ('key, 'data) t [@weight rec_weight]
+    | Change of 'key * ('data option, 'data option) Func.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Update of 'key * ('data option, 'data) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Remove of 'key * ('key, 'data) t [@weight rec_weight]
+    | Map of ('data, 'data) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Mapi of ('key, ('data, 'data) Func.t) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Filter_keys of ('key, bool) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Filter of ('data, bool) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Filteri of ('key, ('data, bool) Func.t) Func.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Filter_map of ('data, 'data option) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Filter_mapi of ('key, ('data, 'data option) Func.t) Func.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Partition_tf of Side.t * ('data, bool) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Partitioni_tf of Side.t * ('key, ('data, bool) Func.t) Func.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Partition_map of Side.t * ('data, ('data, 'data) Either.t) Func.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Partition_mapi of
+        Side.t * ('key, ('data, ('data, 'data) Either.t) Func.t) Func.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Merge of
+        ('key, ('data, 'data option) Func.t) Func.t
+        * ('key, ('data, 'data option) Func.t) Func.t
+        * ('key, ('data, ('data, 'data option) Func.t) Func.t) Func.t
+        * ('key, 'data) t
+        * ('key, 'data) t [@weight rec_weight]
+    | Merge_skewed of
+        ('key, ('data, ('data, 'data) Func.t) Func.t) Func.t
+        * ('key, 'data) t
+        * ('key, 'data) t [@weight rec_weight]
+    | Merge_disjoint_exn of ('key, 'data) t * ('key, 'data) t [@weight rec_weight]
+    | Split of Side.t * 'key * ('key, 'data) t [@weight rec_weight]
+    | Split_le_gt of Side.t * 'key * ('key, 'data) t [@weight rec_weight]
+    | Split_lt_ge of Side.t * 'key * ('key, 'data) t [@weight rec_weight]
+    | Append of ('key, 'data) t * ('key, 'data) t [@weight rec_weight]
+    | Subrange of 'key Maybe_bound.t * 'key Maybe_bound.t * ('key, 'data) t
+    [@weight rec_weight]
+    | Make_applicative_traversals__mapi of
+        ('key, ('data, 'data) Func.t) Func.t * ('key, 'data) t [@weight rec_weight]
+    | Make_applicative_traversals__filter_mapi of
+        ('key, ('data, 'data option) Func.t) Func.t * ('key, 'data) t [@weight rec_weight]
+  [@@deriving equal, quickcheck ~generator ~observer, sexp_of]
+
+  let nested = function
+    | Empty -> []
+    | Singleton (_, _) -> []
+    | Map_keys (_, t) -> [ t ]
+    | Map_keys_exn (_, t) -> [ t ]
+    | Of_sorted_array _ -> []
+    | Of_sorted_array_unchecked _ -> []
+    | Of_increasing_iterator_unchecked _ -> []
+    | Of_increasing_sequence _ -> []
+    | Of_alist _ -> []
+    | Of_alist_or_error _ -> []
+    | Of_alist_exn _ -> []
+    | Of_alist_fold (_, _, _) -> []
+    | Of_alist_reduce (_, _) -> []
+    | Of_sequence _ -> []
+    | Of_sequence_or_error _ -> []
+    | Of_sequence_exn _ -> []
+    | Of_sequence_fold (_, _, _) -> []
+    | Of_sequence_reduce (_, _) -> []
+    | Of_list_with_key (_, _) -> []
+    | Of_list_with_key_or_error (_, _) -> []
+    | Of_list_with_key_exn (_, _) -> []
+    | Of_list_with_key_fold (_, _, _, _) -> []
+    | Of_list_with_key_reduce (_, _, _) -> []
+    | Of_iteri _ -> []
+    | Of_iteri_exn _ -> []
+    | Add (_, _, t) -> [ t ]
+    | Add_exn (_, _, t) -> [ t ]
+    | Set (_, _, t) -> [ t ]
+    | Change (_, _, t) -> [ t ]
+    | Update (_, _, t) -> [ t ]
+    | Remove (_, t) -> [ t ]
+    | Map (_, t) -> [ t ]
+    | Mapi (_, t) -> [ t ]
+    | Filter_keys (_, t) -> [ t ]
+    | Filter (_, t) -> [ t ]
+    | Filteri (_, t) -> [ t ]
+    | Filter_map (_, t) -> [ t ]
+    | Filter_mapi (_, t) -> [ t ]
+    | Partition_tf (_, _, t) -> [ t ]
+    | Partitioni_tf (_, _, t) -> [ t ]
+    | Partition_map (_, _, t) -> [ t ]
+    | Partition_mapi (_, _, t) -> [ t ]
+    | Merge (_, _, _, a, b) -> [ a; b ]
+    | Merge_skewed (_, a, b) -> [ a; b ]
+    | Merge_disjoint_exn (a, b) -> [ a; b ]
+    | Split (_, _, t) -> [ t ]
+    | Split_le_gt (_, _, t) -> [ t ]
+    | Split_lt_ge (_, _, t) -> [ t ]
+    | Append (a, b) -> [ a; b ]
+    | Subrange (_, _, t) -> [ t ]
+    | Make_applicative_traversals__mapi (_, t) -> [ t ]
+    | Make_applicative_traversals__filter_mapi (_, t) -> [ t ]
+  ;;
+
+  let rec number_of_constructors t =
+    1 + List.sum (module Int) (nested t) ~f:number_of_constructors
+  ;;
+
+  (* Simple shrinker to whittle away unnecessary enclosing constructors. *)
+  let quickcheck_shrinker (type key data) (_ : key Shrinker.t) (_ : data Shrinker.t)
+    : (key, data) t Shrinker.t
+    =
+    Shrinker.create (fun t -> Sequence.of_list (nested t))
+  ;;
+
+  let keys t ~compare =
+    let rec keys = function
+      | Empty -> []
+      | Singleton (key, _) -> [ key ]
+      | Map_keys (fn, t) -> Func.inputs fn @ Func.outputs fn @ keys t
+      | Map_keys_exn (fn, t) -> Func.inputs fn @ Func.outputs fn @ keys t
+      | Of_sorted_array alist -> List.map alist ~f:fst
+      | Of_sorted_array_unchecked alist -> List.map alist ~f:fst
+      | Of_increasing_iterator_unchecked alist -> List.map alist ~f:fst
+      | Of_increasing_sequence alist -> List.map alist ~f:fst
+      | Of_alist alist -> List.map alist ~f:fst
+      | Of_alist_or_error alist -> List.map alist ~f:fst
+      | Of_alist_exn alist -> List.map alist ~f:fst
+      | Of_alist_fold (_, _, alist) -> List.map alist ~f:fst
+      | Of_alist_reduce (_, alist) -> List.map alist ~f:fst
+      | Of_sequence alist -> List.map alist ~f:fst
+      | Of_sequence_or_error alist -> List.map alist ~f:fst
+      | Of_sequence_exn alist -> List.map alist ~f:fst
+      | Of_sequence_fold (_, _, alist) -> List.map alist ~f:fst
+      | Of_sequence_reduce (_, alist) -> List.map alist ~f:fst
+      | Of_list_with_key (get_key_fn, _) -> Func.outputs get_key_fn
+      | Of_list_with_key_or_error (get_key_fn, _) -> Func.outputs get_key_fn
+      | Of_list_with_key_exn (get_key_fn, _) -> Func.outputs get_key_fn
+      | Of_list_with_key_fold (_, _, get_key_fn, _) -> Func.outputs get_key_fn
+      | Of_list_with_key_reduce (_, get_key_fn, _) -> Func.outputs get_key_fn
+      | Of_iteri alist -> List.map alist ~f:fst
+      | Of_iteri_exn alist -> List.map alist ~f:fst
+      | Add (key, _, t) -> key :: keys t
+      | Add_exn (key, _, t) -> key :: keys t
+      | Set (key, _, t) -> key :: keys t
+      | Change (key, _, t) -> key :: keys t
+      | Update (key, _, t) -> key :: keys t
+      | Remove (key, t) -> key :: keys t
+      | Map (_, t) -> keys t
+      | Mapi (fn, t) -> Func.inputs fn @ keys t
+      | Filter_keys (fn, t) -> Func.inputs fn @ keys t
+      | Filter (_, t) -> keys t
+      | Filteri (fn, t) -> Func.inputs fn @ keys t
+      | Filter_map (_, t) -> keys t
+      | Filter_mapi (fn, t) -> Func.inputs fn @ keys t
+      | Partition_tf (_, _, t) -> keys t
+      | Partitioni_tf (_, fn, t) -> Func.inputs fn @ keys t
+      | Partition_map (_, _, t) -> keys t
+      | Partition_mapi (_, fn, t) -> Func.inputs fn @ keys t
+      | Merge (left_fn, right_fn, both_fn, a, b) ->
+        Func.inputs left_fn @ Func.inputs right_fn @ Func.inputs both_fn @ keys a @ keys b
+      | Merge_skewed (fn, a, b) -> Func.inputs fn @ keys a @ keys b
+      | Merge_disjoint_exn (a, b) -> keys a @ keys b
+      | Split (_, key, t) -> key :: keys t
+      | Split_le_gt (_, key, t) -> key :: keys t
+      | Split_lt_ge (_, key, t) -> key :: keys t
+      | Append (a, b) -> keys a @ keys b
+      | Subrange (lower_bound, upper_bound, t) ->
+        Maybe_bound.to_list lower_bound @ Maybe_bound.to_list upper_bound @ keys t
+      | Make_applicative_traversals__mapi (fn, t) -> Func.inputs fn @ keys t
+      | Make_applicative_traversals__filter_mapi (fn, t) -> Func.inputs fn @ keys t
+    in
+    List.dedup_and_sort ~compare (keys t)
+  ;;
+
+  let rec map
+    : type key1 key2 data1 data2.
+      (key1, data1) t -> k:(key1 -> key2) -> d:(data1 -> data2) -> (key2, data2) t
+    =
+    fun t ~k ~d ->
+    match t with
+    | Empty -> Empty
+    | Singleton (key, data) -> Singleton (k key, d data)
+    | Map_keys (fn, t) -> Map_keys (Func.map ~i:k ~o:k fn, map ~k ~d t)
+    | Map_keys_exn (fn, t) -> Map_keys_exn (Func.map ~i:k ~o:k fn, map ~k ~d t)
+    | Of_sorted_array alist ->
+      Of_sorted_array (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_sorted_array_unchecked alist ->
+      Of_sorted_array_unchecked (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_increasing_iterator_unchecked alist ->
+      Of_increasing_iterator_unchecked
+        (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_increasing_sequence alist ->
+      Of_increasing_sequence (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_alist alist -> Of_alist (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_alist_or_error alist ->
+      Of_alist_or_error (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_alist_exn alist ->
+      Of_alist_exn (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_alist_fold (init, fn, alist) ->
+      Of_alist_fold
+        ( d init
+        , Func.map ~i:d ~o:(Func.map ~i:d ~o:d) fn
+        , List.map ~f:(fun (key, data) -> k key, d data) alist )
+    | Of_alist_reduce (fn, alist) ->
+      Of_alist_reduce
+        ( Func.map ~i:d ~o:(Func.map ~i:d ~o:d) fn
+        , List.map ~f:(fun (key, data) -> k key, d data) alist )
+    | Of_sequence alist ->
+      Of_sequence (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_sequence_or_error alist ->
+      Of_sequence_or_error (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_sequence_exn alist ->
+      Of_sequence_exn (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_sequence_fold (init, fn, alist) ->
+      Of_sequence_fold
+        ( d init
+        , Func.map ~i:d ~o:(Func.map ~i:d ~o:d) fn
+        , List.map ~f:(fun (key, data) -> k key, d data) alist )
+    | Of_sequence_reduce (fn, alist) ->
+      Of_sequence_reduce
+        ( Func.map ~i:d ~o:(Func.map ~i:d ~o:d) fn
+        , List.map ~f:(fun (key, data) -> k key, d data) alist )
+    | Of_list_with_key (get_key_fn, list) ->
+      Of_list_with_key (Func.map ~i:d ~o:k get_key_fn, List.map ~f:d list)
+    | Of_list_with_key_or_error (get_key_fn, list) ->
+      Of_list_with_key_or_error (Func.map ~i:d ~o:k get_key_fn, List.map ~f:d list)
+    | Of_list_with_key_exn (get_key_fn, list) ->
+      Of_list_with_key_exn (Func.map ~i:d ~o:k get_key_fn, List.map ~f:d list)
+    | Of_list_with_key_fold (init, fn, get_key_fn, list) ->
+      Of_list_with_key_fold
+        ( d init
+        , Func.map ~i:d ~o:(Func.map ~i:d ~o:d) fn
+        , Func.map ~i:d ~o:k get_key_fn
+        , List.map ~f:d list )
+    | Of_list_with_key_reduce (fn, get_key_fn, list) ->
+      Of_list_with_key_reduce
+        ( Func.map ~i:d ~o:(Func.map ~i:d ~o:d) fn
+        , Func.map ~i:d ~o:k get_key_fn
+        , List.map ~f:d list )
+    | Of_iteri alist -> Of_iteri (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Of_iteri_exn alist ->
+      Of_iteri_exn (List.map ~f:(fun (key, data) -> k key, d data) alist)
+    | Add (key, data, t) -> Add (k key, d data, map ~k ~d t)
+    | Add_exn (key, data, t) -> Add_exn (k key, d data, map ~k ~d t)
+    | Set (key, data, t) -> Set (k key, d data, map ~k ~d t)
+    | Change (key, fn, t) ->
+      Change (k key, Func.map ~i:(Option.map ~f:d) ~o:(Option.map ~f:d) fn, map ~k ~d t)
+    | Update (key, fn, t) ->
+      Update (k key, Func.map ~i:(Option.map ~f:d) ~o:d fn, map ~k ~d t)
+    | Remove (key, t) -> Remove (k key, map ~k ~d t)
+    | Map (fn, t) -> Map (Func.map ~i:d ~o:d fn, map ~k ~d t)
+    | Mapi (fn, t) -> Mapi (Func.map ~i:k ~o:(Func.map ~i:d ~o:d) fn, map ~k ~d t)
+    | Filter_keys (fn, t) -> Filter_keys (Func.map ~i:k ~o:Fn.id fn, map ~k ~d t)
+    | Filter (fn, t) -> Filter (Func.map ~i:d ~o:Fn.id fn, map ~k ~d t)
+    | Filteri (fn, t) ->
+      Filteri (Func.map ~i:k ~o:(Func.map ~i:d ~o:Fn.id) fn, map ~k ~d t)
+    | Filter_map (fn, t) -> Filter_map (Func.map ~i:d ~o:(Option.map ~f:d) fn, map ~k ~d t)
+    | Filter_mapi (fn, t) ->
+      Filter_mapi (Func.map ~i:k ~o:(Func.map ~i:d ~o:(Option.map ~f:d)) fn, map ~k ~d t)
+    | Partition_tf (side, fn, t) ->
+      Partition_tf (side, Func.map ~i:d ~o:Fn.id fn, map ~k ~d t)
+    | Partitioni_tf (side, fn, t) ->
+      Partitioni_tf (side, Func.map ~i:k ~o:(Func.map ~i:d ~o:Fn.id) fn, map ~k ~d t)
+    | Partition_map (side, fn, t) ->
+      Partition_map
+        (side, Func.map ~i:d ~o:(Either.map ~first:d ~second:d) fn, map ~k ~d t)
+    | Partition_mapi (side, fn, t) ->
+      Partition_mapi
+        ( side
+        , Func.map ~i:k ~o:(Func.map ~i:d ~o:(Either.map ~first:d ~second:d)) fn
+        , map ~k ~d t )
+    | Merge (left_fn, right_fn, both_fn, a, b) ->
+      Merge
+        ( Func.map ~i:k ~o:(Func.map ~i:d ~o:(Option.map ~f:d)) left_fn
+        , Func.map ~i:k ~o:(Func.map ~i:d ~o:(Option.map ~f:d)) right_fn
+        , Func.map ~i:k ~o:(Func.map ~i:d ~o:(Func.map ~i:d ~o:(Option.map ~f:d))) both_fn
+        , map ~k ~d a
+        , map ~k ~d b )
+    | Merge_skewed (fn, a, b) ->
+      Merge_skewed
+        ( Func.map ~i:k ~o:(Func.map ~i:d ~o:(Func.map ~i:d ~o:d)) fn
+        , map ~k ~d a
+        , map ~k ~d b )
+    | Merge_disjoint_exn (a, b) -> Merge_disjoint_exn (map ~k ~d a, map ~k ~d b)
+    | Split (side, key, t) -> Split (side, k key, map ~k ~d t)
+    | Split_le_gt (side, key, t) -> Split_le_gt (side, k key, map ~k ~d t)
+    | Split_lt_ge (side, key, t) -> Split_lt_ge (side, k key, map ~k ~d t)
+    | Append (a, b) -> Append (map ~k ~d a, map ~k ~d b)
+    | Subrange (lower_bound, upper_bound, t) ->
+      Subrange
+        (Maybe_bound.map ~f:k lower_bound, Maybe_bound.map ~f:k upper_bound, map ~k ~d t)
+    | Make_applicative_traversals__mapi (fn, t) ->
+      Make_applicative_traversals__mapi
+        (Func.map ~i:k ~o:(Func.map ~i:d ~o:d) fn, map ~k ~d t)
+    | Make_applicative_traversals__filter_mapi (fn, t) ->
+      Make_applicative_traversals__filter_mapi
+        (Func.map ~i:k ~o:(Func.map ~i:d ~o:(Option.map ~f:d)) fn, map ~k ~d t)
+  ;;
+
+  module Make
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types)
+      (Data : Data.S) =
+  struct
+    module Key = struct
+      include Instance.Key
+
+      let get = to_int
+      let set _ n = of_int n
+    end
+
+    module Data = struct
+      include Data
+
+      let get = to_int
+      let set _ n = of_int n
+    end
+
+    let unique_key = Adjustable.unique (module Key)
+    let non_overlapping_data = Adjustable.non_overlapping (module Data)
+
+    let non_overlapping_alist =
+      Adjustable.non_overlapping
+        (module struct
+          type t = Key.t * Data.t
+
+          let get (key, _) = Key.to_int key
+          let set (_, data) n = Key.of_int n, data
+        end)
+    ;;
+
+    let keys t = keys t ~compare:Key.compare
+
+    (* [value (normalize t)] is guaranteed not to raise, at least for [t] from
+       [quickcheck_generator]. We rely on key values being small so we don't have to deal
+       with integer overflow. *)
+    let rec normalize = function
+      | Empty -> Empty
+      | Singleton (key, data) -> Singleton (key, data)
+      | Map_keys (fn, t) ->
+        let t = normalize t in
+        let fn = Func.injective fn (module Key) (module Key) (keys t) in
+        Map_keys (fn, t)
+      | Map_keys_exn (fn, t) ->
+        let t = normalize t in
+        let fn = Func.injective fn (module Key) (module Key) (keys t) in
+        Map_keys_exn (fn, t)
+      | Of_sorted_array alist ->
+        let alist =
+          non_overlapping_alist alist
+          |> sort_either_direction ~compare:[%compare: Key.t * _]
+        in
+        Of_sorted_array alist
+      | Of_sorted_array_unchecked alist ->
+        let alist =
+          non_overlapping_alist alist
+          |> sort_either_direction ~compare:[%compare: Key.t * _]
+        in
+        Of_sorted_array_unchecked alist
+      | Of_increasing_iterator_unchecked alist ->
+        let alist =
+          non_overlapping_alist alist |> List.sort ~compare:[%compare: Key.t * _]
+        in
+        Of_increasing_iterator_unchecked alist
+      | Of_increasing_sequence alist ->
+        let alist =
+          non_overlapping_alist alist |> List.sort ~compare:[%compare: Key.t * _]
+        in
+        Of_increasing_sequence alist
+      | Of_alist alist ->
+        let alist = non_overlapping_alist alist in
+        Of_alist alist
+      | Of_alist_or_error alist ->
+        let alist = non_overlapping_alist alist in
+        Of_alist_or_error alist
+      | Of_alist_exn alist ->
+        let alist = non_overlapping_alist alist in
+        Of_alist_exn alist
+      | Of_alist_fold (init, fn, alist) -> Of_alist_fold (init, fn, alist)
+      | Of_alist_reduce (fn, alist) -> Of_alist_reduce (fn, alist)
+      | Of_sequence alist ->
+        let alist = non_overlapping_alist alist in
+        Of_sequence alist
+      | Of_sequence_or_error alist ->
+        let alist = non_overlapping_alist alist in
+        Of_sequence_or_error alist
+      | Of_sequence_exn alist ->
+        let alist = non_overlapping_alist alist in
+        Of_sequence_exn alist
+      | Of_sequence_fold (init, fn, alist) -> Of_sequence_fold (init, fn, alist)
+      | Of_sequence_reduce (fn, alist) -> Of_sequence_reduce (fn, alist)
+      | Of_list_with_key (fn, list) ->
+        let list = non_overlapping_data list in
+        let fn = Func.injective fn (module Data) (module Key) list in
+        Of_list_with_key (fn, list)
+      | Of_list_with_key_or_error (fn, list) ->
+        let list = non_overlapping_data list in
+        let fn = Func.injective fn (module Data) (module Key) list in
+        Of_list_with_key_or_error (fn, list)
+      | Of_list_with_key_exn (fn, list) ->
+        let list = non_overlapping_data list in
+        let fn = Func.injective fn (module Data) (module Key) list in
+        Of_list_with_key_exn (fn, list)
+      | Of_list_with_key_fold (init, fn, get_key_fn, list) ->
+        Of_list_with_key_fold (init, fn, get_key_fn, list)
+      | Of_list_with_key_reduce (fn, get_key_fn, list) ->
+        Of_list_with_key_reduce (fn, get_key_fn, list)
+      | Of_iteri alist -> Of_iteri (non_overlapping_alist alist)
+      | Of_iteri_exn alist -> Of_iteri_exn (non_overlapping_alist alist)
+      | Add (key, data, t) ->
+        let t = normalize t in
+        let key = unique_key key (keys t) in
+        Add (key, data, t)
+      | Add_exn (key, data, t) ->
+        let t = normalize t in
+        let key = unique_key key (keys t) in
+        Add_exn (key, data, t)
+      | Set (key, data, t) -> Set (key, data, normalize t)
+      | Change (key, fn, t) -> Change (key, fn, normalize t)
+      | Update (key, fn, t) -> Update (key, fn, normalize t)
+      | Remove (key, t) -> Remove (key, normalize t)
+      | Map (fn, t) -> Map (fn, normalize t)
+      | Mapi (fn, t) -> Mapi (fn, normalize t)
+      | Filter_keys (fn, t) -> Filter_keys (fn, normalize t)
+      | Filter (fn, t) -> Filter (fn, normalize t)
+      | Filteri (fn, t) -> Filteri (fn, normalize t)
+      | Filter_map (fn, t) -> Filter_map (fn, normalize t)
+      | Filter_mapi (fn, t) -> Filter_mapi (fn, normalize t)
+      | Partition_tf (side, fn, t) -> Partition_tf (side, fn, normalize t)
+      | Partitioni_tf (side, fn, t) -> Partitioni_tf (side, fn, normalize t)
+      | Partition_map (side, fn, t) -> Partition_map (side, fn, normalize t)
+      | Partition_mapi (side, fn, t) -> Partition_mapi (side, fn, normalize t)
+      | Merge (left_fn, right_fn, both_fn, a, b) ->
+        Merge (left_fn, right_fn, both_fn, normalize a, normalize b)
+      | Merge_skewed (fn, a, b) -> Merge_skewed (fn, normalize a, normalize b)
+      | Merge_disjoint_exn (a, b) ->
+        let a = normalize a
+        and b = normalize b in
+        let rename_a, rename_b =
+          List.concat
+            [ List.map (keys a) ~f:(fun key -> Side.Left, (key, key))
+            ; List.map (keys b) ~f:(fun key -> Side.Right, (key, key))
+            ]
+          |> Adjustable.non_overlapping
+               (module struct
+                 type t = Side.t * (Key.t * Key.t)
+
+                 let get (_, (_, key)) = Key.to_int key
+                 let set (side, (key, _)) int = side, (key, Key.of_int int)
+               end)
+          |> List.partition_map ~f:(function
+            | Left, pair -> First pair
+            | Right, pair -> Second pair)
+        in
+        let a =
+          map a ~k:(fun k -> List.Assoc.find_exn rename_a k ~equal:Key.equal) ~d:Fn.id
+        and b =
+          map b ~k:(fun k -> List.Assoc.find_exn rename_b k ~equal:Key.equal) ~d:Fn.id
+        in
+        Merge_disjoint_exn (a, b)
+      | Split (side, key, t) -> Split (side, key, normalize t)
+      | Split_le_gt (side, key, t) -> Split_le_gt (side, key, normalize t)
+      | Split_lt_ge (side, key, t) -> Split_lt_ge (side, key, normalize t)
+      | Append (a, b) ->
+        let a = normalize a
+        and b = normalize b in
+        let b =
+          (* We rely on [Generator.small_positive_or_zero_int] so that we don't have to
+             worry about overflow here. *)
+          match
+            ( List.max_elt ~compare:Key.compare (keys a)
+            , List.min_elt ~compare:Key.compare (keys b) )
+          with
+          | Some x, Some y when Key.compare x y >= 0 ->
+            let k key = Key.of_int (Key.to_int key + 1 + Key.to_int x - Key.to_int y) in
+            map b ~k ~d:Fn.id
+          | _ -> b
+        in
+        Append (a, b)
+      | Subrange (lower_bound, upper_bound, t) ->
+        Subrange (lower_bound, upper_bound, normalize t)
+      | Make_applicative_traversals__mapi (fn, t) ->
+        Make_applicative_traversals__mapi (fn, normalize t)
+      | Make_applicative_traversals__filter_mapi (fn, t) ->
+        Make_applicative_traversals__filter_mapi (fn, normalize t)
+    ;;
+
+    let or_duplicate_key_exn = function
+      | `Ok x -> x
+      | `Duplicate_key key -> raise_s [%sexp `Duplicate_key (key : Key.t)]
+    ;;
+
+    let or_duplicate_exn = function
+      | `Ok x -> x
+      | `Duplicate -> raise_s [%sexp `Duplicate]
+    ;;
+
+    let or_overlapping_key_ranges_exn = function
+      | `Ok x -> x
+      | `Overlapping_key_ranges -> raise_s [%sexp `Overlapping_key_ranges]
+    ;;
+
+    module Data_option = struct
+      type t = Data.t option [@@deriving compare, equal]
+    end
+
+    module Traversals = Impl.Make_applicative_traversals (struct
+        type 'a t = 'a
+
+        let of_thunk f = f ()
+
+        include Applicative.Make (struct
+            type 'a t = 'a
+
+            let return x = x
+            let apply f x = f x
+            let map = `Define_using_apply
+          end)
+      end)
+
+    let rec value =
+      let open Instance in
+      function
+      | Empty -> create Impl.empty
+      | Singleton (key, data) -> (create Impl.singleton) key data
+      | Map_keys (fn, t) ->
+        (create Impl.map_keys) (value t) ~f:(Func.apply fn (module Key))
+        |> or_duplicate_key_exn
+      | Map_keys_exn (fn, t) ->
+        (create Impl.map_keys_exn) (value t) ~f:(Func.apply fn (module Key))
+      | Of_sorted_array alist ->
+        (create Impl.of_sorted_array) (Array.of_list alist) |> Or_error.ok_exn
+      | Of_sorted_array_unchecked alist ->
+        (create Impl.of_sorted_array_unchecked) (Array.of_list alist)
+      | Of_increasing_iterator_unchecked alist ->
+        let array = Array.of_list alist in
+        (create Impl.of_increasing_iterator_unchecked)
+          ~len:(Array.length array)
+          ~f:(Array.get array)
+      | Of_increasing_sequence alist ->
+        (create Impl.of_increasing_sequence) (Sequence.of_list alist) |> Or_error.ok_exn
+      | Of_alist alist -> (create Impl.of_alist) alist |> or_duplicate_key_exn
+      | Of_alist_or_error alist ->
+        (create Impl.of_alist_or_error) alist |> Or_error.ok_exn
+      | Of_alist_exn alist -> (create Impl.of_alist_exn) alist
+      | Of_alist_fold (init, fn, alist) ->
+        (create Impl.of_alist_fold)
+          alist
+          ~init
+          ~f:(Func.apply2 fn (module Data) (module Data))
+      | Of_alist_reduce (fn, alist) ->
+        (create Impl.of_alist_reduce)
+          alist
+          ~f:(Func.apply2 fn (module Data) (module Data))
+      | Of_sequence alist ->
+        (create Impl.of_sequence) (Sequence.of_list alist) |> or_duplicate_key_exn
+      | Of_sequence_or_error alist ->
+        (create Impl.of_sequence_or_error) (Sequence.of_list alist) |> Or_error.ok_exn
+      | Of_sequence_exn alist -> (create Impl.of_sequence_exn) (Sequence.of_list alist)
+      | Of_sequence_fold (init, fn, alist) ->
+        (create Impl.of_sequence_fold)
+          (Sequence.of_list alist)
+          ~init
+          ~f:(Func.apply2 fn (module Data) (module Data))
+      | Of_sequence_reduce (fn, alist) ->
+        (create Impl.of_sequence_reduce)
+          (Sequence.of_list alist)
+          ~f:(Func.apply2 fn (module Data) (module Data))
+      | Of_list_with_key (fn, alist) ->
+        (create Impl.of_list_with_key) alist ~get_key:(Func.apply fn (module Data))
+        |> or_duplicate_key_exn
+      | Of_list_with_key_or_error (fn, alist) ->
+        (create Impl.of_list_with_key_or_error)
+          alist
+          ~get_key:(Func.apply fn (module Data))
+        |> Or_error.ok_exn
+      | Of_list_with_key_exn (fn, alist) ->
+        (create Impl.of_list_with_key_exn) alist ~get_key:(Func.apply fn (module Data))
+      | Of_list_with_key_fold (init, fn, get_key_fn, alist) ->
+        (create Impl.of_list_with_key_fold)
+          alist
+          ~init
+          ~f:(Func.apply2 fn (module Data) (module Data))
+          ~get_key:(Func.apply get_key_fn (module Data))
+      | Of_list_with_key_reduce (fn, get_key_fn, alist) ->
+        (create Impl.of_list_with_key_reduce)
+          alist
+          ~f:(Func.apply2 fn (module Data) (module Data))
+          ~get_key:(Func.apply get_key_fn (module Data))
+      | Of_iteri alist ->
+        (create Impl.of_iteri) ~iteri:(fun ~f ->
+          List.iter alist ~f:(fun (key, data) -> f ~key ~data) [@nontail])
+        |> or_duplicate_key_exn
+      | Of_iteri_exn alist ->
+        (create Impl.of_iteri_exn) ~iteri:(fun ~f ->
+          List.iter alist ~f:(fun (key, data) -> f ~key ~data) [@nontail])
+      | Add (key, data, t) -> (access Impl.add) (value t) ~key ~data |> or_duplicate_exn
+      | Add_exn (key, data, t) -> (access Impl.add_exn) (value t) ~key ~data
+      | Set (key, data, t) -> (access Impl.set) (value t) ~key ~data
+      | Change (key, fn, t) ->
+        (access Impl.change) (value t) key ~f:(Func.apply fn (module Data_option))
+      | Update (key, fn, t) ->
+        (access Impl.update) (value t) key ~f:(Func.apply fn (module Data_option))
+      | Remove (key, t) -> (access Impl.remove) (value t) key
+      | Map (fn, t) -> Impl.map (value t) ~f:(Func.apply fn (module Data))
+      | Mapi (fn, t) ->
+        Impl.mapi (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+      | Filter_keys (fn, t) -> Impl.filter_keys (value t) ~f:(Func.apply fn (module Key))
+      | Filter (fn, t) -> Impl.filter (value t) ~f:(Func.apply fn (module Data))
+      | Filteri (fn, t) ->
+        Impl.filteri (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+      | Filter_map (fn, t) -> Impl.filter_map (value t) ~f:(Func.apply fn (module Data))
+      | Filter_mapi (fn, t) ->
+        Impl.filter_mapi (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+      | Partition_tf (side, fn, t) ->
+        Impl.partition_tf (value t) ~f:(Func.apply fn (module Data)) |> Side.select side
+      | Partitioni_tf (side, fn, t) ->
+        Impl.partitioni_tf (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+        |> Side.select side
+      | Partition_map (side, fn, t) ->
+        Impl.partition_map (value t) ~f:(Func.apply fn (module Data)) |> Side.select side
+      | Partition_mapi (side, fn, t) ->
+        Impl.partition_mapi (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+        |> Side.select side
+      | Merge (left_fn, right_fn, both_fn, a, b) ->
+        (access Impl.merge) (value a) (value b) ~f:(fun ~key -> function
+          | `Left data -> Func.apply2 left_fn (module Key) (module Data) key data
+          | `Right data -> Func.apply2 right_fn (module Key) (module Data) key data
+          | `Both (x, y) ->
+            Func.apply3 both_fn (module Key) (module Data) (module Data) key x y)
+      | Merge_skewed (fn, a, b) ->
+        (access Impl.merge_skewed) (value a) (value b) ~combine:(fun ~key x y ->
+          Func.apply3 fn (module Key) (module Data) (module Data) key x y)
+      | Merge_disjoint_exn (a, b) -> (access Impl.merge_disjoint_exn) (value a) (value b)
+      | Split (side, key, t) -> (access Impl.split) (value t) key |> Side.select3 side
+      | Split_le_gt (side, key, t) ->
+        (access Impl.split_le_gt) (value t) key |> Side.select side
+      | Split_lt_ge (side, key, t) ->
+        (access Impl.split_lt_ge) (value t) key |> Side.select side
+      | Append (a, b) ->
+        (access Impl.append) ~lower_part:(value a) ~upper_part:(value b)
+        |> or_overlapping_key_ranges_exn
+      | Subrange (lower_bound, upper_bound, t) ->
+        (access Impl.subrange) ~lower_bound ~upper_bound (value t)
+      | Make_applicative_traversals__mapi (fn, t) ->
+        Traversals.mapi (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+      | Make_applicative_traversals__filter_mapi (fn, t) ->
+        Traversals.filter_mapi (value t) ~f:(fun ~key ~data ->
+          Func.apply2 fn (module Key) (module Data) key data)
+    ;;
+
+    (* Report normalization failure using a small input if possible. *)
+    let rec shrink_and_raise ~src ~dst ~exn =
+      Shrinker.shrink [%shrinker: (_, _) t] src
+      |> Sequence.find_map ~f:(fun src ->
+        let dst = normalize src in
+        match value dst with
+        | _ -> None
+        | exception exn -> Some (src, dst, exn))
+      |> function
+      | Some (src, dst, exn) -> shrink_and_raise ~src ~dst ~exn
+      | None ->
+        raise_s
+          [%message
+            "normalization fails"
+              (src : (Key.t, Data.t) t)
+              (dst : (Key.t, Data.t) t)
+              (exn : exn)]
+    ;;
+
+    (* We test normalization when we apply it so we can get a good, early error message if
+       something goes wrong. *)
+    let normalize src =
+      let dst = normalize src in
+      match value dst with
+      | _ -> dst
+      | exception exn -> shrink_and_raise ~src ~dst ~exn
+    ;;
+  end
+end
+
+(* Cobble everything together and generate normalized constructor trees. *)
+module Make
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types)
+    (Data : Data.S) =
+struct
+  open Instance
+
+  type data = Data.t [@@deriving sexp_of]
+  type t = (Key.t, Data.t) Constructor.t [@@deriving equal, quickcheck, sexp_of]
+
+  include Constructor.Make (Instance) (Impl) (Data)
+
+  let quickcheck_generator = Generator.map quickcheck_generator ~f:normalize
+end
+
+(* Coverage testing so we know we haven't forgotten any constructor functions.
+
+   The number of quickcheck tests on 32-bit architectures is configured to be lower, so we
+   skip the coverage checks there. *)
+let%test_module (_ [@tags "64-bits-only"]) =
+  (module (
+  struct
+    module Types = struct
+      type 'key key = 'key
+      type 'cmp cmp = 'cmp
+      type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.t
+      type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
+
+      type ('key, 'cmp, 'fn) create_options =
+        ('key, 'cmp, 'fn) Map.With_first_class_module.t
+
+      type ('key, 'cmp, 'fn) access_options = ('key, 'cmp, 'fn) Map.Without_comparator.t
+    end
+
+    open struct
+      module Int_data = struct
+        include Int
+
+        type t = int [@@deriving quickcheck]
+
+        let combine_non_commutative a b = (10 * a) + b
+      end
+
+      module Instance = struct
+        module Types = Types
+        module Key = Int_data
+
+        type 'a t = (int, 'a, Int.comparator_witness) Map.t
+
+        let compare = Map.compare_direct
+        let equal = Map.equal
+        let sexp_of_t f t = Map.sexp_of_m__t (module Key) f t
+        let create f = f ((module Key) : (_, _) Comparator.Module.t)
+        let access f = f
+      end
+
+      module Cons = Make (Instance) (Map) (Int_data)
+
+      let sample = Memo.memoize Cons.quickcheck_generator
+
+      let%expect_test "normalization" =
+        quickcheck_m
+          (module struct
+            include Cons
+
+            let sample = sample
+          end)
+          ~f:(fun t ->
+            require_equal (module Cons) t (Cons.normalize t);
+            require_does_not_raise (fun () -> ignore (Cons.value t : int Map.M(Int).t)))
+      ;;
+
+      let%expect_test "number of constructors" =
+        let stats = Stats.create () in
+        List.iter (Lazy.force sample) ~f:(fun t ->
+          Stats.add stats (Constructor.number_of_constructors t));
+        Stats.print stats;
+        [%expect
+          {|
+            % | size | count
+          ----+------+------
+            0 |    1 | 10000
+           50 |    4 |  5747
+           75 |   11 |  2687
+           90 |   25 |  1057
+           95 |   40 |   523
+           99 |   77 |   101
+          100 |  293 |     1
+          |}]
+      ;;
+
+      let test predicate =
+        let stats = Stats.create () in
+        List.iter (force sample) ~f:(fun t ->
+          if predicate t
+          then (
+            let size = Map.length (Cons.value t) in
+            Stats.add stats size));
+        Stats.print stats
+      ;;
+    end
+
+    (* Accessors only, not covered. *)
+
+    include (Map : Accessors with module Types := Types)
+
+    (* Complicated types, not covered. *)
+
+    let transpose_keys = Map.transpose_keys
+    let of_tree = Map.of_tree
+    let combine_errors = Map.combine_errors
+    let unzip = Map.unzip
+    let of_alist_multi = Map.of_alist_multi
+    let of_sequence_multi = Map.of_sequence_multi
+    let of_list_with_key_multi = Map.of_list_with_key_multi
+    let add_multi = Map.add_multi
+    let remove_multi = Map.remove_multi
+
+    (* Tests *)
+
+    let empty = Map.empty
+
+    let%expect_test _ =
+      test (function
+        | Empty -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    86
+        |}]
+    ;;
+
+    let singleton = Map.singleton
+
+    let%expect_test _ =
+      test (function
+        | Singleton _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+        100 |    1 |    79
+        |}]
+    ;;
+
+    let map_keys = Map.map_keys
+
+    let%expect_test _ =
+      test (function
+        | Map_keys _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   117
+        ----+------+------
+          0 |    1 |   170
+         50 |    3 |    94
+         75 |    8 |    44
+         90 |   14 |    21
+         95 |   19 |    10
+         99 |   27 |     2
+        100 |   28 |     1
+        |}]
+    ;;
+
+    let map_keys_exn = Map.map_keys_exn
+
+    let%expect_test _ =
+      test (function
+        | Map_keys_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    91
+        ----+------+------
+          0 |    1 |   192
+         50 |    3 |   100
+         75 |    8 |    50
+         90 |   16 |    20
+         95 |   23 |    11
+         99 |   28 |     2
+        100 |   48 |     1
+        |}]
+    ;;
+
+    let of_sorted_array = Map.of_sorted_array
+
+    let%expect_test _ =
+      test (function
+        | Of_sorted_array _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    16
+        ----+------+------
+          0 |    1 |    56
+         50 |   11 |    28
+         75 |   21 |    15
+         90 |   25 |     8
+         95 |   28 |     3
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_sorted_array_unchecked = Map.of_sorted_array_unchecked
+
+    let%expect_test _ =
+      test (function
+        | Of_sorted_array_unchecked _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |     9
+        ----+------+------
+          0 |    1 |    74
+         50 |    8 |    41
+         75 |   18 |    20
+         90 |   25 |     9
+        100 |   28 |     4
+        |}]
+    ;;
+
+    let of_increasing_iterator_unchecked = Map.of_increasing_iterator_unchecked
+
+    let%expect_test _ =
+      test (function
+        | Of_increasing_iterator_unchecked _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |     9
+        ----+------+------
+          0 |    1 |    82
+         50 |   10 |    41
+         75 |   18 |    21
+         90 |   26 |     9
+         95 |   27 |     7
+        100 |   30 |     2
+        |}]
+    ;;
+
+    let of_alist = Map.of_alist
+
+    let%expect_test _ =
+      test (function
+        | Of_alist _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    18
+        ----+------+------
+          0 |    1 |    64
+         50 |   13 |    32
+         75 |   22 |    16
+         90 |   26 |     8
+         95 |   29 |     4
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_alist_or_error = Map.of_alist_or_error
+
+    let%expect_test _ =
+      test (function
+        | Of_alist_or_error _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    18
+        ----+------+------
+          0 |    1 |    74
+         50 |   11 |    37
+         75 |   20 |    20
+         90 |   26 |     8
+         95 |   29 |     4
+        100 |   31 |     2
+        |}]
+    ;;
+
+    let of_alist_exn = Map.of_alist_exn
+
+    let%expect_test _ =
+      test (function
+        | Of_alist_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |     9
+        ----+------+------
+          0 |    1 |    59
+         50 |    9 |    30
+         75 |   16 |    15
+         90 |   25 |     6
+         95 |   28 |     3
+        100 |   30 |     1
+        |}]
+    ;;
+
+    let of_alist_fold = Map.of_alist_fold
+
+    let%expect_test _ =
+      test (function
+        | Of_alist_fold _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |     8
+        ----+------+------
+          0 |    1 |    76
+         50 |    3 |    55
+         75 |    4 |    32
+        100 |    5 |     8
+        |}]
+    ;;
+
+    let of_alist_reduce = Map.of_alist_reduce
+
+    let%expect_test _ =
+      test (function
+        | Of_alist_reduce _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    11
+        ----+------+------
+          0 |    1 |    72
+         50 |    3 |    41
+         90 |    4 |    29
+         95 |    5 |     7
+        100 |    6 |     1
+        |}]
+    ;;
+
+    let of_increasing_sequence = Map.of_increasing_sequence
+
+    let%expect_test _ =
+      test (function
+        | Of_increasing_sequence _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |     9
+        ----+------+------
+          0 |    1 |    77
+         50 |    9 |    39
+         75 |   17 |    20
+         90 |   20 |    12
+         95 |   24 |     5
+        100 |   28 |     1
+        |}]
+    ;;
+
+    let of_sequence = Map.of_sequence
+
+    let%expect_test _ =
+      test (function
+        | Of_sequence _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |     9
+        ----+------+------
+          0 |    1 |    79
+         50 |    9 |    44
+         75 |   15 |    20
+         90 |   22 |     9
+         95 |   23 |     7
+        100 |   29 |     1
+        |}]
+    ;;
+
+    let of_sequence_or_error = Map.of_sequence_or_error
+
+    let%expect_test _ =
+      test (function
+        | Of_sequence_or_error _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    15
+        ----+------+------
+          0 |    1 |    77
+         50 |    9 |    41
+         75 |   18 |    22
+         90 |   24 |     9
+         95 |   26 |     6
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_sequence_exn = Map.of_sequence_exn
+
+    let%expect_test _ =
+      test (function
+        | Of_sequence_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    11
+        ----+------+------
+          0 |    1 |    71
+         50 |   14 |    36
+         75 |   21 |    19
+         90 |   25 |     8
+         95 |   27 |     4
+        100 |   28 |     2
+        |}]
+    ;;
+
+    let of_sequence_fold = Map.of_sequence_fold
+
+    let%expect_test _ =
+      test (function
+        | Of_sequence_fold _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    13
+        ----+------+------
+          0 |    1 |    71
+         50 |    3 |    48
+         90 |    4 |    32
+        100 |    5 |     7
+        |}]
+    ;;
+
+    let of_sequence_reduce = Map.of_sequence_reduce
+
+    let%expect_test _ =
+      test (function
+        | Of_sequence_reduce _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    11
+        ----+------+------
+          0 |    1 |    68
+         75 |    3 |    45
+         95 |    4 |    14
+        100 |    5 |     3
+        |}]
+    ;;
+
+    let of_list_with_key = Map.of_list_with_key
+
+    let%expect_test _ =
+      test (function
+        | Of_list_with_key _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    10
+        ----+------+------
+          0 |    1 |    68
+         50 |   12 |    35
+         75 |   19 |    17
+         95 |   25 |     7
+        100 |   27 |     1
+        |}]
+    ;;
+
+    let of_list_with_key_or_error = Map.of_list_with_key_or_error
+
+    let%expect_test _ =
+      test (function
+        | Of_list_with_key_or_error _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    14
+        ----+------+------
+          0 |    1 |    86
+         50 |   11 |    44
+         75 |   18 |    23
+         90 |   25 |    10
+         95 |   27 |     6
+        100 |   30 |     1
+        |}]
+    ;;
+
+    let of_list_with_key_exn = Map.of_list_with_key_exn
+
+    let%expect_test _ =
+      test (function
+        | Of_list_with_key_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    10
+        ----+------+------
+          0 |    1 |    68
+         50 |   10 |    34
+         75 |   17 |    18
+         90 |   24 |     7
+         95 |   25 |     6
+        100 |   28 |     2
+        |}]
+    ;;
+
+    let of_list_with_key_fold = Map.of_list_with_key_fold
+
+    let%expect_test _ =
+      test (function
+        | Of_list_with_key_fold _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    13
+        ----+------+------
+          0 |    1 |    68
+         50 |    2 |    41
+        100 |    3 |    17
+        |}]
+    ;;
+
+    let of_list_with_key_reduce = Map.of_list_with_key_reduce
+
+    let%expect_test _ =
+      test (function
+        | Of_list_with_key_reduce _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    12
+        ----+------+------
+          0 |    1 |    69
+         50 |    2 |    48
+         95 |    3 |    18
+        100 |    4 |     1
+        |}]
+    ;;
+
+    let of_iteri = Map.of_iteri
+
+    let%expect_test _ =
+      test (function
+        | Of_iteri _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    11
+        ----+------+------
+          0 |    1 |    78
+         50 |   11 |    39
+         75 |   20 |    20
+         90 |   27 |     8
+        100 |   30 |     5
+        |}]
+    ;;
+
+    let of_iteri_exn = Map.of_iteri_exn
+
+    let%expect_test _ =
+      test (function
+        | Of_iteri_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    17
+        ----+------+------
+          0 |    1 |    67
+         50 |   10 |    36
+         75 |   18 |    17
+         90 |   26 |     7
+         95 |   29 |     5
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let add = Map.add
+
+    let%expect_test _ =
+      test (function
+        | Add _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          0 |    1 |   265
+         50 |    3 |   143
+         75 |    7 |    69
+         90 |   17 |    27
+         95 |   21 |    16
+         99 |   27 |     4
+        100 |   38 |     1
+        |}]
+    ;;
+
+    let add_exn = Map.add_exn
+
+    let%expect_test _ =
+      test (function
+        | Add_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          0 |    1 |   271
+         50 |    2 |   183
+         75 |    4 |    85
+         90 |   13 |    33
+         95 |   21 |    14
+         99 |   28 |     4
+        100 |   51 |     1
+        |}]
+    ;;
+
+    let set = Map.set
+
+    let%expect_test _ =
+      test (function
+        | Set _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          0 |    1 |   263
+         50 |    2 |   151
+         75 |    5 |    66
+         90 |   12 |    29
+         95 |   20 |    14
+         99 |   26 |     3
+        100 |   29 |     1
+        |}]
+    ;;
+
+    let change = Map.change
+
+    let%expect_test _ =
+      test (function
+        | Change _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    62
+        ----+------+------
+          0 |    1 |   202
+         50 |    3 |   101
+         75 |    8 |    53
+         90 |   16 |    22
+         95 |   21 |    11
+         99 |   28 |     3
+        100 |   41 |     1
+        |}]
+    ;;
+
+    let update = Map.update
+
+    let%expect_test _ =
+      test (function
+        | Update _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          0 |    1 |   277
+         50 |    2 |   178
+         75 |    7 |    71
+         90 |   18 |    29
+         95 |   23 |    18
+         99 |   30 |     3
+        100 |   48 |     1
+        |}]
+    ;;
+
+    let remove = Map.remove
+
+    let%expect_test _ =
+      test (function
+        | Remove _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   100
+        ----+------+------
+          0 |    1 |   190
+         50 |    3 |   113
+         75 |   11 |    48
+         90 |   20 |    20
+         95 |   24 |    10
+         99 |   39 |     2
+        100 |   42 |     1
+        |}]
+    ;;
+
+    let map = Map.map
+
+    let%expect_test _ =
+      test (function
+        | Map _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   110
+        ----+------+------
+          0 |    1 |   194
+         50 |    3 |   106
+         75 |    8 |    53
+         90 |   18 |    22
+         95 |   23 |    10
+         99 |   43 |     2
+        100 |   49 |     1
+        |}]
+    ;;
+
+    let mapi = Map.mapi
+
+    let%expect_test _ =
+      test (function
+        | Mapi _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   100
+        ----+------+------
+          0 |    1 |   169
+         50 |    2 |   114
+         75 |    8 |    45
+         90 |   18 |    18
+         95 |   21 |     9
+         99 |   29 |     2
+        100 |   30 |     1
+        |}]
+    ;;
+
+    let filter_keys = Map.filter_keys
+
+    let%expect_test _ =
+      test (function
+        | Filter_keys _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   168
+        ----+------+------
+          0 |    1 |   133
+         50 |    2 |    76
+         75 |    7 |    34
+         90 |   16 |    18
+         95 |   22 |     7
+         99 |   29 |     2
+        100 |   38 |     1
+        |}]
+    ;;
+
+    let filter = Map.filter
+
+    let%expect_test _ =
+      test (function
+        | Filter _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   163
+        ----+------+------
+          0 |    1 |   140
+         50 |    2 |    97
+         75 |    6 |    37
+         90 |   12 |    14
+         95 |   20 |     7
+        100 |   24 |     2
+        |}]
+    ;;
+
+    let filteri = Map.filteri
+
+    let%expect_test _ =
+      test (function
+        | Filteri _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   157
+        ----+------+------
+          0 |    1 |   134
+         50 |    2 |    81
+         75 |    4 |    39
+         90 |   10 |    16
+         95 |   14 |     8
+         99 |   23 |     2
+        100 |   24 |     1
+        |}]
+    ;;
+
+    let filter_map = Map.filter_map
+
+    let%expect_test _ =
+      test (function
+        | Filter_map _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   154
+        ----+------+------
+          0 |    1 |   109
+         50 |    3 |    64
+         75 |    6 |    30
+         90 |   16 |    11
+         95 |   20 |     8
+         99 |   24 |     2
+        100 |   26 |     1
+        |}]
+    ;;
+
+    let filter_mapi = Map.filter_mapi
+
+    let%expect_test _ =
+      test (function
+        | Filter_mapi _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   184
+        ----+------+------
+          0 |    1 |   119
+         50 |    2 |    78
+         75 |    5 |    32
+         90 |   14 |    12
+         95 |   19 |     6
+         99 |   24 |     3
+        100 |   25 |     1
+        |}]
+    ;;
+
+    let partition_mapi = Map.partition_mapi
+
+    let%expect_test _ =
+      test (function
+        | Partition_mapi _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   145
+        ----+------+------
+          0 |    1 |   105
+         50 |    3 |    53
+         75 |    7 |    27
+         90 |   15 |    11
+         95 |   22 |     6
+         99 |   26 |     3
+        100 |   28 |     1
+        |}]
+    ;;
+
+    let partition_map = Map.partition_map
+
+    let%expect_test _ =
+      test (function
+        | Partition_map _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   142
+        ----+------+------
+          0 |    1 |   128
+         50 |    3 |    64
+         75 |    8 |    32
+         90 |   15 |    13
+         95 |   18 |     8
+        100 |   24 |     2
+        |}]
+    ;;
+
+    let partitioni_tf = Map.partitioni_tf
+
+    let%expect_test _ =
+      test (function
+        | Partitioni_tf _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   158
+        ----+------+------
+          0 |    1 |   132
+         50 |    2 |    77
+         75 |    5 |    33
+         90 |   10 |    15
+         95 |   14 |     7
+        100 |   27 |     2
+        |}]
+    ;;
+
+    let partition_tf = Map.partition_tf
+
+    let%expect_test _ =
+      test (function
+        | Partition_tf _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   142
+        ----+------+------
+          0 |    1 |   121
+         50 |    2 |    75
+         75 |    6 |    33
+         90 |   12 |    14
+         95 |   21 |     7
+         99 |   29 |     2
+        100 |   41 |     1
+        |}]
+    ;;
+
+    let merge = Map.merge
+
+    let%expect_test _ =
+      test (function
+        | Merge _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    83
+        ----+------+------
+          0 |    1 |   179
+         50 |    2 |   120
+         75 |    5 |    55
+         90 |    9 |    20
+         95 |   11 |    10
+         99 |   24 |     2
+        100 |   53 |     1
+        |}]
+    ;;
+
+    let merge_disjoint_exn = Map.merge_disjoint_exn
+
+    let%expect_test _ =
+      test (function
+        | Merge_disjoint_exn _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    33
+        ----+------+------
+          0 |    1 |   249
+         50 |    5 |   126
+         75 |   13 |    67
+         90 |   23 |    31
+         95 |   29 |    13
+         99 |   42 |     3
+        100 |   69 |     1
+        |}]
+    ;;
+
+    let merge_skewed = Map.merge_skewed
+
+    let%expect_test _ =
+      test (function
+        | Merge_skewed _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    37
+        ----+------+------
+          0 |    1 |   237
+         50 |    5 |   122
+         75 |   13 |    65
+         90 |   22 |    25
+         95 |   27 |    15
+         99 |   34 |     3
+        100 |   40 |     1
+        |}]
+    ;;
+
+    let split = Map.split
+
+    let%expect_test _ =
+      test (function
+        | Split _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   176
+        ----+------+------
+          0 |    1 |   115
+         50 |    2 |    72
+         75 |    6 |    33
+         90 |   10 |    15
+         95 |   14 |     8
+         99 |   18 |     2
+        100 |   27 |     1
+        |}]
+    ;;
+
+    let split_le_gt = Map.split_le_gt
+
+    let%expect_test _ =
+      test (function
+        | Split_le_gt _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   164
+        ----+------+------
+          0 |    1 |   115
+         50 |    2 |    67
+         75 |    5 |    30
+         90 |   12 |    13
+         95 |   19 |     7
+         99 |   23 |     4
+        100 |   25 |     1
+        |}]
+    ;;
+
+    let split_lt_ge = Map.split_lt_ge
+
+    let%expect_test _ =
+      test (function
+        | Split_lt_ge _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   132
+        ----+------+------
+          0 |    1 |   123
+         50 |    2 |    69
+         75 |    5 |    32
+         90 |   13 |    13
+         95 |   15 |     7
+         99 |   27 |     2
+        100 |   63 |     1
+        |}]
+    ;;
+
+    let append = Map.append
+
+    let%expect_test _ =
+      test (function
+        | Append _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    23
+        ----+------+------
+          0 |    1 |   260
+         50 |    5 |   140
+         75 |   12 |    66
+         90 |   22 |    26
+         95 |   28 |    13
+         99 |   41 |     3
+        100 |   43 |     2
+        |}]
+    ;;
+
+    let subrange = Map.subrange
+
+    let%expect_test _ =
+      test (function
+        | Subrange _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   191
+        ----+------+------
+          0 |    1 |    84
+         50 |    2 |    51
+         75 |    6 |    23
+         90 |   16 |     9
+         95 |   19 |     5
+        100 |   25 |     1
+        |}]
+    ;;
+
+    module Make_applicative_traversals (A : Applicative.Lazy_applicative) = struct
+      module T = Map.Make_applicative_traversals (A)
+
+      let mapi = T.mapi
+      let filter_mapi = T.filter_mapi
+    end
+
+    let%expect_test _ =
+      test (function
+        | Make_applicative_traversals__mapi _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    94
+        ----+------+------
+          0 |    1 |   179
+         50 |    3 |    95
+         75 |    6 |    53
+         90 |   16 |    20
+         95 |   21 |     9
+         99 |   25 |     2
+        100 |   27 |     1
+        |}]
+    ;;
+
+    let%expect_test _ =
+      test (function
+        | Make_applicative_traversals__filter_mapi _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   159
+        ----+------+------
+          0 |    1 |   138
+         50 |    3 |    70
+         75 |    7 |    35
+         90 |   12 |    17
+         95 |   16 |     8
+         99 |   22 |     2
+        100 |   27 |     1
+        |}]
+    ;;
+  end :
+    Impl))
+;;
diff --git a/test/coverage/map/constructor.mli b/test/coverage/map/constructor.mli
new file mode 100644
index 00000000..0d8b0e66
--- /dev/null
+++ b/test/coverage/map/constructor.mli
@@ -0,0 +1 @@
+include Constructor_intf.Constructor
diff --git a/test/coverage/map/constructor_intf.ml b/test/coverage/map/constructor_intf.ml
new file mode 100644
index 00000000..3bb05781
--- /dev/null
+++ b/test/coverage/map/constructor_intf.ml
@@ -0,0 +1,21 @@
+(** Creates types for explicit trees of map constructors. This can be used to test maps
+    with coverage over most functions from Map that construct them. *)
+
+open! Base
+open Base_test_coverage_helpers
+open Functor_intf.Definitions
+
+module type Constructor = sig
+  (** Create a constructor type for maps with [int Types.key] keys and [Data.t] data.
+      Excludes functions that operate on restricted types of data, like [of_list_multi] or
+      [unzip]. *)
+  module Make
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types)
+      (Data : Data.S) : sig
+    type t [@@deriving equal, quickcheck, sexp_of]
+
+    (** Get the actual value the constructor represents. *)
+    val value : t -> Data.t Instance.t
+  end
+end
diff --git a/test/coverage/map/dune b/test/coverage/map/dune
new file mode 100644
index 00000000..77c548f5
--- /dev/null
+++ b/test/coverage/map/dune
@@ -0,0 +1,6 @@
+(library
+ (name base_test_coverage_map)
+ (libraries base base_quickcheck base_test_coverage_helpers
+   expect_test_helpers_core.expect_test_helpers_base sexp_grammar stdio)
+ (preprocess
+  (pps ppx_jane)))
diff --git a/test/map_full_interface/functor.ml b/test/coverage/map/functor.ml
similarity index 57%
rename from test/map_full_interface/functor.ml
rename to test/coverage/map/functor.ml
index 16de64b1..0d9b344d 100644
--- a/test/map_full_interface/functor.ml
+++ b/test/coverage/map/functor.ml
@@ -10,243 +10,205 @@
 open! Base
 open Base_quickcheck
 open Expect_test_helpers_base
+open Base_test_coverage_helpers
+open Overrides
 include Functor_intf.Definitions
 
-open struct
-  (** quickcheck configuration *)
-
-  let quickcheck_config =
-    let test_count =
-      (* In js_of_ocaml, quickcheck is slow due to 64-bit arithmetic, and some map
-         operations are especially slow due to use of exceptions and exception handlers.
-         So on "other" backends, we turn the test count down. *)
-      match Sys.backend_type with
-      | Native | Bytecode -> 10_000
-      | Other _ -> 1_000
-    in
-    { Base_quickcheck.Test.default_config with test_count }
-  ;;
+module Generate
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types)
+    (Data : Data.S) : Generate with module Instance := Instance and module Data := Data =
+struct
+  include Constructor.Make (Instance) (Impl) (Data)
 
-  let quickcheck_m here m ~f = quickcheck_m here m ~f ~config:quickcheck_config
+  module Value = struct
+    type t = Data.t Instance.t [@@deriving compare, equal, sexp_of]
+  end
 end
 
-module Instance (Cmp : sig
-  type comparator_witness
-
-  val comparator : (int, comparator_witness) Comparator.t
-end) =
+module Test_helpers
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) =
 struct
-  module Key = struct
-    type t = int [@@deriving quickcheck, sexp_of]
-    type comparator_witness = Cmp.comparator_witness
+  open Instance
+  module Generate = Generate (Instance) (Impl)
 
-    let comparator = Cmp.comparator
-    let compare = comparator.compare
-    let equal = [%compare.equal: t]
-    let quickcheck_generator = Base_quickcheck.Generator.small_strictly_positive_int
+  module Alist = struct
+    type t = (Key.t * int) list [@@deriving compare, equal, quickcheck, sexp_of]
 
-    include Comparable.Infix (struct
-      type nonrec t = t
+    let sample = Memo.memoize [%generator: t]
+  end
 
-      let compare = compare
-    end)
+  module Alist_merge = struct
+    type t = (Key.t * (int, int) Map.Merge_element.t) list [@@deriving equal, sexp_of]
   end
 
-  type 'a t = 'a Map.M(Key).t [@@deriving equal, sexp_of]
+  module Alist_multi = struct
+    type t = (Key.t * int list) list [@@deriving equal, quickcheck, sexp_of]
+  end
 
-  let key x = x
-  let int x = x
-  let tree x = x
+  module Diff = struct
+    type t = (Key.t, int) Map.Symmetric_diff_element.t list [@@deriving equal, sexp_of]
+  end
 
-  let quickcheck_generator gen =
-    Base_quickcheck.Generator.map_t_m
-      (module Key)
-      Base_quickcheck.Generator.small_strictly_positive_int
-      gen
-  ;;
+  module Inst = struct
+    include Generate (Data.Int)
 
-  let quickcheck_observer obs =
-    Base_quickcheck.Observer.map_t Base_quickcheck.Observer.int obs
-  ;;
+    let sample = Memo.memoize [%generator: t]
+  end
 
-  let quickcheck_shrinker shr =
-    Base_quickcheck.Shrinker.map_t Base_quickcheck.Shrinker.int shr
-  ;;
-end
+  module Inst_and_key = struct
+    type t = Inst.t * Key.t [@@deriving quickcheck, sexp_of]
 
-(** A functor like [Instance], but for tree types. *)
-module Instance_tree (Cmp : sig
-  type comparator_witness
+    let sample = Memo.memoize [%generator: t]
+  end
 
-  val comparator : (int, comparator_witness) Comparator.t
-end) =
-struct
-  module M = Instance (Cmp)
-  include M
+  module Inst_and_key_and_data = struct
+    type t = Inst.t * Key.t * int [@@deriving quickcheck, sexp_of]
 
-  type 'a t = (int, 'a, Cmp.comparator_witness) Map.Using_comparator.Tree.t
+    let sample = Memo.memoize [%generator: t]
+  end
 
-  let of_tree tree = Map.Using_comparator.of_tree ~comparator:Cmp.comparator tree
-  let to_tree t = Map.Using_comparator.to_tree t
+  module Inst_and_key_and_maybe_data = struct
+    type t = Inst.t * Key.t * int option [@@deriving quickcheck, sexp_of]
 
-  let quickcheck_generator gen =
-    Base_quickcheck.Generator.map (M.quickcheck_generator gen) ~f:to_tree
-  ;;
+    let sample = Memo.memoize [%generator: t]
+  end
 
-  let quickcheck_observer obs =
-    Base_quickcheck.Observer.unmap (M.quickcheck_observer obs) ~f:of_tree
-  ;;
+  module Inst_inst = struct
+    include Generate (struct
+        type t = Inst.Value.t [@@deriving compare, equal, sexp_of]
 
-  let quickcheck_shrinker shr =
-    Base_quickcheck.Shrinker.map (M.quickcheck_shrinker shr) ~f:to_tree ~f_inverse:of_tree
-  ;;
+        let quickcheck_generator = Generator.map Inst.quickcheck_generator ~f:Inst.value
+        let quickcheck_observer = Observer.opaque
+        let quickcheck_shrinker = Shrinker.atomic
+        let to_int = Impl.length
 
-  let equal equal_a = Map.Using_comparator.Tree.equal ~comparator:Cmp.comparator equal_a
-  let sexp_of_t sexp_of_a t = M.sexp_of_t sexp_of_a (of_tree t)
-end
+        let of_int n =
+          List.init n ~f:(fun i -> Key.of_int i, i) |> create Impl.of_alist_exn
+        ;;
 
-(** Functor for [List.t] *)
-module Lst (T : sig
-  type t [@@deriving equal, sexp_of]
-end) =
-struct
-  type t = T.t list [@@deriving equal, sexp_of]
-end
+        let combine_non_commutative a b =
+          (access Impl.merge_skewed) a b ~combine:(fun ~key:_ a b ->
+            Data.Int.combine_non_commutative a b)
+        ;;
+      end)
 
-(** Functor for [Or_error], ignoring error contents when comparing. *)
-module Ok (T : sig
-  type t [@@deriving equal, sexp_of]
-end) =
-struct
-  type t = (T.t, (Error.t[@equal.ignore])) Result.t [@@deriving equal, sexp_of]
-end
+    let sample = Memo.memoize [%generator: t]
+  end
 
-(** Functor for [Option.t] *)
-module Opt (T : sig
-  type t [@@deriving equal, sexp_of]
-end) =
-struct
-  type t = T.t option [@@deriving equal, sexp_of]
-end
+  module Inst_pair = struct
+    include Generate (struct
+        type t = int * int [@@deriving compare, equal, quickcheck, sexp_of]
 
-(** Functor for pairs of a single type. Random generation frequently generates pairs of
-    identical values. *)
-module Pair (T : sig
-  type t [@@deriving equal, quickcheck, sexp_of]
-end) =
-struct
-  type t = T.t * T.t [@@deriving equal, quickcheck, sexp_of]
-
-  let quickcheck_generator =
-    let open Base_quickcheck.Generator.Let_syntax in
-    match%bind Base_quickcheck.Generator.bool with
-    | true -> [%generator: t]
-    | false ->
-      let%map x = [%generator: T.t] in
-      x, x
-  ;;
-end
+        let to_int (x, y) = Int.max x y
+        let of_int n = n, n
 
-(* Used in [test__*.ml].  *)
-module Test_creators_and_accessors
-  (Types : Types)
-  (Impl : S with module Types := Types)
-  (Instance : Instance with module Types := Types) : S with module Types := Types = struct
-  open Instance
-  open Impl
+        let combine_non_commutative (a, b) (c, d) =
+          Data.Int.combine_non_commutative a c, Data.Int.combine_non_commutative b d
+        ;;
+      end)
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Inst_and_inst = struct
+    include Data.Pair (Inst)
 
-  open struct
-    (** Test helpers, not to be exported. *)
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Inst_and_inst_and_key = struct
+    module Inst2 = Inst_and_inst
 
-    module Alist = struct
-      type t = (Key.t * int) list [@@deriving compare, equal, quickcheck, sexp_of]
-    end
+    type t = Inst2.t * Key.t [@@deriving quickcheck, sexp_of]
 
-    module Alist_merge = struct
-      type t = (Key.t * (int, int) Map.Merge_element.t) list [@@deriving equal, sexp_of]
-    end
+    let sample = Memo.memoize [%generator: t]
+  end
 
-    module Alist_multi = struct
-      type t = (Key.t * int list) list [@@deriving equal, quickcheck, sexp_of]
-    end
+  module Inst_multi = Generate (struct
+      type t = int list [@@deriving compare, equal, quickcheck, sexp_of]
 
-    module Diff = struct
-      type t = (Key.t, int) Map.Symmetric_diff_element.t list [@@deriving equal, sexp_of]
-    end
+      let to_int = List.length
+      let of_int n = List.init n ~f:Fn.id
+      let combine_non_commutative = ( @ )
+    end)
 
-    module Inst = struct
-      type t = int Instance.t [@@deriving equal, quickcheck, sexp_of]
-    end
+  module Inst_multi_and_key = struct
+    type t = Inst_multi.t * Key.t [@@deriving quickcheck, sexp_of]
 
-    module Inst_and_key = struct
-      type t = Inst.t * Key.t [@@deriving quickcheck, sexp_of]
-    end
+    let sample = Memo.memoize [%generator: t]
+  end
 
-    module Inst_and_key_and_data = struct
-      type t = Inst.t * Key.t * int [@@deriving quickcheck, sexp_of]
-    end
+  module Inst_multi_and_key_and_data = struct
+    type t = Inst_multi.t * Key.t * int [@@deriving quickcheck, sexp_of]
 
-    module Inst_inst = struct
-      type t = Inst.t Instance.t [@@deriving equal, quickcheck, sexp_of]
-    end
+    let sample = Memo.memoize [%generator: t]
+  end
 
-    module Inst_pair = struct
-      type t = (int * int) Instance.t [@@deriving equal, quickcheck, sexp_of]
-    end
+  module Key_and_data = struct
+    type t = Key.t * int [@@deriving equal, sexp_of]
+  end
 
-    module Inst_multi = struct
-      type t = int list Instance.t [@@deriving equal, quickcheck, sexp_of]
-    end
+  module Key_and_data_inst = struct
+    type t = (Key.t * int) Instance.t [@@deriving equal, sexp_of]
+  end
 
-    module Key_and_data = struct
-      type t = Key.t * int [@@deriving equal, sexp_of]
-    end
+  module Key_and_data_inst_multi = struct
+    type t = (Key.t * int) list Instance.t [@@deriving equal, sexp_of]
+  end
 
-    module Key_and_data_inst = struct
-      type t = (Key.t * int) Instance.t [@@deriving equal, sexp_of]
-    end
+  module Inst_and_bounds = struct
+    type t = Inst.t * Key.t Maybe_bound.t * Key.t Maybe_bound.t
+    [@@deriving quickcheck, sexp_of]
 
-    module Key_and_data_inst_multi = struct
-      type t = (Key.t * int) list Instance.t [@@deriving equal, sexp_of]
-    end
+    let sample = Memo.memoize [%generator: t]
+  end
 
-    module Maybe_bound = struct
-      include Maybe_bound
+  let ok_or_duplicate_key = function
+    | `Ok x -> Ok x
+    | `Duplicate_key key -> Or_error.error_s [%sexp (key : Key.t)]
+  ;;
 
-      type 'a t = 'a Maybe_bound.t =
-        | Incl of 'a
-        | Excl of 'a
-        | Unbounded
-      [@@deriving quickcheck, sexp_of]
-    end
+  module Physical_equality (T : sig
+      type t [@@deriving sexp_of]
+    end) =
+  struct
+    type t = T.t [@@deriving sexp_of]
 
-    let ok_or_duplicate_key = function
-      | `Ok x -> Ok x
-      | `Duplicate_key key -> Or_error.error_s [%sexp (key : Key.t)]
-    ;;
+    let equal a b = phys_equal a b
   end
+end
+
+module Test_creators
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) :
+  Creators with module Types := Instance.Types = struct
+  open Instance
+  open Impl
+  open Test_helpers (Instance) (Impl)
+
+  let () = print_endline "Functor.Test_creators: running tests."
 
   (** creators *)
 
-  let empty = empty
-  let () = require_equal [%here] (module Sexp) [%sexp (create empty : int t)] [%sexp []]
-  let singleton = singleton
+  and empty = empty
 
-  let () =
+  and () = require_equal (module Sexp) [%sexp (create empty : int t)] [%sexp []]
+  and singleton = singleton
+
+  and () =
     require_equal
-      [%here]
       (module Sexp)
-      [%sexp (create singleton (key 1) 2 : int t)]
+      [%sexp (create singleton (Key.of_int 1) 2 : int t)]
       [%sexp [ [ 1; 2 ] ]]
-  ;;
 
-  let of_alist = of_alist
-  let of_alist_or_error = of_alist_or_error
-  let of_alist_exn = of_alist_exn
+  and of_alist = of_alist
+  and of_alist_or_error = of_alist_or_error
+  and of_alist_exn = of_alist_exn
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let t_or_error = create of_alist_or_error alist in
@@ -257,24 +219,21 @@ module Test_creators_and_accessors
           | `Duplicate_key key -> Or_error.error_s [%sexp (key : Key.t)]
         in
         require_equal
-          [%here]
-          (module Ok (Alist))
+          (module Data.Or_error (Alist))
           (Or_error.map t_or_error ~f:to_alist)
           (let compare a b = Comparable.lift Key.compare ~f:fst a b in
            if List.contains_dup alist ~compare
            then Or_error.error_string "duplicate"
            else Ok (List.sort alist ~compare));
-        require_equal [%here] (module Ok (Inst)) t_exn t_or_error;
-        require_equal [%here] (module Ok (Inst)) t_or_duplicate t_or_error)
-  ;;
+        require_equal (module Data.Or_error (Inst.Value)) t_exn t_or_error;
+        require_equal (module Data.Or_error (Inst.Value)) t_or_duplicate t_or_error)
 
-  let of_alist_multi = of_alist_multi
-  let of_alist_fold = of_alist_fold
-  let of_alist_reduce = of_alist_reduce
+  and of_alist_multi = of_alist_multi
+  and of_alist_fold = of_alist_fold
+  and of_alist_reduce = of_alist_reduce
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let t_multi = create of_alist_multi alist in
@@ -286,21 +245,18 @@ module Test_creators_and_accessors
             x @ y)
         in
         require_equal
-          [%here]
           (module Alist_multi)
           (to_alist t_multi)
           (List.Assoc.sort_and_group alist ~compare:Key.compare);
-        require_equal [%here] (module Inst_multi) t_fold t_multi;
-        require_equal [%here] (module Inst_multi) t_reduce t_multi)
-  ;;
+        require_equal (module Inst_multi.Value) t_fold t_multi;
+        require_equal (module Inst_multi.Value) t_reduce t_multi)
 
-  let of_sequence = of_sequence
-  let of_sequence_or_error = of_sequence_or_error
-  let of_sequence_exn = of_sequence_exn
+  and of_sequence = of_sequence
+  and of_sequence_or_error = of_sequence_or_error
+  and of_sequence_exn = of_sequence_exn
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let seq = Sequence.of_list alist in
@@ -312,18 +268,16 @@ module Test_creators_and_accessors
           | `Duplicate_key key -> Or_error.error_s [%sexp (key : Key.t)]
         in
         let expect = create of_alist_or_error alist in
-        require_equal [%here] (module Ok (Inst)) t_or_error expect;
-        require_equal [%here] (module Ok (Inst)) t_exn expect;
-        require_equal [%here] (module Ok (Inst)) t_or_duplicate expect)
-  ;;
+        require_equal (module Data.Or_error (Inst.Value)) t_or_error expect;
+        require_equal (module Data.Or_error (Inst.Value)) t_exn expect;
+        require_equal (module Data.Or_error (Inst.Value)) t_or_duplicate expect)
 
-  let of_sequence_multi = of_sequence_multi
-  let of_sequence_fold = of_sequence_fold
-  let of_sequence_reduce = of_sequence_reduce
+  and of_sequence_multi = of_sequence_multi
+  and of_sequence_fold = of_sequence_fold
+  and of_sequence_reduce = of_sequence_reduce
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let seq = Sequence.of_list alist in
@@ -338,53 +292,45 @@ module Test_creators_and_accessors
             ~f:(fun x y -> x @ y)
         in
         let expect = create of_alist_multi alist in
-        require_equal [%here] (module Inst_multi) t_multi expect;
-        require_equal [%here] (module Inst_multi) t_fold expect;
-        require_equal [%here] (module Inst_multi) t_reduce expect)
-  ;;
-
-  let of_list_with_key = of_list_with_key
-  let of_list_with_key_or_error = of_list_with_key_or_error
-  let of_list_with_key_exn = of_list_with_key_exn
-  let of_list_with_key_multi = of_list_with_key_multi
-  let of_list_with_key_fold = of_list_with_key_fold
-  let of_list_with_key_reduce = of_list_with_key_reduce
-
-  let () =
+        require_equal (module Inst_multi.Value) t_multi expect;
+        require_equal (module Inst_multi.Value) t_fold expect;
+        require_equal (module Inst_multi.Value) t_reduce expect)
+
+  and of_list_with_key = of_list_with_key
+  and of_list_with_key_or_error = of_list_with_key_or_error
+  and of_list_with_key_exn = of_list_with_key_exn
+  and of_list_with_key_multi = of_list_with_key_multi
+  and of_list_with_key_fold = of_list_with_key_fold
+  and of_list_with_key_reduce = of_list_with_key_reduce
+
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun list ->
         let alist = List.map list ~f:(fun (key, data) -> key, (key, data)) in
         require_equal
-          [%here]
-          (module Ok (Key_and_data_inst))
+          (module Data.Or_error (Key_and_data_inst))
           (create of_list_with_key list ~get_key:fst |> ok_or_duplicate_key)
           (create of_alist alist |> ok_or_duplicate_key);
         require_equal
-          [%here]
-          (module Ok (Key_and_data_inst))
+          (module Data.Or_error (Key_and_data_inst))
           (create of_list_with_key_or_error list ~get_key:fst)
           (create of_alist_or_error alist);
         require_equal
-          [%here]
-          (module Ok (Key_and_data_inst))
+          (module Data.Or_error (Key_and_data_inst))
           (Or_error.try_with (fun () -> create of_list_with_key_exn list ~get_key:fst))
           (Or_error.try_with (fun () -> create of_alist_exn alist));
         require_equal
-          [%here]
           (module Key_and_data_inst_multi)
           (create of_list_with_key_multi list ~get_key:fst)
           (create of_alist_multi alist);
         require_equal
-          [%here]
           (module Key_and_data_inst_multi)
           (create of_list_with_key_fold list ~get_key:fst ~init:[] ~f:(fun acc x ->
              x :: acc)
            |> map ~f:List.rev)
           (create of_alist_multi alist);
         require_equal
-          [%here]
           (module Key_and_data_inst_multi)
           (create
              of_list_with_key_reduce
@@ -392,13 +338,11 @@ module Test_creators_and_accessors
              ~get_key:(fun x -> x |> List.hd_exn |> fst)
              ~f:(fun x y -> x @ y))
           (create of_alist_multi alist))
-  ;;
 
-  let of_increasing_sequence = of_increasing_sequence
+  and of_increasing_sequence = of_increasing_sequence
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let seq = Sequence.of_list alist in
@@ -409,14 +353,12 @@ module Test_creators_and_accessors
           then create of_alist_or_error alist
           else Or_error.error_string "decreasing keys"
         in
-        require_equal [%here] (module Ok (Inst)) actual expect)
-  ;;
+        require_equal (module Data.Or_error (Inst.Value)) actual expect)
 
-  let of_sorted_array = of_sorted_array
+  and of_sorted_array = of_sorted_array
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let actual = create of_sorted_array (Array.of_list alist) in
@@ -427,14 +369,12 @@ module Test_creators_and_accessors
           then create of_alist_or_error alist
           else Or_error.error_string "unsorted"
         in
-        require_equal [%here] (module Ok (Inst)) actual expect)
-  ;;
+        require_equal (module Data.Or_error (Inst.Value)) actual expect)
 
-  let of_sorted_array_unchecked = of_sorted_array_unchecked
+  and of_sorted_array_unchecked = of_sorted_array_unchecked
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let alist =
@@ -444,15 +384,13 @@ module Test_creators_and_accessors
         let actual_fwd = create of_sorted_array_unchecked (Array.of_list alist) in
         let actual_rev = create of_sorted_array_unchecked (Array.of_list_rev alist) in
         let expect = create of_alist_exn alist in
-        require_equal [%here] (module Inst) actual_fwd expect;
-        require_equal [%here] (module Inst) actual_rev expect)
-  ;;
+        require_equal (module Inst.Value) actual_fwd expect;
+        require_equal (module Inst.Value) actual_rev expect)
 
-  let of_increasing_iterator_unchecked = of_increasing_iterator_unchecked
+  and of_increasing_iterator_unchecked = of_increasing_iterator_unchecked
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let alist =
@@ -467,15 +405,13 @@ module Test_creators_and_accessors
             ~f:(Array.get array)
         in
         let expect = create of_alist_exn alist in
-        require_equal [%here] (module Inst) actual expect)
-  ;;
+        require_equal (module Inst.Value) actual expect)
 
-  let of_iteri = of_iteri
-  let of_iteri_exn = of_iteri_exn
+  and of_iteri = of_iteri
+  and of_iteri_exn = of_iteri_exn
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Alist)
       ~f:(fun alist ->
         let iteri ~f = List.iter alist ~f:(fun (key, data) -> f ~key ~data) [@nontail] in
@@ -486,18 +422,17 @@ module Test_creators_and_accessors
         in
         let actual_exn = Or_error.try_with (fun () -> create of_iteri_exn ~iteri) in
         let expect = create of_alist_or_error alist in
-        require_equal [%here] (module Ok (Inst)) actual_or_duplicate expect;
-        require_equal [%here] (module Ok (Inst)) actual_exn expect)
-  ;;
+        require_equal (module Data.Or_error (Inst.Value)) actual_or_duplicate expect;
+        require_equal (module Data.Or_error (Inst.Value)) actual_exn expect)
 
-  let map_keys = map_keys
-  let map_keys_exn = map_keys_exn
+  and map_keys = map_keys
+  and map_keys_exn = map_keys_exn
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key)
       ~f:(fun (t, k) ->
+        let t = Inst.value t in
         let f key = Comparable.min Key.compare k key in
         let actual_or_duplicate =
           match create map_keys t ~f with
@@ -510,198 +445,106 @@ module Test_creators_and_accessors
           |> List.map ~f:(fun (key, data) -> f key, data)
           |> create of_alist_or_error
         in
-        require_equal [%here] (module Ok (Inst)) actual_or_duplicate expect;
-        require_equal [%here] (module Ok (Inst)) actual_exn expect)
-  ;;
+        require_equal (module Data.Or_error (Inst.Value)) actual_or_duplicate expect;
+        require_equal (module Data.Or_error (Inst.Value)) actual_exn expect)
 
-  let transpose_keys = transpose_keys
+  and transpose_keys = transpose_keys
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_inst)
       ~f:(fun t ->
+        let t = Inst_inst.value t in
         let transpose_keys = create (access transpose_keys) in
         let transposed = transpose_keys t in
-        require [%here] (access invariants transposed);
+        require (access invariants transposed);
         let round_trip = transpose_keys transposed in
-        require_equal
-          [%here]
-          (module Inst_inst)
-          (filter t ~f:(Fn.non is_empty))
-          round_trip)
+        require_equal (module Inst_inst.Value) (filter t ~f:(Fn.non is_empty)) round_trip)
+
+  and of_tree = of_tree
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let tree = to_tree t in
+        let round_trip = create of_tree tree in
+        require_equal (module Inst.Value) t round_trip)
   ;;
+end
+
+module Test_accessors
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) :
+  Accessors with module Types := Instance.Types = struct
+  open Instance
+  open Impl
+  open Test_helpers (Instance) (Impl)
+
+  let () = print_endline "Functor.Test_accessors: running tests."
 
   (** accessors *)
 
-  let invariants = invariants
+  and invariants = invariants
 
-  let () =
-    quickcheck_m [%here] (module Inst) ~f:(fun t -> require [%here] (access invariants t))
-  ;;
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        require (access invariants t))
 
-  let is_empty = is_empty
-  let length = length
+  and is_empty = is_empty
+  and length = length
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         let len = length t in
-        require_equal [%here] (module Bool) (is_empty t) (len = 0);
-        require_equal [%here] (module Int) len (List.length (to_alist t)))
-  ;;
+        require_equal (module Bool) (is_empty t) (len = 0);
+        require_equal (module Int) len (List.length (to_alist t)))
 
-  let mem = mem
-  let find = find
-  let find_exn = find_exn
+  and mem = mem
+  and find = find
+  and find_exn = find_exn
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key)
       ~f:(fun (t, key) ->
+        let t = Inst.value t in
         let expect = List.Assoc.find (to_alist t) key ~equal:Key.equal in
-        require_equal [%here] (module Bool) (access mem t key) (Option.is_some expect);
-        require_equal [%here] (module Opt (Int)) (access find t key) expect;
+        require_equal (module Bool) (access mem t key) (Option.is_some expect);
+        require_equal (module Data.Option (Int)) (access find t key) expect;
         require_equal
-          [%here]
-          (module Opt (Int))
+          (module Data.Option (Int))
           (Option.try_with (fun () -> access find_exn t key))
           expect)
-  ;;
-
-  let set = set
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key_and_data)
-      ~f:(fun (t, key, data) ->
-        require_equal
-          [%here]
-          (module Alist)
-          (to_alist (access set t ~key ~data))
-          (List.sort
-             ~compare:(fun a b -> Comparable.lift Key.compare ~f:fst a b)
-             ((key, data) :: List.Assoc.remove (to_alist t) key ~equal:Key.equal)))
-  ;;
-
-  let add = add
-  let add_exn = add_exn
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key_and_data)
-      ~f:(fun (t, key, data) ->
-        let t_add =
-          match access add t ~key ~data with
-          | `Ok t -> Ok t
-          | `Duplicate -> Or_error.error_string "duplicate"
-        in
-        let t_add_exn = Or_error.try_with (fun () -> access add_exn t ~key ~data) in
-        let expect =
-          if access mem t key
-          then Or_error.error_string "duplicate"
-          else Ok (access set t ~key ~data)
-        in
-        require_equal [%here] (module Ok (Inst)) t_add expect;
-        require_equal [%here] (module Ok (Inst)) t_add_exn expect)
-  ;;
 
-  let remove = remove
+  and find_multi = find_multi
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module Inst_and_key)
+      (module Inst_multi_and_key)
       ~f:(fun (t, key) ->
+        let t = Inst_multi.value t in
         require_equal
-          [%here]
-          (module Alist)
-          (to_alist (access remove t key))
-          (List.Assoc.remove (to_alist t) key ~equal:Key.equal))
-  ;;
-
-  let change = change
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module struct
-        type t = Inst.t * Key.t * int option [@@deriving quickcheck, sexp_of]
-      end)
-      ~f:(fun (t, key, maybe_data) ->
-        let actual =
-          access change t key ~f:(fun previous ->
-            require_equal [%here] (module Opt (Int)) previous (access find t key);
-            maybe_data)
-        in
-        let expect =
-          match maybe_data with
-          | None -> access remove t key
-          | Some data -> access set t ~key ~data
-        in
-        require_equal [%here] (module Inst) actual expect)
-  ;;
-
-  let update = update
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key_and_data)
-      ~f:(fun (t, key, data) ->
-        let actual =
-          access update t key ~f:(fun previous ->
-            require_equal [%here] (module Opt (Int)) previous (access find t key);
-            data)
-        in
-        let expect = access set t ~key ~data in
-        require_equal [%here] (module Inst) actual expect)
-  ;;
-
-  let find_multi = find_multi
-  let add_multi = add_multi
-  let remove_multi = remove_multi
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module struct
-        type t = Inst_multi.t * Key.t * int [@@deriving quickcheck, sexp_of]
-      end)
-      ~f:(fun (t, key, data) ->
-        require_equal
-          [%here]
-          (module Lst (Int))
+          (module Data.List (Int))
           (access find_multi t key)
-          (access find t key |> Option.value ~default:[]);
-        require_equal
-          [%here]
-          (module Inst_multi)
-          (access add_multi t ~key ~data)
-          (access update t key ~f:(fun option -> data :: Option.value option ~default:[]));
-        require_equal
-          [%here]
-          (module Inst_multi)
-          (access remove_multi t key)
-          (access change t key ~f:(function
-            | None | Some ([] | [ _ ]) -> None
-            | Some (_ :: (_ :: _ as rest)) -> Some rest)))
-  ;;
+          (access find t key |> Option.value ~default:[]))
 
-  let iter_keys = iter_keys
-  let iter = iter
-  let iteri = iteri
+  and iter_keys = iter_keys
+  and iter = iter
+  and iteri = iteri
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         let actuali =
           let q = Queue.create () in
           iteri t ~f:(fun ~key ~data -> Queue.enqueue q (key, data));
@@ -717,301 +560,109 @@ module Test_creators_and_accessors
           iter t ~f:(Queue.enqueue q);
           Queue.to_list q
         in
-        require_equal [%here] (module Alist) actuali (to_alist t);
-        require_equal [%here] (module Lst (Key)) actual_keys (keys t);
-        require_equal [%here] (module Lst (Int)) actual (data t))
-  ;;
+        require_equal (module Alist) actuali (to_alist t);
+        require_equal (module Data.List (Key)) actual_keys (keys t);
+        require_equal (module Data.List (Int)) actual (data t))
 
-  let map = map
-  let mapi = mapi
+  and fold = fold
+  and fold_right = fold_right
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         require_equal
-          [%here]
-          (module Inst)
-          (map t ~f:Int.succ)
-          (t |> to_alist |> List.Assoc.map ~f:Int.succ |> create of_alist_exn);
+          (module Alist)
+          (fold t ~init:[] ~f:(fun ~key ~data list -> (key, data) :: list))
+          (List.rev (to_alist t));
         require_equal
-          [%here]
-          (module struct
-            type t = (Key.t * int) Instance.t [@@deriving equal, sexp_of]
-          end)
-          (mapi t ~f:(fun ~key ~data -> key, data))
-          (t |> to_alist |> List.map ~f:(fun (k, v) -> k, (k, v)) |> create of_alist_exn))
-  ;;
-
-  let filter_keys = filter_keys
-  let filter = filter
-  let filteri = filteri
-
-  module Physical_equality (T : sig
-    type t [@@deriving sexp_of]
-  end) =
-  struct
-    type t = T.t [@@deriving sexp_of]
+          (module Alist)
+          (fold_right t ~init:[] ~f:(fun ~key ~data list -> (key, data) :: list))
+          (to_alist t))
 
-    let equal a b = phys_equal a b
-  end
+  and fold_until = fold_until
+  and iteri_until = iteri_until
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module Inst_and_key_and_data)
-      ~f:(fun (t, k, d) ->
-        require_equal
-          [%here]
-          (module Physical_equality (Inst))
-          (filter ~f:(fun _ -> true) t)
-          t;
-        require_equal
-          [%here]
-          (module Alist)
-          (to_alist (filter_keys t ~f:(fun key -> Key.( <= ) key k)))
-          (List.filter (to_alist t) ~f:(fun (key, _) -> Key.( <= ) key k));
-        require_equal
-          [%here]
-          (module Alist)
-          (to_alist (filter t ~f:(fun data -> data <= d)))
-          (List.filter (to_alist t) ~f:(fun (_, data) -> data <= d));
+      (module Inst_and_key)
+      ~f:(fun (t, threshold) ->
+        let t = Inst.value t in
         require_equal
-          [%here]
-          (module Alist)
-          (to_alist (filteri t ~f:(fun ~key ~data -> Key.( <= ) key k && data <= d)))
-          (List.filter (to_alist t) ~f:(fun (key, data) -> Key.( <= ) key k && data <= d)))
-  ;;
+          (module struct
+            type t = int list * Base.Map.Finished_or_unfinished.t
+            [@@deriving equal, sexp_of]
+          end)
+          (let q = Queue.create () in
+           let status =
+             iteri_until t ~f:(fun ~key ~data ->
+               if Key.( >= ) key threshold
+               then Stop
+               else (
+                 Queue.enqueue q data;
+                 Continue))
+           in
+           Queue.to_list q, status)
+          (let list =
+             to_alist t
+             |> List.take_while ~f:(fun (key, _) -> Key.( < ) key threshold)
+             |> List.map ~f:snd
+           in
+           list, if List.length list = length t then Finished else Unfinished))
 
-  let filter_map = filter_map
-  let filter_mapi = filter_mapi
+  and equal = equal
+  and compare_direct = compare_direct
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module Inst_and_key_and_data)
-      ~f:(fun (t, k, d) ->
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
         require_equal
-          [%here]
-          (module Alist)
-          (to_alist (filter_map t ~f:(fun data -> Option.some_if (data >= d) (data - d))))
-          (List.filter_map (to_alist t) ~f:(fun (key, data) ->
-             Option.some_if (data >= d) (key, data - d)));
+          (module Ordering)
+          (Ordering.of_int (access compare_direct Int.compare a b))
+          (Ordering.of_int (Alist.compare (to_alist a) (to_alist b)));
         require_equal
-          [%here]
-          (module Alist)
-          (to_alist
-             (filter_mapi t ~f:(fun ~key ~data ->
-                Option.some_if (Key.( <= ) key k && data >= d) (data - d))))
-          (List.filter_map (to_alist t) ~f:(fun (key, data) ->
-             Option.some_if (Key.( <= ) key k && data >= d) (key, data - d))))
-  ;;
+          (module Bool)
+          (access compare_direct Int.compare a b = 0)
+          (access equal Int.equal a b))
 
-  let partition_mapi = partition_mapi
-  let partition_map = partition_map
-  let partitioni_tf = partitioni_tf
-  let partition_tf = partition_tf
+  and keys = keys
+  and data = data
+  and to_alist = to_alist
+  and to_sequence = to_sequence
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module Inst_and_key_and_data)
-      ~f:(fun (t, k, d) ->
-        require_equal
-          [%here]
-          (module Physical_equality (Inst))
-          (fst (partition_tf ~f:(fun _ -> true) t))
-          t;
-        require_equal
-          [%here]
-          (module Pair (Alist))
-          (let a, b = partition_tf t ~f:(fun data -> data <= d) in
-           to_alist a, to_alist b)
-          (List.partition_tf (to_alist t) ~f:(fun (_, data) -> data <= d));
-        require_equal
-          [%here]
-          (module Pair (Alist))
-          (let a, b =
-             partitioni_tf t ~f:(fun ~key ~data -> Key.( <= ) key k && data <= d)
-           in
-           to_alist a, to_alist b)
-          (List.partition_tf (to_alist t) ~f:(fun (key, data) ->
-             Key.( <= ) key k && data <= d));
-        require_equal
-          [%here]
-          (module Pair (Alist))
-          (let a, b =
-             partition_map t ~f:(fun data ->
-               if data >= d then First (data - d) else Second d)
-           in
-           to_alist a, to_alist b)
-          (List.partition_map (to_alist t) ~f:(fun (key, data) ->
-             if data >= d then First (key, data - d) else Second (key, d)));
-        require_equal
-          [%here]
-          (module Pair (Alist))
-          (let a, b =
-             partition_mapi t ~f:(fun ~key ~data ->
-               if Key.( <= ) key k && data >= d then First (data - d) else Second d)
-           in
-           to_alist a, to_alist b)
-          (List.partition_map (to_alist t) ~f:(fun (key, data) ->
-             if Key.( <= ) key k && data >= d
-             then First (key, data - d)
-             else Second (key, d))))
-  ;;
-
-  let fold = fold
-  let fold_right = fold_right
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst)
-      ~f:(fun t ->
-        require_equal
-          [%here]
-          (module Alist)
-          (fold t ~init:[] ~f:(fun ~key ~data list -> (key, data) :: list))
-          (List.rev (to_alist t));
-        require_equal
-          [%here]
-          (module Alist)
-          (fold_right t ~init:[] ~f:(fun ~key ~data list -> (key, data) :: list))
-          (to_alist t))
-  ;;
-
-  let fold_until = fold_until
-  let iteri_until = iteri_until
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key)
-      ~f:(fun (t, threshold) ->
-        require_equal
-          [%here]
-          (module struct
-            type t = int list * Base.Map.Finished_or_unfinished.t
-            [@@deriving equal, sexp_of]
-          end)
-          (let q = Queue.create () in
-           let status =
-             iteri_until t ~f:(fun ~key ~data ->
-               if Key.( >= ) key threshold
-               then Stop
-               else (
-                 Queue.enqueue q data;
-                 Continue))
-           in
-           Queue.to_list q, status)
-          (let list =
-             to_alist t
-             |> List.take_while ~f:(fun (key, _) -> Key.( < ) key threshold)
-             |> List.map ~f:snd
-           in
-           list, if List.length list = length t then Finished else Unfinished))
-  ;;
-
-  let combine_errors = combine_errors
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key)
-      ~f:(fun (t, threshold) ->
-        let t =
-          mapi t ~f:(fun ~key ~data ->
-            if Key.( <= ) key threshold then Ok data else Or_error.error_string "too big")
-        in
-        require_equal
-          [%here]
-          (module Ok (Inst))
-          (access combine_errors t)
-          (to_alist t
-           |> List.map ~f:(fun (key, result) ->
-                Or_error.map result ~f:(fun data -> key, data))
-           |> Or_error.combine_errors
-           |> Or_error.map ~f:(create of_alist_exn)))
-  ;;
-
-  let unzip = unzip
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_pair)
-      ~f:(fun t ->
-        require_equal
-          [%here]
-          (module Pair (Alist))
-          (let a, b = unzip t in
-           to_alist a, to_alist b)
-          (to_alist t
-           |> List.map ~f:(fun (key, (a, b)) -> (key, a), (key, b))
-           |> List.unzip))
-  ;;
-
-  let equal = equal
-  let compare_direct = compare_direct
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Pair (Inst))
-      ~f:(fun (a, b) ->
-        require_equal
-          [%here]
-          (module Ordering)
-          (Ordering.of_int (access compare_direct Int.compare a b))
-          (Ordering.of_int (Alist.compare (to_alist a) (to_alist b)));
-        require_equal
-          [%here]
-          (module Bool)
-          (access compare_direct Int.compare a b = 0)
-          (access equal Int.equal a b))
-  ;;
-
-  let keys = keys
-  let data = data
-  let to_alist = to_alist
-  let to_sequence = to_sequence
-
-  let () =
-    quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         let alist = to_alist t in
-        require_equal [%here] (module Inst) (create of_alist_exn alist) t;
-        require_equal [%here] (module Lst (Key)) (keys t) (List.map alist ~f:fst);
-        require_equal [%here] (module Lst (Int)) (data t) (List.map alist ~f:snd);
-        require_equal
-          [%here]
-          (module Alist)
-          (Sequence.to_list ((access to_sequence) t))
-          alist)
-  ;;
+        require_equal (module Inst.Value) (create of_alist_exn alist) t;
+        require_equal (module Data.List (Key)) (keys t) (List.map alist ~f:fst);
+        require_equal (module Data.List (Int)) (data t) (List.map alist ~f:snd);
+        require_equal (module Alist) (Sequence.to_list ((access to_sequence) t)) alist)
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module struct
         type t = Inst.t * [ `Decreasing | `Increasing ] [@@deriving quickcheck, sexp_of]
+
+        let sample = Memo.memoize [%generator: t]
       end)
       ~f:(fun (t, key_order) ->
+        let t = Inst.value t in
         let alist = to_alist t ~key_order in
         require_equal
-          [%here]
-          (module Lst (Key_and_data))
+          (module Data.List (Key_and_data))
           alist
           (match key_order with
            | `Increasing -> to_alist t
            | `Decreasing -> List.rev (to_alist t));
         require_equal
-          [%here]
-          (module Lst (Key_and_data))
+          (module Data.List (Key_and_data))
           alist
           (Sequence.to_list
              ((access to_sequence)
@@ -1020,16 +671,17 @@ module Test_creators_and_accessors
                   (match key_order with
                    | `Decreasing -> `Decreasing_key
                    | `Increasing -> `Increasing_key))))
-  ;;
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module struct
         type t = Inst.t * [ `Decreasing_key | `Increasing_key ] * Key.t * Key.t
         [@@deriving quickcheck, sexp_of]
+
+        let sample = Memo.memoize [%generator: t]
       end)
       ~f:(fun (t, order, keys_greater_or_equal_to, keys_less_or_equal_to) ->
+        let t = Inst.value t in
         let alist =
           Sequence.to_list
             ((access to_sequence)
@@ -1039,8 +691,7 @@ module Test_creators_and_accessors
                ~keys_less_or_equal_to)
         in
         require_equal
-          [%here]
-          (module Lst (Key_and_data))
+          (module Data.List (Key_and_data))
           alist
           (List.filter
              (match order with
@@ -1049,26 +700,16 @@ module Test_creators_and_accessors
              ~f:(fun (key, _) ->
                Key.( <= ) keys_greater_or_equal_to key
                && Key.( <= ) key keys_less_or_equal_to)))
-  ;;
 
-  let merge = merge
-  let iter2 = iter2
-  let fold2 = fold2
+  and iter2 = iter2
+  and fold2 = fold2
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module struct
-        module Inst2 = Pair (Inst)
-
-        type t = Inst2.t * Key.t [@@deriving quickcheck, sexp_of]
-      end)
+      (module Inst_and_inst_and_key)
       ~f:(fun ((a, b), k) ->
-        let merge_alist =
-          access merge a b ~f:(fun ~key elt ->
-            Option.some_if (Key.( > ) key k) (key, elt))
-          |> data
-        in
+        let a = Inst.value a in
+        let b = Inst.value b in
         let iter2_alist =
           let q = Queue.create () in
           access iter2 a b ~f:(fun ~key ~data:elt ->
@@ -1085,67 +726,27 @@ module Test_creators_and_accessors
           |> List.concat_map ~f:to_alist
           |> List.Assoc.sort_and_group ~compare:Key.compare
           |> List.filter_map ~f:(fun (key, list) ->
-               let elt =
-                 match (list : _ Either.t list) with
-                 | [ First x ] -> `Left x
-                 | [ Second y ] -> `Right y
-                 | [ First x; Second y ] -> `Both (x, y)
-                 | _ -> assert false
-               in
-               Option.some_if (Key.( > ) key k) (key, elt))
-        in
-        require_equal [%here] (module Alist_merge) merge_alist expect;
-        require_equal [%here] (module Alist_merge) iter2_alist expect;
-        require_equal [%here] (module Alist_merge) fold2_alist expect)
-  ;;
-
-  let merge_disjoint_exn = merge_disjoint_exn
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Pair (Inst))
-      ~f:(fun (a, b) ->
-        let actual = Option.try_with (fun () -> access merge_disjoint_exn a b) in
-        let expect =
-          if existsi a ~f:(fun ~key ~data:_ -> access mem b key)
-          then None
-          else
-            Some
-              (access merge a b ~f:(fun ~key:_ elt ->
-                 match elt with
-                 | `Left x | `Right x -> Some x
-                 | `Both _ -> assert false))
-        in
-        require_equal [%here] (module Opt (Inst)) actual expect)
-  ;;
-
-  let merge_skewed = merge_skewed
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Pair (Inst))
-      ~f:(fun (a, b) ->
-        let actual = access merge_skewed a b ~combine:(fun ~key a b -> int key + a + b) in
-        let expect =
-          access merge a b ~f:(fun ~key elt ->
-            match elt with
-            | `Left a -> Some a
-            | `Right b -> Some b
-            | `Both (a, b) -> Some (int key + a + b))
+            let elt =
+              match (list : _ Either.t list) with
+              | [ First x ] -> `Left x
+              | [ Second y ] -> `Right y
+              | [ First x; Second y ] -> `Both (x, y)
+              | _ -> assert false
+            in
+            Option.some_if (Key.( > ) key k) (key, elt))
         in
-        require_equal [%here] (module Inst) actual expect)
-  ;;
+        require_equal (module Alist_merge) iter2_alist expect;
+        require_equal (module Alist_merge) fold2_alist expect)
 
-  let symmetric_diff = symmetric_diff
-  let fold_symmetric_diff = fold_symmetric_diff
+  and symmetric_diff = symmetric_diff
+  and fold_symmetric_diff = fold_symmetric_diff
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module Pair (Inst))
+      (module Inst_and_inst)
       ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
         let diff_alist =
           access symmetric_diff a b ~data_equal:Int.equal |> Sequence.to_list
         in
@@ -1167,204 +768,100 @@ module Test_creators_and_accessors
             | `Both (x, y) -> if x = y then None else Some (`Unequal (x, y)))
           |> to_alist
         in
-        require_equal [%here] (module Diff) diff_alist expect;
-        require_equal [%here] (module Diff) fold_alist expect)
-  ;;
+        require_equal (module Diff) diff_alist expect;
+        require_equal (module Diff) fold_alist expect)
 
-  let min_elt = min_elt
-  let max_elt = max_elt
-  let min_elt_exn = min_elt_exn
-  let max_elt_exn = max_elt_exn
+  and min_elt = min_elt
+  and max_elt = max_elt
+  and min_elt_exn = min_elt_exn
+  and max_elt_exn = max_elt_exn
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (min_elt t)
           (List.hd (to_alist t));
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (max_elt t)
           (List.last (to_alist t));
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (Option.try_with (fun () -> min_elt_exn t))
           (List.hd (to_alist t));
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (Option.try_with (fun () -> max_elt_exn t))
           (List.last (to_alist t)))
-  ;;
 
-  let for_all = for_all
-  let for_alli = for_alli
-  let exists = exists
-  let existsi = existsi
-  let count = count
-  let counti = counti
+  and for_all = for_all
+  and for_alli = for_alli
+  and exists = exists
+  and existsi = existsi
+  and count = count
+  and counti = counti
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key_and_data)
       ~f:(fun (t, k, d) ->
+        let t = Inst.value t in
         let f data = data <= d in
         let fi ~key ~data = Key.( <= ) key k && data <= d in
         let fp (key, data) = fi ~key ~data in
         let data = data t in
         let alist = to_alist t in
-        require_equal [%here] (module Bool) (for_all t ~f) (List.for_all data ~f);
-        require_equal [%here] (module Bool) (for_alli t ~f:fi) (List.for_all alist ~f:fp);
-        require_equal [%here] (module Bool) (exists t ~f) (List.exists data ~f);
-        require_equal [%here] (module Bool) (existsi t ~f:fi) (List.exists alist ~f:fp);
-        require_equal [%here] (module Int) (count t ~f) (List.count data ~f);
-        require_equal [%here] (module Int) (counti t ~f:fi) (List.count alist ~f:fp))
-  ;;
+        require_equal (module Bool) (for_all t ~f) (List.for_all data ~f);
+        require_equal (module Bool) (for_alli t ~f:fi) (List.for_all alist ~f:fp);
+        require_equal (module Bool) (exists t ~f) (List.exists data ~f);
+        require_equal (module Bool) (existsi t ~f:fi) (List.exists alist ~f:fp);
+        require_equal (module Int) (count t ~f) (List.count data ~f);
+        require_equal (module Int) (counti t ~f:fi) (List.count alist ~f:fp))
 
-  let sum = sum
-  let sumi = sumi
+  and sum = sum
+  and sumi = sumi
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         let f data = data * 2 in
-        let fi ~key ~data = (Instance.int key * 2) + (data * 3) in
+        let fi ~key ~data = (Key.to_int key * 2) + (data * 3) in
         let fp (key, data) = fi ~key ~data in
         let m = (module Int : Container.Summable with type t = int) in
         let data = data t in
         let alist = to_alist t in
-        require_equal [%here] (module Int) (sum m t ~f) (List.sum m data ~f);
-        require_equal [%here] (module Int) (sumi m t ~f:fi) (List.sum m alist ~f:fp))
-  ;;
-
-  let split = split
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key)
-      ~f:(fun (t, k) ->
-        require_equal
-          [%here]
-          (module struct
-            type t = Inst.t * (Key.t * int) option * Inst.t [@@deriving equal, sexp_of]
-          end)
-          (access split t k)
-          (let before, equal, after =
-             List.partition3_map (to_alist t) ~f:(fun (key, data) ->
-               match Ordering.of_int (Key.compare key k) with
-               | Less -> `Fst (key, data)
-               | Equal -> `Snd (key, data)
-               | Greater -> `Trd (key, data))
-           in
-           create of_alist_exn before, List.hd equal, create of_alist_exn after))
-  ;;
-
-  let split_le_gt = split_le_gt
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key)
-      ~f:(fun (t, k) ->
-        require_equal
-          [%here]
-          (module struct
-            type t = Inst.t * Inst.t [@@deriving equal, sexp_of]
-          end)
-          (access split_le_gt t k)
-          (let before, after =
-             List.partition_tf (to_alist t) ~f:(fun (key, _) -> Key.( <= ) key k)
-           in
-           create of_alist_exn before, create of_alist_exn after))
-  ;;
-
-  let split_lt_ge = split_lt_ge
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst_and_key)
-      ~f:(fun (t, k) ->
-        require_equal
-          [%here]
-          (module struct
-            type t = Inst.t * Inst.t [@@deriving equal, sexp_of]
-          end)
-          (access split_lt_ge t k)
-          (let before, after =
-             List.partition_tf (to_alist t) ~f:(fun (key, _) -> Key.( < ) key k)
-           in
-           create of_alist_exn before, create of_alist_exn after))
-  ;;
-
-  let append = append
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Pair (Inst))
-      ~f:(fun (a, b) ->
-        require_equal
-          [%here]
-          (module Ok (Inst))
-          (match access append ~lower_part:a ~upper_part:b with
-           | `Ok t -> Ok t
-           | `Overlapping_key_ranges -> Or_error.error_string "overlap")
-          (match max_elt a, min_elt b with
-           | Some (x, _), Some (y, _) when Key.( >= ) x y ->
-             Or_error.error_string "overlap"
-           | _ -> Ok (create of_alist_exn (to_alist a @ to_alist b)));
-        let a' =
-          (* we rely on the fact that the [Inst] generator uses positive keys *)
-          create map_keys_exn a ~f:(fun k -> key (-int k))
-        in
-        require_equal
-          [%here]
-          (module Ok (Inst))
-          (match access append ~lower_part:a' ~upper_part:b with
-           | `Ok t -> Ok t
-           | `Overlapping_key_ranges -> Or_error.error_string "overlap")
-          (Ok (create of_alist_exn (to_alist a' @ to_alist b))))
-  ;;
+        require_equal (module Int) (sum m t ~f) (List.sum m data ~f);
+        require_equal (module Int) (sumi m t ~f:fi) (List.sum m alist ~f:fp))
 
-  let subrange = subrange
-  let fold_range_inclusive = fold_range_inclusive
-  let range_to_alist = range_to_alist
+  and fold_range_inclusive = fold_range_inclusive
+  and range_to_alist = range_to_alist
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
-      (module struct
-        type t = Inst.t * Key.t Maybe_bound.t * Key.t Maybe_bound.t
-        [@@deriving quickcheck, sexp_of]
-      end)
+      (module Inst_and_bounds)
       ~f:(fun (t, lower_bound, upper_bound) ->
-        let subrange_alist = access subrange t ~lower_bound ~upper_bound |> to_alist in
+        let t = Inst.value t in
         let min =
           match lower_bound with
-          | Unbounded -> key Int.min_value
+          | Unbounded -> Key.of_int Int.min_value
           | Incl min -> min
           | Excl too_small ->
             (* key generator does not generate [max_value], so this cannot overflow *)
-            key (int too_small + 1)
+            Key.of_int (Key.to_int too_small + 1)
         in
         let max =
           match upper_bound with
-          | Unbounded -> key Int.max_value
+          | Unbounded -> Key.of_int Int.max_value
           | Incl max -> max
           | Excl too_large ->
             (* key generator does not generate [min_value], so this cannot overflow *)
-            key (int too_large - 1)
+            Key.of_int (Key.to_int too_large - 1)
         in
         let fold_alist =
           access fold_range_inclusive t ~min ~max ~init:[] ~f:(fun ~key ~data acc ->
@@ -1386,155 +883,602 @@ module Test_creators_and_accessors
                 ~upper:upper_bound
                 ~compare:Key.compare)
         in
-        require_equal [%here] (module Alist) subrange_alist expect;
-        require_equal [%here] (module Alist) fold_alist expect;
-        require_equal [%here] (module Alist) range_alist expect)
-  ;;
+        require_equal (module Alist) fold_alist expect;
+        require_equal (module Alist) range_alist expect)
 
-  let closest_key = closest_key
+  and closest_key = closest_key
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key)
       ~f:(fun (t, k) ->
+        let t = Inst.value t in
         let alist = to_alist t in
         let rev_alist = List.rev alist in
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (access closest_key t `Less_than k)
           (List.find rev_alist ~f:(fun (key, _) -> Key.( < ) key k));
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (access closest_key t `Less_or_equal_to k)
           (List.find rev_alist ~f:(fun (key, _) -> Key.( <= ) key k));
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (access closest_key t `Greater_or_equal_to k)
           (List.find alist ~f:(fun (key, _) -> Key.( >= ) key k));
         require_equal
-          [%here]
-          (module Opt (Key_and_data))
+          (module Data.Option (Key_and_data))
           (access closest_key t `Greater_than k)
           (List.find alist ~f:(fun (key, _) -> Key.( > ) key k)))
-  ;;
 
-  let nth = nth
-  let nth_exn = nth_exn
-  let rank = rank
+  and nth = nth
+  and nth_exn = nth_exn
+  and rank = rank
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key)
       ~f:(fun (t, k) ->
+        let t = Inst.value t in
         List.iteri (to_alist t) ~f:(fun i (key, data) ->
-          require_equal [%here] (module Opt (Key_and_data)) (nth t i) (Some (key, data));
+          require_equal (module Data.Option (Key_and_data)) (nth t i) (Some (key, data));
           require_equal
-            [%here]
-            (module Opt (Key_and_data))
+            (module Data.Option (Key_and_data))
             (Option.try_with (fun () -> nth_exn t i))
             (nth t i);
-          require_equal [%here] (module Opt (Int)) (access rank t key) (Some i));
-        require_equal [%here] (module Opt (Key_and_data)) (nth t (length t)) None;
+          require_equal (module Data.Option (Int)) (access rank t key) (Some i));
+        require_equal (module Data.Option (Key_and_data)) (nth t (length t)) None;
         require_equal
-          [%here]
-          (module Opt (Int))
+          (module Data.Option (Int))
           (access rank t k)
           (List.find_mapi (to_alist t) ~f:(fun i (key, _) ->
              Option.some_if (Key.equal key k) i)))
-  ;;
 
-  let binary_search = binary_search
+  and binary_search = binary_search
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key)
       ~f:(fun (t, k) ->
+        let t = Inst.value t in
         let targets = [%all: Binary_searchable.Which_target_by_key.t] in
         let compare (key, _) k = Key.compare key k in
         List.iter targets ~f:(fun which_target ->
           require_equal
-            [%here]
-            (module Opt (Key_and_data))
+            (module Data.Option (Key_and_data))
             (access
                binary_search
                t
                ~compare:(fun ~key ~data k' ->
-                 require_equal [%here] (module Key) k' k;
-                 require_equal [%here] (module Opt (Int)) (access find t key) (Some data);
+                 require_equal (module Key) k' k;
+                 require_equal (module Data.Option (Int)) (access find t key) (Some data);
                  compare (key, data) k')
                which_target
                k)
             (let array = Array.of_list (to_alist t) in
              Array.binary_search array ~compare which_target k
+             |> [%globalize: int option]
              |> Option.map ~f:(Array.get array))))
-  ;;
 
-  let binary_search_segmented = binary_search_segmented
+  and binary_search_segmented = binary_search_segmented
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module Inst_and_key)
       ~f:(fun (t, k) ->
+        let t = Inst.value t in
         let targets = [%all: Binary_searchable.Which_target_by_segment.t] in
         let segment_of (key, _) = if Key.( <= ) key k then `Left else `Right in
         List.iter targets ~f:(fun which_target ->
           require_equal
-            [%here]
-            (module Opt (Key_and_data))
+            (module Data.Option (Key_and_data))
             (access
                binary_search_segmented
                t
                ~segment_of:(fun ~key ~data ->
-                 require_equal [%here] (module Opt (Int)) (access find t key) (Some data);
+                 require_equal (module Data.Option (Int)) (access find t key) (Some data);
                  segment_of (key, data))
                which_target)
             (let array = Array.of_list (to_alist t) in
              Array.binary_search_segmented array ~segment_of which_target
+             |> [%globalize: int option]
              |> Option.map ~f:(Array.get array))))
-  ;;
 
-  let binary_search_subrange = binary_search_subrange
+  and binary_search_subrange = binary_search_subrange
 
-  let () =
+  and () =
     quickcheck_m
-      [%here]
       (module struct
         type t = Inst.t * Key.t Maybe_bound.t * Key.t Maybe_bound.t
         [@@deriving quickcheck, sexp_of]
+
+        let sample = Memo.memoize [%generator: t]
       end)
       ~f:(fun (t, lower_bound, upper_bound) ->
+        let t = Inst.value t in
         require_equal
-          [%here]
-          (module Inst)
+          (module Inst.Value)
           (access
              binary_search_subrange
              t
              ~compare:(fun ~key ~data bound ->
-               require_equal [%here] (module Opt (Int)) (access find t key) (Some data);
+               require_equal (module Data.Option (Int)) (access find t key) (Some data);
                Key.compare key bound)
              ~lower_bound
              ~upper_bound)
           (access subrange t ~lower_bound ~upper_bound))
+
+  and to_tree = to_tree
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let tree = to_tree t in
+        let round_trip = create of_tree tree in
+        require_equal (module Inst.Value) t round_trip)
   ;;
+end
 
-  module Make_applicative_traversals (A : Applicative.Lazy_applicative) = struct
-    module M = Make_applicative_traversals (A)
+module Test_transformers
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) :
+  Transformers with module Types := Instance.Types = struct
+  open Instance
+  open Impl
+  open Test_helpers (Instance) (Impl)
 
-    let mapi = M.mapi
-    let filter_mapi = M.filter_mapi
-  end
+  module type Make_applicative_traversals = module type of Make_applicative_traversals
 
-  let () =
-    let module M =
-      Make_applicative_traversals (struct
-        module M = struct
+  let () = print_endline "Functor.Test_transformers: running tests."
+
+  (** transformers *)
+
+  and set = set
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_data)
+      ~f:(fun (t, key, data) ->
+        let t = Inst.value t in
+        require_equal
+          (module Alist)
+          (to_alist (access set t ~key ~data))
+          (List.sort
+             ~compare:(fun a b -> Comparable.lift Key.compare ~f:fst a b)
+             ((key, data) :: List.Assoc.remove (to_alist t) key ~equal:Key.equal)))
+
+  and add = add
+  and add_exn = add_exn
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_data)
+      ~f:(fun (t, key, data) ->
+        let t = Inst.value t in
+        let t_add =
+          match access add t ~key ~data with
+          | `Ok t -> Ok t
+          | `Duplicate -> Or_error.error_string "duplicate"
+        in
+        let t_add_exn = Or_error.try_with (fun () -> access add_exn t ~key ~data) in
+        let expect =
+          if access mem t key
+          then Or_error.error_string "duplicate"
+          else Ok (access set t ~key ~data)
+        in
+        require_equal (module Data.Or_error (Inst.Value)) t_add expect;
+        require_equal (module Data.Or_error (Inst.Value)) t_add_exn expect)
+
+  and remove = remove
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key)
+      ~f:(fun (t, key) ->
+        let t = Inst.value t in
+        require_equal
+          (module Alist)
+          (to_alist (access remove t key))
+          (List.Assoc.remove (to_alist t) key ~equal:Key.equal))
+
+  and change = change
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_maybe_data)
+      ~f:(fun (t, key, maybe_data) ->
+        let t = Inst.value t in
+        let actual =
+          access change t key ~f:(fun previous ->
+            require_equal (module Data.Option (Int)) previous (access find t key);
+            maybe_data)
+        in
+        let expect =
+          match maybe_data with
+          | None -> access remove t key
+          | Some data -> access set t ~key ~data
+        in
+        require_equal (module Inst.Value) actual expect)
+
+  and update = update
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_data)
+      ~f:(fun (t, key, data) ->
+        let t = Inst.value t in
+        let actual =
+          access update t key ~f:(fun previous ->
+            require_equal (module Data.Option (Int)) previous (access find t key);
+            data)
+        in
+        let expect = access set t ~key ~data in
+        require_equal (module Inst.Value) actual expect)
+
+  and add_multi = add_multi
+  and remove_multi = remove_multi
+
+  and () =
+    quickcheck_m
+      (module Inst_multi_and_key_and_data)
+      ~f:(fun (t, key, data) ->
+        let t = Inst_multi.value t in
+        require_equal
+          (module Inst_multi.Value)
+          (access add_multi t ~key ~data)
+          (access update t key ~f:(fun option -> data :: Option.value option ~default:[]));
+        require_equal
+          (module Inst_multi.Value)
+          (access remove_multi t key)
+          (access change t key ~f:(function
+            | None | Some ([] | [ _ ]) -> None
+            | Some (_ :: (_ :: _ as rest)) -> Some rest)))
+
+  and map = map
+  and mapi = mapi
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        require_equal
+          (module Inst.Value)
+          (map t ~f:Int.succ)
+          (t |> to_alist |> List.Assoc.map ~f:Int.succ |> create of_alist_exn);
+        require_equal
+          (module struct
+            type t = (Key.t * int) Instance.t [@@deriving equal, sexp_of]
+          end)
+          (mapi t ~f:(fun ~key ~data -> key, data))
+          (t |> to_alist |> List.map ~f:(fun (k, v) -> k, (k, v)) |> create of_alist_exn))
+
+  and filter_keys = filter_keys
+  and filter = filter
+  and filteri = filteri
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_data)
+      ~f:(fun (t, k, d) ->
+        let t = Inst.value t in
+        require_equal
+          (module Physical_equality (Inst.Value))
+          (filter ~f:(fun _ -> true) t)
+          t;
+        require_equal
+          (module Alist)
+          (to_alist (filter_keys t ~f:(fun key -> Key.( <= ) key k)))
+          (List.filter (to_alist t) ~f:(fun (key, _) -> Key.( <= ) key k));
+        require_equal
+          (module Alist)
+          (to_alist (filter t ~f:(fun data -> data <= d)))
+          (List.filter (to_alist t) ~f:(fun (_, data) -> data <= d));
+        require_equal
+          (module Alist)
+          (to_alist (filteri t ~f:(fun ~key ~data -> Key.( <= ) key k && data <= d)))
+          (List.filter (to_alist t) ~f:(fun (key, data) -> Key.( <= ) key k && data <= d)))
+
+  and filter_map = filter_map
+  and filter_mapi = filter_mapi
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_data)
+      ~f:(fun (t, k, d) ->
+        let t = Inst.value t in
+        require_equal
+          (module Alist)
+          (to_alist (filter_map t ~f:(fun data -> Option.some_if (data >= d) (data - d))))
+          (List.filter_map (to_alist t) ~f:(fun (key, data) ->
+             Option.some_if (data >= d) (key, data - d)));
+        require_equal
+          (module Alist)
+          (to_alist
+             (filter_mapi t ~f:(fun ~key ~data ->
+                Option.some_if (Key.( <= ) key k && data >= d) (data - d))))
+          (List.filter_map (to_alist t) ~f:(fun (key, data) ->
+             Option.some_if (Key.( <= ) key k && data >= d) (key, data - d))))
+
+  and partition_mapi = partition_mapi
+  and partition_map = partition_map
+  and partitioni_tf = partitioni_tf
+  and partition_tf = partition_tf
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key_and_data)
+      ~f:(fun (t, k, d) ->
+        let t = Inst.value t in
+        require_equal
+          (module Physical_equality (Inst.Value))
+          (fst (partition_tf ~f:(fun _ -> true) t))
+          t;
+        require_equal
+          (module Data.Pair (Alist))
+          (let a, b = partition_tf t ~f:(fun data -> data <= d) in
+           to_alist a, to_alist b)
+          (List.partition_tf (to_alist t) ~f:(fun (_, data) -> data <= d));
+        require_equal
+          (module Data.Pair (Alist))
+          (let a, b =
+             partitioni_tf t ~f:(fun ~key ~data -> Key.( <= ) key k && data <= d)
+           in
+           to_alist a, to_alist b)
+          (List.partition_tf (to_alist t) ~f:(fun (key, data) ->
+             Key.( <= ) key k && data <= d));
+        require_equal
+          (module Data.Pair (Alist))
+          (let a, b =
+             partition_map t ~f:(fun data ->
+               if data >= d then First (data - d) else Second d)
+           in
+           to_alist a, to_alist b)
+          (List.partition_map (to_alist t) ~f:(fun (key, data) ->
+             if data >= d then First (key, data - d) else Second (key, d)));
+        require_equal
+          (module Data.Pair (Alist))
+          (let a, b =
+             partition_mapi t ~f:(fun ~key ~data ->
+               if Key.( <= ) key k && data >= d then First (data - d) else Second d)
+           in
+           to_alist a, to_alist b)
+          (List.partition_map (to_alist t) ~f:(fun (key, data) ->
+             if Key.( <= ) key k && data >= d
+             then First (key, data - d)
+             else Second (key, d))))
+
+  and combine_errors = combine_errors
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key)
+      ~f:(fun (t, threshold) ->
+        let t = Inst.value t in
+        let t =
+          mapi t ~f:(fun ~key ~data ->
+            if Key.( <= ) key threshold then Ok data else Or_error.error_string "too big")
+        in
+        require_equal
+          (module Data.Or_error (Inst.Value))
+          (access combine_errors t)
+          (to_alist t
+           |> List.map ~f:(fun (key, result) ->
+             Or_error.map result ~f:(fun data -> key, data))
+           |> Or_error.combine_errors
+           |> Or_error.map ~f:(create of_alist_exn)))
+
+  and unzip = unzip
+
+  and () =
+    quickcheck_m
+      (module Inst_pair)
+      ~f:(fun t ->
+        let t = Inst_pair.value t in
+        require_equal
+          (module Data.Pair (Alist))
+          (let a, b = unzip t in
+           to_alist a, to_alist b)
+          (to_alist t
+           |> List.map ~f:(fun (key, (a, b)) -> (key, a), (key, b))
+           |> List.unzip))
+
+  and merge = merge
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst_and_key)
+      ~f:(fun ((a, b), k) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let merge_alist =
+          access merge a b ~f:(fun ~key elt ->
+            Option.some_if (Key.( > ) key k) (key, elt))
+          |> data
+        in
+        let expect =
+          [ map a ~f:Either.first; map b ~f:Either.second ]
+          |> List.concat_map ~f:to_alist
+          |> List.Assoc.sort_and_group ~compare:Key.compare
+          |> List.filter_map ~f:(fun (key, list) ->
+            let elt =
+              match (list : _ Either.t list) with
+              | [ First x ] -> `Left x
+              | [ Second y ] -> `Right y
+              | [ First x; Second y ] -> `Both (x, y)
+              | _ -> assert false
+            in
+            Option.some_if (Key.( > ) key k) (key, elt))
+        in
+        require_equal (module Alist_merge) merge_alist expect)
+
+  and merge_disjoint_exn = merge_disjoint_exn
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual = Option.try_with (fun () -> access merge_disjoint_exn a b) in
+        let expect =
+          if existsi a ~f:(fun ~key ~data:_ -> access mem b key)
+          then None
+          else
+            Some
+              (access merge a b ~f:(fun ~key:_ elt ->
+                 match elt with
+                 | `Left x | `Right x -> Some x
+                 | `Both _ -> assert false))
+        in
+        require_equal (module Data.Option (Inst.Value)) actual expect)
+
+  and merge_skewed = merge_skewed
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual =
+          access merge_skewed a b ~combine:(fun ~key a b -> Key.to_int key + a + b)
+        in
+        let expect =
+          access merge a b ~f:(fun ~key elt ->
+            match elt with
+            | `Left a -> Some a
+            | `Right b -> Some b
+            | `Both (a, b) -> Some (Key.to_int key + a + b))
+        in
+        require_equal (module Inst.Value) actual expect)
+
+  and split = split
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key)
+      ~f:(fun (t, k) ->
+        let t = Inst.value t in
+        require_equal
+          (module struct
+            type t = Inst.Value.t * (Key.t * int) option * Inst.Value.t
+            [@@deriving equal, sexp_of]
+          end)
+          (access split t k)
+          (let before, equal, after =
+             List.partition3_map (to_alist t) ~f:(fun (key, data) ->
+               match Ordering.of_int (Key.compare key k) with
+               | Less -> `Fst (key, data)
+               | Equal -> `Snd (key, data)
+               | Greater -> `Trd (key, data))
+           in
+           create of_alist_exn before, List.hd equal, create of_alist_exn after))
+
+  and split_le_gt = split_le_gt
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key)
+      ~f:(fun (t, k) ->
+        let t = Inst.value t in
+        require_equal
+          (module struct
+            type t = Inst.Value.t * Inst.Value.t [@@deriving equal, sexp_of]
+          end)
+          (access split_le_gt t k)
+          (let before, after =
+             List.partition_tf (to_alist t) ~f:(fun (key, _) -> Key.( <= ) key k)
+           in
+           create of_alist_exn before, create of_alist_exn after))
+
+  and split_lt_ge = split_lt_ge
+
+  and () =
+    quickcheck_m
+      (module Inst_and_key)
+      ~f:(fun (t, k) ->
+        let t = Inst.value t in
+        require_equal
+          (module struct
+            type t = Inst.Value.t * Inst.Value.t [@@deriving equal, sexp_of]
+          end)
+          (access split_lt_ge t k)
+          (let before, after =
+             List.partition_tf (to_alist t) ~f:(fun (key, _) -> Key.( < ) key k)
+           in
+           create of_alist_exn before, create of_alist_exn after))
+
+  and append = append
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        require_equal
+          (module Data.Or_error (Inst.Value))
+          (match access append ~lower_part:a ~upper_part:b with
+           | `Ok t -> Ok t
+           | `Overlapping_key_ranges -> Or_error.error_string "overlap")
+          (match max_elt a, min_elt b with
+           | Some (x, _), Some (y, _) when Key.( >= ) x y ->
+             Or_error.error_string "overlap"
+           | _ -> Ok (create of_alist_exn (to_alist a @ to_alist b)));
+        let a' =
+          (* we rely on the fact that the [Inst] generator uses positive keys *)
+          create map_keys_exn a ~f:(fun k -> Key.of_int (-Key.to_int k))
+        in
+        require_equal
+          (module Data.Or_error (Inst.Value))
+          (match access append ~lower_part:a' ~upper_part:b with
+           | `Ok t -> Ok t
+           | `Overlapping_key_ranges -> Or_error.error_string "overlap")
+          (Ok (create of_alist_exn (to_alist a' @ to_alist b))))
+
+  and subrange = subrange
+
+  and () =
+    quickcheck_m
+      (module Inst_and_bounds)
+      ~f:(fun (t, lower_bound, upper_bound) ->
+        let t = Inst.value t in
+        let subrange_alist = access subrange t ~lower_bound ~upper_bound |> to_alist in
+        let expect =
+          if Maybe_bound.bounds_crossed
+               ~lower:lower_bound
+               ~upper:upper_bound
+               ~compare:Key.compare
+          then []
+          else
+            List.filter (to_alist t) ~f:(fun (key, _) ->
+              Maybe_bound.interval_contains_exn
+                key
+                ~lower:lower_bound
+                ~upper:upper_bound
+                ~compare:Key.compare)
+        in
+        require_equal (module Alist) subrange_alist expect)
+
+  and m_Make_applicative_traversals : (module Make_applicative_traversals) =
+    (module functor
+              (A : Applicative.Lazy_applicative)
+              ->
+              struct
+                module M = Make_applicative_traversals (A)
+
+                let mapi = M.mapi
+                let filter_mapi = M.filter_mapi
+              end)
+
+  and () =
+    let module M =
+      Make_applicative_traversals (struct
+        module M = struct
           type 'a t = 'a
 
           let return x = x
@@ -1548,32 +1492,14 @@ module Test_creators_and_accessors
       end)
     in
     quickcheck_m
-      [%here]
       (module Inst)
       ~f:(fun t ->
+        let t = Inst.value t in
         let f1 ~key:_ ~data = (data * 2) + 1 in
         let f2 ~key:_ ~data = if data < 0 then None else Some data in
-        require_equal [%here] (module Inst) (mapi t ~f:f1) (M.mapi t ~f:f1);
-        require_equal [%here] (module Inst) (filter_mapi t ~f:f2) (M.filter_mapi t ~f:f2))
+        require_equal (module Inst.Value) (mapi t ~f:f1) (M.mapi t ~f:f1);
+        require_equal (module Inst.Value) (filter_mapi t ~f:f2) (M.filter_mapi t ~f:f2))
   ;;
 
-  (** tree conversion *)
-
-  let to_tree = to_tree
-  let of_tree = of_tree
-
-  let () =
-    quickcheck_m
-      [%here]
-      (module Inst)
-      ~f:(fun t ->
-        let tree = to_tree t in
-        let round_trip = create of_tree tree in
-        require_equal [%here] (module Inst) t round_trip;
-        require_equal
-          [%here]
-          (module Alist)
-          (to_alist t)
-          (Map.Using_comparator.Tree.to_alist (Instance.tree tree)))
-  ;;
+  module Make_applicative_traversals = (val m_Make_applicative_traversals)
 end
diff --git a/test/map_full_interface/functor.mli b/test/coverage/map/functor.mli
similarity index 100%
rename from test/map_full_interface/functor.mli
rename to test/coverage/map/functor.mli
diff --git a/test/coverage/map/functor_intf.ml b/test/coverage/map/functor_intf.ml
new file mode 100644
index 00000000..eb293e97
--- /dev/null
+++ b/test/coverage/map/functor_intf.ml
@@ -0,0 +1,137 @@
+open! Base
+open Base_test_coverage_helpers
+
+module Definitions = struct
+  (** The types that distinguish instances of
+      [Map.Creators_and_accessors_and_transformers_generic]. *)
+  module type Types = sig
+    type 'k key
+    type 'c cmp
+    type ('k, 'v, 'c) t
+    type ('k, 'v, 'c) tree
+    type ('k, 'c, 'a) create_options
+    type ('k, 'c, 'a) access_options
+  end
+
+  (** Like [Map.Creators_generic], but based on [Types] for easier instantiation. *)
+  module type Creators = sig
+    module Types : Types
+
+    include
+      Map.Creators_generic
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) Types.t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Types.tree
+      with type 'a key := 'a Types.key
+      with type 'a cmp := 'a Types.cmp
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Types.create_options
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Types.access_options
+  end
+
+  (** Like [Map.Accessors_generic], but based on [Types] for easier instantiation. *)
+  module type Accessors = sig
+    module Types : Types
+
+    include
+      Map.Accessors_generic
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) Types.t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Types.tree
+      with type 'a key := 'a Types.key
+      with type 'a cmp := 'a Types.cmp
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Types.access_options
+  end
+
+  (** Like [Map.Transformers_generic], but based on [Types] for easier instantiation. *)
+  module type Transformers = sig
+    module Types : Types
+
+    include
+      Map.Transformers_generic
+      with type ('a, 'b, 'c) t := ('a, 'b, 'c) Types.t
+      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Types.tree
+      with type 'a key := 'a Types.key
+      with type 'a cmp := 'a Types.cmp
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Types.access_options
+  end
+
+  (** Like [Map.Creators_and_accessors_and_transformers_generic], but based on [Types] for
+      easier instantiation. *)
+  module type Impl = sig
+    module Types : Types
+    include Creators with module Types := Types
+    include Accessors with module Types := Types
+    include Transformers with module Types := Types
+  end
+
+  module type Key = sig
+    module Types : Types
+
+    type t = int Types.key [@@deriving compare, equal, quickcheck, sexp_of]
+
+    include Comparable.Infix with type t := t
+
+    include
+      Comparator.S
+      with type t := t
+       and type comparator_witness = Int.comparator_witness Types.cmp
+
+    val of_int : int -> t
+    val to_int : t -> int
+  end
+
+  (** Helpers for testing a tree or map type that is an instance of [S]. *)
+  module type Instance = sig
+    module Types : Types
+    module Key : Key with module Types := Types
+
+    type 'a t = (int, 'a, Int.comparator_witness) Types.t
+    [@@deriving compare, equal, sexp_of]
+
+    (** Pass a comparator to a creator function, if necessary. *)
+    val create : (int, Int.comparator_witness, 'a) Types.create_options -> 'a
+
+    (** Pass a comparator to an accessor function, if necessary *)
+    val access : (int, Int.comparator_witness, 'a) Types.access_options -> 'a
+  end
+
+  module type Generate = sig
+    module Instance : Instance
+    module Data : Data.S
+
+    type t [@@deriving equal, quickcheck, sexp_of]
+
+    module Value : sig
+      type t = Data.t Instance.t [@@deriving compare, equal, sexp_of]
+    end
+
+    val value : t -> Value.t
+  end
+end
+
+module type Functor = sig
+  include module type of struct
+    include Definitions
+  end
+
+  (** Expect tests for everything exported from [Map.Creators_generic]. *)
+  module Test_creators
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Creators with module Types := Instance.Types
+
+  (** Expect tests for everything exported from [Map.Accessors_generic]. *)
+  module Test_accessors
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Accessors with module Types := Instance.Types
+
+  (** Expect tests for everything exported from [Map.Transformers_generic]. *)
+  module Test_transformers
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Transformers with module Types := Instance.Types
+
+  module Generate
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types)
+      (Data : Data.S) : Generate with module Instance := Instance and module Data := Data
+end
diff --git a/test/coverage/map/instances.ml b/test/coverage/map/instances.ml
new file mode 100644
index 00000000..2ae1eba3
--- /dev/null
+++ b/test/coverage/map/instances.ml
@@ -0,0 +1,64 @@
+open! Base
+open Base_quickcheck
+open Base_test_coverage_helpers
+open Overrides
+include Instances_intf.Definitions
+
+module Make_key
+    (Types : Functor.Types with type 'key key = 'key)
+    (Cmp : sig
+       val comparator : (int, Int.comparator_witness Types.cmp) Comparator.t
+     end) : Functor.Key with module Types := Types = struct
+  type t = int [@@deriving compare, equal, quickcheck, sexp_of]
+  type comparator_witness = Int.comparator_witness Types.cmp
+
+  let comparator = Cmp.comparator
+
+  include (Int : Comparable.Infix with type t := t)
+
+  let of_int = Fn.id
+  let to_int = Fn.id
+end
+
+module Poly = struct
+  module Types = Types.Poly
+  module Key = Make_key (Types) (Comparator.Poly)
+
+  type 'a t = 'a Map.M(Key).t [@@deriving compare, equal, sexp_of]
+
+  let create x = x
+  let access x = x
+end
+
+module Toplevel = struct
+  module Types = Types.Toplevel
+  module Key = Make_key (Types) (Int)
+
+  type 'a t = 'a Map.M(Key).t [@@deriving compare, equal, sexp_of]
+
+  let create f = f ((module Int) : _ Comparator.Module.t)
+  let access x = x
+end
+
+module Tree = struct
+  module Types = Types.Tree
+  module Key = Make_key (Types) (Int)
+
+  type 'a t = (int, 'a, Int.comparator_witness) Types.t
+
+  let compare f = Comparable.lift (Toplevel.compare f) ~f:(Map.of_tree (module Key))
+  let equal f = Comparable.lift (Toplevel.equal f) ~f:(Map.of_tree (module Key))
+  let sexp_of_t f t = Toplevel.sexp_of_t f (Map.of_tree (module Key) t)
+  let create f = f ~comparator:Int.comparator
+  let access f = f ~comparator:Int.comparator
+end
+
+module Using_comparator = struct
+  module Types = Types.Using_comparator
+  module Key = Make_key (Types) (Int)
+
+  type 'a t = 'a Map.M(Key).t [@@deriving compare, equal, sexp_of]
+
+  let create f = f ~comparator:Int.comparator
+  let access x = x
+end
diff --git a/test/coverage/map/instances.mli b/test/coverage/map/instances.mli
new file mode 100644
index 00000000..174eeb6e
--- /dev/null
+++ b/test/coverage/map/instances.mli
@@ -0,0 +1 @@
+include Instances_intf.Instances
diff --git a/test/coverage/map/instances_intf.ml b/test/coverage/map/instances_intf.ml
new file mode 100644
index 00000000..9a3956d6
--- /dev/null
+++ b/test/coverage/map/instances_intf.ml
@@ -0,0 +1,52 @@
+open! Base
+
+module Definitions = struct
+  module Types = struct
+    module Poly = struct
+      type 'key key = 'key
+      type 'cmp cmp = Comparator.Poly.comparator_witness
+      type ('key, 'data, 'cmp) t = ('key, 'data) Map.Poly.t
+      type ('key, 'data, 'cmp) tree = ('key, 'data) Map.Poly.tree
+      type ('key, 'cmp, 'fn) create_options = 'fn
+      type ('key, 'cmp, 'fn) access_options = 'fn
+    end
+
+    module Toplevel = struct
+      type 'key key = 'key
+      type 'cmp cmp = 'cmp
+      type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.t
+      type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
+      type ('key, 'cmp, 'fn) create_options = ('key, 'cmp) Comparator.Module.t -> 'fn
+      type ('key, 'cmp, 'fn) access_options = 'fn
+    end
+
+    module Tree = struct
+      type 'key key = 'key
+      type 'cmp cmp = 'cmp
+      type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
+      type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
+      type ('key, 'cmp, 'fn) create_options = comparator:('key, 'cmp) Comparator.t -> 'fn
+      type ('key, 'cmp, 'fn) access_options = comparator:('key, 'cmp) Comparator.t -> 'fn
+    end
+
+    module Using_comparator = struct
+      type 'key key = 'key
+      type 'cmp cmp = 'cmp
+      type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.Using_comparator.t
+      type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
+      type ('key, 'cmp, 'fn) create_options = comparator:('key, 'cmp) Comparator.t -> 'fn
+      type ('key, 'cmp, 'fn) access_options = 'fn
+    end
+  end
+end
+
+module type Instances = sig
+  include module type of struct
+    include Definitions
+  end
+
+  module Poly : Functor.Instance with module Types = Types.Poly
+  module Toplevel : Functor.Instance with module Types = Types.Toplevel
+  module Tree : Functor.Instance with module Types = Types.Tree
+  module Using_comparator : Functor.Instance with module Types = Types.Using_comparator
+end
diff --git a/test/map_full_interface/test_all.ml b/test/coverage/map/test_all.ml
similarity index 67%
rename from test/map_full_interface/test_all.ml
rename to test/coverage/map/test_all.ml
index be1c303b..b65734eb 100644
--- a/test/map_full_interface/test_all.ml
+++ b/test/coverage/map/test_all.ml
@@ -1,22 +1,40 @@
 open! Base
 open Base_quickcheck
 open Expect_test_helpers_base
+open Base_test_coverage_helpers
 open Functor
 open Map
+open Overrides
 
 open struct
   (** Instantiating key and data both as [int]. *)
   module Instance_int = struct
-    module I = Instance (Int)
+    include Generate (Instances.Toplevel) (Base.Map) (Data.Int)
 
-    type t = int I.t [@@deriving equal, quickcheck, sexp_of]
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Instance_int_pair = struct
+    include Data.Pair (Instance_int)
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Tree_int = struct
+    include Generate (Instances.Tree) (Base.Map.Using_comparator.Tree) (Data.Int)
+
+    let sample = Memo.memoize [%generator: t]
   end
 end
 
 (** module types *)
 
 module type Accessors_generic = Accessors_generic
-module type Creators_and_accessors_generic = Creators_and_accessors_generic
+module type Transformers_generic = Transformers_generic
+
+module type Creators_and_accessors_and_transformers_generic =
+  Creators_and_accessors_and_transformers_generic
+
 module type Creators_generic = Creators_generic
 module type For_deriving = For_deriving
 module type S_poly = S_poly
@@ -35,6 +53,10 @@ module Merge_element = Merge_element
 module Or_duplicate = Or_duplicate
 module Symmetric_diff_element = Symmetric_diff_element
 
+(** private exports - untested *)
+
+module Private = Private [@@alert "-map_private"]
+
 (** types *)
 
 type nonrec ('k, 'v, 'c) t = ('k, 'v, 'c) t
@@ -59,13 +81,13 @@ let m__t_of_sexp = m__t_of_sexp
 
 let%expect_test _ =
   quickcheck_m
-    [%here]
     (module Instance_int)
     ~f:(fun t ->
+      let t = Instance_int.value t in
       let sexp = [%sexp_of: int M(Int).t] t in
-      require_equal [%here] (module Sexp) sexp [%sexp (to_alist t : (int * int) list)];
+      require_equal (module Sexp) sexp [%sexp (to_alist t : (int * int) list)];
       let round_trip = [%of_sexp: int M(Int).t] sexp in
-      require_equal [%here] (module Instance_int) round_trip t);
+      require_equal (module Instance_int.Value) round_trip t);
   [%expect {| |}]
 ;;
 
@@ -98,16 +120,15 @@ let equal_m__t = equal_m__t
 
 let%expect_test _ =
   quickcheck_m
-    [%here]
-    (module Pair (Instance_int))
+    (module Instance_int_pair)
     ~f:(fun (a, b) ->
+      let a = Instance_int.value a in
+      let b = Instance_int.value b in
       require_equal
-        [%here]
         (module Ordering)
         (Ordering.of_int ([%compare: int M(Int).t] a b))
         (Ordering.of_int ([%compare: (int * int) list] (to_alist a) (to_alist b)));
       require_equal
-        [%here]
         (module Bool)
         ([%equal: int M(Int).t] a b)
         ([%equal: (int * int) list] (to_alist a) (to_alist b)));
@@ -121,14 +142,14 @@ let hash_fold_direct = hash_fold_direct
 
 let%expect_test _ =
   quickcheck_m
-    [%here]
     (module Instance_int)
     ~f:(fun t ->
+      let t = Instance_int.value t in
       let actual_m = Hash.run [%hash_fold: int M(Int).t] t in
       let actual_direct = Hash.run (hash_fold_direct Int.hash_fold_t Int.hash_fold_t) t in
       let expect = Hash.run [%hash_fold: (int * int) list] (to_alist t) in
-      require_equal [%here] (module Int) actual_m expect;
-      require_equal [%here] (module Int) actual_direct expect);
+      require_equal (module Int) actual_m expect;
+      require_equal (module Int) actual_direct expect);
   [%expect {| |}]
 ;;
 
@@ -137,9 +158,18 @@ let%expect_test _ =
 let comparator_s = comparator_s
 let comparator = comparator
 
-(** creators and accessors *)
+(** creators and accessors and transformers *)
+
+include (
+  Test_toplevel_accessors :
+    Functor.Accessors with module Types := Instances.Types.Toplevel)
 
-include (Test_toplevel : Test_toplevel.S)
+include (
+  Test_toplevel_creators : Functor.Creators with module Types := Instances.Types.Toplevel)
+
+include (
+  Test_toplevel_transformers :
+    Functor.Transformers with module Types := Instances.Types.Toplevel)
 
 (** polymorphic comparison interface *)
 module Poly = struct
@@ -149,7 +179,15 @@ module Poly = struct
   type nonrec ('k, 'v) tree = ('k, 'v) tree
   type nonrec comparator_witness = comparator_witness
 
-  include (Test_poly : Test_poly.S)
+  include (
+    Test_poly_accessors : Functor.Accessors with module Types := Instances.Types.Poly)
+
+  include (
+    Test_poly_creators : Functor.Creators with module Types := Instances.Types.Poly)
+
+  include (
+    Test_poly_transformers :
+      Functor.Transformers with module Types := Instances.Types.Poly)
 end
 
 (** comparator interface *)
@@ -172,15 +210,15 @@ module Using_comparator = struct
 
   let%expect_test _ =
     quickcheck_m
-      [%here]
       (module Instance_int)
       ~f:(fun t ->
+        let t = Instance_int.value t in
         let sexp = sexp_of_t Int.sexp_of_t Int.sexp_of_t [%sexp_of: _] t in
-        require_equal [%here] (module Sexp) sexp ([%sexp_of: int Map.M(Int).t] t);
+        require_equal (module Sexp) sexp ([%sexp_of: int Map.M(Int).t] t);
         let round_trip =
           t_of_sexp_direct ~comparator:Int.comparator Int.t_of_sexp Int.t_of_sexp sexp
         in
-        require_equal [%here] (module Instance_int) round_trip t);
+        require_equal (module Instance_int.Value) round_trip t);
     [%expect {| |}]
   ;;
 
@@ -190,11 +228,10 @@ module Using_comparator = struct
 
   let%expect_test _ =
     quickcheck_m
-      [%here]
       (module Instance_int)
       ~f:(fun t ->
+        let t = Instance_int.value t in
         require_equal
-          [%here]
           (module Int)
           (Hash.run (hash_fold_direct Int.hash_fold_t Int.hash_fold_t) t)
           (Hash.run [%hash_fold: int Map.M(Int).t] t));
@@ -209,9 +246,19 @@ module Using_comparator = struct
     let empty = empty
   end
 
-  (** creators and accessors *)
+  (** creators and accessors and transformers *)
 
-  include (Test_using_comparator : Test_using_comparator.S)
+  include (
+    Test_using_comparator_accessors :
+      Functor.Accessors with module Types := Instances.Types.Using_comparator)
+
+  include (
+    Test_using_comparator_creators :
+      Functor.Creators with module Types := Instances.Types.Using_comparator)
+
+  include (
+    Test_using_comparator_transformers :
+      Functor.Transformers with module Types := Instances.Types.Using_comparator)
 
   (** tree interface *)
 
@@ -228,19 +275,12 @@ module Using_comparator = struct
     let t_of_sexp_direct = t_of_sexp_direct
 
     let%expect_test _ =
-      let module Tree_int = struct
-        module I = Instance_tree (Int)
-
-        type t = int I.t [@@deriving equal, quickcheck, sexp_of]
-      end
-      in
       quickcheck_m
-        [%here]
         (module Tree_int)
         ~f:(fun tree ->
+          let tree = Tree_int.value tree in
           let sexp = sexp_of_t Int.sexp_of_t Int.sexp_of_t [%sexp_of: _] tree in
           require_equal
-            [%here]
             (module Sexp)
             sexp
             ([%sexp_of: int Map.M(Int).t]
@@ -248,7 +288,7 @@ module Using_comparator = struct
           let round_trip =
             t_of_sexp_direct ~comparator:Int.comparator Int.t_of_sexp Int.t_of_sexp sexp
           in
-          require_equal [%here] (module Tree_int) round_trip tree);
+          require_equal (module Tree_int.Value) round_trip tree);
       [%expect {| |}]
     ;;
 
@@ -270,20 +310,15 @@ module Using_comparator = struct
       let to_tree = to_tree
 
       let%expect_test _ =
-        let module Tree_int = struct
-          module I = Instance_tree (Int)
-
-          type t = int I.t [@@deriving equal, quickcheck, sexp_of]
-        end
-        in
         quickcheck_m
-          [%here]
           (module struct
             type t =
               ((int[@generator Base_quickcheck.Generator.small_strictly_positive_int])
               * int)
-              list
+                list
             [@@deriving quickcheck, sexp_of]
+
+            let sample = Memo.memoize [%generator: t]
           end)
           ~f:(fun alist ->
             let actual =
@@ -293,7 +328,7 @@ module Using_comparator = struct
               |> Or_error.map ~f:to_tree
             in
             Or_error.iter actual ~f:(fun map ->
-              require [%here] (Tree.invariants map ~comparator:Int.comparator));
+              require (Tree.invariants map ~comparator:Int.comparator));
             let expect =
               match List.is_sorted_strictly alist ~compare:[%compare: int * _] with
               | false -> Error (Error.of_string "not sorted")
@@ -303,13 +338,21 @@ module Using_comparator = struct
                      ~comparator:Int.comparator
                      (Sequence.of_list alist))
             in
-            require_equal [%here] (module Ok (Tree_int)) actual expect);
+            require_equal (module Data.Or_error (Tree_int.Value)) actual expect);
         [%expect {| |}]
       ;;
     end
 
-    (** creators and accessors *)
+    (** creators and accessors and transformers *)
+
+    include (
+      Test_tree_accessors : Functor.Accessors with module Types := Instances.Types.Tree)
+
+    include (
+      Test_tree_creators : Functor.Creators with module Types := Instances.Types.Tree)
 
-    include (Test_tree : Test_tree.S)
+    include (
+      Test_tree_transformers :
+        Functor.Transformers with module Types := Instances.Types.Tree)
   end
 end
diff --git a/test/map_full_interface/test_all.mli b/test/coverage/map/test_all.mli
similarity index 100%
rename from test/map_full_interface/test_all.mli
rename to test/coverage/map/test_all.mli
diff --git a/test/coverage/map/test_poly_accessors.ml b/test/coverage/map/test_poly_accessors.ml
new file mode 100644
index 00000000..d395f1b7
--- /dev/null
+++ b/test/coverage/map/test_poly_accessors.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map.Poly
+
+let%expect_test "[Base.Map.Poly] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Poly) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (Implementation : Functor.Accessors with module Types := Instances.Types.Poly)
diff --git a/test/coverage/map/test_poly_accessors.mli b/test/coverage/map/test_poly_accessors.mli
new file mode 100644
index 00000000..bec58887
--- /dev/null
+++ b/test/coverage/map/test_poly_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Poly
diff --git a/test/coverage/map/test_poly_creators.ml b/test/coverage/map/test_poly_creators.ml
new file mode 100644
index 00000000..c32cb9aa
--- /dev/null
+++ b/test/coverage/map/test_poly_creators.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map.Poly
+
+let%expect_test "[Base.Map.Poly] creators/accessors" =
+  let open Functor.Test_creators (Instances.Poly) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (Implementation : Functor.Creators with module Types := Instances.Types.Poly)
diff --git a/test/coverage/map/test_poly_creators.mli b/test/coverage/map/test_poly_creators.mli
new file mode 100644
index 00000000..69ba2e87
--- /dev/null
+++ b/test/coverage/map/test_poly_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Poly
diff --git a/test/coverage/map/test_poly_transformers.ml b/test/coverage/map/test_poly_transformers.ml
new file mode 100644
index 00000000..089aec9f
--- /dev/null
+++ b/test/coverage/map/test_poly_transformers.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map.Poly
+
+let%expect_test "[Base.Map.Poly] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Poly) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (Implementation : Functor.Transformers with module Types := Instances.Types.Poly)
diff --git a/test/coverage/map/test_poly_transformers.mli b/test/coverage/map/test_poly_transformers.mli
new file mode 100644
index 00000000..e157a8d2
--- /dev/null
+++ b/test/coverage/map/test_poly_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Poly
diff --git a/test/coverage/map/test_toplevel_accessors.ml b/test/coverage/map/test_toplevel_accessors.ml
new file mode 100644
index 00000000..c5ce7cc2
--- /dev/null
+++ b/test/coverage/map/test_toplevel_accessors.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map
+
+let%expect_test "[Base.Map] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Toplevel) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (Implementation : Functor.Accessors with module Types := Instances.Types.Toplevel)
diff --git a/test/coverage/map/test_toplevel_accessors.mli b/test/coverage/map/test_toplevel_accessors.mli
new file mode 100644
index 00000000..f45b2b7a
--- /dev/null
+++ b/test/coverage/map/test_toplevel_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Toplevel
diff --git a/test/coverage/map/test_toplevel_creators.ml b/test/coverage/map/test_toplevel_creators.ml
new file mode 100644
index 00000000..ec996c8f
--- /dev/null
+++ b/test/coverage/map/test_toplevel_creators.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map
+
+let%expect_test "[Base.Map] creators/accessors" =
+  let open Functor.Test_creators (Instances.Toplevel) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (Implementation : Functor.Creators with module Types := Instances.Types.Toplevel)
diff --git a/test/coverage/map/test_toplevel_creators.mli b/test/coverage/map/test_toplevel_creators.mli
new file mode 100644
index 00000000..a270f003
--- /dev/null
+++ b/test/coverage/map/test_toplevel_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Toplevel
diff --git a/test/coverage/map/test_toplevel_transformers.ml b/test/coverage/map/test_toplevel_transformers.ml
new file mode 100644
index 00000000..87b5f0b0
--- /dev/null
+++ b/test/coverage/map/test_toplevel_transformers.ml
@@ -0,0 +1,10 @@
+open! Base
+module Implementation = Base.Map
+
+let%expect_test "[Base.Map] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Toplevel) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (
+  Implementation : Functor.Transformers with module Types := Instances.Types.Toplevel)
diff --git a/test/coverage/map/test_toplevel_transformers.mli b/test/coverage/map/test_toplevel_transformers.mli
new file mode 100644
index 00000000..b63f012b
--- /dev/null
+++ b/test/coverage/map/test_toplevel_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Toplevel
diff --git a/test/coverage/map/test_tree_accessors.ml b/test/coverage/map/test_tree_accessors.ml
new file mode 100644
index 00000000..7a724a13
--- /dev/null
+++ b/test/coverage/map/test_tree_accessors.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map.Using_comparator.Tree
+
+let%expect_test "[Base.Map.Using_comparator.Tree] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Tree) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (Implementation : Functor.Accessors with module Types := Instances.Types.Tree)
diff --git a/test/coverage/map/test_tree_accessors.mli b/test/coverage/map/test_tree_accessors.mli
new file mode 100644
index 00000000..7a3442d9
--- /dev/null
+++ b/test/coverage/map/test_tree_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Tree
diff --git a/test/coverage/map/test_tree_creators.ml b/test/coverage/map/test_tree_creators.ml
new file mode 100644
index 00000000..580bd59c
--- /dev/null
+++ b/test/coverage/map/test_tree_creators.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map.Using_comparator.Tree
+
+let%expect_test "[Base.Map.Using_comparator.Tree] creators/accessors" =
+  let open Functor.Test_creators (Instances.Tree) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (Implementation : Functor.Creators with module Types := Instances.Types.Tree)
diff --git a/test/coverage/map/test_tree_creators.mli b/test/coverage/map/test_tree_creators.mli
new file mode 100644
index 00000000..661a0bef
--- /dev/null
+++ b/test/coverage/map/test_tree_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Tree
diff --git a/test/coverage/map/test_tree_transformers.ml b/test/coverage/map/test_tree_transformers.ml
new file mode 100644
index 00000000..6234a723
--- /dev/null
+++ b/test/coverage/map/test_tree_transformers.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Map.Using_comparator.Tree
+
+let%expect_test "[Base.Map.Using_comparator.Tree] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Tree) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (Implementation : Functor.Transformers with module Types := Instances.Types.Tree)
diff --git a/test/coverage/map/test_tree_transformers.mli b/test/coverage/map/test_tree_transformers.mli
new file mode 100644
index 00000000..092966d7
--- /dev/null
+++ b/test/coverage/map/test_tree_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Tree
diff --git a/test/coverage/map/test_using_comparator_accessors.ml b/test/coverage/map/test_using_comparator_accessors.ml
new file mode 100644
index 00000000..4f1075c3
--- /dev/null
+++ b/test/coverage/map/test_using_comparator_accessors.ml
@@ -0,0 +1,10 @@
+open! Base
+module Implementation = Base.Map.Using_comparator
+
+let%expect_test "[Base.Map.Using_comparator] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Using_comparator) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (
+  Implementation : Functor.Accessors with module Types := Instances.Types.Using_comparator)
diff --git a/test/coverage/map/test_using_comparator_accessors.mli b/test/coverage/map/test_using_comparator_accessors.mli
new file mode 100644
index 00000000..7e7118b4
--- /dev/null
+++ b/test/coverage/map/test_using_comparator_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Using_comparator
diff --git a/test/coverage/map/test_using_comparator_creators.ml b/test/coverage/map/test_using_comparator_creators.ml
new file mode 100644
index 00000000..0c2f61a3
--- /dev/null
+++ b/test/coverage/map/test_using_comparator_creators.ml
@@ -0,0 +1,10 @@
+open! Base
+module Implementation = Base.Map.Using_comparator
+
+let%expect_test "[Base.Map.Using_comparator] creators/accessors" =
+  let open Functor.Test_creators (Instances.Using_comparator) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (
+  Implementation : Functor.Creators with module Types := Instances.Types.Using_comparator)
diff --git a/test/coverage/map/test_using_comparator_creators.mli b/test/coverage/map/test_using_comparator_creators.mli
new file mode 100644
index 00000000..aa3fd102
--- /dev/null
+++ b/test/coverage/map/test_using_comparator_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Using_comparator
diff --git a/test/coverage/map/test_using_comparator_transformers.ml b/test/coverage/map/test_using_comparator_transformers.ml
new file mode 100644
index 00000000..b35ff8f4
--- /dev/null
+++ b/test/coverage/map/test_using_comparator_transformers.ml
@@ -0,0 +1,11 @@
+open! Base
+module Implementation = Base.Map.Using_comparator
+
+let%expect_test "[Base.Map.Using_comparator] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Using_comparator) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (
+  Implementation :
+    Functor.Transformers with module Types := Instances.Types.Using_comparator)
diff --git a/test/coverage/map/test_using_comparator_transformers.mli b/test/coverage/map/test_using_comparator_transformers.mli
new file mode 100644
index 00000000..3a8f6d69
--- /dev/null
+++ b/test/coverage/map/test_using_comparator_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Using_comparator
diff --git a/test/coverage/set/base_test_coverage_set.ml b/test/coverage/set/base_test_coverage_set.ml
new file mode 100644
index 00000000..9b28931c
--- /dev/null
+++ b/test/coverage/set/base_test_coverage_set.ml
@@ -0,0 +1 @@
+(*_ This library deliberately exports nothing. *)
diff --git a/test/coverage/set/constructor.ml b/test/coverage/set/constructor.ml
new file mode 100644
index 00000000..7bad4b1d
--- /dev/null
+++ b/test/coverage/set/constructor.ml
@@ -0,0 +1,990 @@
+open! Base
+open Base_quickcheck
+open Expect_test_helpers_base
+open Base_test_coverage_helpers
+open Functor_intf.Definitions
+open Overrides
+
+let sort_either_direction list ~compare =
+  match list with
+  | [] | [ _ ] -> list
+  | a :: b :: _ ->
+    if compare a b > 0
+    then List.sort list ~compare:(Comparable.reverse compare)
+    else List.sort list ~compare
+;;
+
+(* Set operations allow overlap, since unlike maps two identical keys do not potentially
+   carry different data. But we want to sometimes force no overlap to consider larger
+   sets. So for operations that allow overlap, we sometimes randomly disallow it. This is
+   enforced in the [normalize] operation, below. *)
+module Overlap = struct
+  type t =
+    | Allow_overlap
+    | Disallow_overlap
+  [@@deriving equal, quickcheck, sexp_of]
+end
+
+module Side = struct
+  type t =
+    | Left
+    | Right
+  [@@deriving equal, quickcheck, sexp_of]
+
+  let select t (a, b) =
+    match t with
+    | Left -> a
+    | Right -> b
+  ;;
+
+  let select3 t (a, _, b) =
+    match t with
+    | Left -> a
+    | Right -> b
+  ;;
+end
+
+module Constructor = struct
+  let rec_weight = 4.
+
+  type 'elt t =
+    | Empty
+    | Singleton of 'elt
+    | Of_sorted_array of 'elt list
+    | Of_sorted_array_unchecked of 'elt list
+    | Of_increasing_iterator_unchecked of 'elt list
+    | Of_list of Overlap.t * 'elt list
+    | Of_array of Overlap.t * 'elt list
+    | Of_sequence of Overlap.t * 'elt list
+    | Add of Overlap.t * 'elt * 'elt t [@weight rec_weight]
+    | Remove of 'elt * 'elt t [@weight rec_weight]
+    | Map of Overlap.t * ('elt, 'elt) Func.t * 'elt t [@weight rec_weight]
+    | Filter of ('elt, bool) Func.t * 'elt t [@weight rec_weight]
+    | Filter_map of Overlap.t * ('elt, 'elt option) Func.t * 'elt t [@weight rec_weight]
+    | Partition_tf of Side.t * ('elt, bool) Func.t * 'elt t [@weight rec_weight]
+    | Diff of 'elt t * 'elt t [@weight rec_weight]
+    | Inter of 'elt t * 'elt t [@weight rec_weight]
+    | Union of Overlap.t * 'elt t * 'elt t [@weight rec_weight]
+    | Union_list of Overlap.t * 'elt t list [@weight rec_weight]
+    | Split of Side.t * 'elt * 'elt t [@weight rec_weight]
+    | Split_le_gt of Side.t * 'elt * 'elt t [@weight rec_weight]
+    | Split_lt_ge of Side.t * 'elt * 'elt t [@weight rec_weight]
+    | Group_by of ('elt, int) Func.t * int * 'elt t [@weight rec_weight]
+    | Remove_index of int * 'elt t [@weight rec_weight]
+  [@@deriving equal, quickcheck ~generator ~observer, sexp_of]
+
+  let nested = function
+    | Empty -> []
+    | Singleton _ -> []
+    | Of_sorted_array _ -> []
+    | Of_sorted_array_unchecked _ -> []
+    | Of_increasing_iterator_unchecked _ -> []
+    | Of_list _ -> []
+    | Of_array _ -> []
+    | Of_sequence _ -> []
+    | Add (_, _, t) -> [ t ]
+    | Remove (_, t) -> [ t ]
+    | Map (_, _, t) -> [ t ]
+    | Filter (_, t) -> [ t ]
+    | Filter_map (_, _, t) -> [ t ]
+    | Partition_tf (_, _, t) -> [ t ]
+    | Diff (a, b) -> [ a; b ]
+    | Inter (a, b) -> [ a; b ]
+    | Union (_, a, b) -> [ a; b ]
+    | Union_list (_, list) -> list
+    | Split (_, _, t) -> [ t ]
+    | Split_le_gt (_, _, t) -> [ t ]
+    | Split_lt_ge (_, _, t) -> [ t ]
+    | Group_by (_, _, t) -> [ t ]
+    | Remove_index (_, t) -> [ t ]
+  ;;
+
+  let rec number_of_constructors t =
+    1 + List.sum (module Int) (nested t) ~f:number_of_constructors
+  ;;
+
+  (* Simple shrinker to whittle away unnecessary enclosing constructors. *)
+  let quickcheck_shrinker (type elt) (_ : elt Shrinker.t) : elt t Shrinker.t =
+    Shrinker.create (fun t -> Sequence.of_list (nested t))
+  ;;
+
+  let elts t ~compare =
+    let rec elts = function
+      | Empty -> []
+      | Singleton elt -> [ elt ]
+      | Of_sorted_array list -> list
+      | Of_sorted_array_unchecked list -> list
+      | Of_increasing_iterator_unchecked list -> list
+      | Of_list (_, list) -> list
+      | Of_array (_, list) -> list
+      | Of_sequence (_, list) -> list
+      | Add (_, elt, t) -> elt :: elts t
+      | Remove (elt, t) -> elt :: elts t
+      | Map (_, fn, t) -> Func.inputs fn @ Func.outputs fn @ elts t
+      | Filter (fn, t) -> Func.inputs fn @ elts t
+      | Filter_map (_, fn, t) ->
+        Func.inputs fn @ List.filter_opt (Func.outputs fn) @ elts t
+      | Partition_tf (_, fn, t) -> Func.inputs fn @ elts t
+      | Diff (a, b) -> elts a @ elts b
+      | Inter (a, b) -> elts a @ elts b
+      | Union (_, a, b) -> elts a @ elts b
+      | Union_list (_, list) -> List.concat_map ~f:elts list
+      | Split (_, elt, t) -> elt :: elts t
+      | Split_le_gt (_, elt, t) -> elt :: elts t
+      | Split_lt_ge (_, elt, t) -> elt :: elts t
+      | Group_by (fn, _, t) -> Func.inputs fn @ elts t
+      | Remove_index (_, t) -> elts t
+    in
+    List.dedup_and_sort ~compare (elts t)
+  ;;
+
+  let rec map : type elt1 elt2. elt1 t -> f:(elt1 -> elt2) -> elt2 t =
+    fun t ~f ->
+    match t with
+    | Empty -> Empty
+    | Singleton elt -> Singleton (f elt)
+    | Of_sorted_array list -> Of_sorted_array (List.map ~f:(fun elt -> f elt) list)
+    | Of_sorted_array_unchecked list ->
+      Of_sorted_array_unchecked (List.map ~f:(fun elt -> f elt) list)
+    | Of_increasing_iterator_unchecked list ->
+      Of_increasing_iterator_unchecked (List.map ~f:(fun elt -> f elt) list)
+    | Of_list (overlap, list) -> Of_list (overlap, List.map ~f:(fun elt -> f elt) list)
+    | Of_array (overlap, list) -> Of_array (overlap, List.map ~f:(fun elt -> f elt) list)
+    | Of_sequence (overlap, list) ->
+      Of_sequence (overlap, List.map ~f:(fun elt -> f elt) list)
+    | Add (overlap, elt, t) -> Add (overlap, f elt, map ~f t)
+    | Remove (elt, t) -> Remove (f elt, map ~f t)
+    | Map (overlap, fn, t) -> Map (overlap, Func.map ~i:f ~o:f fn, map ~f t)
+    | Filter (fn, t) -> Filter (Func.map ~i:f ~o:Fn.id fn, map ~f t)
+    | Filter_map (overlap, fn, t) ->
+      Filter_map (overlap, Func.map ~i:f ~o:(Option.map ~f) fn, map ~f t)
+    | Partition_tf (side, fn, t) ->
+      Partition_tf (side, Func.map ~i:f ~o:Fn.id fn, map ~f t)
+    | Diff (a, b) -> Diff (map ~f a, map ~f b)
+    | Inter (a, b) -> Inter (map ~f a, map ~f b)
+    | Union (overlap, a, b) -> Union (overlap, map ~f a, map ~f b)
+    | Union_list (overlap, list) -> Union_list (overlap, List.map ~f:(map ~f) list)
+    | Split (side, elt, t) -> Split (side, f elt, map ~f t)
+    | Split_le_gt (side, elt, t) -> Split_le_gt (side, f elt, map ~f t)
+    | Split_lt_ge (side, elt, t) -> Split_lt_ge (side, f elt, map ~f t)
+    | Group_by (fn, i, t) -> Group_by (Func.map ~i:f ~o:Fn.id fn, i, map ~f t)
+    | Remove_index (i, t) -> Remove_index (i, map ~f t)
+  ;;
+
+  let _ = map
+
+  module Make (Instance : Instance) (Impl : Impl with module Types := Instance.Types) =
+  struct
+    module Elt = struct
+      include Instance.Elt
+
+      let get = to_int
+      let set _ n = of_int n
+    end
+
+    let unique_elt = Adjustable.unique (module Elt)
+    let non_overlapping_elts = Adjustable.non_overlapping (module Elt)
+    let elts t = elts t ~compare:Elt.compare
+
+    (* [value (normalize t)] is guaranteed not to raise, at least for [t] from
+       [quickcheck_generator]. We rely on elt values being small so we don't have to deal
+       with integer overflow. *)
+    let rec normalize = function
+      | Empty -> Empty
+      | Singleton elt -> Singleton elt
+      | Of_sorted_array list ->
+        let list =
+          non_overlapping_elts list |> sort_either_direction ~compare:Elt.compare
+        in
+        Of_sorted_array list
+      | Of_sorted_array_unchecked list ->
+        let list =
+          non_overlapping_elts list |> sort_either_direction ~compare:Elt.compare
+        in
+        Of_sorted_array_unchecked list
+      | Of_increasing_iterator_unchecked list ->
+        let list = non_overlapping_elts list |> List.sort ~compare:Elt.compare in
+        Of_increasing_iterator_unchecked list
+      | Of_list (overlap, list) ->
+        let list =
+          match overlap with
+          | Allow_overlap -> list
+          | Disallow_overlap -> non_overlapping_elts list
+        in
+        Of_list (overlap, list)
+      | Of_array (overlap, list) ->
+        let list =
+          match overlap with
+          | Allow_overlap -> list
+          | Disallow_overlap -> non_overlapping_elts list
+        in
+        Of_array (overlap, list)
+      | Of_sequence (overlap, list) ->
+        let list =
+          match overlap with
+          | Allow_overlap -> list
+          | Disallow_overlap -> non_overlapping_elts list
+        in
+        Of_sequence (overlap, list)
+      | Add (overlap, elt, t) ->
+        let t = normalize t in
+        let elt =
+          match overlap with
+          | Allow_overlap -> elt
+          | Disallow_overlap -> unique_elt elt (elts t)
+        in
+        Add (overlap, elt, t)
+      | Remove (elt, t) -> Remove (elt, normalize t)
+      | Map (overlap, fn, t) ->
+        let t = normalize t in
+        let fn =
+          match overlap with
+          | Allow_overlap -> fn
+          | Disallow_overlap -> Func.injective fn (module Elt) (module Elt) (elts t)
+        in
+        Map (overlap, fn, t)
+      | Filter (fn, t) -> Filter (fn, normalize t)
+      | Filter_map (overlap, fn, t) ->
+        let t = normalize t in
+        let fn =
+          match overlap with
+          | Allow_overlap -> fn
+          | Disallow_overlap ->
+            Func.injective
+              fn
+              (module Elt)
+              (module struct
+                type t = Elt.t option
+
+                let get = function
+                  | None -> 0
+                  | Some e -> 1 + Elt.get e
+                ;;
+
+                let set _ n = if n <= 0 then None else Some (Elt.of_int (n - 1))
+              end)
+              (elts t)
+        in
+        Filter_map (overlap, fn, t)
+      | Partition_tf (side, fn, t) -> Partition_tf (side, fn, normalize t)
+      | Diff (a, b) -> Diff (normalize a, normalize b)
+      | Inter (a, b) -> Inter (normalize a, normalize b)
+      | Union (overlap, a, b) ->
+        let a = normalize a
+        and b = normalize b in
+        let rename_a, rename_b =
+          List.concat
+            [ List.map (elts a) ~f:(fun elt -> Side.Left, (elt, elt))
+            ; List.map (elts b) ~f:(fun elt -> Side.Right, (elt, elt))
+            ]
+          |> Adjustable.non_overlapping
+               (module struct
+                 type t = Side.t * (Elt.t * Elt.t)
+
+                 let get (_, (_, elt)) = Elt.to_int elt
+                 let set (side, (elt, _)) int = side, (elt, Elt.of_int int)
+               end)
+          |> List.partition_map ~f:(function
+            | Left, pair -> First pair
+            | Right, pair -> Second pair)
+        in
+        let a = map a ~f:(fun e -> List.Assoc.find_exn rename_a e ~equal:Elt.equal)
+        and b = map b ~f:(fun e -> List.Assoc.find_exn rename_b e ~equal:Elt.equal) in
+        Union (overlap, a, b)
+      | Union_list (overlap, list) ->
+        let list = List.map ~f:normalize list in
+        let list =
+          match overlap with
+          | Allow_overlap -> list
+          | Disallow_overlap ->
+            let renamings =
+              let alist =
+                List.concat_mapi list ~f:(fun i t -> List.map (elts t) ~f:(fun e -> i, e))
+                |> Adjustable.non_overlapping
+                     (module struct
+                       type t = int * Elt.t
+
+                       let get (_, elt) = Elt.to_int elt
+                       let set (i, _) n = i, Elt.of_int n
+                     end)
+              in
+              List.mapi list ~f:(fun i t ->
+                List.zip_exn
+                  (elts t)
+                  (List.filter_map alist ~f:(fun (j, e) -> Option.some_if (i = j) e)))
+            in
+            List.map2_exn renamings list ~f:(fun renaming t ->
+              map t ~f:(fun e -> List.Assoc.find_exn renaming e ~equal:Elt.equal))
+        in
+        Union_list (overlap, list)
+      | Split (side, elt, t) -> Split (side, elt, normalize t)
+      | Split_le_gt (side, elt, t) -> Split_le_gt (side, elt, normalize t)
+      | Split_lt_ge (side, elt, t) -> Split_lt_ge (side, elt, normalize t)
+      | Group_by (fn, n, t) -> Group_by (fn, n, normalize t)
+      | Remove_index (i, t) -> Remove_index (i, normalize t)
+    ;;
+
+    let rec value =
+      let open Instance in
+      function
+      | Empty -> create Impl.empty
+      | Singleton elt -> (create Impl.singleton) elt
+      | Of_sorted_array list ->
+        (create Impl.of_sorted_array) (Array.of_list list) |> Or_error.ok_exn
+      | Of_sorted_array_unchecked list ->
+        (create Impl.of_sorted_array_unchecked) (Array.of_list list)
+      | Of_increasing_iterator_unchecked list ->
+        let array = Array.of_list list in
+        (create Impl.of_increasing_iterator_unchecked)
+          ~len:(Array.length array)
+          ~f:(Array.get array)
+      | Of_list (_, list) -> (create Impl.of_list) list
+      | Of_array (_, list) -> (create Impl.of_array) (Array.of_list list)
+      | Of_sequence (_, list) -> (create Impl.of_sequence) (Sequence.of_list list)
+      | Add (_, elt, t) -> (access Impl.add) (value t) elt
+      | Remove (elt, t) -> (access Impl.remove) (value t) elt
+      | Map (_, fn, t) ->
+        (create Impl.map) (value t) ~f:(fun elt -> Func.apply fn (module Elt) elt)
+      | Filter (fn, t) -> Impl.filter (value t) ~f:(Func.apply fn (module Elt))
+      | Filter_map (_, fn, t) ->
+        (create Impl.filter_map) (value t) ~f:(fun elt -> Func.apply fn (module Elt) elt)
+      | Partition_tf (side, fn, t) ->
+        Impl.partition_tf (value t) ~f:(Func.apply fn (module Elt)) |> Side.select side
+      | Diff (a, b) -> (access Impl.diff) (value a) (value b)
+      | Inter (a, b) -> (access Impl.inter) (value a) (value b)
+      | Union (_, a, b) -> (access Impl.union) (value a) (value b)
+      | Union_list (_, list) -> (create Impl.union_list) (List.map ~f:value list)
+      | Split (side, elt, t) -> (access Impl.split) (value t) elt |> Side.select3 side
+      | Split_le_gt (side, elt, t) ->
+        (access Impl.split_le_gt) (value t) elt |> Side.select side
+      | Split_lt_ge (side, elt, t) ->
+        (access Impl.split_lt_ge) (value t) elt |> Side.select side
+      | Group_by (fn, n, t) ->
+        let list =
+          Impl.group_by
+            (value t)
+            ~equiv:(Comparable.lift Int.equal ~f:(Func.apply fn (module Elt)))
+        in
+        List.nth list n |> Option.value ~default:(create Impl.empty)
+      | Remove_index (n, t) -> (access Impl.remove_index) (value t) n
+    ;;
+
+    (* Report normalization failure using a small input if possible. *)
+    let rec shrink_and_raise ~src ~dst ~exn =
+      Shrinker.shrink [%shrinker: _ t] src
+      |> Sequence.find_map ~f:(fun src ->
+        let dst = normalize src in
+        match value dst with
+        | _ -> None
+        | exception exn -> Some (src, dst, exn))
+      |> function
+      | Some (src, dst, exn) -> shrink_and_raise ~src ~dst ~exn
+      | None ->
+        raise_s
+          [%message "normalization fails" (src : Elt.t t) (dst : Elt.t t) (exn : exn)]
+    ;;
+
+    (* We test normalization when we apply it so we can get a good, early error message if
+       something goes wrong. *)
+    let normalize src =
+      let dst = normalize src in
+      match value dst with
+      | _ -> dst
+      | exception exn -> shrink_and_raise ~src ~dst ~exn
+    ;;
+  end
+end
+
+(* Cobble everything together and generate normalized constructor trees. *)
+module Make (Instance : Instance) (Impl : Impl with module Types := Instance.Types) =
+struct
+  open Instance
+
+  type t = Elt.t Constructor.t [@@deriving equal, quickcheck, sexp_of]
+
+  include Constructor.Make (Instance) (Impl)
+
+  let quickcheck_generator = Generator.map quickcheck_generator ~f:normalize
+end
+
+(* Coverage testing so we know we haven't forgotten any constructor functions.
+
+   The number of quickcheck tests on 32-bit architectures is configured to be lower, so we
+   skip the coverage checks there. *)
+let%test_module (_ [@tags "64-bits-only"]) =
+  (module (
+  struct
+    module Types = struct
+      type 'elt elt = 'elt
+      type 'cmp cmp = 'cmp
+      type ('elt, 'cmp) set = ('elt, 'cmp) Set.t
+      type ('elt, 'cmp) t = ('elt, 'cmp) Set.t
+      type ('elt, 'cmp) tree = ('elt, 'cmp) Set.Using_comparator.Tree.t
+
+      type ('elt, 'cmp, 'fn) create_options =
+        ('elt, 'cmp, 'fn) Set.With_first_class_module.t
+
+      type ('elt, 'cmp, 'fn) access_options = ('elt, 'cmp, 'fn) Set.Without_comparator.t
+    end
+
+    open struct
+      module Elt = struct
+        include Int
+
+        type t = int [@@deriving quickcheck]
+      end
+
+      module Instance = struct
+        module Types = Types
+        module Elt = Elt
+
+        type t = (int, Int.comparator_witness) Set.t
+
+        let compare = Set.compare_direct
+        let equal = Set.equal
+        let sexp_of_t t = Set.sexp_of_m__t (module Elt) t
+        let create f = f ((module Elt) : (_, _) Comparator.Module.t)
+        let access f = f
+      end
+
+      module Cons = Make (Instance) (Set)
+
+      let sample = Memo.memoize Cons.quickcheck_generator
+
+      let%expect_test "normalization" =
+        quickcheck_m
+          (module struct
+            include Cons
+
+            let sample = sample
+          end)
+          ~f:(fun t ->
+            require_equal (module Cons) t (Cons.normalize t);
+            require_does_not_raise (fun () -> ignore (Cons.value t : Set.M(Int).t)))
+      ;;
+
+      let%expect_test "number of constructors" =
+        let stats = Stats.create () in
+        List.iter (Lazy.force sample) ~f:(fun t ->
+          Stats.add stats (Constructor.number_of_constructors t));
+        Stats.print stats;
+        [%expect
+          {|
+            % | size | count
+          ----+------+------
+            0 |    1 | 10000
+           50 |    9 |  5119
+           75 |   38 |  2510
+           90 |   80 |  1004
+           95 |  129 |   505
+           99 |  274 |   100
+          100 |  718 |     1
+          |}]
+      ;;
+
+      let test predicate =
+        let stats = Stats.create () in
+        List.iter (force sample) ~f:(fun t ->
+          if predicate t
+          then (
+            let size = Set.length (Cons.value t) in
+            Stats.add stats size));
+        Stats.print stats
+      ;;
+    end
+
+    (* Accessors only, not covered. *)
+
+    include (Set : Accessors with module Types := Types)
+
+    (* Complicated types, not covered. *)
+
+    let of_tree = Set.of_tree
+
+    (* Deprecated, not covered *)
+    let stable_dedup_list = (Set.stable_dedup_list [@alert "-deprecated"])
+
+    (* Tests *)
+
+    let empty = Set.empty
+
+    let%expect_test _ =
+      test (function
+        | Empty -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   198
+        |}]
+    ;;
+
+    let singleton = Set.singleton
+
+    let%expect_test _ =
+      test (function
+        | Singleton _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+        100 |    1 |   181
+        |}]
+    ;;
+
+    let of_sorted_array = Set.of_sorted_array
+
+    let%expect_test _ =
+      test (function
+        | Of_sorted_array _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    25
+        ----+------+------
+          0 |    1 |   152
+         50 |    8 |    78
+         75 |   16 |    38
+         90 |   23 |    16
+         95 |   28 |     8
+         99 |   30 |     2
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_sorted_array_unchecked = Set.of_sorted_array_unchecked
+
+    let%expect_test _ =
+      test (function
+        | Of_sorted_array_unchecked _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    29
+        ----+------+------
+          0 |    1 |   172
+         50 |   10 |    86
+         75 |   19 |    47
+         90 |   25 |    20
+         95 |   29 |     9
+         99 |   30 |     7
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_increasing_iterator_unchecked = Set.of_increasing_iterator_unchecked
+
+    let%expect_test _ =
+      test (function
+        | Of_increasing_iterator_unchecked _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    40
+        ----+------+------
+          0 |    1 |   143
+         50 |    9 |    76
+         75 |   19 |    36
+         90 |   25 |    18
+         95 |   27 |    10
+         99 |   29 |     4
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_list = Set.of_list
+
+    let%expect_test _ =
+      test (function
+        | Of_list _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    32
+        ----+------+------
+          0 |    1 |   159
+         50 |    4 |    85
+         75 |    6 |    41
+         90 |   16 |    16
+         95 |   24 |    11
+         99 |   29 |     2
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let of_array = Set.of_array
+
+    let%expect_test _ =
+      test (function
+        | Of_array _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    27
+        ----+------+------
+          0 |    1 |   165
+         50 |    4 |    86
+         75 |   12 |    42
+         90 |   21 |    17
+         95 |   24 |     9
+        100 |   30 |     2
+        |}]
+    ;;
+
+    let of_sequence = Set.of_sequence
+
+    let%expect_test _ =
+      test (function
+        | Of_sequence _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    34
+        ----+------+------
+          0 |    1 |   154
+         50 |    4 |    82
+         75 |    8 |    40
+         90 |   20 |    16
+         95 |   26 |     8
+         99 |   30 |     5
+        100 |   31 |     1
+        |}]
+    ;;
+
+    let add = Set.add
+
+    let%expect_test _ =
+      test (function
+        | Add _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+         50 |    1 |   574
+         75 |    3 |   155
+         90 |    8 |    59
+         95 |   12 |    29
+         99 |   25 |     6
+        100 |   29 |     1
+        |}]
+    ;;
+
+    let remove = Set.remove
+
+    let%expect_test _ =
+      test (function
+        | Remove _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   325
+        ----+------+------
+          0 |    1 |   238
+         50 |    2 |   146
+         75 |    8 |    62
+         90 |   17 |    25
+         95 |   21 |    12
+         99 |   27 |     3
+        100 |   28 |     1
+        |}]
+    ;;
+
+    let map = Set.map
+
+    let%expect_test _ =
+      test (function
+        | Map _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   295
+        ----+------+------
+          0 |    1 |   249
+         50 |    2 |   130
+         75 |    3 |    79
+         90 |    8 |    26
+         95 |   12 |    13
+         99 |   24 |     4
+        100 |   29 |     1
+        |}]
+    ;;
+
+    let filter = Set.filter
+
+    let%expect_test _ =
+      test (function
+        | Filter _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   404
+        ----+------+------
+          0 |    1 |   145
+         50 |    2 |    82
+         75 |    5 |    38
+         90 |   14 |    15
+         95 |   19 |     8
+         99 |   23 |     3
+        100 |   25 |     1
+        |}]
+    ;;
+
+    let filter_map = Set.filter_map
+
+    let%expect_test _ =
+      test (function
+        | Filter_map _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   350
+        ----+------+------
+          0 |    1 |   207
+         50 |    2 |   107
+         75 |    3 |    63
+         90 |   12 |    21
+         95 |   14 |    14
+         99 |   24 |     4
+        100 |   27 |     1
+        |}]
+    ;;
+
+    let partition_tf = Set.partition_tf
+
+    let%expect_test _ =
+      test (function
+        | Partition_tf _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   411
+        ----+------+------
+          0 |    1 |   155
+         50 |    2 |    86
+         75 |    4 |    43
+         90 |   13 |    17
+         95 |   17 |     8
+         99 |   25 |     3
+        100 |   28 |     1
+        |}]
+    ;;
+
+    let diff = Set.diff
+
+    let%expect_test _ =
+      test (function
+        | Diff _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   348
+        ----+------+------
+          0 |    1 |   218
+         50 |    2 |   135
+         75 |    7 |    55
+         90 |   14 |    23
+         95 |   18 |    13
+        100 |   29 |     3
+        |}]
+    ;;
+
+    let inter = Set.inter
+
+    let%expect_test _ =
+      test (function
+        | Inter _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   519
+        ----+------+------
+         50 |    1 |    63
+         75 |    2 |    30
+         90 |    6 |     7
+         95 |    8 |     4
+        100 |   25 |     1
+        |}]
+    ;;
+
+    let union = Set.union
+
+    let%expect_test _ =
+      test (function
+        | Union _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   173
+        ----+------+------
+          0 |    1 |   395
+         50 |    3 |   229
+         75 |    9 |   104
+         90 |   17 |    45
+         95 |   25 |    22
+         99 |   37 |     4
+        100 |   48 |     2
+        |}]
+    ;;
+
+    let union_list = Set.union_list
+
+    let%expect_test _ =
+      test (function
+        | Union_list _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |    88
+        ----+------+------
+          0 |    1 |   448
+         50 |    3 |   251
+         75 |    6 |   120
+         90 |   10 |    53
+         95 |   13 |    30
+         99 |   19 |     5
+        100 |   24 |     1
+        |}]
+    ;;
+
+    let split = Set.split
+
+    let%expect_test _ =
+      test (function
+        | Split _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   413
+        ----+------+------
+          0 |    1 |   155
+         50 |    2 |    88
+         75 |    5 |    39
+         90 |   13 |    16
+         95 |   16 |    10
+         99 |   26 |     2
+        100 |   27 |     1
+        |}]
+    ;;
+
+    let split_le_gt = Set.split_le_gt
+
+    let%expect_test _ =
+      test (function
+        | Split_le_gt _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   401
+        ----+------+------
+          0 |    1 |   160
+         50 |    2 |    91
+         75 |    5 |    44
+         90 |   11 |    16
+         95 |   14 |     9
+         99 |   17 |     4
+        100 |   24 |     1
+        |}]
+    ;;
+
+    let split_lt_ge = Set.split_lt_ge
+
+    let%expect_test _ =
+      test (function
+        | Split_lt_ge _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   427
+        ----+------+------
+          0 |    1 |   172
+         50 |    2 |    88
+         75 |    4 |    54
+         90 |   10 |    19
+         95 |   13 |    10
+         99 |   26 |     2
+        100 |   36 |     1
+        |}]
+    ;;
+
+    let group_by = Set.group_by
+
+    let%expect_test _ =
+      test (function
+        | Group_by _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   559
+        ----+------+------
+          0 |    1 |     9
+         50 |    2 |     5
+         75 |    4 |     3
+        100 |   14 |     1
+        |}]
+    ;;
+
+    let remove_index = Set.remove_index
+
+    let%expect_test _ =
+      test (function
+        | Remove_index _ -> true
+        | _ -> false);
+      [%expect
+        {|
+          % | size | count
+        ----+------+------
+          - |    0 |   304
+        ----+------+------
+          0 |    1 |   284
+         50 |    2 |   157
+         75 |    6 |    75
+         90 |   13 |    32
+         95 |   19 |    15
+         99 |   26 |     4
+        100 |   27 |     2
+        |}]
+    ;;
+  end :
+    Impl))
+;;
diff --git a/test/coverage/set/constructor.mli b/test/coverage/set/constructor.mli
new file mode 100644
index 00000000..0d8b0e66
--- /dev/null
+++ b/test/coverage/set/constructor.mli
@@ -0,0 +1 @@
+include Constructor_intf.Constructor
diff --git a/test/coverage/set/constructor_intf.ml b/test/coverage/set/constructor_intf.ml
new file mode 100644
index 00000000..586b3a80
--- /dev/null
+++ b/test/coverage/set/constructor_intf.ml
@@ -0,0 +1,17 @@
+(** Creates types for explicit trees of map constructors. This can be used to test maps
+    with coverage over most functions from Map that construct them. *)
+
+open! Base
+open Functor_intf.Definitions
+
+module type Constructor = sig
+  (** Create a constructor type for maps with [int Types.key] keys and [Data.t] data. *)
+  module Make
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) : sig
+    type t [@@deriving equal, quickcheck, sexp_of]
+
+    (** Get the actual value the constructor represents. *)
+    val value : t -> Instance.t
+  end
+end
diff --git a/test/map_full_interface/dune b/test/coverage/set/dune
similarity index 54%
rename from test/map_full_interface/dune
rename to test/coverage/set/dune
index 0881dcef..a3e10610 100644
--- a/test/map_full_interface/dune
+++ b/test/coverage/set/dune
@@ -1,6 +1,6 @@
 (library
- (name base_test_map_full_interface)
- (libraries base base_quickcheck
+ (name base_test_coverage_set)
+ (libraries base base_quickcheck base_test_coverage_helpers
    expect_test_helpers_core.expect_test_helpers_base sexp_grammar)
  (preprocess
   (pps ppx_jane)))
diff --git a/test/coverage/set/functor.ml b/test/coverage/set/functor.ml
new file mode 100644
index 00000000..d3a58198
--- /dev/null
+++ b/test/coverage/set/functor.ml
@@ -0,0 +1,946 @@
+(** Comprehensive testing of [Base.Set].
+
+    This file tests all exports of [Base.Set]. Every time a new export is added, we have
+    to add a new definition somewhere here. Every time we add a definition, we should add
+    a test unless the definition is untestable (e.g., a module type) or trivial (e.g., a
+    module containing only ppx-derived definitions). We should document categories of
+    untested definitions, mark them as untested, and keep them separate from definitions
+    that need tests. *)
+
+open! Base
+open Base_quickcheck
+open Expect_test_helpers_base
+open Base_test_coverage_helpers
+open Overrides
+include Functor_intf.Definitions
+
+module Generate (Instance : Instance) (Impl : Impl with module Types := Instance.Types) :
+  Generate with module Instance := Instance = struct
+  include Constructor.Make (Instance) (Impl)
+
+  module Value = struct
+    type t = Instance.t [@@deriving compare, equal, sexp_of]
+  end
+end
+
+module Test_helpers
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) =
+struct
+  open Instance
+
+  module Inst = struct
+    include Generate (Instance) (Impl)
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Elts = struct
+    type t = Elt.t list [@@deriving compare, equal, quickcheck, sexp_of]
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Elts_result = struct
+    type t = (Elt.t list, Elt.t list) Result.t [@@deriving compare, equal, sexp_of]
+  end
+
+  module Inst_and_int = struct
+    type t = Inst.t * int [@@deriving quickcheck, sexp_of]
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Inst_and_elt = struct
+    type t = Inst.t * Elt.t [@@deriving quickcheck, sexp_of]
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Inst_and_inst = struct
+    include Data.Pair (Inst)
+
+    let sample = Memo.memoize [%generator: t]
+
+    module Value = struct
+      type t = Inst.Value.t * Inst.Value.t [@@deriving equal, sexp_of]
+    end
+  end
+
+  module Inst_list = struct
+    type t = Inst.t list [@@deriving equal, quickcheck, sexp_of]
+
+    let sample = Memo.memoize [%generator: t]
+
+    module Value = struct
+      type t = Inst.Value.t list [@@deriving equal, sexp_of]
+    end
+  end
+
+  module Physical_equality (T : sig
+      type t [@@deriving sexp_of]
+    end) =
+  struct
+    type t = T.t [@@deriving sexp_of]
+
+    let equal a b = phys_equal a b
+  end
+end
+
+module Test_creators
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) :
+  Creators with module Types := Instance.Types = struct
+  open Instance
+  open Impl
+  open Test_helpers (Instance) (Impl)
+
+  let () = print_endline "Functor.Test_creators: running tests."
+
+  (** deprecated, not testing *)
+
+  and stable_dedup_list = (stable_dedup_list [@alert "-deprecated"])
+
+  (** creators *)
+
+  and empty = empty
+
+  and () = require_equal (module Sexp) [%sexp (create empty : t)] [%sexp []]
+  and singleton = singleton
+
+  and () =
+    require_equal
+      (module Sexp)
+      [%sexp (create singleton (Elt.of_int 1) : t)]
+      [%sexp [ 1 ]]
+
+  and of_list = of_list
+
+  and () =
+    quickcheck_m
+      (module Elts)
+      ~f:(fun list ->
+        let t = create of_list list in
+        require_equal
+          (module Elts)
+          (to_list t)
+          (List.dedup_and_sort list ~compare:Elt.compare))
+
+  and of_array = of_array
+
+  and () =
+    quickcheck_m
+      (module Elts)
+      ~f:(fun list ->
+        let t = create of_array (Array.of_list list) in
+        require_equal
+          (module Elts)
+          (to_list t)
+          (List.dedup_and_sort list ~compare:Elt.compare))
+
+  and of_sequence = of_sequence
+
+  and () =
+    quickcheck_m
+      (module Elts)
+      ~f:(fun list ->
+        let t = create of_sequence (Sequence.of_list list) in
+        require_equal
+          (module Elts)
+          (to_list t)
+          (List.dedup_and_sort list ~compare:Elt.compare))
+
+  and of_sorted_array = of_sorted_array
+
+  and () =
+    quickcheck_m
+      (module Elts)
+      ~f:(fun elts ->
+        let actual = create of_sorted_array (Array.of_list elts) in
+        let expect =
+          if List.is_sorted_strictly ~compare:Elt.compare elts
+             || List.is_sorted_strictly ~compare:Elt.compare (List.rev elts)
+          then Ok (create of_list elts)
+          else Or_error.error_string "unsorted"
+        in
+        require_equal (module Data.Or_error (Inst.Value)) actual expect)
+
+  and of_sorted_array_unchecked = of_sorted_array_unchecked
+
+  and () =
+    quickcheck_m
+      (module Elts)
+      ~f:(fun elts ->
+        let elts = List.dedup_and_sort elts ~compare:Elt.compare in
+        let actual_fwd = create of_sorted_array_unchecked (Array.of_list elts) in
+        let actual_rev = create of_sorted_array_unchecked (Array.of_list_rev elts) in
+        let expect = create of_list elts in
+        require_equal (module Inst.Value) actual_fwd expect;
+        require_equal (module Inst.Value) actual_rev expect)
+
+  and of_increasing_iterator_unchecked = of_increasing_iterator_unchecked
+
+  and () =
+    quickcheck_m
+      (module Elts)
+      ~f:(fun elts ->
+        let elts = List.dedup_and_sort elts ~compare:Elt.compare in
+        let actual =
+          let array = Array.of_list elts in
+          create
+            of_increasing_iterator_unchecked
+            ~len:(Array.length array)
+            ~f:(Array.get array)
+        in
+        let expect = create of_list elts in
+        require_equal (module Inst.Value) actual expect)
+
+  and of_tree = of_tree
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let tree = to_tree t in
+        let round_trip = create of_tree tree in
+        require_equal (module Inst.Value) t round_trip)
+
+  and union_list = union_list
+
+  and () =
+    quickcheck_m
+      (module Inst_list)
+      ~f:(fun list ->
+        let list = List.map ~f:Inst.value list in
+        let t = (create union_list) list in
+        require_equal
+          (module Elts)
+          (to_list t)
+          (List.dedup_and_sort ~compare:Elt.compare (List.concat_map ~f:to_list list)))
+
+  and map = map
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        let f elt = Comparable.min Elt.compare elt e in
+        let actual = (create map) t ~f in
+        let expect = to_list t |> List.map ~f |> create of_list in
+        require_equal (module Inst.Value) actual expect)
+
+  and filter_map = filter_map
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        let f elt =
+          match Ordering.of_int (Elt.compare elt e) with
+          | Less -> Some elt
+          | Equal -> None
+          | Greater -> Some e
+        in
+        let actual = (create filter_map) t ~f in
+        let expect = to_list t |> List.filter_map ~f |> create of_list in
+        require_equal (module Inst.Value) actual expect)
+  ;;
+end
+
+module Test_accessors
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) :
+  Accessors with module Types := Instance.Types = struct
+  open Instance
+  open Impl
+  open Test_helpers (Instance) (Impl)
+
+  let () = print_endline "Functor.Test_accessors: running tests."
+
+  (** accessors *)
+
+  and invariants = invariants
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        require (access invariants t))
+
+  and is_empty = is_empty
+  and length = length
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let len = length t in
+        require_equal (module Bool) (is_empty t) (len = 0);
+        require_equal (module Int) len (List.length (to_list t)))
+
+  and is_subset = is_subset
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        require_equal
+          (module Bool)
+          (access is_subset a ~of_:b)
+          (for_all a ~f:((access mem) b)))
+
+  and are_disjoint = are_disjoint
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        require_equal
+          (module Bool)
+          (access are_disjoint a b)
+          (is_empty ((access inter) a b)))
+
+  and mem = mem
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, elt) ->
+        let t = Inst.value t in
+        let expect = List.mem (to_list t) elt ~equal:Elt.equal in
+        require_equal (module Bool) (access mem t elt) expect)
+
+  and find = find
+  and find_exn = find_exn
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, elt) ->
+        let t = Inst.value t in
+        let expect = List.find (to_list t) ~f:(Elt.equal elt) in
+        require_equal (module Data.Option (Elt)) (find t ~f:(Elt.equal elt)) expect;
+        require_equal
+          (module Data.Option (Elt))
+          (Option.try_with (fun () -> find_exn t ~f:(Elt.equal elt)))
+          expect)
+
+  and find_map = find_map
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        let f elt =
+          match Ordering.of_int (Elt.compare elt e) with
+          | Less -> Some elt
+          | Equal -> None
+          | Greater -> Some e
+        in
+        let actual = find_map t ~f in
+        let candidates = List.filter_map (to_list t) ~f in
+        match actual with
+        | None -> require (List.is_empty candidates)
+        | Some elt -> require (List.mem candidates elt ~equal:Elt.equal))
+
+  and iter = iter
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let actual =
+          let q = Queue.create () in
+          iter t ~f:(Queue.enqueue q);
+          Queue.to_list q
+        in
+        require_equal (module Data.List (Elt)) actual (to_list t))
+
+  and fold = fold
+  and fold_right = fold_right
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        require_equal
+          (module Elts)
+          (fold t ~init:[] ~f:(fun list elt -> elt :: list))
+          (List.rev (to_list t));
+        require_equal
+          (module Elts)
+          (fold_right t ~init:[] ~f:(fun elt list -> elt :: list))
+          (to_list t))
+
+  and fold_until = fold_until
+  and fold_result = fold_result
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, threshold) ->
+        let t = Inst.value t in
+        let until =
+          fold_until
+            t
+            ~init:[]
+            ~finish:(fun list -> Ok list)
+            ~f:(fun acc elt ->
+              if Elt.( >= ) elt threshold then Stop (Error acc) else Continue (elt :: acc))
+        in
+        let result =
+          fold_result t ~init:[] ~f:(fun acc elt ->
+            if Elt.( >= ) elt threshold then Error acc else Ok (elt :: acc))
+        in
+        let expect =
+          let list =
+            to_list t
+            |> List.take_while ~f:(fun elt -> Elt.( < ) elt threshold)
+            |> List.rev
+          in
+          if List.length list = length t then Ok list else Error list
+        in
+        require_equal (module Elts_result) until expect;
+        require_equal (module Elts_result) result expect)
+
+  and equal = equal
+  and compare_direct = compare_direct
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        require_equal
+          (module Ordering)
+          (Ordering.of_int (access compare_direct a b))
+          (Ordering.of_int (Elts.compare (to_list a) (to_list b)));
+        require_equal (module Bool) (access compare_direct a b = 0) (access equal a b))
+
+  and elements = elements
+  and to_list = to_list
+  and to_array = to_array
+  and to_sequence = to_sequence
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let list = to_list t in
+        require_equal (module Inst.Value) (create of_list list) t;
+        require_equal (module Data.List (Elt)) (elements t) list;
+        require_equal (module Elts) (Array.to_list (to_array t)) list;
+        require_equal (module Elts) (Sequence.to_list ((access to_sequence) t)) list)
+
+  and () =
+    quickcheck_m
+      (module struct
+        type t = Inst.t * [ `Decreasing | `Increasing ] * Elt.t * Elt.t
+        [@@deriving quickcheck, sexp_of]
+
+        let sample = Memo.memoize [%generator: t]
+      end)
+      ~f:(fun (t, order, greater_or_equal_to, less_or_equal_to) ->
+        let t = Inst.value t in
+        let alist =
+          Sequence.to_list
+            ((access to_sequence) t ~order ~greater_or_equal_to ~less_or_equal_to)
+        in
+        require_equal
+          (module Elts)
+          alist
+          (List.filter
+             (match order with
+              | `Decreasing -> List.rev (to_list t)
+              | `Increasing -> to_list t)
+             ~f:(fun elt ->
+               Elt.( <= ) greater_or_equal_to elt && Elt.( <= ) elt less_or_equal_to)))
+
+  and iter2 = iter2
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let iter2_list =
+          let q = Queue.create () in
+          access iter2 a b ~f:(Queue.enqueue q);
+          Queue.to_list q
+        in
+        let expect =
+          [ List.map (to_list a) ~f:Either.first; List.map (to_list b) ~f:Either.second ]
+          |> List.concat
+          |> List.sort_and_group ~compare:(Comparable.lift ~f:Either.value Elt.compare)
+          |> List.map ~f:(fun list ->
+            match (list : _ Either.t list) with
+            | [ First x ] -> `Left x
+            | [ Second y ] -> `Right y
+            | [ First x; Second y ] -> `Both (x, y)
+            | _ -> assert false)
+        in
+        require_equal
+          (module struct
+            type t = [ `Left of Elt.t | `Right of Elt.t | `Both of Elt.t * Elt.t ] list
+            [@@deriving equal, sexp_of]
+          end)
+          iter2_list
+          expect)
+
+  and symmetric_diff = symmetric_diff
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual = (access symmetric_diff) a b |> Sequence.to_list in
+        let expect =
+          [ (access diff) a b |> to_list |> List.map ~f:Either.first
+          ; (access diff) b a |> to_list |> List.map ~f:Either.second
+          ]
+          |> List.concat
+          |> List.sort ~compare:(Comparable.lift Elt.compare ~f:Either.value)
+        in
+        require_equal
+          (module struct
+            type t = (Elt.t, Elt.t) Either.t list [@@deriving equal, sexp_of]
+          end)
+          actual
+          expect)
+
+  and merge_to_sequence = merge_to_sequence
+
+  and () =
+    quickcheck_m
+      (module struct
+        type t =
+          Inst.t
+          * Inst.t
+          * [ `Decreasing | `Increasing ] option
+          * Elt.t option
+          * Elt.t option
+        [@@deriving quickcheck, sexp_of]
+
+        let sample = Memo.memoize [%generator: t]
+      end)
+      ~f:(fun (a, b, order, greater_or_equal_to, less_or_equal_to) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual =
+          (access merge_to_sequence) a b ?order ?greater_or_equal_to ?less_or_equal_to
+          |> Sequence.to_list
+        in
+        let expect =
+          let order =
+            match order with
+            | Some `Increasing | None -> Fn.id
+            | Some `Decreasing -> List.rev
+          in
+          let greater_or_equal_to =
+            match greater_or_equal_to with
+            | None -> Fn.id
+            | Some elt -> List.filter ~f:(fun e -> Elt.compare e elt >= 0)
+          in
+          let less_or_equal_to =
+            match less_or_equal_to with
+            | None -> Fn.id
+            | Some elt -> List.filter ~f:(fun e -> Elt.compare e elt <= 0)
+          in
+          (access union) a b
+          |> to_list
+          |> order
+          |> greater_or_equal_to
+          |> less_or_equal_to
+          |> List.map ~f:(fun elt : _ Sequence.Merge_with_duplicates_element.t ->
+            if not ((access mem) a elt)
+            then Right elt
+            else if not ((access mem) b elt)
+            then Left elt
+            else Both (elt, elt))
+        in
+        require_equal
+          (module struct
+            type t = (Elt.t, Elt.t) Sequence.Merge_with_duplicates_element.t list
+            [@@deriving equal, sexp_of]
+          end)
+          actual
+          expect)
+
+  and min_elt = min_elt
+  and max_elt = max_elt
+  and min_elt_exn = min_elt_exn
+  and max_elt_exn = max_elt_exn
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        require_equal (module Data.Option (Elt)) (min_elt t) (List.hd (to_list t));
+        require_equal (module Data.Option (Elt)) (max_elt t) (List.last (to_list t));
+        require_equal
+          (module Data.Option (Elt))
+          (Option.try_with (fun () -> min_elt_exn t))
+          (List.hd (to_list t));
+        require_equal
+          (module Data.Option (Elt))
+          (Option.try_with (fun () -> max_elt_exn t))
+          (List.last (to_list t)))
+
+  and choose = choose
+  and choose_exn = choose_exn
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let choose = choose t in
+        let choose_exn = Option.try_with (fun () -> choose_exn t) in
+        require_equal (module Data.Option (Elt)) choose choose_exn;
+        match choose with
+        | None -> require (is_empty t)
+        | Some elt -> require ((access mem) t elt))
+
+  and for_all = for_all
+  and exists = exists
+  and count = count
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        let f elt = Elt.compare elt e <= 0 in
+        let list = to_list t in
+        require_equal (module Bool) (for_all t ~f) (List.for_all list ~f);
+        require_equal (module Bool) (exists t ~f) (List.exists list ~f);
+        require_equal (module Int) (count t ~f) (List.count list ~f))
+
+  and sum = sum
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let f = Elt.to_int in
+        let m = (module Int : Container.Summable with type t = int) in
+        let list = to_list t in
+        require_equal (module Int) (sum m t ~f) (List.sum m list ~f))
+
+  and nth = nth
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        List.iteri (to_list t) ~f:(fun i elt ->
+          require_equal (module Data.Option (Elt)) (nth t i) (Some elt));
+        require_equal (module Data.Option (Elt)) (nth t (length t)) None)
+
+  and binary_search = binary_search
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        let targets = [%all: Binary_searchable.Which_target_by_key.t] in
+        let compare elt e = Elt.compare elt e in
+        List.iter targets ~f:(fun which_target ->
+          require_equal
+            (module Data.Option (Elt))
+            (access
+               binary_search
+               t
+               ~compare:(fun elt e' ->
+                 require_equal (module Elt) e' e;
+                 require (access mem t elt);
+                 compare elt e')
+               which_target
+               e)
+            (let array = Array.of_list (to_list t) in
+             Array.binary_search array ~compare which_target e
+             |> [%globalize: int option]
+             |> Option.map ~f:(Array.get array))))
+
+  and binary_search_segmented = binary_search_segmented
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        let targets = [%all: Binary_searchable.Which_target_by_segment.t] in
+        let segment_of elt = if Elt.( <= ) elt e then `Left else `Right in
+        List.iter targets ~f:(fun which_target ->
+          require_equal
+            (module Data.Option (Elt))
+            (access
+               binary_search_segmented
+               t
+               ~segment_of:(fun elt ->
+                 require (access mem t elt);
+                 segment_of elt)
+               which_target)
+            (let array = Array.of_list (to_list t) in
+             Array.binary_search_segmented array ~segment_of which_target
+             |> [%globalize: int option]
+             |> Option.map ~f:(Array.get array))))
+
+  and to_tree = to_tree
+
+  and () =
+    quickcheck_m
+      (module Inst)
+      ~f:(fun t ->
+        let t = Inst.value t in
+        let tree = to_tree t in
+        let round_trip = create of_tree tree in
+        require_equal (module Inst.Value) t round_trip)
+  ;;
+
+  module Named = struct
+    let () = ()
+    and is_subset = Named.is_subset
+
+    and () =
+      quickcheck_m
+        (module Inst_and_inst)
+        ~f:(fun (a, b) ->
+          let a = Inst.value a in
+          let b = Inst.value b in
+          require_equal
+            (module Data.Or_error (Unit))
+            ((access Named.is_subset)
+               { name = "a"; set = a }
+               ~of_:{ name = "b"; set = b })
+            (if (access is_subset) a ~of_:b then Ok () else Or_error.error_string "oops"))
+
+    and equal = Named.equal
+
+    and () =
+      quickcheck_m
+        (module Inst_and_inst)
+        ~f:(fun (a, b) ->
+          let a = Inst.value a in
+          let b = Inst.value b in
+          require_equal
+            (module Data.Or_error (Unit))
+            ((access Named.equal) { name = "a"; set = a } { name = "b"; set = b })
+            (if (access equal) a b then Ok () else Or_error.error_string "oops"))
+    ;;
+  end
+end
+
+module Test_transformers
+    (Instance : Instance)
+    (Impl : Impl with module Types := Instance.Types) :
+  Transformers with module Types := Instance.Types = struct
+  open Instance
+  open Impl
+  open Test_helpers (Instance) (Impl)
+
+  let () = print_endline "Functor.Test_transformers: running tests."
+
+  (** transformers *)
+
+  and add = add
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, elt) ->
+        let t = Inst.value t in
+        require_equal
+          (module Elts)
+          (to_list (access add t elt))
+          (List.dedup_and_sort ~compare:Elt.compare (elt :: to_list t)))
+
+  and remove = remove
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, elt) ->
+        let t = Inst.value t in
+        require_equal
+          (module Elts)
+          (to_list (access remove t elt))
+          (List.filter (to_list t) ~f:(fun e -> not (Elt.equal e elt))))
+
+  and remove_index = remove_index
+
+  and () =
+    quickcheck_m
+      (module Inst_and_int)
+      ~f:(fun (t, i) ->
+        let t = Inst.value t in
+        let actual = (access remove_index) t i in
+        let expect = List.filteri (to_list t) ~f:(fun j _ -> i <> j) |> create of_list in
+        require_equal (module Inst.Value) actual expect)
+
+  and filter = filter
+  and partition_tf = partition_tf
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        require_equal
+          (module Physical_equality (Inst.Value))
+          (fst (partition_tf ~f:(fun _ -> true) t))
+          t;
+        let f elt = Elt.compare elt e <= 0 in
+        let by_partition_tf = partition_tf t ~f in
+        let by_filter = filter t ~f, filter t ~f:(Fn.non f) in
+        let expect =
+          let ts, fs =
+            List.partition_tf (to_list t) ~f:(fun elt -> Elt.compare elt e <= 0)
+          in
+          (create of_list) ts, create of_list fs
+        in
+        require_equal (module Inst_and_inst.Value) by_partition_tf expect;
+        require_equal (module Inst_and_inst.Value) by_filter expect)
+
+  and group_by = group_by
+
+  and () =
+    quickcheck_m
+      (module Inst_and_int)
+      ~f:(fun (t, i) ->
+        let t = Inst.value t in
+        let f e = Elt.to_int e % i in
+        let actual = group_by t ~equiv:(Comparable.lift Int.equal ~f) in
+        let expect =
+          List.sort_and_group ~compare:(Comparable.lift Int.compare ~f) (to_list t)
+          |> List.map ~f:(create of_list)
+        in
+        require_equal
+          (module struct
+            type t = Inst_list.Value.t [@@deriving sexp_of]
+
+            let equal =
+              Comparable.lift
+                Inst_list.Value.equal
+                ~f:(List.sort ~compare:Inst.Value.compare)
+            ;;
+          end)
+          actual
+          expect)
+
+  and diff = diff
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual = (access diff) a b in
+        let expect =
+          (create of_list) (List.filter (to_list a) ~f:(fun e -> not ((access mem) b e)))
+        in
+        require_equal (module Inst.Value) actual expect)
+
+  and inter = inter
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual = (access inter) a b in
+        let expect = (create of_list) (List.filter (to_list a) ~f:((access mem) b)) in
+        require_equal (module Inst.Value) actual expect)
+
+  and union = union
+
+  and () =
+    quickcheck_m
+      (module Inst_and_inst)
+      ~f:(fun (a, b) ->
+        let a = Inst.value a in
+        let b = Inst.value b in
+        let actual = (access union) a b in
+        let expect = (create of_list) (to_list a @ to_list b) in
+        require_equal (module Inst.Value) actual expect)
+
+  and split = split
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        require_equal
+          (module struct
+            type t = Inst.Value.t * Elt.t option * Inst.Value.t
+            [@@deriving equal, sexp_of]
+          end)
+          (access split t e)
+          (let before, equal, after =
+             List.partition3_map (to_list t) ~f:(fun elt ->
+               match Ordering.of_int (Elt.compare elt e) with
+               | Less -> `Fst elt
+               | Equal -> `Snd elt
+               | Greater -> `Trd elt)
+           in
+           create of_list before, List.hd equal, create of_list after))
+
+  and split_le_gt = split_le_gt
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        require_equal
+          (module struct
+            type t = Inst.Value.t * Inst.Value.t [@@deriving equal, sexp_of]
+          end)
+          (access split_le_gt t e)
+          (let before, after =
+             List.partition_tf (to_list t) ~f:(fun elt -> Elt.( <= ) elt e)
+           in
+           create of_list before, create of_list after))
+
+  and split_lt_ge = split_lt_ge
+
+  and () =
+    quickcheck_m
+      (module Inst_and_elt)
+      ~f:(fun (t, e) ->
+        let t = Inst.value t in
+        require_equal
+          (module struct
+            type t = Inst.Value.t * Inst.Value.t [@@deriving equal, sexp_of]
+          end)
+          (access split_lt_ge t e)
+          (let before, after =
+             List.partition_tf (to_list t) ~f:(fun elt -> Elt.( < ) elt e)
+           in
+           create of_list before, create of_list after))
+  ;;
+end
diff --git a/test/coverage/set/functor.mli b/test/coverage/set/functor.mli
new file mode 100644
index 00000000..b831749b
--- /dev/null
+++ b/test/coverage/set/functor.mli
@@ -0,0 +1 @@
+include Functor_intf.Functor
diff --git a/test/coverage/set/functor_intf.ml b/test/coverage/set/functor_intf.ml
new file mode 100644
index 00000000..5873d1f9
--- /dev/null
+++ b/test/coverage/set/functor_intf.ml
@@ -0,0 +1,135 @@
+open! Base
+
+module Definitions = struct
+  (** The types that distinguish instances of
+      [Set.Creators_and_accessors_and_transformers_generic]. *)
+  module type Types = sig
+    type 'e elt
+    type 'c cmp
+    type ('e, 'c) set
+    type ('e, 'c) t = ('e elt, 'c cmp) set
+    type ('e, 'c) tree
+    type ('e, 'c, 'a) create_options
+    type ('e, 'c, 'a) access_options
+  end
+
+  (** Like [Set.Creators_generic], but based on [Types] for easier instantiation. *)
+  module type Creators = sig
+    module Types : Types
+
+    include
+      Set.Creators_generic
+      with type ('a, 'b) t := ('a, 'b) Types.t
+      with type ('a, 'b) set := ('a, 'b) Types.set
+      with type ('a, 'b) tree := ('a, 'b) Types.tree
+      with type 'a elt := 'a Types.elt
+      with type 'a cmp := 'a Types.cmp
+      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Types.create_options
+  end
+
+  (** Like [Set.Accessors_generic], but based on [Types] for easier instantiation. *)
+  module type Accessors = sig
+    module Types : Types
+
+    include
+      Set.Accessors_generic
+      with type ('a, 'b) t := ('a, 'b) Types.t
+      with type ('a, 'b) tree := ('a, 'b) Types.tree
+      with type 'a elt := 'a Types.elt
+      with type 'a cmp := 'a Types.cmp
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Types.access_options
+  end
+
+  (** Like [Set.Transformers_generic], but based on [Types] for easier instantiation. *)
+  module type Transformers = sig
+    module Types : Types
+
+    include
+      Set.Transformers_generic
+      with type ('a, 'b) t := ('a, 'b) Types.t
+      with type ('a, 'b) tree := ('a, 'b) Types.tree
+      with type 'a elt := 'a Types.elt
+      with type 'a cmp := 'a Types.cmp
+      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Types.access_options
+  end
+
+  (** Like [Set.Creators_and_accessors_and_transformers_generic], but based on [Types] for
+      easier instantiation. *)
+  module type Impl = sig
+    module Types : Types
+    include Creators with module Types := Types
+    include Accessors with module Types := Types
+    include Transformers with module Types := Types
+  end
+
+  module type Elt = sig
+    module Types : Types
+
+    type t = int Types.elt [@@deriving compare, equal, quickcheck, sexp_of]
+
+    include Comparable.Infix with type t := t
+
+    include
+      Comparator.S
+      with type t := t
+       and type comparator_witness = Int.comparator_witness Types.cmp
+
+    val of_int : int -> t
+    val to_int : t -> int
+  end
+
+  (** Helpers for testing a tree or map type that is an instance of [S]. *)
+  module type Instance = sig
+    module Types : Types
+    module Elt : Elt with module Types := Types
+
+    type t = (int, Int.comparator_witness) Types.t [@@deriving compare, equal, sexp_of]
+
+    (** Pass a comparator to a creator function, if necessary. *)
+    val create : (int, Int.comparator_witness, 'a) Types.create_options -> 'a
+
+    (** Pass a comparator to an accessor function, if necessary *)
+    val access : (int, Int.comparator_witness, 'a) Types.access_options -> 'a
+  end
+
+  module type Generate = sig
+    module Instance : Instance
+
+    type t [@@deriving equal, quickcheck, sexp_of]
+
+    module Value : sig
+      type t = Instance.t [@@deriving compare, equal, sexp_of]
+    end
+
+    val value : t -> Value.t
+  end
+end
+
+module type Functor = sig
+  include module type of struct
+    include Definitions
+  end
+
+  (** Expect tests for everything exported from [Set.Creators_generic]. *)
+  module Test_creators
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Creators with module Types := Instance.Types
+
+  (** Expect tests for everything exported from [Set.Accessors_generic]. *)
+  module Test_accessors
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Accessors with module Types := Instance.Types
+
+  (** Expect tests for everything exported from [Set.Transformers_generic]. *)
+  module Test_transformers
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Transformers with module Types := Instance.Types
+
+  module Generate
+      (Instance : Instance)
+      (Impl : Impl with module Types := Instance.Types) :
+    Generate with module Instance := Instance
+end
diff --git a/test/coverage/set/instances.ml b/test/coverage/set/instances.ml
new file mode 100644
index 00000000..0cdf0b5c
--- /dev/null
+++ b/test/coverage/set/instances.ml
@@ -0,0 +1,64 @@
+open! Base
+open Base_quickcheck
+open Base_test_coverage_helpers
+open Overrides
+include Instances_intf.Definitions
+
+module Make_elt
+    (Types : Functor.Types with type 'elt elt = 'elt)
+    (Cmp : sig
+       val comparator : (int, Int.comparator_witness Types.cmp) Comparator.t
+     end) : Functor.Elt with module Types := Types = struct
+  type t = int [@@deriving compare, equal, quickcheck, sexp_of]
+  type comparator_witness = Int.comparator_witness Types.cmp
+
+  let comparator = Cmp.comparator
+
+  include (Int : Comparable.Infix with type t := t)
+
+  let of_int = Fn.id
+  let to_int = Fn.id
+end
+
+module Poly = struct
+  module Types = Types.Poly
+  module Elt = Make_elt (Types) (Comparator.Poly)
+
+  type t = Set.M(Elt).t [@@deriving compare, equal, sexp_of]
+
+  let create x = x
+  let access x = x
+end
+
+module Toplevel = struct
+  module Types = Types.Toplevel
+  module Elt = Make_elt (Types) (Int)
+
+  type t = Set.M(Elt).t [@@deriving compare, equal, sexp_of]
+
+  let create f = f ((module Int) : _ Comparator.Module.t)
+  let access x = x
+end
+
+module Tree = struct
+  module Types = Types.Tree
+  module Elt = Make_elt (Types) (Int)
+
+  type t = (int, Int.comparator_witness) Types.t
+
+  let compare = Comparable.lift Toplevel.compare ~f:(Set.of_tree (module Elt))
+  let equal = Comparable.lift Toplevel.equal ~f:(Set.of_tree (module Elt))
+  let sexp_of_t t = Toplevel.sexp_of_t (Set.of_tree (module Elt) t)
+  let create f = f ~comparator:Int.comparator
+  let access f = f ~comparator:Int.comparator
+end
+
+module Using_comparator = struct
+  module Types = Types.Using_comparator
+  module Elt = Make_elt (Types) (Int)
+
+  type t = Set.M(Elt).t [@@deriving compare, equal, sexp_of]
+
+  let create f = f ~comparator:Int.comparator
+  let access x = x
+end
diff --git a/test/coverage/set/instances.mli b/test/coverage/set/instances.mli
new file mode 100644
index 00000000..174eeb6e
--- /dev/null
+++ b/test/coverage/set/instances.mli
@@ -0,0 +1 @@
+include Instances_intf.Instances
diff --git a/test/coverage/set/instances_intf.ml b/test/coverage/set/instances_intf.ml
new file mode 100644
index 00000000..1cdef84b
--- /dev/null
+++ b/test/coverage/set/instances_intf.ml
@@ -0,0 +1,59 @@
+open! Base
+
+module Definitions = struct
+  module Types = struct
+    module Poly = struct
+      type 'elt elt = 'elt
+      type 'cmp cmp = Comparator.Poly.comparator_witness
+      type ('elt, 'cmp) set = ('elt, 'cmp) Set.t
+      type ('elt, 'cmp) t = 'elt Set.Poly.t
+
+      type ('elt, 'cmp) tree =
+        ('elt, Comparator.Poly.comparator_witness) Set.Using_comparator.Tree.t
+
+      type ('elt, 'cmp, 'fn) create_options = 'fn
+      type ('elt, 'cmp, 'fn) access_options = 'fn
+    end
+
+    module Toplevel = struct
+      type 'elt elt = 'elt
+      type 'cmp cmp = 'cmp
+      type ('elt, 'cmp) set = ('elt, 'cmp) Set.t
+      type ('elt, 'cmp) t = ('elt, 'cmp) Set.t
+      type ('elt, 'cmp) tree = ('elt, 'cmp) Set.Using_comparator.Tree.t
+      type ('elt, 'cmp, 'fn) create_options = ('elt, 'cmp) Comparator.Module.t -> 'fn
+      type ('elt, 'cmp, 'fn) access_options = 'fn
+    end
+
+    module Tree = struct
+      type 'elt elt = 'elt
+      type 'cmp cmp = 'cmp
+      type ('elt, 'cmp) set = ('elt, 'cmp) Set.Using_comparator.Tree.t
+      type ('elt, 'cmp) t = ('elt, 'cmp) Set.Using_comparator.Tree.t
+      type ('elt, 'cmp) tree = ('elt, 'cmp) Set.Using_comparator.Tree.t
+      type ('elt, 'cmp, 'fn) create_options = comparator:('elt, 'cmp) Comparator.t -> 'fn
+      type ('elt, 'cmp, 'fn) access_options = comparator:('elt, 'cmp) Comparator.t -> 'fn
+    end
+
+    module Using_comparator = struct
+      type 'elt elt = 'elt
+      type 'cmp cmp = 'cmp
+      type ('elt, 'cmp) set = ('elt, 'cmp) Set.Using_comparator.t
+      type ('elt, 'cmp) t = ('elt, 'cmp) Set.Using_comparator.t
+      type ('elt, 'cmp) tree = ('elt, 'cmp) Set.Using_comparator.Tree.t
+      type ('elt, 'cmp, 'fn) create_options = comparator:('elt, 'cmp) Comparator.t -> 'fn
+      type ('elt, 'cmp, 'fn) access_options = 'fn
+    end
+  end
+end
+
+module type Instances = sig
+  include module type of struct
+    include Definitions
+  end
+
+  module Poly : Functor.Instance with module Types = Types.Poly
+  module Toplevel : Functor.Instance with module Types = Types.Toplevel
+  module Tree : Functor.Instance with module Types = Types.Tree
+  module Using_comparator : Functor.Instance with module Types = Types.Using_comparator
+end
diff --git a/test/coverage/set/test_all.ml b/test/coverage/set/test_all.ml
new file mode 100644
index 00000000..5ace572c
--- /dev/null
+++ b/test/coverage/set/test_all.ml
@@ -0,0 +1,305 @@
+open! Base
+open Expect_test_helpers_base
+open Base_test_coverage_helpers
+open Functor
+open Set
+open Overrides
+
+open struct
+  (** Instantiating key and data both as [int]. *)
+  module Instance = struct
+    include Generate (Instances.Toplevel) (Base.Set)
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Instance_pair = struct
+    include Data.Pair (Instance)
+
+    let sample = Memo.memoize [%generator: t]
+  end
+
+  module Tree_int = struct
+    include Generate (Instances.Tree) (Base.Set.Using_comparator.Tree)
+
+    let sample = Memo.memoize [%generator: t]
+  end
+end
+
+(** module types *)
+
+module type Accessors_generic = Accessors_generic
+module type Transformers_generic = Transformers_generic
+
+module type Creators_and_accessors_and_transformers_generic =
+  Creators_and_accessors_and_transformers_generic
+
+module type Creators_generic = Creators_generic
+module type Elt_plain = Elt_plain
+module type For_deriving = For_deriving
+module type S_poly = S_poly
+
+(** type-only modules for module type instantiation - untested *)
+
+module With_comparator = With_comparator
+module With_first_class_module = With_first_class_module
+module Without_comparator = Without_comparator
+
+(** supporting datatypes - untested *)
+
+module Merge_to_sequence_element = Merge_to_sequence_element
+
+(** private module - untested *)
+
+module Private = Private [@alert "-set_private"]
+
+(** types *)
+
+type nonrec ('e, 'c) t = ('e, 'c) t
+
+(** module types for ppx deriving *)
+
+module type Compare_m = Compare_m
+module type Equal_m = Equal_m
+module type Hash_fold_m = Hash_fold_m
+module type M_sexp_grammar = M_sexp_grammar
+module type M_of_sexp = M_of_sexp
+module type Sexp_of_m = Sexp_of_m
+
+(** functor for ppx deriving - tested below *)
+
+module M = M
+
+(** sexp conversions and grammar *)
+
+let sexp_of_m__t = sexp_of_m__t
+let m__t_of_sexp = m__t_of_sexp
+
+let%expect_test _ =
+  quickcheck_m
+    (module Instance)
+    ~f:(fun t ->
+      let t = Instance.value t in
+      let sexp = [%sexp_of: M(Int).t] t in
+      require_equal (module Sexp) sexp [%sexp (to_list t : int list)];
+      let round_trip = [%of_sexp: M(Int).t] sexp in
+      require_equal (module Instance.Value) round_trip t);
+  [%expect {| |}]
+;;
+
+let m__t_sexp_grammar = m__t_sexp_grammar
+
+let%expect_test _ =
+  print_s [%sexp ([%sexp_grammar: M(Int).t] : _ Sexp_grammar.t)];
+  [%expect {| (List (Many Integer)) |}]
+;;
+
+(** comparisons *)
+
+let compare = compare
+let compare_m__t = compare_m__t
+let equal_m__t = equal_m__t
+
+let%expect_test _ =
+  quickcheck_m
+    (module Instance_pair)
+    ~f:(fun (a, b) ->
+      let a = Instance.value a in
+      let b = Instance.value b in
+      require_equal
+        (module Ordering)
+        (Ordering.of_int ([%compare: M(Int).t] a b))
+        (Ordering.of_int ([%compare: int list] (to_list a) (to_list b)));
+      require_equal
+        (module Ordering)
+        (Ordering.of_int ([%compare: M(Int).t] a b))
+        (Ordering.of_int (compare Int.compare [%compare: _] a b));
+      require_equal
+        (module Bool)
+        ([%equal: M(Int).t] a b)
+        ([%equal: int list] (to_list a) (to_list b)));
+  [%expect {| |}]
+;;
+
+(** hash functions *)
+
+let hash_m__t = hash_m__t
+let hash_fold_m__t = hash_fold_m__t
+let hash_fold_direct = hash_fold_direct
+
+let%expect_test _ =
+  quickcheck_m
+    (module Instance)
+    ~f:(fun t ->
+      let t = Instance.value t in
+      let actual_m = [%hash: M(Int).t] t in
+      let actual_fold_m = Hash.run [%hash_fold: M(Int).t] t in
+      let actual_fold_direct = Hash.run (hash_fold_direct Int.hash_fold_t) t in
+      let expect = Hash.run [%hash_fold: int list] (to_list t) in
+      require_equal (module Int) actual_m expect;
+      require_equal (module Int) actual_fold_m expect;
+      require_equal (module Int) actual_fold_direct expect);
+  [%expect {| |}]
+;;
+
+(** comparator accessors - untested *)
+
+let comparator_s = comparator_s
+let comparator = comparator
+
+(** creators and accessors and transformers *)
+
+include (
+  Test_toplevel_accessors :
+    Functor.Accessors with module Types := Instances.Types.Toplevel)
+
+include (
+  Test_toplevel_creators : Functor.Creators with module Types := Instances.Types.Toplevel)
+
+include (
+  Test_toplevel_transformers :
+    Functor.Transformers with module Types := Instances.Types.Toplevel)
+
+module Named = struct
+  type 'a t = 'a Set.Named.t =
+    { set : 'a
+    ; name : string
+    }
+
+  include Named
+end
+
+(** polymorphic comparison interface *)
+module Poly = struct
+  open Poly
+
+  type nonrec 'e t = 'e t
+
+  include (
+    Test_poly_accessors : Functor.Accessors with module Types := Instances.Types.Poly)
+
+  include (
+    Test_poly_creators : Functor.Creators with module Types := Instances.Types.Poly)
+
+  include (
+    Test_poly_transformers :
+      Functor.Transformers with module Types := Instances.Types.Poly)
+end
+
+(** comparator interface *)
+
+module Using_comparator = struct
+  open Using_comparator
+
+  (** type *)
+
+  type nonrec ('e, 'c) t = ('e, 'c) t
+
+  (** comparator accessor - untested *)
+
+  let comparator = comparator
+  let comparator_s = comparator_s
+
+  (** sexp conversions *)
+
+  let sexp_of_t = sexp_of_t
+  let t_of_sexp_direct = t_of_sexp_direct
+
+  let%expect_test _ =
+    quickcheck_m
+      (module Instance)
+      ~f:(fun t ->
+        let t = Instance.value t in
+        let sexp = sexp_of_t Int.sexp_of_t [%sexp_of: _] t in
+        require_equal (module Sexp) sexp ([%sexp_of: Set.M(Int).t] t);
+        let round_trip = t_of_sexp_direct ~comparator:Int.comparator Int.t_of_sexp sexp in
+        require_equal (module Instance.Value) round_trip t);
+    [%expect {| |}]
+  ;;
+
+  (** hash function *)
+
+  let hash_fold_direct = hash_fold_direct
+
+  let%expect_test _ =
+    quickcheck_m
+      (module Instance)
+      ~f:(fun t ->
+        let t = Instance.value t in
+        require_equal
+          (module Int)
+          (Hash.run (hash_fold_direct Int.hash_fold_t) t)
+          (Hash.run [%hash_fold: Set.M(Int).t] t));
+    [%expect {| |}]
+  ;;
+
+  (** functor for polymorphic definition - untested *)
+
+  module Empty_without_value_restriction (Cmp : Comparator.S1) = struct
+    open Empty_without_value_restriction (Cmp)
+
+    let empty = empty
+  end
+
+  (** creators and accessors and transformers *)
+
+  include (
+    Test_using_comparator_accessors :
+      Functor.Accessors with module Types := Instances.Types.Using_comparator)
+
+  include (
+    Test_using_comparator_creators :
+      Functor.Creators with module Types := Instances.Types.Using_comparator)
+
+  include (
+    Test_using_comparator_transformers :
+      Functor.Transformers with module Types := Instances.Types.Using_comparator)
+
+  (** tree interface *)
+
+  module Tree = struct
+    open Tree
+
+    (** type *)
+
+    type nonrec ('e, 'c) t = ('e, 'c) t
+
+    (** sexp conversions *)
+
+    let sexp_of_t = sexp_of_t
+    let t_of_sexp_direct = t_of_sexp_direct
+
+    let%expect_test _ =
+      quickcheck_m
+        (module Tree_int)
+        ~f:(fun tree ->
+          let tree = Tree_int.value tree in
+          let sexp = sexp_of_t Int.sexp_of_t [%sexp_of: _] tree in
+          require_equal
+            (module Sexp)
+            sexp
+            ([%sexp_of: Set.M(Int).t]
+               (Using_comparator.of_tree tree ~comparator:Int.comparator));
+          let round_trip =
+            t_of_sexp_direct ~comparator:Int.comparator Int.t_of_sexp sexp
+          in
+          require_equal (module Tree_int.Value) round_trip tree)
+    ;;
+
+    (** polymorphic constructor - untested *)
+
+    let empty_without_value_restriction = empty_without_value_restriction
+
+    (** creators and accessors and transformers *)
+
+    include (
+      Test_tree_accessors : Functor.Accessors with module Types := Instances.Types.Tree)
+
+    include (
+      Test_tree_creators : Functor.Creators with module Types := Instances.Types.Tree)
+
+    include (
+      Test_tree_transformers :
+        Functor.Transformers with module Types := Instances.Types.Tree)
+  end
+end
diff --git a/test/coverage/set/test_all.mli b/test/coverage/set/test_all.mli
new file mode 100644
index 00000000..1ed78ce7
--- /dev/null
+++ b/test/coverage/set/test_all.mli
@@ -0,0 +1,5 @@
+open! Base
+
+include module type of struct
+  include Set
+end [@remove_aliases]
diff --git a/test/coverage/set/test_poly_accessors.ml b/test/coverage/set/test_poly_accessors.ml
new file mode 100644
index 00000000..e5e34b3e
--- /dev/null
+++ b/test/coverage/set/test_poly_accessors.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set.Poly
+
+let%expect_test "[Base.Set.Poly] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Poly) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (Implementation : Functor.Accessors with module Types := Instances.Types.Poly)
diff --git a/test/coverage/set/test_poly_accessors.mli b/test/coverage/set/test_poly_accessors.mli
new file mode 100644
index 00000000..bec58887
--- /dev/null
+++ b/test/coverage/set/test_poly_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Poly
diff --git a/test/coverage/set/test_poly_creators.ml b/test/coverage/set/test_poly_creators.ml
new file mode 100644
index 00000000..0748cc97
--- /dev/null
+++ b/test/coverage/set/test_poly_creators.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set.Poly
+
+let%expect_test "[Base.Set.Poly] creators/accessors" =
+  let open Functor.Test_creators (Instances.Poly) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (Implementation : Functor.Creators with module Types := Instances.Types.Poly)
diff --git a/test/coverage/set/test_poly_creators.mli b/test/coverage/set/test_poly_creators.mli
new file mode 100644
index 00000000..69ba2e87
--- /dev/null
+++ b/test/coverage/set/test_poly_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Poly
diff --git a/test/coverage/set/test_poly_transformers.ml b/test/coverage/set/test_poly_transformers.ml
new file mode 100644
index 00000000..0864a249
--- /dev/null
+++ b/test/coverage/set/test_poly_transformers.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set.Poly
+
+let%expect_test "[Base.Set.Poly] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Poly) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (Implementation : Functor.Transformers with module Types := Instances.Types.Poly)
diff --git a/test/coverage/set/test_poly_transformers.mli b/test/coverage/set/test_poly_transformers.mli
new file mode 100644
index 00000000..e157a8d2
--- /dev/null
+++ b/test/coverage/set/test_poly_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Poly
diff --git a/test/coverage/set/test_toplevel_accessors.ml b/test/coverage/set/test_toplevel_accessors.ml
new file mode 100644
index 00000000..ecaa891d
--- /dev/null
+++ b/test/coverage/set/test_toplevel_accessors.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set
+
+let%expect_test "[Base.Set] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Toplevel) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (Implementation : Functor.Accessors with module Types := Instances.Types.Toplevel)
diff --git a/test/coverage/set/test_toplevel_accessors.mli b/test/coverage/set/test_toplevel_accessors.mli
new file mode 100644
index 00000000..f45b2b7a
--- /dev/null
+++ b/test/coverage/set/test_toplevel_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Toplevel
diff --git a/test/coverage/set/test_toplevel_creators.ml b/test/coverage/set/test_toplevel_creators.ml
new file mode 100644
index 00000000..8187e198
--- /dev/null
+++ b/test/coverage/set/test_toplevel_creators.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set
+
+let%expect_test "[Base.Set] creators/accessors" =
+  let open Functor.Test_creators (Instances.Toplevel) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (Implementation : Functor.Creators with module Types := Instances.Types.Toplevel)
diff --git a/test/coverage/set/test_toplevel_creators.mli b/test/coverage/set/test_toplevel_creators.mli
new file mode 100644
index 00000000..a270f003
--- /dev/null
+++ b/test/coverage/set/test_toplevel_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Toplevel
diff --git a/test/coverage/set/test_toplevel_transformers.ml b/test/coverage/set/test_toplevel_transformers.ml
new file mode 100644
index 00000000..923c0b26
--- /dev/null
+++ b/test/coverage/set/test_toplevel_transformers.ml
@@ -0,0 +1,10 @@
+open! Base
+module Implementation = Base.Set
+
+let%expect_test "[Base.Set] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Toplevel) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (
+  Implementation : Functor.Transformers with module Types := Instances.Types.Toplevel)
diff --git a/test/coverage/set/test_toplevel_transformers.mli b/test/coverage/set/test_toplevel_transformers.mli
new file mode 100644
index 00000000..b63f012b
--- /dev/null
+++ b/test/coverage/set/test_toplevel_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Toplevel
diff --git a/test/coverage/set/test_tree_accessors.ml b/test/coverage/set/test_tree_accessors.ml
new file mode 100644
index 00000000..eacacb17
--- /dev/null
+++ b/test/coverage/set/test_tree_accessors.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set.Using_comparator.Tree
+
+let%expect_test "[Base.Set.Using_comparator.Tree] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Tree) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (Implementation : Functor.Accessors with module Types := Instances.Types.Tree)
diff --git a/test/coverage/set/test_tree_accessors.mli b/test/coverage/set/test_tree_accessors.mli
new file mode 100644
index 00000000..7a3442d9
--- /dev/null
+++ b/test/coverage/set/test_tree_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Tree
diff --git a/test/coverage/set/test_tree_creators.ml b/test/coverage/set/test_tree_creators.ml
new file mode 100644
index 00000000..dfe59ee1
--- /dev/null
+++ b/test/coverage/set/test_tree_creators.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set.Using_comparator.Tree
+
+let%expect_test "[Base.Set.Using_comparator.Tree] creators/accessors" =
+  let open Functor.Test_creators (Instances.Tree) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (Implementation : Functor.Creators with module Types := Instances.Types.Tree)
diff --git a/test/coverage/set/test_tree_creators.mli b/test/coverage/set/test_tree_creators.mli
new file mode 100644
index 00000000..661a0bef
--- /dev/null
+++ b/test/coverage/set/test_tree_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Tree
diff --git a/test/coverage/set/test_tree_transformers.ml b/test/coverage/set/test_tree_transformers.ml
new file mode 100644
index 00000000..f1d99f43
--- /dev/null
+++ b/test/coverage/set/test_tree_transformers.ml
@@ -0,0 +1,9 @@
+open! Base
+module Implementation = Base.Set.Using_comparator.Tree
+
+let%expect_test "[Base.Set.Using_comparator.Tree] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Tree) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (Implementation : Functor.Transformers with module Types := Instances.Types.Tree)
diff --git a/test/coverage/set/test_tree_transformers.mli b/test/coverage/set/test_tree_transformers.mli
new file mode 100644
index 00000000..092966d7
--- /dev/null
+++ b/test/coverage/set/test_tree_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Tree
diff --git a/test/coverage/set/test_using_comparator_accessors.ml b/test/coverage/set/test_using_comparator_accessors.ml
new file mode 100644
index 00000000..ba04f18a
--- /dev/null
+++ b/test/coverage/set/test_using_comparator_accessors.ml
@@ -0,0 +1,10 @@
+open! Base
+module Implementation = Base.Set.Using_comparator
+
+let%expect_test "[Base.Set.Using_comparator] creators/accessors" =
+  let open Functor.Test_accessors (Instances.Using_comparator) (Implementation) in
+  [%expect {| Functor.Test_accessors: running tests. |}]
+;;
+
+include (
+  Implementation : Functor.Accessors with module Types := Instances.Types.Using_comparator)
diff --git a/test/coverage/set/test_using_comparator_accessors.mli b/test/coverage/set/test_using_comparator_accessors.mli
new file mode 100644
index 00000000..7e7118b4
--- /dev/null
+++ b/test/coverage/set/test_using_comparator_accessors.mli
@@ -0,0 +1 @@
+include Functor.Accessors with module Types := Instances.Types.Using_comparator
diff --git a/test/coverage/set/test_using_comparator_creators.ml b/test/coverage/set/test_using_comparator_creators.ml
new file mode 100644
index 00000000..3c963586
--- /dev/null
+++ b/test/coverage/set/test_using_comparator_creators.ml
@@ -0,0 +1,10 @@
+open! Base
+module Implementation = Base.Set.Using_comparator
+
+let%expect_test "[Base.Set.Using_comparator] creators/accessors" =
+  let open Functor.Test_creators (Instances.Using_comparator) (Implementation) in
+  [%expect {| Functor.Test_creators: running tests. |}]
+;;
+
+include (
+  Implementation : Functor.Creators with module Types := Instances.Types.Using_comparator)
diff --git a/test/coverage/set/test_using_comparator_creators.mli b/test/coverage/set/test_using_comparator_creators.mli
new file mode 100644
index 00000000..aa3fd102
--- /dev/null
+++ b/test/coverage/set/test_using_comparator_creators.mli
@@ -0,0 +1 @@
+include Functor.Creators with module Types := Instances.Types.Using_comparator
diff --git a/test/coverage/set/test_using_comparator_transformers.ml b/test/coverage/set/test_using_comparator_transformers.ml
new file mode 100644
index 00000000..f02e02ef
--- /dev/null
+++ b/test/coverage/set/test_using_comparator_transformers.ml
@@ -0,0 +1,11 @@
+open! Base
+module Implementation = Base.Set.Using_comparator
+
+let%expect_test "[Base.Set.Using_comparator] creators/accessors" =
+  let open Functor.Test_transformers (Instances.Using_comparator) (Implementation) in
+  [%expect {| Functor.Test_transformers: running tests. |}]
+;;
+
+include (
+  Implementation :
+    Functor.Transformers with module Types := Instances.Types.Using_comparator)
diff --git a/test/coverage/set/test_using_comparator_transformers.mli b/test/coverage/set/test_using_comparator_transformers.mli
new file mode 100644
index 00000000..3a8f6d69
--- /dev/null
+++ b/test/coverage/set/test_using_comparator_transformers.mli
@@ -0,0 +1 @@
+include Functor.Transformers with module Types := Instances.Types.Using_comparator
diff --git a/test/dune b/test/dune
index afd1ada9..186e16ca 100644
--- a/test/dune
+++ b/test/dune
@@ -1,7 +1,7 @@
 (library
  (name base_test)
  (libraries base base_container_tests core.base_for_tests base_test_helpers
-   expect_test_helpers_core.expect_test_helpers_base sexplib
-   sexp_grammar_validation num stdio)
+   bignum.bigint expect_test_helpers_core.expect_test_helpers_base
+   sexp_grammar_validation sexplib stdio)
  (preprocess
   (pps ppx_jane -dont-apply=pipebang -no-check-on-extensions)))
diff --git a/test/hashtbl_tests.ml b/test/hashtbl_tests.ml
index f8a39289..27ea255e 100644
--- a/test/hashtbl_tests.ml
+++ b/test/hashtbl_tests.ml
@@ -345,10 +345,10 @@ end
    [Creators_generic].  *)
 module _ : sig end = struct
   module Make_creators_check
-    (Type : T.T2)
-    (Key : T.T1)
-    (Options : T.T3)
-    (_ : Hashtbl.Private.Creators_generic
+      (Type : T.T2)
+      (Key : T.T1)
+      (Options : T.T3)
+      (_ : Hashtbl.Private.Creators_generic
            with type ('a, 'b) t := ('a, 'b) Type.t
            with type 'a key := 'a Key.t
            with type ('a, 'b, 'z) create_options := ('a, 'b, 'z) Options.t) =
diff --git a/test/helpers/test_container.ml b/test/helpers/test_container.ml
index 10ef2e6a..dc73c236 100644
--- a/test/helpers/test_container.ml
+++ b/test/helpers/test_container.ml
@@ -1,27 +1,29 @@
 open! Base
 open! Container
 
-module Test_generic (Elt : sig
-  type 'a t
+module Test_generic
+    (Elt : sig
+       type 'a t
 
-  val of_int : int -> int t
-  val to_int : int t -> int
-end) (Container : sig
-  type 'a t [@@deriving sexp]
+       val of_int : int -> int t
+       val to_int : int t -> int
+     end)
+    (Container : sig
+       type 'a t [@@deriving sexp]
 
-  include Generic with type ('a, _, _) t := 'a t with type 'a elt := 'a Elt.t
+       include Generic with type ('a, _, _) t := 'a t with type 'a elt := 'a Elt.t
 
-  val mem : 'a t -> 'a Elt.t -> equal:('a Elt.t -> 'a Elt.t -> bool) -> bool
-  val of_list : 'a Elt.t list -> [ `Ok of 'a t | `Skip_test ]
-end) : sig
-  type 'a t [@@deriving sexp]
+       val mem : 'a t -> 'a Elt.t -> equal:('a Elt.t -> 'a Elt.t -> bool) -> bool
+       val of_list : 'a Elt.t list -> [ `Ok of 'a t | `Skip_test ]
+     end) : sig
+    type 'a t [@@deriving sexp]
 
-  include Generic with type ('a, _, _) t := 'a t
+    include Generic with type ('a, _, _) t := 'a t
 
-  val mem : 'a t -> 'a Elt.t -> equal:('a Elt.t -> 'a Elt.t -> bool) -> bool
-end
-with type 'a t := 'a Container.t
-with type 'a elt := 'a Elt.t =
+    val mem : 'a t -> 'a Elt.t -> equal:('a Elt.t -> 'a Elt.t -> bool) -> bool
+  end
+  with type 'a t := 'a Container.t
+  with type 'a elt := 'a Elt.t =
 (* This signature constraint reminds us to add unit tests when functions are added to
    [Generic]. *)
 struct
@@ -142,12 +144,12 @@ struct
 end
 
 module Test_S1_allow_skipping_tests (Container : sig
-  type 'a t [@@deriving sexp]
+    type 'a t [@@deriving sexp]
 
-  include Container.S1 with type 'a t := 'a t
+    include Container.S1 with type 'a t := 'a t
 
-  val of_list : 'a list -> [ `Ok of 'a t | `Skip_test ]
-end) =
+    val of_list : 'a list -> [ `Ok of 'a t | `Skip_test ]
+  end) =
 struct
   include
     Test_generic
@@ -161,32 +163,32 @@ struct
 end
 
 module Test_S1 (Container : sig
-  type 'a t [@@deriving sexp]
+    type 'a t [@@deriving sexp]
 
-  include Container.S1 with type 'a t := 'a t
+    include Container.S1 with type 'a t := 'a t
 
-  val of_list : 'a list -> 'a t
-end) =
+    val of_list : 'a list -> 'a t
+  end) =
 Test_S1_allow_skipping_tests (struct
-  include Container
+    include Container
 
-  let of_list l = `Ok (of_list l)
-end)
+    let of_list l = `Ok (of_list l)
+  end)
 
 module Test_S0 (Container : sig
-  module Elt : sig
-    type t [@@deriving sexp]
+    module Elt : sig
+      type t [@@deriving sexp]
 
-    val of_int : int -> t
-    val to_int : t -> int
-  end
+      val of_int : int -> t
+      val to_int : t -> int
+    end
 
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Container.S0 with type t := t and type elt := Elt.t
+    include Container.S0 with type t := t and type elt := Elt.t
 
-  val of_list : Elt.t list -> t
-end) =
+    val of_list : Elt.t list -> t
+  end) =
 struct
   include
     Test_generic
diff --git a/test/helpers/test_container.mli b/test/helpers/test_container.mli
index 736359a3..c71080a2 100644
--- a/test/helpers/test_container.mli
+++ b/test/helpers/test_container.mli
@@ -2,56 +2,56 @@ open! Base
 open! Container
 
 module Test_S1_allow_skipping_tests (Container : sig
-  type 'a t [@@deriving sexp]
+    type 'a t [@@deriving sexp]
 
-  include Container.S1 with type 'a t := 'a t
+    include Container.S1 with type 'a t := 'a t
 
-  val of_list : 'a list -> [ `Ok of 'a t | `Skip_test ]
-end) : sig
-  type 'a t [@@deriving sexp]
+    val of_list : 'a list -> [ `Ok of 'a t | `Skip_test ]
+  end) : sig
+    type 'a t [@@deriving sexp]
 
-  include Generic with type ('a, _, _) t := 'a t
+    include Generic with type ('a, _, _) t := 'a t
 
-  val mem : 'a t -> 'a -> equal:('a -> 'a -> bool) -> bool
-end
-with type 'a t := 'a Container.t
-with type 'a elt := 'a
+    val mem : 'a t -> 'a -> equal:('a -> 'a -> bool) -> bool
+  end
+  with type 'a t := 'a Container.t
+  with type 'a elt := 'a
 
 module Test_S1 (Container : sig
-  type 'a t [@@deriving sexp]
+    type 'a t [@@deriving sexp]
 
-  include Container.S1 with type 'a t := 'a t
+    include Container.S1 with type 'a t := 'a t
 
-  val of_list : 'a list -> 'a t
-end) : sig
-  type 'a t [@@deriving sexp]
+    val of_list : 'a list -> 'a t
+  end) : sig
+    type 'a t [@@deriving sexp]
 
-  include Generic with type ('a, _, _) t := 'a t
+    include Generic with type ('a, _, _) t := 'a t
 
-  val mem : 'a t -> 'a -> equal:('a -> 'a -> bool) -> bool
-end
-with type 'a t := 'a Container.t
-with type 'a elt := 'a
+    val mem : 'a t -> 'a -> equal:('a -> 'a -> bool) -> bool
+  end
+  with type 'a t := 'a Container.t
+  with type 'a elt := 'a
 
 module Test_S0 (Container : sig
-  module Elt : sig
-    type t [@@deriving sexp]
+    module Elt : sig
+      type t [@@deriving sexp]
 
-    val of_int : int -> t
-    val to_int : t -> int
-  end
+      val of_int : int -> t
+      val to_int : t -> int
+    end
 
-  type t [@@deriving sexp]
+    type t [@@deriving sexp]
 
-  include Container.S0 with type t := t and type elt := Elt.t
+    include Container.S0 with type t := t and type elt := Elt.t
 
-  val of_list : Elt.t list -> t
-end) : sig
-  type 'a t [@@deriving sexp]
+    val of_list : Elt.t list -> t
+  end) : sig
+    type 'a t [@@deriving sexp]
 
-  include Generic with type ('a, _, _) t := 'a t
+    include Generic with type ('a, _, _) t := 'a t
 
-  val mem : 'a t -> 'a elt -> bool
-end
-with type 'a t := Container.t
-with type 'a elt := Container.Elt.t
+    val mem : 'a t -> 'a elt -> bool
+  end
+  with type 'a t := Container.t
+  with type 'a elt := Container.Elt.t
diff --git a/test/import.ml b/test/import.ml
index 184abf93..ba6d5a90 100644
--- a/test/import.ml
+++ b/test/import.ml
@@ -21,7 +21,7 @@ let check_hash_coherence (type t) here (module T : Hash with type t = t) ts =
     let hash1 = T.hash t in
     let hash2 = [%hash: T.t] t in
     require
-      here
+      ~here
       (hash1 = hash2)
       ~cr:CR_soon
       ~if_false_then_print_s:
diff --git a/test/map_full_interface/functor_intf.ml b/test/map_full_interface/functor_intf.ml
deleted file mode 100644
index b568dfc7..00000000
--- a/test/map_full_interface/functor_intf.ml
+++ /dev/null
@@ -1,130 +0,0 @@
-open! Base
-
-module Definitions = struct
-  (** The types that distinguish instances of [Map.Creators_and_accessors_generic]. *)
-  module type Types = sig
-    type 'k key
-    type 'c cmp
-    type ('k, 'v, 'c) t
-    type ('k, 'v, 'c) tree
-    type ('k, 'c, 'a) create_options
-    type ('k, 'c, 'a) access_options
-  end
-
-  (** Like [Map.Creators_and_accessors_generic], but based on [Types] for easier
-      instantiation. *)
-  module type S = sig
-    module Types : Types
-
-    include
-      Map.Creators_and_accessors_generic
-        with type ('a, 'b, 'c) t := ('a, 'b, 'c) Types.t
-        with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Types.tree
-        with type 'a key := 'a Types.key
-        with type 'a cmp := 'a Types.cmp
-        with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) Types.create_options
-        with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Types.access_options
-  end
-
-  (** Helpers for testing a tree or map type that is an instance of [S]. *)
-  module type Instance = sig
-    module Types : Types
-
-    module Key : sig
-      type t = int Types.key [@@deriving compare, equal, quickcheck, sexp_of]
-
-      include Comparable.Infix with type t := t
-    end
-
-    type 'a t = (int, 'a, Int.comparator_witness) Types.t
-    [@@deriving equal, quickcheck, sexp_of]
-
-    (** Construct a [Key.t]. *)
-    val key : int -> Key.t
-
-    (** Extract an int from a [Key.t]. *)
-    val int : Key.t -> int
-
-    (** Extract a tree (without a comparator) from [t]. *)
-    val tree
-      :  (Key.t, 'a, Int.comparator_witness) Types.tree
-      -> (Key.t, 'a, Int.comparator_witness Types.cmp) Map.Using_comparator.Tree.t
-
-    (** Pass a comparator to a creator function, if necessary. *)
-    val create : (int, Int.comparator_witness, 'a) Types.create_options -> 'a
-
-    (** Pass a comparator to an accessor function, if necessary *)
-    val access : (int, Int.comparator_witness, 'a) Types.access_options -> 'a
-  end
-end
-
-module type Functor = sig
-  include module type of struct
-    include Definitions
-  end
-
-  (** Expect tests for everything exported from [Map.Creators_and_accessors_generic]. *)
-  module Test_creators_and_accessors
-    (Types : Types)
-    (Impl : S with module Types := Types)
-    (Instance : Instance with module Types := Types) : S with module Types := Types
-
-  (** A functor to generate all of [Instance] but [create] and [access] for a map type. *)
-  module Instance (Cmp : sig
-    type comparator_witness
-
-    val comparator : (int, comparator_witness) Comparator.t
-  end) : sig
-    module Key : sig
-      type t = int [@@deriving compare, equal, quickcheck, sexp_of]
-
-      include
-        Comparator.S with type t := t and type comparator_witness = Cmp.comparator_witness
-
-      include Comparable.Infix with type t := t
-    end
-
-    type 'a t = 'a Map.M(Key).t [@@deriving equal, quickcheck, sexp_of]
-
-    val key : 'a -> 'a
-    val int : 'a -> 'a
-    val tree : 'a -> 'a
-  end
-
-  (** A functor like [Instance], but for tree types. *)
-  module Instance_tree (Cmp : sig
-    type comparator_witness
-
-    val comparator : (int, comparator_witness) Comparator.t
-  end) : sig
-    module Key : sig
-      type t = int [@@deriving compare, equal, quickcheck, sexp_of]
-
-      include
-        Comparator.S
-          with type t := int
-           and type comparator_witness = Cmp.comparator_witness
-
-      include Comparable.Infix with type t := t
-    end
-
-    type 'a t = (int, 'a, Cmp.comparator_witness) Map.Using_comparator.Tree.t
-    [@@deriving equal, quickcheck, sexp_of]
-
-    val key : 'a -> 'a
-    val int : 'a -> 'a
-    val tree : 'a -> 'a
-  end
-
-  module Ok (T : sig
-    type t [@@deriving equal, sexp_of]
-  end) : sig
-    type t = T.t Or_error.t [@@deriving equal, sexp_of]
-  end
-
-  module Pair (T : sig
-    type t [@@deriving equal, quickcheck, sexp_of]
-  end) : sig
-    type t = T.t * T.t [@@deriving equal, quickcheck, sexp_of]
-  end
-end
diff --git a/test/map_full_interface/test_poly.ml b/test/map_full_interface/test_poly.ml
deleted file mode 100644
index d1df570b..00000000
--- a/test/map_full_interface/test_poly.ml
+++ /dev/null
@@ -1,15 +0,0 @@
-open! Base
-include Test_poly_intf.Definitions
-include (Base.Map.Poly : S)
-
-let%expect_test "[Base.Map.Poly] creators/accessors" =
-  let open
-    Functor.Test_creators_and_accessors (Types) (Base.Map.Poly)
-      (struct
-        include Functor.Instance (Comparator.Poly)
-
-        let create x = x
-        let access x = x
-      end) in
-  [%expect {| |}]
-;;
diff --git a/test/map_full_interface/test_poly.mli b/test/map_full_interface/test_poly.mli
deleted file mode 100644
index bc6d76f5..00000000
--- a/test/map_full_interface/test_poly.mli
+++ /dev/null
@@ -1 +0,0 @@
-include Test_poly_intf.Test_poly
diff --git a/test/map_full_interface/test_poly_intf.ml b/test/map_full_interface/test_poly_intf.ml
deleted file mode 100644
index 5f3e7eba..00000000
--- a/test/map_full_interface/test_poly_intf.ml
+++ /dev/null
@@ -1,22 +0,0 @@
-open! Base
-
-module Definitions = struct
-  module Types = struct
-    type 'key key = 'key
-    type 'cmp cmp = Comparator.Poly.comparator_witness
-    type ('key, 'data, 'cmp) t = ('key, 'data) Map.Poly.t
-    type ('key, 'data, 'cmp) tree = ('key, 'data) Map.Poly.tree
-    type ('key, 'cmp, 'fn) create_options = 'fn
-    type ('key, 'cmp, 'fn) access_options = 'fn
-  end
-
-  module type S = Functor.S with module Types := Types
-end
-
-module type Test_poly = sig
-  include module type of struct
-    include Definitions
-  end
-
-  include S
-end
diff --git a/test/map_full_interface/test_toplevel.ml b/test/map_full_interface/test_toplevel.ml
deleted file mode 100644
index d0d9ca8d..00000000
--- a/test/map_full_interface/test_toplevel.ml
+++ /dev/null
@@ -1,15 +0,0 @@
-open! Base
-include Test_toplevel_intf.Definitions
-include (Base.Map : S)
-
-let%expect_test "[Base.Map] creators/accessors" =
-  let open
-    Functor.Test_creators_and_accessors (Types) (Base.Map)
-      (struct
-        include Functor.Instance (Int)
-
-        let create f = f ((module Int) : _ Comparator.Module.t)
-        let access x = x
-      end) in
-  [%expect {| |}]
-;;
diff --git a/test/map_full_interface/test_toplevel.mli b/test/map_full_interface/test_toplevel.mli
deleted file mode 100644
index 038567e7..00000000
--- a/test/map_full_interface/test_toplevel.mli
+++ /dev/null
@@ -1 +0,0 @@
-include Test_toplevel_intf.Test_toplevel
diff --git a/test/map_full_interface/test_toplevel_intf.ml b/test/map_full_interface/test_toplevel_intf.ml
deleted file mode 100644
index 56ffc9cd..00000000
--- a/test/map_full_interface/test_toplevel_intf.ml
+++ /dev/null
@@ -1,22 +0,0 @@
-open! Base
-
-module Definitions = struct
-  module Types = struct
-    type 'key key = 'key
-    type 'cmp cmp = 'cmp
-    type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.t
-    type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
-    type ('key, 'cmp, 'fn) create_options = ('key, 'cmp) Comparator.Module.t -> 'fn
-    type ('key, 'cmp, 'fn) access_options = 'fn
-  end
-
-  module type S = Functor.S with module Types := Types
-end
-
-module type Test_toplevel = sig
-  include module type of struct
-    include Definitions
-  end
-
-  include S
-end
diff --git a/test/map_full_interface/test_tree.ml b/test/map_full_interface/test_tree.ml
deleted file mode 100644
index 90747818..00000000
--- a/test/map_full_interface/test_tree.ml
+++ /dev/null
@@ -1,15 +0,0 @@
-open! Base
-include Test_tree_intf.Definitions
-include (Base.Map.Using_comparator.Tree : S)
-
-let%expect_test "[Base.Map.Using_comparator.Tree] creators/accessors" =
-  let open
-    Functor.Test_creators_and_accessors (Types) (Base.Map.Using_comparator.Tree)
-      (struct
-        include Functor.Instance_tree (Int)
-
-        let create f = f ~comparator:Int.comparator
-        let access f = f ~comparator:Int.comparator
-      end) in
-  [%expect {| |}]
-;;
diff --git a/test/map_full_interface/test_tree.mli b/test/map_full_interface/test_tree.mli
deleted file mode 100644
index 5181eb66..00000000
--- a/test/map_full_interface/test_tree.mli
+++ /dev/null
@@ -1 +0,0 @@
-include Test_tree_intf.Test_tree
diff --git a/test/map_full_interface/test_tree_intf.ml b/test/map_full_interface/test_tree_intf.ml
deleted file mode 100644
index f375dcd9..00000000
--- a/test/map_full_interface/test_tree_intf.ml
+++ /dev/null
@@ -1,22 +0,0 @@
-open! Base
-
-module Definitions = struct
-  module Types = struct
-    type 'key key = 'key
-    type 'cmp cmp = 'cmp
-    type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
-    type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
-    type ('key, 'cmp, 'fn) create_options = comparator:('key, 'cmp) Comparator.t -> 'fn
-    type ('key, 'cmp, 'fn) access_options = comparator:('key, 'cmp) Comparator.t -> 'fn
-  end
-
-  module type S = Functor.S with module Types := Types
-end
-
-module type Test_tree = sig
-  include module type of struct
-    include Definitions
-  end
-
-  include S
-end
diff --git a/test/map_full_interface/test_using_comparator.ml b/test/map_full_interface/test_using_comparator.ml
deleted file mode 100644
index cf37efab..00000000
--- a/test/map_full_interface/test_using_comparator.ml
+++ /dev/null
@@ -1,15 +0,0 @@
-open! Base
-include Test_using_comparator_intf.Definitions
-include (Base.Map.Using_comparator : S)
-
-let%expect_test "[Base.Map.Using_comparator] creators/accessors" =
-  let open
-    Functor.Test_creators_and_accessors (Types) (Base.Map.Using_comparator)
-      (struct
-        include Functor.Instance (Int)
-
-        let create f = f ~comparator:Int.comparator
-        let access x = x
-      end) in
-  [%expect {| |}]
-;;
diff --git a/test/map_full_interface/test_using_comparator.mli b/test/map_full_interface/test_using_comparator.mli
deleted file mode 100644
index 8a43dcd6..00000000
--- a/test/map_full_interface/test_using_comparator.mli
+++ /dev/null
@@ -1 +0,0 @@
-include Test_using_comparator_intf.Test_using_comparator
diff --git a/test/map_full_interface/test_using_comparator_intf.ml b/test/map_full_interface/test_using_comparator_intf.ml
deleted file mode 100644
index 7c134d9b..00000000
--- a/test/map_full_interface/test_using_comparator_intf.ml
+++ /dev/null
@@ -1,22 +0,0 @@
-open! Base
-
-module Definitions = struct
-  module Types = struct
-    type 'key key = 'key
-    type 'cmp cmp = 'cmp
-    type ('key, 'data, 'cmp) t = ('key, 'data, 'cmp) Map.Using_comparator.t
-    type ('key, 'data, 'cmp) tree = ('key, 'data, 'cmp) Map.Using_comparator.Tree.t
-    type ('key, 'cmp, 'fn) create_options = comparator:('key, 'cmp) Comparator.t -> 'fn
-    type ('key, 'cmp, 'fn) access_options = 'fn
-  end
-
-  module type S = Functor.S with module Types := Types
-end
-
-module type Test_using_comparator = sig
-  include module type of struct
-    include Definitions
-  end
-
-  include S
-end
diff --git a/test/test_applicative.ml b/test/test_applicative.ml
index afc751e8..2e8c4d6b 100644
--- a/test/test_applicative.ml
+++ b/test/test_applicative.ml
@@ -193,32 +193,32 @@ end
 
 let%test_module "Make" =
   (module Test_applicative_s (Applicative.Make (struct
-    type 'a t = 'a Or_error.t
+      type 'a t = 'a Or_error.t
 
-    let return = Or_error.return
-    let apply = Or_error.apply
-    let map = `Define_using_apply
-  end)))
+      let return = Or_error.return
+      let apply = Or_error.apply
+      let map = `Define_using_apply
+    end)))
 ;;
 
 let%test_module "Make" =
   (module Test_applicative_s (Applicative.Make_using_map2 (struct
-    type 'a t = 'a Or_error.t
+      type 'a t = 'a Or_error.t
 
-    let return = Or_error.return
-    let map2 = Or_error.map2
-    let map = `Define_using_map2
-  end)))
+      let return = Or_error.return
+      let map2 = Or_error.map2
+      let map = `Define_using_map2
+    end)))
 ;;
 
 let%test_module "Make" =
   (module Test_applicative_s (Applicative.Make_using_map2_local (struct
-    type 'a t = 'a Or_error.t
+      type 'a t = 'a Or_error.t
 
-    let return x = Ok x
-    let map2 = Or_error.map2
-    let map = `Define_using_map2
-  end)))
+      let return x = Ok x
+      let map2 = Or_error.map2
+      let map = `Define_using_map2
+    end)))
 ;;
 
 (* While law-abiding applicatives shouldn't be relying functions being called
@@ -239,12 +239,12 @@ let%expect_test _ =
       | Map2 : ('a -> 'b -> 'c) * 'a t * 'b t -> 'c t
 
     include Applicative.Make_using_map2 (struct
-      type nonrec 'a t = 'a t
+        type nonrec 'a t = 'a t
 
-      let return x = Return x
-      let map2 a b ~f = Map2 (f, a, b)
-      let map = `Custom (fun a ~f -> Map (f, a))
-    end)
+        let return x = Return x
+        let map2 a b ~f = Map2 (f, a, b)
+        let map = `Custom (fun a ~f -> Map (f, a))
+      end)
 
     let rec sexp_of_t : type a. a t -> Sexp.t = function
       | Other x -> Atom x
diff --git a/test/test_array.ml b/test/test_array.ml
index 741cccce..6c0324ab 100644
--- a/test/test_array.ml
+++ b/test/test_array.ml
@@ -5,12 +5,12 @@ open Array
 
 let%test_module "Binary_searchable" =
   (module Test_binary_searchable.Test1 (struct
-    include Array
+      include Array
 
-    module For_test = struct
-      let of_array = Fn.id
-    end
-  end))
+      module For_test = struct
+        let of_array = Fn.id
+      end
+    end))
 ;;
 
 let%test_module "Blit" =
@@ -118,7 +118,6 @@ let%expect_test "merge" =
     let res = merge a1 a2 ~compare:Int.compare in
     print_s ([%sexp_of: int array] res);
     require_equal
-      [%here]
       (module struct
         type t = int list [@@deriving equal, sexp_of]
       end)
@@ -152,7 +151,6 @@ let%expect_test "merge with duplicates" =
     let res = merge a1 a2 ~compare in
     print_s ([%sexp_of: (int * string) array] res);
     require_equal
-      [%here]
       (module struct
         type t = (int * string) list [@@deriving equal, sexp_of]
       end)
@@ -160,7 +158,8 @@ let%expect_test "merge with duplicates" =
       (List.merge (to_list a1) (to_list a2) ~compare)
   in
   test [| 1, "a1" |] [| 1, "a2" |];
-  [%expect {|
+  [%expect
+    {|
     ((1 a1)
      (1 a2))
     |}];
@@ -206,24 +205,17 @@ let%test_module "count{,i}" =
   (module struct
     let%expect_test "[Array.count{,i} = List.count{,i}]" =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> bool) [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun (list, f) ->
-          require_equal
-            [%here]
-            (module Int)
-            (list |> List.count ~f)
-            (list |> of_list |> count ~f));
+          require_equal (module Int) (list |> List.count ~f) (list |> of_list |> count ~f));
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> int -> bool) [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun (list, f) ->
           require_equal
-            [%here]
             (module Int)
             (list |> List.counti ~f)
             (list |> of_list |> counti ~f))
@@ -238,14 +230,12 @@ let%test_module "{min,max}_elt" =
   (module struct
     let test_opt_selector arr_fun list_fun =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list [@@deriving sexp_of, quickcheck]
         end)
         ~f:(fun list ->
           let arr = of_list list in
           require_equal
-            [%here]
             (module struct
               type t = int option [@@deriving sexp_of, equal]
             end)
@@ -286,7 +276,7 @@ let%expect_test _ =
 ;;
 
 let%expect_test "map2_exn raise" =
-  require_does_raise [%here] (fun () -> map2_exn [| 1; 2; 3 |] [| 2; 3; 4; 5 |] ~f:( + ));
+  require_does_raise (fun () -> map2_exn [| 1; 2; 3 |] [| 2; 3; 4; 5 |] ~f:( + ));
   [%expect {| (Invalid_argument "length mismatch in Array.map2_exn: 3 <> 4") |}]
 ;;
 
@@ -576,7 +566,6 @@ let%test_module "permute" =
             | Ok _ -> test_permute initial_contents ~pos ~len
             | Error _ ->
               require
-                [%here]
                 (Exn.does_raise (fun () ->
                    permute ?pos ?len (Array.of_list initial_contents)))))
       done;
@@ -622,12 +611,8 @@ let%expect_test "rev and rev_inplace" =
       rev_inplace array;
       array
     in
-    require_equal
-      [%here]
-      (module Int_list)
-      (to_list reversed_array)
-      (List.rev ordered_list);
-    require_equal [%here] (module Int_array) reversed_array (rev ordered_array);
+    require_equal (module Int_list) (to_list reversed_array) (List.rev ordered_list);
+    require_equal (module Int_array) reversed_array (rev ordered_array);
     print_s [%sexp (reversed_array : int array)]
   in
   test [];
@@ -643,7 +628,7 @@ let%expect_test "map_inplace" =
     let f x = x * x in
     let array = of_list list in
     map_inplace array ~f;
-    require_equal [%here] (module Int_list) (to_list array) (List.map list ~f);
+    require_equal (module Int_list) (to_list array) (List.map list ~f);
     print_s [%sexp (array : int array)]
   in
   test [];
@@ -655,11 +640,12 @@ let%expect_test "map_inplace" =
 ;;
 
 let%expect_test "cartesian_product" =
-  require [%here] (is_empty (cartesian_product [||] [||]));
-  require [%here] (is_empty (cartesian_product [||] [| 13 |]));
-  require [%here] (is_empty (cartesian_product [| 13 |] [||]));
+  require (is_empty (cartesian_product [||] [||]));
+  require (is_empty (cartesian_product [||] [| 13 |]));
+  require (is_empty (cartesian_product [| 13 |] [||]));
   print_s [%sexp (cartesian_product [| 1; 2; 3 |] [| "a"; "b" |] : (int * string) array)];
-  [%expect {|
+  [%expect
+    {|
     ((1 a)
      (1 b)
      (2 a)
diff --git a/test/test_array_local.mlt b/test/test_array_local.mlt
index 587cc34e..5f366c0a 100644
--- a/test/test_array_local.mlt
+++ b/test/test_array_local.mlt
@@ -9,7 +9,7 @@ Array.create_local ~len:10 k
 [%%expect
   {|
 Line _, characters _-_:
-Error: This value escapes its region
+Error: This value escapes its region.
 |}]
 ;;
 
@@ -20,5 +20,5 @@ ref arr
 [%%expect
   {|
 Line _, characters _-_:
-Error: This value escapes its region
+Error: This value escapes its region.
 |}]
diff --git a/test/test_base_containers_mono.ml b/test/test_base_containers_mono.ml
index c750fae0..94cb9fbf 100644
--- a/test/test_base_containers_mono.ml
+++ b/test/test_base_containers_mono.ml
@@ -18,7 +18,7 @@ include (
 
     let of_list = of_char_list
   end) :
-    sig end)
+  sig end)
 
 let%expect_test "Hash_set" =
   Base_container_tests.test_container_s0
diff --git a/test/test_blit.ml b/test/test_blit.ml
index 10540751..e1b7e8c0 100644
--- a/test/test_blit.ml
+++ b/test/test_blit.ml
@@ -9,23 +9,23 @@ let%test_module _ =
     let slices_are_valid = ref (Ok ())
 
     module B = Make (struct
-      type t = bool array
+        type t = bool array
 
-      let create ~len = Array.create false ~len
-      let length = Array.length
+        let create ~len = Array.create false ~len
+        let length = Array.length
 
-      let unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
-        blit_was_called := true;
-        slices_are_valid
+        let unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
+          blit_was_called := true;
+          slices_are_valid
           := Or_error.try_with (fun () ->
                assert (len >= 0);
                assert (src_pos >= 0);
                assert (src_pos + len <= Array.length src);
                assert (dst_pos >= 0);
                assert (dst_pos + len <= Array.length dst));
-        Array.blit ~src ~src_pos ~dst ~dst_pos ~len
-      ;;
-    end)
+          Array.blit ~src ~src_pos ~dst ~dst_pos ~len
+        ;;
+      end)
 
     let%test_module "Bool" =
       (module Test_blit.Test
@@ -72,7 +72,7 @@ let%test_module _ =
                   check (fun () ->
                     ignore
                       (B.subo (Array.create ~len:src false) ?pos:src_pos ?len:src_len
-                        : bool array))
+                       : bool array))
                 with
                 | exn ->
                   raise_s
diff --git a/test/test_bytes.ml b/test/test_bytes.ml
index e6cf1775..be959850 100644
--- a/test/test_bytes.ml
+++ b/test/test_bytes.ml
@@ -11,6 +11,7 @@ let%test_module "Blit" =
             (struct
               include Bytes
 
+              let get t i = get t i
               let create ~len = create len
             end)
             (Bytes))
@@ -28,7 +29,7 @@ let%expect_test "local" =
     printf "%c" string.[i]
   done;
   [%expect {| 0123456789 |}];
-  Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+  Expect_test_helpers_base.require_does_raise (fun () ->
     ignore (Bytes.create_local (Sys.max_string_length + 1) : Bytes.t));
   [%expect {| (Invalid_argument Bytes.create_local) |}]
 ;;
diff --git a/test/test_char.ml b/test/test_char.ml
index 3c993390..2d4e64b4 100644
--- a/test/test_char.ml
+++ b/test/test_char.ml
@@ -136,7 +136,6 @@ let%expect_test "get_hex_digit" =
        (C 12) (D 13) (E 14) (F 15) (a 10) (b 11) (c 12) (d 13) (e 14) (f 15))
       |}];
     require_equal
-      [%here]
       (module struct
         type t = (char * int) list [@@deriving equal, sexp_of]
       end)
@@ -145,7 +144,7 @@ let%expect_test "get_hex_digit" =
        |> List.map ~f:(fun char -> char, get_hex_digit_exn char))
       hex_digit_alist;
     [%expect {| |}];
-    require_does_raise [%here] (fun () -> get_hex_digit_exn Char.min_value);
+    require_does_raise (fun () -> get_hex_digit_exn Char.min_value);
     [%expect {| ("Char.get_hex_digit_exn: not a hexadecimal digit" (char "\000")) |}])
 ;;
 
diff --git a/test/test_clz_ctz.ml b/test/test_clz_ctz.ml
index 3d88ddd2..a8a71b48 100644
--- a/test/test_clz_ctz.ml
+++ b/test/test_clz_ctz.ml
@@ -34,16 +34,16 @@ include Make (Int63)
 include Make (Int63.Private.Emul)
 
 include Make (struct
-  include Int
+    include Int
 
-  let%expect_test "zero" =
-    (* [clz 0] is guaranteed to be num_bits for int. We compute clz on the tagged
+    let%expect_test "zero" =
+      (* [clz 0] is guaranteed to be num_bits for int. We compute clz on the tagged
          representation of int's, and the binary representation of the int [0] is
          num_bits 0's followed by a 1 (the tag bit). *)
-    [%test_result: int] ~expect:num_bits (clz 0)
-  ;;
+      [%test_result: int] ~expect:num_bits (clz 0)
+    ;;
 
-  (* [ctz 0] is unspecified. On linux it seems to be stable and equal to the system
+    (* [ctz 0] is unspecified. On linux it seems to be stable and equal to the system
        word size (which is num_bits + 1).
        ran 2019-02-11 on linux:
        {v
@@ -56,57 +56,57 @@ include Make (struct
         [%test_result: int] ~expect:(num_bits) (ctz 0)
        v}
     *)
-end)
+  end)
 
 include Make (struct
-  include Int32
+    include Int32
 
-  let clz_and_ctz i32 = { E.clz = clz i32; ctz = ctz i32 }
+    let clz_and_ctz i32 = { E.clz = clz i32; ctz = ctz i32 }
 
-  let%expect_test "extra examples" =
-    [%test_result: E.t] ~expect:{ clz = 31; ctz = 0 } (clz_and_ctz 0b1l);
-    [%test_result: E.t] ~expect:{ clz = 30; ctz = 1 } (clz_and_ctz 0b10l);
-    [%test_result: E.t] ~expect:{ clz = 30; ctz = 0 } (clz_and_ctz 0b11l);
-    [%test_result: E.t] ~expect:{ clz = 25; ctz = 1 } (clz_and_ctz 0b1000010l);
-    [%test_result: E.t]
-      ~expect:{ clz = 8; ctz = 6 }
-      (clz_and_ctz 0b100000010000001001000000l);
-    [%test_result: E.t]
-      ~expect:{ clz = 0; ctz = 31 }
-      (clz_and_ctz 0b10000000000000000000000000000000l);
-    [%test_result: E.t]
-      ~expect:{ clz = 9; ctz = 6 }
-      (clz_and_ctz 0b00000000010000000100000001000000l);
-    [%test_result: E.t]
-      ~expect:{ clz = 0; ctz = 6 }
-      (clz_and_ctz 0b10000000010000000100000001000000l)
-  ;;
-end)
+    let%expect_test "extra examples" =
+      [%test_result: E.t] ~expect:{ clz = 31; ctz = 0 } (clz_and_ctz 0b1l);
+      [%test_result: E.t] ~expect:{ clz = 30; ctz = 1 } (clz_and_ctz 0b10l);
+      [%test_result: E.t] ~expect:{ clz = 30; ctz = 0 } (clz_and_ctz 0b11l);
+      [%test_result: E.t] ~expect:{ clz = 25; ctz = 1 } (clz_and_ctz 0b1000010l);
+      [%test_result: E.t]
+        ~expect:{ clz = 8; ctz = 6 }
+        (clz_and_ctz 0b100000010000001001000000l);
+      [%test_result: E.t]
+        ~expect:{ clz = 0; ctz = 31 }
+        (clz_and_ctz 0b10000000000000000000000000000000l);
+      [%test_result: E.t]
+        ~expect:{ clz = 9; ctz = 6 }
+        (clz_and_ctz 0b00000000010000000100000001000000l);
+      [%test_result: E.t]
+        ~expect:{ clz = 0; ctz = 6 }
+        (clz_and_ctz 0b10000000010000000100000001000000l)
+    ;;
+  end)
 
 include Make (struct
-  include Int64
+    include Int64
 
-  let clz_and_ctz i64 = { E.clz = clz i64; ctz = ctz i64 }
+    let clz_and_ctz i64 = { E.clz = clz i64; ctz = ctz i64 }
 
-  let%expect_test "extra examples" =
-    [%test_result: E.t] ~expect:{ clz = 63; ctz = 0 } (clz_and_ctz 0b1L);
-    [%test_result: E.t] ~expect:{ clz = 62; ctz = 1 } (clz_and_ctz 0b10L);
-    [%test_result: E.t] ~expect:{ clz = 62; ctz = 0 } (clz_and_ctz 0b11L);
-    [%test_result: E.t] ~expect:{ clz = 57; ctz = 1 } (clz_and_ctz 0b1000010L);
-    [%test_result: E.t]
-      ~expect:{ clz = 40; ctz = 6 }
-      (clz_and_ctz 0b100000010000001001000000L);
-    [%test_result: E.t]
-      ~expect:{ clz = 0; ctz = 63 }
-      (clz_and_ctz 0b1000000000000000000000000000000000000000000000000000000000000000L);
-    [%test_result: E.t]
-      ~expect:{ clz = 32; ctz = 31 }
-      (clz_and_ctz 0b0000000000000000000000000000000010000000000000000000000000000000L);
-    [%test_result: E.t]
-      ~expect:{ clz = 32; ctz = 6 }
-      (clz_and_ctz 0b0000000000000000000000000000000010000000010000000100000001000000L);
-    [%test_result: E.t]
-      ~expect:{ clz = 33; ctz = 6 }
-      (clz_and_ctz 0b0000000000000000000000000000000001000000010000000100000001000000L)
-  ;;
-end)
+    let%expect_test "extra examples" =
+      [%test_result: E.t] ~expect:{ clz = 63; ctz = 0 } (clz_and_ctz 0b1L);
+      [%test_result: E.t] ~expect:{ clz = 62; ctz = 1 } (clz_and_ctz 0b10L);
+      [%test_result: E.t] ~expect:{ clz = 62; ctz = 0 } (clz_and_ctz 0b11L);
+      [%test_result: E.t] ~expect:{ clz = 57; ctz = 1 } (clz_and_ctz 0b1000010L);
+      [%test_result: E.t]
+        ~expect:{ clz = 40; ctz = 6 }
+        (clz_and_ctz 0b100000010000001001000000L);
+      [%test_result: E.t]
+        ~expect:{ clz = 0; ctz = 63 }
+        (clz_and_ctz 0b1000000000000000000000000000000000000000000000000000000000000000L);
+      [%test_result: E.t]
+        ~expect:{ clz = 32; ctz = 31 }
+        (clz_and_ctz 0b0000000000000000000000000000000010000000000000000000000000000000L);
+      [%test_result: E.t]
+        ~expect:{ clz = 32; ctz = 6 }
+        (clz_and_ctz 0b0000000000000000000000000000000010000000010000000100000001000000L);
+      [%test_result: E.t]
+        ~expect:{ clz = 33; ctz = 6 }
+        (clz_and_ctz 0b0000000000000000000000000000000001000000010000000100000001000000L)
+    ;;
+  end)
diff --git a/test/test_compare.ml b/test/test_compare.ml
index 1a2b3fbd..daffe30f 100644
--- a/test/test_compare.ml
+++ b/test/test_compare.ml
@@ -19,7 +19,7 @@ let test (type a) here (module T : S with type t = a) list =
           if not (Result.compare actual expect = 0)
           then (
             print_cr
-              here
+              ~here
               [%message
                 "comparison failed"
                   (operator : string)
@@ -123,7 +123,6 @@ let%test_module "lexicographic" =
             let ordering = Ordering.of_int (compare a b) in
             print_s [%message (a : int) (b : int) (ordering : Ordering.t)];
             require_equal
-              [%here]
               (module Ordering)
               (Ordering.of_int (compare a b))
               (Ordering.of_int (Comparable.lexicographic [ compare ] a b)));
diff --git a/test/test_container_module_types.ml b/test/test_container_module_types.ml
index 771dea26..5ab67a2c 100644
--- a/test/test_container_module_types.ml
+++ b/test/test_container_module_types.ml
@@ -60,9 +60,9 @@ module _ : module type of Container = struct
 
       include
         Generic_with_creators
-          with type _ elt := elt
-           and type (_, _, _) t := t
-           and type ('a, _, _) concat := 'a list
+        with type _ elt := elt
+         and type (_, _, _) t := t
+         and type ('a, _, _) concat := 'a list
 
       val mem : t -> elt -> bool
     end
@@ -108,9 +108,9 @@ module _ : module type of Container = struct
 
       include
         Generic_with_creators
-          with type 'a elt := 'a
-           and type ('a, _, _) t := 'a t
-           and type ('a, _, _) concat := 'a t
+        with type 'a elt := 'a
+         and type ('a, _, _) t := 'a t
+         and type ('a, _, _) concat := 'a t
     end
   end
 
@@ -183,9 +183,9 @@ module _ : module type of Indexed_container = struct
 
       include
         Generic_with_creators
-          with type _ elt := elt
-           and type (_, _, _) t := t
-           and type ('a, _, _) concat := 'a list
+        with type _ elt := elt
+         and type (_, _, _) t := t
+         and type ('a, _, _) concat := 'a list
 
       val mem : t -> elt -> bool
     end
@@ -203,9 +203,9 @@ module _ : module type of Indexed_container = struct
 
       include
         Generic_with_creators
-          with type 'a elt := 'a
-           and type ('a, _, _) t := 'a t
-           and type ('a, _, _) concat := 'a t
+        with type 'a elt := 'a
+         and type ('a, _, _) t := 'a t
+         and type ('a, _, _) concat := 'a t
     end
   end
 
diff --git a/test/test_dictionary_module_types.ml b/test/test_dictionary_module_types.ml
index 934601d2..f2593600 100644
--- a/test/test_dictionary_module_types.ml
+++ b/test/test_dictionary_module_types.ml
@@ -21,9 +21,9 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Accessors
-          with type _ key := key
-           and type (_, 'data, _) t := 'data t
-           and type ('fn, _, _, _) accessor := 'fn
+        with type _ key := key
+         and type (_, 'data, _) t := 'data t
+         and type ('fn, _, _, _) accessor := 'fn
     end
   end
 
@@ -40,9 +40,9 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Accessors
-          with type 'key key := 'key
-           and type ('key, 'data, _) t := ('key, 'data) t
-           and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+        with type 'key key := 'key
+         and type ('key, 'data, _) t := ('key, 'data) t
+         and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
     end
   end
 
@@ -59,16 +59,77 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Accessors
-          with type 'key key := 'key
-           and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-           and type ('fn, 'key, 'data, 'phantom) accessor :=
-            ('fn, 'key, 'data, 'phantom) accessor
+        with type 'key key := 'key
+         and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+         and type ('fn, 'key, 'data, 'phantom) accessor :=
+          ('fn, 'key, 'data, 'phantom) accessor
     end
   end
 
   module _ (M : Accessors3) : Accessors_instance3 = M
   module _ (M : Accessors_instance3) : Accessors3 = M
 
+  (* The generic interface for transformers. *)
+  module type Transformers = Dictionary_immutable.Transformers
+
+  (* Ensure that Transformers1 is Transformers with only a data type argument. *)
+  module type Transformers1 = Dictionary_immutable.Transformers1
+
+  open struct
+    module type Transformers_instance1 = sig
+      type key
+      type 'data t
+
+      include
+        Transformers
+        with type _ key := key
+         and type (_, 'data, _) t := 'data t
+         and type ('fn, _, _, _) transformer := 'fn
+    end
+  end
+
+  module _ (M : Transformers1) : Transformers_instance1 = M
+  module _ (M : Transformers_instance1) : Transformers1 = M
+
+  (* Ensure that Transformers2 is Transformers with no phantom type argument. *)
+  module type Transformers2 = Dictionary_immutable.Transformers2
+
+  open struct
+    module type Transformers_instance2 = sig
+      type ('key, 'data) t
+      type ('fn, 'key, 'data) transformer
+
+      include
+        Transformers
+        with type 'key key := 'key
+         and type ('key, 'data, _) t := ('key, 'data) t
+         and type ('fn, 'key, 'data, _) transformer := ('fn, 'key, 'data) transformer
+    end
+  end
+
+  module _ (M : Transformers2) : Transformers_instance2 = M
+  module _ (M : Transformers_instance2) : Transformers2 = M
+
+  (* Ensure that Transformers3 is Transformers with no [key] type. *)
+  module type Transformers3 = Dictionary_immutable.Transformers3
+
+  open struct
+    module type Transformers_instance3 = sig
+      type ('key, 'data, 'phantom) t
+      type ('fn, 'key, 'data, 'phantom) transformer
+
+      include
+        Transformers
+        with type 'key key := 'key
+         and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+         and type ('fn, 'key, 'data, 'phantom) transformer :=
+          ('fn, 'key, 'data, 'phantom) transformer
+    end
+  end
+
+  module _ (M : Transformers3) : Transformers_instance3 = M
+  module _ (M : Transformers_instance3) : Transformers3 = M
+
   (* The generic interface for creators. *)
   module type Creators = Dictionary_immutable.Creators
 
@@ -82,9 +143,9 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Creators
-          with type _ key := key
-           and type (_, 'data, _) t := 'data t
-           and type ('fn, _, _, _) creator := 'fn
+        with type _ key := key
+         and type (_, 'data, _) t := 'data t
+         and type ('fn, _, _, _) creator := 'fn
     end
   end
 
@@ -101,9 +162,9 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Creators
-          with type 'key key := 'key
-           and type ('key, 'data, _) t := ('key, 'data) t
-           and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
+        with type 'key key := 'key
+         and type ('key, 'data, _) t := ('key, 'data) t
+         and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
     end
   end
 
@@ -120,10 +181,10 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Creators
-          with type 'key key := 'key
-           and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-           and type ('fn, 'key, 'data, 'phantom) creator :=
-            ('fn, 'key, 'data, 'phantom) creator
+        with type 'key key := 'key
+         and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+         and type ('fn, 'key, 'data, 'phantom) creator :=
+          ('fn, 'key, 'data, 'phantom) creator
     end
   end
 
@@ -142,17 +203,24 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         Accessors
-          with type 'key key := 'key key
-          with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-          with type ('fn, 'key, 'data, 'phantom) accessor :=
-            ('fn, 'key, 'data, 'phantom) accessor
+        with type 'key key := 'key key
+        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+        with type ('fn, 'key, 'data, 'phantom) accessor :=
+          ('fn, 'key, 'data, 'phantom) accessor
+
+      include
+        Transformers
+        with type 'key key := 'key key
+        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+        with type ('fn, 'key, 'data, 'phantom) transformer :=
+          ('fn, 'key, 'data, 'phantom) accessor
 
       include
         Creators
-          with type 'key key := 'key key
-          with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-          with type ('fn, 'key, 'data, 'phantom) creator :=
-            ('fn, 'key, 'data, 'phantom) creator
+        with type 'key key := 'key key
+        with type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+        with type ('fn, 'key, 'data, 'phantom) creator :=
+          ('fn, 'key, 'data, 'phantom) creator
     end
   end
 
@@ -169,10 +237,10 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         S
-          with type _ key := key
-           and type (_, 'data, _) t := 'data t
-           and type ('fn, _, _, _) accessor := 'fn
-           and type ('fn, _, _, _) creator := 'fn
+        with type _ key := key
+         and type (_, 'data, _) t := 'data t
+         and type ('fn, _, _, _) accessor := 'fn
+         and type ('fn, _, _, _) creator := 'fn
     end
   end
 
@@ -190,10 +258,10 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         S
-          with type 'key key := 'key
-           and type ('key, 'data, _) t := ('key, 'data) t
-           and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
-           and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
+        with type 'key key := 'key
+         and type ('key, 'data, _) t := ('key, 'data) t
+         and type ('fn, 'key, 'data, _) accessor := ('fn, 'key, 'data) accessor
+         and type ('fn, 'key, 'data, _) creator := ('fn, 'key, 'data) creator
     end
   end
 
@@ -211,12 +279,12 @@ module _ : module type of Dictionary_immutable = struct
 
       include
         S
-          with type 'key key := 'key
-           and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
-           and type ('fn, 'key, 'data, 'phantom) accessor :=
-            ('fn, 'key, 'data, 'phantom) accessor
-           and type ('fn, 'key, 'data, 'phantom) creator :=
-            ('fn, 'key, 'data, 'phantom) creator
+        with type 'key key := 'key
+         and type ('key, 'data, 'phantom) t := ('key, 'data, 'phantom) t
+         and type ('fn, 'key, 'data, 'phantom) accessor :=
+          ('fn, 'key, 'data, 'phantom) accessor
+         and type ('fn, 'key, 'data, 'phantom) creator :=
+          ('fn, 'key, 'data, 'phantom) creator
     end
   end
 
diff --git a/test/test_either.ml b/test/test_either.ml
index 6257db5d..94afe9a9 100644
--- a/test/test_either.ml
+++ b/test/test_either.ml
@@ -14,7 +14,8 @@ let%expect_test "First.Monad.map" =
   let f' = inc f in
   let s' = inc s in
   print_s [%message (f' : t) (s' : t)];
-  [%expect {|
+  [%expect
+    {|
     ((f' (First  1))
      (s' (Second str)))
     |}]
@@ -29,7 +30,8 @@ let%expect_test "Second.Monad.map" =
   let f' = add f in
   let s' = add s in
   print_s [%message (f' : t) (s' : t)];
-  [%expect {|
+  [%expect
+    {|
     ((f' (First  0))
      (s' (Second str1)))
     |}]
@@ -44,7 +46,8 @@ let%expect_test "First.Monad.bind" =
   let f' = inc f in
   let s' = inc s in
   print_s [%message (f' : t) (s' : t)];
-  [%expect {|
+  [%expect
+    {|
     ((f' (First  1))
      (s' (Second str)))
     |}]
@@ -59,7 +62,8 @@ let%expect_test "Second.Monad.bind" =
   let f' = add f in
   let s' = add s in
   print_s [%message (f' : t) (s' : t)];
-  [%expect {|
+  [%expect
+    {|
     ((f' (First  0))
      (s' (Second str1)))
     |}]
diff --git a/test/test_error.ml b/test/test_error.ml
index ca7afee2..49ea4236 100644
--- a/test/test_error.ml
+++ b/test/test_error.ml
@@ -10,7 +10,8 @@ let errors =
 
 let%expect_test _ =
   List.iter errors ~f:(fun error -> show_raise (fun () -> Error.raise error));
-  [%expect {|
+  [%expect
+    {|
     (raised ABC)
     (raised (DEF GHI))
     (raised (foo (bar 31)))
@@ -20,7 +21,8 @@ let%expect_test _ =
 let%expect_test _ =
   List.iter errors ~f:(fun error ->
     show_raise (fun () -> Error.raise_s [%sexp (error : Error.t)]));
-  [%expect {|
+  [%expect
+    {|
     (raised ABC)
     (raised (DEF GHI))
     (raised (foo (bar 31)))
diff --git a/test/test_exn_reraise.ml b/test/test_exn_reraise.ml
index fd10adb6..15fb3972 100644
--- a/test/test_exn_reraise.ml
+++ b/test/test_exn_reraise.ml
@@ -88,7 +88,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "Base.Exn.reraise" =
       test_reraiser _Base_Exn_reraise;
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: true
         After  re-raise: true
         |}]
@@ -98,7 +99,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "Base.Exn.reraise" =
       test_reraiser _Base_Exn_reraise_after_clobbering_most_recent_backtrace;
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: false
         After  re-raise: true
         |}]
@@ -108,7 +110,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "%reraise unequal" =
       test_reraiser external_reraise_unequal;
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: false
         After  re-raise: true
         |}]
@@ -118,7 +121,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "raise unequal" =
       test_reraiser vanilla_raise_unequal;
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: false
         After  re-raise: true
         |}]
@@ -128,7 +132,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "raise equal" =
       test_reraiser vanilla_raise;
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: true
         After  re-raise: true
         |}]
@@ -138,7 +143,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "Caml.Printexc.raise_with_backtrace" =
       test_reraiser raise_with_original_backtrace;
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: true
         After  re-raise: true
         |}]
@@ -148,7 +154,8 @@ let%test_module ("Show native backtraces" [@tags "no-js"]) =
     let%expect_test "Exn.reraise_uncaught" =
       test_reraise_uncaught ~reraise_uncaught:(Exn.reraise_uncaught "reraised");
       really_show_backtrace [%expect.output];
-      [%expect {|
+      [%expect
+        {|
         Before re-raise: true
         After  re-raise: true
         |}]
diff --git a/test/test_exported_int_conversions.ml b/test/test_exported_int_conversions.ml
index 49f062af..4aacbc37 100644
--- a/test/test_exported_int_conversions.ml
+++ b/test/test_exported_int_conversions.ml
@@ -70,8 +70,8 @@ let test_total
   iter
     (module A)
     ~f:(fun a ->
-      require_compare_equal [%here] (module B) (b_of_a a) (a_to_b a);
-      require_compare_equal [%here] (module Int64) (A.to_int64 a) (B.to_int64 (b_of_a a)))
+      require_compare_equal (module B) (b_of_a a) (a_to_b a);
+      require_compare_equal (module Int64) (A.to_int64 a) (B.to_int64 (b_of_a a)))
 ;;
 
 let truncate int64 ~num_bits =
@@ -101,28 +101,26 @@ let test_partial
   iter
     (module A)
     ~f:(fun a ->
-      require_compare_equal [%here] (module B_option) (b_of_a a) (a_to_b a);
-      require_compare_equal [%here] (module B_option) (b_of_a a) (try_with b_of_a_exn a);
-      require_compare_equal [%here] (module B_option) (a_to_b a) (try_with a_to_b_exn a);
+      require_compare_equal (module B_option) (b_of_a a) (a_to_b a);
+      require_compare_equal (module B_option) (b_of_a a) (try_with b_of_a_exn a);
+      require_compare_equal (module B_option) (a_to_b a) (try_with a_to_b_exn a);
       match b_of_a a with
       | Some b ->
         Int.incr convertible_count;
-        require_compare_equal [%here] (module B) b (b_of_a_trunc a);
-        require_compare_equal [%here] (module B) b (a_to_b_trunc a);
-        require_compare_equal [%here] (module Int64) (A.to_int64 a) (B.to_int64 b)
+        require_compare_equal (module B) b (b_of_a_trunc a);
+        require_compare_equal (module B) b (a_to_b_trunc a);
+        require_compare_equal (module Int64) (A.to_int64 a) (B.to_int64 b)
       | None ->
         let trunc = truncate (A.to_int64 a) ~num_bits:B.num_bits in
-        require_compare_equal [%here] (module Int64) trunc (B.to_int64 (b_of_a_trunc a));
-        require_compare_equal [%here] (module Int64) trunc (B.to_int64 (a_to_b_trunc a));
+        require_compare_equal (module Int64) trunc (B.to_int64 (b_of_a_trunc a));
+        require_compare_equal (module Int64) trunc (B.to_int64 (a_to_b_trunc a));
         require
-          [%here]
           (Int64.( > ) (A.to_int64 a) (B.to_int64 B.max_value)
            || Int64.( < ) (A.to_int64 a) (B.to_int64 B.min_value))
           ~if_false_then_print_s:(lazy [%message "failed to convert" ~_:(a : A.t)]));
   (* Make sure we stress the conversion a nontrivial number of times. This makes sure the
      random generation is useful and we aren't just testing the hard-coded examples. *)
   require
-    [%here]
     (!convertible_count > 100)
     ~if_false_then_print_s:
       (lazy
diff --git a/test/test_float.ml b/test/test_float.ml
index 03c93f5f..1b7d74cf 100644
--- a/test/test_float.ml
+++ b/test/test_float.ml
@@ -129,27 +129,27 @@ let%test_module "clamp" =
     let%test "clamp also bad 4" = Or_error.is_error (clamp nan ~min:nan ~max:nan)
 
     let%test_unit "clamp_exn bad" =
-      Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+      Expect_test_helpers_base.require_does_raise (fun () ->
         clamp_exn 2.5 ~min:3. ~max:2.)
     ;;
 
     let%test_unit "clamp_exn also bad" =
-      Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+      Expect_test_helpers_base.require_does_raise (fun () ->
         clamp_exn 2.5 ~min:nan ~max:3.)
     ;;
 
     let%test_unit "clamp_exn also bad 2" =
-      Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+      Expect_test_helpers_base.require_does_raise (fun () ->
         clamp_exn 2.5 ~min:2. ~max:nan)
     ;;
 
     let%test_unit "clamp_exn also bad 3" =
-      Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+      Expect_test_helpers_base.require_does_raise (fun () ->
         clamp_exn 2.5 ~min:nan ~max:nan)
     ;;
 
     let%test_unit "clamp_exn also bad 4" =
-      Expect_test_helpers_base.require_does_raise [%here] (fun () ->
+      Expect_test_helpers_base.require_does_raise (fun () ->
         clamp_exn nan ~min:nan ~max:nan)
     ;;
   end)
@@ -829,14 +829,14 @@ let%test_module _ =
 ;;
 
 module Test_bounds (I : sig
-  type t
-
-  val num_bits : int
-  val of_float : float -> t
-  val to_int64 : t -> Int64.t
-  val max_value : t
-  val min_value : t
-end) =
+    type t
+
+    val num_bits : int
+    val of_float : float -> t
+    val to_int64 : t -> Int64.t
+    val max_value : t
+    val min_value : t
+  end) =
 struct
   open I
 
@@ -872,20 +872,49 @@ struct
       Int64.( < ) lower_bound_minus_epsilon min_value)
   ;;
 
-  let%test "bigger than upper bound overflows" =
+  (* This test requires a modification for wasm; the value of [upper_bound_plus_epsilon]
+     in case of [Int64], instead of being [Int64.min_value], is actually
+     [Int64.max_value]. This is due to the limited instruction set provided by wasm; there
+     are two instructions that convert a float to an i64:
+
+     - trunc: traps when the result would be out of range. (a "trap" is
+       basically an unrecoverable exception)
+     - trunc_sat: "saturates" the result when it is out of range, rather than
+       trapping. If the result would be an overflow, it gets clamped to
+       [max_int], and if it would be an underflow, it gets clamped to [min_int].
+
+     The wasm_of_ocaml compiler uses trunc_sat to avoid trapping, but this
+     means it yields a different result on out-of-range results.
+  *)
+  let bigger_than_upper_bound_overflows ~wasm =
     let upper_bound = Int64.of_float float_upper_bound in
     let upper_bound_plus_epsilon =
       Stdlib.Int64.of_float (one_ulp `Up float_upper_bound)
     in
     let max_value = to_int64 max_value in
     if Int.( = ) num_bits 64
-       (* upper_bound_plus_epsilon is not representable as a Int64.t, it has overflowed *)
-    then Int64.( < ) upper_bound_plus_epsilon upper_bound
+    then
+      if not wasm
+      then
+        (* upper_bound_plus_epsilon is not representable as a Int64.t, it has overflowed *)
+        Int64.( = ) upper_bound_plus_epsilon Int64.min_value
+      else
+        (* In the wasm version we clamp instead of overflowing, see the explanation in the
+           comment above. *)
+        Int64.( = ) upper_bound_plus_epsilon Int64.max_value
     else (
       assert (Int64.( >= ) upper_bound_plus_epsilon upper_bound);
       (* a value greater than max_value would overflow if converted to [t] *)
       Int64.( > ) upper_bound_plus_epsilon max_value)
   ;;
+
+  let%test ("bigger than upper bound overflows" [@tags "no-wasm"]) =
+    bigger_than_upper_bound_overflows ~wasm:false
+  ;;
+
+  let%test ("bigger than upper bound overflows, kind of" [@tags "wasm-only"]) =
+    bigger_than_upper_bound_overflows ~wasm:true
+  ;;
 end
 
 let%test_module "Int" = (module Test_bounds (Int))
@@ -1079,7 +1108,8 @@ let%test_module "Hexadecimal syntax" =
 let%expect_test "square" =
   printf "%f\n" (square 1.5);
   printf "%f\n" (square (-2.5));
-  [%expect {|
+  [%expect
+    {|
     2.250000
     6.250000
     |}]
@@ -1091,7 +1121,7 @@ let%expect_test "mathematical constants" =
   eq pi "3.141592653589793238462643383279502884197169399375105820974";
   eq sqrt_pi "1.772453850905516027298167483341145182797549456122387128213";
   eq sqrt_2pi "2.506628274631000502415765284811045253006986740609938316629";
-  eq euler "0.577215664901532860606512090082402431042159335939923598805";
+  eq euler_gamma_constant "0.577215664901532860606512090082402431042159335939923598805";
   (* Check size of diff from  ordinary computation. *)
   printf "sqrt pi diff  : %.20f\n" (sqrt_pi - sqrt pi);
   printf "sqrt 2pi diff : %.20f\n" (sqrt_2pi - sqrt (2. * pi));
@@ -1196,25 +1226,25 @@ let%expect_test "is_nan, is_inf, and is_finite" =
 ;;
 
 let%expect_test "nan" =
-  require [%here] (Float.is_nan (Float.min 1. Float.nan));
-  require [%here] (Float.is_nan (Float.min Float.nan 0.));
-  require [%here] (Float.is_nan (Float.min Float.nan Float.nan));
-  require [%here] (Float.is_nan (Float.max 1. Float.nan));
-  require [%here] (Float.is_nan (Float.max Float.nan 0.));
-  require [%here] (Float.is_nan (Float.max Float.nan Float.nan));
-  require_equal [%here] (module Float) 1. (Float.min_inan 1. Float.nan);
-  require_equal [%here] (module Float) 0. (Float.min_inan Float.nan 0.);
-  require [%here] (Float.is_nan (Float.min_inan Float.nan Float.nan));
-  require_equal [%here] (module Float) 1. (Float.max_inan 1. Float.nan);
-  require_equal [%here] (module Float) 0. (Float.max_inan Float.nan 0.);
-  require [%here] (Float.is_nan (Float.max_inan Float.nan Float.nan))
+  require (Float.is_nan (Float.min 1. Float.nan));
+  require (Float.is_nan (Float.min Float.nan 0.));
+  require (Float.is_nan (Float.min Float.nan Float.nan));
+  require (Float.is_nan (Float.max 1. Float.nan));
+  require (Float.is_nan (Float.max Float.nan 0.));
+  require (Float.is_nan (Float.max Float.nan Float.nan));
+  require_equal (module Float) 1. (Float.min_inan 1. Float.nan);
+  require_equal (module Float) 0. (Float.min_inan Float.nan 0.);
+  require (Float.is_nan (Float.min_inan Float.nan Float.nan));
+  require_equal (module Float) 1. (Float.max_inan 1. Float.nan);
+  require_equal (module Float) 0. (Float.max_inan Float.nan 0.);
+  require (Float.is_nan (Float.max_inan Float.nan Float.nan))
 ;;
 
 let%expect_test "iround_exn" =
-  require_equal [%here] (module Int) 0 (Float.iround_exn ~dir:`Nearest 0.2);
-  require_equal [%here] (module Int) 0 (Float.iround_exn ~dir:`Nearest (-0.2));
-  require_equal [%here] (module Int) 3 (Float.iround_exn ~dir:`Nearest 3.4);
-  require_equal [%here] (module Int) (-3) (Float.iround_exn ~dir:`Nearest (-3.4))
+  require_equal (module Int) 0 (Float.iround_exn ~dir:`Nearest 0.2);
+  require_equal (module Int) 0 (Float.iround_exn ~dir:`Nearest (-0.2));
+  require_equal (module Int) 3 (Float.iround_exn ~dir:`Nearest 3.4);
+  require_equal (module Int) (-3) (Float.iround_exn ~dir:`Nearest (-3.4))
 ;;
 
 let%expect_test "log" =
@@ -1233,19 +1263,22 @@ let%expect_test "log" =
     print_s [%sexp { log2 : float; log10 : float; ratio : float }]
   in
   test (-1.);
-  [%expect {|
+  [%expect
+    {|
     ((log2  NAN)
      (log10 NAN)
      (ratio NAN))
     |}];
   test 0.;
-  [%expect {|
+  [%expect
+    {|
     ((log2  -INF)
      (log10 -INF)
      (ratio NAN))
     |}];
   test 1.;
-  [%expect {|
+  [%expect
+    {|
     ((log2  0)
      (log10 0)
      (ratio NAN))
@@ -1293,7 +1326,8 @@ let%expect_test "log" =
      (ratio 3.3219280948873622))
     |}];
   test Float.infinity;
-  [%expect {|
+  [%expect
+    {|
     ((log2  INF)
      (log10 INF)
      (ratio NAN))
diff --git a/test/test_globalize_lib.ml b/test/test_globalize_lib.ml
index f2d41270..6c2f7605 100644
--- a/test/test_globalize_lib.ml
+++ b/test/test_globalize_lib.ml
@@ -1,4 +1,4 @@
-open! Core
+open! Base
 open! Import
 
 let%expect_test "bool_true" =
@@ -62,7 +62,8 @@ let%expect_test "array" =
   let a = [| "one"; "two"; "three" |] in
   let a' = globalize_array globalize_string a in
   Array.iter ~f:print_endline a';
-  [%expect {|
+  [%expect
+    {|
     one
     two
     three
@@ -73,13 +74,23 @@ let%expect_test "list" =
   let l = [ "one"; "two"; "three" ] in
   let l' = globalize_list globalize_string l in
   List.iter ~f:print_endline l';
-  [%expect {|
+  [%expect
+    {|
     one
     two
     three
     |}]
 ;;
 
+let%expect_test "list does not stack overflow" =
+  let l = List.init 5_000_000 ~f:(fun i -> i) in
+  (* Test for timeout / stack overflow on a long list. *)
+  (match globalize_list globalize_int l with
+   | (_ : int list) -> ()
+   | exception Stack_overflow -> print_cr [%message "stack overflow"]);
+  [%expect {| |}]
+;;
+
 let%expect_test "option" =
   let o = Some "hello" in
   let o' = globalize_option globalize_string o in
diff --git a/test/test_hash_set.ml b/test/test_hash_set.ml
index f678a236..3e57e456 100644
--- a/test/test_hash_set.ml
+++ b/test/test_hash_set.ml
@@ -81,19 +81,19 @@ let%expect_test "deriving equal" =
     let of_list lst = { hs = Hash_set.of_list (module Int) lst }
   end
   in
-  require [%here] (Hs.equal (Hs.of_list []) (Hs.of_list []));
-  require [%here] (not (Hs.equal (Hs.of_list [ 1 ]) (Hs.of_list [])));
-  require [%here] (not (Hs.equal (Hs.of_list [ 1 ]) (Hs.of_list [ 2 ])));
-  require [%here] (Hs.equal (Hs.of_list [ 1 ]) (Hs.of_list [ 1 ]))
+  require (Hs.equal (Hs.of_list []) (Hs.of_list []));
+  require (not (Hs.equal (Hs.of_list [ 1 ]) (Hs.of_list [])));
+  require (not (Hs.equal (Hs.of_list [ 1 ]) (Hs.of_list [ 2 ])));
+  require (Hs.equal (Hs.of_list [ 1 ]) (Hs.of_list [ 1 ]))
 ;;
 
 (* This module exists to check, at compile-time, that [Creators] is a subset of
    [Creators_generic]. *)
 module _ (M : Creators) :
   Creators_generic
-    with type 'a t := 'a M.t
-    with type 'a elt := 'a
-    with type ('a, 'z) create_options := ('a, 'z) create_options = struct
+  with type 'a t := 'a M.t
+  with type 'a elt := 'a
+  with type ('a, 'z) create_options := ('a, 'z) create_options = struct
   include M
 
   let create ?growth_allowed ?size m () = create ?growth_allowed ?size m
diff --git a/test/test_hashtbl.ml b/test/test_hashtbl.ml
index 28f8e1c0..8270e2ac 100644
--- a/test/test_hashtbl.ml
+++ b/test/test_hashtbl.ml
@@ -18,19 +18,18 @@ let%test "Hashtbl.merge succeeds with first-class-module interface" =
 
 let%test_module _ =
   (module Hashtbl_tests.Make (struct
-    include Hashtbl
+      include Hashtbl
 
-    let create_poly ?size () = Poly.create ?size ()
-    let of_alist_poly_exn l = Poly.of_alist_exn l
-    let of_alist_poly_or_error l = Poly.of_alist_or_error l
-  end))
+      let create_poly ?size () = Poly.create ?size ()
+      let of_alist_poly_exn l = Poly.of_alist_exn l
+      let of_alist_poly_or_error l = Poly.of_alist_or_error l
+    end))
 ;;
 
 let%expect_test "Hashtbl.find_exn" =
   let table = Hashtbl.of_alist_exn (module String) [ "one", 1; "two", 2; "three", 3 ] in
   let test_success key =
-    require_does_not_raise [%here] (fun () ->
-      print_s [%sexp (Hashtbl.find_exn table key : int)])
+    require_does_not_raise (fun () -> print_s [%sexp (Hashtbl.find_exn table key : int)])
   in
   test_success "one";
   [%expect {| 1 |}];
@@ -38,9 +37,7 @@ let%expect_test "Hashtbl.find_exn" =
   [%expect {| 2 |}];
   test_success "three";
   [%expect {| 3 |}];
-  let test_failure key =
-    require_does_raise [%here] (fun () -> Hashtbl.find_exn table key)
-  in
+  let test_failure key = require_does_raise (fun () -> Hashtbl.find_exn table key) in
   test_failure "zero";
   [%expect {| (Not_found_s ("Hashtbl.find_exn: not found" zero)) |}];
   test_failure "four";
@@ -50,9 +47,9 @@ let%expect_test "Hashtbl.find_exn" =
 let%expect_test "[t_of_sexp] error on duplicate" =
   let sexp = Sexplib.Sexp.of_string "((0 a)(1 b)(2 c)(1 d))" in
   (match [%of_sexp: string Hashtbl.M(String).t] sexp with
-   | t -> print_cr [%here] [%message "did not raise" (t : string Hashtbl.M(String).t)]
+   | t -> print_cr [%message "did not raise" (t : string Hashtbl.M(String).t)]
    | exception (Sexp.Of_sexp_error _ as exn) -> print_s (sexp_of_exn exn)
-   | exception exn -> print_cr [%here] [%message "wrong kind of exception" (exn : exn)]);
+   | exception exn -> print_cr [%message "wrong kind of exception" (exn : exn)]);
   [%expect {| (Of_sexp_error "Hashtbl.t_of_sexp: duplicate key" (invalid_sexp 1)) |}]
 ;;
 
@@ -69,7 +66,7 @@ let%expect_test "[choose], [choose_exn], [choose_randomly], [choose_randomly_exn
           ~choose_randomly:(Hashtbl.choose_randomly t : (_ * _) option)
           ~choose_randomly_exn:
             (Or_error.try_with (fun () -> Hashtbl.choose_randomly_exn t)
-              : (_ * _) Or_error.t)]
+             : (_ * _) Or_error.t)]
   in
   test [];
   [%expect
diff --git a/test/test_identifiable.ml b/test/test_identifiable.ml
index d65af34b..304bc3bc 100644
--- a/test/test_identifiable.ml
+++ b/test/test_identifiable.ml
@@ -5,10 +5,10 @@ module T = struct
   type t = string
 
   include Make (struct
-    let module_name = "test"
+      let module_name = "test"
 
-    include String
-  end)
+      include String
+    end)
 end
 
 let%expect_test ("hash coherence" [@tags "64-bits-only"]) =
diff --git a/test/test_indexed_container.ml b/test/test_indexed_container.ml
index e7257223..1aa83fd7 100644
--- a/test/test_indexed_container.ml
+++ b/test/test_indexed_container.ml
@@ -6,14 +6,14 @@ module This_list : S = struct
   include List
 
   include Indexed_container.Make (struct
-    type 'a t = 'a list
-
-    let fold = List.fold
-    let iter = `Custom List.iter
-    let length = `Custom List.length
-    let foldi = `Define_using_fold
-    let iteri = `Define_using_fold
-  end)
+      type 'a t = 'a list
+
+      let fold = List.fold
+      let iter = `Custom List.iter
+      let length = `Custom List.length
+      let foldi = `Define_using_fold
+      let iteri = `Define_using_fold
+    end)
 end
 
 module That_list : S = List
@@ -41,7 +41,7 @@ let check (type a) here examples ~actual ~expect (module Output : Output with ty
     let actual = actual example in
     let expect = expect example in
     require
-      here
+      ~here
       (Output.compare actual expect = 0)
       ~if_false_then_print_s:(lazy [%message (expect : Output.t)]);
     print_s [%sexp (actual : Output.t)])
@@ -55,7 +55,8 @@ let%expect_test "foldi" =
     (module Int_list)
     ~actual:(fun list -> This_list.foldi list ~init:[] ~f)
     ~expect:(fun list -> That_list.foldi list ~init:[] ~f);
-  [%expect {|
+  [%expect
+    {|
     ()
     (1)
     (2)
@@ -74,7 +75,8 @@ let%expect_test "findi" =
       ~expect:(fun list -> That_list.findi list ~f)
   in
   check (fun i _elt -> i = 0);
-  [%expect {|
+  [%expect
+    {|
     ()
     ((0 1))
     ((0 2))
@@ -82,7 +84,8 @@ let%expect_test "findi" =
     ((0 0))
     |}];
   check (fun _i elt -> elt = 1);
-  [%expect {|
+  [%expect
+    {|
     ()
     ((0 1))
     ()
@@ -99,7 +102,8 @@ let%expect_test "find_mapi" =
     (module Int_option)
     ~actual:(fun list -> This_list.find_mapi list ~f)
     ~expect:(fun list -> That_list.find_mapi list ~f);
-  [%expect {|
+  [%expect
+    {|
     ()
     (1)
     ()
@@ -149,7 +153,8 @@ let%expect_test "for_alli" =
     (module Bool)
     ~actual:(fun list -> This_list.for_alli list ~f)
     ~expect:(fun list -> That_list.for_alli list ~f);
-  [%expect {|
+  [%expect
+    {|
     true
     true
     false
@@ -168,7 +173,8 @@ let%expect_test "existsi" =
     (module Bool)
     ~actual:(fun list -> This_list.existsi list ~f)
     ~expect:(fun list -> That_list.existsi list ~f);
-  [%expect {|
+  [%expect
+    {|
     false
     true
     false
@@ -187,7 +193,8 @@ let%expect_test "counti" =
     (module Int)
     ~actual:(fun list -> This_list.counti list ~f)
     ~expect:(fun list -> That_list.counti list ~f);
-  [%expect {|
+  [%expect
+    {|
     0
     1
     0
diff --git a/test/test_info.ml b/test/test_info.ml
index c6d353e3..1bb147f1 100644
--- a/test/test_info.ml
+++ b/test/test_info.ml
@@ -35,7 +35,6 @@ let%expect_test _ =
 
 let%expect_test _ =
   require_equal
-    [%here]
     (module Sexp)
     (sexp_of_t nested)
     (sexp_of_t (of_strings [ "a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i" ]));
@@ -50,7 +49,7 @@ let%expect_test _ =
 
 let round t =
   let sexp = sexp_of_t t in
-  require [%here] (Sexp.( = ) sexp (sexp_of_t (t_of_sexp sexp)))
+  require (Sexp.( = ) sexp (sexp_of_t (t_of_sexp sexp)))
 ;;
 
 let%expect_test "non-empty tag" =
@@ -76,7 +75,7 @@ let%expect_test _ =
 ;;
 
 let%expect_test _ =
-  require_equal [%here] (module String) (to_string_hum (of_string "a\nb")) "a\nb";
+  require_equal (module String) (to_string_hum (of_string "a\nb")) "a\nb";
   [%expect {| |}]
 ;;
 
diff --git a/test/test_int.ml b/test/test_int.ml
index 9a7ca862..5508ae89 100644
--- a/test/test_int.ml
+++ b/test/test_int.ml
@@ -22,10 +22,9 @@ let%expect_test "of_string_opt" =
 
 let%expect_test "to_string_hum" =
   let test_roundtrip int =
-    require_equal [%here] (module Int) (of_string (to_string_hum int)) int
+    require_equal (module Int) (of_string (to_string_hum int)) int
   in
   quickcheck_m
-    [%here]
     (module struct
       type t = int [@@deriving quickcheck, sexp_of]
     end)
@@ -114,7 +113,6 @@ let%test_module "Hex" =
 
 let%expect_test "binary" =
   quickcheck_m
-    [%here]
     (module struct
       type t = int [@@deriving quickcheck, sexp_of]
     end)
@@ -129,49 +127,57 @@ let test_binary i =
 
 let%expect_test "binary" =
   test_binary 0b0;
-  [%expect {|
+  [%expect
+    {|
     0b0
     0b0
     0b0
     |}];
   test_binary 0b01;
-  [%expect {|
+  [%expect
+    {|
     0b1
     0b1
     0b1
     |}];
   test_binary 0b100;
-  [%expect {|
+  [%expect
+    {|
     0b100
     0b100
     0b100
     |}];
   test_binary 0b101;
-  [%expect {|
+  [%expect
+    {|
     0b101
     0b101
     0b101
     |}];
   test_binary 0b10_1010_1010_1010;
-  [%expect {|
+  [%expect
+    {|
     0b10_1010_1010_1010
     0b10101010101010
     0b10_1010_1010_1010
     |}];
   test_binary 0b11_1111_0000_0000;
-  [%expect {|
+  [%expect
+    {|
     0b11_1111_0000_0000
     0b11111100000000
     0b11_1111_0000_0000
     |}];
   test_binary 19;
-  [%expect {|
+  [%expect
+    {|
     0b1_0011
     0b10011
     0b1_0011
     |}];
   test_binary 0;
-  [%expect {|
+  [%expect
+    {|
     0b0
     0b0
     0b0
@@ -202,7 +208,7 @@ let%expect_test ("63-bit cases" [@tags "64-bits-only"]) =
     |}]
 ;;
 
-let%expect_test ("32-bit cases" [@tags "js-only"]) =
+let%expect_test ("32-bit cases" [@tags "js-only", "no-wasm"]) =
   test_binary (-1);
   [%expect
     {|
@@ -226,6 +232,30 @@ let%expect_test ("32-bit cases" [@tags "js-only"]) =
     |}]
 ;;
 
+let%expect_test ("32-bit wasm cases" [@tags "wasm-only"]) =
+  test_binary (-1);
+  [%expect
+    {|
+    0b111_1111_1111_1111_1111_1111_1111_1111
+    0b1111111111111111111111111111111
+    0b111_1111_1111_1111_1111_1111_1111_1111
+    |}];
+  test_binary max_value;
+  [%expect
+    {|
+    0b11_1111_1111_1111_1111_1111_1111_1111
+    0b111111111111111111111111111111
+    0b11_1111_1111_1111_1111_1111_1111_1111
+    |}];
+  test_binary min_value;
+  [%expect
+    {|
+    0b100_0000_0000_0000_0000_0000_0000_0000
+    0b1000000000000000000000000000000
+    0b100_0000_0000_0000_0000_0000_0000_0000
+    |}]
+;;
+
 let%test _ = neg 5 + 5 = 0
 let%test _ = pow min_value 1 = min_value
 let%test _ = pow max_value 1 = max_value
@@ -268,7 +298,6 @@ let%expect_test "bswap16" =
 
 let%expect_test "% and /%" =
   quickcheck_m
-    [%here]
     (module struct
       type t =
         int
@@ -279,22 +308,22 @@ let%expect_test "% and /%" =
     ~f:(fun (a, b) ->
       let r = a % b in
       let q = a /% b in
-      require [%here] (r >= 0);
-      require_equal [%here] (module Int) a ((q * b) + r))
+      require (r >= 0);
+      require_equal (module Int) a ((q * b) + r))
 ;;
 
 include (
-  struct
-    (** Various functors whose type-correctness ensures desired relationships between
+struct
+  (** Various functors whose type-correctness ensures desired relationships between
       interfaces. *)
 
-    (* O contained in S *)
-    module _ (M : S) : module type of M.O = M
+  (* O contained in S *)
+  module _ (M : S) : module type of M.O = M
 
-    (* O contained in S_unbounded *)
-    module _ (M : S_unbounded) : module type of M.O = M
+  (* O contained in S_unbounded *)
+  module _ (M : S_unbounded) : module type of M.O = M
 
-    (* S_unbounded in S *)
-    module _ (M : S) : S_unbounded = M
-  end :
-    sig end)
+  (* S_unbounded in S *)
+  module _ (M : S) : S_unbounded = M
+end :
+sig end)
diff --git a/test/test_int32.ml b/test/test_int32.ml
index 45f37f0c..7431ecce 100644
--- a/test/test_int32.ml
+++ b/test/test_int32.ml
@@ -33,7 +33,6 @@ let%expect_test "bswap32" =
 
 let%expect_test "binary" =
   quickcheck_m
-    [%here]
     (module struct
       type t = int32 [@@deriving quickcheck, sexp_of]
     end)
@@ -49,31 +48,36 @@ let test_binary i =
 
 let%expect_test "binary" =
   test_binary 0b01l;
-  [%expect {|
+  [%expect
+    {|
     0b1
     0b1
     0b1
     |}];
   test_binary 0b100l;
-  [%expect {|
+  [%expect
+    {|
     0b100
     0b100
     0b100
     |}];
   test_binary 0b101l;
-  [%expect {|
+  [%expect
+    {|
     0b101
     0b101
     0b101
     |}];
   test_binary 0b10_1010_1010_1010l;
-  [%expect {|
+  [%expect
+    {|
     0b10_1010_1010_1010
     0b10101010101010
     0b10_1010_1010_1010
     |}];
   test_binary 0b11_1111_0000_0000l;
-  [%expect {|
+  [%expect
+    {|
     0b11_1111_0000_0000
     0b11111100000000
     0b11_1111_0000_0000
diff --git a/test/test_int63.ml b/test/test_int63.ml
index 94ae29e7..1ca065fd 100644
--- a/test/test_int63.ml
+++ b/test/test_int63.ml
@@ -100,7 +100,8 @@ let%expect_test "[floor_log2]" =
   for i = 1 to 8 do
     floor_log2 (i |> of_int)
   done;
-  [%expect {|
+  [%expect
+    {|
     0
     1
     1
@@ -120,7 +121,6 @@ let%expect_test "[floor_log2]" =
 
 let%expect_test "binary" =
   quickcheck_m
-    [%here]
     (module struct
       type t = int64 [@@deriving quickcheck, sexp_of]
     end)
@@ -137,13 +137,15 @@ let test_binary i =
 
 let%expect_test ("binary emulation" [@tags "js-only"]) =
   test_binary 0b1L;
-  [%expect {|
+  [%expect
+    {|
     0b1
     0b1
     0b1
     |}];
   test_binary 0b0L;
-  [%expect {|
+  [%expect
+    {|
     0b0
     0b0
     0b0
@@ -152,33 +154,49 @@ let%expect_test ("binary emulation" [@tags "js-only"]) =
 
 let%expect_test "binary" =
   test_binary 0b01L;
-  [%expect {|
+  [%expect
+    {|
     0b1
     0b1
     0b1
     |}];
   test_binary 0b100L;
-  [%expect {|
+  [%expect
+    {|
     0b100
     0b100
     0b100
     |}];
   test_binary 0b101L;
-  [%expect {|
+  [%expect
+    {|
     0b101
     0b101
     0b101
     |}];
   test_binary 0b10_1010_1010_1010L;
-  [%expect {|
+  [%expect
+    {|
     0b10_1010_1010_1010
     0b10101010101010
     0b10_1010_1010_1010
     |}];
   test_binary 0b11_1111_0000_0000L;
-  [%expect {|
+  [%expect
+    {|
     0b11_1111_0000_0000
     0b11111100000000
     0b11_1111_0000_0000
     |}]
 ;;
+
+let%expect_test ("inlining and resolve calls" [@tags "64-bits-only", "js-only"]) =
+  let i =
+    (Int.bit_and [@inlined always]) (Sys.opaque_identity 1) (Sys.opaque_identity 1)
+  in
+  print_s [%sexp (i : int)];
+  let j = Int63.of_int (Sys.opaque_identity 1) in
+  let i = (Int63.bit_and [@inlined always]) j j in
+  print_s [%sexp (i : t)];
+  [%expect {| |}]
+;;
diff --git a/test/test_int63_emul.ml b/test/test_int63_emul.ml
index 7579cc40..9164dedd 100644
--- a/test/test_int63_emul.ml
+++ b/test/test_int63_emul.ml
@@ -5,7 +5,7 @@ let%expect_test _ =
   let s63 = Int63.(Hex.to_string min_value) in
   let s63_emul = Int63_emul.(Hex.to_string min_value) in
   print_s [%message (s63 : string) (s63_emul : string)];
-  require [%here] (String.equal s63 s63_emul);
+  require (String.equal s63 s63_emul);
   [%expect
     {|
     ((s63      -0x4000000000000000)
diff --git a/test/test_int64.ml b/test/test_int64.ml
index 500a660f..4636565a 100644
--- a/test/test_int64.ml
+++ b/test/test_int64.ml
@@ -77,7 +77,6 @@ let%expect_test "bswap64" =
 
 let%expect_test "binary" =
   quickcheck_m
-    [%here]
     (module struct
       type t = int64 [@@deriving quickcheck, sexp_of]
     end)
@@ -93,31 +92,36 @@ let test_binary i =
 
 let%expect_test "binary" =
   test_binary 0b01L;
-  [%expect {|
+  [%expect
+    {|
     0b1
     0b1
     0b1
     |}];
   test_binary 0b100L;
-  [%expect {|
+  [%expect
+    {|
     0b100
     0b100
     0b100
     |}];
   test_binary 0b101L;
-  [%expect {|
+  [%expect
+    {|
     0b101
     0b101
     0b101
     |}];
   test_binary 0b10_1010_1010_1010L;
-  [%expect {|
+  [%expect
+    {|
     0b10_1010_1010_1010
     0b10101010101010
     0b10_1010_1010_1010
     |}];
   test_binary 0b11_1111_0000_0000L;
-  [%expect {|
+  [%expect
+    {|
     0b11_1111_0000_0000
     0b11111100000000
     0b11_1111_0000_0000
diff --git a/test/test_int_conversions.ml b/test/test_int_conversions.ml
index 908dbeb3..ead1dc07 100644
--- a/test/test_int_conversions.ml
+++ b/test/test_int_conversions.ml
@@ -53,7 +53,7 @@ let%test_module "conversions" =
         match a_to_b_or_error a with
         | Ok b ->
           require
-            loc
+            ~here:loc
             (B.equal b b')
             ~if_false_then_print_s:
               (lazy
@@ -65,7 +65,7 @@ let%test_module "conversions" =
                     ~output:(b : B.t)
                     ~expected:(b' : B.t)]);
           require
-            loc
+            ~here:loc
             (A.equal a a')
             ~if_false_then_print_s:
               (lazy
@@ -78,7 +78,7 @@ let%test_module "conversions" =
                     ~round_trip:(a' : A.t)])
         | Error error ->
           require
-            loc
+            ~here:loc
             (not (A.equal a a'))
             ~if_false_then_print_s:
               (lazy
@@ -234,21 +234,21 @@ let%test_module "Make_hex" =
       type t = int [@@deriving quickcheck]
 
       module M = Make_hex (struct
-        type nonrec t = int [@@deriving sexp, compare ~localize, hash, quickcheck]
+          type nonrec t = int [@@deriving sexp, compare ~localize, hash, quickcheck]
 
-        let to_string = Int.Hex.to_string
-        let of_string = Int.Hex.of_string
-        let zero = 0
-        let ( < ) = ( < )
-        let neg = Int.neg
-        let module_name = "Hex_int"
-      end)
+          let to_string = Int.Hex.to_string
+          let of_string = Int.Hex.of_string
+          let zero = 0
+          let ( < ) = ( < )
+          let neg = Int.neg
+          let module_name = "Hex_int"
+        end)
 
       include (M.Hex : module type of M.Hex with type t := t)
     end
 
     let%expect_test "validate sexp grammar" =
-      require_ok [%here] (Sexp_grammar_validation.validate_grammar (module Hex_int));
+      require_ok (Sexp_grammar_validation.validate_grammar (module Hex_int));
       [%expect {| String |}]
     ;;
   end)
diff --git a/test/test_int_math.ml b/test/test_int_math.ml
index dedcf847..dc649b8d 100644
--- a/test/test_int_math.ml
+++ b/test/test_int_math.ml
@@ -262,7 +262,7 @@ let%test_module "int rounding quickcheck tests" =
       in
       let module Math = Make (Integer) in
       let module Pair = Rounding_pair (Integer) in
-      require_does_not_raise [%here] (fun () ->
+      require_does_not_raise (fun () ->
         Base_quickcheck.Test.run_exn
           (module Pair)
           ~f:(fun ({ number; factor } : Pair.t) ->
@@ -439,33 +439,22 @@ let%test_module "overflow_bounds" =
       Int64.equal Pow_overflow_bounds.overflow_bound_max_int64_value Int64.max_value
     ;;
 
-    module Big_int = struct
-      include Big_int
-
-      let ( > ) = gt_big_int
-      let ( = ) = eq_big_int
-      let ( ^ ) = power_big_int_positive_int
-      let ( + ) = add_big_int
-      let one = unit_big_int
-      let to_string = string_of_big_int
-    end
-
     let test_overflow_table tbl conv max_val =
       assert (Array.length tbl = 64);
       let max_val = conv max_val in
       Array.iteri tbl ~f:(fun i max_base ->
         let max_base = conv max_base in
-        let overflows b = Big_int.(b ^ i > max_val) in
+        let overflows b = Bigint.(b ** of_int i > max_val) in
         let is_ok =
           if i = 0
-          then Big_int.(max_base = max_val)
-          else (not (overflows max_base)) && overflows Big_int.(max_base + one)
+          then Bigint.(max_base = max_val)
+          else (not (overflows max_base)) && overflows Bigint.(max_base + one)
         in
         if not is_ok
         then
           Printf.failwithf
             "overflow table check failed for %s (index %d)"
-            (Big_int.to_string max_base)
+            (Bigint.to_string max_base)
             i
             ())
     ;;
@@ -473,14 +462,14 @@ let%test_module "overflow_bounds" =
     let%test_unit _ =
       test_overflow_table
         Pow_overflow_bounds.int_positive_overflow_bounds
-        Big_int.big_int_of_int
+        Bigint.of_int
         Int.max_value
     ;;
 
     let%test_unit _ =
       test_overflow_table
         Pow_overflow_bounds.int64_positive_overflow_bounds
-        Big_int.big_int_of_int64
+        Bigint.of_int64
         Int64.max_value
     ;;
   end)
diff --git a/test/test_lazy.ml b/test/test_lazy.ml
index 86215f1b..0a145501 100644
--- a/test/test_lazy.ml
+++ b/test/test_lazy.ml
@@ -94,14 +94,16 @@ let%expect_test "equal" =
   [%expect {| true |}];
   (* [force], resulting in [true] *)
   print_s [%sexp (equal Int.equal lazy_a lazy_b : bool)];
-  [%expect {|
+  [%expect
+    {|
     force lazy_b
     force lazy_a
     true
     |}];
   (* [force], resulting in [false] *)
   print_s [%sexp (equal Int.equal lazy_b lazy_c : bool)];
-  [%expect {|
+  [%expect
+    {|
     force lazy_c
     false
     |}]
diff --git a/test/test_list.ml b/test/test_list.ml
index 4d10cb47..e4c438fc 100644
--- a/test/test_list.ml
+++ b/test/test_list.ml
@@ -504,7 +504,6 @@ let%test_module "Assoc.group" =
             List.map data ~f:(fun datum -> key, datum))
         in
         require_equal
-          [%here]
           (module struct
             type t = (String.Caseless.t * int) list [@@deriving equal, sexp_of]
           end)
@@ -516,7 +515,8 @@ let%test_module "Assoc.group" =
       test [ "a", 1; "A", 2 ];
       [%expect {| ((a (1 2))) |}];
       test [ "a", 1; "b", 2 ];
-      [%expect {|
+      [%expect
+        {|
         ((a (1))
          (b (2)))
         |}];
@@ -531,7 +531,8 @@ let%test_module "Assoc.group" =
          (EVEN (6)))
         |}];
       test [ "odd", 1; "Odd", 3; "ODD", 5; "even", 2; "Even", 4; "EVEN", 6 ];
-      [%expect {|
+      [%expect
+        {|
         ((odd  (1 3 5))
          (even (2 4 6)))
         |}]
@@ -546,7 +547,6 @@ let%test_module "Assoc.sort_and_group" =
         let multi = Assoc.sort_and_group alist ~compare:String.Caseless.compare in
         print_s [%sexp (multi : (string * int list) list)];
         require_equal
-          [%here]
           (module struct
             type t = (string * int list) list [@@deriving equal, sexp_of]
           end)
@@ -558,12 +558,14 @@ let%test_module "Assoc.sort_and_group" =
       test [ "a", 1; "A", 2 ];
       [%expect {| ((a (1 2))) |}];
       test [ "a", 1; "b", 2 ];
-      [%expect {|
+      [%expect
+        {|
         ((a (1))
          (b (2)))
         |}];
       test [ "odd", 1; "even", 2; "Odd", 3; "Even", 4; "ODD", 5; "EVEN", 6 ];
-      [%expect {|
+      [%expect
+        {|
         ((even (2 4 6))
          (odd  (1 3 5)))
         |}]
@@ -1277,9 +1279,9 @@ let%expect_test "drop_last" =
 
 let%expect_test "drop_last_exn" =
   let print_drop_last_exn x = print_s [%sexp (List.drop_last_exn x : int list)] in
-  require_does_raise [%here] (fun () -> print_drop_last_exn []);
+  require_does_raise (fun () -> print_drop_last_exn []);
   [%expect {| (Failure "List.drop_last_exn: empty list") |}];
-  require_does_not_raise [%here] (fun () -> print_drop_last_exn [ 1 ]);
+  require_does_not_raise (fun () -> print_drop_last_exn [ 1 ]);
   [%expect {| () |}]
 ;;
 
@@ -1320,7 +1322,6 @@ let%expect_test "[all_equal]" =
 let%expect_test "[Cartesian_product.apply] identity" =
   let test list =
     require_equal
-      [%here]
       (module struct
         type t = char list [@@deriving equal, sexp_of]
       end)
@@ -1377,7 +1378,6 @@ let%expect_test "[compare__local] is the same as [compare]" =
     end)
     ~f:(fun (l1, l2) ->
       require_equal
-        [%here]
         (module Int)
         (compare Int.compare l1 l2)
         (compare__local Int.compare__local l1 l2));
@@ -1391,7 +1391,6 @@ let%expect_test "[equal__local] is the same as [equal]" =
     end)
     ~f:(fun (l1, l2) ->
       require_equal
-        [%here]
         (module Bool)
         (equal Int.equal l1 l2)
         (equal__local Int.equal__local l1 l2));
@@ -1463,30 +1462,25 @@ let%expect_test "list sort, dedup" =
   in
   let compare = Char.Caseless.compare in
   quickcheck_m
-    [%here]
     ~examples:[ []; [ 'a'; 'a' ]; [ 'a'; 'A' ]; [ 'A'; 'a' ]; [ 'A'; 'A' ] ]
     (module Char_list)
     ~f:(fun list ->
       require_equal
-        [%here]
         (module Char_list)
         ~message:"sort mismatch"
         (List.sort list ~compare)
         (slow_sort list ~compare);
       require_equal
-        [%here]
         (module Char_list)
         ~message:"stable_sort mismatch"
         (List.stable_sort list ~compare)
         (slow_stable_sort list ~compare);
       require_equal
-        [%here]
         (module Char_list)
         ~message:"dedup_and_sort mismatch"
         (List.dedup_and_sort list ~compare)
         (slow_dedup_and_sort list ~compare);
       require_equal
-        [%here]
         (module Char_list)
         ~message:"stable_dedup mismatch"
         (List.stable_dedup list ~compare)
@@ -1501,7 +1495,6 @@ let%expect_test "[take], [drop], and [split]" =
       let phys_equal_whole = phys_equal list whole in
       let check problem bool =
         require
-          [%here]
           bool
           ~if_false_then_print_s:
             [%lazy_message
@@ -1607,26 +1600,24 @@ let%test_module "filter{,i}" =
 
     let%expect_test "[filter]" =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> bool) [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun (list, f) ->
           (* test [f] *)
           let pos = List.filter list ~f in
-          require [%here] (List.for_all pos ~f);
+          require (List.for_all pos ~f);
           (* test [~f] *)
           let not_f = Fn.non f in
           let neg = List.filter list ~f:not_f in
-          require [%here] (List.for_all neg ~f:not_f);
+          require (List.for_all neg ~f:not_f);
           (* test [f \/ ~f] *)
           let sort = sort ~compare:Int.compare in
-          require_equal [%here] (module Int_list) (sort list) (sort (pos @ neg)))
+          require_equal (module Int_list) (sort list) (sort (pos @ neg)))
     ;;
 
     let%expect_test "[filteri]" =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> int -> bool) [@@deriving quickcheck, sexp_of]
         end)
@@ -1638,27 +1629,25 @@ let%test_module "filter{,i}" =
             let use_orig_index f : _ = fun (i, x) -> f i x in
             (* test [f] *)
             let pos = List.filteri list ~f:(ignore_stash f) in
-            require [%here] (List.for_all pos ~f:(use_orig_index f));
+            require (List.for_all pos ~f:(use_orig_index f));
             (* test [~f] *)
             let not_f i x = not (f i x) in
             let neg = List.filteri list ~f:(ignore_stash not_f) in
-            require [%here] (List.for_all neg ~f:(use_orig_index not_f));
+            require (List.for_all neg ~f:(use_orig_index not_f));
             pos, neg
           in
           (* test [f \/ ~f] *)
           let sort = sort ~compare:[%compare: int * _] in
-          require_equal [%here] (module Int_list) list (sort (pos @ neg) |> map ~f:snd))
+          require_equal (module Int_list) list (sort (pos @ neg) |> map ~f:snd))
     ;;
 
     let%expect_test "[filteri ~f:(Fn.const f) = filter ~f]" =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> bool) [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun (list, f) ->
           require_equal
-            [%here]
             (module Int_list)
             (filteri list ~f:(fun _ x -> f x))
             (filter list ~f))
@@ -1714,19 +1703,17 @@ let%test_module "count{,i}" =
   (module struct
     let%expect_test "[count{,i} list ~f = List.length (filter{,i} list ~f)]" =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> bool) [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun (list, f) ->
-          require_equal [%here] (module Int) (count list ~f) (length (filter list ~f)));
+          require_equal (module Int) (count list ~f) (length (filter list ~f)));
       quickcheck_m
-        [%here]
         (module struct
           type t = int list * (int -> int -> bool) [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun (list, f) ->
-          require_equal [%here] (module Int) (counti list ~f) (length (filteri list ~f)))
+          require_equal (module Int) (counti list ~f) (length (filteri list ~f)))
     ;;
 
     let%test_unit _ =
@@ -1745,18 +1732,16 @@ let%test_module "{min,max}_elt" =
   (module struct
     let test_in_list_and_forall ~tested_f ~holds_for_res_over_all_elem =
       quickcheck_m
-        [%here]
         (module struct
           type t = int list [@@deriving quickcheck, sexp_of]
         end)
         ~f:(fun list ->
           let res = tested_f list ~compare:[%compare: int] in
           match res with
-          | None -> require [%here] (is_empty list)
+          | None -> require (is_empty list)
           | Some res ->
-            require [%here] (mem list res ~equal:Int.equal);
-            iter list ~f:(fun elem ->
-              require [%here] (holds_for_res_over_all_elem ~res ~elem)))
+            require (mem list res ~equal:Int.equal);
+            iter list ~f:(fun elem -> require (holds_for_res_over_all_elem ~res ~elem)))
     ;;
 
     let%expect_test "min_elt" =
@@ -1834,7 +1819,7 @@ let%expect_test "[merge]" =
     let list1 = merge xs ys ~compare:Int.compare in
     print_s [%sexp (list1 : int list)];
     let list2 = merge ys xs ~compare:Int.compare in
-    require_equal [%here] (module Int_list) list1 list2
+    require_equal (module Int_list) list1 list2
   in
   test_int [] [];
   [%expect {| () |}];
@@ -1859,12 +1844,14 @@ let%expect_test "[merge]" =
     print_s [%sexp (list2 : (int * string) list)]
   in
   test_pair [] [];
-  [%expect {|
+  [%expect
+    {|
     ()
     ()
     |}];
   test_pair [] [ 1, "a"; 2, "b"; 3, "c" ];
-  [%expect {|
+  [%expect
+    {|
     ((1 a) (2 b) (3 c))
     ((1 a) (2 b) (3 c))
     |}];
@@ -1875,12 +1862,14 @@ let%expect_test "[merge]" =
     ((1 z) (2 y) (3 x) (4 w) (5 v))
     |}];
   test_pair [ 1, "a"; 2, "b" ] [];
-  [%expect {|
+  [%expect
+    {|
     ((1 a) (2 b))
     ((1 a) (2 b))
     |}];
   test_pair [ 1, "a"; 3, "b" ] [ 1, "b"; 2, "a" ];
-  [%expect {|
+  [%expect
+    {|
     ((1 a) (1 b) (2 a) (3 b))
     ((1 b) (1 a) (2 a) (3 b))
     |}];
diff --git a/test/test_map.ml b/test/test_map.ml
index c3050dec..0c875abb 100644
--- a/test/test_map.ml
+++ b/test/test_map.ml
@@ -7,16 +7,15 @@ let%expect_test "Finished_or_unfinished <-> Continue_or_stop" =
   List.iter2_exn Continue_or_stop.all Finished_or_unfinished.all ~f:(fun c_or_s f_or_u ->
     print_s [%sexp (c_or_s : Continue_or_stop.t), (f_or_u : Finished_or_unfinished.t)];
     require_equal
-      [%here]
       (module Continue_or_stop)
       c_or_s
       (Finished_or_unfinished.to_continue_or_stop f_or_u);
     require_equal
-      [%here]
       (module Finished_or_unfinished)
       f_or_u
       (Finished_or_unfinished.of_continue_or_stop c_or_s));
-  [%expect {|
+  [%expect
+    {|
     (Continue Finished)
     (Stop Unfinished)
     |}]
@@ -56,8 +55,9 @@ let%expect_test "[Map.of_alist_multi] preserves value ordering" =
   print_s
     [%sexp
       (Map.of_alist_multi (module String) [ "a", 1; "a", 2; "b", 1; "b", 3 ]
-        : int list Map.M(String).t)];
-  [%expect {|
+       : int list Map.M(String).t)];
+  [%expect
+    {|
     ((a (1 2))
      (b (1 3)))
     |}]
@@ -66,8 +66,7 @@ let%expect_test "[Map.of_alist_multi] preserves value ordering" =
 let%expect_test "find_exn" =
   let map = Map.of_alist_exn (module String) [ "one", 1; "two", 2; "three", 3 ] in
   let test_success key =
-    require_does_not_raise [%here] (fun () ->
-      print_s [%sexp (Map.find_exn map key : int)])
+    require_does_not_raise (fun () -> print_s [%sexp (Map.find_exn map key : int)])
   in
   test_success "one";
   [%expect {| 1 |}];
@@ -75,7 +74,7 @@ let%expect_test "find_exn" =
   [%expect {| 2 |}];
   test_success "three";
   [%expect {| 3 |}];
-  let test_failure key = require_does_raise [%here] (fun () -> Map.find_exn map key) in
+  let test_failure key = require_does_raise (fun () -> Map.find_exn map key) in
   test_failure "zero";
   [%expect {| (Not_found_s ("Map.find_exn: not found" zero)) |}];
   test_failure "four";
@@ -85,9 +84,9 @@ let%expect_test "find_exn" =
 let%expect_test "[t_of_sexp] error on duplicate" =
   let sexp = Sexplib.Sexp.of_string "((0 a)(1 b)(2 c)(1 d))" in
   (match [%of_sexp: string Map.M(String).t] sexp with
-   | t -> print_cr [%here] [%message "did not raise" (t : string Map.M(String).t)]
+   | t -> print_cr [%message "did not raise" (t : string Map.M(String).t)]
    | exception (Sexp.Of_sexp_error _ as exn) -> print_s (sexp_of_exn exn)
-   | exception exn -> print_cr [%here] [%message "wrong kind of exception" (exn : exn)]);
+   | exception exn -> print_cr [%message "wrong kind of exception" (exn : exn)]);
   [%expect {| (Of_sexp_error "Map.t_of_sexp_direct: duplicate key" (invalid_sexp 1)) |}]
 ;;
 
@@ -108,13 +107,15 @@ let%expect_test "combine_errors" =
   (* singletons *)
   test [ Ok "one" ];
   test [ Error "one" ];
-  [%expect {|
+  [%expect
+    {|
     (Ok ((1 one)))
     (Error ((1 one)))
     |}];
   (* multiple ok *)
   test [ Ok "one"; Ok "two"; Ok "three" ];
-  [%expect {|
+  [%expect
+    {|
     (Ok (
       (1 one)
       (2 two)
@@ -122,7 +123,8 @@ let%expect_test "combine_errors" =
     |}];
   (* multiple errors *)
   test [ Error "one"; Error "two"; Error "three" ];
-  [%expect {|
+  [%expect
+    {|
     (Error (
       (1 one)
       (2 two)
@@ -132,7 +134,8 @@ let%expect_test "combine_errors" =
   test [ Error "one"; Ok "two"; Ok "three" ];
   test [ Ok "one"; Error "two"; Ok "three" ];
   test [ Ok "one"; Ok "two"; Error "three" ];
-  [%expect {|
+  [%expect
+    {|
     (Error ((1 one)))
     (Error ((2 two)))
     (Error ((3 three)))
@@ -231,63 +234,97 @@ let%test_module "[symmetric_diff]" =
         !count - c
       in
       let module Key = struct
-        module T = struct
-          type t = int [@@deriving sexp_of]
+        type t = int [@@deriving sexp_of]
 
-          let compare x y =
-            Int.incr count;
-            compare_int x y
-          ;;
-        end
+        let compare x y =
+          Int.incr count;
+          compare_int x y
+        ;;
 
-        include T
-        include Comparator.Make (T)
+        include (val Comparator.make ~compare ~sexp_of_t)
       end
       in
-      let (_m : unit Map.M(Key).t), map_pairs =
-        List.fold
-          (List.init 1000 ~f:Fn.id)
-          ~init:(Map.empty (module Key), [])
-          ~f:(fun (m, acc) i ->
-            let m' = Map.add_exn m ~key:i ~data:() in
-            m', (m, m') :: acc)
-      in
-      print_s [%sexp (!count : int)];
-      [%expect {| 9_966 |}];
-      count := 0;
-      let diffs = ref 0 in
-      let counts =
-        List.map map_pairs ~f:(fun (m, m') ->
-          measure_comparisons (fun () ->
-            diffs
-              := !diffs
-                 + Map.fold_symmetric_diff
-                     ~init:0
-                     ~f:(fun n _ -> n + 1)
-                     ~data_equal:(fun () () -> true)
-                     (m : unit Map.M(Key).t)
-                     m'))
-      in
-      let worst_counts =
-        List.sort counts ~compare:[%compare: int] |> List.rev |> fun l -> List.take l 20
+      let test size =
+        let map_pairs =
+          (* We measure every step of building up a map from one side. This covers
+             different stages of rebalancing along the way. *)
+          List.folding_map
+            (List.init size ~f:Int.succ)
+            ~init:(Map.singleton (module Key) 0 0)
+            ~f:(fun a i ->
+              let b = Map.add_exn a ~key:i ~data:i in
+              b, (a, b))
+        in
+        let add_comparisons = !count in
+        count := 0;
+        let comparisons =
+          List.map map_pairs ~f:(fun (a, b) ->
+            measure_comparisons (fun () ->
+              Map.fold_symmetric_diff a b ~init:() ~f:(fun () _ -> ()) ~data_equal:( = )))
+          |> List.sort ~compare:Int.compare
+        in
+        let len = List.length comparisons in
+        let diff_comparisons = List.sum (module Int) comparisons ~f:Fn.id in
+        let mean_diff_comparisons = Float.of_int diff_comparisons /. Float.of_int len in
+        let median_diff_comparisons = List.nth_exn comparisons (len / 2) in
+        let diff_comparison_buckets =
+          List.sort_and_group comparisons ~compare:Int.compare
+          |> List.map ~f:(fun list ->
+            [%sexp
+              { comparisons = (List.hd_exn list : int); times = (List.length list : int) }])
+        in
+        print_s
+          [%message
+            ""
+              (size : int)
+              (add_comparisons : int)
+              (diff_comparisons : int)
+              (mean_diff_comparisons : float)
+              (median_diff_comparisons : int)
+              (diff_comparison_buckets : Sexp.t list)]
       in
-      (* The smaller these numbers are, the better. *)
-      print_s [%sexp (!diffs : int), (!count : int)];
-      [%expect {| (1_000 10_955) |}];
-      print_s [%sexp (worst_counts : int list)];
-      [%expect {| (12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12) |}]
+      test (1 lsl 20);
+      [%expect
+        {|
+        ((size                    1_048_576)
+         (add_comparisons         20_971_521)
+         (diff_comparisons        22_020_076)
+         (mean_diff_comparisons   20.999980926513672)
+         (median_diff_comparisons 21)
+         (diff_comparison_buckets (
+           ((comparisons 1)  (times 1))
+           ((comparisons 2)  (times 1))
+           ((comparisons 3)  (times 1))
+           ((comparisons 4)  (times 2))
+           ((comparisons 5)  (times 4))
+           ((comparisons 6)  (times 8))
+           ((comparisons 7)  (times 16))
+           ((comparisons 8)  (times 32))
+           ((comparisons 9)  (times 64))
+           ((comparisons 10) (times 128))
+           ((comparisons 11) (times 256))
+           ((comparisons 12) (times 512))
+           ((comparisons 13) (times 1_024))
+           ((comparisons 14) (times 2_048))
+           ((comparisons 15) (times 4_096))
+           ((comparisons 16) (times 8_192))
+           ((comparisons 17) (times 16_384))
+           ((comparisons 18) (times 32_768))
+           ((comparisons 19) (times 65_536))
+           ((comparisons 20) (times 131_072))
+           ((comparisons 21) (times 262_144))
+           ((comparisons 22) (times 524_287)))))
+        |}]
     ;;
 
     let%expect_test "reconstructing in both directions" =
       let test (map1, map2) =
         let diff = Map.symmetric_diff map1 map2 ~data_equal:Int.equal in
         require_equal
-          [%here]
           (module String_to_int_map)
           (Sequence.fold diff ~init:map1 ~f:apply_diff_left_to_right)
           map2;
         require_equal
-          [%here]
           (module String_to_int_map)
           map1
           (Sequence.fold diff ~init:map2 ~f:apply_diff_right_to_left)
@@ -303,7 +340,6 @@ let%test_module "[symmetric_diff]" =
     let%expect_test "vs [fold_symmetric_diff]" =
       let test (map1, map2) =
         require_compare_equal
-          [%here]
           (module struct
             type t = (string, int) Symmetric_diff_element.t list
             [@@deriving compare, sexp_of]
@@ -358,7 +394,7 @@ let%test_module "of_alist_multi key equality" =
 let%expect_test "remove returns the same object if there's nothing to do" =
   let map1 = Map.of_alist_exn (module Int) [ 1, "one"; 3, "three" ] in
   let map2 = Map.remove map1 2 in
-  require [%here] (phys_equal map1 map2)
+  require (phys_equal map1 map2)
 ;;
 
 let%expect_test "[map_keys]" =
@@ -366,11 +402,12 @@ let%expect_test "[map_keys]" =
     print_s
       [%sexp
         (Map.map_keys c ~f m
-          : [ `Duplicate_key of string | `Ok of string Map.M(String).t ])]
+         : [ `Duplicate_key of string | `Ok of string Map.M(String).t ])]
   in
   let map = Map.of_alist_exn (module Int) [ 1, "one"; 2, "two"; 3, "three" ] in
   test map (module String) ~f:Int.to_string;
-  [%expect {|
+  [%expect
+    {|
     (Ok (
       (1 one)
       (2 two)
@@ -389,7 +426,7 @@ let%expect_test "[fold_until]" =
            ~init:0
            ~f:(fun ~key ~data acc -> if key > 2 then Stop data else Continue (acc + key))
            ~finish:Int.to_string
-          : string)]
+         : string)]
   in
   let map = Map.of_alist_exn (module Int) [ 1, "one"; 2, "two"; 3, "three" ] in
   test map;
@@ -419,7 +456,8 @@ let%expect_test "[merge_disjoint_exn] success" =
   let map1 = Map.of_alist_exn (module Int) [ 1, "one"; 2, "two" ] in
   let map2 = Map.of_alist_exn (module Int) [ 3, "three" ] in
   print_s [%sexp (Map.merge_disjoint_exn map1 map2 : string Map.M(Int).t)];
-  [%expect {|
+  [%expect
+    {|
     ((1 one)
      (2 two)
      (3 three))
diff --git a/test/test_map_and_set_internals.ml b/test/test_map_and_set_internals.ml
new file mode 100644
index 00000000..be3359cd
--- /dev/null
+++ b/test/test_map_and_set_internals.ml
@@ -0,0 +1,1983 @@
+(* In this file we test the binary tree balance invariants used in Set and Map. We rely on
+   the fact that they use the same internal structure and invariants, modulo details
+   unrelated to tree balance. *)
+
+open! Base
+open Expect_test_helpers_base
+
+let print_s sexp =
+  Ref.set_temporarily sexp_style Sexp_style.simple_pretty ~f:(fun () -> print_s sexp)
+;;
+
+module type S = sig
+  type t
+
+  (** Recursively check balance invariantss for [t]. *)
+  val balance_invariants : t -> bool
+
+  (** Trees are balanced enough to be arguments to [create_if_balanced]. *)
+  val are_balanced : t -> t -> bool
+
+  (** Trees are balanced enough to be arguments to [create_if_almost_balanced]. *)
+  val are_almost_balanced : t -> t -> bool
+
+  (** Extracting the structure of trees. *)
+  val expose : t -> (t * t) option
+
+  (** The empty tree. *)
+  val empty : t
+
+  (** Creates a tree without performing any rotations. *)
+  val create_if_balanced : t -> t -> t
+
+  (** Creates a tree, performing O(1) rotations. *)
+  val create_if_almost_balanced : t -> t -> t
+
+  (** Creates a tree, performing O(log n) rotations. *)
+  val create_even_if_completely_unbalanced : t -> t -> t
+end
+
+(* We write one set of expect tests that should behave the same on both sets and maps. *)
+let test (module Tree : S) =
+  let module _ : S = struct
+    type t = Tree.t
+
+    (* Predicates, used in tests below. *)
+
+    let balance_invariants = Tree.balance_invariants
+    let are_balanced = Tree.are_balanced
+    let are_almost_balanced = Tree.are_almost_balanced
+
+    (* Accessor, used in [length] and [sexp_of_t]. *)
+
+    let expose = Tree.expose
+
+    open struct
+      (* Using single-character shorthand tags so that sexps stay on a single line. *)
+      let rec sexp_of_t t =
+        match expose t with
+        | None -> Sexp.Atom "."
+        | Some (l, r) -> Sexp.List [ sexp_of_t l; sexp_of_t r ]
+      ;;
+    end
+
+    (* Constructors, test them. *)
+
+    let empty = Tree.empty
+
+    let%expect_test _ =
+      require (balance_invariants empty);
+      require (are_balanced empty empty);
+      require (are_almost_balanced empty empty)
+    ;;
+
+    open struct
+      (* An enumeration of trees for testing. *)
+      module Trees : sig
+        type t
+
+        val create : max_size:int -> t
+        val iter : t -> size:int -> f:(Tree.t -> unit) -> unit
+      end = struct
+        (* Indexed by size of tree. *)
+        type 'a by_size = { by_size : 'a Queue.t } [@@unboxed]
+
+        (* Enumerates all the ways of balancing for a given size/start. *)
+        type 'a by_balance = { by_balance : 'a Queue.t } [@@unboxed]
+
+        let get_size { by_size } ~size = Queue.get by_size size
+        let iter_by_balance { by_balance } ~f = Queue.iter by_balance ~f
+
+        type t = Tree.t by_balance by_size
+
+        let empty_by_balance = { by_balance = Queue.singleton empty }
+
+        let create_size (t : t) ~size =
+          if size = 0
+          then empty_by_balance
+          else (
+            let q = Queue.create () in
+            let sum = size - 1 in
+            for lsize = 0 to sum do
+              let rsize = sum - lsize in
+              let ls = get_size t ~size:lsize in
+              let rs = get_size t ~size:rsize in
+              iter_by_balance ls ~f:(fun l ->
+                iter_by_balance rs ~f:(fun r ->
+                  if Tree.are_balanced l r
+                  then Queue.enqueue q (Tree.create_if_balanced l r)))
+            done;
+            { by_balance = q })
+        ;;
+
+        let create ~max_size : t =
+          let t = { by_size = Queue.create () } in
+          for size = 0 to max_size do
+            Queue.enqueue t.by_size (create_size t ~size)
+          done;
+          t
+        ;;
+
+        let iter by_size ~size ~f =
+          let by_balance = get_size by_size ~size in
+          iter_by_balance by_balance ~f
+        ;;
+      end
+
+      (* Testing up to size 18 takes ~5 seconds, at least on the box where this was
+         originally tested in 2023-12. Testing more takes ~15 seconds. *)
+      let max_total_size_to_test = 18
+
+      (* Reduce output by skipping cases where either side is an empty tree. *)
+      let min_size_to_show = 1
+
+      (* The smallest size where we see completely-unbalanced pairs and neither side is
+         empty is 9 (8 on one side, 1 on the other). *)
+      let max_total_size_to_show = 9
+
+      (* Cache of pre-computed trees. *)
+      let trees = Trees.create ~max_size:max_total_size_to_test
+
+      (* Call [f] on all pairs of trees up to the given total maximum size. *)
+      let for_all_pairs ~max_total_size f =
+        for total_size = 0 to max_total_size do
+          for lsize = 0 to total_size do
+            let rsize = total_size - lsize in
+            Trees.iter trees ~size:lsize ~f:(fun l ->
+              Trees.iter trees ~size:rsize ~f:(fun r -> f l ~lsize r ~rsize) [@nontail]) [@nontail
+                                                                                          ]
+          done
+        done
+      ;;
+
+      (* Test constructing all triples that are "balanced enough" for [create]. *)
+      let test_all create ~are_balanced_enough ~have_been_shown =
+        let total = ref 0 in
+        let shown = ref 0 in
+        for_all_pairs ~max_total_size:max_total_size_to_test (fun l ~lsize r ~rsize ->
+          if are_balanced_enough l r
+          then (
+            total := !total + 1;
+            let t = create l r in
+            if not (balance_invariants t)
+            then raise_s [%message "invariants failed" ~_:(t : t)];
+            let should_show =
+              lsize + rsize <= max_total_size_to_show
+              && lsize >= min_size_to_show
+              && rsize >= min_size_to_show
+              && not (have_been_shown l r)
+            in
+            if should_show
+            then (
+              print_s [%sexp (lsize : int), (rsize : int), (l : t), (r : t)];
+              shown := !shown + 1)));
+        print_s [%sexp { shown = (!shown : int); total = (!total : int) }]
+      ;;
+    end
+
+    let create_if_balanced = Tree.create_if_balanced
+
+    let%expect_test _ =
+      test_all
+        create_if_balanced
+        ~are_balanced_enough:are_balanced
+        ~have_been_shown:(fun _ _ -> false);
+      [%expect
+        {|
+        (1 1 (. .) (. .))
+        (1 2 (. .) (. (. .)))
+        (1 2 (. .) ((. .) .))
+        (2 1 (. (. .)) (. .))
+        (2 1 ((. .) .) (. .))
+        (1 3 (. .) (. (. (. .))))
+        (1 3 (. .) (. ((. .) .)))
+        (1 3 (. .) ((. .) (. .)))
+        (1 3 (. .) ((. (. .)) .))
+        (1 3 (. .) (((. .) .) .))
+        (2 2 (. (. .)) (. (. .)))
+        (2 2 (. (. .)) ((. .) .))
+        (2 2 ((. .) .) (. (. .)))
+        (2 2 ((. .) .) ((. .) .))
+        (3 1 (. (. (. .))) (. .))
+        (3 1 (. ((. .) .)) (. .))
+        (3 1 ((. .) (. .)) (. .))
+        (3 1 ((. (. .)) .) (. .))
+        (3 1 (((. .) .) .) (. .))
+        (1 4 (. .) (. ((. .) (. .))))
+        (1 4 (. .) ((. .) (. (. .))))
+        (1 4 (. .) ((. .) ((. .) .)))
+        (1 4 (. .) ((. (. .)) (. .)))
+        (1 4 (. .) (((. .) .) (. .)))
+        (1 4 (. .) (((. .) (. .)) .))
+        (2 3 (. (. .)) (. (. (. .))))
+        (2 3 (. (. .)) (. ((. .) .)))
+        (2 3 (. (. .)) ((. .) (. .)))
+        (2 3 (. (. .)) ((. (. .)) .))
+        (2 3 (. (. .)) (((. .) .) .))
+        (2 3 ((. .) .) (. (. (. .))))
+        (2 3 ((. .) .) (. ((. .) .)))
+        (2 3 ((. .) .) ((. .) (. .)))
+        (2 3 ((. .) .) ((. (. .)) .))
+        (2 3 ((. .) .) (((. .) .) .))
+        (3 2 (. (. (. .))) (. (. .)))
+        (3 2 (. (. (. .))) ((. .) .))
+        (3 2 (. ((. .) .)) (. (. .)))
+        (3 2 (. ((. .) .)) ((. .) .))
+        (3 2 ((. .) (. .)) (. (. .)))
+        (3 2 ((. .) (. .)) ((. .) .))
+        (3 2 ((. (. .)) .) (. (. .)))
+        (3 2 ((. (. .)) .) ((. .) .))
+        (3 2 (((. .) .) .) (. (. .)))
+        (3 2 (((. .) .) .) ((. .) .))
+        (4 1 (. ((. .) (. .))) (. .))
+        (4 1 ((. .) (. (. .))) (. .))
+        (4 1 ((. .) ((. .) .)) (. .))
+        (4 1 ((. (. .)) (. .)) (. .))
+        (4 1 (((. .) .) (. .)) (. .))
+        (4 1 (((. .) (. .)) .) (. .))
+        (1 5 (. .) ((. .) ((. .) (. .))))
+        (1 5 (. .) ((. (. .)) (. (. .))))
+        (1 5 (. .) ((. (. .)) ((. .) .)))
+        (1 5 (. .) (((. .) .) (. (. .))))
+        (1 5 (. .) (((. .) .) ((. .) .)))
+        (1 5 (. .) (((. .) (. .)) (. .)))
+        (2 4 (. (. .)) (. ((. .) (. .))))
+        (2 4 (. (. .)) ((. .) (. (. .))))
+        (2 4 (. (. .)) ((. .) ((. .) .)))
+        (2 4 (. (. .)) ((. (. .)) (. .)))
+        (2 4 (. (. .)) (((. .) .) (. .)))
+        (2 4 (. (. .)) (((. .) (. .)) .))
+        (2 4 ((. .) .) (. ((. .) (. .))))
+        (2 4 ((. .) .) ((. .) (. (. .))))
+        (2 4 ((. .) .) ((. .) ((. .) .)))
+        (2 4 ((. .) .) ((. (. .)) (. .)))
+        (2 4 ((. .) .) (((. .) .) (. .)))
+        (2 4 ((. .) .) (((. .) (. .)) .))
+        (3 3 (. (. (. .))) (. (. (. .))))
+        (3 3 (. (. (. .))) (. ((. .) .)))
+        (3 3 (. (. (. .))) ((. .) (. .)))
+        (3 3 (. (. (. .))) ((. (. .)) .))
+        (3 3 (. (. (. .))) (((. .) .) .))
+        (3 3 (. ((. .) .)) (. (. (. .))))
+        (3 3 (. ((. .) .)) (. ((. .) .)))
+        (3 3 (. ((. .) .)) ((. .) (. .)))
+        (3 3 (. ((. .) .)) ((. (. .)) .))
+        (3 3 (. ((. .) .)) (((. .) .) .))
+        (3 3 ((. .) (. .)) (. (. (. .))))
+        (3 3 ((. .) (. .)) (. ((. .) .)))
+        (3 3 ((. .) (. .)) ((. .) (. .)))
+        (3 3 ((. .) (. .)) ((. (. .)) .))
+        (3 3 ((. .) (. .)) (((. .) .) .))
+        (3 3 ((. (. .)) .) (. (. (. .))))
+        (3 3 ((. (. .)) .) (. ((. .) .)))
+        (3 3 ((. (. .)) .) ((. .) (. .)))
+        (3 3 ((. (. .)) .) ((. (. .)) .))
+        (3 3 ((. (. .)) .) (((. .) .) .))
+        (3 3 (((. .) .) .) (. (. (. .))))
+        (3 3 (((. .) .) .) (. ((. .) .)))
+        (3 3 (((. .) .) .) ((. .) (. .)))
+        (3 3 (((. .) .) .) ((. (. .)) .))
+        (3 3 (((. .) .) .) (((. .) .) .))
+        (4 2 (. ((. .) (. .))) (. (. .)))
+        (4 2 (. ((. .) (. .))) ((. .) .))
+        (4 2 ((. .) (. (. .))) (. (. .)))
+        (4 2 ((. .) (. (. .))) ((. .) .))
+        (4 2 ((. .) ((. .) .)) (. (. .)))
+        (4 2 ((. .) ((. .) .)) ((. .) .))
+        (4 2 ((. (. .)) (. .)) (. (. .)))
+        (4 2 ((. (. .)) (. .)) ((. .) .))
+        (4 2 (((. .) .) (. .)) (. (. .)))
+        (4 2 (((. .) .) (. .)) ((. .) .))
+        (4 2 (((. .) (. .)) .) (. (. .)))
+        (4 2 (((. .) (. .)) .) ((. .) .))
+        (5 1 ((. .) ((. .) (. .))) (. .))
+        (5 1 ((. (. .)) (. (. .))) (. .))
+        (5 1 ((. (. .)) ((. .) .)) (. .))
+        (5 1 (((. .) .) (. (. .))) (. .))
+        (5 1 (((. .) .) ((. .) .)) (. .))
+        (5 1 (((. .) (. .)) (. .)) (. .))
+        (1 6 (. .) ((. (. .)) ((. .) (. .))))
+        (1 6 (. .) (((. .) .) ((. .) (. .))))
+        (1 6 (. .) (((. .) (. .)) (. (. .))))
+        (1 6 (. .) (((. .) (. .)) ((. .) .)))
+        (2 5 (. (. .)) ((. .) (. (. (. .)))))
+        (2 5 (. (. .)) ((. .) (. ((. .) .))))
+        (2 5 (. (. .)) ((. .) ((. .) (. .))))
+        (2 5 (. (. .)) ((. .) ((. (. .)) .)))
+        (2 5 (. (. .)) ((. .) (((. .) .) .)))
+        (2 5 (. (. .)) ((. (. .)) (. (. .))))
+        (2 5 (. (. .)) ((. (. .)) ((. .) .)))
+        (2 5 (. (. .)) (((. .) .) (. (. .))))
+        (2 5 (. (. .)) (((. .) .) ((. .) .)))
+        (2 5 (. (. .)) ((. (. (. .))) (. .)))
+        (2 5 (. (. .)) ((. ((. .) .)) (. .)))
+        (2 5 (. (. .)) (((. .) (. .)) (. .)))
+        (2 5 (. (. .)) (((. (. .)) .) (. .)))
+        (2 5 (. (. .)) ((((. .) .) .) (. .)))
+        (2 5 ((. .) .) ((. .) (. (. (. .)))))
+        (2 5 ((. .) .) ((. .) (. ((. .) .))))
+        (2 5 ((. .) .) ((. .) ((. .) (. .))))
+        (2 5 ((. .) .) ((. .) ((. (. .)) .)))
+        (2 5 ((. .) .) ((. .) (((. .) .) .)))
+        (2 5 ((. .) .) ((. (. .)) (. (. .))))
+        (2 5 ((. .) .) ((. (. .)) ((. .) .)))
+        (2 5 ((. .) .) (((. .) .) (. (. .))))
+        (2 5 ((. .) .) (((. .) .) ((. .) .)))
+        (2 5 ((. .) .) ((. (. (. .))) (. .)))
+        (2 5 ((. .) .) ((. ((. .) .)) (. .)))
+        (2 5 ((. .) .) (((. .) (. .)) (. .)))
+        (2 5 ((. .) .) (((. (. .)) .) (. .)))
+        (2 5 ((. .) .) ((((. .) .) .) (. .)))
+        (3 4 (. (. (. .))) (. ((. .) (. .))))
+        (3 4 (. (. (. .))) ((. .) (. (. .))))
+        (3 4 (. (. (. .))) ((. .) ((. .) .)))
+        (3 4 (. (. (. .))) ((. (. .)) (. .)))
+        (3 4 (. (. (. .))) (((. .) .) (. .)))
+        (3 4 (. (. (. .))) (((. .) (. .)) .))
+        (3 4 (. ((. .) .)) (. ((. .) (. .))))
+        (3 4 (. ((. .) .)) ((. .) (. (. .))))
+        (3 4 (. ((. .) .)) ((. .) ((. .) .)))
+        (3 4 (. ((. .) .)) ((. (. .)) (. .)))
+        (3 4 (. ((. .) .)) (((. .) .) (. .)))
+        (3 4 (. ((. .) .)) (((. .) (. .)) .))
+        (3 4 ((. .) (. .)) (. ((. .) (. .))))
+        (3 4 ((. .) (. .)) ((. .) (. (. .))))
+        (3 4 ((. .) (. .)) ((. .) ((. .) .)))
+        (3 4 ((. .) (. .)) ((. (. .)) (. .)))
+        (3 4 ((. .) (. .)) (((. .) .) (. .)))
+        (3 4 ((. .) (. .)) (((. .) (. .)) .))
+        (3 4 ((. (. .)) .) (. ((. .) (. .))))
+        (3 4 ((. (. .)) .) ((. .) (. (. .))))
+        (3 4 ((. (. .)) .) ((. .) ((. .) .)))
+        (3 4 ((. (. .)) .) ((. (. .)) (. .)))
+        (3 4 ((. (. .)) .) (((. .) .) (. .)))
+        (3 4 ((. (. .)) .) (((. .) (. .)) .))
+        (3 4 (((. .) .) .) (. ((. .) (. .))))
+        (3 4 (((. .) .) .) ((. .) (. (. .))))
+        (3 4 (((. .) .) .) ((. .) ((. .) .)))
+        (3 4 (((. .) .) .) ((. (. .)) (. .)))
+        (3 4 (((. .) .) .) (((. .) .) (. .)))
+        (3 4 (((. .) .) .) (((. .) (. .)) .))
+        (4 3 (. ((. .) (. .))) (. (. (. .))))
+        (4 3 (. ((. .) (. .))) (. ((. .) .)))
+        (4 3 (. ((. .) (. .))) ((. .) (. .)))
+        (4 3 (. ((. .) (. .))) ((. (. .)) .))
+        (4 3 (. ((. .) (. .))) (((. .) .) .))
+        (4 3 ((. .) (. (. .))) (. (. (. .))))
+        (4 3 ((. .) (. (. .))) (. ((. .) .)))
+        (4 3 ((. .) (. (. .))) ((. .) (. .)))
+        (4 3 ((. .) (. (. .))) ((. (. .)) .))
+        (4 3 ((. .) (. (. .))) (((. .) .) .))
+        (4 3 ((. .) ((. .) .)) (. (. (. .))))
+        (4 3 ((. .) ((. .) .)) (. ((. .) .)))
+        (4 3 ((. .) ((. .) .)) ((. .) (. .)))
+        (4 3 ((. .) ((. .) .)) ((. (. .)) .))
+        (4 3 ((. .) ((. .) .)) (((. .) .) .))
+        (4 3 ((. (. .)) (. .)) (. (. (. .))))
+        (4 3 ((. (. .)) (. .)) (. ((. .) .)))
+        (4 3 ((. (. .)) (. .)) ((. .) (. .)))
+        (4 3 ((. (. .)) (. .)) ((. (. .)) .))
+        (4 3 ((. (. .)) (. .)) (((. .) .) .))
+        (4 3 (((. .) .) (. .)) (. (. (. .))))
+        (4 3 (((. .) .) (. .)) (. ((. .) .)))
+        (4 3 (((. .) .) (. .)) ((. .) (. .)))
+        (4 3 (((. .) .) (. .)) ((. (. .)) .))
+        (4 3 (((. .) .) (. .)) (((. .) .) .))
+        (4 3 (((. .) (. .)) .) (. (. (. .))))
+        (4 3 (((. .) (. .)) .) (. ((. .) .)))
+        (4 3 (((. .) (. .)) .) ((. .) (. .)))
+        (4 3 (((. .) (. .)) .) ((. (. .)) .))
+        (4 3 (((. .) (. .)) .) (((. .) .) .))
+        (5 2 ((. .) (. (. (. .)))) (. (. .)))
+        (5 2 ((. .) (. (. (. .)))) ((. .) .))
+        (5 2 ((. .) (. ((. .) .))) (. (. .)))
+        (5 2 ((. .) (. ((. .) .))) ((. .) .))
+        (5 2 ((. .) ((. .) (. .))) (. (. .)))
+        (5 2 ((. .) ((. .) (. .))) ((. .) .))
+        (5 2 ((. .) ((. (. .)) .)) (. (. .)))
+        (5 2 ((. .) ((. (. .)) .)) ((. .) .))
+        (5 2 ((. .) (((. .) .) .)) (. (. .)))
+        (5 2 ((. .) (((. .) .) .)) ((. .) .))
+        (5 2 ((. (. .)) (. (. .))) (. (. .)))
+        (5 2 ((. (. .)) (. (. .))) ((. .) .))
+        (5 2 ((. (. .)) ((. .) .)) (. (. .)))
+        (5 2 ((. (. .)) ((. .) .)) ((. .) .))
+        (5 2 (((. .) .) (. (. .))) (. (. .)))
+        (5 2 (((. .) .) (. (. .))) ((. .) .))
+        (5 2 (((. .) .) ((. .) .)) (. (. .)))
+        (5 2 (((. .) .) ((. .) .)) ((. .) .))
+        (5 2 ((. (. (. .))) (. .)) (. (. .)))
+        (5 2 ((. (. (. .))) (. .)) ((. .) .))
+        (5 2 ((. ((. .) .)) (. .)) (. (. .)))
+        (5 2 ((. ((. .) .)) (. .)) ((. .) .))
+        (5 2 (((. .) (. .)) (. .)) (. (. .)))
+        (5 2 (((. .) (. .)) (. .)) ((. .) .))
+        (5 2 (((. (. .)) .) (. .)) (. (. .)))
+        (5 2 (((. (. .)) .) (. .)) ((. .) .))
+        (5 2 ((((. .) .) .) (. .)) (. (. .)))
+        (5 2 ((((. .) .) .) (. .)) ((. .) .))
+        (6 1 ((. (. .)) ((. .) (. .))) (. .))
+        (6 1 (((. .) .) ((. .) (. .))) (. .))
+        (6 1 (((. .) (. .)) (. (. .))) (. .))
+        (6 1 (((. .) (. .)) ((. .) .)) (. .))
+        (1 7 (. .) (((. .) (. .)) ((. .) (. .))))
+        (2 6 (. (. .)) ((. .) (. ((. .) (. .)))))
+        (2 6 (. (. .)) ((. .) ((. .) (. (. .)))))
+        (2 6 (. (. .)) ((. .) ((. .) ((. .) .))))
+        (2 6 (. (. .)) ((. .) ((. (. .)) (. .))))
+        (2 6 (. (. .)) ((. .) (((. .) .) (. .))))
+        (2 6 (. (. .)) ((. .) (((. .) (. .)) .)))
+        (2 6 (. (. .)) ((. (. .)) (. (. (. .)))))
+        (2 6 (. (. .)) ((. (. .)) (. ((. .) .))))
+        (2 6 (. (. .)) ((. (. .)) ((. .) (. .))))
+        (2 6 (. (. .)) ((. (. .)) ((. (. .)) .)))
+        (2 6 (. (. .)) ((. (. .)) (((. .) .) .)))
+        (2 6 (. (. .)) (((. .) .) (. (. (. .)))))
+        (2 6 (. (. .)) (((. .) .) (. ((. .) .))))
+        (2 6 (. (. .)) (((. .) .) ((. .) (. .))))
+        (2 6 (. (. .)) (((. .) .) ((. (. .)) .)))
+        (2 6 (. (. .)) (((. .) .) (((. .) .) .)))
+        (2 6 (. (. .)) ((. (. (. .))) (. (. .))))
+        (2 6 (. (. .)) ((. (. (. .))) ((. .) .)))
+        (2 6 (. (. .)) ((. ((. .) .)) (. (. .))))
+        (2 6 (. (. .)) ((. ((. .) .)) ((. .) .)))
+        (2 6 (. (. .)) (((. .) (. .)) (. (. .))))
+        (2 6 (. (. .)) (((. .) (. .)) ((. .) .)))
+        (2 6 (. (. .)) (((. (. .)) .) (. (. .))))
+        (2 6 (. (. .)) (((. (. .)) .) ((. .) .)))
+        (2 6 (. (. .)) ((((. .) .) .) (. (. .))))
+        (2 6 (. (. .)) ((((. .) .) .) ((. .) .)))
+        (2 6 (. (. .)) ((. ((. .) (. .))) (. .)))
+        (2 6 (. (. .)) (((. .) (. (. .))) (. .)))
+        (2 6 (. (. .)) (((. .) ((. .) .)) (. .)))
+        (2 6 (. (. .)) (((. (. .)) (. .)) (. .)))
+        (2 6 (. (. .)) ((((. .) .) (. .)) (. .)))
+        (2 6 (. (. .)) ((((. .) (. .)) .) (. .)))
+        (2 6 ((. .) .) ((. .) (. ((. .) (. .)))))
+        (2 6 ((. .) .) ((. .) ((. .) (. (. .)))))
+        (2 6 ((. .) .) ((. .) ((. .) ((. .) .))))
+        (2 6 ((. .) .) ((. .) ((. (. .)) (. .))))
+        (2 6 ((. .) .) ((. .) (((. .) .) (. .))))
+        (2 6 ((. .) .) ((. .) (((. .) (. .)) .)))
+        (2 6 ((. .) .) ((. (. .)) (. (. (. .)))))
+        (2 6 ((. .) .) ((. (. .)) (. ((. .) .))))
+        (2 6 ((. .) .) ((. (. .)) ((. .) (. .))))
+        (2 6 ((. .) .) ((. (. .)) ((. (. .)) .)))
+        (2 6 ((. .) .) ((. (. .)) (((. .) .) .)))
+        (2 6 ((. .) .) (((. .) .) (. (. (. .)))))
+        (2 6 ((. .) .) (((. .) .) (. ((. .) .))))
+        (2 6 ((. .) .) (((. .) .) ((. .) (. .))))
+        (2 6 ((. .) .) (((. .) .) ((. (. .)) .)))
+        (2 6 ((. .) .) (((. .) .) (((. .) .) .)))
+        (2 6 ((. .) .) ((. (. (. .))) (. (. .))))
+        (2 6 ((. .) .) ((. (. (. .))) ((. .) .)))
+        (2 6 ((. .) .) ((. ((. .) .)) (. (. .))))
+        (2 6 ((. .) .) ((. ((. .) .)) ((. .) .)))
+        (2 6 ((. .) .) (((. .) (. .)) (. (. .))))
+        (2 6 ((. .) .) (((. .) (. .)) ((. .) .)))
+        (2 6 ((. .) .) (((. (. .)) .) (. (. .))))
+        (2 6 ((. .) .) (((. (. .)) .) ((. .) .)))
+        (2 6 ((. .) .) ((((. .) .) .) (. (. .))))
+        (2 6 ((. .) .) ((((. .) .) .) ((. .) .)))
+        (2 6 ((. .) .) ((. ((. .) (. .))) (. .)))
+        (2 6 ((. .) .) (((. .) (. (. .))) (. .)))
+        (2 6 ((. .) .) (((. .) ((. .) .)) (. .)))
+        (2 6 ((. .) .) (((. (. .)) (. .)) (. .)))
+        (2 6 ((. .) .) ((((. .) .) (. .)) (. .)))
+        (2 6 ((. .) .) ((((. .) (. .)) .) (. .)))
+        (3 5 (. (. (. .))) ((. .) (. (. (. .)))))
+        (3 5 (. (. (. .))) ((. .) (. ((. .) .))))
+        (3 5 (. (. (. .))) ((. .) ((. .) (. .))))
+        (3 5 (. (. (. .))) ((. .) ((. (. .)) .)))
+        (3 5 (. (. (. .))) ((. .) (((. .) .) .)))
+        (3 5 (. (. (. .))) ((. (. .)) (. (. .))))
+        (3 5 (. (. (. .))) ((. (. .)) ((. .) .)))
+        (3 5 (. (. (. .))) (((. .) .) (. (. .))))
+        (3 5 (. (. (. .))) (((. .) .) ((. .) .)))
+        (3 5 (. (. (. .))) ((. (. (. .))) (. .)))
+        (3 5 (. (. (. .))) ((. ((. .) .)) (. .)))
+        (3 5 (. (. (. .))) (((. .) (. .)) (. .)))
+        (3 5 (. (. (. .))) (((. (. .)) .) (. .)))
+        (3 5 (. (. (. .))) ((((. .) .) .) (. .)))
+        (3 5 (. ((. .) .)) ((. .) (. (. (. .)))))
+        (3 5 (. ((. .) .)) ((. .) (. ((. .) .))))
+        (3 5 (. ((. .) .)) ((. .) ((. .) (. .))))
+        (3 5 (. ((. .) .)) ((. .) ((. (. .)) .)))
+        (3 5 (. ((. .) .)) ((. .) (((. .) .) .)))
+        (3 5 (. ((. .) .)) ((. (. .)) (. (. .))))
+        (3 5 (. ((. .) .)) ((. (. .)) ((. .) .)))
+        (3 5 (. ((. .) .)) (((. .) .) (. (. .))))
+        (3 5 (. ((. .) .)) (((. .) .) ((. .) .)))
+        (3 5 (. ((. .) .)) ((. (. (. .))) (. .)))
+        (3 5 (. ((. .) .)) ((. ((. .) .)) (. .)))
+        (3 5 (. ((. .) .)) (((. .) (. .)) (. .)))
+        (3 5 (. ((. .) .)) (((. (. .)) .) (. .)))
+        (3 5 (. ((. .) .)) ((((. .) .) .) (. .)))
+        (3 5 ((. .) (. .)) ((. .) (. (. (. .)))))
+        (3 5 ((. .) (. .)) ((. .) (. ((. .) .))))
+        (3 5 ((. .) (. .)) ((. .) ((. .) (. .))))
+        (3 5 ((. .) (. .)) ((. .) ((. (. .)) .)))
+        (3 5 ((. .) (. .)) ((. .) (((. .) .) .)))
+        (3 5 ((. .) (. .)) ((. (. .)) (. (. .))))
+        (3 5 ((. .) (. .)) ((. (. .)) ((. .) .)))
+        (3 5 ((. .) (. .)) (((. .) .) (. (. .))))
+        (3 5 ((. .) (. .)) (((. .) .) ((. .) .)))
+        (3 5 ((. .) (. .)) ((. (. (. .))) (. .)))
+        (3 5 ((. .) (. .)) ((. ((. .) .)) (. .)))
+        (3 5 ((. .) (. .)) (((. .) (. .)) (. .)))
+        (3 5 ((. .) (. .)) (((. (. .)) .) (. .)))
+        (3 5 ((. .) (. .)) ((((. .) .) .) (. .)))
+        (3 5 ((. (. .)) .) ((. .) (. (. (. .)))))
+        (3 5 ((. (. .)) .) ((. .) (. ((. .) .))))
+        (3 5 ((. (. .)) .) ((. .) ((. .) (. .))))
+        (3 5 ((. (. .)) .) ((. .) ((. (. .)) .)))
+        (3 5 ((. (. .)) .) ((. .) (((. .) .) .)))
+        (3 5 ((. (. .)) .) ((. (. .)) (. (. .))))
+        (3 5 ((. (. .)) .) ((. (. .)) ((. .) .)))
+        (3 5 ((. (. .)) .) (((. .) .) (. (. .))))
+        (3 5 ((. (. .)) .) (((. .) .) ((. .) .)))
+        (3 5 ((. (. .)) .) ((. (. (. .))) (. .)))
+        (3 5 ((. (. .)) .) ((. ((. .) .)) (. .)))
+        (3 5 ((. (. .)) .) (((. .) (. .)) (. .)))
+        (3 5 ((. (. .)) .) (((. (. .)) .) (. .)))
+        (3 5 ((. (. .)) .) ((((. .) .) .) (. .)))
+        (3 5 (((. .) .) .) ((. .) (. (. (. .)))))
+        (3 5 (((. .) .) .) ((. .) (. ((. .) .))))
+        (3 5 (((. .) .) .) ((. .) ((. .) (. .))))
+        (3 5 (((. .) .) .) ((. .) ((. (. .)) .)))
+        (3 5 (((. .) .) .) ((. .) (((. .) .) .)))
+        (3 5 (((. .) .) .) ((. (. .)) (. (. .))))
+        (3 5 (((. .) .) .) ((. (. .)) ((. .) .)))
+        (3 5 (((. .) .) .) (((. .) .) (. (. .))))
+        (3 5 (((. .) .) .) (((. .) .) ((. .) .)))
+        (3 5 (((. .) .) .) ((. (. (. .))) (. .)))
+        (3 5 (((. .) .) .) ((. ((. .) .)) (. .)))
+        (3 5 (((. .) .) .) (((. .) (. .)) (. .)))
+        (3 5 (((. .) .) .) (((. (. .)) .) (. .)))
+        (3 5 (((. .) .) .) ((((. .) .) .) (. .)))
+        (4 4 (. ((. .) (. .))) (. ((. .) (. .))))
+        (4 4 (. ((. .) (. .))) ((. .) (. (. .))))
+        (4 4 (. ((. .) (. .))) ((. .) ((. .) .)))
+        (4 4 (. ((. .) (. .))) ((. (. .)) (. .)))
+        (4 4 (. ((. .) (. .))) (((. .) .) (. .)))
+        (4 4 (. ((. .) (. .))) (((. .) (. .)) .))
+        (4 4 ((. .) (. (. .))) (. ((. .) (. .))))
+        (4 4 ((. .) (. (. .))) ((. .) (. (. .))))
+        (4 4 ((. .) (. (. .))) ((. .) ((. .) .)))
+        (4 4 ((. .) (. (. .))) ((. (. .)) (. .)))
+        (4 4 ((. .) (. (. .))) (((. .) .) (. .)))
+        (4 4 ((. .) (. (. .))) (((. .) (. .)) .))
+        (4 4 ((. .) ((. .) .)) (. ((. .) (. .))))
+        (4 4 ((. .) ((. .) .)) ((. .) (. (. .))))
+        (4 4 ((. .) ((. .) .)) ((. .) ((. .) .)))
+        (4 4 ((. .) ((. .) .)) ((. (. .)) (. .)))
+        (4 4 ((. .) ((. .) .)) (((. .) .) (. .)))
+        (4 4 ((. .) ((. .) .)) (((. .) (. .)) .))
+        (4 4 ((. (. .)) (. .)) (. ((. .) (. .))))
+        (4 4 ((. (. .)) (. .)) ((. .) (. (. .))))
+        (4 4 ((. (. .)) (. .)) ((. .) ((. .) .)))
+        (4 4 ((. (. .)) (. .)) ((. (. .)) (. .)))
+        (4 4 ((. (. .)) (. .)) (((. .) .) (. .)))
+        (4 4 ((. (. .)) (. .)) (((. .) (. .)) .))
+        (4 4 (((. .) .) (. .)) (. ((. .) (. .))))
+        (4 4 (((. .) .) (. .)) ((. .) (. (. .))))
+        (4 4 (((. .) .) (. .)) ((. .) ((. .) .)))
+        (4 4 (((. .) .) (. .)) ((. (. .)) (. .)))
+        (4 4 (((. .) .) (. .)) (((. .) .) (. .)))
+        (4 4 (((. .) .) (. .)) (((. .) (. .)) .))
+        (4 4 (((. .) (. .)) .) (. ((. .) (. .))))
+        (4 4 (((. .) (. .)) .) ((. .) (. (. .))))
+        (4 4 (((. .) (. .)) .) ((. .) ((. .) .)))
+        (4 4 (((. .) (. .)) .) ((. (. .)) (. .)))
+        (4 4 (((. .) (. .)) .) (((. .) .) (. .)))
+        (4 4 (((. .) (. .)) .) (((. .) (. .)) .))
+        (5 3 ((. .) (. (. (. .)))) (. (. (. .))))
+        (5 3 ((. .) (. (. (. .)))) (. ((. .) .)))
+        (5 3 ((. .) (. (. (. .)))) ((. .) (. .)))
+        (5 3 ((. .) (. (. (. .)))) ((. (. .)) .))
+        (5 3 ((. .) (. (. (. .)))) (((. .) .) .))
+        (5 3 ((. .) (. ((. .) .))) (. (. (. .))))
+        (5 3 ((. .) (. ((. .) .))) (. ((. .) .)))
+        (5 3 ((. .) (. ((. .) .))) ((. .) (. .)))
+        (5 3 ((. .) (. ((. .) .))) ((. (. .)) .))
+        (5 3 ((. .) (. ((. .) .))) (((. .) .) .))
+        (5 3 ((. .) ((. .) (. .))) (. (. (. .))))
+        (5 3 ((. .) ((. .) (. .))) (. ((. .) .)))
+        (5 3 ((. .) ((. .) (. .))) ((. .) (. .)))
+        (5 3 ((. .) ((. .) (. .))) ((. (. .)) .))
+        (5 3 ((. .) ((. .) (. .))) (((. .) .) .))
+        (5 3 ((. .) ((. (. .)) .)) (. (. (. .))))
+        (5 3 ((. .) ((. (. .)) .)) (. ((. .) .)))
+        (5 3 ((. .) ((. (. .)) .)) ((. .) (. .)))
+        (5 3 ((. .) ((. (. .)) .)) ((. (. .)) .))
+        (5 3 ((. .) ((. (. .)) .)) (((. .) .) .))
+        (5 3 ((. .) (((. .) .) .)) (. (. (. .))))
+        (5 3 ((. .) (((. .) .) .)) (. ((. .) .)))
+        (5 3 ((. .) (((. .) .) .)) ((. .) (. .)))
+        (5 3 ((. .) (((. .) .) .)) ((. (. .)) .))
+        (5 3 ((. .) (((. .) .) .)) (((. .) .) .))
+        (5 3 ((. (. .)) (. (. .))) (. (. (. .))))
+        (5 3 ((. (. .)) (. (. .))) (. ((. .) .)))
+        (5 3 ((. (. .)) (. (. .))) ((. .) (. .)))
+        (5 3 ((. (. .)) (. (. .))) ((. (. .)) .))
+        (5 3 ((. (. .)) (. (. .))) (((. .) .) .))
+        (5 3 ((. (. .)) ((. .) .)) (. (. (. .))))
+        (5 3 ((. (. .)) ((. .) .)) (. ((. .) .)))
+        (5 3 ((. (. .)) ((. .) .)) ((. .) (. .)))
+        (5 3 ((. (. .)) ((. .) .)) ((. (. .)) .))
+        (5 3 ((. (. .)) ((. .) .)) (((. .) .) .))
+        (5 3 (((. .) .) (. (. .))) (. (. (. .))))
+        (5 3 (((. .) .) (. (. .))) (. ((. .) .)))
+        (5 3 (((. .) .) (. (. .))) ((. .) (. .)))
+        (5 3 (((. .) .) (. (. .))) ((. (. .)) .))
+        (5 3 (((. .) .) (. (. .))) (((. .) .) .))
+        (5 3 (((. .) .) ((. .) .)) (. (. (. .))))
+        (5 3 (((. .) .) ((. .) .)) (. ((. .) .)))
+        (5 3 (((. .) .) ((. .) .)) ((. .) (. .)))
+        (5 3 (((. .) .) ((. .) .)) ((. (. .)) .))
+        (5 3 (((. .) .) ((. .) .)) (((. .) .) .))
+        (5 3 ((. (. (. .))) (. .)) (. (. (. .))))
+        (5 3 ((. (. (. .))) (. .)) (. ((. .) .)))
+        (5 3 ((. (. (. .))) (. .)) ((. .) (. .)))
+        (5 3 ((. (. (. .))) (. .)) ((. (. .)) .))
+        (5 3 ((. (. (. .))) (. .)) (((. .) .) .))
+        (5 3 ((. ((. .) .)) (. .)) (. (. (. .))))
+        (5 3 ((. ((. .) .)) (. .)) (. ((. .) .)))
+        (5 3 ((. ((. .) .)) (. .)) ((. .) (. .)))
+        (5 3 ((. ((. .) .)) (. .)) ((. (. .)) .))
+        (5 3 ((. ((. .) .)) (. .)) (((. .) .) .))
+        (5 3 (((. .) (. .)) (. .)) (. (. (. .))))
+        (5 3 (((. .) (. .)) (. .)) (. ((. .) .)))
+        (5 3 (((. .) (. .)) (. .)) ((. .) (. .)))
+        (5 3 (((. .) (. .)) (. .)) ((. (. .)) .))
+        (5 3 (((. .) (. .)) (. .)) (((. .) .) .))
+        (5 3 (((. (. .)) .) (. .)) (. (. (. .))))
+        (5 3 (((. (. .)) .) (. .)) (. ((. .) .)))
+        (5 3 (((. (. .)) .) (. .)) ((. .) (. .)))
+        (5 3 (((. (. .)) .) (. .)) ((. (. .)) .))
+        (5 3 (((. (. .)) .) (. .)) (((. .) .) .))
+        (5 3 ((((. .) .) .) (. .)) (. (. (. .))))
+        (5 3 ((((. .) .) .) (. .)) (. ((. .) .)))
+        (5 3 ((((. .) .) .) (. .)) ((. .) (. .)))
+        (5 3 ((((. .) .) .) (. .)) ((. (. .)) .))
+        (5 3 ((((. .) .) .) (. .)) (((. .) .) .))
+        (6 2 ((. .) (. ((. .) (. .)))) (. (. .)))
+        (6 2 ((. .) (. ((. .) (. .)))) ((. .) .))
+        (6 2 ((. .) ((. .) (. (. .)))) (. (. .)))
+        (6 2 ((. .) ((. .) (. (. .)))) ((. .) .))
+        (6 2 ((. .) ((. .) ((. .) .))) (. (. .)))
+        (6 2 ((. .) ((. .) ((. .) .))) ((. .) .))
+        (6 2 ((. .) ((. (. .)) (. .))) (. (. .)))
+        (6 2 ((. .) ((. (. .)) (. .))) ((. .) .))
+        (6 2 ((. .) (((. .) .) (. .))) (. (. .)))
+        (6 2 ((. .) (((. .) .) (. .))) ((. .) .))
+        (6 2 ((. .) (((. .) (. .)) .)) (. (. .)))
+        (6 2 ((. .) (((. .) (. .)) .)) ((. .) .))
+        (6 2 ((. (. .)) (. (. (. .)))) (. (. .)))
+        (6 2 ((. (. .)) (. (. (. .)))) ((. .) .))
+        (6 2 ((. (. .)) (. ((. .) .))) (. (. .)))
+        (6 2 ((. (. .)) (. ((. .) .))) ((. .) .))
+        (6 2 ((. (. .)) ((. .) (. .))) (. (. .)))
+        (6 2 ((. (. .)) ((. .) (. .))) ((. .) .))
+        (6 2 ((. (. .)) ((. (. .)) .)) (. (. .)))
+        (6 2 ((. (. .)) ((. (. .)) .)) ((. .) .))
+        (6 2 ((. (. .)) (((. .) .) .)) (. (. .)))
+        (6 2 ((. (. .)) (((. .) .) .)) ((. .) .))
+        (6 2 (((. .) .) (. (. (. .)))) (. (. .)))
+        (6 2 (((. .) .) (. (. (. .)))) ((. .) .))
+        (6 2 (((. .) .) (. ((. .) .))) (. (. .)))
+        (6 2 (((. .) .) (. ((. .) .))) ((. .) .))
+        (6 2 (((. .) .) ((. .) (. .))) (. (. .)))
+        (6 2 (((. .) .) ((. .) (. .))) ((. .) .))
+        (6 2 (((. .) .) ((. (. .)) .)) (. (. .)))
+        (6 2 (((. .) .) ((. (. .)) .)) ((. .) .))
+        (6 2 (((. .) .) (((. .) .) .)) (. (. .)))
+        (6 2 (((. .) .) (((. .) .) .)) ((. .) .))
+        (6 2 ((. (. (. .))) (. (. .))) (. (. .)))
+        (6 2 ((. (. (. .))) (. (. .))) ((. .) .))
+        (6 2 ((. (. (. .))) ((. .) .)) (. (. .)))
+        (6 2 ((. (. (. .))) ((. .) .)) ((. .) .))
+        (6 2 ((. ((. .) .)) (. (. .))) (. (. .)))
+        (6 2 ((. ((. .) .)) (. (. .))) ((. .) .))
+        (6 2 ((. ((. .) .)) ((. .) .)) (. (. .)))
+        (6 2 ((. ((. .) .)) ((. .) .)) ((. .) .))
+        (6 2 (((. .) (. .)) (. (. .))) (. (. .)))
+        (6 2 (((. .) (. .)) (. (. .))) ((. .) .))
+        (6 2 (((. .) (. .)) ((. .) .)) (. (. .)))
+        (6 2 (((. .) (. .)) ((. .) .)) ((. .) .))
+        (6 2 (((. (. .)) .) (. (. .))) (. (. .)))
+        (6 2 (((. (. .)) .) (. (. .))) ((. .) .))
+        (6 2 (((. (. .)) .) ((. .) .)) (. (. .)))
+        (6 2 (((. (. .)) .) ((. .) .)) ((. .) .))
+        (6 2 ((((. .) .) .) (. (. .))) (. (. .)))
+        (6 2 ((((. .) .) .) (. (. .))) ((. .) .))
+        (6 2 ((((. .) .) .) ((. .) .)) (. (. .)))
+        (6 2 ((((. .) .) .) ((. .) .)) ((. .) .))
+        (6 2 ((. ((. .) (. .))) (. .)) (. (. .)))
+        (6 2 ((. ((. .) (. .))) (. .)) ((. .) .))
+        (6 2 (((. .) (. (. .))) (. .)) (. (. .)))
+        (6 2 (((. .) (. (. .))) (. .)) ((. .) .))
+        (6 2 (((. .) ((. .) .)) (. .)) (. (. .)))
+        (6 2 (((. .) ((. .) .)) (. .)) ((. .) .))
+        (6 2 (((. (. .)) (. .)) (. .)) (. (. .)))
+        (6 2 (((. (. .)) (. .)) (. .)) ((. .) .))
+        (6 2 ((((. .) .) (. .)) (. .)) (. (. .)))
+        (6 2 ((((. .) .) (. .)) (. .)) ((. .) .))
+        (6 2 ((((. .) (. .)) .) (. .)) (. (. .)))
+        (6 2 ((((. .) (. .)) .) (. .)) ((. .) .))
+        (7 1 (((. .) (. .)) ((. .) (. .))) (. .))
+        (2 7 (. (. .)) ((. .) ((. .) ((. .) (. .)))))
+        (2 7 (. (. .)) ((. .) ((. (. .)) (. (. .)))))
+        (2 7 (. (. .)) ((. .) ((. (. .)) ((. .) .))))
+        (2 7 (. (. .)) ((. .) (((. .) .) (. (. .)))))
+        (2 7 (. (. .)) ((. .) (((. .) .) ((. .) .))))
+        (2 7 (. (. .)) ((. .) (((. .) (. .)) (. .))))
+        (2 7 (. (. .)) ((. (. .)) (. ((. .) (. .)))))
+        (2 7 (. (. .)) ((. (. .)) ((. .) (. (. .)))))
+        (2 7 (. (. .)) ((. (. .)) ((. .) ((. .) .))))
+        (2 7 (. (. .)) ((. (. .)) ((. (. .)) (. .))))
+        (2 7 (. (. .)) ((. (. .)) (((. .) .) (. .))))
+        (2 7 (. (. .)) ((. (. .)) (((. .) (. .)) .)))
+        (2 7 (. (. .)) (((. .) .) (. ((. .) (. .)))))
+        (2 7 (. (. .)) (((. .) .) ((. .) (. (. .)))))
+        (2 7 (. (. .)) (((. .) .) ((. .) ((. .) .))))
+        (2 7 (. (. .)) (((. .) .) ((. (. .)) (. .))))
+        (2 7 (. (. .)) (((. .) .) (((. .) .) (. .))))
+        (2 7 (. (. .)) (((. .) .) (((. .) (. .)) .)))
+        (2 7 (. (. .)) ((. (. (. .))) (. (. (. .)))))
+        (2 7 (. (. .)) ((. (. (. .))) (. ((. .) .))))
+        (2 7 (. (. .)) ((. (. (. .))) ((. .) (. .))))
+        (2 7 (. (. .)) ((. (. (. .))) ((. (. .)) .)))
+        (2 7 (. (. .)) ((. (. (. .))) (((. .) .) .)))
+        (2 7 (. (. .)) ((. ((. .) .)) (. (. (. .)))))
+        (2 7 (. (. .)) ((. ((. .) .)) (. ((. .) .))))
+        (2 7 (. (. .)) ((. ((. .) .)) ((. .) (. .))))
+        (2 7 (. (. .)) ((. ((. .) .)) ((. (. .)) .)))
+        (2 7 (. (. .)) ((. ((. .) .)) (((. .) .) .)))
+        (2 7 (. (. .)) (((. .) (. .)) (. (. (. .)))))
+        (2 7 (. (. .)) (((. .) (. .)) (. ((. .) .))))
+        (2 7 (. (. .)) (((. .) (. .)) ((. .) (. .))))
+        (2 7 (. (. .)) (((. .) (. .)) ((. (. .)) .)))
+        (2 7 (. (. .)) (((. .) (. .)) (((. .) .) .)))
+        (2 7 (. (. .)) (((. (. .)) .) (. (. (. .)))))
+        (2 7 (. (. .)) (((. (. .)) .) (. ((. .) .))))
+        (2 7 (. (. .)) (((. (. .)) .) ((. .) (. .))))
+        (2 7 (. (. .)) (((. (. .)) .) ((. (. .)) .)))
+        (2 7 (. (. .)) (((. (. .)) .) (((. .) .) .)))
+        (2 7 (. (. .)) ((((. .) .) .) (. (. (. .)))))
+        (2 7 (. (. .)) ((((. .) .) .) (. ((. .) .))))
+        (2 7 (. (. .)) ((((. .) .) .) ((. .) (. .))))
+        (2 7 (. (. .)) ((((. .) .) .) ((. (. .)) .)))
+        (2 7 (. (. .)) ((((. .) .) .) (((. .) .) .)))
+        (2 7 (. (. .)) ((. ((. .) (. .))) (. (. .))))
+        (2 7 (. (. .)) ((. ((. .) (. .))) ((. .) .)))
+        (2 7 (. (. .)) (((. .) (. (. .))) (. (. .))))
+        (2 7 (. (. .)) (((. .) (. (. .))) ((. .) .)))
+        (2 7 (. (. .)) (((. .) ((. .) .)) (. (. .))))
+        (2 7 (. (. .)) (((. .) ((. .) .)) ((. .) .)))
+        (2 7 (. (. .)) (((. (. .)) (. .)) (. (. .))))
+        (2 7 (. (. .)) (((. (. .)) (. .)) ((. .) .)))
+        (2 7 (. (. .)) ((((. .) .) (. .)) (. (. .))))
+        (2 7 (. (. .)) ((((. .) .) (. .)) ((. .) .)))
+        (2 7 (. (. .)) ((((. .) (. .)) .) (. (. .))))
+        (2 7 (. (. .)) ((((. .) (. .)) .) ((. .) .)))
+        (2 7 (. (. .)) (((. .) ((. .) (. .))) (. .)))
+        (2 7 (. (. .)) (((. (. .)) (. (. .))) (. .)))
+        (2 7 (. (. .)) (((. (. .)) ((. .) .)) (. .)))
+        (2 7 (. (. .)) ((((. .) .) (. (. .))) (. .)))
+        (2 7 (. (. .)) ((((. .) .) ((. .) .)) (. .)))
+        (2 7 (. (. .)) ((((. .) (. .)) (. .)) (. .)))
+        (2 7 ((. .) .) ((. .) ((. .) ((. .) (. .)))))
+        (2 7 ((. .) .) ((. .) ((. (. .)) (. (. .)))))
+        (2 7 ((. .) .) ((. .) ((. (. .)) ((. .) .))))
+        (2 7 ((. .) .) ((. .) (((. .) .) (. (. .)))))
+        (2 7 ((. .) .) ((. .) (((. .) .) ((. .) .))))
+        (2 7 ((. .) .) ((. .) (((. .) (. .)) (. .))))
+        (2 7 ((. .) .) ((. (. .)) (. ((. .) (. .)))))
+        (2 7 ((. .) .) ((. (. .)) ((. .) (. (. .)))))
+        (2 7 ((. .) .) ((. (. .)) ((. .) ((. .) .))))
+        (2 7 ((. .) .) ((. (. .)) ((. (. .)) (. .))))
+        (2 7 ((. .) .) ((. (. .)) (((. .) .) (. .))))
+        (2 7 ((. .) .) ((. (. .)) (((. .) (. .)) .)))
+        (2 7 ((. .) .) (((. .) .) (. ((. .) (. .)))))
+        (2 7 ((. .) .) (((. .) .) ((. .) (. (. .)))))
+        (2 7 ((. .) .) (((. .) .) ((. .) ((. .) .))))
+        (2 7 ((. .) .) (((. .) .) ((. (. .)) (. .))))
+        (2 7 ((. .) .) (((. .) .) (((. .) .) (. .))))
+        (2 7 ((. .) .) (((. .) .) (((. .) (. .)) .)))
+        (2 7 ((. .) .) ((. (. (. .))) (. (. (. .)))))
+        (2 7 ((. .) .) ((. (. (. .))) (. ((. .) .))))
+        (2 7 ((. .) .) ((. (. (. .))) ((. .) (. .))))
+        (2 7 ((. .) .) ((. (. (. .))) ((. (. .)) .)))
+        (2 7 ((. .) .) ((. (. (. .))) (((. .) .) .)))
+        (2 7 ((. .) .) ((. ((. .) .)) (. (. (. .)))))
+        (2 7 ((. .) .) ((. ((. .) .)) (. ((. .) .))))
+        (2 7 ((. .) .) ((. ((. .) .)) ((. .) (. .))))
+        (2 7 ((. .) .) ((. ((. .) .)) ((. (. .)) .)))
+        (2 7 ((. .) .) ((. ((. .) .)) (((. .) .) .)))
+        (2 7 ((. .) .) (((. .) (. .)) (. (. (. .)))))
+        (2 7 ((. .) .) (((. .) (. .)) (. ((. .) .))))
+        (2 7 ((. .) .) (((. .) (. .)) ((. .) (. .))))
+        (2 7 ((. .) .) (((. .) (. .)) ((. (. .)) .)))
+        (2 7 ((. .) .) (((. .) (. .)) (((. .) .) .)))
+        (2 7 ((. .) .) (((. (. .)) .) (. (. (. .)))))
+        (2 7 ((. .) .) (((. (. .)) .) (. ((. .) .))))
+        (2 7 ((. .) .) (((. (. .)) .) ((. .) (. .))))
+        (2 7 ((. .) .) (((. (. .)) .) ((. (. .)) .)))
+        (2 7 ((. .) .) (((. (. .)) .) (((. .) .) .)))
+        (2 7 ((. .) .) ((((. .) .) .) (. (. (. .)))))
+        (2 7 ((. .) .) ((((. .) .) .) (. ((. .) .))))
+        (2 7 ((. .) .) ((((. .) .) .) ((. .) (. .))))
+        (2 7 ((. .) .) ((((. .) .) .) ((. (. .)) .)))
+        (2 7 ((. .) .) ((((. .) .) .) (((. .) .) .)))
+        (2 7 ((. .) .) ((. ((. .) (. .))) (. (. .))))
+        (2 7 ((. .) .) ((. ((. .) (. .))) ((. .) .)))
+        (2 7 ((. .) .) (((. .) (. (. .))) (. (. .))))
+        (2 7 ((. .) .) (((. .) (. (. .))) ((. .) .)))
+        (2 7 ((. .) .) (((. .) ((. .) .)) (. (. .))))
+        (2 7 ((. .) .) (((. .) ((. .) .)) ((. .) .)))
+        (2 7 ((. .) .) (((. (. .)) (. .)) (. (. .))))
+        (2 7 ((. .) .) (((. (. .)) (. .)) ((. .) .)))
+        (2 7 ((. .) .) ((((. .) .) (. .)) (. (. .))))
+        (2 7 ((. .) .) ((((. .) .) (. .)) ((. .) .)))
+        (2 7 ((. .) .) ((((. .) (. .)) .) (. (. .))))
+        (2 7 ((. .) .) ((((. .) (. .)) .) ((. .) .)))
+        (2 7 ((. .) .) (((. .) ((. .) (. .))) (. .)))
+        (2 7 ((. .) .) (((. (. .)) (. (. .))) (. .)))
+        (2 7 ((. .) .) (((. (. .)) ((. .) .)) (. .)))
+        (2 7 ((. .) .) ((((. .) .) (. (. .))) (. .)))
+        (2 7 ((. .) .) ((((. .) .) ((. .) .)) (. .)))
+        (2 7 ((. .) .) ((((. .) (. .)) (. .)) (. .)))
+        (3 6 (. (. (. .))) ((. .) (. ((. .) (. .)))))
+        (3 6 (. (. (. .))) ((. .) ((. .) (. (. .)))))
+        (3 6 (. (. (. .))) ((. .) ((. .) ((. .) .))))
+        (3 6 (. (. (. .))) ((. .) ((. (. .)) (. .))))
+        (3 6 (. (. (. .))) ((. .) (((. .) .) (. .))))
+        (3 6 (. (. (. .))) ((. .) (((. .) (. .)) .)))
+        (3 6 (. (. (. .))) ((. (. .)) (. (. (. .)))))
+        (3 6 (. (. (. .))) ((. (. .)) (. ((. .) .))))
+        (3 6 (. (. (. .))) ((. (. .)) ((. .) (. .))))
+        (3 6 (. (. (. .))) ((. (. .)) ((. (. .)) .)))
+        (3 6 (. (. (. .))) ((. (. .)) (((. .) .) .)))
+        (3 6 (. (. (. .))) (((. .) .) (. (. (. .)))))
+        (3 6 (. (. (. .))) (((. .) .) (. ((. .) .))))
+        (3 6 (. (. (. .))) (((. .) .) ((. .) (. .))))
+        (3 6 (. (. (. .))) (((. .) .) ((. (. .)) .)))
+        (3 6 (. (. (. .))) (((. .) .) (((. .) .) .)))
+        (3 6 (. (. (. .))) ((. (. (. .))) (. (. .))))
+        (3 6 (. (. (. .))) ((. (. (. .))) ((. .) .)))
+        (3 6 (. (. (. .))) ((. ((. .) .)) (. (. .))))
+        (3 6 (. (. (. .))) ((. ((. .) .)) ((. .) .)))
+        (3 6 (. (. (. .))) (((. .) (. .)) (. (. .))))
+        (3 6 (. (. (. .))) (((. .) (. .)) ((. .) .)))
+        (3 6 (. (. (. .))) (((. (. .)) .) (. (. .))))
+        (3 6 (. (. (. .))) (((. (. .)) .) ((. .) .)))
+        (3 6 (. (. (. .))) ((((. .) .) .) (. (. .))))
+        (3 6 (. (. (. .))) ((((. .) .) .) ((. .) .)))
+        (3 6 (. (. (. .))) ((. ((. .) (. .))) (. .)))
+        (3 6 (. (. (. .))) (((. .) (. (. .))) (. .)))
+        (3 6 (. (. (. .))) (((. .) ((. .) .)) (. .)))
+        (3 6 (. (. (. .))) (((. (. .)) (. .)) (. .)))
+        (3 6 (. (. (. .))) ((((. .) .) (. .)) (. .)))
+        (3 6 (. (. (. .))) ((((. .) (. .)) .) (. .)))
+        (3 6 (. ((. .) .)) ((. .) (. ((. .) (. .)))))
+        (3 6 (. ((. .) .)) ((. .) ((. .) (. (. .)))))
+        (3 6 (. ((. .) .)) ((. .) ((. .) ((. .) .))))
+        (3 6 (. ((. .) .)) ((. .) ((. (. .)) (. .))))
+        (3 6 (. ((. .) .)) ((. .) (((. .) .) (. .))))
+        (3 6 (. ((. .) .)) ((. .) (((. .) (. .)) .)))
+        (3 6 (. ((. .) .)) ((. (. .)) (. (. (. .)))))
+        (3 6 (. ((. .) .)) ((. (. .)) (. ((. .) .))))
+        (3 6 (. ((. .) .)) ((. (. .)) ((. .) (. .))))
+        (3 6 (. ((. .) .)) ((. (. .)) ((. (. .)) .)))
+        (3 6 (. ((. .) .)) ((. (. .)) (((. .) .) .)))
+        (3 6 (. ((. .) .)) (((. .) .) (. (. (. .)))))
+        (3 6 (. ((. .) .)) (((. .) .) (. ((. .) .))))
+        (3 6 (. ((. .) .)) (((. .) .) ((. .) (. .))))
+        (3 6 (. ((. .) .)) (((. .) .) ((. (. .)) .)))
+        (3 6 (. ((. .) .)) (((. .) .) (((. .) .) .)))
+        (3 6 (. ((. .) .)) ((. (. (. .))) (. (. .))))
+        (3 6 (. ((. .) .)) ((. (. (. .))) ((. .) .)))
+        (3 6 (. ((. .) .)) ((. ((. .) .)) (. (. .))))
+        (3 6 (. ((. .) .)) ((. ((. .) .)) ((. .) .)))
+        (3 6 (. ((. .) .)) (((. .) (. .)) (. (. .))))
+        (3 6 (. ((. .) .)) (((. .) (. .)) ((. .) .)))
+        (3 6 (. ((. .) .)) (((. (. .)) .) (. (. .))))
+        (3 6 (. ((. .) .)) (((. (. .)) .) ((. .) .)))
+        (3 6 (. ((. .) .)) ((((. .) .) .) (. (. .))))
+        (3 6 (. ((. .) .)) ((((. .) .) .) ((. .) .)))
+        (3 6 (. ((. .) .)) ((. ((. .) (. .))) (. .)))
+        (3 6 (. ((. .) .)) (((. .) (. (. .))) (. .)))
+        (3 6 (. ((. .) .)) (((. .) ((. .) .)) (. .)))
+        (3 6 (. ((. .) .)) (((. (. .)) (. .)) (. .)))
+        (3 6 (. ((. .) .)) ((((. .) .) (. .)) (. .)))
+        (3 6 (. ((. .) .)) ((((. .) (. .)) .) (. .)))
+        (3 6 ((. .) (. .)) ((. .) (. ((. .) (. .)))))
+        (3 6 ((. .) (. .)) ((. .) ((. .) (. (. .)))))
+        (3 6 ((. .) (. .)) ((. .) ((. .) ((. .) .))))
+        (3 6 ((. .) (. .)) ((. .) ((. (. .)) (. .))))
+        (3 6 ((. .) (. .)) ((. .) (((. .) .) (. .))))
+        (3 6 ((. .) (. .)) ((. .) (((. .) (. .)) .)))
+        (3 6 ((. .) (. .)) ((. (. .)) (. (. (. .)))))
+        (3 6 ((. .) (. .)) ((. (. .)) (. ((. .) .))))
+        (3 6 ((. .) (. .)) ((. (. .)) ((. .) (. .))))
+        (3 6 ((. .) (. .)) ((. (. .)) ((. (. .)) .)))
+        (3 6 ((. .) (. .)) ((. (. .)) (((. .) .) .)))
+        (3 6 ((. .) (. .)) (((. .) .) (. (. (. .)))))
+        (3 6 ((. .) (. .)) (((. .) .) (. ((. .) .))))
+        (3 6 ((. .) (. .)) (((. .) .) ((. .) (. .))))
+        (3 6 ((. .) (. .)) (((. .) .) ((. (. .)) .)))
+        (3 6 ((. .) (. .)) (((. .) .) (((. .) .) .)))
+        (3 6 ((. .) (. .)) ((. (. (. .))) (. (. .))))
+        (3 6 ((. .) (. .)) ((. (. (. .))) ((. .) .)))
+        (3 6 ((. .) (. .)) ((. ((. .) .)) (. (. .))))
+        (3 6 ((. .) (. .)) ((. ((. .) .)) ((. .) .)))
+        (3 6 ((. .) (. .)) (((. .) (. .)) (. (. .))))
+        (3 6 ((. .) (. .)) (((. .) (. .)) ((. .) .)))
+        (3 6 ((. .) (. .)) (((. (. .)) .) (. (. .))))
+        (3 6 ((. .) (. .)) (((. (. .)) .) ((. .) .)))
+        (3 6 ((. .) (. .)) ((((. .) .) .) (. (. .))))
+        (3 6 ((. .) (. .)) ((((. .) .) .) ((. .) .)))
+        (3 6 ((. .) (. .)) ((. ((. .) (. .))) (. .)))
+        (3 6 ((. .) (. .)) (((. .) (. (. .))) (. .)))
+        (3 6 ((. .) (. .)) (((. .) ((. .) .)) (. .)))
+        (3 6 ((. .) (. .)) (((. (. .)) (. .)) (. .)))
+        (3 6 ((. .) (. .)) ((((. .) .) (. .)) (. .)))
+        (3 6 ((. .) (. .)) ((((. .) (. .)) .) (. .)))
+        (3 6 ((. (. .)) .) ((. .) (. ((. .) (. .)))))
+        (3 6 ((. (. .)) .) ((. .) ((. .) (. (. .)))))
+        (3 6 ((. (. .)) .) ((. .) ((. .) ((. .) .))))
+        (3 6 ((. (. .)) .) ((. .) ((. (. .)) (. .))))
+        (3 6 ((. (. .)) .) ((. .) (((. .) .) (. .))))
+        (3 6 ((. (. .)) .) ((. .) (((. .) (. .)) .)))
+        (3 6 ((. (. .)) .) ((. (. .)) (. (. (. .)))))
+        (3 6 ((. (. .)) .) ((. (. .)) (. ((. .) .))))
+        (3 6 ((. (. .)) .) ((. (. .)) ((. .) (. .))))
+        (3 6 ((. (. .)) .) ((. (. .)) ((. (. .)) .)))
+        (3 6 ((. (. .)) .) ((. (. .)) (((. .) .) .)))
+        (3 6 ((. (. .)) .) (((. .) .) (. (. (. .)))))
+        (3 6 ((. (. .)) .) (((. .) .) (. ((. .) .))))
+        (3 6 ((. (. .)) .) (((. .) .) ((. .) (. .))))
+        (3 6 ((. (. .)) .) (((. .) .) ((. (. .)) .)))
+        (3 6 ((. (. .)) .) (((. .) .) (((. .) .) .)))
+        (3 6 ((. (. .)) .) ((. (. (. .))) (. (. .))))
+        (3 6 ((. (. .)) .) ((. (. (. .))) ((. .) .)))
+        (3 6 ((. (. .)) .) ((. ((. .) .)) (. (. .))))
+        (3 6 ((. (. .)) .) ((. ((. .) .)) ((. .) .)))
+        (3 6 ((. (. .)) .) (((. .) (. .)) (. (. .))))
+        (3 6 ((. (. .)) .) (((. .) (. .)) ((. .) .)))
+        (3 6 ((. (. .)) .) (((. (. .)) .) (. (. .))))
+        (3 6 ((. (. .)) .) (((. (. .)) .) ((. .) .)))
+        (3 6 ((. (. .)) .) ((((. .) .) .) (. (. .))))
+        (3 6 ((. (. .)) .) ((((. .) .) .) ((. .) .)))
+        (3 6 ((. (. .)) .) ((. ((. .) (. .))) (. .)))
+        (3 6 ((. (. .)) .) (((. .) (. (. .))) (. .)))
+        (3 6 ((. (. .)) .) (((. .) ((. .) .)) (. .)))
+        (3 6 ((. (. .)) .) (((. (. .)) (. .)) (. .)))
+        (3 6 ((. (. .)) .) ((((. .) .) (. .)) (. .)))
+        (3 6 ((. (. .)) .) ((((. .) (. .)) .) (. .)))
+        (3 6 (((. .) .) .) ((. .) (. ((. .) (. .)))))
+        (3 6 (((. .) .) .) ((. .) ((. .) (. (. .)))))
+        (3 6 (((. .) .) .) ((. .) ((. .) ((. .) .))))
+        (3 6 (((. .) .) .) ((. .) ((. (. .)) (. .))))
+        (3 6 (((. .) .) .) ((. .) (((. .) .) (. .))))
+        (3 6 (((. .) .) .) ((. .) (((. .) (. .)) .)))
+        (3 6 (((. .) .) .) ((. (. .)) (. (. (. .)))))
+        (3 6 (((. .) .) .) ((. (. .)) (. ((. .) .))))
+        (3 6 (((. .) .) .) ((. (. .)) ((. .) (. .))))
+        (3 6 (((. .) .) .) ((. (. .)) ((. (. .)) .)))
+        (3 6 (((. .) .) .) ((. (. .)) (((. .) .) .)))
+        (3 6 (((. .) .) .) (((. .) .) (. (. (. .)))))
+        (3 6 (((. .) .) .) (((. .) .) (. ((. .) .))))
+        (3 6 (((. .) .) .) (((. .) .) ((. .) (. .))))
+        (3 6 (((. .) .) .) (((. .) .) ((. (. .)) .)))
+        (3 6 (((. .) .) .) (((. .) .) (((. .) .) .)))
+        (3 6 (((. .) .) .) ((. (. (. .))) (. (. .))))
+        (3 6 (((. .) .) .) ((. (. (. .))) ((. .) .)))
+        (3 6 (((. .) .) .) ((. ((. .) .)) (. (. .))))
+        (3 6 (((. .) .) .) ((. ((. .) .)) ((. .) .)))
+        (3 6 (((. .) .) .) (((. .) (. .)) (. (. .))))
+        (3 6 (((. .) .) .) (((. .) (. .)) ((. .) .)))
+        (3 6 (((. .) .) .) (((. (. .)) .) (. (. .))))
+        (3 6 (((. .) .) .) (((. (. .)) .) ((. .) .)))
+        (3 6 (((. .) .) .) ((((. .) .) .) (. (. .))))
+        (3 6 (((. .) .) .) ((((. .) .) .) ((. .) .)))
+        (3 6 (((. .) .) .) ((. ((. .) (. .))) (. .)))
+        (3 6 (((. .) .) .) (((. .) (. (. .))) (. .)))
+        (3 6 (((. .) .) .) (((. .) ((. .) .)) (. .)))
+        (3 6 (((. .) .) .) (((. (. .)) (. .)) (. .)))
+        (3 6 (((. .) .) .) ((((. .) .) (. .)) (. .)))
+        (3 6 (((. .) .) .) ((((. .) (. .)) .) (. .)))
+        (4 5 (. ((. .) (. .))) ((. .) (. (. (. .)))))
+        (4 5 (. ((. .) (. .))) ((. .) (. ((. .) .))))
+        (4 5 (. ((. .) (. .))) ((. .) ((. .) (. .))))
+        (4 5 (. ((. .) (. .))) ((. .) ((. (. .)) .)))
+        (4 5 (. ((. .) (. .))) ((. .) (((. .) .) .)))
+        (4 5 (. ((. .) (. .))) ((. (. .)) (. (. .))))
+        (4 5 (. ((. .) (. .))) ((. (. .)) ((. .) .)))
+        (4 5 (. ((. .) (. .))) (((. .) .) (. (. .))))
+        (4 5 (. ((. .) (. .))) (((. .) .) ((. .) .)))
+        (4 5 (. ((. .) (. .))) ((. (. (. .))) (. .)))
+        (4 5 (. ((. .) (. .))) ((. ((. .) .)) (. .)))
+        (4 5 (. ((. .) (. .))) (((. .) (. .)) (. .)))
+        (4 5 (. ((. .) (. .))) (((. (. .)) .) (. .)))
+        (4 5 (. ((. .) (. .))) ((((. .) .) .) (. .)))
+        (4 5 ((. .) (. (. .))) ((. .) (. (. (. .)))))
+        (4 5 ((. .) (. (. .))) ((. .) (. ((. .) .))))
+        (4 5 ((. .) (. (. .))) ((. .) ((. .) (. .))))
+        (4 5 ((. .) (. (. .))) ((. .) ((. (. .)) .)))
+        (4 5 ((. .) (. (. .))) ((. .) (((. .) .) .)))
+        (4 5 ((. .) (. (. .))) ((. (. .)) (. (. .))))
+        (4 5 ((. .) (. (. .))) ((. (. .)) ((. .) .)))
+        (4 5 ((. .) (. (. .))) (((. .) .) (. (. .))))
+        (4 5 ((. .) (. (. .))) (((. .) .) ((. .) .)))
+        (4 5 ((. .) (. (. .))) ((. (. (. .))) (. .)))
+        (4 5 ((. .) (. (. .))) ((. ((. .) .)) (. .)))
+        (4 5 ((. .) (. (. .))) (((. .) (. .)) (. .)))
+        (4 5 ((. .) (. (. .))) (((. (. .)) .) (. .)))
+        (4 5 ((. .) (. (. .))) ((((. .) .) .) (. .)))
+        (4 5 ((. .) ((. .) .)) ((. .) (. (. (. .)))))
+        (4 5 ((. .) ((. .) .)) ((. .) (. ((. .) .))))
+        (4 5 ((. .) ((. .) .)) ((. .) ((. .) (. .))))
+        (4 5 ((. .) ((. .) .)) ((. .) ((. (. .)) .)))
+        (4 5 ((. .) ((. .) .)) ((. .) (((. .) .) .)))
+        (4 5 ((. .) ((. .) .)) ((. (. .)) (. (. .))))
+        (4 5 ((. .) ((. .) .)) ((. (. .)) ((. .) .)))
+        (4 5 ((. .) ((. .) .)) (((. .) .) (. (. .))))
+        (4 5 ((. .) ((. .) .)) (((. .) .) ((. .) .)))
+        (4 5 ((. .) ((. .) .)) ((. (. (. .))) (. .)))
+        (4 5 ((. .) ((. .) .)) ((. ((. .) .)) (. .)))
+        (4 5 ((. .) ((. .) .)) (((. .) (. .)) (. .)))
+        (4 5 ((. .) ((. .) .)) (((. (. .)) .) (. .)))
+        (4 5 ((. .) ((. .) .)) ((((. .) .) .) (. .)))
+        (4 5 ((. (. .)) (. .)) ((. .) (. (. (. .)))))
+        (4 5 ((. (. .)) (. .)) ((. .) (. ((. .) .))))
+        (4 5 ((. (. .)) (. .)) ((. .) ((. .) (. .))))
+        (4 5 ((. (. .)) (. .)) ((. .) ((. (. .)) .)))
+        (4 5 ((. (. .)) (. .)) ((. .) (((. .) .) .)))
+        (4 5 ((. (. .)) (. .)) ((. (. .)) (. (. .))))
+        (4 5 ((. (. .)) (. .)) ((. (. .)) ((. .) .)))
+        (4 5 ((. (. .)) (. .)) (((. .) .) (. (. .))))
+        (4 5 ((. (. .)) (. .)) (((. .) .) ((. .) .)))
+        (4 5 ((. (. .)) (. .)) ((. (. (. .))) (. .)))
+        (4 5 ((. (. .)) (. .)) ((. ((. .) .)) (. .)))
+        (4 5 ((. (. .)) (. .)) (((. .) (. .)) (. .)))
+        (4 5 ((. (. .)) (. .)) (((. (. .)) .) (. .)))
+        (4 5 ((. (. .)) (. .)) ((((. .) .) .) (. .)))
+        (4 5 (((. .) .) (. .)) ((. .) (. (. (. .)))))
+        (4 5 (((. .) .) (. .)) ((. .) (. ((. .) .))))
+        (4 5 (((. .) .) (. .)) ((. .) ((. .) (. .))))
+        (4 5 (((. .) .) (. .)) ((. .) ((. (. .)) .)))
+        (4 5 (((. .) .) (. .)) ((. .) (((. .) .) .)))
+        (4 5 (((. .) .) (. .)) ((. (. .)) (. (. .))))
+        (4 5 (((. .) .) (. .)) ((. (. .)) ((. .) .)))
+        (4 5 (((. .) .) (. .)) (((. .) .) (. (. .))))
+        (4 5 (((. .) .) (. .)) (((. .) .) ((. .) .)))
+        (4 5 (((. .) .) (. .)) ((. (. (. .))) (. .)))
+        (4 5 (((. .) .) (. .)) ((. ((. .) .)) (. .)))
+        (4 5 (((. .) .) (. .)) (((. .) (. .)) (. .)))
+        (4 5 (((. .) .) (. .)) (((. (. .)) .) (. .)))
+        (4 5 (((. .) .) (. .)) ((((. .) .) .) (. .)))
+        (4 5 (((. .) (. .)) .) ((. .) (. (. (. .)))))
+        (4 5 (((. .) (. .)) .) ((. .) (. ((. .) .))))
+        (4 5 (((. .) (. .)) .) ((. .) ((. .) (. .))))
+        (4 5 (((. .) (. .)) .) ((. .) ((. (. .)) .)))
+        (4 5 (((. .) (. .)) .) ((. .) (((. .) .) .)))
+        (4 5 (((. .) (. .)) .) ((. (. .)) (. (. .))))
+        (4 5 (((. .) (. .)) .) ((. (. .)) ((. .) .)))
+        (4 5 (((. .) (. .)) .) (((. .) .) (. (. .))))
+        (4 5 (((. .) (. .)) .) (((. .) .) ((. .) .)))
+        (4 5 (((. .) (. .)) .) ((. (. (. .))) (. .)))
+        (4 5 (((. .) (. .)) .) ((. ((. .) .)) (. .)))
+        (4 5 (((. .) (. .)) .) (((. .) (. .)) (. .)))
+        (4 5 (((. .) (. .)) .) (((. (. .)) .) (. .)))
+        (4 5 (((. .) (. .)) .) ((((. .) .) .) (. .)))
+        (5 4 ((. .) (. (. (. .)))) (. ((. .) (. .))))
+        (5 4 ((. .) (. (. (. .)))) ((. .) (. (. .))))
+        (5 4 ((. .) (. (. (. .)))) ((. .) ((. .) .)))
+        (5 4 ((. .) (. (. (. .)))) ((. (. .)) (. .)))
+        (5 4 ((. .) (. (. (. .)))) (((. .) .) (. .)))
+        (5 4 ((. .) (. (. (. .)))) (((. .) (. .)) .))
+        (5 4 ((. .) (. ((. .) .))) (. ((. .) (. .))))
+        (5 4 ((. .) (. ((. .) .))) ((. .) (. (. .))))
+        (5 4 ((. .) (. ((. .) .))) ((. .) ((. .) .)))
+        (5 4 ((. .) (. ((. .) .))) ((. (. .)) (. .)))
+        (5 4 ((. .) (. ((. .) .))) (((. .) .) (. .)))
+        (5 4 ((. .) (. ((. .) .))) (((. .) (. .)) .))
+        (5 4 ((. .) ((. .) (. .))) (. ((. .) (. .))))
+        (5 4 ((. .) ((. .) (. .))) ((. .) (. (. .))))
+        (5 4 ((. .) ((. .) (. .))) ((. .) ((. .) .)))
+        (5 4 ((. .) ((. .) (. .))) ((. (. .)) (. .)))
+        (5 4 ((. .) ((. .) (. .))) (((. .) .) (. .)))
+        (5 4 ((. .) ((. .) (. .))) (((. .) (. .)) .))
+        (5 4 ((. .) ((. (. .)) .)) (. ((. .) (. .))))
+        (5 4 ((. .) ((. (. .)) .)) ((. .) (. (. .))))
+        (5 4 ((. .) ((. (. .)) .)) ((. .) ((. .) .)))
+        (5 4 ((. .) ((. (. .)) .)) ((. (. .)) (. .)))
+        (5 4 ((. .) ((. (. .)) .)) (((. .) .) (. .)))
+        (5 4 ((. .) ((. (. .)) .)) (((. .) (. .)) .))
+        (5 4 ((. .) (((. .) .) .)) (. ((. .) (. .))))
+        (5 4 ((. .) (((. .) .) .)) ((. .) (. (. .))))
+        (5 4 ((. .) (((. .) .) .)) ((. .) ((. .) .)))
+        (5 4 ((. .) (((. .) .) .)) ((. (. .)) (. .)))
+        (5 4 ((. .) (((. .) .) .)) (((. .) .) (. .)))
+        (5 4 ((. .) (((. .) .) .)) (((. .) (. .)) .))
+        (5 4 ((. (. .)) (. (. .))) (. ((. .) (. .))))
+        (5 4 ((. (. .)) (. (. .))) ((. .) (. (. .))))
+        (5 4 ((. (. .)) (. (. .))) ((. .) ((. .) .)))
+        (5 4 ((. (. .)) (. (. .))) ((. (. .)) (. .)))
+        (5 4 ((. (. .)) (. (. .))) (((. .) .) (. .)))
+        (5 4 ((. (. .)) (. (. .))) (((. .) (. .)) .))
+        (5 4 ((. (. .)) ((. .) .)) (. ((. .) (. .))))
+        (5 4 ((. (. .)) ((. .) .)) ((. .) (. (. .))))
+        (5 4 ((. (. .)) ((. .) .)) ((. .) ((. .) .)))
+        (5 4 ((. (. .)) ((. .) .)) ((. (. .)) (. .)))
+        (5 4 ((. (. .)) ((. .) .)) (((. .) .) (. .)))
+        (5 4 ((. (. .)) ((. .) .)) (((. .) (. .)) .))
+        (5 4 (((. .) .) (. (. .))) (. ((. .) (. .))))
+        (5 4 (((. .) .) (. (. .))) ((. .) (. (. .))))
+        (5 4 (((. .) .) (. (. .))) ((. .) ((. .) .)))
+        (5 4 (((. .) .) (. (. .))) ((. (. .)) (. .)))
+        (5 4 (((. .) .) (. (. .))) (((. .) .) (. .)))
+        (5 4 (((. .) .) (. (. .))) (((. .) (. .)) .))
+        (5 4 (((. .) .) ((. .) .)) (. ((. .) (. .))))
+        (5 4 (((. .) .) ((. .) .)) ((. .) (. (. .))))
+        (5 4 (((. .) .) ((. .) .)) ((. .) ((. .) .)))
+        (5 4 (((. .) .) ((. .) .)) ((. (. .)) (. .)))
+        (5 4 (((. .) .) ((. .) .)) (((. .) .) (. .)))
+        (5 4 (((. .) .) ((. .) .)) (((. .) (. .)) .))
+        (5 4 ((. (. (. .))) (. .)) (. ((. .) (. .))))
+        (5 4 ((. (. (. .))) (. .)) ((. .) (. (. .))))
+        (5 4 ((. (. (. .))) (. .)) ((. .) ((. .) .)))
+        (5 4 ((. (. (. .))) (. .)) ((. (. .)) (. .)))
+        (5 4 ((. (. (. .))) (. .)) (((. .) .) (. .)))
+        (5 4 ((. (. (. .))) (. .)) (((. .) (. .)) .))
+        (5 4 ((. ((. .) .)) (. .)) (. ((. .) (. .))))
+        (5 4 ((. ((. .) .)) (. .)) ((. .) (. (. .))))
+        (5 4 ((. ((. .) .)) (. .)) ((. .) ((. .) .)))
+        (5 4 ((. ((. .) .)) (. .)) ((. (. .)) (. .)))
+        (5 4 ((. ((. .) .)) (. .)) (((. .) .) (. .)))
+        (5 4 ((. ((. .) .)) (. .)) (((. .) (. .)) .))
+        (5 4 (((. .) (. .)) (. .)) (. ((. .) (. .))))
+        (5 4 (((. .) (. .)) (. .)) ((. .) (. (. .))))
+        (5 4 (((. .) (. .)) (. .)) ((. .) ((. .) .)))
+        (5 4 (((. .) (. .)) (. .)) ((. (. .)) (. .)))
+        (5 4 (((. .) (. .)) (. .)) (((. .) .) (. .)))
+        (5 4 (((. .) (. .)) (. .)) (((. .) (. .)) .))
+        (5 4 (((. (. .)) .) (. .)) (. ((. .) (. .))))
+        (5 4 (((. (. .)) .) (. .)) ((. .) (. (. .))))
+        (5 4 (((. (. .)) .) (. .)) ((. .) ((. .) .)))
+        (5 4 (((. (. .)) .) (. .)) ((. (. .)) (. .)))
+        (5 4 (((. (. .)) .) (. .)) (((. .) .) (. .)))
+        (5 4 (((. (. .)) .) (. .)) (((. .) (. .)) .))
+        (5 4 ((((. .) .) .) (. .)) (. ((. .) (. .))))
+        (5 4 ((((. .) .) .) (. .)) ((. .) (. (. .))))
+        (5 4 ((((. .) .) .) (. .)) ((. .) ((. .) .)))
+        (5 4 ((((. .) .) .) (. .)) ((. (. .)) (. .)))
+        (5 4 ((((. .) .) .) (. .)) (((. .) .) (. .)))
+        (5 4 ((((. .) .) .) (. .)) (((. .) (. .)) .))
+        (6 3 ((. .) (. ((. .) (. .)))) (. (. (. .))))
+        (6 3 ((. .) (. ((. .) (. .)))) (. ((. .) .)))
+        (6 3 ((. .) (. ((. .) (. .)))) ((. .) (. .)))
+        (6 3 ((. .) (. ((. .) (. .)))) ((. (. .)) .))
+        (6 3 ((. .) (. ((. .) (. .)))) (((. .) .) .))
+        (6 3 ((. .) ((. .) (. (. .)))) (. (. (. .))))
+        (6 3 ((. .) ((. .) (. (. .)))) (. ((. .) .)))
+        (6 3 ((. .) ((. .) (. (. .)))) ((. .) (. .)))
+        (6 3 ((. .) ((. .) (. (. .)))) ((. (. .)) .))
+        (6 3 ((. .) ((. .) (. (. .)))) (((. .) .) .))
+        (6 3 ((. .) ((. .) ((. .) .))) (. (. (. .))))
+        (6 3 ((. .) ((. .) ((. .) .))) (. ((. .) .)))
+        (6 3 ((. .) ((. .) ((. .) .))) ((. .) (. .)))
+        (6 3 ((. .) ((. .) ((. .) .))) ((. (. .)) .))
+        (6 3 ((. .) ((. .) ((. .) .))) (((. .) .) .))
+        (6 3 ((. .) ((. (. .)) (. .))) (. (. (. .))))
+        (6 3 ((. .) ((. (. .)) (. .))) (. ((. .) .)))
+        (6 3 ((. .) ((. (. .)) (. .))) ((. .) (. .)))
+        (6 3 ((. .) ((. (. .)) (. .))) ((. (. .)) .))
+        (6 3 ((. .) ((. (. .)) (. .))) (((. .) .) .))
+        (6 3 ((. .) (((. .) .) (. .))) (. (. (. .))))
+        (6 3 ((. .) (((. .) .) (. .))) (. ((. .) .)))
+        (6 3 ((. .) (((. .) .) (. .))) ((. .) (. .)))
+        (6 3 ((. .) (((. .) .) (. .))) ((. (. .)) .))
+        (6 3 ((. .) (((. .) .) (. .))) (((. .) .) .))
+        (6 3 ((. .) (((. .) (. .)) .)) (. (. (. .))))
+        (6 3 ((. .) (((. .) (. .)) .)) (. ((. .) .)))
+        (6 3 ((. .) (((. .) (. .)) .)) ((. .) (. .)))
+        (6 3 ((. .) (((. .) (. .)) .)) ((. (. .)) .))
+        (6 3 ((. .) (((. .) (. .)) .)) (((. .) .) .))
+        (6 3 ((. (. .)) (. (. (. .)))) (. (. (. .))))
+        (6 3 ((. (. .)) (. (. (. .)))) (. ((. .) .)))
+        (6 3 ((. (. .)) (. (. (. .)))) ((. .) (. .)))
+        (6 3 ((. (. .)) (. (. (. .)))) ((. (. .)) .))
+        (6 3 ((. (. .)) (. (. (. .)))) (((. .) .) .))
+        (6 3 ((. (. .)) (. ((. .) .))) (. (. (. .))))
+        (6 3 ((. (. .)) (. ((. .) .))) (. ((. .) .)))
+        (6 3 ((. (. .)) (. ((. .) .))) ((. .) (. .)))
+        (6 3 ((. (. .)) (. ((. .) .))) ((. (. .)) .))
+        (6 3 ((. (. .)) (. ((. .) .))) (((. .) .) .))
+        (6 3 ((. (. .)) ((. .) (. .))) (. (. (. .))))
+        (6 3 ((. (. .)) ((. .) (. .))) (. ((. .) .)))
+        (6 3 ((. (. .)) ((. .) (. .))) ((. .) (. .)))
+        (6 3 ((. (. .)) ((. .) (. .))) ((. (. .)) .))
+        (6 3 ((. (. .)) ((. .) (. .))) (((. .) .) .))
+        (6 3 ((. (. .)) ((. (. .)) .)) (. (. (. .))))
+        (6 3 ((. (. .)) ((. (. .)) .)) (. ((. .) .)))
+        (6 3 ((. (. .)) ((. (. .)) .)) ((. .) (. .)))
+        (6 3 ((. (. .)) ((. (. .)) .)) ((. (. .)) .))
+        (6 3 ((. (. .)) ((. (. .)) .)) (((. .) .) .))
+        (6 3 ((. (. .)) (((. .) .) .)) (. (. (. .))))
+        (6 3 ((. (. .)) (((. .) .) .)) (. ((. .) .)))
+        (6 3 ((. (. .)) (((. .) .) .)) ((. .) (. .)))
+        (6 3 ((. (. .)) (((. .) .) .)) ((. (. .)) .))
+        (6 3 ((. (. .)) (((. .) .) .)) (((. .) .) .))
+        (6 3 (((. .) .) (. (. (. .)))) (. (. (. .))))
+        (6 3 (((. .) .) (. (. (. .)))) (. ((. .) .)))
+        (6 3 (((. .) .) (. (. (. .)))) ((. .) (. .)))
+        (6 3 (((. .) .) (. (. (. .)))) ((. (. .)) .))
+        (6 3 (((. .) .) (. (. (. .)))) (((. .) .) .))
+        (6 3 (((. .) .) (. ((. .) .))) (. (. (. .))))
+        (6 3 (((. .) .) (. ((. .) .))) (. ((. .) .)))
+        (6 3 (((. .) .) (. ((. .) .))) ((. .) (. .)))
+        (6 3 (((. .) .) (. ((. .) .))) ((. (. .)) .))
+        (6 3 (((. .) .) (. ((. .) .))) (((. .) .) .))
+        (6 3 (((. .) .) ((. .) (. .))) (. (. (. .))))
+        (6 3 (((. .) .) ((. .) (. .))) (. ((. .) .)))
+        (6 3 (((. .) .) ((. .) (. .))) ((. .) (. .)))
+        (6 3 (((. .) .) ((. .) (. .))) ((. (. .)) .))
+        (6 3 (((. .) .) ((. .) (. .))) (((. .) .) .))
+        (6 3 (((. .) .) ((. (. .)) .)) (. (. (. .))))
+        (6 3 (((. .) .) ((. (. .)) .)) (. ((. .) .)))
+        (6 3 (((. .) .) ((. (. .)) .)) ((. .) (. .)))
+        (6 3 (((. .) .) ((. (. .)) .)) ((. (. .)) .))
+        (6 3 (((. .) .) ((. (. .)) .)) (((. .) .) .))
+        (6 3 (((. .) .) (((. .) .) .)) (. (. (. .))))
+        (6 3 (((. .) .) (((. .) .) .)) (. ((. .) .)))
+        (6 3 (((. .) .) (((. .) .) .)) ((. .) (. .)))
+        (6 3 (((. .) .) (((. .) .) .)) ((. (. .)) .))
+        (6 3 (((. .) .) (((. .) .) .)) (((. .) .) .))
+        (6 3 ((. (. (. .))) (. (. .))) (. (. (. .))))
+        (6 3 ((. (. (. .))) (. (. .))) (. ((. .) .)))
+        (6 3 ((. (. (. .))) (. (. .))) ((. .) (. .)))
+        (6 3 ((. (. (. .))) (. (. .))) ((. (. .)) .))
+        (6 3 ((. (. (. .))) (. (. .))) (((. .) .) .))
+        (6 3 ((. (. (. .))) ((. .) .)) (. (. (. .))))
+        (6 3 ((. (. (. .))) ((. .) .)) (. ((. .) .)))
+        (6 3 ((. (. (. .))) ((. .) .)) ((. .) (. .)))
+        (6 3 ((. (. (. .))) ((. .) .)) ((. (. .)) .))
+        (6 3 ((. (. (. .))) ((. .) .)) (((. .) .) .))
+        (6 3 ((. ((. .) .)) (. (. .))) (. (. (. .))))
+        (6 3 ((. ((. .) .)) (. (. .))) (. ((. .) .)))
+        (6 3 ((. ((. .) .)) (. (. .))) ((. .) (. .)))
+        (6 3 ((. ((. .) .)) (. (. .))) ((. (. .)) .))
+        (6 3 ((. ((. .) .)) (. (. .))) (((. .) .) .))
+        (6 3 ((. ((. .) .)) ((. .) .)) (. (. (. .))))
+        (6 3 ((. ((. .) .)) ((. .) .)) (. ((. .) .)))
+        (6 3 ((. ((. .) .)) ((. .) .)) ((. .) (. .)))
+        (6 3 ((. ((. .) .)) ((. .) .)) ((. (. .)) .))
+        (6 3 ((. ((. .) .)) ((. .) .)) (((. .) .) .))
+        (6 3 (((. .) (. .)) (. (. .))) (. (. (. .))))
+        (6 3 (((. .) (. .)) (. (. .))) (. ((. .) .)))
+        (6 3 (((. .) (. .)) (. (. .))) ((. .) (. .)))
+        (6 3 (((. .) (. .)) (. (. .))) ((. (. .)) .))
+        (6 3 (((. .) (. .)) (. (. .))) (((. .) .) .))
+        (6 3 (((. .) (. .)) ((. .) .)) (. (. (. .))))
+        (6 3 (((. .) (. .)) ((. .) .)) (. ((. .) .)))
+        (6 3 (((. .) (. .)) ((. .) .)) ((. .) (. .)))
+        (6 3 (((. .) (. .)) ((. .) .)) ((. (. .)) .))
+        (6 3 (((. .) (. .)) ((. .) .)) (((. .) .) .))
+        (6 3 (((. (. .)) .) (. (. .))) (. (. (. .))))
+        (6 3 (((. (. .)) .) (. (. .))) (. ((. .) .)))
+        (6 3 (((. (. .)) .) (. (. .))) ((. .) (. .)))
+        (6 3 (((. (. .)) .) (. (. .))) ((. (. .)) .))
+        (6 3 (((. (. .)) .) (. (. .))) (((. .) .) .))
+        (6 3 (((. (. .)) .) ((. .) .)) (. (. (. .))))
+        (6 3 (((. (. .)) .) ((. .) .)) (. ((. .) .)))
+        (6 3 (((. (. .)) .) ((. .) .)) ((. .) (. .)))
+        (6 3 (((. (. .)) .) ((. .) .)) ((. (. .)) .))
+        (6 3 (((. (. .)) .) ((. .) .)) (((. .) .) .))
+        (6 3 ((((. .) .) .) (. (. .))) (. (. (. .))))
+        (6 3 ((((. .) .) .) (. (. .))) (. ((. .) .)))
+        (6 3 ((((. .) .) .) (. (. .))) ((. .) (. .)))
+        (6 3 ((((. .) .) .) (. (. .))) ((. (. .)) .))
+        (6 3 ((((. .) .) .) (. (. .))) (((. .) .) .))
+        (6 3 ((((. .) .) .) ((. .) .)) (. (. (. .))))
+        (6 3 ((((. .) .) .) ((. .) .)) (. ((. .) .)))
+        (6 3 ((((. .) .) .) ((. .) .)) ((. .) (. .)))
+        (6 3 ((((. .) .) .) ((. .) .)) ((. (. .)) .))
+        (6 3 ((((. .) .) .) ((. .) .)) (((. .) .) .))
+        (6 3 ((. ((. .) (. .))) (. .)) (. (. (. .))))
+        (6 3 ((. ((. .) (. .))) (. .)) (. ((. .) .)))
+        (6 3 ((. ((. .) (. .))) (. .)) ((. .) (. .)))
+        (6 3 ((. ((. .) (. .))) (. .)) ((. (. .)) .))
+        (6 3 ((. ((. .) (. .))) (. .)) (((. .) .) .))
+        (6 3 (((. .) (. (. .))) (. .)) (. (. (. .))))
+        (6 3 (((. .) (. (. .))) (. .)) (. ((. .) .)))
+        (6 3 (((. .) (. (. .))) (. .)) ((. .) (. .)))
+        (6 3 (((. .) (. (. .))) (. .)) ((. (. .)) .))
+        (6 3 (((. .) (. (. .))) (. .)) (((. .) .) .))
+        (6 3 (((. .) ((. .) .)) (. .)) (. (. (. .))))
+        (6 3 (((. .) ((. .) .)) (. .)) (. ((. .) .)))
+        (6 3 (((. .) ((. .) .)) (. .)) ((. .) (. .)))
+        (6 3 (((. .) ((. .) .)) (. .)) ((. (. .)) .))
+        (6 3 (((. .) ((. .) .)) (. .)) (((. .) .) .))
+        (6 3 (((. (. .)) (. .)) (. .)) (. (. (. .))))
+        (6 3 (((. (. .)) (. .)) (. .)) (. ((. .) .)))
+        (6 3 (((. (. .)) (. .)) (. .)) ((. .) (. .)))
+        (6 3 (((. (. .)) (. .)) (. .)) ((. (. .)) .))
+        (6 3 (((. (. .)) (. .)) (. .)) (((. .) .) .))
+        (6 3 ((((. .) .) (. .)) (. .)) (. (. (. .))))
+        (6 3 ((((. .) .) (. .)) (. .)) (. ((. .) .)))
+        (6 3 ((((. .) .) (. .)) (. .)) ((. .) (. .)))
+        (6 3 ((((. .) .) (. .)) (. .)) ((. (. .)) .))
+        (6 3 ((((. .) .) (. .)) (. .)) (((. .) .) .))
+        (6 3 ((((. .) (. .)) .) (. .)) (. (. (. .))))
+        (6 3 ((((. .) (. .)) .) (. .)) (. ((. .) .)))
+        (6 3 ((((. .) (. .)) .) (. .)) ((. .) (. .)))
+        (6 3 ((((. .) (. .)) .) (. .)) ((. (. .)) .))
+        (6 3 ((((. .) (. .)) .) (. .)) (((. .) .) .))
+        (7 2 ((. .) ((. .) ((. .) (. .)))) (. (. .)))
+        (7 2 ((. .) ((. .) ((. .) (. .)))) ((. .) .))
+        (7 2 ((. .) ((. (. .)) (. (. .)))) (. (. .)))
+        (7 2 ((. .) ((. (. .)) (. (. .)))) ((. .) .))
+        (7 2 ((. .) ((. (. .)) ((. .) .))) (. (. .)))
+        (7 2 ((. .) ((. (. .)) ((. .) .))) ((. .) .))
+        (7 2 ((. .) (((. .) .) (. (. .)))) (. (. .)))
+        (7 2 ((. .) (((. .) .) (. (. .)))) ((. .) .))
+        (7 2 ((. .) (((. .) .) ((. .) .))) (. (. .)))
+        (7 2 ((. .) (((. .) .) ((. .) .))) ((. .) .))
+        (7 2 ((. .) (((. .) (. .)) (. .))) (. (. .)))
+        (7 2 ((. .) (((. .) (. .)) (. .))) ((. .) .))
+        (7 2 ((. (. .)) (. ((. .) (. .)))) (. (. .)))
+        (7 2 ((. (. .)) (. ((. .) (. .)))) ((. .) .))
+        (7 2 ((. (. .)) ((. .) (. (. .)))) (. (. .)))
+        (7 2 ((. (. .)) ((. .) (. (. .)))) ((. .) .))
+        (7 2 ((. (. .)) ((. .) ((. .) .))) (. (. .)))
+        (7 2 ((. (. .)) ((. .) ((. .) .))) ((. .) .))
+        (7 2 ((. (. .)) ((. (. .)) (. .))) (. (. .)))
+        (7 2 ((. (. .)) ((. (. .)) (. .))) ((. .) .))
+        (7 2 ((. (. .)) (((. .) .) (. .))) (. (. .)))
+        (7 2 ((. (. .)) (((. .) .) (. .))) ((. .) .))
+        (7 2 ((. (. .)) (((. .) (. .)) .)) (. (. .)))
+        (7 2 ((. (. .)) (((. .) (. .)) .)) ((. .) .))
+        (7 2 (((. .) .) (. ((. .) (. .)))) (. (. .)))
+        (7 2 (((. .) .) (. ((. .) (. .)))) ((. .) .))
+        (7 2 (((. .) .) ((. .) (. (. .)))) (. (. .)))
+        (7 2 (((. .) .) ((. .) (. (. .)))) ((. .) .))
+        (7 2 (((. .) .) ((. .) ((. .) .))) (. (. .)))
+        (7 2 (((. .) .) ((. .) ((. .) .))) ((. .) .))
+        (7 2 (((. .) .) ((. (. .)) (. .))) (. (. .)))
+        (7 2 (((. .) .) ((. (. .)) (. .))) ((. .) .))
+        (7 2 (((. .) .) (((. .) .) (. .))) (. (. .)))
+        (7 2 (((. .) .) (((. .) .) (. .))) ((. .) .))
+        (7 2 (((. .) .) (((. .) (. .)) .)) (. (. .)))
+        (7 2 (((. .) .) (((. .) (. .)) .)) ((. .) .))
+        (7 2 ((. (. (. .))) (. (. (. .)))) (. (. .)))
+        (7 2 ((. (. (. .))) (. (. (. .)))) ((. .) .))
+        (7 2 ((. (. (. .))) (. ((. .) .))) (. (. .)))
+        (7 2 ((. (. (. .))) (. ((. .) .))) ((. .) .))
+        (7 2 ((. (. (. .))) ((. .) (. .))) (. (. .)))
+        (7 2 ((. (. (. .))) ((. .) (. .))) ((. .) .))
+        (7 2 ((. (. (. .))) ((. (. .)) .)) (. (. .)))
+        (7 2 ((. (. (. .))) ((. (. .)) .)) ((. .) .))
+        (7 2 ((. (. (. .))) (((. .) .) .)) (. (. .)))
+        (7 2 ((. (. (. .))) (((. .) .) .)) ((. .) .))
+        (7 2 ((. ((. .) .)) (. (. (. .)))) (. (. .)))
+        (7 2 ((. ((. .) .)) (. (. (. .)))) ((. .) .))
+        (7 2 ((. ((. .) .)) (. ((. .) .))) (. (. .)))
+        (7 2 ((. ((. .) .)) (. ((. .) .))) ((. .) .))
+        (7 2 ((. ((. .) .)) ((. .) (. .))) (. (. .)))
+        (7 2 ((. ((. .) .)) ((. .) (. .))) ((. .) .))
+        (7 2 ((. ((. .) .)) ((. (. .)) .)) (. (. .)))
+        (7 2 ((. ((. .) .)) ((. (. .)) .)) ((. .) .))
+        (7 2 ((. ((. .) .)) (((. .) .) .)) (. (. .)))
+        (7 2 ((. ((. .) .)) (((. .) .) .)) ((. .) .))
+        (7 2 (((. .) (. .)) (. (. (. .)))) (. (. .)))
+        (7 2 (((. .) (. .)) (. (. (. .)))) ((. .) .))
+        (7 2 (((. .) (. .)) (. ((. .) .))) (. (. .)))
+        (7 2 (((. .) (. .)) (. ((. .) .))) ((. .) .))
+        (7 2 (((. .) (. .)) ((. .) (. .))) (. (. .)))
+        (7 2 (((. .) (. .)) ((. .) (. .))) ((. .) .))
+        (7 2 (((. .) (. .)) ((. (. .)) .)) (. (. .)))
+        (7 2 (((. .) (. .)) ((. (. .)) .)) ((. .) .))
+        (7 2 (((. .) (. .)) (((. .) .) .)) (. (. .)))
+        (7 2 (((. .) (. .)) (((. .) .) .)) ((. .) .))
+        (7 2 (((. (. .)) .) (. (. (. .)))) (. (. .)))
+        (7 2 (((. (. .)) .) (. (. (. .)))) ((. .) .))
+        (7 2 (((. (. .)) .) (. ((. .) .))) (. (. .)))
+        (7 2 (((. (. .)) .) (. ((. .) .))) ((. .) .))
+        (7 2 (((. (. .)) .) ((. .) (. .))) (. (. .)))
+        (7 2 (((. (. .)) .) ((. .) (. .))) ((. .) .))
+        (7 2 (((. (. .)) .) ((. (. .)) .)) (. (. .)))
+        (7 2 (((. (. .)) .) ((. (. .)) .)) ((. .) .))
+        (7 2 (((. (. .)) .) (((. .) .) .)) (. (. .)))
+        (7 2 (((. (. .)) .) (((. .) .) .)) ((. .) .))
+        (7 2 ((((. .) .) .) (. (. (. .)))) (. (. .)))
+        (7 2 ((((. .) .) .) (. (. (. .)))) ((. .) .))
+        (7 2 ((((. .) .) .) (. ((. .) .))) (. (. .)))
+        (7 2 ((((. .) .) .) (. ((. .) .))) ((. .) .))
+        (7 2 ((((. .) .) .) ((. .) (. .))) (. (. .)))
+        (7 2 ((((. .) .) .) ((. .) (. .))) ((. .) .))
+        (7 2 ((((. .) .) .) ((. (. .)) .)) (. (. .)))
+        (7 2 ((((. .) .) .) ((. (. .)) .)) ((. .) .))
+        (7 2 ((((. .) .) .) (((. .) .) .)) (. (. .)))
+        (7 2 ((((. .) .) .) (((. .) .) .)) ((. .) .))
+        (7 2 ((. ((. .) (. .))) (. (. .))) (. (. .)))
+        (7 2 ((. ((. .) (. .))) (. (. .))) ((. .) .))
+        (7 2 ((. ((. .) (. .))) ((. .) .)) (. (. .)))
+        (7 2 ((. ((. .) (. .))) ((. .) .)) ((. .) .))
+        (7 2 (((. .) (. (. .))) (. (. .))) (. (. .)))
+        (7 2 (((. .) (. (. .))) (. (. .))) ((. .) .))
+        (7 2 (((. .) (. (. .))) ((. .) .)) (. (. .)))
+        (7 2 (((. .) (. (. .))) ((. .) .)) ((. .) .))
+        (7 2 (((. .) ((. .) .)) (. (. .))) (. (. .)))
+        (7 2 (((. .) ((. .) .)) (. (. .))) ((. .) .))
+        (7 2 (((. .) ((. .) .)) ((. .) .)) (. (. .)))
+        (7 2 (((. .) ((. .) .)) ((. .) .)) ((. .) .))
+        (7 2 (((. (. .)) (. .)) (. (. .))) (. (. .)))
+        (7 2 (((. (. .)) (. .)) (. (. .))) ((. .) .))
+        (7 2 (((. (. .)) (. .)) ((. .) .)) (. (. .)))
+        (7 2 (((. (. .)) (. .)) ((. .) .)) ((. .) .))
+        (7 2 ((((. .) .) (. .)) (. (. .))) (. (. .)))
+        (7 2 ((((. .) .) (. .)) (. (. .))) ((. .) .))
+        (7 2 ((((. .) .) (. .)) ((. .) .)) (. (. .)))
+        (7 2 ((((. .) .) (. .)) ((. .) .)) ((. .) .))
+        (7 2 ((((. .) (. .)) .) (. (. .))) (. (. .)))
+        (7 2 ((((. .) (. .)) .) (. (. .))) ((. .) .))
+        (7 2 ((((. .) (. .)) .) ((. .) .)) (. (. .)))
+        (7 2 ((((. .) (. .)) .) ((. .) .)) ((. .) .))
+        (7 2 (((. .) ((. .) (. .))) (. .)) (. (. .)))
+        (7 2 (((. .) ((. .) (. .))) (. .)) ((. .) .))
+        (7 2 (((. (. .)) (. (. .))) (. .)) (. (. .)))
+        (7 2 (((. (. .)) (. (. .))) (. .)) ((. .) .))
+        (7 2 (((. (. .)) ((. .) .)) (. .)) (. (. .)))
+        (7 2 (((. (. .)) ((. .) .)) (. .)) ((. .) .))
+        (7 2 ((((. .) .) (. (. .))) (. .)) (. (. .)))
+        (7 2 ((((. .) .) (. (. .))) (. .)) ((. .) .))
+        (7 2 ((((. .) .) ((. .) .)) (. .)) (. (. .)))
+        (7 2 ((((. .) .) ((. .) .)) (. .)) ((. .) .))
+        (7 2 ((((. .) (. .)) (. .)) (. .)) (. (. .)))
+        (7 2 ((((. .) (. .)) (. .)) (. .)) ((. .) .))
+        ((shown 1_274) (total 1_977_836))
+        |}]
+    ;;
+
+    let create_if_almost_balanced = Tree.create_if_almost_balanced
+
+    let%expect_test _ =
+      test_all
+        create_if_almost_balanced
+        ~are_balanced_enough:are_almost_balanced
+        ~have_been_shown:are_balanced;
+      [%expect
+        {|
+        (1 5 (. .) ((. .) (. (. (. .)))))
+        (1 5 (. .) ((. .) (. ((. .) .))))
+        (1 5 (. .) ((. .) ((. (. .)) .)))
+        (1 5 (. .) ((. .) (((. .) .) .)))
+        (1 5 (. .) ((. (. (. .))) (. .)))
+        (1 5 (. .) ((. ((. .) .)) (. .)))
+        (1 5 (. .) (((. (. .)) .) (. .)))
+        (1 5 (. .) ((((. .) .) .) (. .)))
+        (5 1 ((. .) (. (. (. .)))) (. .))
+        (5 1 ((. .) (. ((. .) .))) (. .))
+        (5 1 ((. .) ((. (. .)) .)) (. .))
+        (5 1 ((. .) (((. .) .) .)) (. .))
+        (5 1 ((. (. (. .))) (. .)) (. .))
+        (5 1 ((. ((. .) .)) (. .)) (. .))
+        (5 1 (((. (. .)) .) (. .)) (. .))
+        (5 1 ((((. .) .) .) (. .)) (. .))
+        (1 6 (. .) ((. .) (. ((. .) (. .)))))
+        (1 6 (. .) ((. .) ((. .) (. (. .)))))
+        (1 6 (. .) ((. .) ((. .) ((. .) .))))
+        (1 6 (. .) ((. .) ((. (. .)) (. .))))
+        (1 6 (. .) ((. .) (((. .) .) (. .))))
+        (1 6 (. .) ((. .) (((. .) (. .)) .)))
+        (1 6 (. .) ((. (. .)) (. (. (. .)))))
+        (1 6 (. .) ((. (. .)) (. ((. .) .))))
+        (1 6 (. .) ((. (. .)) ((. (. .)) .)))
+        (1 6 (. .) ((. (. .)) (((. .) .) .)))
+        (1 6 (. .) (((. .) .) (. (. (. .)))))
+        (1 6 (. .) (((. .) .) (. ((. .) .))))
+        (1 6 (. .) (((. .) .) ((. (. .)) .)))
+        (1 6 (. .) (((. .) .) (((. .) .) .)))
+        (1 6 (. .) ((. (. (. .))) (. (. .))))
+        (1 6 (. .) ((. (. (. .))) ((. .) .)))
+        (1 6 (. .) ((. ((. .) .)) (. (. .))))
+        (1 6 (. .) ((. ((. .) .)) ((. .) .)))
+        (1 6 (. .) (((. (. .)) .) (. (. .))))
+        (1 6 (. .) (((. (. .)) .) ((. .) .)))
+        (1 6 (. .) ((((. .) .) .) (. (. .))))
+        (1 6 (. .) ((((. .) .) .) ((. .) .)))
+        (1 6 (. .) ((. ((. .) (. .))) (. .)))
+        (1 6 (. .) (((. .) (. (. .))) (. .)))
+        (1 6 (. .) (((. .) ((. .) .)) (. .)))
+        (1 6 (. .) (((. (. .)) (. .)) (. .)))
+        (1 6 (. .) ((((. .) .) (. .)) (. .)))
+        (1 6 (. .) ((((. .) (. .)) .) (. .)))
+        (6 1 ((. .) (. ((. .) (. .)))) (. .))
+        (6 1 ((. .) ((. .) (. (. .)))) (. .))
+        (6 1 ((. .) ((. .) ((. .) .))) (. .))
+        (6 1 ((. .) ((. (. .)) (. .))) (. .))
+        (6 1 ((. .) (((. .) .) (. .))) (. .))
+        (6 1 ((. .) (((. .) (. .)) .)) (. .))
+        (6 1 ((. (. .)) (. (. (. .)))) (. .))
+        (6 1 ((. (. .)) (. ((. .) .))) (. .))
+        (6 1 ((. (. .)) ((. (. .)) .)) (. .))
+        (6 1 ((. (. .)) (((. .) .) .)) (. .))
+        (6 1 (((. .) .) (. (. (. .)))) (. .))
+        (6 1 (((. .) .) (. ((. .) .))) (. .))
+        (6 1 (((. .) .) ((. (. .)) .)) (. .))
+        (6 1 (((. .) .) (((. .) .) .)) (. .))
+        (6 1 ((. (. (. .))) (. (. .))) (. .))
+        (6 1 ((. (. (. .))) ((. .) .)) (. .))
+        (6 1 ((. ((. .) .)) (. (. .))) (. .))
+        (6 1 ((. ((. .) .)) ((. .) .)) (. .))
+        (6 1 (((. (. .)) .) (. (. .))) (. .))
+        (6 1 (((. (. .)) .) ((. .) .)) (. .))
+        (6 1 ((((. .) .) .) (. (. .))) (. .))
+        (6 1 ((((. .) .) .) ((. .) .)) (. .))
+        (6 1 ((. ((. .) (. .))) (. .)) (. .))
+        (6 1 (((. .) (. (. .))) (. .)) (. .))
+        (6 1 (((. .) ((. .) .)) (. .)) (. .))
+        (6 1 (((. (. .)) (. .)) (. .)) (. .))
+        (6 1 ((((. .) .) (. .)) (. .)) (. .))
+        (6 1 ((((. .) (. .)) .) (. .)) (. .))
+        (1 7 (. .) ((. .) ((. .) ((. .) (. .)))))
+        (1 7 (. .) ((. .) ((. (. .)) (. (. .)))))
+        (1 7 (. .) ((. .) ((. (. .)) ((. .) .))))
+        (1 7 (. .) ((. .) (((. .) .) (. (. .)))))
+        (1 7 (. .) ((. .) (((. .) .) ((. .) .))))
+        (1 7 (. .) ((. .) (((. .) (. .)) (. .))))
+        (1 7 (. .) ((. (. .)) (. ((. .) (. .)))))
+        (1 7 (. .) ((. (. .)) ((. .) (. (. .)))))
+        (1 7 (. .) ((. (. .)) ((. .) ((. .) .))))
+        (1 7 (. .) ((. (. .)) ((. (. .)) (. .))))
+        (1 7 (. .) ((. (. .)) (((. .) .) (. .))))
+        (1 7 (. .) ((. (. .)) (((. .) (. .)) .)))
+        (1 7 (. .) (((. .) .) (. ((. .) (. .)))))
+        (1 7 (. .) (((. .) .) ((. .) (. (. .)))))
+        (1 7 (. .) (((. .) .) ((. .) ((. .) .))))
+        (1 7 (. .) (((. .) .) ((. (. .)) (. .))))
+        (1 7 (. .) (((. .) .) (((. .) .) (. .))))
+        (1 7 (. .) (((. .) .) (((. .) (. .)) .)))
+        (1 7 (. .) ((. (. (. .))) (. (. (. .)))))
+        (1 7 (. .) ((. (. (. .))) (. ((. .) .))))
+        (1 7 (. .) ((. (. (. .))) ((. .) (. .))))
+        (1 7 (. .) ((. (. (. .))) ((. (. .)) .)))
+        (1 7 (. .) ((. (. (. .))) (((. .) .) .)))
+        (1 7 (. .) ((. ((. .) .)) (. (. (. .)))))
+        (1 7 (. .) ((. ((. .) .)) (. ((. .) .))))
+        (1 7 (. .) ((. ((. .) .)) ((. .) (. .))))
+        (1 7 (. .) ((. ((. .) .)) ((. (. .)) .)))
+        (1 7 (. .) ((. ((. .) .)) (((. .) .) .)))
+        (1 7 (. .) (((. .) (. .)) (. (. (. .)))))
+        (1 7 (. .) (((. .) (. .)) (. ((. .) .))))
+        (1 7 (. .) (((. .) (. .)) ((. (. .)) .)))
+        (1 7 (. .) (((. .) (. .)) (((. .) .) .)))
+        (1 7 (. .) (((. (. .)) .) (. (. (. .)))))
+        (1 7 (. .) (((. (. .)) .) (. ((. .) .))))
+        (1 7 (. .) (((. (. .)) .) ((. .) (. .))))
+        (1 7 (. .) (((. (. .)) .) ((. (. .)) .)))
+        (1 7 (. .) (((. (. .)) .) (((. .) .) .)))
+        (1 7 (. .) ((((. .) .) .) (. (. (. .)))))
+        (1 7 (. .) ((((. .) .) .) (. ((. .) .))))
+        (1 7 (. .) ((((. .) .) .) ((. .) (. .))))
+        (1 7 (. .) ((((. .) .) .) ((. (. .)) .)))
+        (1 7 (. .) ((((. .) .) .) (((. .) .) .)))
+        (1 7 (. .) ((. ((. .) (. .))) (. (. .))))
+        (1 7 (. .) ((. ((. .) (. .))) ((. .) .)))
+        (1 7 (. .) (((. .) (. (. .))) (. (. .))))
+        (1 7 (. .) (((. .) (. (. .))) ((. .) .)))
+        (1 7 (. .) (((. .) ((. .) .)) (. (. .))))
+        (1 7 (. .) (((. .) ((. .) .)) ((. .) .)))
+        (1 7 (. .) (((. (. .)) (. .)) (. (. .))))
+        (1 7 (. .) (((. (. .)) (. .)) ((. .) .)))
+        (1 7 (. .) ((((. .) .) (. .)) (. (. .))))
+        (1 7 (. .) ((((. .) .) (. .)) ((. .) .)))
+        (1 7 (. .) ((((. .) (. .)) .) (. (. .))))
+        (1 7 (. .) ((((. .) (. .)) .) ((. .) .)))
+        (1 7 (. .) (((. .) ((. .) (. .))) (. .)))
+        (1 7 (. .) (((. (. .)) (. (. .))) (. .)))
+        (1 7 (. .) (((. (. .)) ((. .) .)) (. .)))
+        (1 7 (. .) ((((. .) .) (. (. .))) (. .)))
+        (1 7 (. .) ((((. .) .) ((. .) .)) (. .)))
+        (1 7 (. .) ((((. .) (. .)) (. .)) (. .)))
+        (7 1 ((. .) ((. .) ((. .) (. .)))) (. .))
+        (7 1 ((. .) ((. (. .)) (. (. .)))) (. .))
+        (7 1 ((. .) ((. (. .)) ((. .) .))) (. .))
+        (7 1 ((. .) (((. .) .) (. (. .)))) (. .))
+        (7 1 ((. .) (((. .) .) ((. .) .))) (. .))
+        (7 1 ((. .) (((. .) (. .)) (. .))) (. .))
+        (7 1 ((. (. .)) (. ((. .) (. .)))) (. .))
+        (7 1 ((. (. .)) ((. .) (. (. .)))) (. .))
+        (7 1 ((. (. .)) ((. .) ((. .) .))) (. .))
+        (7 1 ((. (. .)) ((. (. .)) (. .))) (. .))
+        (7 1 ((. (. .)) (((. .) .) (. .))) (. .))
+        (7 1 ((. (. .)) (((. .) (. .)) .)) (. .))
+        (7 1 (((. .) .) (. ((. .) (. .)))) (. .))
+        (7 1 (((. .) .) ((. .) (. (. .)))) (. .))
+        (7 1 (((. .) .) ((. .) ((. .) .))) (. .))
+        (7 1 (((. .) .) ((. (. .)) (. .))) (. .))
+        (7 1 (((. .) .) (((. .) .) (. .))) (. .))
+        (7 1 (((. .) .) (((. .) (. .)) .)) (. .))
+        (7 1 ((. (. (. .))) (. (. (. .)))) (. .))
+        (7 1 ((. (. (. .))) (. ((. .) .))) (. .))
+        (7 1 ((. (. (. .))) ((. .) (. .))) (. .))
+        (7 1 ((. (. (. .))) ((. (. .)) .)) (. .))
+        (7 1 ((. (. (. .))) (((. .) .) .)) (. .))
+        (7 1 ((. ((. .) .)) (. (. (. .)))) (. .))
+        (7 1 ((. ((. .) .)) (. ((. .) .))) (. .))
+        (7 1 ((. ((. .) .)) ((. .) (. .))) (. .))
+        (7 1 ((. ((. .) .)) ((. (. .)) .)) (. .))
+        (7 1 ((. ((. .) .)) (((. .) .) .)) (. .))
+        (7 1 (((. .) (. .)) (. (. (. .)))) (. .))
+        (7 1 (((. .) (. .)) (. ((. .) .))) (. .))
+        (7 1 (((. .) (. .)) ((. (. .)) .)) (. .))
+        (7 1 (((. .) (. .)) (((. .) .) .)) (. .))
+        (7 1 (((. (. .)) .) (. (. (. .)))) (. .))
+        (7 1 (((. (. .)) .) (. ((. .) .))) (. .))
+        (7 1 (((. (. .)) .) ((. .) (. .))) (. .))
+        (7 1 (((. (. .)) .) ((. (. .)) .)) (. .))
+        (7 1 (((. (. .)) .) (((. .) .) .)) (. .))
+        (7 1 ((((. .) .) .) (. (. (. .)))) (. .))
+        (7 1 ((((. .) .) .) (. ((. .) .))) (. .))
+        (7 1 ((((. .) .) .) ((. .) (. .))) (. .))
+        (7 1 ((((. .) .) .) ((. (. .)) .)) (. .))
+        (7 1 ((((. .) .) .) (((. .) .) .)) (. .))
+        (7 1 ((. ((. .) (. .))) (. (. .))) (. .))
+        (7 1 ((. ((. .) (. .))) ((. .) .)) (. .))
+        (7 1 (((. .) (. (. .))) (. (. .))) (. .))
+        (7 1 (((. .) (. (. .))) ((. .) .)) (. .))
+        (7 1 (((. .) ((. .) .)) (. (. .))) (. .))
+        (7 1 (((. .) ((. .) .)) ((. .) .)) (. .))
+        (7 1 (((. (. .)) (. .)) (. (. .))) (. .))
+        (7 1 (((. (. .)) (. .)) ((. .) .)) (. .))
+        (7 1 ((((. .) .) (. .)) (. (. .))) (. .))
+        (7 1 ((((. .) .) (. .)) ((. .) .)) (. .))
+        (7 1 ((((. .) (. .)) .) (. (. .))) (. .))
+        (7 1 ((((. .) (. .)) .) ((. .) .)) (. .))
+        (7 1 (((. .) ((. .) (. .))) (. .)) (. .))
+        (7 1 (((. (. .)) (. (. .))) (. .)) (. .))
+        (7 1 (((. (. .)) ((. .) .)) (. .)) (. .))
+        (7 1 ((((. .) .) (. (. .))) (. .)) (. .))
+        (7 1 ((((. .) .) ((. .) .)) (. .)) (. .))
+        (7 1 ((((. .) (. .)) (. .)) (. .)) (. .))
+        (1 8 (. .) ((. .) ((. (. .)) ((. .) (. .)))))
+        (1 8 (. .) ((. .) (((. .) .) ((. .) (. .)))))
+        (1 8 (. .) ((. .) (((. .) (. .)) (. (. .)))))
+        (1 8 (. .) ((. .) (((. .) (. .)) ((. .) .))))
+        (1 8 (. .) ((. (. .)) ((. .) ((. .) (. .)))))
+        (1 8 (. .) ((. (. .)) ((. (. .)) (. (. .)))))
+        (1 8 (. .) ((. (. .)) ((. (. .)) ((. .) .))))
+        (1 8 (. .) ((. (. .)) (((. .) .) (. (. .)))))
+        (1 8 (. .) ((. (. .)) (((. .) .) ((. .) .))))
+        (1 8 (. .) ((. (. .)) (((. .) (. .)) (. .))))
+        (1 8 (. .) (((. .) .) ((. .) ((. .) (. .)))))
+        (1 8 (. .) (((. .) .) ((. (. .)) (. (. .)))))
+        (1 8 (. .) (((. .) .) ((. (. .)) ((. .) .))))
+        (1 8 (. .) (((. .) .) (((. .) .) (. (. .)))))
+        (1 8 (. .) (((. .) .) (((. .) .) ((. .) .))))
+        (1 8 (. .) (((. .) .) (((. .) (. .)) (. .))))
+        (1 8 (. .) ((. (. (. .))) (. ((. .) (. .)))))
+        (1 8 (. .) ((. (. (. .))) ((. .) (. (. .)))))
+        (1 8 (. .) ((. (. (. .))) ((. .) ((. .) .))))
+        (1 8 (. .) ((. (. (. .))) ((. (. .)) (. .))))
+        (1 8 (. .) ((. (. (. .))) (((. .) .) (. .))))
+        (1 8 (. .) ((. (. (. .))) (((. .) (. .)) .)))
+        (1 8 (. .) ((. ((. .) .)) (. ((. .) (. .)))))
+        (1 8 (. .) ((. ((. .) .)) ((. .) (. (. .)))))
+        (1 8 (. .) ((. ((. .) .)) ((. .) ((. .) .))))
+        (1 8 (. .) ((. ((. .) .)) ((. (. .)) (. .))))
+        (1 8 (. .) ((. ((. .) .)) (((. .) .) (. .))))
+        (1 8 (. .) ((. ((. .) .)) (((. .) (. .)) .)))
+        (1 8 (. .) (((. .) (. .)) (. ((. .) (. .)))))
+        (1 8 (. .) (((. .) (. .)) ((. .) (. (. .)))))
+        (1 8 (. .) (((. .) (. .)) ((. .) ((. .) .))))
+        (1 8 (. .) (((. .) (. .)) ((. (. .)) (. .))))
+        (1 8 (. .) (((. .) (. .)) (((. .) .) (. .))))
+        (1 8 (. .) (((. .) (. .)) (((. .) (. .)) .)))
+        (1 8 (. .) (((. (. .)) .) (. ((. .) (. .)))))
+        (1 8 (. .) (((. (. .)) .) ((. .) (. (. .)))))
+        (1 8 (. .) (((. (. .)) .) ((. .) ((. .) .))))
+        (1 8 (. .) (((. (. .)) .) ((. (. .)) (. .))))
+        (1 8 (. .) (((. (. .)) .) (((. .) .) (. .))))
+        (1 8 (. .) (((. (. .)) .) (((. .) (. .)) .)))
+        (1 8 (. .) ((((. .) .) .) (. ((. .) (. .)))))
+        (1 8 (. .) ((((. .) .) .) ((. .) (. (. .)))))
+        (1 8 (. .) ((((. .) .) .) ((. .) ((. .) .))))
+        (1 8 (. .) ((((. .) .) .) ((. (. .)) (. .))))
+        (1 8 (. .) ((((. .) .) .) (((. .) .) (. .))))
+        (1 8 (. .) ((((. .) .) .) (((. .) (. .)) .)))
+        (1 8 (. .) ((. ((. .) (. .))) (. (. (. .)))))
+        (1 8 (. .) ((. ((. .) (. .))) (. ((. .) .))))
+        (1 8 (. .) ((. ((. .) (. .))) ((. .) (. .))))
+        (1 8 (. .) ((. ((. .) (. .))) ((. (. .)) .)))
+        (1 8 (. .) ((. ((. .) (. .))) (((. .) .) .)))
+        (1 8 (. .) (((. .) (. (. .))) (. (. (. .)))))
+        (1 8 (. .) (((. .) (. (. .))) (. ((. .) .))))
+        (1 8 (. .) (((. .) (. (. .))) ((. .) (. .))))
+        (1 8 (. .) (((. .) (. (. .))) ((. (. .)) .)))
+        (1 8 (. .) (((. .) (. (. .))) (((. .) .) .)))
+        (1 8 (. .) (((. .) ((. .) .)) (. (. (. .)))))
+        (1 8 (. .) (((. .) ((. .) .)) (. ((. .) .))))
+        (1 8 (. .) (((. .) ((. .) .)) ((. .) (. .))))
+        (1 8 (. .) (((. .) ((. .) .)) ((. (. .)) .)))
+        (1 8 (. .) (((. .) ((. .) .)) (((. .) .) .)))
+        (1 8 (. .) (((. (. .)) (. .)) (. (. (. .)))))
+        (1 8 (. .) (((. (. .)) (. .)) (. ((. .) .))))
+        (1 8 (. .) (((. (. .)) (. .)) ((. .) (. .))))
+        (1 8 (. .) (((. (. .)) (. .)) ((. (. .)) .)))
+        (1 8 (. .) (((. (. .)) (. .)) (((. .) .) .)))
+        (1 8 (. .) ((((. .) .) (. .)) (. (. (. .)))))
+        (1 8 (. .) ((((. .) .) (. .)) (. ((. .) .))))
+        (1 8 (. .) ((((. .) .) (. .)) ((. .) (. .))))
+        (1 8 (. .) ((((. .) .) (. .)) ((. (. .)) .)))
+        (1 8 (. .) ((((. .) .) (. .)) (((. .) .) .)))
+        (1 8 (. .) ((((. .) (. .)) .) (. (. (. .)))))
+        (1 8 (. .) ((((. .) (. .)) .) (. ((. .) .))))
+        (1 8 (. .) ((((. .) (. .)) .) ((. .) (. .))))
+        (1 8 (. .) ((((. .) (. .)) .) ((. (. .)) .)))
+        (1 8 (. .) ((((. .) (. .)) .) (((. .) .) .)))
+        (1 8 (. .) (((. .) ((. .) (. .))) (. (. .))))
+        (1 8 (. .) (((. .) ((. .) (. .))) ((. .) .)))
+        (1 8 (. .) (((. (. .)) (. (. .))) (. (. .))))
+        (1 8 (. .) (((. (. .)) (. (. .))) ((. .) .)))
+        (1 8 (. .) (((. (. .)) ((. .) .)) (. (. .))))
+        (1 8 (. .) (((. (. .)) ((. .) .)) ((. .) .)))
+        (1 8 (. .) ((((. .) .) (. (. .))) (. (. .))))
+        (1 8 (. .) ((((. .) .) (. (. .))) ((. .) .)))
+        (1 8 (. .) ((((. .) .) ((. .) .)) (. (. .))))
+        (1 8 (. .) ((((. .) .) ((. .) .)) ((. .) .)))
+        (1 8 (. .) ((((. .) (. .)) (. .)) (. (. .))))
+        (1 8 (. .) ((((. .) (. .)) (. .)) ((. .) .)))
+        (1 8 (. .) (((. (. .)) ((. .) (. .))) (. .)))
+        (1 8 (. .) ((((. .) .) ((. .) (. .))) (. .)))
+        (1 8 (. .) ((((. .) (. .)) (. (. .))) (. .)))
+        (1 8 (. .) ((((. .) (. .)) ((. .) .)) (. .)))
+        (8 1 ((. .) ((. (. .)) ((. .) (. .)))) (. .))
+        (8 1 ((. .) (((. .) .) ((. .) (. .)))) (. .))
+        (8 1 ((. .) (((. .) (. .)) (. (. .)))) (. .))
+        (8 1 ((. .) (((. .) (. .)) ((. .) .))) (. .))
+        (8 1 ((. (. .)) ((. .) ((. .) (. .)))) (. .))
+        (8 1 ((. (. .)) ((. (. .)) (. (. .)))) (. .))
+        (8 1 ((. (. .)) ((. (. .)) ((. .) .))) (. .))
+        (8 1 ((. (. .)) (((. .) .) (. (. .)))) (. .))
+        (8 1 ((. (. .)) (((. .) .) ((. .) .))) (. .))
+        (8 1 ((. (. .)) (((. .) (. .)) (. .))) (. .))
+        (8 1 (((. .) .) ((. .) ((. .) (. .)))) (. .))
+        (8 1 (((. .) .) ((. (. .)) (. (. .)))) (. .))
+        (8 1 (((. .) .) ((. (. .)) ((. .) .))) (. .))
+        (8 1 (((. .) .) (((. .) .) (. (. .)))) (. .))
+        (8 1 (((. .) .) (((. .) .) ((. .) .))) (. .))
+        (8 1 (((. .) .) (((. .) (. .)) (. .))) (. .))
+        (8 1 ((. (. (. .))) (. ((. .) (. .)))) (. .))
+        (8 1 ((. (. (. .))) ((. .) (. (. .)))) (. .))
+        (8 1 ((. (. (. .))) ((. .) ((. .) .))) (. .))
+        (8 1 ((. (. (. .))) ((. (. .)) (. .))) (. .))
+        (8 1 ((. (. (. .))) (((. .) .) (. .))) (. .))
+        (8 1 ((. (. (. .))) (((. .) (. .)) .)) (. .))
+        (8 1 ((. ((. .) .)) (. ((. .) (. .)))) (. .))
+        (8 1 ((. ((. .) .)) ((. .) (. (. .)))) (. .))
+        (8 1 ((. ((. .) .)) ((. .) ((. .) .))) (. .))
+        (8 1 ((. ((. .) .)) ((. (. .)) (. .))) (. .))
+        (8 1 ((. ((. .) .)) (((. .) .) (. .))) (. .))
+        (8 1 ((. ((. .) .)) (((. .) (. .)) .)) (. .))
+        (8 1 (((. .) (. .)) (. ((. .) (. .)))) (. .))
+        (8 1 (((. .) (. .)) ((. .) (. (. .)))) (. .))
+        (8 1 (((. .) (. .)) ((. .) ((. .) .))) (. .))
+        (8 1 (((. .) (. .)) ((. (. .)) (. .))) (. .))
+        (8 1 (((. .) (. .)) (((. .) .) (. .))) (. .))
+        (8 1 (((. .) (. .)) (((. .) (. .)) .)) (. .))
+        (8 1 (((. (. .)) .) (. ((. .) (. .)))) (. .))
+        (8 1 (((. (. .)) .) ((. .) (. (. .)))) (. .))
+        (8 1 (((. (. .)) .) ((. .) ((. .) .))) (. .))
+        (8 1 (((. (. .)) .) ((. (. .)) (. .))) (. .))
+        (8 1 (((. (. .)) .) (((. .) .) (. .))) (. .))
+        (8 1 (((. (. .)) .) (((. .) (. .)) .)) (. .))
+        (8 1 ((((. .) .) .) (. ((. .) (. .)))) (. .))
+        (8 1 ((((. .) .) .) ((. .) (. (. .)))) (. .))
+        (8 1 ((((. .) .) .) ((. .) ((. .) .))) (. .))
+        (8 1 ((((. .) .) .) ((. (. .)) (. .))) (. .))
+        (8 1 ((((. .) .) .) (((. .) .) (. .))) (. .))
+        (8 1 ((((. .) .) .) (((. .) (. .)) .)) (. .))
+        (8 1 ((. ((. .) (. .))) (. (. (. .)))) (. .))
+        (8 1 ((. ((. .) (. .))) (. ((. .) .))) (. .))
+        (8 1 ((. ((. .) (. .))) ((. .) (. .))) (. .))
+        (8 1 ((. ((. .) (. .))) ((. (. .)) .)) (. .))
+        (8 1 ((. ((. .) (. .))) (((. .) .) .)) (. .))
+        (8 1 (((. .) (. (. .))) (. (. (. .)))) (. .))
+        (8 1 (((. .) (. (. .))) (. ((. .) .))) (. .))
+        (8 1 (((. .) (. (. .))) ((. .) (. .))) (. .))
+        (8 1 (((. .) (. (. .))) ((. (. .)) .)) (. .))
+        (8 1 (((. .) (. (. .))) (((. .) .) .)) (. .))
+        (8 1 (((. .) ((. .) .)) (. (. (. .)))) (. .))
+        (8 1 (((. .) ((. .) .)) (. ((. .) .))) (. .))
+        (8 1 (((. .) ((. .) .)) ((. .) (. .))) (. .))
+        (8 1 (((. .) ((. .) .)) ((. (. .)) .)) (. .))
+        (8 1 (((. .) ((. .) .)) (((. .) .) .)) (. .))
+        (8 1 (((. (. .)) (. .)) (. (. (. .)))) (. .))
+        (8 1 (((. (. .)) (. .)) (. ((. .) .))) (. .))
+        (8 1 (((. (. .)) (. .)) ((. .) (. .))) (. .))
+        (8 1 (((. (. .)) (. .)) ((. (. .)) .)) (. .))
+        (8 1 (((. (. .)) (. .)) (((. .) .) .)) (. .))
+        (8 1 ((((. .) .) (. .)) (. (. (. .)))) (. .))
+        (8 1 ((((. .) .) (. .)) (. ((. .) .))) (. .))
+        (8 1 ((((. .) .) (. .)) ((. .) (. .))) (. .))
+        (8 1 ((((. .) .) (. .)) ((. (. .)) .)) (. .))
+        (8 1 ((((. .) .) (. .)) (((. .) .) .)) (. .))
+        (8 1 ((((. .) (. .)) .) (. (. (. .)))) (. .))
+        (8 1 ((((. .) (. .)) .) (. ((. .) .))) (. .))
+        (8 1 ((((. .) (. .)) .) ((. .) (. .))) (. .))
+        (8 1 ((((. .) (. .)) .) ((. (. .)) .)) (. .))
+        (8 1 ((((. .) (. .)) .) (((. .) .) .)) (. .))
+        (8 1 (((. .) ((. .) (. .))) (. (. .))) (. .))
+        (8 1 (((. .) ((. .) (. .))) ((. .) .)) (. .))
+        (8 1 (((. (. .)) (. (. .))) (. (. .))) (. .))
+        (8 1 (((. (. .)) (. (. .))) ((. .) .)) (. .))
+        (8 1 (((. (. .)) ((. .) .)) (. (. .))) (. .))
+        (8 1 (((. (. .)) ((. .) .)) ((. .) .)) (. .))
+        (8 1 ((((. .) .) (. (. .))) (. (. .))) (. .))
+        (8 1 ((((. .) .) (. (. .))) ((. .) .)) (. .))
+        (8 1 ((((. .) .) ((. .) .)) (. (. .))) (. .))
+        (8 1 ((((. .) .) ((. .) .)) ((. .) .)) (. .))
+        (8 1 ((((. .) (. .)) (. .)) (. (. .))) (. .))
+        (8 1 ((((. .) (. .)) (. .)) ((. .) .)) (. .))
+        (8 1 (((. (. .)) ((. .) (. .))) (. .)) (. .))
+        (8 1 ((((. .) .) ((. .) (. .))) (. .)) (. .))
+        (8 1 ((((. .) (. .)) (. (. .))) (. .)) (. .))
+        (8 1 ((((. .) (. .)) ((. .) .)) (. .)) (. .))
+        ((shown 376) (total 2_732_440))
+        |}]
+    ;;
+
+    let create_even_if_completely_unbalanced = Tree.create_even_if_completely_unbalanced
+
+    let%expect_test _ =
+      test_all
+        create_even_if_completely_unbalanced
+        ~are_balanced_enough:(fun _ _ -> true)
+        ~have_been_shown:are_almost_balanced;
+      [%expect
+        {|
+        (1 8 (. .) ((. (. .)) ((. .) (. (. (. .))))))
+        (1 8 (. .) ((. (. .)) ((. .) (. ((. .) .)))))
+        (1 8 (. .) ((. (. .)) ((. .) ((. (. .)) .))))
+        (1 8 (. .) ((. (. .)) ((. .) (((. .) .) .))))
+        (1 8 (. .) ((. (. .)) ((. (. (. .))) (. .))))
+        (1 8 (. .) ((. (. .)) ((. ((. .) .)) (. .))))
+        (1 8 (. .) ((. (. .)) (((. (. .)) .) (. .))))
+        (1 8 (. .) ((. (. .)) ((((. .) .) .) (. .))))
+        (1 8 (. .) (((. .) .) ((. .) (. (. (. .))))))
+        (1 8 (. .) (((. .) .) ((. .) (. ((. .) .)))))
+        (1 8 (. .) (((. .) .) ((. .) ((. (. .)) .))))
+        (1 8 (. .) (((. .) .) ((. .) (((. .) .) .))))
+        (1 8 (. .) (((. .) .) ((. (. (. .))) (. .))))
+        (1 8 (. .) (((. .) .) ((. ((. .) .)) (. .))))
+        (1 8 (. .) (((. .) .) (((. (. .)) .) (. .))))
+        (1 8 (. .) (((. .) .) ((((. .) .) .) (. .))))
+        (1 8 (. .) (((. .) (. (. (. .)))) (. (. .))))
+        (1 8 (. .) (((. .) (. (. (. .)))) ((. .) .)))
+        (1 8 (. .) (((. .) (. ((. .) .))) (. (. .))))
+        (1 8 (. .) (((. .) (. ((. .) .))) ((. .) .)))
+        (1 8 (. .) (((. .) ((. (. .)) .)) (. (. .))))
+        (1 8 (. .) (((. .) ((. (. .)) .)) ((. .) .)))
+        (1 8 (. .) (((. .) (((. .) .) .)) (. (. .))))
+        (1 8 (. .) (((. .) (((. .) .) .)) ((. .) .)))
+        (1 8 (. .) (((. (. (. .))) (. .)) (. (. .))))
+        (1 8 (. .) (((. (. (. .))) (. .)) ((. .) .)))
+        (1 8 (. .) (((. ((. .) .)) (. .)) (. (. .))))
+        (1 8 (. .) (((. ((. .) .)) (. .)) ((. .) .)))
+        (1 8 (. .) ((((. (. .)) .) (. .)) (. (. .))))
+        (1 8 (. .) ((((. (. .)) .) (. .)) ((. .) .)))
+        (1 8 (. .) (((((. .) .) .) (. .)) (. (. .))))
+        (1 8 (. .) (((((. .) .) .) (. .)) ((. .) .)))
+        (8 1 ((. (. .)) ((. .) (. (. (. .))))) (. .))
+        (8 1 ((. (. .)) ((. .) (. ((. .) .)))) (. .))
+        (8 1 ((. (. .)) ((. .) ((. (. .)) .))) (. .))
+        (8 1 ((. (. .)) ((. .) (((. .) .) .))) (. .))
+        (8 1 ((. (. .)) ((. (. (. .))) (. .))) (. .))
+        (8 1 ((. (. .)) ((. ((. .) .)) (. .))) (. .))
+        (8 1 ((. (. .)) (((. (. .)) .) (. .))) (. .))
+        (8 1 ((. (. .)) ((((. .) .) .) (. .))) (. .))
+        (8 1 (((. .) .) ((. .) (. (. (. .))))) (. .))
+        (8 1 (((. .) .) ((. .) (. ((. .) .)))) (. .))
+        (8 1 (((. .) .) ((. .) ((. (. .)) .))) (. .))
+        (8 1 (((. .) .) ((. .) (((. .) .) .))) (. .))
+        (8 1 (((. .) .) ((. (. (. .))) (. .))) (. .))
+        (8 1 (((. .) .) ((. ((. .) .)) (. .))) (. .))
+        (8 1 (((. .) .) (((. (. .)) .) (. .))) (. .))
+        (8 1 (((. .) .) ((((. .) .) .) (. .))) (. .))
+        (8 1 (((. .) (. (. (. .)))) (. (. .))) (. .))
+        (8 1 (((. .) (. (. (. .)))) ((. .) .)) (. .))
+        (8 1 (((. .) (. ((. .) .))) (. (. .))) (. .))
+        (8 1 (((. .) (. ((. .) .))) ((. .) .)) (. .))
+        (8 1 (((. .) ((. (. .)) .)) (. (. .))) (. .))
+        (8 1 (((. .) ((. (. .)) .)) ((. .) .)) (. .))
+        (8 1 (((. .) (((. .) .) .)) (. (. .))) (. .))
+        (8 1 (((. .) (((. .) .) .)) ((. .) .)) (. .))
+        (8 1 (((. (. (. .))) (. .)) (. (. .))) (. .))
+        (8 1 (((. (. (. .))) (. .)) ((. .) .)) (. .))
+        (8 1 (((. ((. .) .)) (. .)) (. (. .))) (. .))
+        (8 1 (((. ((. .) .)) (. .)) ((. .) .)) (. .))
+        (8 1 ((((. (. .)) .) (. .)) (. (. .))) (. .))
+        (8 1 ((((. (. .)) .) (. .)) ((. .) .)) (. .))
+        (8 1 (((((. .) .) .) (. .)) (. (. .))) (. .))
+        (8 1 (((((. .) .) .) (. .)) ((. .) .)) (. .))
+        ((shown 64) (total 5_812_834))
+        |}]
+    ;;
+  end
+  in
+  ()
+;;
+
+let () =
+  test
+    (module struct
+      type t = unit Set.Private.Tree.t
+
+      let balance_invariants = Set.Private.Tree.balance_invariants
+      let are_balanced = Set.Private.Tree.are_balanced
+      let are_almost_balanced = Set.Private.Tree.are_almost_balanced
+      let expose t = Option.map (Set.Private.Tree.expose t) ~f:(fun (l, (), r) -> l, r)
+      let empty = Set.Private.Tree.empty
+      let create_if_balanced l r = Set.Private.Tree.create_if_balanced l () r
+
+      let create_if_almost_balanced l r =
+        Set.Private.Tree.create_if_almost_balanced l () r
+      ;;
+
+      let create_even_if_completely_unbalanced l r =
+        Set.Private.Tree.create_even_if_completely_unbalanced l () r
+      ;;
+    end)
+[@@alert "-set_private"]
+;;
+
+let () =
+  test
+    (module struct
+      type t = (unit, unit) Map.Private.Tree.t
+
+      let balance_invariants = Map.Private.Tree.balance_invariants
+      let are_balanced = Map.Private.Tree.are_balanced
+      let are_almost_balanced = Map.Private.Tree.are_almost_balanced
+
+      let expose t =
+        Option.map (Map.Private.Tree.expose t) ~f:(fun (l, (), (), r) -> l, r)
+      ;;
+
+      let empty = Map.Private.Tree.empty
+      let create_if_balanced l r = Map.Private.Tree.create_if_balanced l () () r
+
+      let create_if_almost_balanced l r =
+        Map.Private.Tree.create_if_almost_balanced l () () r
+      ;;
+
+      let create_even_if_completely_unbalanced l r =
+        Map.Private.Tree.create_even_if_completely_unbalanced l () () r
+      ;;
+    end)
+[@@alert "-map_private"]
+;;
diff --git a/test/test_map_and_set_internals.mli b/test/test_map_and_set_internals.mli
new file mode 100644
index 00000000..74bb7298
--- /dev/null
+++ b/test/test_map_and_set_internals.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
diff --git a/test/test_map_interface.ml b/test/test_map_interface.ml
index 77974b58..0aa2dec4 100644
--- a/test/test_map_interface.ml
+++ b/test/test_map_interface.ml
@@ -9,12 +9,12 @@ module _ : sig
   type ('a, 'b, 'c) t
 
   include
-    Creators_and_accessors_generic
-      with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
-      with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Map.Using_comparator.Tree.t
-      with type 'k key := 'k
-      with type 'c cmp := 'c
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_first_class_module.t
+    Creators_and_accessors_and_transformers_generic
+    with type ('a, 'b, 'c) t := ('a, 'b, 'c) t
+    with type ('a, 'b, 'c) tree := ('a, 'b, 'c) Map.Using_comparator.Tree.t
+    with type 'k key := 'k
+    with type 'c cmp := 'c
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_first_class_module.t
 end =
   Map
diff --git a/test/test_map_traversal.ml b/test/test_map_traversal.ml
index 90a07d74..71b652a4 100644
--- a/test/test_map_traversal.ml
+++ b/test/test_map_traversal.ml
@@ -30,8 +30,8 @@ let%expect_test "mapi correctness check" =
     |> Lazy_apply.run
   in
   let reference_output = Map.mapi map ~f in
-  require [%here] (Map.equal Int.equal test_output reference_output);
-  require [%here] (Map.invariants test_output);
+  require (Map.equal Int.equal test_output reference_output);
+  require (Map.invariants test_output);
   [%expect {| |}]
 ;;
 
@@ -43,8 +43,8 @@ let%expect_test "filter_mapi correctness check" =
     |> Lazy_apply.run
   in
   let reference_output = Map.filter_mapi map ~f in
-  require [%here] (Map.equal Int.equal test_output reference_output);
-  require [%here] (Map.invariants test_output);
+  require (Map.equal Int.equal test_output reference_output);
+  require (Map.invariants test_output);
   [%expect {| |}]
 ;;
 
@@ -137,7 +137,7 @@ let%expect_test "mapi lazy check" =
     | Second _ -> assert false
   in
   let reference_output = Map.mapi map ~f in
-  require [%here] (Map.equal Int.equal test_output reference_output);
+  require (Map.equal Int.equal test_output reference_output);
   [%expect
     {|
     ((key  4)
diff --git a/test/test_minmax.ml b/test/test_minmax.ml
index 7542d638..fc511469 100644
--- a/test/test_minmax.ml
+++ b/test/test_minmax.ml
@@ -142,7 +142,7 @@ let%expect_test ("32-bit platforms" [@tags "no-js", "32-bits-only"]) =
     |}]
 ;;
 
-let%expect_test ("js_of_ocaml platforms" [@tags "js-only"]) =
+let%expect_test ("js_of_ocaml platforms (js)" [@tags "js-only", "no-wasm"]) =
   test (module Int) Large;
   [%expect
     {|
@@ -164,3 +164,26 @@ let%expect_test ("js_of_ocaml platforms" [@tags "js-only"]) =
     (max 0 -2_147_483_648 = 0)
     |}]
 ;;
+
+let%expect_test ("js_of_ocaml platforms (wasm)" [@tags "wasm-only"]) =
+  test (module Int) Large;
+  [%expect
+    {|
+    (min -1_073_741_824 0 = -1_073_741_824)
+    (max -1_073_741_824 0 = 0)
+    (min 1_073_741_823 1_073_741_823 = 1_073_741_823)
+    (max 1_073_741_823 1_073_741_823 = 1_073_741_823)
+    (min 0 -1_073_741_824 = -1_073_741_824)
+    (max 0 -1_073_741_824 = 0)
+    |}];
+  test (module Nativeint) Large;
+  [%expect
+    {|
+    (min -2_147_483_648 0 = -2_147_483_648)
+    (max -2_147_483_648 0 = 0)
+    (min 2_147_483_647 2_147_483_647 = 2_147_483_647)
+    (max 2_147_483_647 2_147_483_647 = 2_147_483_647)
+    (min 0 -2_147_483_648 = -2_147_483_648)
+    (max 0 -2_147_483_648 = 0)
+    |}]
+;;
diff --git a/test/test_nativeint.ml b/test/test_nativeint.ml
index 1e652cb2..dd465940 100644
--- a/test/test_nativeint.ml
+++ b/test/test_nativeint.ml
@@ -27,7 +27,6 @@ let%expect_test "bswap native" =
 
 let%expect_test "binary" =
   quickcheck_m
-    [%here]
     (module struct
       type t = nativeint [@@deriving quickcheck, sexp_of]
     end)
@@ -43,31 +42,36 @@ let test_binary i =
 
 let%expect_test "binary" =
   test_binary 0b01n;
-  [%expect {|
+  [%expect
+    {|
     0b1
     0b1
     0b1
     |}];
   test_binary 0b100n;
-  [%expect {|
+  [%expect
+    {|
     0b100
     0b100
     0b100
     |}];
   test_binary 0b101n;
-  [%expect {|
+  [%expect
+    {|
     0b101
     0b101
     0b101
     |}];
   test_binary 0b101010_10101010n;
-  [%expect {|
+  [%expect
+    {|
     0b10_1010_1010_1010
     0b10101010101010
     0b10_1010_1010_1010
     |}];
   test_binary 0b111111_00000000n;
-  [%expect {|
+  [%expect
+    {|
     0b11_1111_0000_0000
     0b11111100000000
     0b11_1111_0000_0000
diff --git a/test/test_obj_array.ml b/test/test_obj_array.ml
new file mode 100644
index 00000000..86a6ceef
--- /dev/null
+++ b/test/test_obj_array.ml
@@ -0,0 +1,80 @@
+open! Import
+module Obj_array = Base.Exported_for_specific_uses.Obj_array
+
+(* Invariant tests *)
+let%test_module (_ [@tags "no-js"]) =
+  (module (
+  struct
+    type t = Obj_array.t
+
+    let invariant = Obj_array.invariant
+
+    (* We test that constructors satisfy the invariant, especially when given floats. *)
+
+    open struct
+      let test
+        ?cr
+        ?(allow_nonfloat = false)
+        ?(allow_empty = false)
+        ?(here = Stdlib.Lexing.dummy_pos)
+        t
+        =
+        (* assertions for calling convention ... *)
+        if not allow_empty then assert (Obj_array.length t > 0);
+        if not allow_nonfloat
+        then
+          for pos = 0 to Obj_array.length t - 1 do
+            assert (Stdlib.Obj.tag (Obj_array.get t pos) = Stdlib.Obj.double_tag)
+          done;
+        (* ... [require]* for test itself *)
+        require_does_not_raise ~here ?cr (fun () -> Obj_array.invariant t)
+      ;;
+
+      let obj (float : float) = Stdlib.Obj.repr float
+    end
+
+    (* creators *)
+
+    let empty = Obj_array.empty
+    let%expect_test _ = test Obj_array.empty ~allow_empty:true
+    let singleton = Obj_array.singleton
+    let%expect_test _ = test (Obj_array.singleton (obj 0.))
+    let create_zero = Obj_array.create_zero
+    let%expect_test _ = test (Obj_array.create_zero ~len:1) ~allow_nonfloat:true
+    let create = Obj_array.create
+    let%expect_test _ = test (Obj_array.create (obj 0.) ~len:1)
+    let copy = Obj_array.copy
+    let%expect_test _ = test (Obj_array.copy (Obj_array.singleton (obj 0.)))
+    let sub = Obj_array.sub
+    let%expect_test _ = test (Obj_array.sub (Obj_array.singleton (obj 0.)) ~pos:0 ~len:1)
+    let subo = Obj_array.subo
+    let%expect_test _ = test (Obj_array.subo (Obj_array.singleton (obj 0.)))
+
+    (* accessors *)
+
+    let sexp_of_t = Obj_array.sexp_of_t
+    let blit = Obj_array.blit
+    let blito = Obj_array.blito
+    let unsafe_blit = Obj_array.unsafe_blit
+    let length = Obj_array.length
+    let get = Obj_array.get
+    let unsafe_get = Obj_array.unsafe_get
+    let set = Obj_array.set
+    let unsafe_set = Obj_array.unsafe_set
+    let swap = Obj_array.swap
+    let set_with_caml_modify = Obj_array.set_with_caml_modify
+    let unsafe_set_assuming_currently_int = Obj_array.unsafe_set_assuming_currently_int
+
+    let unsafe_set_int_assuming_currently_int =
+      Obj_array.unsafe_set_int_assuming_currently_int
+    ;;
+
+    let unsafe_set_int = Obj_array.unsafe_set_int
+    let unsafe_set_omit_phys_equal_check = Obj_array.unsafe_set_omit_phys_equal_check
+    let unsafe_set_with_caml_modify = Obj_array.unsafe_set_with_caml_modify
+    let unsafe_clear_if_pointer = Obj_array.unsafe_clear_if_pointer
+  end :
+    module type of struct
+      include Obj_array
+    end))
+;;
diff --git a/test/test_obj_array.mli b/test/test_obj_array.mli
new file mode 100644
index 00000000..74bb7298
--- /dev/null
+++ b/test/test_obj_array.mli
@@ -0,0 +1 @@
+(*_ This signature is deliberately empty. *)
diff --git a/test/test_option.ml b/test/test_option.ml
index e3ca0db5..c9c790f3 100644
--- a/test/test_option.ml
+++ b/test/test_option.ml
@@ -16,7 +16,8 @@ let%expect_test "[value_or_thunk]" =
   let test t = print_s [%sexp (value_or_thunk t : int)] in
   (* trigger the thunk *)
   test None;
-  [%expect {|
+  [%expect
+    {|
     THUNK!
     0
     |}];
@@ -28,7 +29,8 @@ let%expect_test "[value_or_thunk]" =
   [%expect {| 1 |}];
   (* trigger the thunk again: no memoization *)
   test None;
-  [%expect {|
+  [%expect
+    {|
     THUNK!
     0
     |}]
@@ -48,3 +50,34 @@ let%expect_test "map2" =
   m (Some 1) None;
   [%expect {| () |}]
 ;;
+
+let%expect_test "some_if_thunk{,_local}" =
+  let print_opt = Option.iter_local ~f:(fun x -> Stdlib.print_int x) in
+  let run_test some_if_thunk =
+    (* In the [false] case, don't run the thunk *)
+    print_opt (some_if_thunk false (fun () -> assert false));
+    [%expect {| |}];
+    (* In the [true] case, do run the thunk *)
+    some_if_thunk true (fun () ->
+      print_endline "running";
+      1)
+    |> print_opt;
+    [%expect
+      {|
+      running
+      1
+      |}]
+  in
+  run_test (fun b f -> some_if_thunk_local b f);
+  run_test some_if_thunk
+;;
+
+let%expect_test "first_some_thunk" =
+  let print_opt = Option.iter_local ~f:(fun x -> Stdlib.print_int x) in
+  print_opt (first_some_thunk None (Fn.const None));
+  [%expect {| |}];
+  print_opt (first_some_thunk (Some 1) (fun () -> failwith "should not be run"));
+  [%expect {| 1 |}];
+  print_opt (first_some_thunk None (Fn.const (Some 2)));
+  [%expect {| 2 |}]
+;;
diff --git a/test/test_option_array.ml b/test/test_option_array.ml
index 3891e1c5..e3661a2d 100644
--- a/test/test_option_array.ml
+++ b/test/test_option_array.ml
@@ -86,8 +86,8 @@ let%expect_test _ =
   let t = create ~len:1 in
   let check x =
     set t 0 (Some x);
-    require [%here] (phys_equal x (unsafe_get_some_exn t 0));
-    require [%here] (phys_equal x (unsafe_get_some_assuming_some t 0))
+    require (phys_equal x (unsafe_get_some_exn t 0));
+    require (phys_equal x (unsafe_get_some_assuming_some t 0))
   in
   check X.magic_value;
   check X.some_other_value
diff --git a/test/test_or_error.ml b/test/test_or_error.ml
index ac9efea6..5026e0a6 100644
--- a/test/test_or_error.ml
+++ b/test/test_or_error.ml
@@ -72,7 +72,7 @@ let%expect_test "behavior and performance on lists of or_error's" =
     (* Test for timeout / stack overflow on a long list. *)
     match to_string (f long_list) with
     | (_ : string) -> ()
-    | exception Stack_overflow -> print_cr [%here] [%message "stack overflow"]
+    | exception Stack_overflow -> print_cr [%message "stack overflow"]
   in
   (* test functions that combine a list of or_errors *)
   test all;
diff --git a/test/test_popcount.ml b/test/test_popcount.ml
index c408d436..3958bd4c 100644
--- a/test/test_popcount.ml
+++ b/test/test_popcount.ml
@@ -33,25 +33,25 @@ module Make (Int : T) = struct
 end
 
 include Make (struct
-  include Int
+    include Int
 
-  type t = int [@@deriving quickcheck]
-end)
+    type t = int [@@deriving quickcheck]
+  end)
 
 include Make (struct
-  include Int32
+    include Int32
 
-  type t = int32 [@@deriving quickcheck]
-end)
+    type t = int32 [@@deriving quickcheck]
+  end)
 
 include Make (struct
-  include Int64
+    include Int64
 
-  type t = int64 [@@deriving quickcheck]
-end)
+    type t = int64 [@@deriving quickcheck]
+  end)
 
 include Make (struct
-  include Nativeint
+    include Nativeint
 
-  type t = nativeint [@@deriving quickcheck]
-end)
+    type t = nativeint [@@deriving quickcheck]
+  end)
diff --git a/test/test_pp.ml b/test/test_pp.ml
index 4c359356..65154691 100644
--- a/test/test_pp.ml
+++ b/test/test_pp.ml
@@ -10,25 +10,29 @@ let print_all pp vs = List.iter ~f:(print pp) vs
 
 let%expect_test "pretty-printers" =
   print_all Char.pp [ '\000'; '\r'; 'a' ];
-  [%expect {|
+  [%expect
+    {|
     '\000'
     '\r'
     'a'
     |}];
   print_all String.pp [ ""; "foo"; "abc\tdef" ];
-  [%expect {|
+  [%expect
+    {|
     ""
     "foo"
     "abc\tdef"
     |}];
   print_all Sign.pp Sign.all;
-  [%expect {|
+  [%expect
+    {|
     Neg
     Zero
     Pos
     |}];
   print_all Bool.pp Bool.all;
-  [%expect {|
+  [%expect
+    {|
     false
     true
     |}];
@@ -37,13 +41,15 @@ let%expect_test "pretty-printers" =
   print_all Nothing.pp Nothing.all;
   [%expect {| |}];
   print_all Float.pp [ 0.; 3.14; 1.0 /. 0.0 ];
-  [%expect {|
+  [%expect
+    {|
     0.
     3.14
     inf
     |}];
   print_all Int.pp [ 0; 1 ];
-  [%expect {|
+  [%expect
+    {|
     0
     1
     |}];
diff --git a/test/test_ppx_compare_lib.ml b/test/test_ppx_compare_lib.ml
index 10305b94..0e9931a0 100644
--- a/test/test_ppx_compare_lib.ml
+++ b/test/test_ppx_compare_lib.ml
@@ -13,7 +13,6 @@ let test (type a) (module T : T with type t = a) ordered =
   List.iteri ordered ~f:(fun i ti ->
     List.iteri ordered ~f:(fun j tj ->
       require
-        [%here]
         (Ordering.equal
            (Ordering.of_int (T.compare ti tj))
            (Ordering.of_int (Int.compare i j)))
diff --git a/test/test_queue.ml b/test/test_queue.ml
index a7cd6814..1500a778 100644
--- a/test/test_queue.ml
+++ b/test/test_queue.ml
@@ -3,1171 +3,1124 @@ open Base_test_helpers
 
 let%test_module _ =
   (module (
-             struct
-               open Queue
-
-               module type S = S
-
-               let does_raise = Exn.does_raise
-
-               type nonrec 'a t = 'a t [@@deriving sexp, sexp_grammar]
-
-               let globalize = globalize
-
-               let%expect_test _ =
-                 let open Expect_test_helpers_base in
-                 let check t =
-                   require_does_not_raise [%here] (fun () ->
-                     invariant ignore t;
-                     print_s [%sexp (t : int t)])
-                 in
-                 let a = of_list [ 1; 2; 3 ] in
-                 check a;
-                 [%expect {| (1 2 3) |}];
-                 let b = globalize globalize_int a in
-                 check b;
-                 [%expect {| (1 2 3) |}];
-                 enqueue b 4;
-                 print_s [%sexp (dequeue a : int option)];
-                 [%expect {| (1) |}];
-                 check a;
-                 [%expect {| (2 3) |}];
-                 check b;
-                 [%expect {| (1 2 3 4) |}]
-               ;;
-
-               let capacity = capacity
-               let set_capacity = set_capacity
-
-               let%test_unit _ =
-                 let t = create () in
-                 [%test_result: int] (capacity t) ~expect:2;
-                 enqueue t 1;
-                 [%test_result: int] (capacity t) ~expect:2;
-                 enqueue t 2;
-                 [%test_result: int] (capacity t) ~expect:2;
-                 enqueue t 3;
-                 [%test_result: int] (capacity t) ~expect:4;
-                 set_capacity t 0;
-                 [%test_result: int] (capacity t) ~expect:4;
-                 set_capacity t 3;
-                 [%test_result: int] (capacity t) ~expect:4;
-                 set_capacity t 100;
-                 [%test_result: int] (capacity t) ~expect:128;
-                 enqueue t 4;
-                 enqueue t 5;
-                 set_capacity t 0;
-                 [%test_result: int] (capacity t) ~expect:8;
-                 set_capacity t (-1);
-                 [%test_result: int] (capacity t) ~expect:8
-               ;;
-
-               let round_trip_sexp t =
-                 let sexp = sexp_of_t Int.sexp_of_t t in
-                 let t' = t_of_sexp Int.t_of_sexp sexp in
-                 [%test_result: int list] ~expect:(to_list t) (to_list t')
-               ;;
-
-               let%test_unit _ = round_trip_sexp (of_list [ 1; 2; 3; 4 ])
-               let%test_unit _ = round_trip_sexp (create ())
-               let%test_unit _ = round_trip_sexp (of_list [])
-               let invariant = invariant
-               let create = create
-
-               let%test_unit _ =
-                 let t = create () in
-                 [%test_result: int] (length t) ~expect:0;
-                 [%test_result: int] (capacity t) ~expect:2
-               ;;
-
-               let%test_unit _ =
-                 let t = create ~capacity:0 () in
-                 [%test_result: int] (length t) ~expect:0;
-                 [%test_result: int] (capacity t) ~expect:1
-               ;;
-
-               let%test_unit _ =
-                 let t = create ~capacity:6 () in
-                 [%test_result: int] (length t) ~expect:0;
-                 [%test_result: int] (capacity t) ~expect:8
-               ;;
-
-               let%test_unit _ =
-                 assert (does_raise (fun () : _ Queue.t -> create ~capacity:(-1) ()))
-               ;;
-
-               let singleton = singleton
-
-               let%test_unit _ =
-                 let t = singleton 7 in
-                 [%test_result: int] (length t) ~expect:1;
-                 [%test_result: int] (capacity t) ~expect:1;
-                 [%test_result: int option] (dequeue t) ~expect:(Some 7);
-                 [%test_result: int option] (dequeue t) ~expect:None
-               ;;
-
-               let init = init
-
-               let%test_unit _ =
-                 let t = init 0 ~f:(fun _ -> assert false) in
-                 [%test_result: int] (length t) ~expect:0;
-                 [%test_result: int] (capacity t) ~expect:1;
-                 [%test_result: int option] (dequeue t) ~expect:None
-               ;;
-
-               let%test_unit _ =
-                 let t = init 3 ~f:(fun i -> i * 2) in
-                 [%test_result: int] (length t) ~expect:3;
-                 [%test_result: int] (capacity t) ~expect:4;
-                 [%test_result: int option] (dequeue t) ~expect:(Some 0);
-                 [%test_result: int option] (dequeue t) ~expect:(Some 2);
-                 [%test_result: int option] (dequeue t) ~expect:(Some 4);
-                 [%test_result: int option] (dequeue t) ~expect:None
-               ;;
-
-               let%test_unit _ =
-                 assert (does_raise (fun () : unit Queue.t -> init (-1) ~f:(fun _ -> ())))
-               ;;
-
-               let get = get
-               let set = set
-
-               let%test_unit _ =
-                 let t = create () in
-                 let get_opt t i = Option.try_with (fun () -> get t i) in
-                 [%test_result: int option] (get_opt t 0) ~expect:None;
-                 [%test_result: int option] (get_opt t (-1)) ~expect:None;
-                 [%test_result: int option] (get_opt t 10) ~expect:None;
-                 List.iter [ -1; 0; 1 ] ~f:(fun i ->
-                   assert (does_raise (fun () -> set t i 0)));
-                 enqueue t 0;
-                 enqueue t 1;
-                 enqueue t 2;
-                 [%test_result: int option] (get_opt t 0) ~expect:(Some 0);
-                 [%test_result: int option] (get_opt t 1) ~expect:(Some 1);
-                 [%test_result: int option] (get_opt t 2) ~expect:(Some 2);
-                 [%test_result: int option] (get_opt t 3) ~expect:None;
-                 ignore (dequeue_exn t : int);
-                 [%test_result: int option] (get_opt t 0) ~expect:(Some 1);
-                 [%test_result: int option] (get_opt t 1) ~expect:(Some 2);
-                 [%test_result: int option] (get_opt t 2) ~expect:None;
-                 set t 0 3;
-                 [%test_result: int option] (get_opt t 0) ~expect:(Some 3);
-                 [%test_result: int option] (get_opt t 1) ~expect:(Some 2);
-                 List.iter [ -1; 2 ] ~f:(fun i ->
-                   assert (does_raise (fun () -> set t i 0)))
-               ;;
-
-               let map = map
-
-               let%test_unit _ =
-                 for i = 0 to 5 do
-                   let l = List.init i ~f:Fn.id in
-                   let t = of_list l in
-                   let f x = x * 2 in
-                   let t' = map t ~f in
-                   [%test_result: int list] (to_list t') ~expect:(List.map l ~f)
-                 done
-               ;;
-
-               let%test_unit _ =
-                 let t = create () in
-                 let t' = map t ~f:(fun x -> x * 2) in
-                 [%test_result: int] (length t') ~expect:(length t);
-                 [%test_result: int] (length t') ~expect:0;
-                 [%test_result: int list] (to_list t') ~expect:[]
-               ;;
-
-               let mapi = mapi
-
-               let%test_unit _ =
-                 for i = 0 to 5 do
-                   let l = List.init i ~f:Fn.id in
-                   let t = of_list l in
-                   let f i x = i, x * 2 in
-                   let t' = mapi t ~f in
-                   [%test_result: (int * int) list] (to_list t') ~expect:(List.mapi l ~f)
-                 done
-               ;;
-
-               let%test_unit _ =
-                 let t = create () in
-                 let t' = mapi t ~f:(fun i x -> i, x * 2) in
-                 [%test_result: int] (length t') ~expect:(length t);
-                 [%test_result: int] (length t') ~expect:0;
-                 [%test_result: (int * int) list] (to_list t') ~expect:[]
-               ;;
-
-               include Test_container.Test_S1 (Queue)
-
-               let dequeue_exn = dequeue_exn
-               let enqueue = enqueue
-               let enqueue_front = enqueue_front
-               let dequeue_back = dequeue_back
-               let dequeue_back_exn = dequeue_back_exn
-               let peek = peek
-               let peek_exn = peek_exn
-               let peek_back = peek_back
-               let peek_back_exn = peek_back_exn
-               let last = last
-               let last_exn = last_exn
-
-               let%test_unit _ =
-                 let t = create () in
-                 [%test_result: int option] (peek t) ~expect:None;
-                 [%test_result: int option] (last t) ~expect:None;
-                 enqueue t 1;
-                 enqueue t 2;
-                 [%test_result: int option] (peek t) ~expect:(Some 1);
-                 [%test_result: int] (peek_exn t) ~expect:1;
-                 [%test_result: int option] (last t) ~expect:(Some 2);
-                 [%test_result: int] (last_exn t) ~expect:2;
-                 [%test_result: int] (dequeue_exn t) ~expect:1;
-                 [%test_result: int] (dequeue_exn t) ~expect:2;
-                 assert (does_raise (fun () -> dequeue_exn t));
-                 assert (does_raise (fun () -> peek_exn t));
-                 assert (does_raise (fun () -> peek_back_exn t));
-                 assert (does_raise (fun () -> last_exn t));
-                 enqueue_front t 1;
-                 enqueue t 2;
-                 enqueue_front t 0;
-                 enqueue t 3;
-                 enqueue t 4;
-                 enqueue t 5;
-                 [%test_result: int option] (peek_back t) ~expect:(Some 5);
-                 [%test_result: int] (peek_back_exn t) ~expect:5;
-                 [%test_result: int] (dequeue_exn t) ~expect:0;
-                 [%test_result: int] (dequeue_exn t) ~expect:1;
-                 [%test_result: int] (dequeue_exn t) ~expect:2;
-                 [%test_result: int] (dequeue_back_exn t) ~expect:5;
-                 [%test_result: int] (dequeue_back_exn t) ~expect:4;
-                 [%test_result: int] (dequeue_back_exn t) ~expect:3
-               ;;
-
-               let dequeue_and_ignore_exn = dequeue_and_ignore_exn
-
-               let%test_unit _ =
-                 let t = create () in
-                 enqueue t 1;
-                 enqueue t 2;
-                 enqueue t 3;
-                 [%test_result: int] (peek_exn t) ~expect:1;
-                 dequeue_and_ignore_exn t;
-                 [%test_result: int] (peek_exn t) ~expect:2;
-                 dequeue_and_ignore_exn t;
-                 [%test_result: int] (peek_exn t) ~expect:3;
-                 dequeue_and_ignore_exn t;
-                 [%test_result: int option] (peek t) ~expect:None;
-                 assert (does_raise (fun () -> dequeue_and_ignore_exn t));
-                 assert (does_raise (fun () -> dequeue_and_ignore_exn t));
-                 [%test_result: int option] (peek t) ~expect:None
-               ;;
-
-               let drain = drain
-
-               let%test_unit _ =
-                 let t = create () in
-                 for i = 0 to 10 do
-                   enqueue t i
-                 done;
-                 [%test_result: int] (peek_exn t) ~expect:0;
-                 [%test_result: int] (length t) ~expect:11;
-                 let r = ref 0 in
-                 let add i = r := !r + i in
-                 drain t ~f:add ~while_:(fun i -> i < 7);
-                 [%test_result: int] (peek_exn t) ~expect:7;
-                 [%test_result: int] (length t) ~expect:4;
-                 [%test_result: int] !r ~expect:21;
-                 drain t ~f:add ~while_:(fun i -> i > 7);
-                 [%test_result: int] (peek_exn t) ~expect:7;
-                 [%test_result: int] (length t) ~expect:4;
-                 [%test_result: int] !r ~expect:21;
-                 drain t ~f:add ~while_:(fun i -> i > 0);
-                 [%test_result: int option] (peek t) ~expect:None;
-                 [%test_result: int] (length t) ~expect:0;
-                 [%test_result: int] !r ~expect:55
-               ;;
-
-               let enqueue_all = enqueue_all
-
-               let%test_unit _ =
-                 let t = create () in
-                 enqueue_all t [ 1; 2; 3 ];
-                 [%test_result: int] (dequeue_exn t) ~expect:1;
-                 [%test_result: int] (dequeue_exn t) ~expect:2;
-                 [%test_result: int option] (last t) ~expect:(Some 3);
-                 enqueue_all t [ 4; 5 ];
-                 [%test_result: int option] (last t) ~expect:(Some 5);
-                 [%test_result: int] (dequeue_exn t) ~expect:3;
-                 [%test_result: int] (dequeue_exn t) ~expect:4;
-                 [%test_result: int] (dequeue_exn t) ~expect:5;
-                 assert (does_raise (fun () -> dequeue_exn t));
-                 enqueue_all t [];
-                 assert (does_raise (fun () -> dequeue_exn t))
-               ;;
-
-               let of_list = of_list
-               let to_list = to_list
-
-               let%test_unit _ =
-                 for i = 0 to 4 do
-                   let list = List.init i ~f:Fn.id in
-                   [%test_result: int list] (to_list (of_list list)) ~expect:list
-                 done
-               ;;
-
-               let%test _ =
-                 let t = create () in
-                 for i = 1 to 5 do
-                   enqueue t i
-                 done;
-                 [%equal: int list] (to_list t) [ 1; 2; 3; 4; 5 ]
-               ;;
-
-               let of_array = of_array
-               let to_array = to_array
-
-               let%test_unit _ =
-                 for len = 0 to 4 do
-                   let array = Array.init len ~f:Fn.id in
-                   [%test_result: int array] (to_array (of_array array)) ~expect:array
-                 done
-               ;;
-
-               let compare = compare
-               let compare__local = compare__local
-               let equal = equal
-               let equal__local = equal__local
-
-               let%test_module "comparisons" =
-                 (module struct
-                   let sign x = if x < 0 then ~-1 else if x > 0 then 1 else 0
-
-                   let test t1 t2 =
-                     [%test_result: bool]
-                       (equal Int.equal t1 t2)
-                       ~expect:(List.equal Int.equal (to_list t1) (to_list t2));
-                     [%test_result: int]
-                       (sign (compare Int.compare t1 t2))
-                       ~expect:(sign (List.compare Int.compare (to_list t1) (to_list t2)));
-                     [%test_result: bool]
-                       (equal__local Int.equal__local t1 t2)
-                       ~expect:
-                         (List.equal__local Int.equal__local (to_list t1) (to_list t2));
-                     [%test_result: int]
-                       (sign (compare__local Int.compare__local t1 t2))
-                       ~expect:
-                         (sign
-                            (List.compare__local
-                               Int.compare__local
-                               (to_list t1)
-                               (to_list t2)))
-                   ;;
-
-                   let lists =
-                     [ []
-                     ; [ 1 ]
-                     ; [ 2 ]
-                     ; [ 1; 1 ]
-                     ; [ 1; 2 ]
-                     ; [ 2; 1 ]
-                     ; [ 1; 1; 1 ]
-                     ; [ 1; 2; 3 ]
-                     ; [ 1; 2; 4 ]
-                     ; [ 1; 2; 4; 8 ]
-                     ; [ 1; 2; 3; 4; 5 ]
-                     ]
-                   ;;
-
-                   let%test_unit _ =
-                     (* [phys_equal] inputs *)
-                     List.iter lists ~f:(fun list ->
-                       let t = of_list list in
-                       test t t)
-                   ;;
-
-                   let%test_unit _ =
-                     List.iter lists ~f:(fun list1 ->
-                       List.iter lists ~f:(fun list2 ->
-                         test (of_list list1) (of_list list2)))
-                   ;;
-                 end)
-               ;;
-
-               let clear = clear
-
-               let%test_unit "clear" =
-                 let q = of_list [ 1; 2; 3; 4 ] in
-                 [%test_result: int] (length q) ~expect:4;
-                 clear q;
-                 [%test_result: int] (length q) ~expect:0
-               ;;
-
-               let blit_transfer = blit_transfer
-
-               let%test_unit _ =
-                 let q_list = [ 1; 2; 3; 4 ] in
-                 let q = of_list q_list in
-                 let q' = create () in
-                 blit_transfer ~src:q ~dst:q' ();
-                 [%test_result: int list] (to_list q') ~expect:q_list;
-                 [%test_result: int list] (to_list q) ~expect:[]
-               ;;
-
-               let%test_unit _ =
-                 let q = of_list [ 1; 2; 3; 4 ] in
-                 let q' = create () in
-                 blit_transfer ~src:q ~dst:q' ~len:2 ();
-                 [%test_result: int list] (to_list q') ~expect:[ 1; 2 ];
-                 [%test_result: int list] (to_list q) ~expect:[ 3; 4 ]
-               ;;
-
-               let%test_unit "blit_transfer on wrapped queues" =
-                 let list = [ 1; 2; 3; 4 ] in
-                 let q = of_list list in
-                 let q' = copy q in
-                 ignore (dequeue_exn q : int);
-                 ignore (dequeue_exn q : int);
-                 ignore (dequeue_exn q' : int);
-                 ignore (dequeue_exn q' : int);
-                 ignore (dequeue_exn q' : int);
-                 enqueue q 5;
-                 enqueue q 6;
-                 blit_transfer ~src:q ~dst:q' ~len:3 ();
-                 [%test_result: int list] (to_list q') ~expect:[ 4; 3; 4; 5 ];
-                 [%test_result: int list] (to_list q) ~expect:[ 6 ]
-               ;;
-
-               let copy = copy
-
-               let%test_unit "copies behave independently" =
-                 let q = of_list [ 1; 2; 3; 4 ] in
-                 let q' = copy q in
-                 enqueue q 5;
-                 ignore (dequeue_exn q' : int);
-                 [%test_result: int list] (to_list q) ~expect:[ 1; 2; 3; 4; 5 ];
-                 [%test_result: int list] (to_list q') ~expect:[ 2; 3; 4 ]
-               ;;
-
-               let dequeue = dequeue
-               let filter = filter
-               let filteri = filteri
-               let filter_inplace = filter_inplace
-               let filteri_inplace = filteri_inplace
-               let concat_map = concat_map
-               let concat_mapi = concat_mapi
-               let filter_map = filter_map
-               let filter_mapi = filter_mapi
-               let counti = counti
-               let existsi = existsi
-               let for_alli = for_alli
-               let iter = iter
-               let iteri = iteri
-               let foldi = foldi
-               let findi = findi
-               let find_mapi = find_mapi
-
-               let%test_module "Linked_queue bisimulation" =
-                 (module struct
-                   module type Queue_intf = sig
-                     type 'a t [@@deriving sexp_of]
-
-                     val create : unit -> 'a t
-                     val enqueue : 'a t -> 'a -> unit
-                     val dequeue : 'a t -> 'a option
-                     val drain : 'a t -> f:('a -> unit) -> while_:('a -> bool) -> unit
-                     val to_array : 'a t -> 'a array
-                     val fold : 'a t -> init:'b -> f:('b -> 'a -> 'b) -> 'b
-                     val foldi : 'a t -> init:'b -> f:(int -> 'b -> 'a -> 'b) -> 'b
-                     val iter : 'a t -> f:('a -> unit) -> unit
-                     val iteri : 'a t -> f:(int -> 'a -> unit) -> unit
-                     val length : 'a t -> int
-                     val clear : 'a t -> unit
-                     val concat_map : 'a t -> f:('a -> 'b list) -> 'b t
-                     val concat_mapi : 'a t -> f:(int -> 'a -> 'b list) -> 'b t
-                     val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
-                     val filter_mapi : 'a t -> f:(int -> 'a -> 'b option) -> 'b t
-                     val filter : 'a t -> f:('a -> bool) -> 'a t
-                     val filteri : 'a t -> f:(int -> 'a -> bool) -> 'a t
-                     val filter_inplace : 'a t -> f:('a -> bool) -> unit
-                     val filteri_inplace : 'a t -> f:(int -> 'a -> bool) -> unit
-                     val map : 'a t -> f:('a -> 'b) -> 'b t
-                     val mapi : 'a t -> f:(int -> 'a -> 'b) -> 'b t
-                     val counti : 'a t -> f:(int -> 'a -> bool) -> int
-                     val existsi : 'a t -> f:(int -> 'a -> bool) -> bool
-                     val for_alli : 'a t -> f:(int -> 'a -> bool) -> bool
-                     val findi : 'a t -> f:(int -> 'a -> bool) -> (int * 'a) option
-                     val find_mapi : 'a t -> f:(int -> 'a -> 'b option) -> 'b option
-                     val transfer : src:'a t -> dst:'a t -> unit
-                     val copy : 'a t -> 'a t
-                   end
-
-                   module That_queue : Queue_intf = Linked_queue
-
-                   module This_queue : Queue_intf = struct
-                     include Queue
-
-                     let create () = create ()
-                     let transfer ~src ~dst = blit_transfer ~src ~dst ()
-                   end
-
-                   let this_to_string this_t =
-                     Sexp.to_string (this_t |> [%sexp_of: int This_queue.t])
-                   ;;
-
-                   let that_to_string that_t =
-                     Sexp.to_string (that_t |> [%sexp_of: int That_queue.t])
-                   ;;
-
-                   let array_string arr = Sexp.to_string (arr |> [%sexp_of: int array])
-                   let create () = This_queue.create (), That_queue.create ()
-
-                   let enqueue (t_a, t_b) v =
-                     let start_a = This_queue.to_array t_a in
-                     let start_b = That_queue.to_array t_b in
-                     This_queue.enqueue t_a v;
-                     That_queue.enqueue t_b v;
-                     let end_a = This_queue.to_array t_a in
-                     let end_b = That_queue.to_array t_b in
-                     if not ([%equal: int array] end_a end_b)
-                     then
-                       Printf.failwithf
-                         "enqueue transition failure of: %s -> %s vs. %s -> %s"
-                         (array_string start_a)
-                         (array_string end_a)
-                         (array_string start_b)
-                         (array_string end_b)
-                         ()
-                   ;;
-
-                   let iter (t_a, t_b) =
-                     let r_a, r_b = ref 0, ref 0 in
-                     This_queue.iter t_a ~f:(fun x -> r_a := !r_a + x);
-                     That_queue.iter t_b ~f:(fun x -> r_b := !r_b + x);
-                     if !r_a <> !r_b
-                     then
-                       Printf.failwithf
-                         "error in iter: %s (from %s) <> %s (from %s)"
-                         (Int.to_string !r_a)
-                         (this_to_string t_a)
-                         (Int.to_string !r_b)
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let iteri (t_a, t_b) =
-                     let r_a, r_b = ref 0, ref 0 in
-                     This_queue.iteri t_a ~f:(fun i x -> r_a := !r_a + (x lxor i));
-                     That_queue.iteri t_b ~f:(fun i x -> r_b := !r_b + (x lxor i));
-                     if !r_a <> !r_b
-                     then
-                       Printf.failwithf
-                         "error in iteri: %s (from %s) <> %s (from %s)"
-                         (Int.to_string !r_a)
-                         (this_to_string t_a)
-                         (Int.to_string !r_b)
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let dequeue (t_a, t_b) =
-                     let start_a = This_queue.to_array t_a in
-                     let start_b = That_queue.to_array t_b in
-                     let a, b = This_queue.dequeue t_a, That_queue.dequeue t_b in
-                     let end_a = This_queue.to_array t_a in
-                     let end_b = That_queue.to_array t_b in
-                     if (not ([%equal: int option] a b))
-                        || not ([%equal: int array] end_a end_b)
-                     then
-                       Printf.failwithf
-                         "error in dequeue: %s (%s -> %s) <> %s (%s -> %s)"
-                         (Option.value ~default:"None" (Option.map a ~f:Int.to_string))
-                         (array_string start_a)
-                         (array_string end_a)
-                         (Option.value ~default:"None" (Option.map b ~f:Int.to_string))
-                         (array_string start_b)
-                         (array_string end_b)
-                         ()
-                   ;;
-
-                   let is_even x = x land 1 = 0
-
-                   let drain (t_a, t_b) =
-                     let orig_a = This_queue.to_array t_a in
-                     let orig_b = That_queue.to_array t_b in
-                     let r_a = ref 0 in
-                     let r_b = ref 0 in
-                     let add r i = r := !r + i in
-                     This_queue.drain t_a ~f:(fun i -> add r_a i) ~while_:is_even;
-                     That_queue.drain t_b ~f:(fun i -> add r_b i) ~while_:is_even;
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a)
-                             (That_queue.to_array t_b)
-                           && !r_a = !r_b)
-                     then
-                       Printf.failwithf
-                         "error in drain: %s -> %s, %d vs. %s -> %s, %d"
-                         (array_string orig_a)
-                         (this_to_string t_a)
-                         !r_a
-                         (array_string orig_b)
-                         (that_to_string t_b)
-                         !r_b
-                         ()
-                   ;;
-
-                   let clear (t_a, t_b) =
-                     This_queue.clear t_a;
-                     That_queue.clear t_b
-                   ;;
-
-                   let filter (t_a, t_b) =
-                     let t_a' = This_queue.filter t_a ~f:is_even in
-                     let t_b' = That_queue.filter t_b ~f:is_even in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in filter: %s -> %s vs. %s -> %s"
-                         (this_to_string t_a)
-                         (this_to_string t_a')
-                         (that_to_string t_b)
-                         (that_to_string t_b')
-                         ()
-                   ;;
-
-                   let filteri (t_a, t_b) =
-                     let t_a' =
-                       This_queue.filteri t_a ~f:(fun i j ->
-                         [%equal: bool] (is_even i) (is_even j))
-                     in
-                     let t_b' =
-                       That_queue.filteri t_b ~f:(fun i j ->
-                         [%equal: bool] (is_even i) (is_even j))
-                     in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in filteri: %s -> %s vs. %s -> %s"
-                         (this_to_string t_a)
-                         (this_to_string t_a')
-                         (that_to_string t_b)
-                         (that_to_string t_b')
-                         ()
-                   ;;
-
-                   let filter_inplace (t_a, t_b) =
-                     let start_a = This_queue.to_array t_a in
-                     let start_b = That_queue.to_array t_b in
-                     This_queue.filter_inplace t_a ~f:is_even;
-                     That_queue.filter_inplace t_b ~f:is_even;
-                     let end_a = This_queue.to_array t_a in
-                     let end_b = That_queue.to_array t_b in
-                     if not ([%equal: int array] end_a end_b)
-                     then
-                       Printf.failwithf
-                         "error in filter_inplace: %s -> %s vs. %s -> %s"
-                         (array_string start_a)
-                         (array_string end_a)
-                         (array_string start_b)
-                         (array_string end_b)
-                         ()
-                   ;;
-
-                   let filteri_inplace (t_a, t_b) =
-                     let start_a = This_queue.to_array t_a in
-                     let start_b = That_queue.to_array t_b in
-                     let f i x = [%equal: bool] (is_even i) (is_even x) in
-                     This_queue.filteri_inplace t_a ~f;
-                     That_queue.filteri_inplace t_b ~f;
-                     let end_a = This_queue.to_array t_a in
-                     let end_b = That_queue.to_array t_b in
-                     if not ([%equal: int array] end_a end_b)
-                     then
-                       Printf.failwithf
-                         "error in filteri_inplace: %s -> %s vs. %s -> %s"
-                         (array_string start_a)
-                         (array_string end_a)
-                         (array_string start_b)
-                         (array_string end_b)
-                         ()
-                   ;;
-
-                   let concat_map (t_a, t_b) =
-                     let f x = [ x; x + 1; x + 2 ] in
-                     let t_a' = This_queue.concat_map t_a ~f in
-                     let t_b' = That_queue.concat_map t_b ~f in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in concat_map: %s (for %s) <> %s (for %s)"
-                         (this_to_string t_a')
-                         (this_to_string t_a)
-                         (that_to_string t_b')
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let concat_mapi (t_a, t_b) =
-                     let f i x = [ x; x + 1; x + 2; x + i ] in
-                     let t_a' = This_queue.concat_mapi t_a ~f in
-                     let t_b' = That_queue.concat_mapi t_b ~f in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in concat_mapi: %s (for %s) <> %s (for %s)"
-                         (this_to_string t_a')
-                         (this_to_string t_a)
-                         (that_to_string t_b')
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let filter_map (t_a, t_b) =
-                     let f x = if is_even x then None else Some (x + 1) in
-                     let t_a' = This_queue.filter_map t_a ~f in
-                     let t_b' = That_queue.filter_map t_b ~f in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in filter_map: %s (for %s) <> %s (for %s)"
-                         (this_to_string t_a')
-                         (this_to_string t_a)
-                         (that_to_string t_b')
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let filter_mapi (t_a, t_b) =
-                     let f i x =
-                       if [%equal: bool] (is_even i) (is_even x)
-                       then None
-                       else Some (x + 1 + i)
-                     in
-                     let t_a' = This_queue.filter_mapi t_a ~f in
-                     let t_b' = That_queue.filter_mapi t_b ~f in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in filter_mapi: %s (for %s) <> %s (for %s)"
-                         (this_to_string t_a')
-                         (this_to_string t_a)
-                         (that_to_string t_b')
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let map (t_a, t_b) =
-                     let f x = x * 7 in
-                     let t_a' = This_queue.map t_a ~f in
-                     let t_b' = That_queue.map t_b ~f in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in map: %s (for %s) <> %s (for %s)"
-                         (this_to_string t_a')
-                         (this_to_string t_a)
-                         (that_to_string t_b')
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let mapi (t_a, t_b) =
-                     let f i x = (x + 3) lxor i in
-                     let t_a' = This_queue.mapi t_a ~f in
-                     let t_b' = That_queue.mapi t_b ~f in
-                     if not
-                          ([%equal: int array]
-                             (This_queue.to_array t_a')
-                             (That_queue.to_array t_b'))
-                     then
-                       Printf.failwithf
-                         "error in mapi: %s (for %s) <> %s (for %s)"
-                         (this_to_string t_a')
-                         (this_to_string t_a)
-                         (that_to_string t_b')
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let counti (t_a, t_b) =
-                     let f i x = i < 7 && i % 7 = x % 7 in
-                     let a' = This_queue.counti t_a ~f in
-                     let b' = That_queue.counti t_b ~f in
-                     if a' <> b'
-                     then
-                       Printf.failwithf
-                         "error in counti: %d (for %s) <> %d (for %s)"
-                         a'
-                         (this_to_string t_a)
-                         b'
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let existsi (t_a, t_b) =
-                     let f i x = i < 7 && i % 7 = x % 7 in
-                     let a' = This_queue.existsi t_a ~f in
-                     let b' = That_queue.existsi t_b ~f in
-                     if not ([%equal: bool] a' b')
-                     then
-                       Printf.failwithf
-                         "error in existsi: %b (for %s) <> %b (for %s)"
-                         a'
-                         (this_to_string t_a)
-                         b'
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let for_alli (t_a, t_b) =
-                     let f i x = i >= 7 || i % 7 <> x % 7 in
-                     let a' = This_queue.for_alli t_a ~f in
-                     let b' = That_queue.for_alli t_b ~f in
-                     if not ([%equal: bool] a' b')
-                     then
-                       Printf.failwithf
-                         "error in for_alli: %b (for %s) <> %b (for %s)"
-                         a'
-                         (this_to_string t_a)
-                         b'
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let findi (t_a, t_b) =
-                     let f i x = i < 7 && i % 7 = x % 7 in
-                     let a' = This_queue.findi t_a ~f in
-                     let b' = That_queue.findi t_b ~f in
-                     if not ([%equal: (int * int) option] a' b')
-                     then
-                       Printf.failwithf
-                         "error in findi: %s (for %s) <> %s (for %s)"
-                         (Sexp.to_string ([%sexp_of: (int * int) option] a'))
-                         (this_to_string t_a)
-                         (Sexp.to_string ([%sexp_of: (int * int) option] b'))
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let find_mapi (t_a, t_b) =
-                     let f i x = if i < 7 && i % 7 = x % 7 then Some (i + x) else None in
-                     let a' = This_queue.find_mapi t_a ~f in
-                     let b' = That_queue.find_mapi t_b ~f in
-                     if not ([%equal: int option] a' b')
-                     then
-                       Printf.failwithf
-                         "error in find_mapi: %s (for %s) <> %s (for %s)"
-                         (Sexp.to_string ([%sexp_of: int option] a'))
-                         (this_to_string t_a)
-                         (Sexp.to_string ([%sexp_of: int option] b'))
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let copy (t_a, t_b) =
-                     let copy_a = This_queue.copy t_a in
-                     let copy_b = That_queue.copy t_b in
-                     let start_a = This_queue.to_array t_a in
-                     let start_b = That_queue.to_array t_b in
-                     let end_a = This_queue.to_array copy_a in
-                     let end_b = That_queue.to_array copy_b in
-                     if not ([%equal: int array] end_a end_b)
-                     then
-                       Printf.failwithf
-                         "error in copy: %s -> %s vs. %s -> %s"
-                         (array_string start_a)
-                         (array_string end_a)
-                         (array_string start_b)
-                         (array_string end_b)
-                         ()
-                   ;;
-
-                   let transfer (t_a, t_b) =
-                     let dst_a = This_queue.create () in
-                     let dst_b = That_queue.create () in
-                     (* sometimes puts some elements in the destination queues *)
-                     if Random.bool ()
-                     then
-                       List.iter [ 1; 2; 3; 4; 5 ] ~f:(fun elem ->
-                         This_queue.enqueue dst_a elem;
-                         That_queue.enqueue dst_b elem);
-                     let start_a = This_queue.to_array t_a in
-                     let start_b = That_queue.to_array t_b in
-                     This_queue.transfer ~src:t_a ~dst:dst_a;
-                     That_queue.transfer ~src:t_b ~dst:dst_b;
-                     let end_a = This_queue.to_array t_a in
-                     let end_b = That_queue.to_array t_b in
-                     let end_a' = This_queue.to_array dst_a in
-                     let end_b' = That_queue.to_array dst_b in
-                     if (not ([%equal: int array] end_a' end_b'))
-                        || not ([%equal: int array] end_a end_b)
-                     then
-                       Printf.failwithf
-                         "error in transfer: %s -> (%s, %s) vs. %s -> (%s, %s)"
-                         (array_string start_a)
-                         (array_string end_a)
-                         (array_string end_a')
-                         (array_string start_b)
-                         (array_string end_b)
-                         (array_string end_b)
-                         ()
-                   ;;
-
-                   let fold_check (t_a, t_b) =
-                     let make_list fold t = fold t ~init:[] ~f:(fun acc x -> x :: acc) in
-                     let this_l = make_list This_queue.fold t_a in
-                     let that_l = make_list That_queue.fold t_b in
-                     if not ([%equal: int list] this_l that_l)
-                     then
-                       Printf.failwithf
-                         "error in fold:  %s (from %s) <> %s (from %s)"
-                         (Sexp.to_string (this_l |> [%sexp_of: int list]))
-                         (this_to_string t_a)
-                         (Sexp.to_string (that_l |> [%sexp_of: int list]))
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let foldi_check (t_a, t_b) =
-                     let make_list foldi t =
-                       foldi t ~init:[] ~f:(fun i acc x -> (i, x) :: acc)
-                     in
-                     let this_l = make_list This_queue.foldi t_a in
-                     let that_l = make_list That_queue.foldi t_b in
-                     if not ([%equal: (int * int) list] this_l that_l)
-                     then
-                       Printf.failwithf
-                         "error in foldi:  %s (from %s) <> %s (from %s)"
-                         (Sexp.to_string (this_l |> [%sexp_of: (int * int) list]))
-                         (this_to_string t_a)
-                         (Sexp.to_string (that_l |> [%sexp_of: (int * int) list]))
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let length_check (t_a, t_b) =
-                     let this_len = This_queue.length t_a in
-                     let that_len = That_queue.length t_b in
-                     if this_len <> that_len
-                     then
-                       Printf.failwithf
-                         "error in length: %i (for %s) <> %i (for %s)"
-                         this_len
-                         (this_to_string t_a)
-                         that_len
-                         (that_to_string t_b)
-                         ()
-                   ;;
-
-                   let%test_unit _ =
-                     let t = create () in
-                     let rec loop ~all_ops ~non_empty_ops =
-                       if all_ops <= 0 && non_empty_ops <= 0
-                       then (
-                         let t_a, t_b = t in
-                         let arr_a = This_queue.to_array t_a in
-                         let arr_b = That_queue.to_array t_b in
-                         if not ([%equal: int array] arr_a arr_b)
-                         then
-                           Printf.failwithf
-                             "queue final states not equal: %s vs. %s"
-                             (array_string arr_a)
-                             (array_string arr_b)
-                             ())
-                       else (
-                         let queue_was_empty = This_queue.length (fst t) = 0 in
-                         let r = Random.int 200 in
-                         if r < 60
-                         then enqueue t (Random.int 10_000)
-                         else if r < 65
-                         then dequeue t
-                         else if r < 70
-                         then clear t
-                         else if r < 80
-                         then iter t
-                         else if r < 85
-                         then iteri t
-                         else if r < 90
-                         then fold_check t
-                         else if r < 95
-                         then foldi_check t
-                         else if r < 100
-                         then filter t
-                         else if r < 105
-                         then filteri t
-                         else if r < 110
-                         then concat_map t
-                         else if r < 115
-                         then concat_mapi t
-                         else if r < 120
-                         then transfer t
-                         else if r < 130
-                         then filter_map t
-                         else if r < 135
-                         then filter_mapi t
-                         else if r < 140
-                         then copy t
-                         else if r < 150
-                         then filter_inplace t
-                         else if r < 155
-                         then for_alli t
-                         else if r < 160
-                         then existsi t
-                         else if r < 165
-                         then counti t
-                         else if r < 170
-                         then findi t
-                         else if r < 175
-                         then find_mapi t
-                         else if r < 180
-                         then map t
-                         else if r < 185
-                         then mapi t
-                         else if r < 190
-                         then filteri_inplace t
-                         else if r < 195
-                         then length_check t
-                         else if r < 200
-                         then drain t
-                         else failwith "Impossible: We did [Random.int 200] above";
-                         loop
-                           ~all_ops:(all_ops - 1)
-                           ~non_empty_ops:
-                             (if queue_was_empty then non_empty_ops else non_empty_ops - 1))
-                     in
-                     loop ~all_ops:30_000 ~non_empty_ops:20_000
-                   ;;
-                 end)
-               ;;
-
-               let%test_unit "modification-during-iteration" =
-                 let x = `A 0 in
-                 let t = of_list [ x; x ] in
-                 let f (`A n) =
-                   ignore n;
-                   clear t
-                 in
-                 assert (does_raise (fun () -> iter t ~f))
-               ;;
-
-               let%test_unit "more-modification-during-iteration" =
-                 let nested_iter_okay = ref false in
-                 let t = of_list [ `iter; `clear ] in
-                 assert (
-                   does_raise (fun () ->
-                     iter t ~f:(function
-                       | `iter ->
-                         iter t ~f:ignore;
-                         nested_iter_okay := true
-                       | `clear -> clear t)));
-                 assert !nested_iter_okay
-               ;;
-
-               let%test_unit "modification-during-filter" =
-                 let reached_unreachable = ref false in
-                 let t = of_list [ `clear; `unreachable ] in
-                 let f x =
-                   match x with
-                   | `clear ->
-                     clear t;
-                     false
-                   | `unreachable ->
-                     reached_unreachable := true;
-                     false
-                 in
-                 assert (does_raise (fun () -> filter t ~f));
-                 assert (not !reached_unreachable)
-               ;;
-
-               let%test_unit "modification-during-filter-inplace" =
-                 let reached_unreachable = ref false in
-                 let t = of_list [ `drop_this; `enqueue_new_element; `unreachable ] in
-                 let f x =
-                   (match x with
-                    | `drop_this | `new_element -> ()
-                    | `enqueue_new_element -> enqueue t `new_element
-                    | `unreachable -> reached_unreachable := true);
-                   false
-                 in
-                 assert (does_raise (fun () -> filter_inplace t ~f));
-                 (* even though we said to drop the first element, the aborted call to [filter_inplace]
+  struct
+    open Queue
+
+    module type S = S
+
+    let does_raise = Exn.does_raise
+
+    type nonrec 'a t = 'a t [@@deriving sexp, sexp_grammar]
+
+    let globalize = globalize
+
+    let%expect_test _ =
+      let open Expect_test_helpers_base in
+      let check t =
+        require_does_not_raise (fun () ->
+          invariant ignore t;
+          print_s [%sexp (t : int t)])
+      in
+      let a = of_list [ 1; 2; 3 ] in
+      check a;
+      [%expect {| (1 2 3) |}];
+      let b = globalize globalize_int a in
+      check b;
+      [%expect {| (1 2 3) |}];
+      enqueue b 4;
+      print_s [%sexp (dequeue a : int option)];
+      [%expect {| (1) |}];
+      check a;
+      [%expect {| (2 3) |}];
+      check b;
+      [%expect {| (1 2 3 4) |}]
+    ;;
+
+    let capacity = capacity
+    let set_capacity = set_capacity
+
+    let%test_unit _ =
+      let t = create () in
+      [%test_result: int] (capacity t) ~expect:2;
+      enqueue t 1;
+      [%test_result: int] (capacity t) ~expect:2;
+      enqueue t 2;
+      [%test_result: int] (capacity t) ~expect:2;
+      enqueue t 3;
+      [%test_result: int] (capacity t) ~expect:4;
+      set_capacity t 0;
+      [%test_result: int] (capacity t) ~expect:4;
+      set_capacity t 3;
+      [%test_result: int] (capacity t) ~expect:4;
+      set_capacity t 100;
+      [%test_result: int] (capacity t) ~expect:128;
+      enqueue t 4;
+      enqueue t 5;
+      set_capacity t 0;
+      [%test_result: int] (capacity t) ~expect:8;
+      set_capacity t (-1);
+      [%test_result: int] (capacity t) ~expect:8
+    ;;
+
+    let round_trip_sexp t =
+      let sexp = sexp_of_t Int.sexp_of_t t in
+      let t' = t_of_sexp Int.t_of_sexp sexp in
+      [%test_result: int list] ~expect:(to_list t) (to_list t')
+    ;;
+
+    let%test_unit _ = round_trip_sexp (of_list [ 1; 2; 3; 4 ])
+    let%test_unit _ = round_trip_sexp (create ())
+    let%test_unit _ = round_trip_sexp (of_list [])
+    let invariant = invariant
+    let create = create
+
+    let%test_unit _ =
+      let t = create () in
+      [%test_result: int] (length t) ~expect:0;
+      [%test_result: int] (capacity t) ~expect:2
+    ;;
+
+    let%test_unit _ =
+      let t = create ~capacity:0 () in
+      [%test_result: int] (length t) ~expect:0;
+      [%test_result: int] (capacity t) ~expect:1
+    ;;
+
+    let%test_unit _ =
+      let t = create ~capacity:6 () in
+      [%test_result: int] (length t) ~expect:0;
+      [%test_result: int] (capacity t) ~expect:8
+    ;;
+
+    let%test_unit _ = assert (does_raise (fun () : _ Queue.t -> create ~capacity:(-1) ()))
+    let singleton = singleton
+
+    let%test_unit _ =
+      let t = singleton 7 in
+      [%test_result: int] (length t) ~expect:1;
+      [%test_result: int] (capacity t) ~expect:1;
+      [%test_result: int option] (dequeue t) ~expect:(Some 7);
+      [%test_result: int option] (dequeue t) ~expect:None
+    ;;
+
+    let init = init
+
+    let%test_unit _ =
+      let t = init 0 ~f:(fun _ -> assert false) in
+      [%test_result: int] (length t) ~expect:0;
+      [%test_result: int] (capacity t) ~expect:1;
+      [%test_result: int option] (dequeue t) ~expect:None
+    ;;
+
+    let%test_unit _ =
+      let t = init 3 ~f:(fun i -> i * 2) in
+      [%test_result: int] (length t) ~expect:3;
+      [%test_result: int] (capacity t) ~expect:4;
+      [%test_result: int option] (dequeue t) ~expect:(Some 0);
+      [%test_result: int option] (dequeue t) ~expect:(Some 2);
+      [%test_result: int option] (dequeue t) ~expect:(Some 4);
+      [%test_result: int option] (dequeue t) ~expect:None
+    ;;
+
+    let%test_unit _ =
+      assert (does_raise (fun () : unit Queue.t -> init (-1) ~f:(fun _ -> ())))
+    ;;
+
+    let get = get
+    let set = set
+
+    let%test_unit _ =
+      let t = create () in
+      let get_opt t i = Option.try_with (fun () -> get t i) in
+      [%test_result: int option] (get_opt t 0) ~expect:None;
+      [%test_result: int option] (get_opt t (-1)) ~expect:None;
+      [%test_result: int option] (get_opt t 10) ~expect:None;
+      List.iter [ -1; 0; 1 ] ~f:(fun i -> assert (does_raise (fun () -> set t i 0)));
+      enqueue t 0;
+      enqueue t 1;
+      enqueue t 2;
+      [%test_result: int option] (get_opt t 0) ~expect:(Some 0);
+      [%test_result: int option] (get_opt t 1) ~expect:(Some 1);
+      [%test_result: int option] (get_opt t 2) ~expect:(Some 2);
+      [%test_result: int option] (get_opt t 3) ~expect:None;
+      ignore (dequeue_exn t : int);
+      [%test_result: int option] (get_opt t 0) ~expect:(Some 1);
+      [%test_result: int option] (get_opt t 1) ~expect:(Some 2);
+      [%test_result: int option] (get_opt t 2) ~expect:None;
+      set t 0 3;
+      [%test_result: int option] (get_opt t 0) ~expect:(Some 3);
+      [%test_result: int option] (get_opt t 1) ~expect:(Some 2);
+      List.iter [ -1; 2 ] ~f:(fun i -> assert (does_raise (fun () -> set t i 0)))
+    ;;
+
+    let map = map
+
+    let%test_unit _ =
+      for i = 0 to 5 do
+        let l = List.init i ~f:Fn.id in
+        let t = of_list l in
+        let f x = x * 2 in
+        let t' = map t ~f in
+        [%test_result: int list] (to_list t') ~expect:(List.map l ~f)
+      done
+    ;;
+
+    let%test_unit _ =
+      let t = create () in
+      let t' = map t ~f:(fun x -> x * 2) in
+      [%test_result: int] (length t') ~expect:(length t);
+      [%test_result: int] (length t') ~expect:0;
+      [%test_result: int list] (to_list t') ~expect:[]
+    ;;
+
+    let mapi = mapi
+
+    let%test_unit _ =
+      for i = 0 to 5 do
+        let l = List.init i ~f:Fn.id in
+        let t = of_list l in
+        let f i x = i, x * 2 in
+        let t' = mapi t ~f in
+        [%test_result: (int * int) list] (to_list t') ~expect:(List.mapi l ~f)
+      done
+    ;;
+
+    let%test_unit _ =
+      let t = create () in
+      let t' = mapi t ~f:(fun i x -> i, x * 2) in
+      [%test_result: int] (length t') ~expect:(length t);
+      [%test_result: int] (length t') ~expect:0;
+      [%test_result: (int * int) list] (to_list t') ~expect:[]
+    ;;
+
+    include Test_container.Test_S1 (Queue)
+
+    let dequeue_exn = dequeue_exn
+    let enqueue = enqueue
+    let enqueue_front = enqueue_front
+    let dequeue_back = dequeue_back
+    let dequeue_back_exn = dequeue_back_exn
+    let peek = peek
+    let peek_exn = peek_exn
+    let peek_back = peek_back
+    let peek_back_exn = peek_back_exn
+    let last = last
+    let last_exn = last_exn
+
+    let%test_unit _ =
+      let t = create () in
+      [%test_result: int option] (peek t) ~expect:None;
+      [%test_result: int option] (last t) ~expect:None;
+      enqueue t 1;
+      enqueue t 2;
+      [%test_result: int option] (peek t) ~expect:(Some 1);
+      [%test_result: int] (peek_exn t) ~expect:1;
+      [%test_result: int option] (last t) ~expect:(Some 2);
+      [%test_result: int] (last_exn t) ~expect:2;
+      [%test_result: int] (dequeue_exn t) ~expect:1;
+      [%test_result: int] (dequeue_exn t) ~expect:2;
+      assert (does_raise (fun () -> dequeue_exn t));
+      assert (does_raise (fun () -> peek_exn t));
+      assert (does_raise (fun () -> peek_back_exn t));
+      assert (does_raise (fun () -> last_exn t));
+      enqueue_front t 1;
+      enqueue t 2;
+      enqueue_front t 0;
+      enqueue t 3;
+      enqueue t 4;
+      enqueue t 5;
+      [%test_result: int option] (peek_back t) ~expect:(Some 5);
+      [%test_result: int] (peek_back_exn t) ~expect:5;
+      [%test_result: int] (dequeue_exn t) ~expect:0;
+      [%test_result: int] (dequeue_exn t) ~expect:1;
+      [%test_result: int] (dequeue_exn t) ~expect:2;
+      [%test_result: int] (dequeue_back_exn t) ~expect:5;
+      [%test_result: int] (dequeue_back_exn t) ~expect:4;
+      [%test_result: int] (dequeue_back_exn t) ~expect:3
+    ;;
+
+    let dequeue_and_ignore_exn = dequeue_and_ignore_exn
+
+    let%test_unit _ =
+      let t = create () in
+      enqueue t 1;
+      enqueue t 2;
+      enqueue t 3;
+      [%test_result: int] (peek_exn t) ~expect:1;
+      dequeue_and_ignore_exn t;
+      [%test_result: int] (peek_exn t) ~expect:2;
+      dequeue_and_ignore_exn t;
+      [%test_result: int] (peek_exn t) ~expect:3;
+      dequeue_and_ignore_exn t;
+      [%test_result: int option] (peek t) ~expect:None;
+      assert (does_raise (fun () -> dequeue_and_ignore_exn t));
+      assert (does_raise (fun () -> dequeue_and_ignore_exn t));
+      [%test_result: int option] (peek t) ~expect:None
+    ;;
+
+    let drain = drain
+
+    let%test_unit _ =
+      let t = create () in
+      for i = 0 to 10 do
+        enqueue t i
+      done;
+      [%test_result: int] (peek_exn t) ~expect:0;
+      [%test_result: int] (length t) ~expect:11;
+      let r = ref 0 in
+      let add i = r := !r + i in
+      drain t ~f:add ~while_:(fun i -> i < 7);
+      [%test_result: int] (peek_exn t) ~expect:7;
+      [%test_result: int] (length t) ~expect:4;
+      [%test_result: int] !r ~expect:21;
+      drain t ~f:add ~while_:(fun i -> i > 7);
+      [%test_result: int] (peek_exn t) ~expect:7;
+      [%test_result: int] (length t) ~expect:4;
+      [%test_result: int] !r ~expect:21;
+      drain t ~f:add ~while_:(fun i -> i > 0);
+      [%test_result: int option] (peek t) ~expect:None;
+      [%test_result: int] (length t) ~expect:0;
+      [%test_result: int] !r ~expect:55
+    ;;
+
+    let enqueue_all = enqueue_all
+
+    let%test_unit _ =
+      let t = create () in
+      enqueue_all t [ 1; 2; 3 ];
+      [%test_result: int] (dequeue_exn t) ~expect:1;
+      [%test_result: int] (dequeue_exn t) ~expect:2;
+      [%test_result: int option] (last t) ~expect:(Some 3);
+      enqueue_all t [ 4; 5 ];
+      [%test_result: int option] (last t) ~expect:(Some 5);
+      [%test_result: int] (dequeue_exn t) ~expect:3;
+      [%test_result: int] (dequeue_exn t) ~expect:4;
+      [%test_result: int] (dequeue_exn t) ~expect:5;
+      assert (does_raise (fun () -> dequeue_exn t));
+      enqueue_all t [];
+      assert (does_raise (fun () -> dequeue_exn t))
+    ;;
+
+    let of_list = of_list
+    let to_list = to_list
+
+    let%test_unit _ =
+      for i = 0 to 4 do
+        let list = List.init i ~f:Fn.id in
+        [%test_result: int list] (to_list (of_list list)) ~expect:list
+      done
+    ;;
+
+    let%test _ =
+      let t = create () in
+      for i = 1 to 5 do
+        enqueue t i
+      done;
+      [%equal: int list] (to_list t) [ 1; 2; 3; 4; 5 ]
+    ;;
+
+    let of_array = of_array
+    let to_array = to_array
+
+    let%test_unit _ =
+      for len = 0 to 4 do
+        let array = Array.init len ~f:Fn.id in
+        [%test_result: int array] (to_array (of_array array)) ~expect:array
+      done
+    ;;
+
+    let compare = compare
+    let compare__local = compare__local
+    let equal = equal
+    let equal__local = equal__local
+
+    let%test_module "comparisons" =
+      (module struct
+        let sign x = if x < 0 then ~-1 else if x > 0 then 1 else 0
+
+        let test t1 t2 =
+          [%test_result: bool]
+            (equal Int.equal t1 t2)
+            ~expect:(List.equal Int.equal (to_list t1) (to_list t2));
+          [%test_result: int]
+            (sign (compare Int.compare t1 t2))
+            ~expect:(sign (List.compare Int.compare (to_list t1) (to_list t2)));
+          [%test_result: bool]
+            (equal__local Int.equal__local t1 t2)
+            ~expect:(List.equal__local Int.equal__local (to_list t1) (to_list t2));
+          [%test_result: int]
+            (sign (compare__local Int.compare__local t1 t2))
+            ~expect:
+              (sign (List.compare__local Int.compare__local (to_list t1) (to_list t2)))
+        ;;
+
+        let lists =
+          [ []
+          ; [ 1 ]
+          ; [ 2 ]
+          ; [ 1; 1 ]
+          ; [ 1; 2 ]
+          ; [ 2; 1 ]
+          ; [ 1; 1; 1 ]
+          ; [ 1; 2; 3 ]
+          ; [ 1; 2; 4 ]
+          ; [ 1; 2; 4; 8 ]
+          ; [ 1; 2; 3; 4; 5 ]
+          ]
+        ;;
+
+        let%test_unit _ =
+          (* [phys_equal] inputs *)
+          List.iter lists ~f:(fun list ->
+            let t = of_list list in
+            test t t)
+        ;;
+
+        let%test_unit _ =
+          List.iter lists ~f:(fun list1 ->
+            List.iter lists ~f:(fun list2 -> test (of_list list1) (of_list list2)))
+        ;;
+      end)
+    ;;
+
+    let clear = clear
+
+    let%test_unit "clear" =
+      let q = of_list [ 1; 2; 3; 4 ] in
+      [%test_result: int] (length q) ~expect:4;
+      clear q;
+      [%test_result: int] (length q) ~expect:0
+    ;;
+
+    let blit_transfer = blit_transfer
+
+    let%test_unit _ =
+      let q_list = [ 1; 2; 3; 4 ] in
+      let q = of_list q_list in
+      let q' = create () in
+      blit_transfer ~src:q ~dst:q' ();
+      [%test_result: int list] (to_list q') ~expect:q_list;
+      [%test_result: int list] (to_list q) ~expect:[]
+    ;;
+
+    let%test_unit _ =
+      let q = of_list [ 1; 2; 3; 4 ] in
+      let q' = create () in
+      blit_transfer ~src:q ~dst:q' ~len:2 ();
+      [%test_result: int list] (to_list q') ~expect:[ 1; 2 ];
+      [%test_result: int list] (to_list q) ~expect:[ 3; 4 ]
+    ;;
+
+    let%test_unit "blit_transfer on wrapped queues" =
+      let list = [ 1; 2; 3; 4 ] in
+      let q = of_list list in
+      let q' = copy q in
+      ignore (dequeue_exn q : int);
+      ignore (dequeue_exn q : int);
+      ignore (dequeue_exn q' : int);
+      ignore (dequeue_exn q' : int);
+      ignore (dequeue_exn q' : int);
+      enqueue q 5;
+      enqueue q 6;
+      blit_transfer ~src:q ~dst:q' ~len:3 ();
+      [%test_result: int list] (to_list q') ~expect:[ 4; 3; 4; 5 ];
+      [%test_result: int list] (to_list q) ~expect:[ 6 ]
+    ;;
+
+    let copy = copy
+
+    let%test_unit "copies behave independently" =
+      let q = of_list [ 1; 2; 3; 4 ] in
+      let q' = copy q in
+      enqueue q 5;
+      ignore (dequeue_exn q' : int);
+      [%test_result: int list] (to_list q) ~expect:[ 1; 2; 3; 4; 5 ];
+      [%test_result: int list] (to_list q') ~expect:[ 2; 3; 4 ]
+    ;;
+
+    let dequeue = dequeue
+    let filter = filter
+    let filteri = filteri
+    let filter_inplace = filter_inplace
+    let filteri_inplace = filteri_inplace
+    let concat_map = concat_map
+    let concat_mapi = concat_mapi
+    let filter_map = filter_map
+    let filter_mapi = filter_mapi
+    let counti = counti
+    let existsi = existsi
+    let for_alli = for_alli
+    let iter = iter
+    let iteri = iteri
+    let foldi = foldi
+    let findi = findi
+    let find_mapi = find_mapi
+
+    let%test_module "Linked_queue bisimulation" =
+      (module struct
+        module type Queue_intf = sig
+          type 'a t [@@deriving sexp_of]
+
+          val create : unit -> 'a t
+          val enqueue : 'a t -> 'a -> unit
+          val dequeue : 'a t -> 'a option
+          val drain : 'a t -> f:('a -> unit) -> while_:('a -> bool) -> unit
+          val to_array : 'a t -> 'a array
+          val fold : 'a t -> init:'b -> f:('b -> 'a -> 'b) -> 'b
+          val foldi : 'a t -> init:'b -> f:(int -> 'b -> 'a -> 'b) -> 'b
+          val iter : 'a t -> f:('a -> unit) -> unit
+          val iteri : 'a t -> f:(int -> 'a -> unit) -> unit
+          val length : 'a t -> int
+          val clear : 'a t -> unit
+          val concat_map : 'a t -> f:('a -> 'b list) -> 'b t
+          val concat_mapi : 'a t -> f:(int -> 'a -> 'b list) -> 'b t
+          val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
+          val filter_mapi : 'a t -> f:(int -> 'a -> 'b option) -> 'b t
+          val filter : 'a t -> f:('a -> bool) -> 'a t
+          val filteri : 'a t -> f:(int -> 'a -> bool) -> 'a t
+          val filter_inplace : 'a t -> f:('a -> bool) -> unit
+          val filteri_inplace : 'a t -> f:(int -> 'a -> bool) -> unit
+          val map : 'a t -> f:('a -> 'b) -> 'b t
+          val mapi : 'a t -> f:(int -> 'a -> 'b) -> 'b t
+          val counti : 'a t -> f:(int -> 'a -> bool) -> int
+          val existsi : 'a t -> f:(int -> 'a -> bool) -> bool
+          val for_alli : 'a t -> f:(int -> 'a -> bool) -> bool
+          val findi : 'a t -> f:(int -> 'a -> bool) -> (int * 'a) option
+          val find_mapi : 'a t -> f:(int -> 'a -> 'b option) -> 'b option
+          val transfer : src:'a t -> dst:'a t -> unit
+          val copy : 'a t -> 'a t
+        end
+
+        module That_queue : Queue_intf = Linked_queue
+
+        module This_queue : Queue_intf = struct
+          include Queue
+
+          let create () = create ()
+          let transfer ~src ~dst = blit_transfer ~src ~dst ()
+        end
+
+        let this_to_string this_t = Sexp.to_string (this_t |> [%sexp_of: int This_queue.t])
+        let that_to_string that_t = Sexp.to_string (that_t |> [%sexp_of: int That_queue.t])
+        let array_string arr = Sexp.to_string (arr |> [%sexp_of: int array])
+        let create () = This_queue.create (), That_queue.create ()
+
+        let enqueue (t_a, t_b) v =
+          let start_a = This_queue.to_array t_a in
+          let start_b = That_queue.to_array t_b in
+          This_queue.enqueue t_a v;
+          That_queue.enqueue t_b v;
+          let end_a = This_queue.to_array t_a in
+          let end_b = That_queue.to_array t_b in
+          if not ([%equal: int array] end_a end_b)
+          then
+            Printf.failwithf
+              "enqueue transition failure of: %s -> %s vs. %s -> %s"
+              (array_string start_a)
+              (array_string end_a)
+              (array_string start_b)
+              (array_string end_b)
+              ()
+        ;;
+
+        let iter (t_a, t_b) =
+          let r_a, r_b = ref 0, ref 0 in
+          This_queue.iter t_a ~f:(fun x -> r_a := !r_a + x);
+          That_queue.iter t_b ~f:(fun x -> r_b := !r_b + x);
+          if !r_a <> !r_b
+          then
+            Printf.failwithf
+              "error in iter: %s (from %s) <> %s (from %s)"
+              (Int.to_string !r_a)
+              (this_to_string t_a)
+              (Int.to_string !r_b)
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let iteri (t_a, t_b) =
+          let r_a, r_b = ref 0, ref 0 in
+          This_queue.iteri t_a ~f:(fun i x -> r_a := !r_a + (x lxor i));
+          That_queue.iteri t_b ~f:(fun i x -> r_b := !r_b + (x lxor i));
+          if !r_a <> !r_b
+          then
+            Printf.failwithf
+              "error in iteri: %s (from %s) <> %s (from %s)"
+              (Int.to_string !r_a)
+              (this_to_string t_a)
+              (Int.to_string !r_b)
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let dequeue (t_a, t_b) =
+          let start_a = This_queue.to_array t_a in
+          let start_b = That_queue.to_array t_b in
+          let a, b = This_queue.dequeue t_a, That_queue.dequeue t_b in
+          let end_a = This_queue.to_array t_a in
+          let end_b = That_queue.to_array t_b in
+          if (not ([%equal: int option] a b)) || not ([%equal: int array] end_a end_b)
+          then
+            Printf.failwithf
+              "error in dequeue: %s (%s -> %s) <> %s (%s -> %s)"
+              (Option.value ~default:"None" (Option.map a ~f:Int.to_string))
+              (array_string start_a)
+              (array_string end_a)
+              (Option.value ~default:"None" (Option.map b ~f:Int.to_string))
+              (array_string start_b)
+              (array_string end_b)
+              ()
+        ;;
+
+        let is_even x = x land 1 = 0
+
+        let drain (t_a, t_b) =
+          let orig_a = This_queue.to_array t_a in
+          let orig_b = That_queue.to_array t_b in
+          let r_a = ref 0 in
+          let r_b = ref 0 in
+          let add r i = r := !r + i in
+          This_queue.drain t_a ~f:(fun i -> add r_a i) ~while_:is_even;
+          That_queue.drain t_b ~f:(fun i -> add r_b i) ~while_:is_even;
+          if not
+               ([%equal: int array] (This_queue.to_array t_a) (That_queue.to_array t_b)
+                && !r_a = !r_b)
+          then
+            Printf.failwithf
+              "error in drain: %s -> %s, %d vs. %s -> %s, %d"
+              (array_string orig_a)
+              (this_to_string t_a)
+              !r_a
+              (array_string orig_b)
+              (that_to_string t_b)
+              !r_b
+              ()
+        ;;
+
+        let clear (t_a, t_b) =
+          This_queue.clear t_a;
+          That_queue.clear t_b
+        ;;
+
+        let filter (t_a, t_b) =
+          let t_a' = This_queue.filter t_a ~f:is_even in
+          let t_b' = That_queue.filter t_b ~f:is_even in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in filter: %s -> %s vs. %s -> %s"
+              (this_to_string t_a)
+              (this_to_string t_a')
+              (that_to_string t_b)
+              (that_to_string t_b')
+              ()
+        ;;
+
+        let filteri (t_a, t_b) =
+          let t_a' =
+            This_queue.filteri t_a ~f:(fun i j -> [%equal: bool] (is_even i) (is_even j))
+          in
+          let t_b' =
+            That_queue.filteri t_b ~f:(fun i j -> [%equal: bool] (is_even i) (is_even j))
+          in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in filteri: %s -> %s vs. %s -> %s"
+              (this_to_string t_a)
+              (this_to_string t_a')
+              (that_to_string t_b)
+              (that_to_string t_b')
+              ()
+        ;;
+
+        let filter_inplace (t_a, t_b) =
+          let start_a = This_queue.to_array t_a in
+          let start_b = That_queue.to_array t_b in
+          This_queue.filter_inplace t_a ~f:is_even;
+          That_queue.filter_inplace t_b ~f:is_even;
+          let end_a = This_queue.to_array t_a in
+          let end_b = That_queue.to_array t_b in
+          if not ([%equal: int array] end_a end_b)
+          then
+            Printf.failwithf
+              "error in filter_inplace: %s -> %s vs. %s -> %s"
+              (array_string start_a)
+              (array_string end_a)
+              (array_string start_b)
+              (array_string end_b)
+              ()
+        ;;
+
+        let filteri_inplace (t_a, t_b) =
+          let start_a = This_queue.to_array t_a in
+          let start_b = That_queue.to_array t_b in
+          let f i x = [%equal: bool] (is_even i) (is_even x) in
+          This_queue.filteri_inplace t_a ~f;
+          That_queue.filteri_inplace t_b ~f;
+          let end_a = This_queue.to_array t_a in
+          let end_b = That_queue.to_array t_b in
+          if not ([%equal: int array] end_a end_b)
+          then
+            Printf.failwithf
+              "error in filteri_inplace: %s -> %s vs. %s -> %s"
+              (array_string start_a)
+              (array_string end_a)
+              (array_string start_b)
+              (array_string end_b)
+              ()
+        ;;
+
+        let concat_map (t_a, t_b) =
+          let f x = [ x; x + 1; x + 2 ] in
+          let t_a' = This_queue.concat_map t_a ~f in
+          let t_b' = That_queue.concat_map t_b ~f in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in concat_map: %s (for %s) <> %s (for %s)"
+              (this_to_string t_a')
+              (this_to_string t_a)
+              (that_to_string t_b')
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let concat_mapi (t_a, t_b) =
+          let f i x = [ x; x + 1; x + 2; x + i ] in
+          let t_a' = This_queue.concat_mapi t_a ~f in
+          let t_b' = That_queue.concat_mapi t_b ~f in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in concat_mapi: %s (for %s) <> %s (for %s)"
+              (this_to_string t_a')
+              (this_to_string t_a)
+              (that_to_string t_b')
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let filter_map (t_a, t_b) =
+          let f x = if is_even x then None else Some (x + 1) in
+          let t_a' = This_queue.filter_map t_a ~f in
+          let t_b' = That_queue.filter_map t_b ~f in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in filter_map: %s (for %s) <> %s (for %s)"
+              (this_to_string t_a')
+              (this_to_string t_a)
+              (that_to_string t_b')
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let filter_mapi (t_a, t_b) =
+          let f i x =
+            if [%equal: bool] (is_even i) (is_even x) then None else Some (x + 1 + i)
+          in
+          let t_a' = This_queue.filter_mapi t_a ~f in
+          let t_b' = That_queue.filter_mapi t_b ~f in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in filter_mapi: %s (for %s) <> %s (for %s)"
+              (this_to_string t_a')
+              (this_to_string t_a)
+              (that_to_string t_b')
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let map (t_a, t_b) =
+          let f x = x * 7 in
+          let t_a' = This_queue.map t_a ~f in
+          let t_b' = That_queue.map t_b ~f in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in map: %s (for %s) <> %s (for %s)"
+              (this_to_string t_a')
+              (this_to_string t_a)
+              (that_to_string t_b')
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let mapi (t_a, t_b) =
+          let f i x = (x + 3) lxor i in
+          let t_a' = This_queue.mapi t_a ~f in
+          let t_b' = That_queue.mapi t_b ~f in
+          if not
+               ([%equal: int array] (This_queue.to_array t_a') (That_queue.to_array t_b'))
+          then
+            Printf.failwithf
+              "error in mapi: %s (for %s) <> %s (for %s)"
+              (this_to_string t_a')
+              (this_to_string t_a)
+              (that_to_string t_b')
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let counti (t_a, t_b) =
+          let f i x = i < 7 && i % 7 = x % 7 in
+          let a' = This_queue.counti t_a ~f in
+          let b' = That_queue.counti t_b ~f in
+          if a' <> b'
+          then
+            Printf.failwithf
+              "error in counti: %d (for %s) <> %d (for %s)"
+              a'
+              (this_to_string t_a)
+              b'
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let existsi (t_a, t_b) =
+          let f i x = i < 7 && i % 7 = x % 7 in
+          let a' = This_queue.existsi t_a ~f in
+          let b' = That_queue.existsi t_b ~f in
+          if not ([%equal: bool] a' b')
+          then
+            Printf.failwithf
+              "error in existsi: %b (for %s) <> %b (for %s)"
+              a'
+              (this_to_string t_a)
+              b'
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let for_alli (t_a, t_b) =
+          let f i x = i >= 7 || i % 7 <> x % 7 in
+          let a' = This_queue.for_alli t_a ~f in
+          let b' = That_queue.for_alli t_b ~f in
+          if not ([%equal: bool] a' b')
+          then
+            Printf.failwithf
+              "error in for_alli: %b (for %s) <> %b (for %s)"
+              a'
+              (this_to_string t_a)
+              b'
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let findi (t_a, t_b) =
+          let f i x = i < 7 && i % 7 = x % 7 in
+          let a' = This_queue.findi t_a ~f in
+          let b' = That_queue.findi t_b ~f in
+          if not ([%equal: (int * int) option] a' b')
+          then
+            Printf.failwithf
+              "error in findi: %s (for %s) <> %s (for %s)"
+              (Sexp.to_string ([%sexp_of: (int * int) option] a'))
+              (this_to_string t_a)
+              (Sexp.to_string ([%sexp_of: (int * int) option] b'))
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let find_mapi (t_a, t_b) =
+          let f i x = if i < 7 && i % 7 = x % 7 then Some (i + x) else None in
+          let a' = This_queue.find_mapi t_a ~f in
+          let b' = That_queue.find_mapi t_b ~f in
+          if not ([%equal: int option] a' b')
+          then
+            Printf.failwithf
+              "error in find_mapi: %s (for %s) <> %s (for %s)"
+              (Sexp.to_string ([%sexp_of: int option] a'))
+              (this_to_string t_a)
+              (Sexp.to_string ([%sexp_of: int option] b'))
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let copy (t_a, t_b) =
+          let copy_a = This_queue.copy t_a in
+          let copy_b = That_queue.copy t_b in
+          let start_a = This_queue.to_array t_a in
+          let start_b = That_queue.to_array t_b in
+          let end_a = This_queue.to_array copy_a in
+          let end_b = That_queue.to_array copy_b in
+          if not ([%equal: int array] end_a end_b)
+          then
+            Printf.failwithf
+              "error in copy: %s -> %s vs. %s -> %s"
+              (array_string start_a)
+              (array_string end_a)
+              (array_string start_b)
+              (array_string end_b)
+              ()
+        ;;
+
+        let transfer (t_a, t_b) =
+          let dst_a = This_queue.create () in
+          let dst_b = That_queue.create () in
+          (* sometimes puts some elements in the destination queues *)
+          if Random.bool ()
+          then
+            List.iter [ 1; 2; 3; 4; 5 ] ~f:(fun elem ->
+              This_queue.enqueue dst_a elem;
+              That_queue.enqueue dst_b elem);
+          let start_a = This_queue.to_array t_a in
+          let start_b = That_queue.to_array t_b in
+          This_queue.transfer ~src:t_a ~dst:dst_a;
+          That_queue.transfer ~src:t_b ~dst:dst_b;
+          let end_a = This_queue.to_array t_a in
+          let end_b = That_queue.to_array t_b in
+          let end_a' = This_queue.to_array dst_a in
+          let end_b' = That_queue.to_array dst_b in
+          if (not ([%equal: int array] end_a' end_b'))
+             || not ([%equal: int array] end_a end_b)
+          then
+            Printf.failwithf
+              "error in transfer: %s -> (%s, %s) vs. %s -> (%s, %s)"
+              (array_string start_a)
+              (array_string end_a)
+              (array_string end_a')
+              (array_string start_b)
+              (array_string end_b)
+              (array_string end_b)
+              ()
+        ;;
+
+        let fold_check (t_a, t_b) =
+          let make_list fold t = fold t ~init:[] ~f:(fun acc x -> x :: acc) in
+          let this_l = make_list This_queue.fold t_a in
+          let that_l = make_list That_queue.fold t_b in
+          if not ([%equal: int list] this_l that_l)
+          then
+            Printf.failwithf
+              "error in fold:  %s (from %s) <> %s (from %s)"
+              (Sexp.to_string (this_l |> [%sexp_of: int list]))
+              (this_to_string t_a)
+              (Sexp.to_string (that_l |> [%sexp_of: int list]))
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let foldi_check (t_a, t_b) =
+          let make_list foldi t = foldi t ~init:[] ~f:(fun i acc x -> (i, x) :: acc) in
+          let this_l = make_list This_queue.foldi t_a in
+          let that_l = make_list That_queue.foldi t_b in
+          if not ([%equal: (int * int) list] this_l that_l)
+          then
+            Printf.failwithf
+              "error in foldi:  %s (from %s) <> %s (from %s)"
+              (Sexp.to_string (this_l |> [%sexp_of: (int * int) list]))
+              (this_to_string t_a)
+              (Sexp.to_string (that_l |> [%sexp_of: (int * int) list]))
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let length_check (t_a, t_b) =
+          let this_len = This_queue.length t_a in
+          let that_len = That_queue.length t_b in
+          if this_len <> that_len
+          then
+            Printf.failwithf
+              "error in length: %i (for %s) <> %i (for %s)"
+              this_len
+              (this_to_string t_a)
+              that_len
+              (that_to_string t_b)
+              ()
+        ;;
+
+        let%test_unit _ =
+          let t = create () in
+          let rec loop ~all_ops ~non_empty_ops =
+            if all_ops <= 0 && non_empty_ops <= 0
+            then (
+              let t_a, t_b = t in
+              let arr_a = This_queue.to_array t_a in
+              let arr_b = That_queue.to_array t_b in
+              if not ([%equal: int array] arr_a arr_b)
+              then
+                Printf.failwithf
+                  "queue final states not equal: %s vs. %s"
+                  (array_string arr_a)
+                  (array_string arr_b)
+                  ())
+            else (
+              let queue_was_empty = This_queue.length (fst t) = 0 in
+              let r = Random.int 200 in
+              if r < 60
+              then enqueue t (Random.int 10_000)
+              else if r < 65
+              then dequeue t
+              else if r < 70
+              then clear t
+              else if r < 80
+              then iter t
+              else if r < 85
+              then iteri t
+              else if r < 90
+              then fold_check t
+              else if r < 95
+              then foldi_check t
+              else if r < 100
+              then filter t
+              else if r < 105
+              then filteri t
+              else if r < 110
+              then concat_map t
+              else if r < 115
+              then concat_mapi t
+              else if r < 120
+              then transfer t
+              else if r < 130
+              then filter_map t
+              else if r < 135
+              then filter_mapi t
+              else if r < 140
+              then copy t
+              else if r < 150
+              then filter_inplace t
+              else if r < 155
+              then for_alli t
+              else if r < 160
+              then existsi t
+              else if r < 165
+              then counti t
+              else if r < 170
+              then findi t
+              else if r < 175
+              then find_mapi t
+              else if r < 180
+              then map t
+              else if r < 185
+              then mapi t
+              else if r < 190
+              then filteri_inplace t
+              else if r < 195
+              then length_check t
+              else if r < 200
+              then drain t
+              else failwith "Impossible: We did [Random.int 200] above";
+              loop
+                ~all_ops:(all_ops - 1)
+                ~non_empty_ops:
+                  (if queue_was_empty then non_empty_ops else non_empty_ops - 1))
+          in
+          loop ~all_ops:30_000 ~non_empty_ops:20_000
+        ;;
+      end)
+    ;;
+
+    let%test_unit "modification-during-iteration" =
+      let x = `A 0 in
+      let t = of_list [ x; x ] in
+      let f (`A n) =
+        ignore n;
+        clear t
+      in
+      assert (does_raise (fun () -> iter t ~f))
+    ;;
+
+    let%test_unit "more-modification-during-iteration" =
+      let nested_iter_okay = ref false in
+      let t = of_list [ `iter; `clear ] in
+      assert (
+        does_raise (fun () ->
+          iter t ~f:(function
+            | `iter ->
+              iter t ~f:ignore;
+              nested_iter_okay := true
+            | `clear -> clear t)));
+      assert !nested_iter_okay
+    ;;
+
+    let%test_unit "modification-during-filter" =
+      let reached_unreachable = ref false in
+      let t = of_list [ `clear; `unreachable ] in
+      let f x =
+        match x with
+        | `clear ->
+          clear t;
+          false
+        | `unreachable ->
+          reached_unreachable := true;
+          false
+      in
+      assert (does_raise (fun () -> filter t ~f));
+      assert (not !reached_unreachable)
+    ;;
+
+    let%test_unit "modification-during-filter-inplace" =
+      let reached_unreachable = ref false in
+      let t = of_list [ `drop_this; `enqueue_new_element; `unreachable ] in
+      let f x =
+        (match x with
+         | `drop_this | `new_element -> ()
+         | `enqueue_new_element -> enqueue t `new_element
+         | `unreachable -> reached_unreachable := true);
+        false
+      in
+      assert (does_raise (fun () -> filter_inplace t ~f));
+      (* even though we said to drop the first element, the aborted call to [filter_inplace]
           shouldn't have made that change *)
-                 (match peek_exn t with
-                  | `drop_this -> ()
-                  | `new_element | `enqueue_new_element | `unreachable ->
-                    failwith "Expected the first element to be `drop_this");
-                 assert (not !reached_unreachable)
-               ;;
-
-               let%test_unit "filter-inplace-during-iteration" =
-                 let reached_unreachable = ref false in
-                 let t = of_list [ `filter_inplace; `unreachable ] in
-                 let f x =
-                   match x with
-                   | `filter_inplace -> filter_inplace t ~f:(fun _ -> false)
-                   | `unreachable -> reached_unreachable := true
-                 in
-                 assert (does_raise (fun () -> iter t ~f));
-                 assert (not !reached_unreachable)
-               ;;
-
-               module Iteration = struct
-                 type t = Iteration.t
-
-                 let start = Iteration.start
-
-                 let assert_no_mutation_since_start =
-                   Iteration.assert_no_mutation_since_start
-                 ;;
-
-                 let%expect_test "mutation-detection" =
-                   let open Expect_test_helpers_base in
-                   let t = of_list [ `elt ] in
-                   let token = start t in
-                   let `elt = get t 0 in
-                   require_does_not_raise [%here] (fun () ->
-                     assert_no_mutation_since_start token t);
-                   [%expect {| |}];
-                   enqueue t `elt;
-                   require_does_raise [%here] (fun () ->
-                     assert_no_mutation_since_start token t);
-                   [%expect
-                     {|
-           ("mutation of queue during iteration" (
-             (num_mutations 2)
-             (front         0)
-             (mask          1)
-             (length        2)
-             (elts (
-               (_)
-               (_)))))
-           |}]
-                 ;;
-               end
-             end
-             (* This signature is here to remind us to update the unit tests whenever we
+      (match peek_exn t with
+       | `drop_this -> ()
+       | `new_element | `enqueue_new_element | `unreachable ->
+         failwith "Expected the first element to be `drop_this");
+      assert (not !reached_unreachable)
+    ;;
+
+    let%test_unit "filter-inplace-during-iteration" =
+      let reached_unreachable = ref false in
+      let t = of_list [ `filter_inplace; `unreachable ] in
+      let f x =
+        match x with
+        | `filter_inplace -> filter_inplace t ~f:(fun _ -> false)
+        | `unreachable -> reached_unreachable := true
+      in
+      assert (does_raise (fun () -> iter t ~f));
+      assert (not !reached_unreachable)
+    ;;
+
+    module Iteration = struct
+      type t = Iteration.t
+
+      let start = Iteration.start
+      let assert_no_mutation_since_start = Iteration.assert_no_mutation_since_start
+
+      let%expect_test "mutation-detection" =
+        let open Expect_test_helpers_base in
+        let t = of_list [ `elt ] in
+        let token = start t in
+        let `elt = get t 0 in
+        require_does_not_raise (fun () -> assert_no_mutation_since_start token t);
+        [%expect {| |}];
+        enqueue t `elt;
+        require_does_raise (fun () -> assert_no_mutation_since_start token t);
+        [%expect
+          {|
+          ("mutation of queue during iteration" (
+            (num_mutations 2)
+            (front         0)
+            (mask          1)
+            (length        2)
+            (elts (
+              (_)
+              (_)))))
+          |}]
+      ;;
+    end
+  end
+  (* This signature is here to remind us to update the unit tests whenever we
       change [Queue]. *) :
-               module type of Queue))
+    module type of Queue))
 ;;
diff --git a/test/test_random.ml b/test/test_random.ml
index 95c04614..728cdd3f 100644
--- a/test/test_random.ml
+++ b/test/test_random.ml
@@ -46,7 +46,7 @@ let test (type t) here m count generate ~min ~max ~check_range:(lo, hi) =
     List.init count ~f:(fun _ -> generate ()) |> List.dedup_and_sort ~compare:T.compare
   in
   require
-    here
+    ~here
     (List.for_all generated ~f:(fun t -> between t ~lower_bound:min ~upper_bound:max))
     ~if_false_then_print_s:
       (lazy
@@ -56,7 +56,7 @@ let test (type t) here m count generate ~min ~max ~check_range:(lo, hi) =
             (max : T.t)
             (generated : T.t list)]);
   require
-    here
+    ~here
     (List.exists generated ~f:(fun t -> between t ~lower_bound:lo ~upper_bound:hi))
     ~if_false_then_print_s:
       (lazy
diff --git a/test/test_ref.ml b/test/test_ref.ml
index 518f0715..2db65278 100644
--- a/test/test_ref.ml
+++ b/test/test_ref.ml
@@ -9,10 +9,10 @@ let%test_unit "[set_temporarily] without raise" =
 
 let%expect_test "[set_temporarily] with raise" =
   let r = ref 0 in
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Nothing.unreachable_code (set_temporarily r 1 ~f:(fun () -> failwith "")));
   [%expect {| (Failure "") |}];
-  require_equal [%here] (module Int) !r 0
+  require_equal (module Int) !r 0
 ;;
 
 let%test_unit "[set_temporarily] where [f] sets the ref" =
@@ -30,7 +30,6 @@ let%expect_test "[sets_temporarily] without raise" =
     sets_temporarily and_values ~f:(fun () ->
       print_s [%message (r1 : int ref) (r2 : int ref)]);
     require_equal
-      [%here]
       (module struct
         type t = int * int [@@deriving equal, sexp_of]
       end)
@@ -38,22 +37,26 @@ let%expect_test "[sets_temporarily] without raise" =
       (i1, i2)
   in
   test [];
-  [%expect {|
+  [%expect
+    {|
     ((r1 1)
      (r2 2))
     |}];
   test [ T (r1, 13) ];
-  [%expect {|
+  [%expect
+    {|
     ((r1 13)
      (r2 2))
     |}];
   test [ T (r1, 13); T (r1, 17) ];
-  [%expect {|
+  [%expect
+    {|
     ((r1 17)
      (r2 2))
     |}];
   test [ T (r1, 13); T (r2, 17) ];
-  [%expect {|
+  [%expect
+    {|
     ((r1 13)
      (r2 17))
     |}]
@@ -61,7 +64,7 @@ let%expect_test "[sets_temporarily] without raise" =
 
 let%expect_test "[sets_temporarily] with raise" =
   let r = ref 0 in
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     Nothing.unreachable_code (sets_temporarily [ T (r, 1) ] ~f:(fun () -> failwith "")));
   [%expect {| (Failure "") |}];
   print_s [%message (r : int ref)];
diff --git a/test/test_result.ml b/test/test_result.ml
index f97f6a3c..e49115cb 100644
--- a/test/test_result.ml
+++ b/test/test_result.ml
@@ -10,7 +10,7 @@ let%test_module "Result.Error" =
     end
 
     let%expect_test "return" =
-      require_equal [%here] (module Int_or_string) (return "error") (Error "error");
+      require_equal (module Int_or_string) (return "error") (Error "error");
       [%expect {| |}]
     ;;
 
@@ -21,7 +21,7 @@ let%test_module "Result.Error" =
         let%bind e3 = Error "e3" in
         return (String.concat ~sep:"," [ e1; e2; e3 ])
       in
-      require_equal [%here] (module Int_or_string) result (Error "e1,e2,e3");
+      require_equal (module Int_or_string) result (Error "e1,e2,e3");
       [%expect {| |}]
     ;;
 
@@ -32,7 +32,7 @@ let%test_module "Result.Error" =
         let%bind e3 = Error "e3" in
         return (String.concat ~sep:"," [ e1; e2; e3 ])
       in
-      require_equal [%here] (module Int_or_string) result (Ok 1);
+      require_equal (module Int_or_string) result (Ok 1);
       [%expect {| |}]
     ;;
 
@@ -41,7 +41,7 @@ let%test_module "Result.Error" =
         let%map e1 = Error "e1" in
         e1 ^ "!"
       in
-      require_equal [%here] (module Int_or_string) result (Error "e1!");
+      require_equal (module Int_or_string) result (Error "e1!");
       [%expect {| |}]
     ;;
 
@@ -50,7 +50,7 @@ let%test_module "Result.Error" =
         let%map e1 = Ok 1 in
         e1 ^ "!"
       in
-      require_equal [%here] (module Int_or_string) result (Ok 1);
+      require_equal (module Int_or_string) result (Ok 1);
       [%expect {| |}]
     ;;
 
diff --git a/test/test_sequence.ml b/test/test_sequence.ml
index 3847257e..91f87fd7 100644
--- a/test/test_sequence.ml
+++ b/test/test_sequence.ml
@@ -448,7 +448,7 @@ let%test_unit _ =
 ;;
 
 let%expect_test _ =
-  require_does_raise [%here] (fun () -> cycle_list_exn []);
+  require_does_raise (fun () -> cycle_list_exn []);
   [%expect {| (Invalid_argument Sequence.cycle_list_exn) |}]
 ;;
 
@@ -493,7 +493,7 @@ let%expect_test "fold_m" =
     s12345
     ~init:[]
     ~f:(fun acc n ->
-    Simple_monad.bind Simple_monad.step ~f:(fun () -> Simple_monad.return (n :: acc)))
+      Simple_monad.bind Simple_monad.step ~f:(fun () -> Simple_monad.return (n :: acc)))
   |> printf !"%{sexp: int list Simple_monad.t}\n";
   [%expect {| (Step (Step (Step (Step (Step (Return (5 4 3 2 1))))))) |}]
 ;;
@@ -556,7 +556,7 @@ let%expect_test "[equal]" =
     let t2 = of_list l2 in
     let b = equal Int.equal t1 t2 in
     print_s [%sexp (b : bool)];
-    require [%here] (Bool.equal b (equal Int.equal t2 t1))
+    require (Bool.equal b (equal Int.equal t2 t1))
   in
   equal [] [];
   [%expect {| true |}];
@@ -703,7 +703,8 @@ let%test_module "Caml.Seq" =
 
     let%expect_test "of_seq" =
       list |> Stdlib.List.to_seq |> Sequence.of_seq |> Sequence.iter ~f:(printf "%d\n");
-      [%expect {|
+      [%expect
+        {|
         1
         2
         3
@@ -713,7 +714,8 @@ let%test_module "Caml.Seq" =
 
     let%expect_test "to_seq" =
       list |> Sequence.of_list |> Sequence.to_seq |> Stdlib.Seq.iter (printf "%d\n");
-      [%expect {|
+      [%expect
+        {|
         1
         2
         3
diff --git a/test/test_set.ml b/test/test_set.ml
index 4cfd70dc..009af980 100644
--- a/test/test_set.ml
+++ b/test/test_set.ml
@@ -12,7 +12,7 @@ let%expect_test "split_le_gt" =
     print_endline "";
     for key = 0 to len + 1 do
       let le, gt = split_le_gt (of_list (List.init len ~f:Int.succ)) key in
-      Core.print_s [%sexp (le : int_set), "<=", (key : int), "<", (gt : int_set)]
+      print_s [%sexp (le : int_set), "<=", (key : int), "<", (gt : int_set)]
     done
   done;
   [%expect
@@ -46,7 +46,7 @@ let%expect_test "split_lt_ge" =
     print_endline "";
     for key = 0 to len + 1 do
       let lt, ge = split_lt_ge (of_list (List.init len ~f:Int.succ)) key in
-      Core.print_s [%sexp (lt : int_set), "<", (key : int), "<=", (ge : int_set)]
+      print_s [%sexp (lt : int_set), "<", (key : int), "<=", (ge : int_set)]
     done
   done;
   [%expect
diff --git a/test/test_set_interface.ml b/test/test_set_interface.ml
index 81d7d059..d393504d 100644
--- a/test/test_set_interface.ml
+++ b/test/test_set_interface.ml
@@ -9,13 +9,13 @@ module _ : sig
   type ('a, 'b) t
 
   include
-    Creators_and_accessors_generic
-      with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
-      with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_first_class_module.t
-      with type ('a, 'b) set := ('a, 'b) t
-      with type ('a, 'b) t := ('a, 'b) t
-      with type ('a, 'b) tree := ('a, 'b) Set.Using_comparator.Tree.t
-      with type 'a elt := 'a
-      with type 'c cmp := 'c
+    Creators_and_accessors_and_transformers_generic
+    with type ('a, 'b, 'c) access_options := ('a, 'b, 'c) Without_comparator.t
+    with type ('a, 'b, 'c) create_options := ('a, 'b, 'c) With_first_class_module.t
+    with type ('a, 'b) set := ('a, 'b) t
+    with type ('a, 'b) t := ('a, 'b) t
+    with type ('a, 'b) tree := ('a, 'b) Set.Using_comparator.Tree.t
+    with type 'a elt := 'a
+    with type 'c cmp := 'c
 end =
   Set
diff --git a/test/test_sexpable.ml b/test/test_sexpable.ml
index c3a80ab7..55d12011 100644
--- a/test/test_sexpable.ml
+++ b/test/test_sexpable.ml
@@ -9,25 +9,23 @@ let%test_module "Of_stringable" =
       type t = Double of string [@@deriving quickcheck]
 
       include Of_stringable (struct
-        type nonrec t = t
+          type nonrec t = t
 
-        let to_string (Double x) = x ^ x
+          let to_string (Double x) = x ^ x
 
-        let of_string x =
-          let length = String.length x in
-          let first_half = String.drop_suffix x (length / 2) in
-          let second_half = String.drop_suffix x (length / 2) in
-          if length % 2 = 0 && String.(first_half = second_half)
-          then Double first_half
-          else failwith [%string "Invalid doubled string %{x}"]
-        ;;
-      end)
+          let of_string x =
+            let length = String.length x in
+            let first_half = String.drop_suffix x (length / 2) in
+            let second_half = String.drop_suffix x (length / 2) in
+            if length % 2 = 0 && String.(first_half = second_half)
+            then Double first_half
+            else failwith [%string "Invalid doubled string %{x}"]
+          ;;
+        end)
     end
 
     let%expect_test "validate sexp grammar" =
-      require_ok
-        [%here]
-        (Sexp_grammar_validation.validate_grammar (module Doubled_string));
+      require_ok (Sexp_grammar_validation.validate_grammar (module Doubled_string));
       [%expect {| String |}]
     ;;
   end)
diff --git a/test/test_sign.ml b/test/test_sign.ml
index d00bd2dc..07864844 100644
--- a/test/test_sign.ml
+++ b/test/test_sign.ml
@@ -6,7 +6,7 @@ let%test "of_int" = of_int 37 = Pos && of_int (-22) = Neg && of_int 0 = Zero
 let%test_unit "( * )" =
   List.cartesian_product all all
   |> List.iter ~f:(fun (s1, s2) ->
-       [%test_result: int] (to_int (s1 * s2)) ~expect:(Int.( * ) (to_int s1) (to_int s2)))
+    [%test_result: int] (to_int (s1 * s2)) ~expect:(Int.( * ) (to_int s1) (to_int s2)))
 ;;
 
 let%expect_test ("hash coherence" [@tags "64-bits-only"]) =
diff --git a/test/test_sign_or_nan.ml b/test/test_sign_or_nan.ml
index 18549fb2..491d3879 100644
--- a/test/test_sign_or_nan.ml
+++ b/test/test_sign_or_nan.ml
@@ -14,8 +14,9 @@ let%expect_test "to_string_hum" =
     print_endline string;
     match to_sign_exn t with
     | exception _ -> ()
-    | sign -> require_equal [%here] (module String) string (Sign.to_string_hum sign));
-  [%expect {|
+    | sign -> require_equal (module String) string (Sign.to_string_hum sign));
+  [%expect
+    {|
     negative
     zero
     positive
diff --git a/test/test_source_code_position.ml b/test/test_source_code_position.ml
index 8adbeebf..accf1a51 100644
--- a/test/test_source_code_position.ml
+++ b/test/test_source_code_position.ml
@@ -11,3 +11,11 @@ let%expect_test "of_pos __POS__" =
   print_s [%sexp (here : Source_code_position.t)];
   [%expect {| test_source_code_position.ml:10:41 |}]
 ;;
+
+let%expect_test "here_or_there" =
+  print_s [%sexp (Source_code_position.here_or_there None : Source_code_position.t)];
+  [%expect {| lib/base/test/test_source_code_position.ml:16:18 |}];
+  let here = Some [%here] in
+  print_s [%sexp (Source_code_position.here_or_there here : Source_code_position.t)];
+  [%expect {| lib/base/test/test_source_code_position.ml:18:18 |}]
+;;
diff --git a/test/test_string.ml b/test/test_string.ml
index 8b59bb12..9b4b92ab 100644
--- a/test/test_string.ml
+++ b/test/test_string.ml
@@ -14,10 +14,10 @@ let%expect_test "edit distance" =
       then (
         let d = edit_distance a b in
         print_s [%sexp (d : int), (a : string), (b : string)];
-        if a = b && Int.( <> ) d 0 then print_cr [%here] [%message "non-zero"];
+        if a = b && Int.( <> ) d 0 then print_cr [%message "non-zero"];
         let d' = edit_distance b a in
         if Int.( <> ) d d'
-        then print_cr [%here] [%message "non-symmetric" ~_:(d : int) ~_:(d' : int)])));
+        then print_cr [%message "non-symmetric" ~_:(d : int) ~_:(d' : int)])));
   [%expect
     {|
     (0 catch catch)
@@ -56,7 +56,7 @@ let%test_module "concat" =
     let test ?sep list =
       let from_list = concat ?sep list in
       let from_array = concat_array ?sep (Array.of_list list) in
-      require_equal [%here] (module String) from_list from_array;
+      require_equal (module String) from_list from_array;
       print_s [%sexp (from_list : string)]
     ;;
 
@@ -86,7 +86,6 @@ let%expect_test "to_list and to_list_rev" =
   let test s =
     let list = to_list s in
     require_equal
-      [%here]
       (module struct
         type t = char list [@@deriving equal, sexp_of]
       end)
@@ -104,9 +103,8 @@ let%expect_test "[of_sequence] and [to_sequence]" =
   let test t =
     let seq = to_sequence t in
     print_s [%sexp (seq : char Sequence.t)];
-    require_equal [%here] (module String) (of_sequence seq) t;
+    require_equal (module String) (of_sequence seq) t;
     require_equal
-      [%here]
       (module struct
         type t = char Sequence.t [@@deriving equal, sexp_of]
       end)
@@ -131,7 +129,7 @@ let%expect_test "sub/unsafe_sub" =
     match Or_error.try_with (fun () -> sub string ~pos ~len) with
     | Ok safe_substring ->
       let unsafe_substring = unsafe_sub string ~pos ~len in
-      require_equal [%here] (module String) safe_substring unsafe_substring;
+      require_equal (module String) safe_substring unsafe_substring;
       print_s [%sexp (safe_substring : t)]
     | Error e -> print_s [%sexp (e : Error.t)]
   in
@@ -172,8 +170,8 @@ let%test_module "Unicode" =
       let actual = (Utf.is_valid string : bool) in
       match actual, expect with
       | true, true | false, false -> ()
-      | true, false -> print_cr [%here] [%message "expected valid result, got invalid"]
-      | false, true -> print_cr [%here] [%message "expected invalid result, got valid"]
+      | true, false -> print_cr [%message "expected valid result, got invalid"]
+      | false, true -> print_cr [%message "expected invalid result, got valid"]
     ;;
 
     let%expect_test "valid" =
@@ -278,7 +276,6 @@ let%test_module "Unicode" =
         if not ([%equal: Uchar.t list] uchars round_trip)
         then
           print_cr
-            [%here]
             [%message
               "encoding does not round trip"
                 (codec_name : string)
@@ -374,7 +371,7 @@ let%test_module "Unicode" =
       [%expect {| αβ |}];
       print_s [%message "" ~_:(utf8 : Utf8.t) ~_:(Utf8.to_list utf8 : Uchar.t list)];
       [%expect {| ("\206\177\206\178" (U+03B1 U+03B2)) |}];
-      require_does_raise [%here] (fun () -> Utf8.get utf8 ~byte_pos:1);
+      require_does_raise (fun () -> Utf8.get utf8 ~byte_pos:1);
       [%expect
         {|
         ("Base.String.Utf8.get: invalid UTF-8 encoding at given position"
@@ -502,14 +499,14 @@ let%test_module "Search_pattern" =
           =
           let create_repr = Private.representation (create pattern ~case_sensitive) in
           let slow_create_repr = slow_create pattern ~case_sensitive in
-          require_equal [%here] (module Private) create_repr expected;
-          require_equal [%here] (module Private) slow_create_repr expected
+          require_equal (module Private) create_repr expected;
+          require_equal (module Private) slow_create_repr expected
         ;;
 
         let cmp_both pattern ~case_sensitive =
           let create_repr = Private.representation (create pattern ~case_sensitive) in
           let slow_create_repr = slow_create pattern ~case_sensitive in
-          require_equal [%here] (module Private) create_repr slow_create_repr
+          require_equal (module Private) create_repr slow_create_repr
         ;;
 
         let%expect_test _ =
@@ -846,7 +843,7 @@ let%test_module "tr_multi" =
       ; "ab", "dcba", "abcdefg", "dccdefg"
       ]
       |> List.map ~f:(fun (target, replacement, string, expected) ->
-           { Test.target; replacement; string; expected = Some expected })
+        { Test.target; replacement; string; expected = Some expected })
     ;;
 
     let%test_unit _ =
@@ -1010,12 +1007,11 @@ let%test_module "rstrip" =
 
 let%test_module "map" =
   (module struct
-    let%expect_test "empty" = require_equal [%here] (module String) (map "" ~f:Fn.id) ""
+    let%expect_test "empty" = require_equal (module String) (map "" ~f:Fn.id) ""
 
     let%expect_test "non-empty" =
       let s = "faboo" in
       require_equal
-        [%here]
         (module String)
         (map s ~f:(function
           | 'a' -> 'b'
@@ -1204,37 +1200,37 @@ let%expect_test "is_substring_at" =
 
 let%expect_test "prefixes and suffixes" =
   let s = "0123456789" in
-  require_equal [%here] (module String) (String.prefix s 0) "";
-  require_equal [%here] (module String) (String.prefix s 1) "0";
-  require_equal [%here] (module String) (String.prefix s 2) "01";
-  require_equal [%here] (module String) (String.prefix s 10) s;
-  require_equal [%here] (module String) (String.prefix s 20) s;
-  require_does_raise [%here] (fun () -> String.prefix s (-1));
+  require_equal (module String) (String.prefix s 0) "";
+  require_equal (module String) (String.prefix s 1) "0";
+  require_equal (module String) (String.prefix s 2) "01";
+  require_equal (module String) (String.prefix s 10) s;
+  require_equal (module String) (String.prefix s 20) s;
+  require_does_raise (fun () -> String.prefix s (-1));
   [%expect {| (Invalid_argument "prefix expecting nonnegative argument") |}];
-  require_equal [%here] (module String) (String.suffix s 0) "";
-  require_equal [%here] (module String) (String.suffix s 1) "9";
-  require_equal [%here] (module String) (String.suffix s 2) "89";
-  require_equal [%here] (module String) (String.suffix s 10) s;
-  require_equal [%here] (module String) (String.suffix s 20) s;
-  require_does_raise [%here] (fun () -> String.suffix s (-1));
+  require_equal (module String) (String.suffix s 0) "";
+  require_equal (module String) (String.suffix s 1) "9";
+  require_equal (module String) (String.suffix s 2) "89";
+  require_equal (module String) (String.suffix s 10) s;
+  require_equal (module String) (String.suffix s 20) s;
+  require_does_raise (fun () -> String.suffix s (-1));
   [%expect {| (Invalid_argument "suffix expecting nonnegative argument") |}]
 ;;
 
 let%expect_test "drop prefixes and suffixes" =
   let s = "0123456789" in
-  require_equal [%here] (module String) (String.drop_prefix s 0) s;
-  require_equal [%here] (module String) (String.drop_prefix s 1) "123456789";
-  require_equal [%here] (module String) (String.drop_prefix s 2) "23456789";
-  require_equal [%here] (module String) (String.drop_prefix s 10) "";
-  require_equal [%here] (module String) (String.drop_prefix s 20) "";
-  require_does_raise [%here] (fun () -> String.drop_prefix s (-1));
+  require_equal (module String) (String.drop_prefix s 0) s;
+  require_equal (module String) (String.drop_prefix s 1) "123456789";
+  require_equal (module String) (String.drop_prefix s 2) "23456789";
+  require_equal (module String) (String.drop_prefix s 10) "";
+  require_equal (module String) (String.drop_prefix s 20) "";
+  require_does_raise (fun () -> String.drop_prefix s (-1));
   [%expect {| (Invalid_argument "drop_prefix expecting nonnegative argument") |}];
-  require_equal [%here] (module String) (String.drop_suffix s 0) s;
-  require_equal [%here] (module String) (String.drop_suffix s 1) "012345678";
-  require_equal [%here] (module String) (String.drop_suffix s 2) "01234567";
-  require_equal [%here] (module String) (String.drop_suffix s 10) "";
-  require_equal [%here] (module String) (String.drop_suffix s 20) "";
-  require_does_raise [%here] (fun () -> String.drop_suffix s (-1));
+  require_equal (module String) (String.drop_suffix s 0) s;
+  require_equal (module String) (String.drop_suffix s 1) "012345678";
+  require_equal (module String) (String.drop_suffix s 2) "01234567";
+  require_equal (module String) (String.drop_suffix s 10) "";
+  require_equal (module String) (String.drop_suffix s 20) "";
+  require_does_raise (fun () -> String.drop_suffix s (-1));
   [%expect {| (Invalid_argument "drop_suffix expecting nonnegative argument") |}]
 ;;
 
@@ -1247,37 +1243,44 @@ let%expect_test "testing prefixes and suffixes" =
           ~is_suffix:(is_suffix outer ~suffix:inner : bool)]
   in
   test "" "a";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix false)
      (is_suffix false))
     |}];
   test "" "";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix true)
      (is_suffix true))
     |}];
   test "Foo" "";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix true)
      (is_suffix true))
     |}];
   test "H" "H";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix true)
      (is_suffix true))
     |}];
   test "Hello" "He";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix true)
      (is_suffix false))
     |}];
   test "Hello" "lo";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix false)
      (is_suffix true))
     |}];
   test "HelloFoo" "lo";
-  [%expect {|
+  [%expect
+    {|
     ((is_prefix false)
      (is_suffix false))
     |}]
@@ -1288,14 +1291,12 @@ let%expect_test "chop_prefix" =
   let test_prefix ~prefix =
     let result = Or_error.try_with (fun () -> chop_prefix_exn s ~prefix) in
     require_equal
-      [%here]
       (module struct
         type t = string option [@@deriving equal, sexp_of]
       end)
       (chop_prefix s ~prefix)
       (Or_error.ok result);
     require_equal
-      [%here]
       (module String)
       (chop_prefix_if_exists s ~prefix)
       (result |> Or_error.ok |> Option.value ~default:s);
@@ -1314,14 +1315,12 @@ let%expect_test "chop_suffix" =
   let test_suffix ~suffix =
     let result = Or_error.try_with (fun () -> chop_suffix_exn s ~suffix) in
     require_equal
-      [%here]
       (module struct
         type t = string option [@@deriving equal, sexp_of]
       end)
       (chop_suffix s ~suffix)
       (Or_error.ok result);
     require_equal
-      [%here]
       (module String)
       (chop_suffix_if_exists s ~suffix)
       (result |> Or_error.ok |> Option.value ~default:s);
@@ -1340,13 +1339,11 @@ let%expect_test "String.concat_lines" =
     String.concat (List.map lines ~f:(fun line -> line ^ if crlf then "\r\n" else "\n"))
   in
   quickcheck_m
-    [%here]
     (module struct
       type t = string list * bool [@@deriving quickcheck, sexp_of]
     end)
     ~f:(fun (lines, crlf) ->
       require_equal
-        [%here]
         (module String)
         (String.concat_lines lines ~crlf)
         (concat_lines_reference lines ~crlf));
@@ -1368,15 +1365,15 @@ let%expect_test "String.concat_lines examples" =
 let%expect_test "pad_left and pad_right" =
   let test ?char t ~len =
     let padded_left = pad_left ?char t ~len in
-    require [%here] (Int.( >= ) (length padded_left) len);
-    require [%here] (String.is_suffix padded_left ~suffix:t);
+    require (Int.( >= ) (length padded_left) len);
+    require (String.is_suffix padded_left ~suffix:t);
     let padded_right = pad_right ?char t ~len in
-    require [%here] (Int.( >= ) (length padded_right) len);
-    require [%here] (String.is_prefix padded_right ~prefix:t);
+    require (Int.( >= ) (length padded_right) len);
+    require (String.is_prefix padded_right ~prefix:t);
     if Int.( >= ) (length t) len
     then (
-      require [%here] (phys_equal t padded_left);
-      require [%here] (phys_equal t padded_right));
+      require (phys_equal t padded_left);
+      require (phys_equal t padded_right));
     print_s [%message (t : string) (padded_left : string) (padded_right : string)]
   in
   test "" ~len:2;
@@ -1524,7 +1521,6 @@ let%test_module "functions that raise Not_found_s" =
         let option_result = lsplit2 s ~on:':' in
         let exn_result = Or_error.try_with (fun () -> lsplit2_exn s ~on:':') in
         require_equal
-          [%here]
           (module struct
             type t = (string * string) option [@@deriving equal, sexp_of]
           end)
@@ -1549,7 +1545,6 @@ let%test_module "functions that raise Not_found_s" =
         let option_result = rsplit2 s ~on:':' in
         let exn_result = Or_error.try_with (fun () -> rsplit2_exn s ~on:':') in
         require_equal
-          [%here]
           (module struct
             type t = (string * string) option [@@deriving equal, sexp_of]
           end)
diff --git a/test/test_type_equal.ml b/test/test_type_equal.ml
index abdce55b..049253d2 100644
--- a/test/test_type_equal.ml
+++ b/test/test_type_equal.ml
@@ -57,7 +57,7 @@ let%test_module "Type_equal" =
     (* let _a_to_b (a : A.t) =
      *   let T = Id.same_witness_exn A.id B.id in
      *   (a : B.t)
-     *)
+    *)
 
     module C = struct
       type 'a t
@@ -83,7 +83,6 @@ let%expect_test "Create*" =
     if Bool.( <> ) same_according_to_id same_according_to_uid
     then
       print_cr
-        [%here]
         [%message
           "[Type_equal.Id] and [Type_equal.Id.Uid] disagree"
             (id1 : _ Type_equal.Id.t)
@@ -209,5 +208,92 @@ let%expect_test "Create*" =
        Bool.type_equal_id
        (Option.type_equal_id Bool.type_equal_id))
     (Tuple3.type_equal_id Int.type_equal_id Bool.type_equal_id Int.type_equal_id);
-  [%expect {| ((tuple3 int bool (option bool)) <> (tuple3 int bool int)) |}]
+  [%expect {| ((tuple3 int bool (option bool)) <> (tuple3 int bool int)) |}];
+  let module Tuple4 =
+    Type_equal.Id.Create4 (struct
+      type ('a, 'b, 'c, 'd) t = 'a * 'b * 'c * 'd [@@deriving sexp_of]
+
+      let name = "tuple4"
+    end)
+  in
+  (* 4-ary vs 0-ary *)
+  test
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id))
+    Int.type_equal_id;
+  [%expect {| ((tuple4 int bool (option bool) (either int bool)) <> int) |}];
+  (* 4-ary vs 1-ary *)
+  test
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id))
+    (Option.type_equal_id Int.type_equal_id);
+  [%expect {| ((tuple4 int bool (option bool) (either int bool)) <> (option int)) |}];
+  (* 4-ary vs 2-ary *)
+  test
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id))
+    (Either.type_equal_id Int.type_equal_id Bool.type_equal_id);
+  [%expect {| ((tuple4 int bool (option bool) (either int bool)) <> (either int bool)) |}];
+  (* 4-ary vs 3-ary *)
+  test
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id))
+    (Tuple3.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id));
+  [%expect
+    {|
+    ((tuple4 int bool (option bool) (either int bool))
+     <>
+     (tuple3 int bool (option bool)))
+    |}];
+  (* 4-ary applied twice to same arguments *)
+  test
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id))
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id));
+  [%expect
+    {|
+    ((tuple4 int bool (option bool) (either int bool))
+     ==
+     (tuple4 int bool (option bool) (either int bool)))
+    |}];
+  (* 4-ary with different arguments *)
+  test
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       (Either.type_equal_id Int.type_equal_id Bool.type_equal_id))
+    (Tuple4.type_equal_id
+       Int.type_equal_id
+       Bool.type_equal_id
+       (Option.type_equal_id Bool.type_equal_id)
+       Int.type_equal_id);
+  [%expect
+    {|
+    ((tuple4 int bool (option bool) (either int bool))
+     <>
+     (tuple4 int bool (option bool) int))
+    |}]
 ;;
diff --git a/test/test_uniform_array.ml b/test/test_uniform_array.ml
index cfeb7ad6..f2f4a946 100644
--- a/test/test_uniform_array.ml
+++ b/test/test_uniform_array.ml
@@ -69,7 +69,7 @@ let%test_unit _ =
 
 let%expect_test "exists" =
   let test arr f = of_list arr |> exists ~f in
-  let r here = require_equal here (module Bool) in
+  let r here = require_equal ~here (module Bool) in
   r [%here] false (test [] Fn.id);
   r [%here] true (test [ true ] Fn.id);
   r [%here] true (test [ false; false; false; false; true ] Fn.id);
@@ -80,7 +80,7 @@ let%expect_test "exists" =
 
 let%expect_test "for_all" =
   let test arr f = of_list arr |> for_all ~f in
-  let r here = require_equal here (module Bool) in
+  let r here = require_equal ~here (module Bool) in
   r [%here] true (test [] Fn.id);
   r [%here] true (test [ true ] Fn.id);
   r [%here] false (test [ false; false; false; false; true ] Fn.id);
@@ -104,8 +104,8 @@ module Sequence = struct
   type 'a z = 'a
 
   let length = length
-  let get = get
-  let set = set
+  let get t i = get t i
+  let set t i x = set t i x
   let create_bool ~len = create ~len false
 end
 
@@ -120,7 +120,7 @@ let%expect_test "map2_exn" =
   [%expect {| (result ()) |}];
   test [ 1; 2; 3 ] [ 100; 200; 300 ] ( + );
   [%expect {| (result (101 202 303)) |}];
-  require_does_raise [%here] (fun () -> test [ 1 ] [] (fun _ _ -> 0));
+  require_does_raise (fun () -> test [ 1 ] [] (fun _ _ -> 0));
   [%expect {| (Invalid_argument Array.map2_exn) |}]
 ;;
 
@@ -135,7 +135,7 @@ let%expect_test "fold2_exn" =
   [%expect {| 0 |}];
   test [ 1; 2; 3 ] [ 7; 8; 9 ];
   [%expect {| 24_006 |}];
-  require_does_raise [%here] (fun () -> test [ 1 ] []);
+  require_does_raise (fun () -> test [ 1 ] []);
   [%expect {| (Invalid_argument Array.fold2_exn) |}]
 ;;
 
@@ -147,7 +147,8 @@ let%expect_test "mapi" =
   test [];
   [%expect {| () |}];
   test [ "foo"; "bar" ];
-  [%expect {|
+  [%expect
+    {|
     ((0 Foo)
      (1 Bar))
     |}]
@@ -174,7 +175,7 @@ let%expect_test "concat_map" =
     print_s
       [%sexp
         (concat_map t ~f:(fun i -> of_list [ i * 10; (i * 10) + 1; (i * 10) + 2 ])
-          : int t)]
+         : int t)]
   in
   test empty;
   [%expect {| () |}];
@@ -188,7 +189,7 @@ let%expect_test "concat_mapi" =
       [%sexp
         (concat_mapi t ~f:(fun idx i ->
            if idx = 1 then empty else of_list [ i * 10; (i * 10) + 1; (i * 10) + 2 ])
-          : int t)]
+         : int t)]
   in
   test empty;
   [%expect {| () |}];
@@ -208,22 +209,26 @@ let%expect_test "partition_map" =
     print_s [%sexp (second : int t)]
   in
   test empty;
-  [%expect {|
+  [%expect
+    {|
     ()
     ()
     |}];
   test (of_list [ 0; 1; 2; 3 ]);
-  [%expect {|
+  [%expect
+    {|
     (0 2)
     (1 3)
     |}];
   test (of_list [ 0; 2; 4; 6 ]);
-  [%expect {|
+  [%expect
+    {|
     (0 2 4 6)
     ()
     |}];
   test (of_list [ 1; 3; 5; 7 ]);
-  [%expect {|
+  [%expect
+    {|
     ()
     (1 3 5 7)
     |}]
@@ -253,7 +258,7 @@ let%expect_test "filter_map" =
       [%sexp
         (filter_map t ~f:(fun i ->
            if i % 2 = 0 then None else Some (Char.of_int_exn (Char.to_int 'a' + i)))
-          : char t)]
+         : char t)]
   in
   test empty;
   [%expect {| () |}];
@@ -273,7 +278,7 @@ let%expect_test "filter_mapi" =
                (Int.to_string idx
                 ^ ": "
                 ^ Char.to_string (Char.of_int_exn (Char.to_int 'a' + i))))
-          : string t)]
+         : string t)]
   in
   test empty;
   [%expect {| () |}];
@@ -312,7 +317,7 @@ let%expect_test "find_mapi" =
     print_s
       [%sexp
         (find_mapi t ~f:(fun idx i -> if idx % 2 = 1 then None else Char.of_int i)
-          : char option)]
+         : char option)]
   in
   test empty;
   [%expect {| () |}];
@@ -328,3 +333,148 @@ let%expect_test "unsafe_to_array_inplace__promise_not_a_float" =
   print_s [%sexp (arr : int array)];
   [%expect {| (1 2 3 4 5) |}]
 ;;
+
+(* Invariant tests *)
+let%test_module (_ [@tags "no-js"]) =
+  (module (
+  struct
+    type 'a t = 'a Uniform_array.t [@@deriving compare ~localize, sexp_of, sexp_grammar]
+
+    let invariant = Uniform_array.invariant
+
+    (* We test that constructors satisfy the invariant, especially when given floats. *)
+
+    open struct
+      let test_poly ?(allow_empty = false) ?cr ?(here = Stdlib.Lexing.dummy_pos) t =
+        assert (allow_empty || length t > 0);
+        require_does_not_raise ~here ?cr (fun () -> invariant t)
+      ;;
+
+      let test ?allow_empty ?cr ?(here = Stdlib.Lexing.dummy_pos) (t : float t) =
+        test_poly ?allow_empty ?cr ~here t
+      ;;
+    end
+
+    let t_of_sexp = Uniform_array.t_of_sexp
+    let%expect_test _ = test (t_of_sexp Float.t_of_sexp (List [ Atom "0" ]))
+    let empty = Uniform_array.empty
+    let%expect_test _ = test empty ~allow_empty:true
+    let create = Uniform_array.create
+    let%expect_test _ = test (create ~len:1 0.)
+    let singleton = Uniform_array.singleton
+    let%expect_test _ = test (singleton 0.)
+    let init = Uniform_array.init
+    let%expect_test _ = test (init 1 ~f:(fun _ -> 0.))
+    let map = Uniform_array.map
+    let%expect_test _ = test (map (singleton 0) ~f:(fun _ -> 0.))
+    let mapi = Uniform_array.mapi
+    let%expect_test _ = test (mapi (singleton 0) ~f:(fun _ _ -> 0.))
+    let of_array = Uniform_array.of_array
+    let%expect_test _ = test (of_array [| 0. |])
+    let of_list = Uniform_array.of_list
+    let%expect_test _ = test (of_list [ 0. ])
+    let of_list_rev = Uniform_array.of_list_rev
+    let%expect_test _ = test (of_list_rev [ 0. ])
+    let sub = Uniform_array.sub
+    let%expect_test _ = test (sub (singleton 0.) ~pos:0 ~len:1)
+    let subo = Uniform_array.subo
+    let%expect_test _ = test (subo (singleton 0.))
+    let copy = Uniform_array.copy
+    let%expect_test _ = test (copy (singleton 0.))
+    let concat = Uniform_array.concat
+    let%expect_test _ = test (concat [ singleton 0. ])
+    let concat_map = Uniform_array.concat_map
+    let%expect_test _ = test (concat_map (singleton 0) ~f:(fun _ -> singleton 0.))
+    let concat_mapi = Uniform_array.concat_mapi
+    let%expect_test _ = test (concat_mapi (singleton 0) ~f:(fun _ _ -> singleton 0.))
+    let partition_map = Uniform_array.partition_map
+
+    let%expect_test _ =
+      let ts, fs =
+        partition_map (of_list [ Either.First 0.; Either.Second 0. ]) ~f:Fn.id
+      in
+      test ts;
+      test fs
+    ;;
+
+    let filter = Uniform_array.filter
+    let%expect_test _ = test (filter (singleton 0.) ~f:(fun _ -> true))
+    let filteri = Uniform_array.filteri
+    let%expect_test _ = test (filteri (singleton 0.) ~f:(fun _ _ -> true))
+    let filter_map = Uniform_array.filter_map
+    let%expect_test _ = test (filter_map (singleton 0) ~f:(fun _ -> Some 0.))
+    let filter_mapi = Uniform_array.filter_mapi
+    let%expect_test _ = test (filter_mapi (singleton 0) ~f:(fun _ _ -> Some 0.))
+    let map2_exn = Uniform_array.map2_exn
+    let%expect_test _ = test (map2_exn (singleton 0) (singleton 0) ~f:(fun _ _ -> 0.))
+    let unsafe_create_uninitialized = Uniform_array.unsafe_create_uninitialized
+
+    let%expect_test _ =
+      let t = unsafe_create_uninitialized ~len:1 in
+      set t 0 0.;
+      test t
+    ;;
+
+    let create_obj_array = Uniform_array.create_obj_array
+
+    let%expect_test _ =
+      let t = create_obj_array ~len:1 in
+      set t 0 (Stdlib.Obj.repr 0.);
+      test_poly t
+    ;;
+
+    (* Accessors, no invariant to test here *)
+
+    let length = Uniform_array.length
+    let get = Uniform_array.get
+    let unsafe_get = Uniform_array.unsafe_get
+    let set = Uniform_array.set
+    let unsafe_set = Uniform_array.unsafe_set
+    let swap = Uniform_array.swap
+    let unsafe_set_omit_phys_equal_check = Uniform_array.unsafe_set_omit_phys_equal_check
+    let unsafe_set_with_caml_modify = Uniform_array.unsafe_set_with_caml_modify
+    let set_with_caml_modify = Uniform_array.set_with_caml_modify
+    let iter = Uniform_array.iter
+    let iteri = Uniform_array.iteri
+    let fold = Uniform_array.fold
+    let foldi = Uniform_array.foldi
+
+    let unsafe_to_array_inplace__promise_not_a_float =
+      Uniform_array.unsafe_to_array_inplace__promise_not_a_float
+    ;;
+
+    let to_array = Uniform_array.to_array
+    let to_list = Uniform_array.to_list
+    let blit = Uniform_array.blit
+    let blito = Uniform_array.blito
+    let unsafe_blit = Uniform_array.unsafe_blit
+    let exists = Uniform_array.exists
+    let existsi = Uniform_array.existsi
+    let for_all = Uniform_array.for_all
+    let for_alli = Uniform_array.for_alli
+    let find = Uniform_array.find
+    let findi = Uniform_array.findi
+    let find_map = Uniform_array.find_map
+    let find_mapi = Uniform_array.find_mapi
+    let fold2_exn = Uniform_array.fold2_exn
+    let min_elt = Uniform_array.min_elt
+    let max_elt = Uniform_array.max_elt
+    let sort = Uniform_array.sort
+    let binary_search = Uniform_array.binary_search
+    let binary_search_segmented = Uniform_array.binary_search_segmented
+
+    let unsafe_set_assuming_currently_int =
+      Uniform_array.unsafe_set_assuming_currently_int
+    ;;
+
+    let unsafe_set_int_assuming_currently_int =
+      Uniform_array.unsafe_set_int_assuming_currently_int
+    ;;
+
+    let unsafe_set_int = Uniform_array.unsafe_set_int
+    let unsafe_clear_if_pointer = Uniform_array.unsafe_clear_if_pointer
+  end :
+    module type of struct
+      include Uniform_array
+    end))
+;;
