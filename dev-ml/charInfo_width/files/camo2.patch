Index: charInfo_width-1.1.0/src/charInfo_width.ml
===================================================================
--- charInfo_width-1.1.0.orig/src/charInfo_width.ml
+++ charInfo_width-1.1.0/src/charInfo_width.ml
@@ -1,4 +1,4 @@
-open CamomileLibraryDefault.Camomile
+open CamomileLib
 open Result
 
 module Cfg = Cfg
Index: charInfo_width-1.1.0/src/charInfo_width.mli
===================================================================
--- charInfo_width-1.1.0.orig/src/charInfo_width.mli
+++ charInfo_width-1.1.0/src/charInfo_width.mli
@@ -1,4 +1,4 @@
-open CamomileLibraryDefault.Camomile
+open CamomileLib
 open Result
 
 module Cfg = Cfg
Index: charInfo_width-1.1.0/src/codes.ml
===================================================================
--- charInfo_width-1.1.0.orig/src/codes.ml
+++ charInfo_width-1.1.0/src/codes.ml
@@ -1,4 +1,4 @@
-open CamomileLibraryDefault.Camomile
+open CamomileLib
 
 include USet
 
Index: charInfo_width-1.1.0/src/codes.mli
===================================================================
--- charInfo_width-1.1.0.orig/src/codes.mli
+++ charInfo_width-1.1.0/src/codes.mli
@@ -9,27 +9,27 @@ type t
 
 (** based on add_range, [add_ranges l s] add a list of ranges [l] to [s]. *)
 val add_ranges :
-  (CamomileLibrary.UChar.t * CamomileLibrary.UChar.t) list -> t -> t
+  (CamomileLib.UChar.t * CamomileLib.UChar.t) list -> t -> t
 
 (** [tuple_to_range tuple] convert [tuple] to a UChar range *)
 val tuple_to_range :
-  int * int -> CamomileLibrary.UChar.t * CamomileLibrary.UChar.t
+  int * int -> CamomileLib.UChar.t * CamomileLib.UChar.t
 
 (** [of_tuple_list l] convert int tuple list [l] to a [USet.t] *)
 val of_tuple_list : (int * int) list -> t
 
-(** {3 Below are type signatures of the original [CamomileLibrary.USet] module} *)
+(** {3 Below are type signatures of the original [CamomileLib.USet] module} *)
 
 val empty : t
 val is_empty : t -> bool
-val mem : CamomileLibrary.UChar.t -> t -> bool
-val add : CamomileLibrary.UChar.t -> t -> t
+val mem : CamomileLib.UChar.t -> t -> bool
+val add : CamomileLib.UChar.t -> t -> t
 val add_range :
-  CamomileLibrary.UChar.t -> CamomileLibrary.UChar.t -> t -> t
-val singleton : CamomileLibrary.UChar.t -> t
-val remove : CamomileLibrary.UChar.t -> t -> t
+  CamomileLib.UChar.t -> CamomileLib.UChar.t -> t -> t
+val singleton : CamomileLib.UChar.t -> t
+val remove : CamomileLib.UChar.t -> t -> t
 val remove_range :
-  CamomileLibrary.UChar.t -> CamomileLibrary.UChar.t -> t -> t
+  CamomileLib.UChar.t -> CamomileLib.UChar.t -> t -> t
 val union : t -> t -> t
 val inter : t -> t -> t
 val diff : t -> t -> t
@@ -37,27 +37,27 @@ val compl : t -> t
 val compare : t -> t -> int
 val equal : t -> t -> bool
 val subset : t -> t -> bool
-val from : CamomileLibrary.UChar.t -> t -> t
-val after : CamomileLibrary.UChar.t -> t -> t
-val until : CamomileLibrary.UChar.t -> t -> t
-val before : CamomileLibrary.UChar.t -> t -> t
-val iter : (CamomileLibrary.UChar.t -> unit) -> t -> unit
+val from : CamomileLib.UChar.t -> t -> t
+val after : CamomileLib.UChar.t -> t -> t
+val until : CamomileLib.UChar.t -> t -> t
+val before : CamomileLib.UChar.t -> t -> t
+val iter : (CamomileLib.UChar.t -> unit) -> t -> unit
 val iter_range :
-  (CamomileLibrary.UChar.t -> CamomileLibrary.UChar.t -> unit) -> t -> unit
-val fold : (CamomileLibrary.UChar.t -> 'a -> 'a) -> t -> 'a -> 'a
+  (CamomileLib.UChar.t -> CamomileLib.UChar.t -> unit) -> t -> unit
+val fold : (CamomileLib.UChar.t -> 'a -> 'a) -> t -> 'a -> 'a
 val fold_range :
-  (CamomileLibrary.UChar.t -> CamomileLibrary.UChar.t -> 'a -> 'a) ->
+  (CamomileLib.UChar.t -> CamomileLib.UChar.t -> 'a -> 'a) ->
   t -> 'a -> 'a
-val for_all : (CamomileLibrary.UChar.t -> bool) -> t -> bool
-val exists : (CamomileLibrary.UChar.t -> bool) -> t -> bool
-val filter : (CamomileLibrary.UChar.t -> bool) -> t -> t
-val partition : (CamomileLibrary.UChar.t -> bool) -> t -> t * t
+val for_all : (CamomileLib.UChar.t -> bool) -> t -> bool
+val exists : (CamomileLib.UChar.t -> bool) -> t -> bool
+val filter : (CamomileLib.UChar.t -> bool) -> t -> t
+val partition : (CamomileLib.UChar.t -> bool) -> t -> t * t
 val cardinal : t -> int
-val elements : t -> CamomileLibrary.UChar.t list
-val ranges : t -> (CamomileLibrary.UChar.t * CamomileLibrary.UChar.t) list
-val min_elt : t -> CamomileLibrary.UChar.t
-val max_elt : t -> CamomileLibrary.UChar.t
-val choose : t -> CamomileLibrary.UChar.t
-val uset_of_iset : CamomileLibrary.Private.ISet.t -> t
-val iset_of_uset : t -> CamomileLibrary.Private.ISet.t
+val elements : t -> CamomileLib.UChar.t list
+val ranges : t -> (CamomileLib.UChar.t * CamomileLib.UChar.t) list
+val min_elt : t -> CamomileLib.UChar.t
+val max_elt : t -> CamomileLib.UChar.t
+val choose : t -> CamomileLib.UChar.t
+val uset_of_iset : CamomileLib.ISet.t -> t
+val iset_of_uset : t -> CamomileLib.ISet.t
 
