Index: camlimages-5.0.4/exif/exif_c.c
===================================================================
--- camlimages-5.0.4.orig/exif/exif_c.c
+++ camlimages-5.0.4/exif/exif_c.c
@@ -37,7 +37,7 @@ value Val_ExifBytes(unsigned char *p, va
     CAMLparam0();
     CAMLlocal1(res);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,Val_int(p[i]));
     }
@@ -49,7 +49,7 @@ value Val_ExifSBytes(signed char *p, val
     CAMLparam0();
     CAMLlocal1(res);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,Val_int(p[i]));
     }
@@ -61,7 +61,7 @@ value Val_ExifShorts(unsigned short *p,
     CAMLparam0();
     CAMLlocal1(res);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,Val_int(p[i]));
     }
@@ -73,7 +73,7 @@ value Val_ExifSShorts(short *p, value vs
     CAMLparam0();
     CAMLlocal1(res);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,Val_int(p[i]));
     }
@@ -85,7 +85,7 @@ value Val_ExifLongs(unsigned long *p, va
     CAMLparam0();
     CAMLlocal1(res);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,caml_copy_int64(p[i]) /* too big... */ );
     }
@@ -97,7 +97,7 @@ value Val_ExifSLongs(long *p, value vsiz
     CAMLparam0();
     CAMLlocal1(res);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,caml_copy_int32(p[i]) /* too big... */ );
     }
@@ -109,9 +109,9 @@ value Val_ExifRationals(unsigned long *p
     CAMLparam0();
     CAMLlocal2(res,tmp);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
-        tmp = alloc(2,0);
+        tmp = caml_alloc(2,0);
         Store_field(tmp,0, caml_copy_int64(p[i*2]) /* too big... */ );
         Store_field(tmp,1, caml_copy_int64(p[i*2+1]) /* too big... */ );
         Store_field(res,i, tmp);
@@ -124,9 +124,9 @@ value Val_ExifSRationals(long *p, value
     CAMLparam0();
     CAMLlocal2(res,tmp);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
-        tmp = alloc(2,0);
+        tmp = caml_alloc(2,0);
         Store_field(tmp,0,caml_copy_int32(p[i*2]) /* too big... */ );
         Store_field(tmp,1,caml_copy_int32(p[i*2]+1) /* too big... */ );
         Store_field(res,i,tmp);
@@ -139,7 +139,7 @@ value Val_ExifFloats(float *p, value vsi
     CAMLparam0();
     CAMLlocal2(res,tmp);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i,caml_copy_double(p[i]));
     }
@@ -151,7 +151,7 @@ value Val_ExifDoubles(double *p, value v
     CAMLparam0();
     CAMLlocal2(res,tmp);
     int i;
-    res = alloc(Int_val(vsize),0);
+    res = caml_alloc(Int_val(vsize),0);
     for(i=0; i<Int_val(vsize); i++){
         Store_field(res,i, caml_copy_double(p[i]));
     }
@@ -173,12 +173,12 @@ value caml_val_exif_data(value string)
     ExifData *data = exif_data_new_from_data(String_val(string), 
                                              caml_string_length(string));
 
-    if( !data ){ failwith("exif_data_new_from_data"); }
+    if( !data ){ caml_failwith("exif_data_new_from_data"); }
 
     // exif_data_free(data);
 
     //fprintf(stderr, "data=%x\n", data);
-    res = alloc_small(1,0);
+    res = caml_alloc_small(1,0);
     Field(res,0) = (value)data;
 
     CAMLreturn(res);
@@ -217,14 +217,14 @@ value caml_exif_data_contents(value vdat
     int i;
     ExifData *data = (ExifData*)Field(vdata,0);
     //fprintf(stderr, "data=%x\n", data);
-    res = alloc_tuple(EXIF_IFD_COUNT);
+    res = caml_alloc_tuple(EXIF_IFD_COUNT);
     for(i=0; i< EXIF_IFD_COUNT; i++){
         ExifContent *p = data->ifd[i];
         if( p ){ 
             exif_content_ref(p);
-            tmp = alloc_small(1,0);
+            tmp = caml_alloc_small(1,0);
             Field(tmp,0) = (value)p;
-            tmp2 = alloc_small(1,0);
+            tmp2 = caml_alloc_small(1,0);
             //fprintf(stderr, "content=%x (count=%d)\n", p, p->count);
             Field(tmp2,0) = tmp;
             Store_field(res,i,tmp2);
@@ -255,11 +255,11 @@ value caml_exif_content_entries(value vd
             exif_entry_ref(e);
             
             // boxing
-            tmp = alloc_small(1,0);
+            tmp = caml_alloc_small(1,0);
             Field(tmp,0) = (value)e;
 
             // cons
-            tmp2 = alloc_small(2,0);
+            tmp2 = caml_alloc_small(2,0);
             Field(tmp2,0) = tmp;
             Field(tmp2,1) = res;
 
@@ -282,11 +282,11 @@ value caml_exif_decode_entry(value vdata
     CAMLlocal1(tpl);
     ExifEntry *p = (ExifEntry *)Field(vdata,0);
 
-    tpl = alloc_tuple(4);
+    tpl = caml_alloc_tuple(4);
     Store_field(tpl,0,Val_int(p->tag));
     Store_field(tpl,1,Val_int(p->format));
     Store_field(tpl,2,Val_int(p->components)); // hope it never overflow...
-    Store_field(tpl,3,alloc_string(p->size));
+    Store_field(tpl,3,caml_alloc_string(p->size));
     memcpy(String_val(Field(tpl,3)), p->data, p->size);
     CAMLreturn(tpl);
 }
@@ -298,7 +298,7 @@ value caml_exif_decode_entry(value vdata
 #include <caml/memory.h>
 #include <caml/fail.h>
 
-#define NA(x) value x(){ failwith("unsupported"); }
+#define NA(x) value x(){ caml_failwith("unsupported"); }
 
 NA(Val_ExifBytes)
 NA(Val_ExifSBytes)
Index: camlimages-5.0.4/jpeg/jpegread.c
===================================================================
--- camlimages-5.0.4.orig/jpeg/jpegread.c
+++ camlimages-5.0.4/jpeg/jpegread.c
@@ -97,7 +97,7 @@ value caml_val_jpeg_marker( jpeg_saved_m
     tmp = caml_alloc_string(p->data_length);
     memcpy( String_val(tmp), p->data, p->data_length);
 
-    res = alloc_small(2,0);
+    res = caml_alloc_small(2,0);
     Field(res, 0) = Val_int(p->marker);
     Field(res, 1) = tmp;
     // fprintf(stderr, "mark %x %d\n", p->marker, p->data_length);
@@ -116,7 +116,7 @@ value caml_val_jpeg_rev_markers( jpeg_sa
 
         // This cannot come before the call of caml_val_jpeg_marker!
         // New allocation with non-initialized blocks crashes GC!
-        tmp = alloc_small(2,0); 
+        tmp = caml_alloc_small(2,0); 
         Field(tmp, 0) = hd;
         Field(tmp, 1) = res;
         res = tmp;
@@ -149,7 +149,7 @@ value open_jpeg_file_for_read( name )
   filename= String_val( name );
 
   if ((infile = fopen(filename, "rb")) == NULL) {
-    failwith("failed to open jpeg file");
+    caml_failwith("failed to open jpeg file");
   }
 
   cinfop = malloc(sizeof (struct jpeg_decompress_struct));
@@ -175,7 +175,7 @@ value open_jpeg_file_for_read( name )
     jpeg_destroy_decompress(cinfop);
     free(jerrp);
     fclose(infile);
-    failwith(jpg_error_message);
+    caml_failwith(jpg_error_message);
   }
   /* Now we can initialize the JPEG decompression object. */
   jpeg_create_decompress(cinfop);
@@ -196,14 +196,14 @@ value open_jpeg_file_for_read( name )
 
   r[0] = Val_int(cinfop->image_width);
   r[1] = Val_int(cinfop->image_height);
-  r[2] = alloc_small(3,0);
+  r[2] = caml_alloc_small(3,0);
   Field(r[2], 0) = (value)cinfop;
   Field(r[2], 1) = (value)infile;
   Field(r[2], 2) = (value)jerrp;
 
   r[3] = caml_val_jpeg_rev_markers( cinfop->marker_list );
 
-  res = alloc_small(4,0);
+  res = caml_alloc_small(4,0);
   for(i=0; i<4; i++) Field(res, i) = r[i];
 
   CAMLreturn(res);
@@ -260,11 +260,11 @@ value open_jpeg_file_for_read_start( jpe
   // CR jfuruse: integer overflow
   r[0] = Val_int(cinfop->output_width);
   r[1] = Val_int(cinfop->output_height);
-  r[2] = alloc_small(3,0);
+  r[2] = caml_alloc_small(3,0);
   Field(r[2], 0) = (value)cinfop;
   Field(r[2], 1) = (value)infile;
   Field(r[2], 2) = (value)jerrp;
-  res = alloc_small(3,0);
+  res = caml_alloc_small(3,0);
   for(i=0; i<3; i++) Field(res, i) = r[i];
 
   DEBUGF("cinfop= %d infile= %d %d %d \n", (int)cinfop, (int)infile, cinfop->output_scanline, cinfop->output_height); 
@@ -345,19 +345,19 @@ value close_jpeg_file_for_read( jpegh )
 #include <caml/memory.h>
 #include <caml/fail.h>
 
-value jpeg_set_scale_denom(){ failwith("unsupported"); }
-value open_jpeg_file_for_read(){ failwith("unsupported"); }
-value open_jpeg_file_for_read_start(){ failwith("unsupported"); }
-value read_jpeg_scanline(){ failwith("unsupported"); }
-value read_jpeg_scanlines(){ failwith("unsupported"); }
-value close_jpeg_file_for_read(){ failwith("unsupported"); }
-value open_jpeg_file_for_write_colorspace(){ failwith("unsupported"); }
-value open_jpeg_file_for_write(){ failwith("unsupported"); }
-value open_jpeg_file_for_write_cmyk(){ failwith("unsupported"); }
-value write_jpeg_scanline(){ failwith("unsupported"); }
-value close_jpeg_file_for_write(){ failwith("unsupported"); }
-value read_JPEG_file(){ failwith("unsupported"); }
-value write_JPEG_file(){ failwith("unsupported"); }
-void caml_jpeg_write_marker(){ failwith("unsupported"); }
+value jpeg_set_scale_denom(){ caml_failwith("unsupported"); }
+value open_jpeg_file_for_read(){ caml_failwith("unsupported"); }
+value open_jpeg_file_for_read_start(){ caml_failwith("unsupported"); }
+value read_jpeg_scanline(){ caml_failwith("unsupported"); }
+value read_jpeg_scanlines(){ caml_failwith("unsupported"); }
+value close_jpeg_file_for_read(){ caml_failwith("unsupported"); }
+value open_jpeg_file_for_write_colorspace(){ caml_failwith("unsupported"); }
+value open_jpeg_file_for_write(){ caml_failwith("unsupported"); }
+value open_jpeg_file_for_write_cmyk(){ caml_failwith("unsupported"); }
+value write_jpeg_scanline(){ caml_failwith("unsupported"); }
+value close_jpeg_file_for_write(){ caml_failwith("unsupported"); }
+value read_JPEG_file(){ caml_failwith("unsupported"); }
+value write_JPEG_file(){ caml_failwith("unsupported"); }
+void caml_jpeg_write_marker(){ caml_failwith("unsupported"); }
 
 #endif // HAS_JPEG
Index: camlimages-5.0.4/jpeg/jpegwrite.c
===================================================================
--- camlimages-5.0.4.orig/jpeg/jpegwrite.c
+++ camlimages-5.0.4/jpeg/jpegwrite.c
@@ -63,7 +63,7 @@ value open_jpeg_file_for_write_colorspac
 {
   CAMLparam0();
   CAMLlocal1(res);
-  char *filename;
+  const char *filename;
   int image_height;
   int image_width;
   int quality;
@@ -79,7 +79,7 @@ value open_jpeg_file_for_write_colorspac
   quality= Int_val(qual);
  
   if ((outfile = fopen(filename, "wb")) == NULL) {
-    failwith("failed to open jpeg file");
+    caml_failwith("failed to open jpeg file");
   }
 
   cinfop = malloc(sizeof (struct jpeg_compress_struct));
@@ -94,7 +94,7 @@ value open_jpeg_file_for_write_colorspac
     jpeg_destroy_compress(cinfop);
     free(jerrp);
     fclose(outfile);
-    failwith(jpg_error_message);
+    caml_failwith(jpg_error_message);
   }
 
   jpeg_create_compress(cinfop);
@@ -108,7 +108,7 @@ value open_jpeg_file_for_write_colorspac
   jpeg_set_quality(cinfop, quality, TRUE);
   jpeg_start_compress(cinfop, TRUE);
 
-  res = alloc_small(3,0);
+  res = caml_alloc_small(3,0);
   Field(res, 0) = (value)cinfop;
   Field(res, 1) = (value)outfile;
   Field(res, 2) = (value)jerrp;
@@ -150,7 +150,7 @@ void caml_jpeg_write_marker( value jpegh
     // const JOCTET * dataptr, unsigned int datalen));
     
     int code = Int_val(Field(raw,0));
-    char *data = String_val(Field(raw,1));
+    const char *data = String_val(Field(raw,1));
     unsigned int len = caml_string_length(Field(raw,1));
     jpeg_write_marker(cinfop, code, data, len); // This actually writes bytes, so data seems to be ok being GCed.
 }
Index: camlimages-5.0.4/xpm/xpmread.c
===================================================================
--- camlimages-5.0.4.orig/xpm/xpmread.c
+++ camlimages-5.0.4/xpm/xpmread.c
@@ -31,7 +31,7 @@ value read_xpm_file( name )
   CAMLparam1(name);
   CAMLlocal3(cmap,imap,result);
 
-  char *filename;
+  const char *filename;
   XpmImage image;
   int i;
 
@@ -45,7 +45,7 @@ value read_xpm_file( name )
     fprintf(stderr, "colors = %d\n", image.ncolors);
     */
 
-    cmap = alloc_tuple( image.ncolors );
+    cmap = caml_alloc_tuple( image.ncolors );
     for(i=0; i<image.ncolors; i++){
       XpmColor *color = image.colorTable + i;
       /*
@@ -61,16 +61,16 @@ value read_xpm_file( name )
 
       if( color->c_color == NULL ) {
           fprintf(stderr, "color id %d has no c_color\n", i);
-          Store_field(cmap, i, copy_string("null"));
+          Store_field(cmap, i, caml_copy_string("null"));
       } else {
-          Store_field(cmap, i, copy_string(color->c_color));
+          Store_field(cmap, i, caml_copy_string(color->c_color));
       }
     }
 
     { /* image map alloc */
       int size = image.width * image.height;
 
-      imap = alloc_tuple( size );
+      imap = caml_alloc_tuple( size );
       for(i=0; i<size; i++){
           Store_field(imap,i,Val_int(image.data[i]));
       }
@@ -78,7 +78,7 @@ value read_xpm_file( name )
 
     
     /* connect the result */
-    result = alloc_small(4,0);
+    result = caml_alloc_small(4,0);
     Field(result,0) = Val_int(image.width);
     Field(result,1) = Val_int(image.height);
     Field(result,2) = cmap;
@@ -88,7 +88,7 @@ value read_xpm_file( name )
 
     CAMLreturn(result);
   } else {
-    failwith("failed to open xpm file");
+    caml_failwith("failed to open xpm file");
   }
 }
 
@@ -99,6 +99,6 @@ value read_xpm_file( name )
 #include <caml/memory.h>
 #include <caml/fail.h>
 
-value read_xpm_file(){ failwith("unsupported"); }
+value read_xpm_file(){ caml_failwith("unsupported"); }
 
 #endif
