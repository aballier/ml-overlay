From e13ecc7b24868c5b9818263e078a5628a4891a5e Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Thu, 21 Nov 2024 20:33:02 +0000
Subject: [PATCH] v0.18~preview.130.05+548

---
 bench/ppx_sexp_conv_bench.ml        | 382 ++++++++++++++--------------
 expander/expand_of_sexp.ml          | 105 ++++----
 expander/expand_sexp_of.ml          | 102 ++++----
 expander/helpers.ml                 |  61 ++---
 expander/helpers.mli                |   4 +-
 expander/labeled_tuple.ml           |   2 +-
 expander/labeled_tuple.mli          |   3 +-
 expander/ppx_sexp_conv_expander.ml  |   8 +-
 expander/ppx_sexp_conv_expander.mli |  14 +-
 expander/ppx_sexp_conv_grammar.ml   |  83 +++---
 expander/ppx_sexp_conv_grammar.mli  |   2 +-
 expander/renaming.ml                |   8 +-
 12 files changed, 373 insertions(+), 401 deletions(-)

diff --git a/bench/ppx_sexp_conv_bench.ml b/bench/ppx_sexp_conv_bench.ml
index 8011b5c..947b676 100644
--- a/bench/ppx_sexp_conv_bench.ml
+++ b/bench/ppx_sexp_conv_bench.ml
@@ -10,200 +10,192 @@ let bench_t_of_sexp ~t_of_sexp string =
   fun () -> t_of_sexp sexp
 ;;
 
-let%bench_module "Record" =
-  (module struct
-    type t =
-      { a : int
-      ; b : int option [@omit_nil]
-      ; c : bool [@sexp.bool]
-      ; d : int array [@sexp.array]
-      ; e : int list [@sexp.list]
-      ; f : int option [@sexp.option]
-      ; g : int [@default 0] [@sexp_drop_default ( = )]
-      ; h : int [@default 0] [@sexp_drop_default.compare]
-      ; i : int [@default 0] [@sexp_drop_default.equal]
-      ; j : int [@default 0] [@sexp_drop_default.sexp]
-      ; k : 'a. 'a list
+module%bench Record = struct
+  type t =
+    { a : int
+    ; b : int option [@omit_nil]
+    ; c : bool [@sexp.bool]
+    ; d : int array [@sexp.array]
+    ; e : int list [@sexp.list]
+    ; f : int option [@sexp.option]
+    ; g : int [@default 0] [@sexp_drop_default ( = )]
+    ; h : int [@default 0] [@sexp_drop_default.compare]
+    ; i : int [@default 0] [@sexp_drop_default.equal]
+    ; j : int [@default 0] [@sexp_drop_default.sexp]
+    ; k : 'a. 'a list
+    }
+  [@@deriving sexp]
+
+  let%bench_fun "sexp_of_t, full" =
+    bench_sexp_of_t
+      ~sexp_of_t
+      { a = 1
+      ; b = Some 2
+      ; c = true
+      ; d = [| 3; 4 |]
+      ; e = [ 5; 6 ]
+      ; f = Some 7
+      ; g = 8
+      ; h = 9
+      ; i = 10
+      ; j = 11
+      ; k = []
       }
-    [@@deriving sexp]
-
-    let%bench_fun "sexp_of_t, full" =
-      bench_sexp_of_t
-        ~sexp_of_t
-        { a = 1
-        ; b = Some 2
-        ; c = true
-        ; d = [| 3; 4 |]
-        ; e = [ 5; 6 ]
-        ; f = Some 7
-        ; g = 8
-        ; h = 9
-        ; i = 10
-        ; j = 11
-        ; k = []
-        }
-    ;;
-
-    let%bench_fun "sexp_of_t, empty" =
-      bench_sexp_of_t
-        ~sexp_of_t
-        { a = 0
-        ; b = None
-        ; c = false
-        ; d = [||]
-        ; e = []
-        ; f = None
-        ; g = 0
-        ; h = 0
-        ; i = 0
-        ; j = 0
-        ; k = []
+  ;;
+
+  let%bench_fun "sexp_of_t, empty" =
+    bench_sexp_of_t
+      ~sexp_of_t
+      { a = 0
+      ; b = None
+      ; c = false
+      ; d = [||]
+      ; e = []
+      ; f = None
+      ; g = 0
+      ; h = 0
+      ; i = 0
+      ; j = 0
+      ; k = []
+      }
+  ;;
+
+  let%bench_fun "t_of_sexp, full, in order" =
+    bench_t_of_sexp
+      ~t_of_sexp
+      "((a 1) (b (2)) (c) (d (3 4)) (e (5 6)) (f 7) (g 8) (h 9) (i 10) (j 11) (k ()))"
+  ;;
+
+  let%bench_fun "t_of_sexp, full, reverse order" =
+    bench_t_of_sexp
+      ~t_of_sexp
+      "((k ()) (j 11) (i 10) (h 9) (g 8) (f 7) (e (5 6)) (d (3 4)) (c) (b (2)) (a 1))"
+  ;;
+
+  let%bench_fun "t_of_sexp, empty" = bench_t_of_sexp ~t_of_sexp "((a 0) (k ()))"
+end
+
+module%bench Variant = struct
+  type t =
+    | Atomic
+    | Tuple of int * string
+    | List of int list [@sexp.list]
+    | Record of
+        { a : int
+        ; b : int option [@omit_nil]
+        ; c : bool [@sexp.bool]
+        ; d : int array [@sexp.array]
+        ; e : int list [@sexp.list]
+        ; f : int option [@sexp.option]
+        ; g : int [@default 0] [@sexp_drop_default ( = )]
+        ; h : int [@default 0] [@sexp_drop_default.compare]
+        ; i : int [@default 0] [@sexp_drop_default.equal]
+        ; j : int [@default 0] [@sexp_drop_default.sexp]
+        ; k : 'a. 'a list
         }
-    ;;
-
-    let%bench_fun "t_of_sexp, full, in order" =
-      bench_t_of_sexp
-        ~t_of_sexp
-        "((a 1) (b (2)) (c) (d (3 4)) (e (5 6)) (f 7) (g 8) (h 9) (i 10) (j 11) (k ()))"
-    ;;
-
-    let%bench_fun "t_of_sexp, full, reverse order" =
-      bench_t_of_sexp
-        ~t_of_sexp
-        "((k ()) (j 11) (i 10) (h 9) (g 8) (f 7) (e (5 6)) (d (3 4)) (c) (b (2)) (a 1))"
-    ;;
-
-    let%bench_fun "t_of_sexp, empty" = bench_t_of_sexp ~t_of_sexp "((a 0) (k ()))"
-  end)
-;;
-
-let%bench_module "Variant" =
-  (module struct
-    type t =
-      | Atomic
-      | Tuple of int * string
-      | List of int list [@sexp.list]
-      | Record of
-          { a : int
-          ; b : int option [@omit_nil]
-          ; c : bool [@sexp.bool]
-          ; d : int array [@sexp.array]
-          ; e : int list [@sexp.list]
-          ; f : int option [@sexp.option]
-          ; g : int [@default 0] [@sexp_drop_default ( = )]
-          ; h : int [@default 0] [@sexp_drop_default.compare]
-          ; i : int [@default 0] [@sexp_drop_default.equal]
-          ; j : int [@default 0] [@sexp_drop_default.sexp]
-          ; k : 'a. 'a list
-          }
-    [@@deriving sexp]
-
-    let%bench_fun "sexp_of_t, atomic" = bench_sexp_of_t ~sexp_of_t Atomic
-    let%bench_fun "sexp_of_t, tuple" = bench_sexp_of_t ~sexp_of_t (Tuple (1, "hello"))
-    let%bench_fun "sexp_of_t, list, full" = bench_sexp_of_t ~sexp_of_t (List [ 1; 2 ])
-    let%bench_fun "sexp_of_t, list, empty" = bench_sexp_of_t ~sexp_of_t (List [])
-
-    let%bench_fun "sexp_of_t, record, full" =
-      bench_sexp_of_t
-        ~sexp_of_t
-        (Record
-           { a = 1
-           ; b = Some 2
-           ; c = true
-           ; d = [| 3; 4 |]
-           ; e = [ 5; 6 ]
-           ; f = Some 7
-           ; g = 8
-           ; h = 9
-           ; i = 10
-           ; j = 11
-           ; k = []
-           })
-    ;;
-
-    let%bench_fun "sexp_of_t, record, empty" =
-      bench_sexp_of_t
-        ~sexp_of_t
-        (Record
-           { a = 0
-           ; b = None
-           ; c = false
-           ; d = [||]
-           ; e = []
-           ; f = None
-           ; g = 0
-           ; h = 0
-           ; i = 0
-           ; j = 0
-           ; k = []
-           })
-    ;;
-
-    let%bench_fun "t_of_sexp, atomic" = bench_t_of_sexp ~t_of_sexp "Atomic"
-    let%bench_fun "t_of_sexp, tuple" = bench_t_of_sexp ~t_of_sexp "(Tuple 1 hello)"
-    let%bench_fun "t_of_sexp, list, full" = bench_t_of_sexp ~t_of_sexp "(List 1 2)"
-    let%bench_fun "t_of_sexp, list, empty" = bench_t_of_sexp ~t_of_sexp "(List)"
-
-    let%bench_fun "t_of_sexp, record, full, in order" =
-      bench_t_of_sexp
-        ~t_of_sexp
-        "(Record (a 1) (b (2)) (c) (d (3 4)) (e (5 6)) (f 7) (g 8) (h 9) (i 10) (j 11) \
-         (k ()))"
-    ;;
-
-    let%bench_fun "t_of_sexp, record, full, reverse order" =
-      bench_t_of_sexp
-        ~t_of_sexp
-        "(Record (k ()) (j 11) (i 10) (h 9) (g 8) (f 7) (e (5 6)) (d (3 4)) (c) (b (2)) \
-         (a 1))"
-    ;;
-
-    let%bench_fun "t_of_sexp, record, empty" =
-      bench_t_of_sexp ~t_of_sexp "(Record (a 0) (k ()))"
-    ;;
-  end)
-;;
-
-let%bench_module "Tag" =
-  (module struct
-    type t =
-      [ `Atomic
-      | `Tuple of int * string
-      | `List of int list [@sexp.list]
-      ]
-    [@@deriving sexp]
-
-    let%bench_fun "sexp_of_t, atomic" = bench_sexp_of_t ~sexp_of_t `Atomic
-    let%bench_fun "sexp_of_t, tuple" = bench_sexp_of_t ~sexp_of_t (`Tuple (1, "hello"))
-    let%bench_fun "sexp_of_t, list, full" = bench_sexp_of_t ~sexp_of_t (`List [ 1; 2 ])
-    let%bench_fun "sexp_of_t, list, empty" = bench_sexp_of_t ~sexp_of_t (`List [])
-    let%bench_fun "t_of_sexp, atomic" = bench_t_of_sexp ~t_of_sexp "Atomic"
-    let%bench_fun "t_of_sexp, tuple" = bench_t_of_sexp ~t_of_sexp "(Tuple (1 hello))"
-    let%bench_fun "t_of_sexp, list, full" = bench_t_of_sexp ~t_of_sexp "(List 1 2)"
-    let%bench_fun "t_of_sexp, list, empty" = bench_t_of_sexp ~t_of_sexp "(List)"
-  end)
-;;
-
-let%bench_module "Inherit" =
-  (module struct
-    type atomic = [ `Atomic ] [@@deriving sexp]
-    type tuple = [ `Tuple of int * string ] [@@deriving sexp]
-    type listed = [ `List of int list [@sexp.list] ] [@@deriving sexp]
-
-    type t =
-      [ atomic
-      | tuple
-      | listed
-      ]
-    [@@deriving sexp]
-
-    let%bench_fun "sexp_of_t, atomic" = bench_sexp_of_t ~sexp_of_t `Atomic
-    let%bench_fun "sexp_of_t, tuple" = bench_sexp_of_t ~sexp_of_t (`Tuple (1, "hello"))
-    let%bench_fun "sexp_of_t, list, full" = bench_sexp_of_t ~sexp_of_t (`List [ 1; 2 ])
-    let%bench_fun "sexp_of_t, list, empty" = bench_sexp_of_t ~sexp_of_t (`List [])
-    let%bench_fun "t_of_sexp, atomic" = bench_t_of_sexp ~t_of_sexp "Atomic"
-    let%bench_fun "t_of_sexp, tuple" = bench_t_of_sexp ~t_of_sexp "(Tuple (1 hello))"
-    let%bench_fun "t_of_sexp, list, full" = bench_t_of_sexp ~t_of_sexp "(List 1 2)"
-    let%bench_fun "t_of_sexp, list, empty" = bench_t_of_sexp ~t_of_sexp "(List)"
-  end)
-;;
+  [@@deriving sexp]
+
+  let%bench_fun "sexp_of_t, atomic" = bench_sexp_of_t ~sexp_of_t Atomic
+  let%bench_fun "sexp_of_t, tuple" = bench_sexp_of_t ~sexp_of_t (Tuple (1, "hello"))
+  let%bench_fun "sexp_of_t, list, full" = bench_sexp_of_t ~sexp_of_t (List [ 1; 2 ])
+  let%bench_fun "sexp_of_t, list, empty" = bench_sexp_of_t ~sexp_of_t (List [])
+
+  let%bench_fun "sexp_of_t, record, full" =
+    bench_sexp_of_t
+      ~sexp_of_t
+      (Record
+         { a = 1
+         ; b = Some 2
+         ; c = true
+         ; d = [| 3; 4 |]
+         ; e = [ 5; 6 ]
+         ; f = Some 7
+         ; g = 8
+         ; h = 9
+         ; i = 10
+         ; j = 11
+         ; k = []
+         })
+  ;;
+
+  let%bench_fun "sexp_of_t, record, empty" =
+    bench_sexp_of_t
+      ~sexp_of_t
+      (Record
+         { a = 0
+         ; b = None
+         ; c = false
+         ; d = [||]
+         ; e = []
+         ; f = None
+         ; g = 0
+         ; h = 0
+         ; i = 0
+         ; j = 0
+         ; k = []
+         })
+  ;;
+
+  let%bench_fun "t_of_sexp, atomic" = bench_t_of_sexp ~t_of_sexp "Atomic"
+  let%bench_fun "t_of_sexp, tuple" = bench_t_of_sexp ~t_of_sexp "(Tuple 1 hello)"
+  let%bench_fun "t_of_sexp, list, full" = bench_t_of_sexp ~t_of_sexp "(List 1 2)"
+  let%bench_fun "t_of_sexp, list, empty" = bench_t_of_sexp ~t_of_sexp "(List)"
+
+  let%bench_fun "t_of_sexp, record, full, in order" =
+    bench_t_of_sexp
+      ~t_of_sexp
+      "(Record (a 1) (b (2)) (c) (d (3 4)) (e (5 6)) (f 7) (g 8) (h 9) (i 10) (j 11) (k \
+       ()))"
+  ;;
+
+  let%bench_fun "t_of_sexp, record, full, reverse order" =
+    bench_t_of_sexp
+      ~t_of_sexp
+      "(Record (k ()) (j 11) (i 10) (h 9) (g 8) (f 7) (e (5 6)) (d (3 4)) (c) (b (2)) (a \
+       1))"
+  ;;
+
+  let%bench_fun "t_of_sexp, record, empty" =
+    bench_t_of_sexp ~t_of_sexp "(Record (a 0) (k ()))"
+  ;;
+end
+
+module%bench Tag = struct
+  type t =
+    [ `Atomic
+    | `Tuple of int * string
+    | `List of int list [@sexp.list]
+    ]
+  [@@deriving sexp]
+
+  let%bench_fun "sexp_of_t, atomic" = bench_sexp_of_t ~sexp_of_t `Atomic
+  let%bench_fun "sexp_of_t, tuple" = bench_sexp_of_t ~sexp_of_t (`Tuple (1, "hello"))
+  let%bench_fun "sexp_of_t, list, full" = bench_sexp_of_t ~sexp_of_t (`List [ 1; 2 ])
+  let%bench_fun "sexp_of_t, list, empty" = bench_sexp_of_t ~sexp_of_t (`List [])
+  let%bench_fun "t_of_sexp, atomic" = bench_t_of_sexp ~t_of_sexp "Atomic"
+  let%bench_fun "t_of_sexp, tuple" = bench_t_of_sexp ~t_of_sexp "(Tuple (1 hello))"
+  let%bench_fun "t_of_sexp, list, full" = bench_t_of_sexp ~t_of_sexp "(List 1 2)"
+  let%bench_fun "t_of_sexp, list, empty" = bench_t_of_sexp ~t_of_sexp "(List)"
+end
+
+module%bench Inherit = struct
+  type atomic = [ `Atomic ] [@@deriving sexp]
+  type tuple = [ `Tuple of int * string ] [@@deriving sexp]
+  type listed = [ `List of int list [@sexp.list] ] [@@deriving sexp]
+
+  type t =
+    [ atomic
+    | tuple
+    | listed
+    ]
+  [@@deriving sexp]
+
+  let%bench_fun "sexp_of_t, atomic" = bench_sexp_of_t ~sexp_of_t `Atomic
+  let%bench_fun "sexp_of_t, tuple" = bench_sexp_of_t ~sexp_of_t (`Tuple (1, "hello"))
+  let%bench_fun "sexp_of_t, list, full" = bench_sexp_of_t ~sexp_of_t (`List [ 1; 2 ])
+  let%bench_fun "sexp_of_t, list, empty" = bench_sexp_of_t ~sexp_of_t (`List [])
+  let%bench_fun "t_of_sexp, atomic" = bench_t_of_sexp ~t_of_sexp "Atomic"
+  let%bench_fun "t_of_sexp, tuple" = bench_t_of_sexp ~t_of_sexp "(Tuple (1 hello))"
+  let%bench_fun "t_of_sexp, list, full" = bench_t_of_sexp ~t_of_sexp "(List 1 2)"
+  let%bench_fun "t_of_sexp, list, empty" = bench_t_of_sexp ~t_of_sexp "(List)"
+end
diff --git a/expander/expand_of_sexp.ml b/expander/expand_of_sexp.ml
index 01db84b..b6da50d 100644
--- a/expander/expand_of_sexp.ml
+++ b/expander/expand_of_sexp.ml
@@ -155,54 +155,54 @@ module Str_generate_of_sexp = struct
     : Conversion.t
     =
     let loc = typ.ptyp_loc in
-    match Ppxlib_jane.Jane_syntax.Core_type.of_ast typ with
-    | Some (Jtyp_tuple alist, (_ : attributes)) ->
-      Conversion.of_reference_exn
-        (labeled_tuple_of_sexp ~error_source ~typevars ~loc alist)
-    | Some (Jtyp_layout _, _) | None ->
-      (match Ppxlib_jane.Shim.Core_type.of_parsetree typ with
-       | _ when Option.is_some (Attribute.get Attrs.opaque typ) ->
-         Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.opaque_of_sexp]
-       | { ptyp_desc = Ptyp_any; _ } ->
+    match Ppxlib_jane.Shim.Core_type.of_parsetree typ with
+    | _ when Option.is_some (Attribute.get Attrs.opaque typ) ->
+      Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.opaque_of_sexp]
+    | { ptyp_desc = Ptyp_any _; _ } ->
+      Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.opaque_of_sexp]
+    | { ptyp_desc = Ptyp_tuple labeled_tps; _ } ->
+      (match Ppxlib_jane.as_unlabeled_tuple labeled_tps with
+       | Some tps ->
+         Conversion.of_lambda (tuple_of_sexp ~error_source ~typevars (loc, tps))
+       | None ->
+         Conversion.of_reference_exn
+           (labeled_tuple_of_sexp ~error_source ~typevars ~loc labeled_tps))
+    | { ptyp_desc = Ptyp_var (parm, _); _ } ->
+      (match Map.find typevars parm with
+       | Some fresh -> Conversion.of_reference_exn (Fresh_name.expression fresh)
+       | None ->
+         Location.raise_errorf ~loc "ppx_sexp_conv: unbound type variable '%s" parm)
+    | { ptyp_desc = Ptyp_constr (id, args); _ } ->
+      (match typ with
+       | [%type: [%t? _] sexp_opaque] ->
          Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.opaque_of_sexp]
-       | { ptyp_desc = Ptyp_tuple tp; _ } ->
-         Conversion.of_lambda (tuple_of_sexp ~error_source ~typevars (loc, tp))
-       | { ptyp_desc = Ptyp_var parm; _ } ->
-         (match Map.find typevars parm with
-          | Some fresh -> Conversion.of_reference_exn (Fresh_name.expression fresh)
-          | None ->
-            Location.raise_errorf ~loc "ppx_sexp_conv: unbound type variable '%s" parm)
-       | { ptyp_desc = Ptyp_constr (id, args); _ } ->
-         (match typ with
-          | [%type: [%t? _] sexp_opaque] ->
-            Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.opaque_of_sexp]
-          | [%type: [%t? ty1] sexp_list] ->
-            let arg1 =
-              Conversion.to_expression ~loc (type_of_sexp ~error_source ~typevars ty1)
-            in
-            Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.list_of_sexp [%e arg1]]
-          | [%type: [%t? ty1] sexp_array] ->
-            let arg1 =
-              Conversion.to_expression ~loc (type_of_sexp ~error_source ~typevars ty1)
-            in
-            Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.array_of_sexp [%e arg1]]
-          | _ ->
-            let args =
-              List.map args ~f:(fun arg ->
-                Conversion.to_expression ~loc (type_of_sexp ~error_source ~typevars arg))
-            in
-            Conversion.of_reference_exn (type_constr_of_sexp ~loc ~internal id args))
-       | { ptyp_desc = Ptyp_arrow (_, _, _, _, _); _ } ->
-         Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.fun_of_sexp]
-       | { ptyp_desc = Ptyp_variant (row_fields, Closed, _); _ } ->
-         variant_of_sexp ~error_source ~typevars ?full_type (loc, row_fields)
-       | { ptyp_desc = Ptyp_poly (parms, poly_tp); _ } ->
-         poly_of_sexp ~error_source ~typevars parms poly_tp
-       | core_type ->
-         Location.raise_errorf
-           ~loc
-           "Type unsupported for ppx [of_sexp] conversion (%s)"
-           (Ppxlib_jane.Language_feature_name.of_core_type_desc core_type.ptyp_desc))
+       | [%type: [%t? ty1] sexp_list] ->
+         let arg1 =
+           Conversion.to_expression ~loc (type_of_sexp ~error_source ~typevars ty1)
+         in
+         Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.list_of_sexp [%e arg1]]
+       | [%type: [%t? ty1] sexp_array] ->
+         let arg1 =
+           Conversion.to_expression ~loc (type_of_sexp ~error_source ~typevars ty1)
+         in
+         Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.array_of_sexp [%e arg1]]
+       | _ ->
+         let args =
+           List.map args ~f:(fun arg ->
+             Conversion.to_expression ~loc (type_of_sexp ~error_source ~typevars arg))
+         in
+         Conversion.of_reference_exn (type_constr_of_sexp ~loc ~internal id args))
+    | { ptyp_desc = Ptyp_arrow (_, _, _, _, _); _ } ->
+      Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.fun_of_sexp]
+    | { ptyp_desc = Ptyp_variant (row_fields, Closed, _); _ } ->
+      variant_of_sexp ~error_source ~typevars ?full_type (loc, row_fields)
+    | { ptyp_desc = Ptyp_poly (parms, poly_tp); _ } ->
+      poly_of_sexp ~error_source ~typevars parms poly_tp
+    | core_type ->
+      Location.raise_errorf
+        ~loc
+        "Type unsupported for ppx [of_sexp] conversion (%s)"
+        (Ppxlib_jane.Language_feature_name.of_core_type_desc core_type.ptyp_desc)
 
   (* Conversion of (unlabeled) tuples *)
   and tuple_of_sexp ~error_source ~typevars (loc, tps) =
@@ -224,7 +224,7 @@ module Str_generate_of_sexp = struct
 
   (* Conversion of labeled tuples *)
   and labeled_tuple_of_sexp ~error_source ~typevars ~loc alist =
-    assert (Labeled_tuple.is_valid alist);
+    assert (Labeled_tuple.has_any_label alist);
     let fields_expr =
       List.fold_right
         alist
@@ -249,7 +249,7 @@ module Str_generate_of_sexp = struct
         List.fold_right pats ~init:(punit ~loc) ~f:(fun pat1 pat2 ->
           ppat_tuple ~loc [ pat1; pat2 ])
       in
-      let expr = Ppxlib_jane.Jane_syntax.Labeled_tuples.expr_of ~loc exprs in
+      let expr = Ppxlib_jane.Ast_builder.Default.pexp_tuple ~loc exprs in
       [%expr fun [%p pat] -> [%e expr]]
     in
     pexp_apply
@@ -579,14 +579,14 @@ module Str_generate_of_sexp = struct
   and poly_of_sexp ~error_source ~typevars parms tp =
     let loc = tp.ptyp_loc in
     let typevars =
-      List.fold parms ~init:typevars ~f:(fun map parm ->
+      List.fold parms ~init:typevars ~f:(fun map (parm, _jkind) ->
         Map.set
           map
           ~key:parm.txt
           ~data:(Fresh_name.create ("_of_" ^ parm.txt) ~loc:parm.loc))
     in
     let bindings =
-      let mk_binding parm =
+      let mk_binding (parm, _jkind) =
         let fresh = Map.find_exn typevars parm.txt in
         let fresh_sexp = Fresh_name.create "sexp" ~loc in
         value_binding
@@ -611,9 +611,10 @@ module Str_generate_of_sexp = struct
     }
 
   let record_poly_type field =
-    match field.pld_type.ptyp_desc with
+    match Ppxlib_jane.Shim.Core_type_desc.of_parsetree field.pld_type.ptyp_desc with
     | Ptyp_poly (params, body) ->
       let type_and_field_name = Fresh_name.of_string_loc field.pld_name in
+      let params = List.map params ~f:(fun (name, _jkind) -> name) in
       Some { type_and_field_name; params; body }
     | _ -> None
   ;;
diff --git a/expander/expand_sexp_of.ml b/expander/expand_sexp_of.ml
index 7ce51bd..a00e7fc 100644
--- a/expander/expand_sexp_of.ml
+++ b/expander/expand_sexp_of.ml
@@ -52,47 +52,45 @@ module Str_generate_sexp_of = struct
   (* Conversion of types *)
   let rec sexp_of_type ~renaming typ : Conversion.t =
     let loc = { typ.ptyp_loc with loc_ghost = true } in
-    match Ppxlib_jane.Jane_syntax.Core_type.of_ast typ with
-    | Some (Jtyp_tuple alist, (_ : attributes)) ->
-      Conversion.of_lambda [ sexp_of_labeled_tuple ~renaming ~loc alist ]
-    | Some (Jtyp_layout _, _) | None ->
-      (match Ppxlib_jane.Shim.Core_type.of_parsetree typ with
-       | _ when Option.is_some (Attribute.get Attrs.opaque typ) ->
+    match Ppxlib_jane.Shim.Core_type.of_parsetree typ with
+    | _ when Option.is_some (Attribute.get Attrs.opaque typ) ->
+      Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.sexp_of_opaque]
+    | { ptyp_desc = Ptyp_any _; _ } ->
+      Conversion.of_lambda [ ppat_any ~loc --> [%expr Sexplib0.Sexp.Atom "_"] ]
+    | { ptyp_desc = Ptyp_tuple labeled_tps; _ } ->
+      (match Ppxlib_jane.as_unlabeled_tuple labeled_tps with
+       | Some tps -> Conversion.of_lambda [ sexp_of_tuple ~renaming (loc, tps) ]
+       | None -> Conversion.of_lambda [ sexp_of_labeled_tuple ~renaming ~loc labeled_tps ])
+    | { ptyp_desc = Ptyp_var (parm, _); _ } ->
+      (match Renaming.binding_kind renaming parm ~loc with
+       | Universally_bound fresh ->
+         Conversion.of_reference_exn (Fresh_name.expression fresh)
+       | Existentially_bound -> sexp_of_type ~renaming [%type: _])
+    | { ptyp_desc = Ptyp_constr (id, args); _ } ->
+      (match typ with
+       | [%type: [%t? _] sexp_opaque] ->
          Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.sexp_of_opaque]
-       | { ptyp_desc = Ptyp_any; _ } ->
-         Conversion.of_lambda [ ppat_any ~loc --> [%expr Sexplib0.Sexp.Atom "_"] ]
-       | { ptyp_desc = Ptyp_tuple tp; _ } ->
-         Conversion.of_lambda [ sexp_of_tuple ~renaming (loc, tp) ]
-       | { ptyp_desc = Ptyp_var parm; _ } ->
-         (match Renaming.binding_kind renaming parm ~loc with
-          | Universally_bound fresh ->
-            Conversion.of_reference_exn (Fresh_name.expression fresh)
-          | Existentially_bound -> sexp_of_type ~renaming [%type: _])
-       | { ptyp_desc = Ptyp_constr (id, args); _ } ->
-         (match typ with
-          | [%type: [%t? _] sexp_opaque] ->
-            Conversion.of_reference_exn [%expr Sexplib0.Sexp_conv.sexp_of_opaque]
-          | _ ->
-            Conversion.of_reference_exn
-              (sexp_of_type_constr
-                 ~loc
-                 id
-                 (List.map args ~f:(fun tp ->
-                    Conversion.to_expression ~loc (sexp_of_type ~renaming tp)))))
-       | { ptyp_desc = Ptyp_arrow (_, _, _, _, _); _ } ->
-         Conversion.of_lambda
-           [ ppat_any ~loc
-             --> [%expr Sexplib0.Sexp_conv.sexp_of_fun Sexplib0.Sexp_conv.ignore]
-           ]
-       | { ptyp_desc = Ptyp_variant (row_fields, Closed, _); _ } ->
-         sexp_of_variant ~renaming (loc, row_fields)
-       | { ptyp_desc = Ptyp_poly (parms, poly_tp); _ } ->
-         sexp_of_poly ~renaming parms poly_tp
-       | core_type ->
-         Location.raise_errorf
-           ~loc
-           "Type unsupported for ppx [sexp_of] conversion (%s)"
-           (Ppxlib_jane.Language_feature_name.of_core_type_desc core_type.ptyp_desc))
+       | _ ->
+         Conversion.of_reference_exn
+           (sexp_of_type_constr
+              ~loc
+              id
+              (List.map args ~f:(fun tp ->
+                 Conversion.to_expression ~loc (sexp_of_type ~renaming tp)))))
+    | { ptyp_desc = Ptyp_arrow (_, _, _, _, _); _ } ->
+      Conversion.of_lambda
+        [ ppat_any ~loc
+          --> [%expr Sexplib0.Sexp_conv.sexp_of_fun Sexplib0.Sexp_conv.ignore]
+        ]
+    | { ptyp_desc = Ptyp_variant (row_fields, Closed, _); _ } ->
+      sexp_of_variant ~renaming (loc, row_fields)
+    | { ptyp_desc = Ptyp_poly (parms, poly_tp); _ } ->
+      sexp_of_poly ~renaming parms poly_tp
+    | core_type ->
+      Location.raise_errorf
+        ~loc
+        "Type unsupported for ppx [sexp_of] conversion (%s)"
+        (Ppxlib_jane.Language_feature_name.of_core_type_desc core_type.ptyp_desc)
 
   (* Conversion of (unlabeled) tuples *)
   and sexp_of_tuple ~renaming (loc, tps) =
@@ -106,7 +104,6 @@ module Str_generate_sexp_of = struct
 
   (* Conversion of labeled tuples *)
   and sexp_of_labeled_tuple ~renaming ~loc alist =
-    assert (Labeled_tuple.is_valid alist);
     let ({ bindings; arguments; converted } : Conversion.Apply_all.t) =
       List.map alist ~f:(fun (_, core_type) -> sexp_of_type ~renaming core_type)
       |> Conversion.apply_all ~loc
@@ -125,9 +122,10 @@ module Str_generate_sexp_of = struct
       |> pexp_let ~loc Nonrecursive bindings
     in
     let pat =
-      ( List.map2_exn alist arguments ~f:(fun (label_option, _) arg -> label_option, arg)
-      , Closed )
-      |> Ppxlib_jane.Jane_syntax.Labeled_tuples.pat_of ~loc
+      Ppxlib_jane.Ast_builder.Default.ppat_tuple
+        ~loc
+        (List.map2_exn alist arguments ~f:(fun (label_option, _) arg -> label_option, arg))
+        Closed
     in
     pat --> expr
 
@@ -196,13 +194,11 @@ module Str_generate_sexp_of = struct
   and sexp_of_poly ~renaming parms tp =
     let loc = tp.ptyp_loc in
     let renaming =
-      List.fold_left
-        parms
-        ~init:renaming
-        ~f:(Renaming.add_universally_bound ~prefix:"_of_")
+      List.fold_left parms ~init:renaming ~f:(fun renaming (name, _jkind) ->
+        Renaming.add_universally_bound renaming name ~prefix:"_of_")
     in
     let bindings =
-      let mk_binding parm =
+      let mk_binding (parm, _jkind) =
         let name =
           match Renaming.binding_kind renaming parm.txt ~loc:parm.loc with
           | Universally_bound name -> name
@@ -295,9 +291,9 @@ module Str_generate_sexp_of = struct
         object
           inherit Ast_traverse.iter as super
 
-          method! core_type_desc =
-            function
-            | Ptyp_var v ->
+          method! core_type_desc t =
+            match Ppxlib_jane.Shim.Core_type_desc.of_parsetree t with
+            | Ptyp_var (v, _) ->
               Location.raise_errorf
                 ~loc
                 "[@%s] was used, but the type of the field contains a type variable: '%s.\n\
@@ -305,7 +301,7 @@ module Str_generate_sexp_of = struct
                  Consider using [@sexp_drop_if _] or [@sexp_drop_default.sexp] instead."
                 attr_name
                 v
-            | t -> super#core_type_desc t
+            | _ -> super#core_type_desc t
         end
       in
       iter#core_type
diff --git a/expander/helpers.ml b/expander/helpers.ml
index 1cebfbf..338b726 100644
--- a/expander/helpers.ml
+++ b/expander/helpers.ml
@@ -11,10 +11,11 @@ let replace_variables_by_underscores =
     object
       inherit Ast_traverse.map as super
 
-      method! core_type_desc =
-        function
-        | Ptyp_var _ -> Ptyp_any
-        | t -> super#core_type_desc t
+      method! core_type_desc t =
+        match Ppxlib_jane.Shim.Core_type_desc.of_parsetree t with
+        | Ptyp_var (_, jkind) ->
+          Ppxlib_jane.Shim.Core_type_desc.to_parsetree (Ptyp_any jkind)
+        | _ -> super#core_type_desc t
     end
   in
   map#core_type
@@ -51,19 +52,11 @@ let make_type_rigid ~rigid_types =
       inherit Ast_traverse.map as super
 
       method! core_type ty =
-        match Ppxlib_jane.Jane_syntax.Core_type.of_ast ty with
-        | Some (Jtyp_layout (Ltyp_var { name = Some name; jkind = _ }), ptyp_attributes)
-          ->
+        match Ppxlib_jane.Shim.Core_type_desc.of_parsetree ty.ptyp_desc with
+        | Ptyp_var (name, _) ->
           let ptyp_desc = find_rigid_type_constr ~loc:ty.ptyp_loc ~rigid_types name in
-          { ty with ptyp_desc; ptyp_attributes }
-        | Some _ -> super#core_type ty
-        | None ->
-          let ptyp_desc =
-            match ty.ptyp_desc with
-            | Ptyp_var s -> find_rigid_type_constr ~loc:ty.ptyp_loc ~rigid_types s
-            | desc -> super#core_type_desc desc
-          in
           { ty with ptyp_desc }
+        | _ -> super#core_type ty
     end
   in
   map#core_type
@@ -76,7 +69,7 @@ let make_type_rigid ~rigid_types =
    not work because of certains types with constraints. We thus only use rigid variables
    for sum types, which includes all GADTs. *)
 
-type bound_var = string loc * Ppxlib_jane.Jane_syntax.Jkind.annotation option
+type bound_var = string loc * Ppxlib_jane.jkind_annotation option
 
 let tvars_of_core_type : core_type -> bound_var list =
   let add_binding_to_list (bindings : bound_var list) (bound : bound_var) =
@@ -95,15 +88,9 @@ let tvars_of_core_type : core_type -> bound_var list =
 
       method! core_type x acc =
         let loc = x.ptyp_loc in
-        match x.ptyp_desc with
-        | Ptyp_var bound_name ->
-          let binding =
-            match Ppxlib_jane.Jane_syntax.Core_type.of_ast x with
-            | Some (Jtyp_layout (Ltyp_var { name = Some name; jkind }), _attrs) ->
-              { txt = name; loc }, Some jkind
-            | _ -> { txt = bound_name; loc }, None
-          in
-          add_binding_to_list acc binding
+        match Ppxlib_jane.Shim.Core_type_desc.of_parsetree x.ptyp_desc with
+        | Ptyp_var (bound_name, jkind) ->
+          add_binding_to_list acc ({ txt = bound_name; loc }, jkind)
         | _ -> super#core_type x acc
     end
   in
@@ -115,7 +102,7 @@ let constrained_function_binding
     (loc : Location.t)
   (td : type_declaration)
   (typ : core_type)
-  ~(tps : (string loc * Ppxlib_jane.Jane_syntax.Jkind.annotation option) list)
+  ~(tps : (string loc * Ppxlib_jane.jkind_annotation option) list)
   ~(func_name : string)
   (body : expression)
   =
@@ -130,12 +117,7 @@ let constrained_function_binding
     if not has_vars
     then pat
     else (
-      let annot =
-        Ppxlib_jane.Jane_syntax.Core_type.core_type_of
-          ~loc
-          ~attrs:[]
-          (Jtyp_layout (Ltyp_poly { inner_type = typ; bound_vars }))
-      in
+      let annot = Ppxlib_jane.Ast_builder.Default.ptyp_poly ~loc bound_vars typ in
       ppat_constraint ~loc pat annot)
   in
   let body =
@@ -154,9 +136,7 @@ let constrained_function_binding
           match jkind with
           | None -> pexp_newtype ~loc name body
           | Some jkind ->
-            Ppxlib_jane.Jane_syntax.Layouts.expr_of
-              ~loc
-              (Lexp_newtype (name, jkind, body)))
+            Ppxlib_jane.Ast_builder.Default.pexp_newtype ~loc name (Some jkind) body)
         ~init:(pexp_constraint ~loc body (make_type_rigid ~rigid_types typ)))
     else if has_vars
     then body
@@ -203,10 +183,10 @@ let rec is_value_expression expr =
   (* Type-only wrappers; we check their contents. *)
   | Pexp_constraint (expr, (_ : core_type option), _)
   | Pexp_coerce (expr, (_ : core_type option), (_ : core_type))
-  | Pexp_newtype ((_ : string loc), expr)
+  | Pexp_newtype ((_ : string loc), (_ : Ppxlib_jane.jkind_annotation option), expr)
   | Pexp_stack expr -> is_value_expression expr
   (* Allocating constructors; they are only values if all of their contents are. *)
-  | Pexp_tuple exprs -> List.for_all exprs ~f:is_value_expression
+  | Pexp_tuple lexprs -> List.for_all lexprs ~f:(fun (_, e) -> is_value_expression e)
   | Pexp_unboxed_tuple lexprs ->
     List.for_all lexprs ~f:(fun (_, e) -> is_value_expression e)
   | Pexp_construct (_, maybe_expr) -> Option.for_all maybe_expr ~f:is_value_expression
@@ -239,7 +219,8 @@ let rec is_value_expression expr =
   | Pexp_pack _
   | Pexp_open _
   | Pexp_letop _
-  | Pexp_extension _ -> false
+  | Pexp_extension _
+  | Pexp_comprehension _ -> false
 ;;
 
 let really_recursive_respecting_opaque rec_flag tds =
@@ -259,14 +240,14 @@ let really_recursive_respecting_opaque rec_flag tds =
 
 let strip_attributes =
   object
-    inherit Ast_traverse.map
+    inherit Ppxlib_jane.Ast_traverse.map
 
     method! attribute attr =
       Location.raise_errorf ~loc:attr.attr_loc "failed to strip attribute from syntax"
 
     method! attributes _ = []
 
-    method! signature items =
+    method! signature_items items =
       List.filter items ~f:(fun item ->
         match item.psig_desc with
         | Psig_attribute _ -> false
diff --git a/expander/helpers.mli b/expander/helpers.mli
index 8df007b..87dea7a 100644
--- a/expander/helpers.mli
+++ b/expander/helpers.mli
@@ -12,7 +12,7 @@ val constrained_function_binding
   :  location (** location to use for the binding *)
   -> type_declaration (** type declaration used to derive the function *)
   -> core_type (** type of the function *)
-  -> tps:(string loc * Ppxlib_jane.Jane_syntax.Jkind.annotation option) list
+  -> tps:(string loc * Ppxlib_jane.Shim.jkind_annotation option) list
        (** names and jkinds of type parameters in the declaration *)
   -> func_name:string (** name to bind the function to *)
   -> expression (** expression representing the function *)
@@ -39,4 +39,4 @@ val is_value_expression : expression -> bool
     attribute. *)
 val really_recursive_respecting_opaque : rec_flag -> type_declaration list -> rec_flag
 
-val strip_attributes : Ast_traverse.map
+val strip_attributes : Ppxlib_jane.Ast_traverse.map
diff --git a/expander/labeled_tuple.ml b/expander/labeled_tuple.ml
index 339bd7e..3441c0a 100644
--- a/expander/labeled_tuple.ml
+++ b/expander/labeled_tuple.ml
@@ -1,6 +1,6 @@
 open! Base
 
-let is_valid alist = List.exists alist ~f:(fun (option, _) -> Option.is_some option)
+let has_any_label alist = List.exists alist ~f:(fun (label, _) -> Option.is_some label)
 
 let atom_of_label = function
   | None -> "."
diff --git a/expander/labeled_tuple.mli b/expander/labeled_tuple.mli
index 2414f81..d15b2fa 100644
--- a/expander/labeled_tuple.mli
+++ b/expander/labeled_tuple.mli
@@ -3,7 +3,6 @@
    (https://github.com/ocaml-flambda/flambda-backend/). *)
 
 open! Base
-open Ppxlib_jane
 
-val is_valid : Jane_syntax.Labeled_tuples.core_type -> bool
+val has_any_label : (string option * _) list -> bool
 val atom_of_label : string option -> string
diff --git a/expander/ppx_sexp_conv_expander.ml b/expander/ppx_sexp_conv_expander.ml
index f5998d1..f25cb19 100644
--- a/expander/ppx_sexp_conv_expander.ml
+++ b/expander/ppx_sexp_conv_expander.ml
@@ -53,12 +53,12 @@ module Sig_sexp = struct
               | Maybe_non_value
           end in
           let has_jkind_annotation =
-            match Ppxlib_jane.Jane_syntax.Layouts.of_type_declaration td with
+            match Ppxlib_jane.Shim.Type_declaration.extract_jkind_annotation td with
             | None -> None
-            | Some (jkind, _) ->
-              (match jkind.txt with
+            | Some jkind ->
+              (match jkind.pjkind_desc with
                | Default -> None (* [t : _] *)
-               | Abbreviation { txt = "value"; _ } -> Some Value (* [t : value] *)
+               | Abbreviation "value" -> Some Value (* [t : value] *)
                | _ -> Some Maybe_non_value)
           in
           let is_value =
diff --git a/expander/ppx_sexp_conv_expander.mli b/expander/ppx_sexp_conv_expander.mli
index a0847ce..3a6e2d7 100644
--- a/expander/ppx_sexp_conv_expander.mli
+++ b/expander/ppx_sexp_conv_expander.mli
@@ -10,9 +10,13 @@ module Sexp_of : sig
     :  loc:Location.t
     -> path:string
     -> rec_flag * type_declaration list
-    -> signature
+    -> signature_item list
 
-  val sig_exception : loc:Location.t -> path:string -> type_exception -> signature
+  val sig_exception
+    :  loc:Location.t
+    -> path:string
+    -> type_exception
+    -> signature_item list
 
   val str_type_decl
     :  loc:Location.t
@@ -32,7 +36,7 @@ module Of_sexp : sig
     -> loc:Location.t
     -> path:string
     -> rec_flag * type_declaration list
-    -> signature
+    -> signature_item list
 
   val str_type_decl
     :  loc:Location.t
@@ -54,7 +58,7 @@ module Sexp_grammar : sig
   val sig_type_decl
     :  ctxt:Expansion_context.Deriver.t
     -> rec_flag * type_declaration list
-    -> signature
+    -> signature_item list
 
   val str_type_decl
     :  ctxt:Expansion_context.Deriver.t
@@ -68,5 +72,5 @@ module Sig_sexp : sig
     :  loc:Location.t
     -> path:string
     -> rec_flag * type_declaration list
-    -> signature
+    -> signature_item list
 end
diff --git a/expander/ppx_sexp_conv_grammar.ml b/expander/ppx_sexp_conv_grammar.ml
index 5b20faa..8d18e39 100644
--- a/expander/ppx_sexp_conv_grammar.ml
+++ b/expander/ppx_sexp_conv_grammar.ml
@@ -274,56 +274,55 @@ let rec grammar_of_type core_type ~rec_flag ~tags_of_doc_comments =
     match from_attribute with
     | Some expr -> expr
     | None ->
-      (match Ppxlib_jane.Jane_syntax.Core_type.of_ast core_type with
-       | Some (Jtyp_tuple ltps, _attrs) ->
-         grammar_of_labeled_tuple ~loc ~rec_flag ~tags_of_doc_comments ltps
-       | Some (Jtyp_layout _, _) | None ->
-         (match Ppxlib_jane.Shim.Core_type_desc.of_parsetree core_type.ptyp_desc with
-          | Ptyp_any -> any_grammar ~loc "_"
-          | Ptyp_var name ->
-            (match rec_flag with
-             | Recursive ->
-               (* For recursive grammars, [grammar_of_type] for any type variables is called
+      (match Ppxlib_jane.Shim.Core_type_desc.of_parsetree core_type.ptyp_desc with
+       | Ptyp_any _ -> any_grammar ~loc "_"
+       | Ptyp_var (name, _) ->
+         (match rec_flag with
+          | Recursive ->
+            (* For recursive grammars, [grammar_of_type] for any type variables is called
                   inside a [defn]. The variables should therefore be resolved as [Tyvar]
                   grammars. *)
-               tyvar_grammar ~loc (estring ~loc name)
-             | Nonrecursive ->
-               (* Outside recursive [defn]s, type variables are passed in as function
+            tyvar_grammar ~loc (estring ~loc name)
+          | Nonrecursive ->
+            (* Outside recursive [defn]s, type variables are passed in as function
                   arguments. *)
-               unapplied_type_constr_conv
-                 ~loc
-                 ~f:tyvar_grammar_name
-                 (Located.lident ~loc name)
-               |> untyped_grammar ~loc)
-          | Ptyp_arrow _ -> arrow_grammar ~loc
-          | Ptyp_tuple list ->
-            List.map ~f:(grammar_of_type ~rec_flag ~tags_of_doc_comments) list
+            unapplied_type_constr_conv
+              ~loc
+              ~f:tyvar_grammar_name
+              (Located.lident ~loc name)
+            |> untyped_grammar ~loc)
+       | Ptyp_arrow _ -> arrow_grammar ~loc
+       | Ptyp_tuple labeled_tps ->
+         (match Ppxlib_jane.as_unlabeled_tuple labeled_tps with
+          | Some tps ->
+            List.map ~f:(grammar_of_type ~rec_flag ~tags_of_doc_comments) tps
             |> tuple_grammar ~loc
             |> list_grammar ~loc
-          | Ptyp_unboxed_tuple _ -> unsupported ~loc "unboxed tuple types"
-          | Ptyp_constr (id, args) ->
-            List.map args ~f:(fun core_type ->
-              let loc = core_type.ptyp_loc in
-              grammar_of_type ~rec_flag ~tags_of_doc_comments core_type
-              |> typed_grammar ~loc)
-            |> type_constr_conv ~loc ~f:grammar_name id
-            |> untyped_grammar ~loc
-          | Ptyp_object _ -> unsupported ~loc "object types"
-          | Ptyp_class _ -> unsupported ~loc "class types"
-          | Ptyp_alias _ -> unsupported ~loc "type aliases"
-          | Ptyp_variant (rows, closed_flag, (_ : string list option)) ->
-            (match closed_flag with
-             | Open -> unsupported ~loc "open polymorphic variant types"
-             | Closed ->
-               grammar_of_polymorphic_variant ~loc ~rec_flag ~tags_of_doc_comments rows)
-          | Ptyp_poly _ -> unsupported ~loc "explicitly polymorphic types"
-          | Ptyp_package _ -> unsupported ~loc "first-class module types"
-          | Ptyp_extension _ -> unsupported ~loc "unexpanded ppx extensions"))
+          | None ->
+            grammar_of_labeled_tuple ~loc ~rec_flag ~tags_of_doc_comments labeled_tps)
+       | Ptyp_unboxed_tuple _ -> unsupported ~loc "unboxed tuple types"
+       | Ptyp_constr (id, args) ->
+         List.map args ~f:(fun core_type ->
+           let loc = core_type.ptyp_loc in
+           grammar_of_type ~rec_flag ~tags_of_doc_comments core_type |> typed_grammar ~loc)
+         |> type_constr_conv ~loc ~f:grammar_name id
+         |> untyped_grammar ~loc
+       | Ptyp_object _ -> unsupported ~loc "object types"
+       | Ptyp_class _ -> unsupported ~loc "class types"
+       | Ptyp_alias _ -> unsupported ~loc "type aliases"
+       | Ptyp_variant (rows, closed_flag, (_ : string list option)) ->
+         (match closed_flag with
+          | Open -> unsupported ~loc "open polymorphic variant types"
+          | Closed ->
+            grammar_of_polymorphic_variant ~loc ~rec_flag ~tags_of_doc_comments rows)
+       | Ptyp_poly _ -> unsupported ~loc "explicitly polymorphic types"
+       | Ptyp_package _ -> unsupported ~loc "first-class module types"
+       | Ptyp_extension _ -> unsupported ~loc "unexpanded ppx extensions")
   in
   grammar_of_type_tags core_type grammar ~tags_of_doc_comments
 
 and grammar_of_labeled_tuple ~loc ~rec_flag ~tags_of_doc_comments alist =
-  assert (Labeled_tuple.is_valid alist);
+  assert (Labeled_tuple.has_any_label alist);
   let fields =
     List.concat_map alist ~f:(fun (lbl, typ) ->
       let lbl = Labeled_tuple.atom_of_label lbl in
@@ -524,7 +523,7 @@ let rec is_preallocated_constant expr =
   | Pexp_constraint (expr, _, _) | Pexp_coerce (expr, _, _) | Pexp_open (_, expr) ->
     is_preallocated_constant expr
   | Pexp_constant _ -> true
-  | Pexp_tuple args -> List.for_all ~f:is_preallocated_constant args
+  | Pexp_tuple args -> List.for_all ~f:(fun (_, e) -> is_preallocated_constant e) args
   | Pexp_variant (_, maybe_arg) | Pexp_construct (_, maybe_arg) ->
     Option.for_all ~f:is_preallocated_constant maybe_arg
   | Pexp_record (fields, maybe_template) ->
diff --git a/expander/ppx_sexp_conv_grammar.mli b/expander/ppx_sexp_conv_grammar.mli
index f62c3d6..4c63258 100644
--- a/expander/ppx_sexp_conv_grammar.mli
+++ b/expander/ppx_sexp_conv_grammar.mli
@@ -12,7 +12,7 @@ val core_type
 val sig_type_decl
   :  ctxt:Expansion_context.Deriver.t
   -> rec_flag * type_declaration list
-  -> signature
+  -> signature_item list
 
 val str_type_decl
   :  ctxt:Expansion_context.Deriver.t
diff --git a/expander/renaming.ml b/expander/renaming.ml
index dff3785..5f28203 100644
--- a/expander/renaming.ml
+++ b/expander/renaming.ml
@@ -60,8 +60,8 @@ let with_constructor_declaration original cd ~type_parameters:tps =
       inherit [t] Ast_traverse.fold as super
 
       method! core_type ty t =
-        match ty.ptyp_desc with
-        | Ptyp_var var ->
+        match Ppxlib_jane.Shim.Core_type_desc.of_parsetree ty.ptyp_desc with
+        | Ptyp_var (var, _) ->
           let error =
             { loc = ty.ptyp_loc
             ; txt = "ppx_sexp_conv: variable is not a parameter of the type constructor"
@@ -72,8 +72,8 @@ let with_constructor_declaration original cd ~type_parameters:tps =
     end
   in
   let aux t tp_name tp_in_return_type =
-    match tp_in_return_type.ptyp_desc with
-    | Ptyp_var var ->
+    match Ppxlib_jane.Shim.Core_type_desc.of_parsetree tp_in_return_type.ptyp_desc with
+    | Ptyp_var (var, _) ->
       let data =
         let loc = tp_in_return_type.ptyp_loc in
         if Map.mem t.universal var
