From 0875fbce61c00e4f4b5a068aa5c1f654829c614d Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Tue, 13 Aug 2024 20:53:44 +0100
Subject: [PATCH] v0.17~preview.129.36+325

---
 doc/part3-map.mdx                        |    9 +-
 skeleton/dune                            |    7 +
 skeleton/incremental_skeleton.ml         |    4 +
 skeleton/incremental_skeleton.mli        |   31 +
 skeleton/node.ml                         |   15 +
 skeleton/node.mli                        |   18 +
 skeleton/render_relation.ml              |   10 +
 skeleton/render_relation.mli             |   10 +
 skeleton/skeleton.ml                     |  225 +
 skeleton/skeleton.mli                    |   29 +
 src/adjust_heights_heap.ml               |    4 +-
 src/dot_user_info.ml                     |    4 +-
 src/incremental.ml                       |   58 +-
 src/incremental_intf.ml                  |   44 +-
 src/internal_observer.ml                 |    2 +-
 src/node.ml                              |   26 +-
 src/node.mli                             |    4 +-
 src/node_to_dot.ml                       |   16 +-
 src/on_update_handler.ml                 |   10 +-
 src/recompute_heap.ml                    |    4 +-
 src/state.ml                             |   40 +-
 src/unordered_array_fold.ml              |   10 +-
 step_function/test/dune                  |    2 +-
 step_function/test/test_step_function.ml |    2 +-
 test-debug/dune                          |    9 +-
 test/dune                                |    5 +-
 test/test_config.ml                      |    2 +-
 test/test_exceptional_behavior.ml        |    6 +-
 test/test_for_analyzer.ml                |    4 +-
 test/test_incremental.ml                 | 8667 +++++++++++-----------
 test/test_non_debug.ml                   |    4 +-
 test/test_skeleton.ml                    |  317 +
 test/test_skeleton.mli                   |    0
 35 files changed, 5124 insertions(+), 4481 deletions(-)
 create mode 100644 skeleton/dune
 create mode 100644 skeleton/incremental_skeleton.ml
 create mode 100644 skeleton/incremental_skeleton.mli
 create mode 100644 skeleton/node.ml
 create mode 100644 skeleton/node.mli
 create mode 100644 skeleton/render_relation.ml
 create mode 100644 skeleton/render_relation.mli
 create mode 100644 skeleton/skeleton.ml
 create mode 100644 skeleton/skeleton.mli
 create mode 100644 test/test_skeleton.ml
 create mode 100644 test/test_skeleton.mli

diff --git a/doc/part3-map.mdx b/doc/part3-map.mdx
index e0a472a..9bbff9d 100644
--- a/doc/part3-map.mdx
+++ b/doc/part3-map.mdx
@@ -261,10 +261,11 @@ Compare the types of each function:
 = <fun>
 # let _ = Incr_map.mapi'
 - : ?instrumentation:Incr_map.Instrumentation.t ->
-    ?cutoff:'a Incr.Cutoff.t ->
-    ?data_equal:('a -> 'a -> bool) ->
-    ('b, 'a, 'c) Map.t Incr.t ->
-    f:(key:'b -> data:'a Incr.t -> 'd Incr.t) -> ('b, 'd, 'c) Map.t Incr.t
+    ?comparator:('a, 'b) Comparator.Module.t ->
+    ?cutoff:'c Incr.Cutoff.t ->
+    ?data_equal:('c -> 'c -> bool) ->
+    ('a, 'c, 'b) Map.t Incr.t ->
+    f:(key:'a -> data:'c Incr.t -> 'd Incr.t) -> ('a, 'd, 'b) Map.t Incr.t
 = <fun>
 ```
 
diff --git a/skeleton/dune b/skeleton/dune
new file mode 100644
index 0000000..fb04764
--- /dev/null
+++ b/skeleton/dune
@@ -0,0 +1,7 @@
+(library
+ (name incremental_skeleton)
+ (public_name incremental.skeleton)
+ (libraries core incremental textutils_kernel.text_block
+   core_kernel.reversed_list)
+ (preprocess
+  (pps ppx_jane)))
diff --git a/skeleton/incremental_skeleton.ml b/skeleton/incremental_skeleton.ml
new file mode 100644
index 0000000..ccb4a60
--- /dev/null
+++ b/skeleton/incremental_skeleton.ml
@@ -0,0 +1,4 @@
+open! Core
+module Node = Node
+module Render_relation = Render_relation
+include Skeleton
diff --git a/skeleton/incremental_skeleton.mli b/skeleton/incremental_skeleton.mli
new file mode 100644
index 0000000..7f04a93
--- /dev/null
+++ b/skeleton/incremental_skeleton.mli
@@ -0,0 +1,31 @@
+open! Core
+module Node = Node
+module Render_relation = Render_relation
+
+type t =
+  { nodes : Node.t list
+  ; seen : Incremental.For_analyzer.Node_id.Set.t
+  ; num_stabilizes : int
+  }
+[@@deriving sexp]
+
+module Render_target : sig
+  type t =
+    | Dot
+    | Graph_easy
+end
+
+(** Creates a static snapshot of the current incremental graph.
+
+    If [?normalize] is true (default false), node IDs will be normalized relative to the
+    minimum node ID in the graph. This is primarily useful for tests.  *)
+val snapshot : ?normalize:bool -> _ Incremental.State.t -> t
+
+(** Converts a [t] to a dot string that can be rendered by graphviz. *)
+val to_dot
+  :  ?extra_attrs:(Node.t -> Incremental.For_analyzer.Dot_user_info.t option)
+  -> ?render_target:Render_target.t
+  -> ?filtered_nodes:Node.t list
+  -> ?render_relation:Render_relation.t
+  -> t
+  -> string
diff --git a/skeleton/node.ml b/skeleton/node.ml
new file mode 100644
index 0000000..e5786bb
--- /dev/null
+++ b/skeleton/node.ml
@@ -0,0 +1,15 @@
+open! Core
+open Incremental.For_analyzer
+
+type t =
+  { id : Node_id.t
+  ; kind : Kind.t
+  ; children : Node_id.t list [@sexp.list]
+  ; bind_children : Node_id.t list [@sexp.list]
+  ; user_info : Dot_user_info.t option [@sexp.option]
+  ; recomputed_at : Stabilization_num.t
+  ; cutoff : Cutoff.t [@default Cutoff.Phys_equal] [@sexp_drop_default.equal]
+  ; changed_at : Stabilization_num.t
+  ; height : int
+  }
+[@@deriving sexp]
diff --git a/skeleton/node.mli b/skeleton/node.mli
new file mode 100644
index 0000000..4a03bab
--- /dev/null
+++ b/skeleton/node.mli
@@ -0,0 +1,18 @@
+open! Core
+open Incremental.For_analyzer
+
+(* Snapshot of a [Incr.Node]'s data/metadata for use in analysis/visualization of the
+   overall graph *)
+
+type t =
+  { id : Node_id.t
+  ; kind : Kind.t
+  ; children : Node_id.t list
+  ; bind_children : Node_id.t list
+  ; user_info : Dot_user_info.t option
+  ; recomputed_at : Stabilization_num.t
+  ; cutoff : Cutoff.t
+  ; changed_at : Stabilization_num.t
+  ; height : int
+  }
+[@@deriving sexp]
diff --git a/skeleton/render_relation.ml b/skeleton/render_relation.ml
new file mode 100644
index 0000000..f8ccd2f
--- /dev/null
+++ b/skeleton/render_relation.ml
@@ -0,0 +1,10 @@
+open! Core
+
+type t =
+  | All
+  | Ancestors
+  | Descendants
+  | Both
+[@@deriving sexp, enumerate, compare, equal]
+
+let arg = Command.Arg_type.create (fun s -> s |> Sexp.Atom |> t_of_sexp)
diff --git a/skeleton/render_relation.mli b/skeleton/render_relation.mli
new file mode 100644
index 0000000..8a51da0
--- /dev/null
+++ b/skeleton/render_relation.mli
@@ -0,0 +1,10 @@
+open! Core
+
+type t =
+  | All
+  | Ancestors
+  | Descendants
+  | Both
+[@@deriving sexp, enumerate, compare, equal]
+
+val arg : t Command.Arg_type.t
diff --git a/skeleton/skeleton.ml b/skeleton/skeleton.ml
new file mode 100644
index 0000000..4e6139b
--- /dev/null
+++ b/skeleton/skeleton.ml
@@ -0,0 +1,225 @@
+open! Core
+module Node_id = Incremental.For_analyzer.Node_id
+module Dot_user_info = Incremental.For_analyzer.Dot_user_info
+
+type t =
+  { nodes : Node.t list
+  ; seen : Node_id.Set.t
+  ; num_stabilizes : int
+  }
+[@@deriving sexp]
+
+module Render_target = struct
+  type t =
+    | Dot
+    | Graph_easy
+end
+
+let normalize_ids skeleton =
+  let nodes = skeleton.nodes in
+  match nodes with
+  | [] -> skeleton
+  | hd :: _ as nodes ->
+    let lowest_id =
+      List.map nodes ~f:(fun node -> Node_id.to_int node.id)
+      |> List.min_elt ~compare:Int.compare
+      |> Option.value ~default:(Node_id.to_int hd.id)
+    in
+    let new_id node_id =
+      (* Nodes are one-indexed *)
+      Node_id.to_int node_id - lowest_id + 1 |> Node_id.of_int
+    in
+    let nodes =
+      List.map nodes ~f:(fun node ->
+        let id = new_id node.id in
+        let children = List.map node.children ~f:new_id in
+        let bind_children = List.map node.bind_children ~f:new_id in
+        { node with id; children; bind_children })
+    in
+    let seen = Node_id.Set.map skeleton.seen ~f:new_id in
+    { skeleton with nodes; seen }
+;;
+
+let snapshot ?(normalize = false) state =
+  let seen = Node_id.Hash_set.create () in
+  let nodes = ref Reversed_list.[] in
+  let add_node
+    ~id
+    ~kind
+    ~cutoff
+    ~children
+    ~bind_children
+    ~user_info
+    ~recomputed_at
+    ~changed_at
+    ~height
+    =
+    Hash_set.add seen id;
+    let new_node =
+      { Node.id
+      ; kind
+      ; cutoff
+      ; children
+      ; bind_children
+      ; user_info
+      ; recomputed_at
+      ; changed_at
+      ; height
+      }
+    in
+    nodes := new_node :: !nodes
+  in
+  Incremental.For_analyzer.traverse
+    (Incremental.For_analyzer.directly_observed state)
+    ~add_node;
+  let skeleton =
+    { nodes = Reversed_list.rev !nodes
+    ; seen = Node_id.Set.of_hash_set seen
+    ; num_stabilizes = Incremental.State.num_stabilizes state
+    }
+  in
+  if normalize then normalize_ids skeleton else skeleton
+;;
+
+let node_name (node_id : Node_id.t) = "n" ^ Node_id.to_string node_id
+
+let make_node ~(node : Node.t) ~extra_attrs ~(render_target : Render_target.t) =
+  let name = node_name node.id in
+  let base_node_dot =
+    Dot_user_info.dot
+      ~label:
+        [ name
+        ; Sexp.to_string ([%sexp_of: Incremental.For_analyzer.Kind.t] node.kind)
+        ; sprintf "height=%d" node.height
+        ]
+      ~attributes:
+        (match render_target with
+         | Dot -> String.Map.singleton "fontname" "Sans Serif"
+         | Graph_easy -> String.Map.empty)
+  in
+  let info =
+    let node_info =
+      Option.value_map node.user_info ~default:base_node_dot ~f:(fun user_info ->
+        Dot_user_info.append base_node_dot user_info)
+    in
+    let attrs_opt = extra_attrs node in
+    Option.value_map attrs_opt ~default:node_info ~f:(fun attrs ->
+      Dot_user_info.append node_info attrs)
+  in
+  Text_block.text
+    (Dot_user_info.to_string
+       ?shape:
+         (match render_target with
+          | Dot -> None
+          | Graph_easy -> Some "box")
+       ~name
+       (Dot_user_info.to_dot info))
+;;
+
+(* The parameters' names reflect the ordering of these nodes in the [Incr] graph where
+   the children of a node are the inputs (e.g. a Var would be the child of a Map), but it
+   seems more intuitive to visualize it in the opposite direction*)
+let edge ~from ~to_ = Text_block.textf {|%s -> %s|} (node_name to_) (node_name from)
+
+let make_edges ~(nodes : Node.t list) ~desired_nodes =
+  List.concat_map nodes ~f:(fun from_node ->
+    let from_node_id = from_node.id in
+    List.filter_map from_node.children ~f:(fun to_node_id ->
+      Option.some_if
+        (Set.mem desired_nodes to_node_id)
+        (edge ~from:from_node_id ~to_:to_node_id)))
+;;
+
+let bind_edge ~from ~to_ =
+  Text_block.textf {|%s -> %s [style=dashed]|} (node_name to_) (node_name from)
+;;
+
+(* Note that the direction of information flow is flipped in bind nodes as compared to
+   regular child nodes *)
+let make_bind_edges ~(nodes : Node.t list) ~desired_nodes ~seen =
+  List.concat_map nodes ~f:(fun to_node ->
+    let to_node_id = to_node.id in
+    List.filter_map to_node.bind_children ~f:(fun from_node_id ->
+      Option.some_if
+        (Set.mem desired_nodes from_node_id && Set.mem seen from_node_id)
+        (bind_edge ~from:from_node_id ~to_:to_node_id)))
+;;
+
+let find_connected_nodes
+  ~(start_nodes : Node_id.t list)
+  ~(edges : Node_id.t list Node_id.Map.t)
+  =
+  let rec recurse_node node_id seen =
+    if Set.mem seen node_id
+    then seen
+    else (
+      let seen = Set.add seen node_id in
+      let node_ids = Map.find_multi edges node_id in
+      List.fold node_ids ~init:seen ~f:(fun seen child_id -> recurse_node child_id seen))
+  in
+  List.fold start_nodes ~init:Node_id.Set.empty ~f:(fun seen node_id ->
+    recurse_node node_id seen)
+;;
+
+let to_dot
+  ?(extra_attrs = fun _ -> None)
+  ?(render_target = Render_target.Dot)
+  ?(filtered_nodes : Node.t list = [])
+  ?(render_relation = Render_relation.All)
+  { nodes; seen; num_stabilizes = _ }
+  =
+  let desired_nodes =
+    let child_edges =
+      lazy
+        (List.fold nodes ~init:Node_id.Map.empty ~f:(fun child_edges node ->
+           let added_bind =
+             List.fold node.bind_children ~init:child_edges ~f:(fun edges bind_id ->
+               Map.add_multi edges ~key:bind_id ~data:node.id)
+           in
+           List.fold node.children ~init:added_bind ~f:(fun edges child_id ->
+             Map.add_multi edges ~key:node.id ~data:child_id)))
+    in
+    let parent_edges =
+      lazy
+        (Map.fold
+           (force child_edges)
+           ~init:Node_id.Map.empty
+           ~f:(fun ~key:node_id ~data:children parent_edges ->
+             List.fold children ~init:parent_edges ~f:(fun parent_edges child_id ->
+               Map.add_multi parent_edges ~key:child_id ~data:node_id)))
+    in
+    let find_connected_nodes =
+      find_connected_nodes ~start_nodes:(List.map filtered_nodes ~f:(fun node -> node.id))
+    in
+    match render_relation with
+    | Ancestors -> find_connected_nodes ~edges:(force child_edges)
+    | Descendants -> find_connected_nodes ~edges:(force parent_edges)
+    | Both ->
+      Set.union
+        (find_connected_nodes ~edges:(force parent_edges))
+        (find_connected_nodes ~edges:(force child_edges))
+    | All -> Node_id.Set.of_list (List.map nodes ~f:(fun node -> node.id))
+  in
+  let desired_node_list =
+    List.filter nodes ~f:(fun node -> Set.mem desired_nodes node.id)
+  in
+  let edges = make_edges ~nodes:desired_node_list ~desired_nodes in
+  let bind_edges = make_bind_edges ~nodes:desired_node_list ~desired_nodes ~seen in
+  let nodes =
+    List.map desired_node_list ~f:(fun node ->
+      make_node ~node ~extra_attrs ~render_target)
+  in
+  let text_block =
+    let open Text_block in
+    vcat
+      [ text "digraph G {"
+      ; indent
+          (vcat
+             (text "rankdir = TB"
+              :: text "bgcolor = transparent"
+              :: (nodes @ edges @ bind_edges)))
+      ; text "}"
+      ]
+  in
+  Text_block.render text_block
+;;
diff --git a/skeleton/skeleton.mli b/skeleton/skeleton.mli
new file mode 100644
index 0000000..8dd1015
--- /dev/null
+++ b/skeleton/skeleton.mli
@@ -0,0 +1,29 @@
+open! Core
+module Node_id = Incremental.For_analyzer.Node_id
+module Dot_user_info = Incremental.For_analyzer.Dot_user_info
+
+(* Structure for extracting desired information out of an [Incr] graph, to be used for
+   further analysis/filtering/visualization *)
+
+type t =
+  { nodes : Node.t list
+  ; seen : Node_id.Set.t
+  ; num_stabilizes : int
+  }
+[@@deriving sexp]
+
+module Render_target : sig
+  type t =
+    | Dot
+    | Graph_easy
+end
+
+val snapshot : ?normalize:bool -> _ Incremental.State.t -> t
+
+val to_dot
+  :  ?extra_attrs:(Node.t -> Dot_user_info.t option)
+  -> ?render_target:Render_target.t
+  -> ?filtered_nodes:Node.t list
+  -> ?render_relation:Render_relation.t
+  -> t
+  -> string
diff --git a/src/adjust_heights_heap.ml b/src/adjust_heights_heap.ml
index 449e46e..6477044 100644
--- a/src/adjust_heights_heap.ml
+++ b/src/adjust_heights_heap.ml
@@ -3,8 +3,8 @@ open Import
 open Types.Kind
 
 module As_adjust_heights_list = Node.Packed.As_list (struct
-  let next (Node.Packed.T node) = node.next_in_adjust_heights_heap
-end)
+    let next (Node.Packed.T node) = node.next_in_adjust_heights_heap
+  end)
 
 module Nodes_by_height = struct
   type t = As_adjust_heights_list.t Uniform_array.t [@@deriving sexp_of]
diff --git a/src/dot_user_info.ml b/src/dot_user_info.ml
index 31319d9..fb077d7 100644
--- a/src/dot_user_info.ml
+++ b/src/dot_user_info.ml
@@ -67,7 +67,7 @@ let to_string ?(shape = "Mrecord") ~name { label; attributes } =
     label
     |> Set.to_list
     |> List.map ~f:(fun cols ->
-         "{" ^ String.concat (List.map cols ~f:escape_record_label) ~sep:"|" ^ "}")
+      "{" ^ String.concat (List.map cols ~f:escape_record_label) ~sep:"|" ^ "}")
     |> String.concat ~sep:"|"
     |> fun s -> "{" ^ s ^ "}"
   in
@@ -75,7 +75,7 @@ let to_string ?(shape = "Mrecord") ~name { label; attributes } =
     attributes
     |> Map.to_alist
     |> List.map ~f:(fun (k, v) ->
-         sprintf {| %s=%s|} (escape_dot_string k) (escape_dot_string v))
+      sprintf {| %s=%s|} (escape_dot_string k) (escape_dot_string v))
     |> String.concat ~sep:" "
   in
   sprintf {|  %s [shape=%s label=%s %s]|} name shape (escape_dot_string label) attributes
diff --git a/src/incremental.ml b/src/incremental.ml
index 7ad55d1..9598b33 100644
--- a/src/incremental.ml
+++ b/src/incremental.ml
@@ -408,10 +408,10 @@ module Make () = Make_with_config (Config.Default ()) ()
 include Generic
 
 module Add_witness0 (M : sig
-  type t [@@deriving sexp_of]
+    type t [@@deriving sexp_of]
 
-  include Invariant.S with type t := t
-end) : sig
+    include Invariant.S with type t := t
+  end) : sig
   type 'w t = M.t [@@deriving sexp_of]
 
   include Invariant.S1 with type 'a t := 'a t
@@ -423,10 +423,10 @@ end = struct
 end
 
 module Add_witness1 (M : sig
-  type 'a t [@@deriving sexp_of]
+    type 'a t [@@deriving sexp_of]
 
-  include Invariant.S1 with type 'a t := 'a t
-end) : sig
+    include Invariant.S1 with type 'a t := 'a t
+  end) : sig
   type ('a, 'w) t = 'a M.t [@@deriving sexp_of]
 
   include Invariant.S2 with type ('a, 'b) t := ('a, 'b) t
@@ -449,20 +449,20 @@ module Expert = struct
     include Dependency
 
     include Add_witness1 (struct
-      include Dependency
+        include Dependency
 
-      let invariant _ _ = ()
-    end)
+        let invariant _ _ = ()
+      end)
   end
 
   module Node = struct
     include Node
 
     include Add_witness1 (struct
-      include Node
+        include Node
 
-      let invariant _ _ = ()
-    end)
+        let invariant _ _ = ()
+      end)
   end
 
   module Step_result = State.Step_result
@@ -505,23 +505,23 @@ module type S = sig
 
   include
     S_gen
-      with type 'a t = ('a, state_witness) incremental
-      with type Before_or_after.t = Before_or_after.t
-      with type Clock.t = state_witness Clock.t
-      with type 'a Cutoff.t = 'a Cutoff.t
-      with type 'a Expert.Dependency.t = ('a, state_witness) Expert.Dependency.t
-      with type 'a Expert.Node.t = ('a, state_witness) Expert.Node.t
-      with type Expert.Step_result.t = Expert.Step_result.t
-      with type 'a Observer.t = ('a, state_witness) Observer.t
-      with type 'a Observer.Update.t = 'a Observer.Update.t
-      with type Packed.t = Packed.t
-      with type Scope.t = state_witness Scope.t
-      with type State.t = state_witness State.t
-      with type State.Stats.t = State.Stats.t
-      with type ('a, 'b) Unordered_array_fold_update.t =
-        ('a, 'b) Unordered_array_fold_update.t
-      with type 'a Update.t = 'a Update.t
-      with type 'a Var.t = ('a, state_witness) Var.t
+    with type 'a t = ('a, state_witness) incremental
+    with type Before_or_after.t = Before_or_after.t
+    with type Clock.t = state_witness Clock.t
+    with type 'a Cutoff.t = 'a Cutoff.t
+    with type 'a Expert.Dependency.t = ('a, state_witness) Expert.Dependency.t
+    with type 'a Expert.Node.t = ('a, state_witness) Expert.Node.t
+    with type Expert.Step_result.t = Expert.Step_result.t
+    with type 'a Observer.t = ('a, state_witness) Observer.t
+    with type 'a Observer.Update.t = 'a Observer.Update.t
+    with type Packed.t = Packed.t
+    with type Scope.t = state_witness Scope.t
+    with type State.t = state_witness State.t
+    with type State.Stats.t = State.Stats.t
+    with type ('a, 'b) Unordered_array_fold_update.t =
+      ('a, 'b) Unordered_array_fold_update.t
+    with type 'a Update.t = 'a Update.t
+    with type 'a Var.t = ('a, state_witness) Var.t
 end
 
 module Private = struct
diff --git a/src/incremental_intf.ml b/src/incremental_intf.ml
index 8ffd90c..c1286ab 100644
--- a/src/incremental_intf.ml
+++ b/src/incremental_intf.ml
@@ -220,9 +220,9 @@
     So, all necessary nodes are kept alive, from the perspective of the garbage collector.
 
     If an observer has no on-update handlers and user code no longer holds on to it,
-    incremental (via a finalizer on the observer), detects this and disallows future use
-    of the observer, making the node it observed unnecessary if it is not necessary for
-    another reason.  One can eagerly remove an observer by calling [disallow_future_use].
+    incremental (via a finalizer on the observer) detects this and disallows future use of
+    the observer, making the node it observed unnecessary if it is not necessary for
+    another reason. One can eagerly remove an observer by calling [disallow_future_use].
     Because finalizers may be called much later than when an observer actually becomes
     unreachable, it is preferable to disable observers using [disallow_future_use] to
     avoid useless propagation during stabilizations.
@@ -1066,7 +1066,9 @@ module type Incremental = sig
         finalization). *)
     val num_active_observers : _ t -> int
 
-    (** {2 constant-time stats} These are counters that are constant time to read, and
+    (** {2 constant-time stats}
+
+        These are counters that are constant time to read, and
         that are automatically updated in the ordinary course.  *)
 
     val max_height_seen : _ t -> int
@@ -1968,23 +1970,23 @@ module type Incremental = sig
 
     include
       S_gen
-        with type 'a t = ('a, state_witness) incremental
-        with type Before_or_after.t = Before_or_after.t
-        with type Clock.t = state_witness Clock.t
-        with type 'a Cutoff.t = 'a Cutoff.t
-        with type 'a Expert.Dependency.t = ('a, state_witness) Expert.Dependency.t
-        with type 'a Expert.Node.t = ('a, state_witness) Expert.Node.t
-        with type Expert.Step_result.t = Expert.Step_result.t
-        with type 'a Observer.t = ('a, state_witness) Observer.t
-        with type 'a Observer.Update.t = 'a Observer.Update.t
-        with type Packed.t = Packed.t
-        with type Scope.t = state_witness Scope.t
-        with type State.t = state_witness State.t
-        with type State.Stats.t = State.Stats.t
-        with type ('a, 'b) Unordered_array_fold_update.t =
-          ('a, 'b) Unordered_array_fold_update.t
-        with type 'a Update.t = 'a Update.t
-        with type 'a Var.t = ('a, state_witness) Var.t
+      with type 'a t = ('a, state_witness) incremental
+      with type Before_or_after.t = Before_or_after.t
+      with type Clock.t = state_witness Clock.t
+      with type 'a Cutoff.t = 'a Cutoff.t
+      with type 'a Expert.Dependency.t = ('a, state_witness) Expert.Dependency.t
+      with type 'a Expert.Node.t = ('a, state_witness) Expert.Node.t
+      with type Expert.Step_result.t = Expert.Step_result.t
+      with type 'a Observer.t = ('a, state_witness) Observer.t
+      with type 'a Observer.Update.t = 'a Observer.Update.t
+      with type Packed.t = Packed.t
+      with type Scope.t = state_witness Scope.t
+      with type State.t = state_witness State.t
+      with type State.Stats.t = State.Stats.t
+      with type ('a, 'b) Unordered_array_fold_update.t =
+        ('a, 'b) Unordered_array_fold_update.t
+      with type 'a Update.t = 'a Update.t
+      with type 'a Var.t = ('a, state_witness) Var.t
   end
 
   (** [Make] returns a new incremental implementation.  [Make] uses [Config.Default
diff --git a/src/internal_observer.ml b/src/internal_observer.ml
index e10fdd2..2a8b8db 100644
--- a/src/internal_observer.ml
+++ b/src/internal_observer.ml
@@ -163,7 +163,7 @@ let unlink_from_observing t =
   let observing = t.observing in
   if phys_equal t (Uopt.value_exn observing.observers) then observing.observers <- next;
   observing.num_on_update_handlers
-    <- observing.num_on_update_handlers - List.length t.on_update_handlers;
+  <- observing.num_on_update_handlers - List.length t.on_update_handlers;
   t.on_update_handlers <- []
 ;;
 
diff --git a/src/node.ml b/src/node.ml
index b11aecc..8577d76 100644
--- a/src/node.ml
+++ b/src/node.ml
@@ -115,17 +115,17 @@ let user_info t =
 
 let set_user_info t info =
   t.user_info
-    <- (match info with
-        | None -> None
-        | Some i -> Some (Info i))
+  <- (match info with
+      | None -> None
+      | Some i -> Some (Info i))
 ;;
 
 let append_user_info_graphviz t ~label ~attrs =
   let new_ = Dot_user_info.dot ~label ~attributes:attrs in
   t.user_info
-    <- (match t.user_info with
-        | None -> Some new_
-        | Some other -> Some (Dot_user_info.append other new_))
+  <- (match t.user_info with
+      | None -> Some new_
+      | Some other -> Some (Dot_user_info.append other new_))
 ;;
 
 let edge_is_stale ~child ~parent =
@@ -330,7 +330,7 @@ let invariant (type a) (invariant_a : a -> unit) (t : a t) =
               ~expect:
                 (List.length t.on_update_handlers
                  + fold_observers t ~init:0 ~f:(fun n { on_update_handlers; _ } ->
-                     n + List.length on_update_handlers))))
+                   n + List.length on_update_handlers))))
       ~num_parents:
         (check (fun num_parents ->
            assert (num_parents >= 0);
@@ -491,7 +491,7 @@ let run_on_update_handlers t node_update ~now =
 let set_kind t kind =
   t.kind <- kind;
   t.my_parent_index_in_child_at_index
-    <- Array.create ~len:(Kind.initial_num_children kind) (-1)
+  <- Array.create ~len:(Kind.initial_num_children kind) (-1)
 ;;
 
 let create state created_in kind =
@@ -543,9 +543,9 @@ let make_space_for_parent_if_necessary t =
   then (
     let new_max_num_parents = 2 * max_num_parents t in
     t.parent1_and_beyond
-      <- Uniform_array.realloc t.parent1_and_beyond ~len:(new_max_num_parents - 1);
+    <- Uniform_array.realloc t.parent1_and_beyond ~len:(new_max_num_parents - 1);
     t.my_child_index_in_parent_at_index
-      <- Array.realloc t.my_child_index_in_parent_at_index ~len:new_max_num_parents (-1));
+    <- Array.realloc t.my_child_index_in_parent_at_index ~len:new_max_num_parents (-1));
   if debug then assert (t.num_parents < max_num_parents t)
 ;;
 
@@ -556,7 +556,7 @@ let make_space_for_child_if_necessary t ~child_index =
     if debug then assert (child_index = max_num_children);
     let new_max_num_children = Int.max 2 (2 * max_num_children) in
     t.my_parent_index_in_child_at_index
-      <- Array.realloc t.my_parent_index_in_child_at_index ~len:new_max_num_children (-1));
+    <- Array.realloc t.my_parent_index_in_child_at_index ~len:new_max_num_children (-1));
   if debug then assert (child_index < Array.length t.my_parent_index_in_child_at_index)
 ;;
 
@@ -646,8 +646,8 @@ module Packed = struct
   let invariant (T t) = invariant ignore t
 
   module As_list (M : sig
-    val next : Packed.t -> Packed.t Uopt.t
-  end) =
+      val next : Packed.t -> Packed.t Uopt.t
+    end) =
   struct
     type t = Packed.t Uopt.t
 
diff --git a/src/node.mli b/src/node.mli
index 1a885b5..2278ab2 100644
--- a/src/node.mli
+++ b/src/node.mli
@@ -36,8 +36,8 @@ module Packed : sig
       contained within it.  The recompute heap uses this with [next_in_recompute_heap],
       and the adjust-heights heap uses this with [next_in_adjust_heights_heap]. *)
   module As_list (M : sig
-    val next : t -> t Uopt.t
-  end) : sig
+      val next : t -> t Uopt.t
+    end) : sig
     type t = Types.Node.Packed.t Uopt.t [@@deriving sexp_of]
 
     include Invariant.S with type t := t
diff --git a/src/node_to_dot.ml b/src/node_to_dot.ml
index 6866fae..6cc2444 100644
--- a/src/node_to_dot.ml
+++ b/src/node_to_dot.ml
@@ -36,14 +36,14 @@ let save_dot ~emit_bind_edges out ts =
         ~recomputed_at:_
         ~changed_at:_
         ~height
-        ->
-    let name = node_name id in
-    Hash_set.add seen id;
-    print_node out ~name ~kind ~height ~user_info;
-    List.iter children ~f:(fun child_id ->
-      fprintf out "  %s -> %s\n" (node_name child_id) name);
-    List.iter bind_children ~f:(fun bind_child_id ->
-      bind_edges := (bind_child_id, id) :: !bind_edges));
+      ->
+      let name = node_name id in
+      Hash_set.add seen id;
+      print_node out ~name ~kind ~height ~user_info;
+      List.iter children ~f:(fun child_id ->
+        fprintf out "  %s -> %s\n" (node_name child_id) name);
+      List.iter bind_children ~f:(fun bind_child_id ->
+        bind_edges := (bind_child_id, id) :: !bind_edges));
   if emit_bind_edges
   then
     List.iter !bind_edges ~f:(fun (bind_child_id, id) ->
diff --git a/src/on_update_handler.ml b/src/on_update_handler.ml
index de624e0..4bc5830 100644
--- a/src/on_update_handler.ml
+++ b/src/on_update_handler.ml
@@ -31,11 +31,11 @@ let create f ~at:created_at = { f; previous_update_kind = Never_been_updated; cr
 
 let really_run t (node_update : _ Node_update.t) =
   t.previous_update_kind
-    <- (match node_update with
-        | Necessary _ -> Necessary
-        | Changed _ -> Changed
-        | Invalidated -> Invalidated
-        | Unnecessary -> Unnecessary);
+  <- (match node_update with
+      | Necessary _ -> Necessary
+      | Changed _ -> Changed
+      | Invalidated -> Invalidated
+      | Unnecessary -> Unnecessary);
   t.f node_update
 ;;
 
diff --git a/src/recompute_heap.ml b/src/recompute_heap.ml
index 1bc5196..ddf4a77 100644
--- a/src/recompute_heap.ml
+++ b/src/recompute_heap.ml
@@ -2,8 +2,8 @@ open Core
 open Import
 
 module As_recompute_list = Node.Packed.As_list (struct
-  let next (Node.Packed.T node) = node.next_in_recompute_heap
-end)
+    let next (Node.Packed.T node) = node.next_in_recompute_heap
+  end)
 
 module Nodes_by_height = struct
   type t = As_recompute_list.t Uniform_array.t [@@deriving sexp_of]
diff --git a/src/state.ml b/src/state.ml
index 4f73c6f..d980768 100644
--- a/src/state.ml
+++ b/src/state.ml
@@ -1105,7 +1105,7 @@ and maybe_change_value : type a. a Node.t -> a -> unit =
         if can_recompute_now
         then (
           t.num_nodes_recomputed_directly_because_one_child
-            <- t.num_nodes_recomputed_directly_because_one_child + 1;
+          <- t.num_nodes_recomputed_directly_because_one_child + 1;
           recompute parent)
         else if parent.height <= Recompute_heap.min_height t.recompute_heap
         then (
@@ -1114,7 +1114,7 @@ and maybe_change_value : type a. a Node.t -> a -> unit =
              [parent] immediately and save adding it to and then removing it from the
              recompute heap. *)
           t.num_nodes_recomputed_directly_because_min_height
-            <- t.num_nodes_recomputed_directly_because_min_height + 1;
+          <- t.num_nodes_recomputed_directly_because_min_height + 1;
           recompute parent)
         else (
           if debug then assert (Node.needs_to_be_computed parent);
@@ -1169,11 +1169,13 @@ let disallow_future_use internal_observer =
 ;;
 
 let disallow_finalized_observers t =
-  while Thread_safe_queue.length t.finalized_observers > 0 do
-    let (T internal_observer) = Thread_safe_queue.dequeue_exn t.finalized_observers in
+  let disallow_if_finalized (Internal_observer.Packed.T internal_observer) =
     if List.is_empty internal_observer.on_update_handlers
     then disallow_future_use internal_observer
-  done
+  in
+  Thread_safe_queue.dequeue_until_empty
+    ~f:disallow_if_finalized
+    t.finalized_observers [@nontail]
 ;;
 
 let observer_finalizer t =
@@ -1221,8 +1223,8 @@ let add_new_observers t =
       let observing = internal_observer.observing in
       let was_necessary = Node.is_necessary observing in
       observing.num_on_update_handlers
-        <- observing.num_on_update_handlers
-           + List.length internal_observer.on_update_handlers;
+      <- observing.num_on_update_handlers
+         + List.length internal_observer.on_update_handlers;
       let old_observers = observing.observers in
       if Uopt.is_some old_observers
       then (
@@ -1300,10 +1302,10 @@ let set_var var value =
 ;;
 
 let reclaim_space_in_weak_hashtbls t =
-  while Thread_safe_queue.length t.weak_hashtbls > 0 do
-    let (T weak_hashtbl) = Thread_safe_queue.dequeue_exn t.weak_hashtbls in
+  let reclaim (Packed_weak_hashtbl.T weak_hashtbl) =
     Weak_hashtbl.reclaim_space_for_keys_with_unused_data weak_hashtbl
-  done
+  in
+  Thread_safe_queue.dequeue_until_empty ~f:reclaim t.weak_hashtbls [@nontail]
 ;;
 
 let stabilize_start t =
@@ -1804,10 +1806,10 @@ let at_intervals (clock : Clock.t) interval =
      recomputed. *)
   Node.set_cutoff main Cutoff.never;
   at_intervals.alarm
-    <- add_alarm
-         clock
-         ~at:(next_interval_alarm_strict clock ~base ~interval)
-         (Alarm_value.create (At_intervals at_intervals));
+  <- add_alarm
+       clock
+       ~at:(next_interval_alarm_strict clock ~base ~interval)
+       (Alarm_value.create (At_intervals at_intervals));
   main
 ;;
 
@@ -1879,10 +1881,10 @@ let advance_clock (clock : Clock.t) ~to_ =
         if Node.is_valid main
         then (
           at_intervals.alarm
-            <- add_alarm
-                 clock
-                 ~at:(next_interval_alarm_strict clock ~base ~interval)
-                 alarm_value;
+          <- add_alarm
+               clock
+               ~at:(next_interval_alarm_strict clock ~base ~interval)
+               alarm_value;
           make_stale main)
       | Snapshot { main; value_at; _ } ->
         if debug then assert (Node.is_valid main);
@@ -1986,7 +1988,7 @@ module Expert = struct
       if Option.is_some state.only_in_debug.currently_running_node
       then
         state.only_in_debug.expert_nodes_created_by_current_node
-          <- T node :: state.only_in_debug.expert_nodes_created_by_current_node;
+        <- T node :: state.only_in_debug.expert_nodes_created_by_current_node;
     node
   ;;
 
diff --git a/src/unordered_array_fold.ml b/src/unordered_array_fold.ml
index fe9fa84..41a8959 100644
--- a/src/unordered_array_fold.ml
+++ b/src/unordered_array_fold.ml
@@ -126,11 +126,11 @@ let child_changed
       (* We only reach this case if we have already done a full compute, in which case
          [Uopt.is_some t.fold_value] and [Uopt.is_some old_value_opt]. *)
       t.fold_value
-        <- Uopt.some
-             (t.update
-                (Uopt.value_exn t.fold_value)
-                ~old_value:(Uopt.value_exn old_value_opt)
-                ~new_value))
+      <- Uopt.some
+           (t.update
+              (Uopt.value_exn t.fold_value)
+              ~old_value:(Uopt.value_exn old_value_opt)
+              ~new_value))
     else if t.num_changes_since_last_full_compute < t.full_compute_every_n_changes
     then force_full_compute t
 ;;
diff --git a/step_function/test/dune b/step_function/test/dune
index 2ab281c..0b6b902 100644
--- a/step_function/test/dune
+++ b/step_function/test/dune
@@ -1,6 +1,6 @@
 (library
  (name incremental_step_function_test)
- (libraries expect_test_helpers_core.expect_test_helpers_base
+ (libraries core expect_test_helpers_core.expect_test_helpers_base
    incremental_step_function)
  (preprocess
   (pps ppx_jane)))
diff --git a/step_function/test/test_step_function.ml b/step_function/test/test_step_function.ml
index cd6b626..ec6ffe7 100644
--- a/step_function/test/test_step_function.ml
+++ b/step_function/test/test_step_function.ml
@@ -30,7 +30,7 @@ let%expect_test "empty [~steps] is same as constant" =
 ;;
 
 let%expect_test "[create_exn] raise" =
-  require_does_raise [%here] ~hide_positions:true (fun () ->
+  require_does_raise ~hide_positions:true (fun () ->
     create_exn ~init:13 ~steps:[ 1, 14; 0, 15 ]);
   [%expect
     {|
diff --git a/test-debug/dune b/test-debug/dune
index cee55b5..cdadb61 100644
--- a/test-debug/dune
+++ b/test-debug/dune
@@ -1,7 +1,9 @@
 (library
  (name incremental_debug_test)
- (libraries core expect_test_helpers_core incremental incremental_debug
-   core_unix.time_ns_unix)
+ (libraries core core_unix expect_test_helpers_core.expect_test_helpers_base
+   expect_test_helpers_core patdiff.expect_test_patdiff expect_test_graphviz
+   expect_test_sexp_diff incremental incremental_skeleton incremental_debug
+   core_unix.time_ns_unix core_kernel.timing_wheel)
  (flags :standard -w -60)
  (preprocess
   (pps ppx_jane)))
@@ -10,7 +12,8 @@
  (targets import.ml test_config.ml test_config.mli test_for_analyzer.ml
    test_for_analyzer.mli test_generics.ml test_generics.mli
    test_incremental.ml test_incremental.mli test_exceptional_behavior.ml
-   test_exceptional_behavior.mli test_let_syntax.ml test_let_syntax.mli)
+   test_exceptional_behavior.mli test_let_syntax.ml test_let_syntax.mli
+   test_skeleton.ml test_skeleton.mli)
  (deps
   (:first_dep generate_debug_test_lib.sh)
   (glob_files ../test/*.ml)
diff --git a/test/dune b/test/dune
index adb255d..05d6b7d 100644
--- a/test/dune
+++ b/test/dune
@@ -1,5 +1,8 @@
 (library
  (name incremental_test)
- (libraries core expect_test_helpers_core incremental core_unix.time_ns_unix)
+ (libraries core core_unix expect_test_helpers_core.expect_test_helpers_base
+   expect_test_helpers_core patdiff.expect_test_patdiff expect_test_graphviz
+   expect_test_sexp_diff incremental incremental_skeleton
+   core_unix.time_ns_unix core_kernel.timing_wheel)
  (preprocess
   (pps ppx_jane)))
diff --git a/test/test_config.ml b/test/test_config.ml
index 11a08fa..aa01275 100644
--- a/test/test_config.ml
+++ b/test/test_config.ml
@@ -5,7 +5,7 @@ let%expect_test "default timing-wheel precision and level durations" =
   let module I = Incremental.Make () in
   let config = I.Clock.default_timing_wheel_config in
   let durations = Timing_wheel.Config.durations config in
-  require [%here] (Time_ns.Span.( >= ) (List.last_exn durations) Time_ns.Span.day);
+  require (Time_ns.Span.( >= ) (List.last_exn durations) Time_ns.Span.day);
   print_s
     [%message
       ""
diff --git a/test/test_exceptional_behavior.ml b/test/test_exceptional_behavior.ml
index 095dbe2..8d31de5 100644
--- a/test/test_exceptional_behavior.ml
+++ b/test/test_exceptional_behavior.ml
@@ -16,17 +16,17 @@ let require_does_raise here f =
   Expect_test_helpers_base.require_does_raise
     ~show_backtrace:true
     ~hide_positions:false
-    here
+    ~here
     f;
   (* check it to see that our function is in the backtrace, but don't print *)
-  let with_backtrace = Expect_test_helpers_base.expect_test_output [%here] in
+  let with_backtrace = Expect_test_helpers_base.expect_test_output () in
   if not (String.is_substring with_backtrace ~substring:"my_function_that_fails")
   then print_endline with_backtrace;
   (* re-run the function, this time just printing the message *)
   Expect_test_helpers_base.require_does_raise
     ~show_backtrace:false
     ~hide_positions:true
-    here
+    ~here
     f
 ;;
 
diff --git a/test/test_for_analyzer.ml b/test/test_for_analyzer.ml
index c2ca112..a0eddb3 100644
--- a/test/test_for_analyzer.ml
+++ b/test/test_for_analyzer.ml
@@ -29,8 +29,8 @@ let print_nodes node_list pack output_node =
         ~recomputed_at
         ~changed_at
         ~height
-        ->
-    nodes
+      ->
+      nodes
       := { id; kind; cutoff; children; bind_children; recomputed_at; changed_at; height }
          :: !nodes);
   let min_id_opt =
diff --git a/test/test_incremental.ml b/test/test_incremental.ml
index 691c1ad..08eaccf 100644
--- a/test/test_incremental.ml
+++ b/test/test_incremental.ml
@@ -11,8 +11,8 @@ module Alarm_precision = Timing_wheel.Alarm_precision
 let does_raise = Exn.does_raise
 
 module Test (M : sig
-  val bind_lhs_change_should_invalidate_rhs : bool
-end) =
+    val bind_lhs_change_should_invalidate_rhs : bool
+  end) =
 struct
   let check_invalidity = M.bind_lhs_change_should_invalidate_rhs
   let skip_invalidity_check = not check_invalidity
@@ -52,8 +52,8 @@ struct
     ;;
 
     module On_update_queue (Update : sig
-      type 'a t [@@deriving compare, sexp_of]
-    end) =
+        type 'a t [@@deriving compare, sexp_of]
+      end) =
     struct
       let on_update_queue () =
         let r = ref [] in
@@ -93,990 +93,1121 @@ struct
       open I
 
       include (
-        struct
-          type nonrec state_witness = state_witness [@@deriving sexp_of]
-          type nonrec 'a t = 'a t
-
-          module Infix = Infix
-          module Before_or_after = Before_or_after
-          module Node_value = Node_value
-          module Step_function = Step_function
-
-          let invariant = invariant
-          let stabilize = stabilize
-
-          (* used in lots of tests *)
-          let observe = observe
-
-          (* *)
-          let user_info = user_info
-          let set_user_info = set_user_info
-          let append_user_info_graphviz = append_user_info_graphviz
-          let save_dot_to_file = save_dot_to_file
-          let save_dot = save_dot
-
-          module Update = Update
-          module Packed = Packed
-
-          let pack = pack
-
-          module Let_syntax = Let_syntax
-
-          module State = struct
-            open State
-
-            type nonrec t = t [@@deriving sexp_of]
-
-            let invariant = invariant
-            let t = t
-            let%expect_test _ = invariant t
-            let max_height_allowed = max_height_allowed
-
-            (* the default *)
-            let%test _ = max_height_allowed t = 128
-            let max_height_seen = max_height_seen
-
-            (* because of [let invalid] above *)
-            let%test _ = max_height_seen t = 3
-            let set_max_height_allowed = set_max_height_allowed
+      struct
+        type nonrec state_witness = state_witness [@@deriving sexp_of]
+        type nonrec 'a t = 'a t
 
-            let%expect_test _ =
-              List.iter [ -1; 2 ] ~f:(fun height ->
-                assert (does_raise (fun () -> set_max_height_allowed t height)))
-            ;;
-
-            let%expect_test _ = set_max_height_allowed t 10
-            let%test _ = max_height_allowed t = 10
-            let%expect_test _ = set_max_height_allowed t 128
-
-            let%expect_test _ =
-              set_max_height_allowed t 256;
-              let rec loop n =
-                if n = 0 then return 0 else loop (n - 1) >>| fun i -> i + 1
-              in
-              let o = observe (loop (max_height_allowed t)) in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = max_height_allowed t)
-            ;;
+        module Infix = Infix
+        module Before_or_after = Before_or_after
+        module Node_value = Node_value
+        module Step_function = Step_function
 
-            let%test _ = max_height_allowed t = max_height_seen t
-            let%expect_test _ = invariant t
-            let num_active_observers = num_active_observers
-
-            let%expect_test _ =
-              Gc.full_major ();
-              stabilize_ [%here];
-              let n = num_active_observers t in
-              let o = observe (const 0) in
-              disallow_future_use o;
-              [%test_result: int] (num_active_observers t) ~expect:n
-            ;;
+        let invariant = invariant
+        let stabilize = stabilize
 
-            let%expect_test _ =
-              Gc.full_major ();
-              stabilize_ [%here];
-              let n = num_active_observers t in
-              let o = observe (const 0) in
-              stabilize_ [%here];
-              [%test_result: int] (num_active_observers t) ~expect:(n + 1);
-              disallow_future_use o;
-              [%test_result: int] (num_active_observers t) ~expect:n;
-              stabilize_ [%here];
-              [%test_result: int] (num_active_observers t) ~expect:n
-            ;;
+        (* used in lots of tests *)
+        let observe = observe
 
-            let%expect_test _ =
-              (* [observe ~should_finalize:true] *)
-              Gc.full_major ();
-              stabilize_ [%here];
-              let _o = observe (const 13) ~should_finalize:true in
-              stabilize_ [%here];
-              let n = num_active_observers t in
-              Gc.full_major ();
-              stabilize_ [%here];
-              [%test_result: int] (num_active_observers t) ~expect:(n - 1)
-            ;;
+        (* *)
+        let user_info = user_info
+        let set_user_info = set_user_info
+        let append_user_info_graphviz = append_user_info_graphviz
+        let save_dot_to_file = save_dot_to_file
+        let save_dot = save_dot
 
-            let%expect_test _ =
-              (* [observe ~should_finalize:false] *)
-              Gc.full_major ();
-              stabilize_ [%here];
-              let _o = observe (const 13) ~should_finalize:false in
-              stabilize_ [%here];
-              let n = num_active_observers t in
-              Gc.full_major ();
-              stabilize_ [%here];
-              [%test_result: int] (num_active_observers t) ~expect:n
-            ;;
+        module Update = Update
+        module Packed = Packed
 
-            let keep_node_creation_backtrace = keep_node_creation_backtrace
-            let set_keep_node_creation_backtrace = set_keep_node_creation_backtrace
-            let num_nodes_became_necessary = num_nodes_became_necessary
-            let num_nodes_became_unnecessary = num_nodes_became_unnecessary
-            let num_nodes_changed = num_nodes_changed
-            let num_nodes_created = num_nodes_created
-            let num_nodes_invalidated = num_nodes_invalidated
-            let num_nodes_recomputed = num_nodes_recomputed
-            let num_stabilizes = num_stabilizes
-            let num_var_sets = num_var_sets
-
-            let num_nodes_recomputed_directly_because_min_height =
-              num_nodes_recomputed_directly_because_min_height
-            ;;
+        let pack = pack
 
-            let%expect_test _ =
-              let var = Var.create 1 in
-              let o =
-                observe
-                  (map2
-                     (map2 (Var.watch var) (const 1) ~f:( + ))
-                     (map2 (const 2) (const 3) ~f:( + ))
-                     ~f:( + ))
-              in
-              stabilize_ [%here];
-              let stat1 = num_nodes_recomputed_directly_because_min_height t in
-              Var.set var 2;
-              stabilize_ [%here];
-              let stat2 = num_nodes_recomputed_directly_because_min_height t in
-              [%test_eq: int] (stat2 - stat1) 2;
-              disallow_future_use o
-            ;;
+        module Let_syntax = Let_syntax
 
-            let num_nodes_recomputed_directly_because_one_child =
-              num_nodes_recomputed_directly_because_one_child
-            ;;
+        module State = struct
+          open State
 
-            let%expect_test _ =
-              (* We can't use the same variable twice otherwise the optimization is not
-               applied. *)
-              let var1 = Var.create 1 in
-              let var2 = Var.create 1 in
-              let o var = observe (map (map (Var.watch var) ~f:Fn.id) ~f:Fn.id) in
-              let o1 = o var1 in
-              let o2 = o var2 in
-              stabilize_ [%here];
-              let stat1 = num_nodes_recomputed_directly_because_one_child t in
-              Var.set var1 2;
-              Var.set var2 2;
-              stabilize_ [%here];
-              let stat2 = num_nodes_recomputed_directly_because_one_child t in
-              [%test_result: int] (stat2 - stat1) ~expect:4;
-              disallow_future_use o1;
-              disallow_future_use o2
-            ;;
+          type nonrec t = t [@@deriving sexp_of]
 
-            module Stats = Stats
+          let invariant = invariant
+          let t = t
+          let%expect_test _ = invariant t
+          let max_height_allowed = max_height_allowed
 
-            let stats = stats
-          end
+          (* the default *)
+          let%test _ = max_height_allowed t = 128
+          let max_height_seen = max_height_seen
 
-          let sexp_of_t = sexp_of_t
+          (* because of [let invalid] above *)
+          let%test _ = max_height_seen t = 3
+          let set_max_height_allowed = set_max_height_allowed
 
           let%expect_test _ =
-            State.(invariant t);
-            let i = 13 in
-            let t = const i in
-            let o = observe t in
-            stabilize_ [%here];
-            [%test_eq: Sexp.t] (t |> [%sexp_of: int t]) (i |> [%sexp_of: int]);
-            disallow_future_use o
+            List.iter [ -1; 2 ] ~f:(fun height ->
+              assert (does_raise (fun () -> set_max_height_allowed t height)))
           ;;
 
-          let is_invalid t =
-            let o = observe t in
-            stabilize_ [%here];
-            let result = is_error (Observer.value o) in
-            disallow_future_use o;
-            skip_invalidity_check || result
-          ;;
+          let%expect_test _ = set_max_height_allowed t 10
+          let%test _ = max_height_allowed t = 10
+          let%expect_test _ = set_max_height_allowed t 128
 
-          let is_invalidated_on_bind_rhs (f : int -> _ t) =
-            let x = Var.create 13 in
-            let r = ref None in
-            let o1 =
-              observe
-                (Var.watch x
-                 >>= fun i ->
-                 r := Some (f i);
-                 return ())
+          let%expect_test _ =
+            set_max_height_allowed t 256;
+            let rec loop n =
+              if n = 0 then return 0 else loop (n - 1) >>| fun i -> i + 1
             in
+            let o = observe (loop (max_height_allowed t)) in
             stabilize_ [%here];
-            let t = Option.value_exn !r in
-            let o2 = observe t in
-            Var.set x 14;
-            stabilize_ [%here];
-            let result = is_invalid t in
-            disallow_future_use o1;
-            disallow_future_use o2;
-            result
-          ;;
-
-          let%test _ = is_invalid invalid
-          let is_valid = is_valid
-          let%test _ = is_valid (const 3)
-          let%test _ = skip_invalidity_check || not (is_valid invalid)
-          let const = const
-          let return = return
-          let is_const = is_const
-          let is_necessary = is_necessary
-
-          let%expect_test _ =
-            List.iter [ const; return ] ~f:(fun const ->
-              let i = const 13 in
-              assert (is_const i);
-              assert (not (is_necessary i));
-              let o = observe i in
-              assert (not (is_necessary i));
-              stabilize_ [%here];
-              assert (is_necessary i);
-              assert (value o = 13);
-              assert (is_const i))
+            assert (Observer.value_exn o = max_height_allowed t)
           ;;
 
-          let%test _ = is_invalidated_on_bind_rhs (fun _ -> const 13)
-
-          module Var = struct
-            open Var
-
-            type nonrec 'a t = 'a t [@@deriving sexp_of]
-
-            let create_ ?use_current_scope _where value = create ?use_current_scope value
-            let create = create
-            let latest_value = latest_value
-            let set = set
-            let value = value
-            let watch = watch
-            let replace = replace
-
-            let%expect_test _ =
-              (* observing a var after stabilization *)
-              let x = create_ [%here] 0 in
-              stabilize_ [%here];
-              let o = observe (watch x) in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 0)
-            ;;
-
-            let%expect_test _ =
-              (* observing a set var after stabilization *)
-              let x = create_ [%here] 0 in
-              set x 1;
-              stabilize_ [%here];
-              let o = observe (watch x) in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 1)
-            ;;
-
-            let%expect_test _ =
-              (* observing a replace var after stabilization *)
-              let x = create_ [%here] 0 in
-              replace x ~f:(( + ) 1);
-              stabilize_ [%here];
-              let o = observe (watch x) in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 1)
-            ;;
-
-            let%expect_test _ =
-              (* observing and setting var after stabilization *)
-              let x = create_ [%here] 0 in
-              stabilize_ [%here];
-              let o = observe (watch x) in
-              set x 1;
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 1)
-            ;;
-
-            let%expect_test _ =
-              (* [set] without stabilizing *)
-              let x = create_ [%here] 13 in
-              assert (value x = 13);
-              assert (latest_value x = 13);
-              let o = observe (watch x) in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 13);
-              set x 14;
-              assert (value x = 14);
-              assert (latest_value x = 14);
-              assert (Observer.value_exn o = 13)
-            ;;
-
-            let%expect_test _ =
-              (* [set] during stabilization *)
-              let v0 = create_ [%here] 0 in
-              let v1 = create_ [%here] 1 in
-              let v2 = create_ [%here] 2 in
-              let o0 = observe (watch v0) in
-              let o1 =
-                observe
-                  (watch v1
-                   >>| fun i ->
-                   let i0 = value v0 in
-                   set v0 i;
-                   assert (value v0 = i0);
-                   assert (latest_value v0 = i);
-                   let i2 = value v2 in
-                   set v2 i;
-                   assert (value v2 = i2);
-                   assert (latest_value v2 = i);
-                   i)
-              in
-              let o2 = observe (watch v2) in
-              let var_values_are i0 i1 i2 =
-                value v0 = i0 && value v1 = i1 && value v2 = i2
-              in
-              let observer_values_are i0 i1 i2 =
-                Observer.value_exn o0 = i0
-                && Observer.value_exn o1 = i1
-                && Observer.value_exn o2 = i2
-              in
-              assert (var_values_are 0 1 2);
-              stabilize_ [%here];
-              assert (observer_values_are 0 1 2);
-              assert (var_values_are 1 1 1);
-              stabilize_ [%here];
-              assert (observer_values_are 1 1 1);
-              assert (var_values_are 1 1 1);
-              set v1 13;
-              assert (observer_values_are 1 1 1);
-              assert (var_values_are 1 13 1);
-              stabilize_ [%here];
-              assert (observer_values_are 1 13 1);
-              assert (var_values_are 13 13 13);
-              stabilize_ [%here];
-              assert (observer_values_are 13 13 13);
-              assert (var_values_are 13 13 13)
-            ;;
-
-            let%expect_test _ =
-              (* [set] during stabilization gets the last value that was set *)
-              let x = create_ [%here] 0 in
-              let o =
-                observe
-                  (map (watch x) ~f:(fun v ->
-                     set x 1;
-                     set x 2;
-                     assert (latest_value x = 2);
-                     v))
-              in
-              stabilize_ [%here];
-              assert (value x = 2);
-              stabilize_ [%here];
-              [%test_result: int] (Observer.value_exn o) ~expect:2;
-              disallow_future_use o
-            ;;
-
-            let%expect_test _ =
-              (* [replace] during stabilization gets the latest value *)
-              let x = create_ [%here] 0 in
-              let o =
-                observe
-                  (map (watch x) ~f:(fun v ->
-                     set x 2;
-                     replace x ~f:(fun v ->
-                       assert (v = 2);
-                       v + 1);
-                     v))
-              in
-              stabilize_ [%here];
-              print_s [%sexp (value x : int)];
-              [%expect {| 3 |}];
-              print_s [%sexp (Observer.value_exn o : int)];
-              [%expect {| 0 |}];
-              stabilize_ [%here];
-              print_s [%sexp (Observer.value_exn o : int)];
-              [%expect {| 3 |}];
-              disallow_future_use o
-            ;;
-
-            let%expect_test _ =
-              (* [create] during stabilization *)
-              let o =
-                observe
-                  (bind (const 13) ~f:(fun i ->
-                     let v = create_ [%here] i in
-                     watch v))
-              in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 13)
-            ;;
-
-            let%expect_test _ =
-              (* [create] and [set] during stabilization *)
-              let o =
-                observe
-                  (bind (const 13) ~f:(fun i ->
-                     let v = create_ [%here] i in
-                     let t = watch v in
-                     set v 15;
-                     t))
-              in
-              stabilize_ [%here];
-              assert (Observer.value_exn o = 13)
-            ;;
-
-            let%expect_test _ =
-              (* maybe invalidating a variable *)
-              List.iter [ false; true ] ~f:(fun use_current_scope ->
-                let lhs = Var.create 0 in
-                let rhs = ref (const 0) in
-                let o =
-                  observe
-                    (bind (watch lhs) ~f:(fun i ->
-                       rhs := Var.watch (create_ [%here] ~use_current_scope i);
-                       !rhs))
-                in
-                stabilize_ [%here];
-                let rhs = !rhs in
-                assert (is_valid rhs);
-                set lhs 1;
-                stabilize_ [%here];
-                if check_invalidity
-                then [%test_result: bool] (not (is_valid rhs)) ~expect:use_current_scope;
-                assert (Observer.value_exn o = 1))
-            ;;
-          end
-
-          let am_stabilizing = am_stabilizing
-          let%test _ = not (am_stabilizing ())
+          let%test _ = max_height_allowed t = max_height_seen t
+          let%expect_test _ = invariant t
+          let num_active_observers = num_active_observers
 
           let%expect_test _ =
-            let x = Var.create_ [%here] 13 in
-            let o = observe (map (watch x) ~f:(fun _ -> assert (am_stabilizing ()))) in
+            Gc.full_major ();
             stabilize_ [%here];
-            disallow_future_use o
+            let n = num_active_observers t in
+            let o = observe (const 0) in
+            disallow_future_use o;
+            [%test_result: int] (num_active_observers t) ~expect:n
           ;;
 
-          let map = map
-          let map2 = map2
-          let map3 = map3
-          let map4 = map4
-          let map5 = map5
-          let map6 = map6
-          let map7 = map7
-          let map8 = map8
-          let map9 = map9
-          let map10 = map10
-          let map11 = map11
-          let map12 = map12
-          let map13 = map13
-          let map14 = map14
-          let map15 = map15
-          let ( >>| ) = ( >>| )
-
-          let test_map n (mapN : int t -> int t) =
-            let o = observe (mapN (const 1)) in
-            stabilize_ [%here];
-            assert (value o = n);
-            let x = Var.create_ [%here] 1 in
-            let o = observe (mapN (watch x)) in
+          let%expect_test _ =
+            Gc.full_major ();
             stabilize_ [%here];
-            assert (value o = n);
-            Var.set x 0;
+            let n = num_active_observers t in
+            let o = observe (const 0) in
             stabilize_ [%here];
-            assert (value o = 0);
-            Var.set x 2;
+            [%test_result: int] (num_active_observers t) ~expect:(n + 1);
+            disallow_future_use o;
+            [%test_result: int] (num_active_observers t) ~expect:n;
             stabilize_ [%here];
-            assert (value o = 2 * n);
-            assert (is_invalid (mapN invalid));
-            assert (is_invalidated_on_bind_rhs (fun i -> mapN (const i)))
+            [%test_result: int] (num_active_observers t) ~expect:n
           ;;
 
-          let%expect_test _ = test_map 1 (fun i -> i >>| fun a1 -> a1)
-          let%expect_test _ = test_map 1 (fun i -> map i ~f:(fun a1 -> a1))
-          let%expect_test _ = test_map 2 (fun i -> map2 i i ~f:(fun a1 a2 -> a1 + a2))
-
           let%expect_test _ =
-            test_map 3 (fun i -> map3 i i i ~f:(fun a1 a2 a3 -> a1 + a2 + a3))
+            (* [observe ~should_finalize:true] *)
+            Gc.full_major ();
+            stabilize_ [%here];
+            let _o = observe (const 13) ~should_finalize:true in
+            stabilize_ [%here];
+            let n = num_active_observers t in
+            Gc.full_major ();
+            stabilize_ [%here];
+            [%test_result: int] (num_active_observers t) ~expect:(n - 1)
           ;;
 
           let%expect_test _ =
-            test_map 4 (fun i -> map4 i i i i ~f:(fun a1 a2 a3 a4 -> a1 + a2 + a3 + a4))
+            (* [observe ~should_finalize:false] *)
+            Gc.full_major ();
+            stabilize_ [%here];
+            let _o = observe (const 13) ~should_finalize:false in
+            stabilize_ [%here];
+            let n = num_active_observers t in
+            Gc.full_major ();
+            stabilize_ [%here];
+            [%test_result: int] (num_active_observers t) ~expect:n
           ;;
 
-          let%expect_test _ =
-            test_map 5 (fun i ->
-              map5 i i i i i ~f:(fun a1 a2 a3 a4 a5 -> a1 + a2 + a3 + a4 + a5))
-          ;;
+          let keep_node_creation_backtrace = keep_node_creation_backtrace
+          let set_keep_node_creation_backtrace = set_keep_node_creation_backtrace
+          let num_nodes_became_necessary = num_nodes_became_necessary
+          let num_nodes_became_unnecessary = num_nodes_became_unnecessary
+          let num_nodes_changed = num_nodes_changed
+          let num_nodes_created = num_nodes_created
+          let num_nodes_invalidated = num_nodes_invalidated
+          let num_nodes_recomputed = num_nodes_recomputed
+          let num_stabilizes = num_stabilizes
+          let num_var_sets = num_var_sets
 
-          let%expect_test _ =
-            test_map 6 (fun i ->
-              map6 i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 -> a1 + a2 + a3 + a4 + a5 + a6))
+          let num_nodes_recomputed_directly_because_min_height =
+            num_nodes_recomputed_directly_because_min_height
           ;;
 
           let%expect_test _ =
-            test_map 7 (fun i ->
-              map7 i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 ->
-                a1 + a2 + a3 + a4 + a5 + a6 + a7))
+            let var = Var.create 1 in
+            let o =
+              observe
+                (map2
+                   (map2 (Var.watch var) (const 1) ~f:( + ))
+                   (map2 (const 2) (const 3) ~f:( + ))
+                   ~f:( + ))
+            in
+            stabilize_ [%here];
+            let stat1 = num_nodes_recomputed_directly_because_min_height t in
+            Var.set var 2;
+            stabilize_ [%here];
+            let stat2 = num_nodes_recomputed_directly_because_min_height t in
+            [%test_eq: int] (stat2 - stat1) 2;
+            disallow_future_use o
           ;;
 
-          let%expect_test _ =
-            test_map 8 (fun i ->
-              map8 i i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 a8 ->
-                a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8))
+          let num_nodes_recomputed_directly_because_one_child =
+            num_nodes_recomputed_directly_because_one_child
           ;;
 
           let%expect_test _ =
-            test_map 9 (fun i ->
-              map9 i i i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 a8 a9 ->
-                a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9))
+            (* We can't use the same variable twice otherwise the optimization is not
+               applied. *)
+            let var1 = Var.create 1 in
+            let var2 = Var.create 1 in
+            let o var = observe (map (map (Var.watch var) ~f:Fn.id) ~f:Fn.id) in
+            let o1 = o var1 in
+            let o2 = o var2 in
+            stabilize_ [%here];
+            let stat1 = num_nodes_recomputed_directly_because_one_child t in
+            Var.set var1 2;
+            Var.set var2 2;
+            stabilize_ [%here];
+            let stat2 = num_nodes_recomputed_directly_because_one_child t in
+            [%test_result: int] (stat2 - stat1) ~expect:4;
+            disallow_future_use o1;
+            disallow_future_use o2
           ;;
 
-          let%expect_test _ =
-            test_map 10 (fun i ->
-              map10 i i i i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 ->
-                a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10))
-          ;;
+          module Stats = Stats
+
+          let stats = stats
+        end
+
+        let sexp_of_t = sexp_of_t
+
+        let%expect_test _ =
+          State.(invariant t);
+          let i = 13 in
+          let t = const i in
+          let o = observe t in
+          stabilize_ [%here];
+          [%test_eq: Sexp.t] (t |> [%sexp_of: int t]) (i |> [%sexp_of: int]);
+          disallow_future_use o
+        ;;
+
+        let is_invalid t =
+          let o = observe t in
+          stabilize_ [%here];
+          let result = is_error (Observer.value o) in
+          disallow_future_use o;
+          skip_invalidity_check || result
+        ;;
+
+        let is_invalidated_on_bind_rhs (f : int -> _ t) =
+          let x = Var.create 13 in
+          let r = ref None in
+          let o1 =
+            observe
+              (Var.watch x
+               >>= fun i ->
+               r := Some (f i);
+               return ())
+          in
+          stabilize_ [%here];
+          let t = Option.value_exn !r in
+          let o2 = observe t in
+          Var.set x 14;
+          stabilize_ [%here];
+          let result = is_invalid t in
+          disallow_future_use o1;
+          disallow_future_use o2;
+          result
+        ;;
+
+        let%test _ = is_invalid invalid
+        let is_valid = is_valid
+        let%test _ = is_valid (const 3)
+        let%test _ = skip_invalidity_check || not (is_valid invalid)
+        let const = const
+        let return = return
+        let is_const = is_const
+        let is_necessary = is_necessary
+
+        let%expect_test _ =
+          List.iter [ const; return ] ~f:(fun const ->
+            let i = const 13 in
+            assert (is_const i);
+            assert (not (is_necessary i));
+            let o = observe i in
+            assert (not (is_necessary i));
+            stabilize_ [%here];
+            assert (is_necessary i);
+            assert (value o = 13);
+            assert (is_const i))
+        ;;
 
-          let%expect_test _ =
-            let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 =
-              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11
-            in
-            test_map 11 (fun i -> map11 i i i i i i i i i i i ~f)
-          ;;
+        let%test _ = is_invalidated_on_bind_rhs (fun _ -> const 13)
 
-          let%expect_test _ =
-            let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 =
-              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12
-            in
-            test_map 12 (fun i -> map12 i i i i i i i i i i i i ~f)
-          ;;
+        module Var = struct
+          open Var
 
-          let%expect_test _ =
-            let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 =
-              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13
-            in
-            test_map 13 (fun i -> map13 i i i i i i i i i i i i i ~f)
-          ;;
+          type nonrec 'a t = 'a t [@@deriving sexp_of]
 
-          let%expect_test _ =
-            let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 =
-              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14
-            in
-            test_map 14 (fun i -> map14 i i i i i i i i i i i i i i ~f)
-          ;;
+          let create_ ?use_current_scope _where value = create ?use_current_scope value
+          let create = create
+          let latest_value = latest_value
+          let set = set
+          let value = value
+          let watch = watch
+          let replace = replace
 
           let%expect_test _ =
-            let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 =
-              a1
-              + a2
-              + a3
-              + a4
-              + a5
-              + a6
-              + a7
-              + a8
-              + a9
-              + a10
-              + a11
-              + a12
-              + a13
-              + a14
-              + a15
-            in
-            test_map 15 (fun i -> map15 i i i i i i i i i i i i i i i ~f)
+            (* observing a var after stabilization *)
+            let x = create_ [%here] 0 in
+            stabilize_ [%here];
+            let o = observe (watch x) in
+            stabilize_ [%here];
+            assert (Observer.value_exn o = 0)
           ;;
 
           let%expect_test _ =
-            let x0 = Var.create_ [%here] 13 in
-            let o0 = observe (watch x0) in
-            let t1 = map (watch x0) ~f:(fun x -> x + 1) in
-            let t1_o = observe t1 in
+            (* observing a set var after stabilization *)
+            let x = create_ [%here] 0 in
+            set x 1;
             stabilize_ [%here];
-            assert (value t1_o = value o0 + 1);
-            Var.set x0 14;
+            let o = observe (watch x) in
             stabilize_ [%here];
-            assert (value t1_o = value o0 + 1);
-            let x1 = Var.create_ [%here] 15 in
-            let o1 = observe (watch x1) in
-            let t2 = map2 (watch x0) (watch x1) ~f:(fun x y -> x + y) in
-            let t2_o = observe t2 in
-            let t3 = map2 t1 t2 ~f:(fun x y -> x - y) in
-            let t3_o = observe t3 in
-            let check () =
-              stabilize_ [%here];
-              assert (value t1_o = value o0 + 1);
-              assert (value t2_o = value o0 + value o1);
-              assert (value t3_o = value t1_o - value t2_o)
-            in
-            check ();
-            Var.set x0 16;
-            check ();
-            Var.set x1 17;
-            check ();
-            Var.set x0 18;
-            Var.set x1 19;
-            check ()
+            assert (Observer.value_exn o = 1)
           ;;
 
           let%expect_test _ =
-            (* deep *)
-            let rec loop i t =
-              if i = 0 then t else loop (i - 1) (map t ~f:(fun x -> x + 1))
-            in
-            let x0 = Var.create_ [%here] 0 in
-            let n = 100 in
-            let o = observe (loop n (watch x0)) in
+            (* observing a replace var after stabilization *)
+            let x = create_ [%here] 0 in
+            replace x ~f:(( + ) 1);
             stabilize_ [%here];
-            assert (value o = n);
-            Var.set x0 1;
+            let o = observe (watch x) in
             stabilize_ [%here];
-            assert (value o = n + 1);
-            disallow_future_use o;
-            stabilize_ [%here]
+            assert (Observer.value_exn o = 1)
           ;;
 
-          let bind = bind
-          let ( >>= ) = ( >>= )
-
           let%expect_test _ =
-            (* [bind] of a constant *)
+            (* observing and setting var after stabilization *)
+            let x = create_ [%here] 0 in
             stabilize_ [%here];
-            let o = observe (const 13 >>= const) in
+            let o = observe (watch x) in
+            set x 1;
             stabilize_ [%here];
-            assert (value o = 13)
-          ;;
-
-          let%test _ =
-            is_invalidated_on_bind_rhs (fun i -> bind (const i) ~f:(fun _ -> const i))
+            assert (Observer.value_exn o = 1)
           ;;
 
           let%expect_test _ =
-            (* bind created with an invalid rhs *)
-            let o = observe (const () >>= fun () -> invalid) in
+            (* [set] without stabilizing *)
+            let x = create_ [%here] 13 in
+            assert (value x = 13);
+            assert (latest_value x = 13);
+            let o = observe (watch x) in
             stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+            assert (Observer.value_exn o = 13);
+            set x 14;
+            assert (value x = 14);
+            assert (latest_value x = 14);
+            assert (Observer.value_exn o = 13)
           ;;
 
           let%expect_test _ =
-            (* bind created with an rhs that becomes invalid *)
-            let b = Var.create true in
-            let o = observe (Var.watch b >>= fun b -> if b then const 13 else invalid) in
+            (* [set] during stabilization *)
+            let v0 = create_ [%here] 0 in
+            let v1 = create_ [%here] 1 in
+            let v2 = create_ [%here] 2 in
+            let o0 = observe (watch v0) in
+            let o1 =
+              observe
+                (watch v1
+                 >>| fun i ->
+                 let i0 = value v0 in
+                 set v0 i;
+                 assert (value v0 = i0);
+                 assert (latest_value v0 = i);
+                 let i2 = value v2 in
+                 set v2 i;
+                 assert (value v2 = i2);
+                 assert (latest_value v2 = i);
+                 i)
+            in
+            let o2 = observe (watch v2) in
+            let var_values_are i0 i1 i2 =
+              value v0 = i0 && value v1 = i1 && value v2 = i2
+            in
+            let observer_values_are i0 i1 i2 =
+              Observer.value_exn o0 = i0
+              && Observer.value_exn o1 = i1
+              && Observer.value_exn o2 = i2
+            in
+            assert (var_values_are 0 1 2);
+            stabilize_ [%here];
+            assert (observer_values_are 0 1 2);
+            assert (var_values_are 1 1 1);
             stabilize_ [%here];
-            Var.set b false;
-            assert (is_valid (Observer.observing o));
+            assert (observer_values_are 1 1 1);
+            assert (var_values_are 1 1 1);
+            set v1 13;
+            assert (observer_values_are 1 1 1);
+            assert (var_values_are 1 13 1);
             stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+            assert (observer_values_are 1 13 1);
+            assert (var_values_are 13 13 13);
+            stabilize_ [%here];
+            assert (observer_values_are 13 13 13);
+            assert (var_values_are 13 13 13)
           ;;
 
           let%expect_test _ =
-            (* an invalid node created on the rhs of a valid bind, later invalidated *)
-            let x = Var.create_ [%here] 13 in
-            let r = ref None in
-            let o1 =
+            (* [set] during stabilization gets the last value that was set *)
+            let x = create_ [%here] 0 in
+            let o =
               observe
-                (bind (Var.watch x) ~f:(fun _ ->
-                   r := Some (map invalid ~f:Fn.id);
-                   return ()))
+                (map (watch x) ~f:(fun v ->
+                   set x 1;
+                   set x 2;
+                   assert (latest_value x = 2);
+                   v))
             in
             stabilize_ [%here];
-            let o2 = observe (Option.value_exn !r) in
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o2)));
-            Var.set x 14;
+            assert (value x = 2);
             stabilize_ [%here];
-            disallow_future_use o1;
-            disallow_future_use o2
+            [%test_result: int] (Observer.value_exn o) ~expect:2;
+            disallow_future_use o
           ;;
 
           let%expect_test _ =
-            (* invariants blow up here if we don't make sure that we first make the
-             lhs-change node of binds necessary and only then the rhs necessary. *)
-            let node1 = const () >>= return in
-            let o = observe node1 in
-            stabilize_ [%here];
-            disallow_future_use o;
+            (* [replace] during stabilization gets the latest value *)
+            let x = create_ [%here] 0 in
+            let o =
+              observe
+                (map (watch x) ~f:(fun v ->
+                   set x 2;
+                   replace x ~f:(fun v ->
+                     assert (v = 2);
+                     v + 1);
+                   v))
+            in
             stabilize_ [%here];
-            let o = observe node1 in
+            print_s [%sexp (value x : int)];
+            [%expect {| 3 |}];
+            print_s [%sexp (Observer.value_exn o : int)];
+            [%expect {| 0 |}];
             stabilize_ [%here];
+            print_s [%sexp (Observer.value_exn o : int)];
+            [%expect {| 3 |}];
             disallow_future_use o
           ;;
 
-          let print_dot_file node = Packed.save_dot Out_channel.stdout [ pack node ]
+          let%expect_test _ =
+            (* [create] during stabilization *)
+            let o =
+              observe
+                (bind (const 13) ~f:(fun i ->
+                   let v = create_ [%here] i in
+                   watch v))
+            in
+            stabilize_ [%here];
+            assert (Observer.value_exn o = 13)
+          ;;
 
-          let%expect_test "plain node graphviz" =
-            let n = return "hello" in
-            print_dot_file n;
-            [%expect
-              {|
-            digraph G {
-              rankdir = BT
-              n### [shape=Mrecord label="{{n###|Const|height=-1}}" ]
-            }
-            |}]
+          let%expect_test _ =
+            (* [create] and [set] during stabilization *)
+            let o =
+              observe
+                (bind (const 13) ~f:(fun i ->
+                   let v = create_ [%here] i in
+                   let t = watch v in
+                   set v 15;
+                   t))
+            in
+            stabilize_ [%here];
+            assert (Observer.value_exn o = 13)
           ;;
 
-          let%expect_test "annotated with info" =
-            let n = return "hello" in
-            set_user_info n (Some (Info.of_string "hello world"));
-            print_dot_file n;
-            [%expect
-              {|
-            digraph G {
-              rankdir = BT
-              n### [shape=Mrecord label="{{hello\ world}|{n###|Const|height=-1}}" ]
+          let%expect_test _ =
+            (* maybe invalidating a variable *)
+            List.iter [ false; true ] ~f:(fun use_current_scope ->
+              let lhs = Var.create 0 in
+              let rhs = ref (const 0) in
+              let o =
+                observe
+                  (bind (watch lhs) ~f:(fun i ->
+                     rhs := Var.watch (create_ [%here] ~use_current_scope i);
+                     !rhs))
+              in
+              stabilize_ [%here];
+              let rhs = !rhs in
+              assert (is_valid rhs);
+              set lhs 1;
+              stabilize_ [%here];
+              if check_invalidity
+              then [%test_result: bool] (not (is_valid rhs)) ~expect:use_current_scope;
+              assert (Observer.value_exn o = 1))
+          ;;
+        end
+
+        let am_stabilizing = am_stabilizing
+        let%test _ = not (am_stabilizing ())
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] 13 in
+          let o = observe (map (watch x) ~f:(fun _ -> assert (am_stabilizing ()))) in
+          stabilize_ [%here];
+          disallow_future_use o
+        ;;
+
+        let map = map
+        let map2 = map2
+        let map3 = map3
+        let map4 = map4
+        let map5 = map5
+        let map6 = map6
+        let map7 = map7
+        let map8 = map8
+        let map9 = map9
+        let map10 = map10
+        let map11 = map11
+        let map12 = map12
+        let map13 = map13
+        let map14 = map14
+        let map15 = map15
+        let ( >>| ) = ( >>| )
+
+        let test_map n (mapN : int t -> int t) =
+          let o = observe (mapN (const 1)) in
+          stabilize_ [%here];
+          assert (value o = n);
+          let x = Var.create_ [%here] 1 in
+          let o = observe (mapN (watch x)) in
+          stabilize_ [%here];
+          assert (value o = n);
+          Var.set x 0;
+          stabilize_ [%here];
+          assert (value o = 0);
+          Var.set x 2;
+          stabilize_ [%here];
+          assert (value o = 2 * n);
+          assert (is_invalid (mapN invalid));
+          assert (is_invalidated_on_bind_rhs (fun i -> mapN (const i)))
+        ;;
+
+        let%expect_test _ = test_map 1 (fun i -> i >>| fun a1 -> a1)
+        let%expect_test _ = test_map 1 (fun i -> map i ~f:(fun a1 -> a1))
+        let%expect_test _ = test_map 2 (fun i -> map2 i i ~f:(fun a1 a2 -> a1 + a2))
+
+        let%expect_test _ =
+          test_map 3 (fun i -> map3 i i i ~f:(fun a1 a2 a3 -> a1 + a2 + a3))
+        ;;
+
+        let%expect_test _ =
+          test_map 4 (fun i -> map4 i i i i ~f:(fun a1 a2 a3 a4 -> a1 + a2 + a3 + a4))
+        ;;
+
+        let%expect_test _ =
+          test_map 5 (fun i ->
+            map5 i i i i i ~f:(fun a1 a2 a3 a4 a5 -> a1 + a2 + a3 + a4 + a5))
+        ;;
+
+        let%expect_test _ =
+          test_map 6 (fun i ->
+            map6 i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 -> a1 + a2 + a3 + a4 + a5 + a6))
+        ;;
+
+        let%expect_test _ =
+          test_map 7 (fun i ->
+            map7 i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 ->
+              a1 + a2 + a3 + a4 + a5 + a6 + a7))
+        ;;
+
+        let%expect_test _ =
+          test_map 8 (fun i ->
+            map8 i i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 a8 ->
+              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8))
+        ;;
+
+        let%expect_test _ =
+          test_map 9 (fun i ->
+            map9 i i i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 a8 a9 ->
+              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9))
+        ;;
+
+        let%expect_test _ =
+          test_map 10 (fun i ->
+            map10 i i i i i i i i i i ~f:(fun a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 ->
+              a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10))
+        ;;
+
+        let%expect_test _ =
+          let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 =
+            a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11
+          in
+          test_map 11 (fun i -> map11 i i i i i i i i i i i ~f)
+        ;;
+
+        let%expect_test _ =
+          let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 =
+            a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12
+          in
+          test_map 12 (fun i -> map12 i i i i i i i i i i i i ~f)
+        ;;
+
+        let%expect_test _ =
+          let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 =
+            a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13
+          in
+          test_map 13 (fun i -> map13 i i i i i i i i i i i i i ~f)
+        ;;
+
+        let%expect_test _ =
+          let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 =
+            a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14
+          in
+          test_map 14 (fun i -> map14 i i i i i i i i i i i i i i ~f)
+        ;;
+
+        let%expect_test _ =
+          let f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 =
+            a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15
+          in
+          test_map 15 (fun i -> map15 i i i i i i i i i i i i i i i ~f)
+        ;;
+
+        let%expect_test _ =
+          let x0 = Var.create_ [%here] 13 in
+          let o0 = observe (watch x0) in
+          let t1 = map (watch x0) ~f:(fun x -> x + 1) in
+          let t1_o = observe t1 in
+          stabilize_ [%here];
+          assert (value t1_o = value o0 + 1);
+          Var.set x0 14;
+          stabilize_ [%here];
+          assert (value t1_o = value o0 + 1);
+          let x1 = Var.create_ [%here] 15 in
+          let o1 = observe (watch x1) in
+          let t2 = map2 (watch x0) (watch x1) ~f:(fun x y -> x + y) in
+          let t2_o = observe t2 in
+          let t3 = map2 t1 t2 ~f:(fun x y -> x - y) in
+          let t3_o = observe t3 in
+          let check () =
+            stabilize_ [%here];
+            assert (value t1_o = value o0 + 1);
+            assert (value t2_o = value o0 + value o1);
+            assert (value t3_o = value t1_o - value t2_o)
+          in
+          check ();
+          Var.set x0 16;
+          check ();
+          Var.set x1 17;
+          check ();
+          Var.set x0 18;
+          Var.set x1 19;
+          check ()
+        ;;
+
+        let%expect_test _ =
+          (* deep *)
+          let rec loop i t =
+            if i = 0 then t else loop (i - 1) (map t ~f:(fun x -> x + 1))
+          in
+          let x0 = Var.create_ [%here] 0 in
+          let n = 100 in
+          let o = observe (loop n (watch x0)) in
+          stabilize_ [%here];
+          assert (value o = n);
+          Var.set x0 1;
+          stabilize_ [%here];
+          assert (value o = n + 1);
+          disallow_future_use o;
+          stabilize_ [%here]
+        ;;
+
+        let bind = bind
+        let ( >>= ) = ( >>= )
+
+        let%expect_test _ =
+          (* [bind] of a constant *)
+          stabilize_ [%here];
+          let o = observe (const 13 >>= const) in
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let%test _ =
+          is_invalidated_on_bind_rhs (fun i -> bind (const i) ~f:(fun _ -> const i))
+        ;;
+
+        let%expect_test _ =
+          (* bind created with an invalid rhs *)
+          let o = observe (const () >>= fun () -> invalid) in
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* bind created with an rhs that becomes invalid *)
+          let b = Var.create true in
+          let o = observe (Var.watch b >>= fun b -> if b then const 13 else invalid) in
+          stabilize_ [%here];
+          Var.set b false;
+          assert (is_valid (Observer.observing o));
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* an invalid node created on the rhs of a valid bind, later invalidated *)
+          let x = Var.create_ [%here] 13 in
+          let r = ref None in
+          let o1 =
+            observe
+              (bind (Var.watch x) ~f:(fun _ ->
+                 r := Some (map invalid ~f:Fn.id);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let o2 = observe (Option.value_exn !r) in
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o2)));
+          Var.set x 14;
+          stabilize_ [%here];
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test _ =
+          (* invariants blow up here if we don't make sure that we first make the
+             lhs-change node of binds necessary and only then the rhs necessary. *)
+          let node1 = const () >>= return in
+          let o = observe node1 in
+          stabilize_ [%here];
+          disallow_future_use o;
+          stabilize_ [%here];
+          let o = observe node1 in
+          stabilize_ [%here];
+          disallow_future_use o
+        ;;
+
+        let print_dot_file node = Packed.save_dot Out_channel.stdout [ pack node ]
+
+        let%expect_test "plain node graphviz" =
+          let n = return "hello" in
+          print_dot_file n;
+          [%expect
+            {|
+            digraph G {
+              rankdir = BT
+              n### [shape=Mrecord label="{{n###|Const|height=-1}}" ]
             }
             |}]
-          ;;
-
-          let%expect_test "annotated with label and attributes" =
-            let n = return "hello" in
-            append_user_info_graphviz
-              n
-              ~label:[ "hello"; "world" ]
-              ~attrs:(String.Map.of_alist_exn [ "fillcolor", "green" ]);
-            print_dot_file n;
-            [%expect
-              {|
+        ;;
+
+        let%expect_test "annotated with info" =
+          let n = return "hello" in
+          set_user_info n (Some (Info.of_string "hello world"));
+          print_dot_file n;
+          [%expect
+            {|
+            digraph G {
+              rankdir = BT
+              n### [shape=Mrecord label="{{hello\ world}|{n###|Const|height=-1}}" ]
+            }
+            |}]
+        ;;
+
+        let%expect_test "annotated with label and attributes" =
+          let n = return "hello" in
+          append_user_info_graphviz
+            n
+            ~label:[ "hello"; "world" ]
+            ~attrs:(String.Map.of_alist_exn [ "fillcolor", "green" ]);
+          print_dot_file n;
+          [%expect
+            {|
             digraph G {
               rankdir = BT
               n### [shape=Mrecord label="{{hello|world}|{n###|Const|height=-1}}"  "fillcolor"="green"]
             }
             |}]
-          ;;
+        ;;
+
+        let%expect_test _ =
+          let v1 = Var.create_ [%here] 0 in
+          let i1 = Var.watch v1 in
+          let i2 = i1 >>| fun x -> x + 1 in
+          let i3 = i1 >>| fun x -> x + 2 in
+          let i4 = i2 >>= fun x1 -> i3 >>= fun x2 -> const (x1 + x2) in
+          let o4 = observe i4 in
+          List.iter (List.init 20 ~f:Fn.id) ~f:(fun x ->
+            Gc.full_major ();
+            Var.set v1 x;
+            stabilize_ [%here];
+            assert (Observer.value_exn o4 = (2 * x) + 3))
+        ;;
+
+        let%expect_test _ =
+          (* graph changes only *)
+          let x = Var.create_ [%here] true in
+          let a = const 3 in
+          let b = const 4 in
+          let o = observe (bind (watch x) ~f:(fun bool -> if bool then a else b)) in
+          let check where expect =
+            stabilize_ where;
+            [%test_eq: int] (value o) expect
+          in
+          check [%here] 3;
+          Var.set x false;
+          check [%here] 4;
+          Var.set x true;
+          check [%here] 3
+        ;;
+
+        let%expect_test _ =
+          let x0 = Var.create_ [%here] 13 in
+          let o0 = observe (watch x0) in
+          let x1 = Var.create_ [%here] 15 in
+          let o1 = observe (watch x1) in
+          let x2 = Var.create_ [%here] true in
+          let o2 = observe (watch x2) in
+          let t = bind (watch x2) ~f:(fun b -> if b then watch x0 else watch x1) in
+          let t_o = observe t in
+          let check () =
+            stabilize_ [%here];
+            assert (value t_o = value (if value o2 then o0 else o1))
+          in
+          check ();
+          Var.set x0 17;
+          check ();
+          Var.set x1 19;
+          check ();
+          Var.set x2 false;
+          check ();
+          Var.set x0 21;
+          Var.set x2 true;
+          check ()
+        ;;
+
+        let%expect_test _ =
+          (* walking chains of maps is not allowed to cross scopes *)
+          let x0 = Var.create_ [%here] 0 in
+          let x1 = Var.create_ [%here] 1 in
+          let r = ref 0 in
+          let i2 =
+            observe
+              (Var.watch x0
+               >>= fun i ->
+               Var.watch x1
+               >>| fun _ ->
+               incr r;
+               i)
+          in
+          assert (!r = 0);
+          stabilize_ [%here];
+          assert (!r = 1);
+          assert (value i2 = 0);
+          Var.set x0 10;
+          Var.set x1 11;
+          stabilize_ [%here];
+          assert (!r = 2);
+          assert (value i2 = 10)
+        ;;
+
+        let%expect_test _ =
+          let v1 = Var.create_ [%here] 0 in
+          let i1 = Var.watch v1 in
+          let o1 = observe i1 in
+          Var.set v1 1;
+          let i2 = i1 >>= fun _ -> i1 in
+          let o2 = observe i2 in
+          stabilize_ [%here];
+          Var.set v1 2;
+          stabilize_ [%here];
+          Gc.keep_alive (i1, i2, o1, o2)
+        ;;
+
+        let%expect_test _ =
+          (* topological overload many *)
+          let rec copy_true c1 = bind c1 ~f:(fun x -> if x then c1 else copy_false c1)
+          and copy_false c1 = bind c1 ~f:(fun x -> if x then copy_true c1 else c1) in
+          let x1 = Var.create_ [%here] false in
+          let rec loop cur i =
+            if i > 1000 then cur else loop (copy_true (copy_false cur)) (i + 1)
+          in
+          let hold = loop (Var.watch x1) 0 in
+          let rec set_loop at i =
+            if i < 5
+            then (
+              Var.set x1 at;
+              stabilize_ [%here];
+              set_loop (not at) (i + 1))
+          in
+          set_loop true 0;
+          Gc.keep_alive hold
+        ;;
+
+        let%expect_test _ =
+          (* nested var sets *)
+          (* We model a simple ETF that initially consists of 100 shares of IBM and
+             200 shares of microsoft with an implicit divisor of 1. *)
+          (* the last trade prices of two stocks *)
+          let ibm = Var.create_ [%here] 50. in
+          let msft = Var.create_ [%here] 20. in
+          (* .5 shares of IBM, .5 shares of MSFT.  Divisor implicitly 1. *)
+          let cfg = Var.create_ [%here] (0.5, 0.5) in
+          let nav =
+            observe
+              (bind (Var.watch cfg) ~f:(fun (ibm_mult, msft_mult) ->
+                 let x = map (Var.watch ibm) ~f:(fun ibm -> ibm *. ibm_mult) in
+                 let y = map (Var.watch msft) ~f:(fun msft -> msft *. msft_mult) in
+                 sum [| x; y |] ~zero:0. ~add:( +. ) ~sub:( -. )))
+          in
+          stabilize_ [%here];
+          assert (value nav =. (0.5 *. 50.) +. (0.5 *. 20.));
+          Var.set cfg (0.6, 0.4);
+          stabilize_ [%here];
+          assert (value nav =. (0.6 *. 50.) +. (0.4 *. 20.))
+        ;;
+
+        let%expect_test _ =
+          (* adjust heights *)
+          let x = Var.create_ [%here] 0 in
+          let rec chain i = if i = 0 then watch x else chain (i - 1) >>| fun i -> i + 1 in
+          let b = bind (watch x) ~f:chain in
+          let rec dag i =
+            if i = 0
+            then b
+            else (
+              let t = dag (i - 1) in
+              map2 t t ~f:( + ))
+          in
+          let o = observe (dag 20) in
+          for i = 1 to 10 do
+            Var.set x i;
+            stabilize_ [%here]
+          done;
+          disallow_future_use o
+        ;;
+
+        let make_high t =
+          let rec loop t n =
+            if n = 0 then t else loop (map2 t t ~f:(fun a _ -> a)) (n - 1)
+          in
+          loop t 5
+        ;;
+
+        let%expect_test _ =
+          (* an invalid unused rhs doesn't invalidate the [bind] *)
+          let r = ref None in
+          let lhs = Var.create_ [%here] 1 in
+          let o1 =
+            observe
+              (bind (watch lhs) ~f:(fun i ->
+                 r := Some (const i);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let else_ = Option.value_exn !r in
+          let test = Var.create_ [%here] false in
+          let o2 =
+            observe
+              (bind
+                 (make_high (watch test))
+                 ~f:(fun test -> if test then const 13 else else_))
+          in
+          stabilize_ [%here];
+          Var.set lhs 2;
+          (* invalidates [else_]. *)
+          Var.set test true;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid else_));
+          assert (value o2 = 13);
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test _ =
+          (* plugging an invalid node in a bind can invalidate the bind (though
+             not always) *)
+          let x = Var.create 4 in
+          let r = ref (const (-1)) in
+          let o =
+            observe
+              (Var.watch x
+               >>= fun i ->
+               r := const i;
+               const ())
+          in
+          stabilize_ [%here];
+          let escaped = !r in
+          let escaped_o = observe escaped in
+          stabilize_ [%here];
+          assert (Observer.value_exn escaped_o = 4);
+          Var.set x 5;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid escaped));
+          disallow_future_use o;
+          let o = observe (Var.watch x >>= fun _ -> escaped) in
+          stabilize_ [%here];
+          disallow_future_use o;
+          disallow_future_use escaped_o
+        ;;
+
+        let%expect_test _ =
+          (* changing the rhs from a node to its ancestor, which causes problems if
+             we leave the node with a broken invariant while adding the ancestor. *)
+          let lhs_var = Var.create false in
+          let num_calls = ref 0 in
+          let rhs_var = Var.create 13 in
+          let rhs_false =
+            map (watch rhs_var) ~f:(fun i ->
+              incr num_calls;
+              i + 1)
+          in
+          let rhs_true = map rhs_false ~f:(fun i -> i + 1) in
+          let o =
+            observe (bind (watch lhs_var) ~f:(fun b -> if b then rhs_true else rhs_false))
+          in
+          stabilize_ [%here];
+          [%test_result: int] !num_calls ~expect:1;
+          Var.set lhs_var true;
+          stabilize_ [%here];
+          [%test_result: int] !num_calls ~expect:1;
+          disallow_future_use o;
+          stabilize_ [%here];
+          Var.set rhs_var 14;
+          stabilize_ [%here];
+          [%test_result: int] !num_calls ~expect:1
+        ;;
+
+        let bind2 = bind2
+        let bind3 = bind3
+        let bind4 = bind4
+
+        let%expect_test _ =
+          let v1 = Var.create_ [%here] 1 in
+          let v2 = Var.create_ [%here] 2 in
+          let v3 = Var.create_ [%here] 3 in
+          let v4 = Var.create_ [%here] 4 in
+          let o =
+            observe
+              (bind4 (watch v1) (watch v2) (watch v3) (watch v4) ~f:(fun x1 x2 x3 x4 ->
+                 bind3 (watch v2) (watch v3) (watch v4) ~f:(fun y2 y3 y4 ->
+                   bind2 (watch v3) (watch v4) ~f:(fun z3 z4 ->
+                     bind (watch v4) ~f:(fun w4 ->
+                       return (x1 + x2 + x3 + x4 + y2 + y3 + y4 + z3 + z4 + w4))))))
+          in
+          let check where =
+            stabilize_ where;
+            [%test_result: int]
+              (value o)
+              ~expect:
+                (Var.value v1
+                 + (2 * Var.value v2)
+                 + (3 * Var.value v3)
+                 + (4 * Var.value v4))
+          in
+          check [%here];
+          Var.set v4 5;
+          check [%here];
+          Var.set v3 6;
+          check [%here];
+          Var.set v2 7;
+          check [%here];
+          Var.set v1 8;
+          check [%here];
+          Var.set v1 9;
+          Var.set v2 10;
+          Var.set v3 11;
+          Var.set v4 12;
+          check [%here]
+        ;;
+
+        module Join (X : sig
+            val join : 'a t t -> 'a t
+          end) =
+        struct
+          let join = X.join
 
           let%expect_test _ =
-            let v1 = Var.create_ [%here] 0 in
-            let i1 = Var.watch v1 in
-            let i2 = i1 >>| fun x -> x + 1 in
-            let i3 = i1 >>| fun x -> x + 2 in
-            let i4 = i2 >>= fun x1 -> i3 >>= fun x2 -> const (x1 + x2) in
-            let o4 = observe i4 in
-            List.iter (List.init 20 ~f:Fn.id) ~f:(fun x ->
-              Gc.full_major ();
-              Var.set v1 x;
-              stabilize_ [%here];
-              assert (Observer.value_exn o4 = (2 * x) + 3))
+            (* [join] of a constant *)
+            let o = observe (join (const (const 1))) in
+            stabilize_ [%here];
+            assert (value o = 1)
           ;;
 
           let%expect_test _ =
             (* graph changes only *)
-            let x = Var.create_ [%here] true in
             let a = const 3 in
             let b = const 4 in
-            let o = observe (bind (watch x) ~f:(fun bool -> if bool then a else b)) in
+            let x = Var.create_ [%here] a in
+            let o = observe (join (watch x)) in
             let check where expect =
               stabilize_ where;
-              [%test_eq: int] (value o) expect
+              [%test_result: int] (value o) ~expect
             in
             check [%here] 3;
-            Var.set x false;
+            Var.set x b;
             check [%here] 4;
-            Var.set x true;
+            Var.set x a;
             check [%here] 3
           ;;
 
           let%expect_test _ =
-            let x0 = Var.create_ [%here] 13 in
-            let o0 = observe (watch x0) in
-            let x1 = Var.create_ [%here] 15 in
-            let o1 = observe (watch x1) in
-            let x2 = Var.create_ [%here] true in
-            let o2 = observe (watch x2) in
-            let t = bind (watch x2) ~f:(fun b -> if b then watch x0 else watch x1) in
-            let t_o = observe t in
-            let check () =
-              stabilize_ [%here];
-              assert (value t_o = value (if value o2 then o0 else o1))
-            in
-            check ();
-            Var.set x0 17;
-            check ();
-            Var.set x1 19;
-            check ();
-            Var.set x2 false;
-            check ();
-            Var.set x0 21;
-            Var.set x2 true;
-            check ()
-          ;;
-
-          let%expect_test _ =
-            (* walking chains of maps is not allowed to cross scopes *)
-            let x0 = Var.create_ [%here] 0 in
-            let x1 = Var.create_ [%here] 1 in
-            let r = ref 0 in
-            let i2 =
-              observe
-                (Var.watch x0
-                 >>= fun i ->
-                 Var.watch x1
-                 >>| fun _ ->
-                 incr r;
-                 i)
-            in
-            assert (!r = 0);
-            stabilize_ [%here];
-            assert (!r = 1);
-            assert (value i2 = 0);
-            Var.set x0 10;
-            Var.set x1 11;
-            stabilize_ [%here];
-            assert (!r = 2);
-            assert (value i2 = 10)
-          ;;
-
-          let%expect_test _ =
-            let v1 = Var.create_ [%here] 0 in
-            let i1 = Var.watch v1 in
-            let o1 = observe i1 in
-            Var.set v1 1;
-            let i2 = i1 >>= fun _ -> i1 in
-            let o2 = observe i2 in
+            let v1 = Var.create_ [%here] 1 in
+            let v2 = Var.create_ [%here] 2 in
+            let v3 = Var.create_ [%here] (Var.watch v1) in
+            let o = observe (join (Var.watch v3)) in
             stabilize_ [%here];
-            Var.set v1 2;
+            assert (value o = 1);
+            Var.set v1 13;
             stabilize_ [%here];
-            Gc.keep_alive (i1, i2, o1, o2)
-          ;;
-
-          let%expect_test _ =
-            (* topological overload many *)
-            let rec copy_true c1 = bind c1 ~f:(fun x -> if x then c1 else copy_false c1)
-            and copy_false c1 = bind c1 ~f:(fun x -> if x then copy_true c1 else c1) in
-            let x1 = Var.create_ [%here] false in
-            let rec loop cur i =
-              if i > 1000 then cur else loop (copy_true (copy_false cur)) (i + 1)
-            in
-            let hold = loop (Var.watch x1) 0 in
-            let rec set_loop at i =
-              if i < 5
-              then (
-                Var.set x1 at;
-                stabilize_ [%here];
-                set_loop (not at) (i + 1))
-            in
-            set_loop true 0;
-            Gc.keep_alive hold
-          ;;
-
-          let%expect_test _ =
-            (* nested var sets *)
-            (* We model a simple ETF that initially consists of 100 shares of IBM and
-             200 shares of microsoft with an implicit divisor of 1. *)
-            (* the last trade prices of two stocks *)
-            let ibm = Var.create_ [%here] 50. in
-            let msft = Var.create_ [%here] 20. in
-            (* .5 shares of IBM, .5 shares of MSFT.  Divisor implicitly 1. *)
-            let cfg = Var.create_ [%here] (0.5, 0.5) in
-            let nav =
-              observe
-                (bind (Var.watch cfg) ~f:(fun (ibm_mult, msft_mult) ->
-                   let x = map (Var.watch ibm) ~f:(fun ibm -> ibm *. ibm_mult) in
-                   let y = map (Var.watch msft) ~f:(fun msft -> msft *. msft_mult) in
-                   sum [| x; y |] ~zero:0. ~add:( +. ) ~sub:( -. )))
-            in
+            assert (value o = 13);
+            Var.set v3 (Var.watch v2);
             stabilize_ [%here];
-            assert (value nav =. (0.5 *. 50.) +. (0.5 *. 20.));
-            Var.set cfg (0.6, 0.4);
+            assert (value o = 2);
+            Var.set v3 (Var.watch v1);
+            Var.set v1 14;
             stabilize_ [%here];
-            assert (value nav =. (0.6 *. 50.) +. (0.4 *. 20.))
-          ;;
-
-          let%expect_test _ =
-            (* adjust heights *)
-            let x = Var.create_ [%here] 0 in
-            let rec chain i =
-              if i = 0 then watch x else chain (i - 1) >>| fun i -> i + 1
-            in
-            let b = bind (watch x) ~f:chain in
-            let rec dag i =
-              if i = 0
-              then b
-              else (
-                let t = dag (i - 1) in
-                map2 t t ~f:( + ))
-            in
-            let o = observe (dag 20) in
-            for i = 1 to 10 do
-              Var.set x i;
-              stabilize_ [%here]
-            done;
-            disallow_future_use o
-          ;;
-
-          let make_high t =
-            let rec loop t n =
-              if n = 0 then t else loop (map2 t t ~f:(fun a _ -> a)) (n - 1)
-            in
-            loop t 5
+            assert (value o = 14)
           ;;
 
           let%expect_test _ =
-            (* an invalid unused rhs doesn't invalidate the [bind] *)
-            let r = ref None in
+            (* an invalid unused rhs doesn't invalidate the [join] *)
+            let x = Var.create_ [%here] (const 0) in
             let lhs = Var.create_ [%here] 1 in
             let o1 =
               observe
                 (bind (watch lhs) ~f:(fun i ->
-                   r := Some (const i);
+                   Var.set x (const i);
                    return ()))
             in
             stabilize_ [%here];
-            let else_ = Option.value_exn !r in
-            let test = Var.create_ [%here] false in
-            let o2 =
-              observe
-                (bind
-                   (make_high (watch test))
-                   ~f:(fun test -> if test then const 13 else else_))
-            in
+            let o2 = observe (join (make_high (Var.watch x))) in
             stabilize_ [%here];
             Var.set lhs 2;
-            (* invalidates [else_]. *)
-            Var.set test true;
+            (* invalidate *)
+            Var.set x (const 3);
             stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid else_));
-            assert (value o2 = 13);
+            assert (value o2 = 3);
             disallow_future_use o1;
             disallow_future_use o2
           ;;
 
           let%expect_test _ =
-            (* plugging an invalid node in a bind can invalidate the bind (though
-             not always) *)
-            let x = Var.create 4 in
-            let r = ref (const (-1)) in
-            let o =
-              observe
-                (Var.watch x
-                 >>= fun i ->
-                 r := const i;
-                 const ())
-            in
-            stabilize_ [%here];
-            let escaped = !r in
-            let escaped_o = observe escaped in
-            stabilize_ [%here];
-            assert (Observer.value_exn escaped_o = 4);
-            Var.set x 5;
+            (* checking that join can be invalidated *)
+            let join = join (const invalid) in
+            let o = observe join in
             stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid escaped));
             disallow_future_use o;
-            let o = observe (Var.watch x >>= fun _ -> escaped) in
-            stabilize_ [%here];
-            disallow_future_use o;
-            disallow_future_use escaped_o
+            assert (skip_invalidity_check || not (is_valid join))
           ;;
 
           let%expect_test _ =
             (* changing the rhs from a node to its ancestor, which causes problems if
-             we leave the node with a broken invariant while adding the ancestor. *)
-            let lhs_var = Var.create false in
+               we leave the node with a broken invariant while adding the ancestor. *)
             let num_calls = ref 0 in
             let rhs_var = Var.create 13 in
-            let rhs_false =
+            let first =
               map (watch rhs_var) ~f:(fun i ->
                 incr num_calls;
                 i + 1)
             in
-            let rhs_true = map rhs_false ~f:(fun i -> i + 1) in
-            let o =
-              observe
-                (bind (watch lhs_var) ~f:(fun b -> if b then rhs_true else rhs_false))
-            in
+            let second = map first ~f:(fun i -> i + 1) in
+            let lhs_var = Var.create first in
+            let o = observe (join (watch lhs_var)) in
             stabilize_ [%here];
             [%test_result: int] !num_calls ~expect:1;
-            Var.set lhs_var true;
+            Var.set lhs_var second;
             stabilize_ [%here];
             [%test_result: int] !num_calls ~expect:1;
             disallow_future_use o;
@@ -1085,3279 +1216,3116 @@ struct
             stabilize_ [%here];
             [%test_result: int] !num_calls ~expect:1
           ;;
+        end
 
-          let bind2 = bind2
-          let bind3 = bind3
-          let bind4 = bind4
+        include Join (struct
+            let join = join
+          end)
 
-          let%expect_test _ =
-            let v1 = Var.create_ [%here] 1 in
-            let v2 = Var.create_ [%here] 2 in
-            let v3 = Var.create_ [%here] 3 in
-            let v4 = Var.create_ [%here] 4 in
-            let o =
-              observe
-                (bind4 (watch v1) (watch v2) (watch v3) (watch v4) ~f:(fun x1 x2 x3 x4 ->
-                   bind3 (watch v2) (watch v3) (watch v4) ~f:(fun y2 y3 y4 ->
-                     bind2 (watch v3) (watch v4) ~f:(fun z3 z4 ->
-                       bind (watch v4) ~f:(fun w4 ->
-                         return (x1 + x2 + x3 + x4 + y2 + y3 + y4 + z3 + z4 + w4))))))
-            in
-            let check where =
-              stabilize_ where;
-              [%test_result: int]
-                (value o)
-                ~expect:
-                  (Var.value v1
-                   + (2 * Var.value v2)
-                   + (3 * Var.value v3)
-                   + (4 * Var.value v4))
+        let if_ = if_
+
+        let%expect_test _ =
+          (* [if_ true] *)
+          let o = observe (if_ (const true) ~then_:(const 13) ~else_:(const 14)) in
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let%expect_test _ =
+          (* [if_ false] *)
+          let o = observe (if_ (const false) ~then_:(const 13) ~else_:(const 14)) in
+          stabilize_ [%here];
+          assert (value o = 14)
+        ;;
+
+        let%expect_test _ =
+          (* graph changes only *)
+          let x = Var.create_ [%here] true in
+          let o = observe (if_ (watch x) ~then_:(const 3) ~else_:(const 4)) in
+          let check where expect =
+            stabilize_ where;
+            [%test_eq: int] (value o) expect
+          in
+          check [%here] 3;
+          Var.set x false;
+          check [%here] 4;
+          Var.set x true;
+          check [%here] 3;
+          Var.set x false;
+          check [%here] 4
+        ;;
+
+        let%expect_test _ =
+          let test = Var.create_ [%here] true in
+          let then_ = Var.create_ [%here] 1 in
+          let else_ = Var.create_ [%here] 2 in
+          let num_then_run = ref 0 in
+          let num_else_run = ref 0 in
+          let ite =
+            observe
+              (if_
+                 (Var.watch test)
+                 ~then_:
+                   (Var.watch then_
+                    >>| fun i ->
+                    incr num_then_run;
+                    i)
+                 ~else_:
+                   (Var.watch else_
+                    >>| fun i ->
+                    incr num_else_run;
+                    i))
+          in
+          stabilize_ [%here];
+          assert (Observer.value_exn ite = 1);
+          assert (!num_then_run = 1);
+          assert (!num_else_run = 0);
+          Var.set test false;
+          stabilize_ [%here];
+          assert (Observer.value_exn ite = 2);
+          Var.set test true;
+          stabilize_ [%here];
+          assert (Observer.value_exn ite = 1);
+          Var.set then_ 3;
+          Var.set else_ 4;
+          let ntr = !num_then_run in
+          let ner = !num_else_run in
+          stabilize_ [%here];
+          assert (Observer.value_exn ite = 3);
+          assert (!num_then_run = ntr + 1);
+          assert (!num_else_run = ner);
+          Var.set test false;
+          Var.set then_ 5;
+          Var.set else_ 6;
+          stabilize_ [%here];
+          assert (Observer.value_exn ite = 6)
+        ;;
+
+        let%expect_test _ =
+          (* an invalid unused branch doesn't invalidate the [if_] *)
+          let r = ref None in
+          let lhs = Var.create_ [%here] 1 in
+          let o1 =
+            observe
+              (bind (watch lhs) ~f:(fun i ->
+                 r := Some (const i);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let else_ = Option.value_exn !r in
+          let test = Var.create_ [%here] false in
+          let o2 = observe (if_ (make_high (watch test)) ~then_:(const 13) ~else_) in
+          stabilize_ [%here];
+          Var.set lhs 2;
+          (* invalidates [else_]. *)
+          Var.set test true;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid else_));
+          assert (value o2 = 13);
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test _ =
+          (* if-then-else created with an invalid test *)
+          let o =
+            observe (if_ (invalid >>| fun _ -> true) ~then_:(const ()) ~else_:(const ()))
+          in
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* if-then-else created with an invalid branch *)
+          let o = observe (if_ (const true) ~then_:invalid ~else_:(const 13)) in
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* if-then-else switching to an invalid branch *)
+          let b = Var.create false in
+          let o = observe (if_ (Var.watch b) ~then_:invalid ~else_:(const 13)) in
+          stabilize_ [%here];
+          assert (is_valid (Observer.observing o));
+          Var.set b true;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* if-then-else switching to an invalid branch via a map *)
+          let b = Var.create false in
+          let o =
+            observe (if_ (Var.watch b) ~then_:(invalid >>| fun _ -> 13) ~else_:(const 13))
+          in
+          stabilize_ [%here];
+          assert (is_valid (Observer.observing o));
+          Var.set b true;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* if-then-else switching to an invalid test *)
+          let b = Var.create false in
+          let o =
+            observe
+              (if_
+                 (if_
+                    (Var.watch b)
+                    ~then_:(invalid >>| fun _ -> true)
+                    ~else_:(const true))
+                 ~then_:(const 13)
+                 ~else_:(const 15))
+          in
+          stabilize_ [%here];
+          assert (is_valid (Observer.observing o));
+          Var.set b true;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
+        ;;
+
+        let%expect_test _ =
+          (* changing branches from a node to its ancestor, which causes problems if
+             we leave the node with a broken invariant while adding the ancestor. *)
+          let test_var = Var.create false in
+          let num_calls = ref 0 in
+          let branch_var = Var.create 13 in
+          let else_ =
+            map (watch branch_var) ~f:(fun i ->
+              incr num_calls;
+              i + 1)
+          in
+          let then_ = map else_ ~f:(fun i -> i + 1) in
+          let o = observe (if_ (watch test_var) ~then_ ~else_) in
+          stabilize_ [%here];
+          [%test_result: int] !num_calls ~expect:1;
+          Var.set test_var true;
+          stabilize_ [%here];
+          [%test_result: int] !num_calls ~expect:1;
+          disallow_future_use o;
+          stabilize_ [%here];
+          Var.set branch_var 14;
+          stabilize_ [%here];
+          [%test_result: int] !num_calls ~expect:1
+        ;;
+
+        let freeze = freeze
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] 13 in
+          let f = freeze (Var.watch x) in
+          let y = observe f in
+          assert (not (is_const f));
+          stabilize_ [%here];
+          assert (value y = 13);
+          assert (is_const f);
+          let u = Var.create_ [%here] 1 in
+          let z = observe (bind (Var.watch u) ~f:(fun _ -> freeze (Var.watch x))) in
+          stabilize_ [%here];
+          assert (value z = 13);
+          Var.set u 2;
+          Var.set x 14;
+          stabilize_ [%here];
+          assert (value z = 14);
+          Var.set x 15;
+          stabilize_ [%here];
+          assert (value z = 14);
+          Var.set u 3;
+          stabilize_ [%here];
+          assert (value z = 15)
+        ;;
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] 13 in
+          let o1 = observe (freeze (Var.watch x >>| Fn.id)) in
+          let o2 = observe (Var.watch x >>| Fn.id) in
+          stabilize_ [%here];
+          assert (value o1 = 13);
+          assert (value o2 = 13);
+          stabilize_ [%here];
+          assert (value o1 = 13);
+          assert (value o2 = 13);
+          Var.set x 14;
+          stabilize_ [%here];
+          assert (value o1 = 13);
+          assert (value o2 = 14)
+        ;;
+
+        let%expect_test _ =
+          (* [freeze] nodes increment [num_nodes_became_necessary] *)
+          let i1 = State.(num_nodes_became_necessary t) in
+          ignore (freeze (const ()) : unit t);
+          let i2 = State.(num_nodes_became_necessary t) in
+          [%test_result: int] i2 ~expect:(i1 + 2)
+        ;;
+
+        (* one for the [const], one for the [freeze] *)
+
+        (* TEST_UNIT = (\* freeze nodes leak memory (and forces spurious computations) until
+         *                they freeze *\)
+         *   let c = const () in
+         *   for i = 0 to 100_000_000 do
+         *     ignore (freeze c ~when_:(fun () -> false) : unit t);
+         *     if i mod 1000 = 0 then begin
+         *       Printf.printf "num parents %d\n%!" ((Obj.magic c : int array).(7));
+         *       stabilize_ [%here];
+         *     end
+         *   done;
+         * ;; *)
+
+        let%expect_test _ =
+          (* [freeze]ing something that is otherwise unnecessary. *)
+          let x = Var.create_ [%here] 0 in
+          let i = freeze (Var.watch x >>| fun i -> i + 1) in
+          stabilize_ [%here];
+          Var.set x 13;
+          let o = observe i in
+          stabilize_ [%here];
+          assert (value o = 1 (* not 14 *))
+        ;;
+
+        let%expect_test _ =
+          (* a frozen node remains valid, even if its original scope isn't *)
+          let x = Var.create_ [%here] 13 in
+          let r = ref None in
+          let o1 =
+            observe
+              (watch x
+               >>= fun i ->
+               if Option.is_none !r then r := Some (freeze (const i));
+               const ())
+          in
+          stabilize_ [%here];
+          let f = Option.value_exn !r in
+          Var.set x 15;
+          stabilize_ [%here];
+          let o2 = observe f in
+          stabilize_ [%here];
+          assert (is_const f);
+          assert (value o2 = 13);
+          disallow_future_use o1;
+          stabilize_ [%here]
+        ;;
+
+        let%expect_test _ =
+          (* a frozen node remains valid, even if the node it froze isn't *)
+          let x = Var.create_ [%here] 13 in
+          let r = ref (const 14) in
+          let o1 =
+            observe
+              (watch x
+               >>= fun i ->
+               r := const i;
+               const ())
+          in
+          stabilize_ [%here];
+          let o2 = observe (freeze !r) in
+          stabilize_ [%here];
+          Var.set x 15;
+          stabilize_ [%here];
+          assert (value o2 = 13);
+          disallow_future_use o1
+        ;;
+
+        let%expect_test _ =
+          (* [freeze ~when] *)
+          let x = Var.create_ [%here] 13 in
+          let o = observe (freeze (watch x) ~when_:(fun i -> i >= 15)) in
+          let check where expect =
+            stabilize_ where;
+            [%test_result: int] (value o) ~expect
+          in
+          check [%here] 13;
+          Var.set x 14;
+          check [%here] 14;
+          Var.set x 15;
+          check [%here] 15;
+          Var.set x 16;
+          check [%here] 15;
+          Var.set x 14;
+          check [%here] 15
+        ;;
+
+        let%expect_test _ =
+          (* a freeze that is invalidated before it is frozen. *)
+          let r = ref None in
+          let x = Var.create_ [%here] 13 in
+          let o =
+            observe
+              (bind (watch x) ~f:(fun i ->
+                 r := Some (const i);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let f = freeze (Option.value_exn !r) ~when_:(fun _ -> false) in
+          Var.set x 14;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid f));
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* a freeze that is stabilized and invalidated before it is frozen. *)
+          let r = ref None in
+          let x = Var.create_ [%here] 13 in
+          let o =
+            observe
+              (bind (watch x) ~f:(fun i ->
+                 r := Some (const i);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let f = freeze (Option.value_exn !r) ~when_:(fun _ -> false) in
+          stabilize_ [%here];
+          Var.set x 14;
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid f));
+          disallow_future_use o
+        ;;
+
+        let depend_on = depend_on
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] 13 in
+          let y = Var.create_ [%here] 14 in
+          let d = depend_on (watch x) ~depend_on:(watch y) in
+          let o = observe d in
+          let nx = ref 0 in
+          let incr_o r = function
+            | Observer.Update.Invalidated -> assert false
+            | Initialized _ | Changed _ -> incr r
+          in
+          let incr r = function
+            | Update.Invalidated -> assert false
+            | Unnecessary -> ()
+            | Necessary _ | Changed _ -> incr r
+          in
+          Observer.on_update_exn o ~f:(incr_o nx);
+          let ny = ref 0 in
+          on_update (Var.watch y) ~f:(incr ny);
+          let check where eo enx eny =
+            stabilize_ where;
+            [%test_result: int] (value o) ~expect:eo;
+            [%test_result: int] !nx ~expect:enx;
+            [%test_result: int] !ny ~expect:eny
+          in
+          check [%here] 13 1 1;
+          Var.set x 15;
+          check [%here] 15 2 1;
+          Var.set y 16;
+          check [%here] 15 2 2;
+          Var.set x 17;
+          Var.set y 18;
+          check [%here] 17 3 3;
+          Var.set x 17;
+          check [%here] 17 3 3;
+          Var.set y 18;
+          check [%here] 17 3 3;
+          disallow_future_use o;
+          let check where enx eny =
+            stabilize_ where;
+            [%test_result: int] !nx ~expect:enx;
+            [%test_result: int] !ny ~expect:eny
+          in
+          Var.set x 19;
+          Var.set y 20;
+          check [%here] 3 3;
+          let o = observe d in
+          Observer.on_update_exn o ~f:(incr_o nx);
+          check [%here] 4 4;
+          [%test_result: int] (value o) ~expect:19
+        ;;
+
+        let%expect_test _ =
+          (* propagating the first argument of [depend_on] while the result of
+             [depend_on] is not observable *)
+          let var = Var.create 1 in
+          let depend = depend_on (Var.watch var) ~depend_on:(const ()) in
+          let o = observe depend in
+          stabilize_ [%here];
+          assert (Observer.value_exn o = 1);
+          disallow_future_use o;
+          let o = observe (Var.watch var) in
+          Var.set var 2;
+          stabilize_ [%here];
+          assert (Observer.value_exn o = 2);
+          disallow_future_use o;
+          let o = observe depend in
+          stabilize_ [%here];
+          [%test_eq: int] (Observer.value_exn o) 2
+        ;;
+
+        let%expect_test _ =
+          (* depend_on doesn't cutoff using phys_equal *)
+          let v1 = Var.create () in
+          let v2 = Var.create 1 in
+          set_cutoff (Var.watch v1) Cutoff.never;
+          let o = observe (depend_on (Var.watch v1) ~depend_on:(Var.watch v2)) in
+          let updates = ref 0 in
+          Observer.on_update_exn o ~f:(fun _ -> incr updates);
+          [%test_eq: int] !updates 0;
+          stabilize_ [%here];
+          [%test_eq: int] !updates 1;
+          Var.set v2 2;
+          stabilize_ [%here];
+          [%test_eq: int] !updates 1;
+          Var.set v1 ();
+          stabilize_ [%here];
+          [%test_eq: int] !updates 2;
+          disallow_future_use o
+        ;;
+
+        let necessary_if_alive = necessary_if_alive
+
+        let%expect_test _ =
+          (* dead => unnecessary *)
+          let x = Var.create 13 in
+          let push, check = on_update_queue () in
+          on_update (watch x) ~f:push;
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          let t = necessary_if_alive (watch x) in
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          Var.set x 14;
+          stabilize_ [%here];
+          check [ Changed (13, 14) ];
+          Gc.keep_alive t;
+          Gc.full_major ();
+          stabilize_ [%here];
+          check [ Unnecessary ]
+        ;;
+
+        let%expect_test _ =
+          (* cutoff is preserved *)
+          let x = Var.create 13 in
+          set_cutoff (watch x) Cutoff.never;
+          let t = necessary_if_alive (watch x) in
+          let o = observe t in
+          let push, check = on_update_queue () in
+          on_update t ~f:push;
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          Var.set x 14;
+          stabilize_ [%here];
+          check [ Changed (13, 14) ];
+          Var.set x 14;
+          stabilize_ [%here];
+          check [ Changed (14, 14) ];
+          disallow_future_use o;
+          Gc.full_major ();
+          stabilize_ [%here];
+          check [ Unnecessary ]
+        ;;
+
+        let all = all
+        let both = both
+        let exists = exists
+        let for_all = for_all
+
+        let test q list_f =
+          for num_vars = 0 to 3 do
+            let vars = List.init num_vars ~f:(fun _ -> Var.create_ [%here] true) in
+            let q = observe (q (Array.of_list_map vars ~f:watch)) in
+            let all = observe (all (List.map vars ~f:watch)) in
+            let rec loop vars =
+              match vars with
+              | [] ->
+                stabilize_ [%here];
+                [%test_eq: Bool.t] (value q) (list_f (value all) ~f:Fn.id)
+              | var :: vars ->
+                List.iter [ false; true ] ~f:(fun b ->
+                  Var.set var b;
+                  loop vars)
             in
-            check [%here];
-            Var.set v4 5;
-            check [%here];
-            Var.set v3 6;
-            check [%here];
-            Var.set v2 7;
-            check [%here];
-            Var.set v1 8;
-            check [%here];
-            Var.set v1 9;
-            Var.set v2 10;
-            Var.set v3 11;
-            Var.set v4 12;
-            check [%here]
-          ;;
-
-          module Join (X : sig
-            val join : 'a t t -> 'a t
-          end) =
-          struct
-            let join = X.join
-
-            let%expect_test _ =
-              (* [join] of a constant *)
-              let o = observe (join (const (const 1))) in
-              stabilize_ [%here];
-              assert (value o = 1)
-            ;;
-
-            let%expect_test _ =
-              (* graph changes only *)
-              let a = const 3 in
-              let b = const 4 in
-              let x = Var.create_ [%here] a in
-              let o = observe (join (watch x)) in
-              let check where expect =
-                stabilize_ where;
-                [%test_result: int] (value o) ~expect
+            loop vars
+          done
+        ;;
+
+        let%expect_test _ = test exists List.exists
+        let%expect_test _ = test for_all List.for_all
+        let array_fold = array_fold
+
+        let%expect_test _ =
+          (* empty array *)
+          let o = observe (array_fold [||] ~init:13 ~f:(fun _ -> assert false)) in
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] 13 in
+          let y = Var.create_ [%here] 14 in
+          let o =
+            observe (array_fold [| watch y; watch x |] ~init:[] ~f:(fun ac x -> x :: ac))
+          in
+          let check where expect =
+            stabilize_ where;
+            [%test_result: int list] (value o) ~expect
+          in
+          check [%here] [ 13; 14 ];
+          Var.set x 15;
+          check [%here] [ 15; 14 ];
+          Var.set y 16;
+          check [%here] [ 15; 16 ];
+          Var.set x 17;
+          Var.set y 18;
+          check [%here] [ 17; 18 ]
+        ;;
+
+        let reduce_balanced = reduce_balanced
+
+        let reduce_balanced_exn a ~f ~reduce =
+          Option.value_exn (reduce_balanced a ~f ~reduce)
+        ;;
+
+        let%expect_test _ =
+          (* empty array *)
+          let f =
+            reduce_balanced
+              [||]
+              ~f:(fun _ -> assert false)
+              ~reduce:(fun _ _ -> assert false)
+          in
+          assert (Option.is_none f)
+        ;;
+
+        let%expect_test _ =
+          (* singular value *)
+          let f =
+            reduce_balanced_exn [| watch (Var.create_ [%here] 1) |] ~f:Fn.id ~reduce:( + )
+          in
+          let o = observe f in
+          stabilize_ [%here];
+          assert (value o = 1)
+        ;;
+
+        let%expect_test _ =
+          (* non-commutative function test *)
+          let list = [ "a"; "b"; "c"; "d"; "e"; "f"; "g" ] in
+          let list = List.map list ~f:(Var.create_ [%here]) in
+          let array = Array.of_list_map ~f:Var.watch list in
+          let reduce_calls = ref 0 in
+          let f =
+            reduce_balanced_exn array ~f:Fn.id ~reduce:(fun x y ->
+              incr reduce_calls;
+              x ^ y)
+          in
+          let o = observe f in
+          stabilize_ [%here];
+          [%test_eq: string] (value o) "abcdefg";
+          [%test_eq: int] !reduce_calls 6;
+          Var.set (List.hd_exn list) "z";
+          stabilize_ [%here];
+          [%test_eq: string] (value o) "zbcdefg";
+          [%test_eq: int] !reduce_calls 9
+        ;;
+
+        let%expect_test _ =
+          (* observability changes *)
+          let observe_stabilize_disallow node =
+            let o = observe node in
+            stabilize_ [%here];
+            let v = value o in
+            disallow_future_use o;
+            v
+          in
+          let v = Var.create_ [%here] 0 in
+          let res = observe_stabilize_disallow (Var.watch v) in
+          assert (res = 0);
+          (* stabilize a reduce_balanced_exn node with already stabilized children *)
+          let f = reduce_balanced_exn [| watch v |] ~f:Fn.id ~reduce:( + ) in
+          let res = observe_stabilize_disallow f in
+          assert (res = 0);
+          (* re-stabilize a reduce_balanced_exn with a stale cache of its stabilized
+             children. *)
+          Var.set v 1;
+          let res = observe_stabilize_disallow (Var.watch v) in
+          assert (res = 1);
+          let res = observe_stabilize_disallow f in
+          assert (res = 1)
+        ;;
+
+        let%expect_test _ =
+          (* multiple occurences of a node in the fold. *)
+          let x = Var.create_ [%here] 1 in
+          let f = reduce_balanced_exn [| watch x; watch x |] ~f:Fn.id ~reduce:( + ) in
+          let o = observe f in
+          let f2 =
+            reduce_balanced_exn [| watch x; watch x; watch x |] ~f:Fn.id ~reduce:( + )
+          in
+          let o2 = observe f2 in
+          stabilize_ [%here];
+          assert (value o = 2);
+          assert (value o2 = 3);
+          Var.set x 3;
+          stabilize_ [%here];
+          assert (value o = 6);
+          assert (value o2 = 9);
+          disallow_future_use o;
+          disallow_future_use o2;
+          stabilize_ [%here];
+          Var.set x 4;
+          stabilize_ [%here];
+          let o = observe f in
+          let o2 = observe f2 in
+          stabilize_ [%here];
+          assert (value o = 8);
+          assert (value o2 = 12)
+        ;;
+
+        let%expect_test _ =
+          (* general creation and updating *)
+          let module Test_value = struct
+            type t =
+              { var : int Var.t
+              ; update1 : int option
+              ; update2 : int option
+              ; update3 : int option
+              }
+
+            let quickcheck_generator =
+              let open Quickcheck.Generator.Let_syntax in
+              let update_gen =
+                let%bind weight = Float.gen_uniform_excl 0.0 3.0 in
+                Quickcheck.Generator.weighted_union
+                  [ 1.0, Quickcheck.Generator.singleton None
+                  ; weight, Int.quickcheck_generator >>| Option.some
+                  ]
               in
-              check [%here] 3;
-              Var.set x b;
-              check [%here] 4;
-              Var.set x a;
-              check [%here] 3
-            ;;
-
-            let%expect_test _ =
-              let v1 = Var.create_ [%here] 1 in
-              let v2 = Var.create_ [%here] 2 in
-              let v3 = Var.create_ [%here] (Var.watch v1) in
-              let o = observe (join (Var.watch v3)) in
-              stabilize_ [%here];
-              assert (value o = 1);
-              Var.set v1 13;
-              stabilize_ [%here];
-              assert (value o = 13);
-              Var.set v3 (Var.watch v2);
-              stabilize_ [%here];
-              assert (value o = 2);
-              Var.set v3 (Var.watch v1);
-              Var.set v1 14;
-              stabilize_ [%here];
-              assert (value o = 14)
+              let%map var = Int.quickcheck_generator >>| Var.create_ [%here]
+              and update1 = update_gen
+              and update2 = update_gen
+              and update3 = update_gen in
+              { var; update1; update2; update3 }
             ;;
-
-            let%expect_test _ =
-              (* an invalid unused rhs doesn't invalidate the [join] *)
-              let x = Var.create_ [%here] (const 0) in
-              let lhs = Var.create_ [%here] 1 in
-              let o1 =
+          end
+          in
+          Quickcheck.test
+            (let open Quickcheck.Let_syntax in
+             let%map test_value = List.gen_non_empty Test_value.quickcheck_generator in
+             test_value)
+            (* Trials limited because incremental tests can take time on the order of
+               milliseconds each, due to the invariant checking. *)
+            ~trials:100
+            ~f:(fun test_values ->
+              let array =
+                Array.of_list_map test_values ~f:(fun test_value -> watch test_value.var)
+              in
+              let len = Array.length array in
+              let reduce_count = ref 0 in
+              let fold_count = ref 0 in
+              let update_count = ref 0 in
+              let assert_expected_reductions_and_reset () =
+                if !update_count = 0
+                then (
+                  assert (!fold_count = 0);
+                  assert (!reduce_count = 0))
+                else (
+                  assert (!fold_count = len);
+                  assert (
+                    !reduce_count <= Int.min (len - 1) (Int.ceil_log2 len * !update_count)));
+                fold_count := 0;
+                reduce_count := 0;
+                update_count := 0
+              in
+              let reduce_f =
+                reduce_balanced_exn array ~f:Fn.id ~reduce:(fun a b ->
+                  incr reduce_count;
+                  a * b)
+              in
+              let fold_f =
+                array_fold array ~init:1 ~f:(fun a b ->
+                  incr fold_count;
+                  a * b)
+              in
+              update_count := len;
+              let reduce_o = observe reduce_f in
+              let fold_o = observe fold_f in
+              stabilize_ [%here];
+              assert (value fold_o = value reduce_o);
+              assert_expected_reductions_and_reset ();
+              List.iter test_values ~f:(fun test_value ->
+                Option.iter test_value.update1 ~f:(fun a ->
+                  Var.set test_value.var a;
+                  incr update_count));
+              stabilize_ [%here];
+              assert (value fold_o = value reduce_o);
+              assert_expected_reductions_and_reset ();
+              List.iter test_values ~f:(fun test_value ->
+                let updated = ref false in
+                Option.iter test_value.update2 ~f:(fun a ->
+                  Var.set test_value.var a;
+                  updated := true);
+                Option.iter test_value.update3 ~f:(fun a ->
+                  Var.set test_value.var a;
+                  updated := true);
+                if !updated then incr update_count);
+              stabilize_ [%here];
+              assert (value fold_o = value reduce_o);
+              assert_expected_reductions_and_reset ())
+        ;;
+
+        module Unordered_array_fold_update = Unordered_array_fold_update
+
+        let unordered_array_fold = unordered_array_fold
+
+        let%expect_test _ =
+          (* empty array *)
+          let o =
+            observe
+              (unordered_array_fold
+                 ~full_compute_every_n_changes:0
+                 [||]
+                 ~init:13
+                 ~f:(fun _ -> assert false)
+                 ~update:(F_inverse (fun _ -> assert false)))
+          in
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let%expect_test _ =
+          (* an unnecessary [unordered_array_fold] isn't computed. *)
+          let x = Var.create_ [%here] 1 in
+          let num_f_inverse = ref 0 in
+          let ox = observe (Var.watch x) in
+          let fold =
+            unordered_array_fold
+              [| Var.watch x |]
+              ~init:0
+              ~f:( + )
+              ~update:
+                (F_inverse
+                   (fun b a ->
+                     incr num_f_inverse;
+                     b - a))
+          in
+          let r = observe fold in
+          stabilize_ [%here];
+          assert (value r = 1);
+          assert (!num_f_inverse = 0);
+          Var.set x 2;
+          stabilize_ [%here];
+          assert (value r = 2);
+          assert (!num_f_inverse = 1);
+          disallow_future_use r;
+          Var.set x 3;
+          stabilize_ [%here];
+          assert (!num_f_inverse = 1);
+          assert (value ox = 3);
+          let r = observe fold in
+          stabilize_ [%here];
+          [%test_result: int] (value r) ~expect:3;
+          assert (!num_f_inverse = 1)
+        ;;
+
+        let%expect_test _ =
+          (* multiple occurences of a node in the fold. *)
+          let x = Var.create_ [%here] 1 in
+          let f =
+            unordered_array_fold
+              [| watch x; watch x |]
+              ~init:0
+              ~f:( + )
+              ~update:(F_inverse ( - ))
+          in
+          let o = observe f in
+          stabilize_ [%here];
+          assert (value o = 2);
+          Var.set x 3;
+          stabilize_ [%here];
+          assert (value o = 6);
+          disallow_future_use o;
+          stabilize_ [%here];
+          Var.set x 4;
+          stabilize_ [%here];
+          let o = observe f in
+          stabilize_ [%here];
+          assert (value o = 8)
+        ;;
+
+        let%expect_test "[~update:(Update _)]" =
+          let x = Var.create_ [%here] 1 in
+          let fold =
+            unordered_array_fold
+              [| Var.watch x |]
+              ~init:0
+              ~f:( + )
+              ~update:
+                (Update (fun acc ~old_value ~new_value -> acc - old_value + new_value))
+          in
+          let r = observe fold in
+          let print () =
+            stabilize_ [%here];
+            let r = value r in
+            print_s [%sexp (r : int)]
+          in
+          print ();
+          [%expect {| 1 |}];
+          Var.set x 3;
+          print ();
+          [%expect {| 3 |}]
+        ;;
+
+        let opt_unordered_array_fold = opt_unordered_array_fold
+
+        let%expect_test _ =
+          let o =
+            observe
+              (opt_unordered_array_fold
+                 [||]
+                 ~init:()
+                 ~f:(fun _ -> assert false)
+                 ~f_inverse:(fun _ -> assert false))
+          in
+          stabilize_ [%here];
+          assert (is_some (value o))
+        ;;
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] None in
+          let y = Var.create_ [%here] None in
+          let t =
+            observe
+              (opt_unordered_array_fold
+                 [| watch x; watch y |]
+                 ~init:0
+                 ~f:( + )
+                 ~f_inverse:( - ))
+          in
+          let check where expect =
+            stabilize_ where;
+            [%test_eq: int option] (value t) expect
+          in
+          check [%here] None;
+          Var.set x (Some 13);
+          check [%here] None;
+          Var.set y (Some 14);
+          check [%here] (Some 27);
+          Var.set y None;
+          check [%here] None
+        ;;
+
+        let sum = sum
+
+        let%expect_test _ =
+          (* empty *)
+          let o =
+            observe
+              (sum
+                 [||]
+                 ~zero:13
+                 ~add:(fun _ -> assert false)
+                 ~sub:(fun _ -> assert false))
+          in
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let%expect_test _ =
+          (* full recompute *)
+          let x = Var.create_ [%here] 13. in
+          let y = Var.create_ [%here] 15. in
+          let num_adds = ref 0 in
+          let add a b =
+            incr num_adds;
+            a +. b
+          in
+          let num_subs = ref 0 in
+          let sub a b =
+            incr num_subs;
+            a -. b
+          in
+          let z =
+            observe
+              (sum
+                 [| watch x; watch y |]
+                 ~zero:0.
+                 ~add
+                 ~sub
+                 ~full_compute_every_n_changes:2)
+          in
+          stabilize_ [%here];
+          assert (!num_adds = 2);
+          assert (!num_subs = 0);
+          assert (Float.equal (value z) 28.);
+          Var.set x 17.;
+          stabilize_ [%here];
+          assert (!num_adds = 3);
+          assert (!num_subs = 1);
+          assert (Float.equal (value z) 32.);
+          Var.set y 19.;
+          stabilize_ [%here];
+          (* [num_adds] increases 2 for the full recompute.  [num_subs] doesn't change
+             because of the full recompute. *)
+          [%test_result: int] !num_adds ~expect:5;
+          [%test_result: int] !num_subs ~expect:1;
+          assert (Float.equal (value z) 36.)
+        ;;
+
+        let opt_sum = opt_sum
+
+        let%expect_test _ =
+          let t =
+            observe
+              (opt_sum
+                 [||]
+                 ~zero:()
+                 ~add:(fun _ -> assert false)
+                 ~sub:(fun _ -> assert false))
+          in
+          stabilize_ [%here];
+          assert (is_some (value t))
+        ;;
+
+        let%expect_test _ =
+          let x = Var.create_ [%here] None in
+          let y = Var.create_ [%here] None in
+          let t =
+            observe (opt_sum [| watch x; watch y |] ~zero:0 ~add:( + ) ~sub:( - ))
+          in
+          let check where expect =
+            stabilize_ where;
+            [%test_eq: int option] (value t) expect
+          in
+          check [%here] None;
+          Var.set x (Some 13);
+          check [%here] None;
+          Var.set y (Some 14);
+          check [%here] (Some 27);
+          Var.set y None;
+          check [%here] None
+        ;;
+
+        let sum_int = sum_int
+        let sum_float = sum_float
+
+        let test_sum (type a) sum (of_int : int -> a) equal =
+          let x = Var.create_ [%here] (of_int 13) in
+          let y = Var.create_ [%here] (of_int 15) in
+          let z = observe (sum [| watch x; watch y |]) in
+          stabilize_ [%here];
+          assert (equal (value z) (of_int 28));
+          stabilize_ [%here];
+          Var.set x (of_int 17);
+          stabilize_ [%here];
+          assert (equal (value z) (of_int 32));
+          Var.set x (of_int 19);
+          Var.set y (of_int 21);
+          stabilize_ [%here];
+          assert (equal (value z) (of_int 40))
+        ;;
+
+        let%expect_test _ = test_sum sum_int Fn.id Int.equal
+        let%expect_test _ = test_sum sum_float Float.of_int Float.equal
+
+        let%expect_test _ =
+          let o = observe (sum_float [||]) in
+          stabilize_ [%here];
+          [%test_result: Float.t] (value o) ~expect:0.
+        ;;
+
+        module Clock = Clock
+
+        let%expect_test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let w = observe (Clock.watch_now clock) in
+          stabilize_ [%here];
+          let before_advance = Clock.now clock in
+          assert (Time_ns.equal before_advance (value w));
+          let to_ = Time_ns.add before_advance (sec 1.) in
+          Clock.advance_clock clock ~to_;
+          assert (Time_ns.equal (Clock.now clock) to_);
+          assert (Time_ns.equal (value w) before_advance);
+          (* we didn't yet stabilize *)
+          stabilize_ [%here];
+          assert (Time_ns.equal (value w) to_)
+        ;;
+
+        let%expect_test "[advance_clock] backwards" =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let o = observe (Clock.watch_now clock) in
+          let show_now () =
+            stabilize_ [%here];
+            print_s [%sexp (Clock.now clock : Time_ns.t), (value o : Time_ns.t)]
+          in
+          show_now ();
+          [%expect
+            {|
+            ((1969-12-31 19:00:00.000000000-05:00)
+             (1969-12-31 19:00:00.000000000-05:00))
+            |}];
+          Clock.advance_clock clock ~to_:(Time_ns.add Time_ns.epoch (sec 1.));
+          show_now ();
+          [%expect
+            {|
+            ((1969-12-31 19:00:01.000000000-05:00)
+             (1969-12-31 19:00:01.000000000-05:00))
+            |}];
+          Clock.advance_clock clock ~to_:Time_ns.epoch;
+          show_now ();
+          [%expect
+            {|
+            ((1969-12-31 19:00:01.000000000-05:00)
+             (1969-12-31 19:00:01.000000000-05:00))
+            |}]
+        ;;
+
+        let is observer v = Poly.equal (value observer) v
+
+        let%expect_test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let o = observe (Clock.after clock (sec 1.)) in
+          let show () =
+            stabilize_ [%here];
+            print_s [%sexp (value o : Before_or_after.t)]
+          in
+          show ();
+          [%expect {| Before |}];
+          Clock.advance_clock_by clock (sec 1.);
+          show ();
+          [%expect {| After |}];
+          Clock.advance_clock_by clock (Clock.alarm_precision clock);
+          show ();
+          [%expect {| After |}]
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          is_invalidated_on_bind_rhs (fun _ ->
+            Clock.at clock (Time_ns.add (Clock.now clock) (sec 1.)))
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
+          is_invalidated_on_bind_rhs (fun _ ->
+            Clock.at clock (Time_ns.add (Clock.now clock) (sec (-1.))))
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          is_invalidated_on_bind_rhs (fun _ -> Clock.after clock (sec 1.))
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
+          is_invalidated_on_bind_rhs (fun _ -> Clock.after clock (sec (-1.)))
+        ;;
+
+        let%expect_test _ =
+          let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
+          let now = Clock.now clock in
+          let at span = observe (Clock.at clock (Time_ns.add now span)) in
+          let i1 = at (sec (-1.)) in
+          let i2 = at (sec (-0.1)) in
+          let i3 = at (sec 1.) in
+          stabilize_ [%here];
+          assert (is i1 After);
+          assert (is i2 After);
+          assert (is i3 Before);
+          Clock.advance_clock_by clock (sec 0.5);
+          stabilize_ [%here];
+          assert (is i1 After);
+          assert (is i2 After);
+          assert (is i3 Before);
+          Clock.advance_clock_by clock (sec 1.);
+          stabilize_ [%here];
+          assert (is i1 After);
+          assert (is i2 After);
+          assert (is i3 After)
+        ;;
+
+        let%expect_test _ =
+          (* advancing the clock in the same stabilization cycle as creation *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = observe (Clock.after clock (sec 1.)) in
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          assert (is i After)
+        ;;
+
+        let%expect_test _ =
+          (* firing an unnecessary [after] and then observing it *)
+          let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
+          let i = Clock.after clock (sec (-1.)) in
+          stabilize_ [%here];
+          let o = observe i in
+          stabilize_ [%here];
+          assert (is o After);
+          let r = ref 0 in
+          let i =
+            Clock.after clock (sec 1.)
+            >>| fun z ->
+            incr r;
+            z
+          in
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          assert (!r = 0);
+          stabilize_ [%here];
+          let o = observe i in
+          stabilize_ [%here];
+          assert (!r = 1);
+          assert (is o After)
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          does_raise (fun () -> Clock.at_intervals clock (sec (-1.)))
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          does_raise (fun () -> Clock.at_intervals clock (sec 0.))
+        ;;
+
+        let%test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          is_invalidated_on_bind_rhs (fun _ -> Clock.at_intervals clock (sec 1.))
+        ;;
+
+        let%expect_test _ =
+          (* advancing the clock does nothing by itself *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let r = ref 0 in
+          let i = Clock.at_intervals clock (sec 1.) >>| fun () -> incr r in
+          let o = observe i in
+          assert (!r = 0);
+          Clock.advance_clock_by clock (sec 2.);
+          assert (!r = 0);
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let r = ref (-1) in
+          let i = Clock.at_intervals clock (sec 1.) >>| fun () -> incr r in
+          let o = observe i in
+          stabilize_ [%here];
+          let show_r () = print_s [%sexp (!r : int)] in
+          show_r ();
+          [%expect {| 0 |}];
+          Clock.advance_clock_by clock (sec 0.5);
+          stabilize_ [%here];
+          show_r ();
+          [%expect {| 0 |}];
+          Clock.advance_clock_by clock (sec 1.);
+          stabilize_ [%here];
+          show_r ();
+          [%expect {| 1 |}];
+          Clock.advance_clock_by clock (sec 1.);
+          show_r ();
+          [%expect {| 1 |}];
+          Clock.advance_clock_by clock (sec 1.);
+          show_r ();
+          [%expect {| 1 |}];
+          Clock.advance_clock_by clock (sec 1.);
+          show_r ();
+          [%expect {| 1 |}];
+          stabilize_ [%here];
+          show_r ();
+          [%expect {| 2 |}];
+          Clock.advance_clock_by clock (sec 10.);
+          stabilize_ [%here];
+          show_r ();
+          [%expect {| 3 |}];
+          disallow_future_use o;
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          show_r ();
+          [%expect {| 3 |}];
+          let o = observe i in
+          stabilize_ [%here];
+          show_r ();
+          [%expect {| 4 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* advancing exactly to intervals doesn't skip any *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let r = ref (-1) in
+          let o = observe (Clock.at_intervals clock (sec 1.) >>| fun () -> incr r) in
+          stabilize_ [%here];
+          [%test_result: int] !r ~expect:0;
+          let base = Clock.now clock in
+          let curr = ref base in
+          for i = 1 to 20 do
+            curr := Time_ns.next_multiple ~base ~after:!curr ~interval:(sec 1.) ();
+            Clock.advance_clock clock ~to_:!curr;
+            stabilize_ [%here];
+            [%test_result: int] !r ~expect:i
+          done;
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* [interval < alarm precision] raises *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          assert (does_raise (fun () -> Clock.at_intervals clock (sec 0.0005)))
+        ;;
+
+        let%expect_test _ =
+          (* [at] in the past *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          assert (
+            is_error
+              (Clock.snapshot
+                 clock
+                 (const 14)
+                 ~at:(Time_ns.sub (Clock.now clock) (sec 1.))
+                 ~before:13))
+        ;;
+
+        let%expect_test _ =
+          (* [at] in the future *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let o =
+            observe
+              (ok_exn
+                 (Clock.snapshot
+                    clock
+                    (const 14)
+                    ~at:(Time_ns.add (Clock.now clock) (sec 1.))
+                    ~before:13))
+          in
+          stabilize_ [%here];
+          assert (value o = 13);
+          stabilize_ [%here];
+          Clock.advance_clock_by clock (sec 2.);
+          assert (value o = 13);
+          stabilize_ [%here];
+          assert (value o = 14)
+        ;;
+
+        let%expect_test _ =
+          (* [at] in the future, unobserved *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x = Var.create_ [%here] 13 in
+          let i =
+            ok_exn
+              (Clock.snapshot
+                 clock
+                 (Var.watch x)
+                 ~at:(Time_ns.add (Clock.now clock) (sec 1.))
+                 ~before:15)
+          in
+          stabilize_ [%here];
+          Var.set x 17;
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          Var.set x 19;
+          let o = observe i in
+          stabilize_ [%here];
+          assert (value o = 17)
+        ;;
+
+        let%expect_test _ =
+          (* [advance_clock] past [at] prior to stabilization. *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let o =
+            observe
+              (ok_exn
+                 (Clock.snapshot
+                    clock
+                    (const 15)
+                    ~at:(Time_ns.add (Clock.now clock) (sec 1.))
+                    ~before:13))
+          in
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          assert (value o = 15)
+        ;;
+
+        let%expect_test _ =
+          (* unobserved, [advance_clock] past [at] prior to stabilization. *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x = Var.create_ [%here] 13 in
+          let i =
+            ok_exn
+              (Clock.snapshot
+                 clock
+                 (Var.watch x)
+                 ~at:(Time_ns.add (Clock.now clock) (sec 1.))
+                 ~before:15)
+          in
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          Var.set x 17;
+          let o = observe i in
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let%expect_test _ =
+          (* invalidated *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let t =
+            ok_exn
+              (Clock.snapshot
+                 clock
+                 invalid
+                 ~at:(Time_ns.add (Clock.now clock) (sec 1.))
+                 ~before:13)
+          in
+          let o = observe t in
+          stabilize_ [%here];
+          assert (value o = 13);
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          assert (skip_invalidity_check || not (is_valid t));
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* [snapshot] nodes increment [num_nodes_became_necessary] *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i1 = State.(num_nodes_became_necessary t) in
+          let c = const () in
+          for _ = 1 to 5 do
+            ignore
+              (ok_exn
+                 (Clock.snapshot
+                    clock
+                    c
+                    ~at:(Time_ns.add (Clock.now clock) (sec 1.))
+                    ~before:())
+               : _ t)
+          done;
+          Clock.advance_clock_by clock (sec 2.);
+          let i2 = State.(num_nodes_became_necessary t) in
+          (* the 5 [snapshot]s that became [freeze] plus the [const] *)
+          [%test_result: int] i2 ~expect:(i1 + 6)
+        ;;
+
+        let relative_step_function clock ~init steps =
+          let now = Clock.now clock in
+          Step_function.create_exn
+            ~init
+            ~steps:
+              (List.map steps ~f:(fun (after, a) ->
+                 Time_ns.add now (sec (Float.of_int after)), a))
+        ;;
+
+        let relative_step_function_incr clock ~init steps =
+          Clock.step_function
+            clock
+            ~init
+            (List.map steps ~f:(fun (after, a) ->
+               Time_ns.add (Clock.now clock) (sec (Float.of_int after)), a))
+        ;;
+
+        let%expect_test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          require
+            (is_invalidated_on_bind_rhs (fun i -> Clock.step_function clock ~init:i []))
+        ;;
+
+        let%expect_test _ =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          require
+            (is_invalidated_on_bind_rhs (fun i ->
+               relative_step_function_incr clock ~init:i [ 1, i + 1 ]))
+        ;;
+
+        let%expect_test _ =
+          (* no steps *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = Clock.step_function clock ~init:13 [] in
+          let o = observe i in
+          stabilize_ [%here];
+          print_s [%sexp (value o : int)];
+          [%expect {| 13 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* one step at a time *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = relative_step_function_incr clock ~init:13 [ 1, 14; 2, 15 ] in
+          let o = observe i in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 13 |}];
+          Clock.advance_clock_by clock (sec 1.5);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 14 |}];
+          Clock.advance_clock_by clock (sec 1.);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 15 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* all steps in the past *)
+          let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 2.)) () in
+          let i = relative_step_function_incr clock ~init:13 [ -2, 14; -1, 15 ] in
+          let o = observe i in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 15 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* some steps in the past *)
+          let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
+          let i = relative_step_function_incr clock ~init:13 [ -1, 14; 1, 15 ] in
+          let o = observe i in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 14 |}];
+          Clock.advance_clock_by clock (sec 1.5);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 15 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* cross multiple steps in one stabilization cycle *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = relative_step_function_incr clock ~init:13 [ 1, 14; 2, 15 ] in
+          let o = observe i in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 13 |}];
+          Clock.advance_clock_by clock (sec 1.5);
+          Clock.advance_clock_by clock (sec 1.);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 15 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* cross step in same stabilization as creation *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = relative_step_function_incr clock ~init:13 [ 1, 14 ] in
+          let o = observe i in
+          let show () = print_s [%sexp (value o : int)] in
+          Clock.advance_clock_by clock (sec 2.);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 14 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* observe after step *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = relative_step_function_incr clock ~init:13 [ 1, 14 ] in
+          stabilize_ [%here];
+          Clock.advance_clock_by clock (sec 1.5);
+          stabilize_ [%here];
+          let o = observe i in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 14 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* advancing exactly to steps doesn't skip steps *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let base = Clock.now clock in
+          let curr = ref base in
+          let steps = ref [] in
+          for i = 1 to 20 do
+            curr := Time_ns.next_multiple ~base ~after:!curr ~interval:(sec 1.) ();
+            steps := (!curr, i) :: !steps
+          done;
+          let steps = List.rev !steps in
+          let o = observe (Clock.step_function clock ~init:0 steps) in
+          List.iter steps ~f:(fun (to_, _) ->
+            Clock.advance_clock clock ~to_;
+            stabilize_ [%here];
+            print_s [%sexp (value o : int)]);
+          [%expect
+            {|
+            1
+            2
+            3
+            4
+            5
+            6
+            7
+            8
+            9
+            10
+            11
+            12
+            13
+            14
+            15
+            16
+            17
+            18
+            19
+            20
+            |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test "[incremental_step_function]" =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x = Var.create (Step_function.constant 1) in
+          let o = observe (Clock.incremental_step_function clock (watch x)) in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 1 |}];
+          Var.set x (Step_function.constant 2);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 2 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test "incremental step function with step in the past, present, and \
+                         future"
+          =
+          let test ~step_at =
+            let clock = Clock.create ~start:Time_ns.epoch () in
+            let x = Var.create (Step_function.constant 1) in
+            let o = observe (Clock.incremental_step_function clock (watch x)) in
+            let show () = print_s [%sexp (value o : int)] in
+            stabilize_ [%here];
+            show ();
+            [%expect {| 1 |}];
+            Var.set x (relative_step_function clock ~init:2 [ step_at, 3 ]);
+            stabilize_ [%here];
+            show ();
+            disallow_future_use o
+          in
+          test ~step_at:(-1);
+          [%expect {| 3 |}];
+          test ~step_at:0;
+          [%expect {| 3 |}];
+          test ~step_at:1;
+          [%expect {| 2 |}]
+        ;;
+
+        let%expect_test "incremental step function; advance time and change function" =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x = Var.create (relative_step_function clock ~init:13 [ 1, 14 ]) in
+          let o = observe (Clock.incremental_step_function clock (watch x)) in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 13 |}];
+          Var.set x (relative_step_function clock ~init:15 [ 1, 16 ]);
+          Clock.advance_clock_by clock (sec 1.);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 16 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test "incremental step function; change to const and then advance time"
+          =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x = Var.create (relative_step_function clock ~init:13 [ 1, 14 ]) in
+          let o = observe (Clock.incremental_step_function clock (watch x)) in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 13 |}];
+          Var.set x (Step_function.constant 15);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 15 |}];
+          Clock.advance_clock_by clock (sec 1.);
+          stabilize_ [%here];
+          show ();
+          [%expect {| 15 |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test "incremental step function is invalidated when child is" =
+          let b = Var.create true in
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let t =
+            Clock.incremental_step_function
+              clock
+              (if_ (watch b) ~then_:(const 0) ~else_:invalid >>| Step_function.constant)
+          in
+          let o = observe t in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 0 |}];
+          Var.set b false;
+          stabilize_ [%here];
+          print_s [%sexp (check_invalidity && is_valid t : bool)];
+          [%expect {| false |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test "incremental step function that becomes observable in a \
+                         stabilization after its child stabilizes"
+          =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x = Var.create (Step_function.constant 13) in
+          let ox = observe (watch x) in
+          let t = Clock.incremental_step_function clock (watch x) in
+          stabilize_ [%here];
+          let o = observe t in
+          let show () = print_s [%sexp (value o : int)] in
+          stabilize_ [%here];
+          show ();
+          [%expect {| 13 |}];
+          disallow_future_use ox;
+          disallow_future_use o
+        ;;
+
+        let%expect_test "incremental step function of const used in other places" =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let c = const (Step_function.constant 13) in
+          let c1 = c >>| fun s -> s in
+          let o1 = observe c1 in
+          let x = Clock.incremental_step_function clock c in
+          let ox = observe x in
+          stabilize_ [%here];
+          disallow_future_use o1;
+          disallow_future_use ox
+        ;;
+
+        let%expect_test _ =
+          (* Equivalence between [step_function] and reimplementation with [at] *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let my_step_function ~init steps =
+            let xs =
+              Array.map (Array.of_list steps) ~f:(fun (time, x) ->
+                map (Clock.at clock time) ~f:(function
+                  | Before -> None
+                  | After -> Some x))
+            in
+            array_fold xs ~init ~f:(fun acc x -> Option.value x ~default:acc)
+          in
+          let base = Clock.now clock in
+          let steps =
+            List.map
+              ~f:(fun (d, v) -> Time_ns.add base (sec d), v)
+              [ 1.0, 1
+              ; 1.99999, 2
+                (* It is unspecified whether this alarm has fired when the
+                 time is 2. but this test relies on the two
+                 step_functions having the same unspecified behaviour. *)
+              ; 2.0, 3
+              ; 3.00001, 4
+              ; 4.0, 5
+              ; 4.00001, 6
+              ; 5.0, 6
+              ; 6.0, 7
+              ]
+          in
+          let o1 = observe (Clock.step_function clock ~init:0 steps) in
+          let o2 = observe (my_step_function ~init:0 steps) in
+          stabilize_ [%here];
+          for i = 1 to 7 do
+            Clock.advance_clock clock ~to_:(Time_ns.add base (sec (Float.of_int i)));
+            stabilize_ [%here];
+            print_s [%sexp (value o1 : int), (value o2 : int)];
+            require (value o1 = value o2)
+          done;
+          [%expect
+            {|
+            (1 1)
+            (3 3)
+            (3 3)
+            (5 5)
+            (6 6)
+            (7 7)
+            (7 7)
+            |}];
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test "[Step_function.create_from_sequence]" =
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let x =
+            Var.create
+              (Step_function.create_from_sequence
+                 ~init:13
+                 ~steps:
+                   (Sequence.unfold
+                      ~init:(Clock.now clock, 14)
+                      ~f:(fun (at, i) ->
+                        print_s [%message "unfold" (i : int)];
+                        Some ((at, i), (Time_ns.add at (sec 1.), i + 1)))))
+          in
+          let o = observe (Clock.incremental_step_function clock (watch x)) in
+          let show () = print_s [%sexp (value o : int)] in
+          for _ = 1 to 5 do
+            Clock.advance_clock_by clock (sec 1.);
+            stabilize_ [%here];
+            show ()
+          done;
+          [%expect
+            {|
+            (unfold (i 14))
+            (unfold (i 15))
+            (unfold (i 16))
+            (unfold (i 16))
+            15
+            (unfold (i 16))
+            (unfold (i 17))
+            (unfold (i 17))
+            16
+            (unfold (i 17))
+            (unfold (i 18))
+            (unfold (i 18))
+            17
+            (unfold (i 18))
+            (unfold (i 19))
+            (unfold (i 19))
+            18
+            (unfold (i 19))
+            (unfold (i 20))
+            (unfold (i 20))
+            19
+            |}];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* Advancing to a scheduled time shouldn't break things. *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let fut = Time_ns.add (Clock.now clock) (sec 1.0) in
+          let o1 = observe (Clock.at clock fut) in
+          let o2 = observe (ok_exn (Clock.snapshot clock (const 1) ~at:fut ~before:0)) in
+          Clock.advance_clock clock ~to_:fut;
+          stabilize_ [%here];
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test _ =
+          (* alarms get cleaned up for invalidated time-based incrementals *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          List.iter
+            [ (fun () -> Clock.after clock (sec 1.) >>| fun _ -> ())
+            ; (fun () -> Clock.at_intervals clock (sec 1.))
+            ; (fun () -> relative_step_function_incr clock ~init:() [ 1, () ])
+            ]
+            ~f:(fun create_time_based_incremental ->
+              let num_alarms = Clock.timing_wheel_length clock in
+              let x = Var.create_ [%here] 0 in
+              let o =
                 observe
-                  (bind (watch lhs) ~f:(fun i ->
-                     Var.set x (const i);
-                     return ()))
+                  (bind (Var.watch x) ~f:(fun i ->
+                     if i >= 0 then create_time_based_incremental () else return ()))
               in
               stabilize_ [%here];
-              let o2 = observe (join (make_high (Var.watch x))) in
-              stabilize_ [%here];
-              Var.set lhs 2;
-              (* invalidate *)
-              Var.set x (const 3);
+              for i = 1 to 10 do
+                Var.set x i;
+                stabilize_ [%here];
+                if check_invalidity
+                then
+                  [%test_result: int]
+                    ~expect:(num_alarms + 1)
+                    (Clock.timing_wheel_length clock)
+              done;
+              Var.set x (-1);
               stabilize_ [%here];
-              assert (value o2 = 3);
-              disallow_future_use o1;
-              disallow_future_use o2
-            ;;
+              if check_invalidity
+              then
+                [%test_result: int] ~expect:num_alarms (Clock.timing_wheel_length clock);
+              disallow_future_use o)
+        ;;
 
-            let%expect_test _ =
-              (* checking that join can be invalidated *)
-              let join = join (const invalid) in
-              let o = observe join in
-              stabilize_ [%here];
-              disallow_future_use o;
-              assert (skip_invalidity_check || not (is_valid join))
-            ;;
+        module Observer = struct
+          open Observer
 
-            let%expect_test _ =
-              (* changing the rhs from a node to its ancestor, which causes problems if
-               we leave the node with a broken invariant while adding the ancestor. *)
-              let num_calls = ref 0 in
-              let rhs_var = Var.create 13 in
-              let first =
-                map (watch rhs_var) ~f:(fun i ->
-                  incr num_calls;
-                  i + 1)
-              in
-              let second = map first ~f:(fun i -> i + 1) in
-              let lhs_var = Var.create first in
-              let o = observe (join (watch lhs_var)) in
-              stabilize_ [%here];
-              [%test_result: int] !num_calls ~expect:1;
-              Var.set lhs_var second;
-              stabilize_ [%here];
-              [%test_result: int] !num_calls ~expect:1;
-              disallow_future_use o;
-              stabilize_ [%here];
-              Var.set rhs_var 14;
-              stabilize_ [%here];
-              [%test_result: int] !num_calls ~expect:1
-            ;;
-          end
+          type nonrec 'a t = 'a t [@@deriving sexp_of]
 
-          include Join (struct
-            let join = join
-          end)
+          let%expect_test "[sexp_of_t]" =
+            let t = observe (watch (Var.create 13)) in
+            let show_t () = print_s [%sexp (t : int t)] in
+            show_t ();
+            [%expect {| <unstabilized> |}];
+            stabilize_ [%here];
+            show_t ();
+            [%expect {| 13 |}];
+            disallow_future_use t;
+            show_t ();
+            [%expect {| <disallowed> |}]
+          ;;
 
-          let if_ = if_
+          let invariant = invariant
+          let observing = observing
 
           let%expect_test _ =
-            (* [if_ true] *)
-            let o = observe (if_ (const true) ~then_:(const 13) ~else_:(const 14)) in
-            stabilize_ [%here];
-            assert (value o = 13)
+            let x = Var.create_ [%here] 0 in
+            let o = observe (watch x) in
+            assert (phys_same (observing o) (watch x))
           ;;
 
+          let use_is_allowed = use_is_allowed
+
           let%expect_test _ =
-            (* [if_ false] *)
-            let o = observe (if_ (const false) ~then_:(const 13) ~else_:(const 14)) in
-            stabilize_ [%here];
-            assert (value o = 14)
+            let o = observe (watch (Var.create_ [%here] 0)) in
+            assert (use_is_allowed o);
+            disallow_future_use o;
+            assert (not (use_is_allowed o))
           ;;
 
+          let disallow_future_use = disallow_future_use
+          let value = value
+          let value_exn = value_exn
+
           let%expect_test _ =
-            (* graph changes only *)
-            let x = Var.create_ [%here] true in
-            let o = observe (if_ (watch x) ~then_:(const 3) ~else_:(const 4)) in
-            let check where expect =
-              stabilize_ where;
-              [%test_eq: int] (value o) expect
-            in
-            check [%here] 3;
-            Var.set x false;
-            check [%here] 4;
-            Var.set x true;
-            check [%here] 3;
-            Var.set x false;
-            check [%here] 4
-          ;;
-
-          let%expect_test _ =
-            let test = Var.create_ [%here] true in
-            let then_ = Var.create_ [%here] 1 in
-            let else_ = Var.create_ [%here] 2 in
-            let num_then_run = ref 0 in
-            let num_else_run = ref 0 in
-            let ite =
-              observe
-                (if_
-                   (Var.watch test)
-                   ~then_:
-                     (Var.watch then_
-                      >>| fun i ->
-                      incr num_then_run;
-                      i)
-                   ~else_:
-                     (Var.watch else_
-                      >>| fun i ->
-                      incr num_else_run;
-                      i))
-            in
-            stabilize_ [%here];
-            assert (Observer.value_exn ite = 1);
-            assert (!num_then_run = 1);
-            assert (!num_else_run = 0);
-            Var.set test false;
-            stabilize_ [%here];
-            assert (Observer.value_exn ite = 2);
-            Var.set test true;
-            stabilize_ [%here];
-            assert (Observer.value_exn ite = 1);
-            Var.set then_ 3;
-            Var.set else_ 4;
-            let ntr = !num_then_run in
-            let ner = !num_else_run in
-            stabilize_ [%here];
-            assert (Observer.value_exn ite = 3);
-            assert (!num_then_run = ntr + 1);
-            assert (!num_else_run = ner);
-            Var.set test false;
-            Var.set then_ 5;
-            Var.set else_ 6;
-            stabilize_ [%here];
-            assert (Observer.value_exn ite = 6)
-          ;;
-
-          let%expect_test _ =
-            (* an invalid unused branch doesn't invalidate the [if_] *)
-            let r = ref None in
-            let lhs = Var.create_ [%here] 1 in
-            let o1 =
-              observe
-                (bind (watch lhs) ~f:(fun i ->
-                   r := Some (const i);
-                   return ()))
-            in
-            stabilize_ [%here];
-            let else_ = Option.value_exn !r in
-            let test = Var.create_ [%here] false in
-            let o2 = observe (if_ (make_high (watch test)) ~then_:(const 13) ~else_) in
-            stabilize_ [%here];
-            Var.set lhs 2;
-            (* invalidates [else_]. *)
-            Var.set test true;
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid else_));
-            assert (value o2 = 13);
-            disallow_future_use o1;
-            disallow_future_use o2
-          ;;
-
-          let%expect_test _ =
-            (* if-then-else created with an invalid test *)
-            let o =
-              observe
-                (if_ (invalid >>| fun _ -> true) ~then_:(const ()) ~else_:(const ()))
-            in
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
-          ;;
-
-          let%expect_test _ =
-            (* if-then-else created with an invalid branch *)
-            let o = observe (if_ (const true) ~then_:invalid ~else_:(const 13)) in
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
-          ;;
-
-          let%expect_test _ =
-            (* if-then-else switching to an invalid branch *)
-            let b = Var.create false in
-            let o = observe (if_ (Var.watch b) ~then_:invalid ~else_:(const 13)) in
-            stabilize_ [%here];
-            assert (is_valid (Observer.observing o));
-            Var.set b true;
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
-          ;;
-
-          let%expect_test _ =
-            (* if-then-else switching to an invalid branch via a map *)
-            let b = Var.create false in
-            let o =
-              observe
-                (if_ (Var.watch b) ~then_:(invalid >>| fun _ -> 13) ~else_:(const 13))
-            in
-            stabilize_ [%here];
-            assert (is_valid (Observer.observing o));
-            Var.set b true;
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
-          ;;
-
-          let%expect_test _ =
-            (* if-then-else switching to an invalid test *)
-            let b = Var.create false in
-            let o =
-              observe
-                (if_
-                   (if_
-                      (Var.watch b)
-                      ~then_:(invalid >>| fun _ -> true)
-                      ~else_:(const true))
-                   ~then_:(const 13)
-                   ~else_:(const 15))
-            in
-            stabilize_ [%here];
-            assert (is_valid (Observer.observing o));
-            Var.set b true;
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid (Observer.observing o)))
-          ;;
-
-          let%expect_test _ =
-            (* changing branches from a node to its ancestor, which causes problems if
-             we leave the node with a broken invariant while adding the ancestor. *)
-            let test_var = Var.create false in
-            let num_calls = ref 0 in
-            let branch_var = Var.create 13 in
-            let else_ =
-              map (watch branch_var) ~f:(fun i ->
-                incr num_calls;
-                i + 1)
-            in
-            let then_ = map else_ ~f:(fun i -> i + 1) in
-            let o = observe (if_ (watch test_var) ~then_ ~else_) in
-            stabilize_ [%here];
-            [%test_result: int] !num_calls ~expect:1;
-            Var.set test_var true;
-            stabilize_ [%here];
-            [%test_result: int] !num_calls ~expect:1;
-            disallow_future_use o;
-            stabilize_ [%here];
-            Var.set branch_var 14;
-            stabilize_ [%here];
-            [%test_result: int] !num_calls ~expect:1
-          ;;
-
-          let freeze = freeze
-
-          let%expect_test _ =
-            let x = Var.create_ [%here] 13 in
-            let f = freeze (Var.watch x) in
-            let y = observe f in
-            assert (not (is_const f));
-            stabilize_ [%here];
-            assert (value y = 13);
-            assert (is_const f);
-            let u = Var.create_ [%here] 1 in
-            let z = observe (bind (Var.watch u) ~f:(fun _ -> freeze (Var.watch x))) in
-            stabilize_ [%here];
-            assert (value z = 13);
-            Var.set u 2;
-            Var.set x 14;
-            stabilize_ [%here];
-            assert (value z = 14);
-            Var.set x 15;
-            stabilize_ [%here];
-            assert (value z = 14);
-            Var.set u 3;
-            stabilize_ [%here];
-            assert (value z = 15)
-          ;;
-
-          let%expect_test _ =
-            let x = Var.create_ [%here] 13 in
-            let o1 = observe (freeze (Var.watch x >>| Fn.id)) in
-            let o2 = observe (Var.watch x >>| Fn.id) in
-            stabilize_ [%here];
-            assert (value o1 = 13);
-            assert (value o2 = 13);
-            stabilize_ [%here];
-            assert (value o1 = 13);
-            assert (value o2 = 13);
-            Var.set x 14;
-            stabilize_ [%here];
-            assert (value o1 = 13);
-            assert (value o2 = 14)
-          ;;
-
-          let%expect_test _ =
-            (* [freeze] nodes increment [num_nodes_became_necessary] *)
-            let i1 = State.(num_nodes_became_necessary t) in
-            ignore (freeze (const ()) : unit t);
-            let i2 = State.(num_nodes_became_necessary t) in
-            [%test_result: int] i2 ~expect:(i1 + 2)
-          ;;
-
-          (* one for the [const], one for the [freeze] *)
-
-          (* TEST_UNIT = (\* freeze nodes leak memory (and forces spurious computations) until
-           *                they freeze *\)
-           *   let c = const () in
-           *   for i = 0 to 100_000_000 do
-           *     ignore (freeze c ~when_:(fun () -> false) : unit t);
-           *     if i mod 1000 = 0 then begin
-           *       Printf.printf "num parents %d\n%!" ((Obj.magic c : int array).(7));
-           *       stabilize_ [%here];
-           *     end
-           *   done;
-           * ;; *)
-
-          let%expect_test _ =
-            (* [freeze]ing something that is otherwise unnecessary. *)
+            (* calling [value] before stabilizing returns error. *)
             let x = Var.create_ [%here] 0 in
-            let i = freeze (Var.watch x >>| fun i -> i + 1) in
-            stabilize_ [%here];
-            Var.set x 13;
-            let o = observe i in
-            stabilize_ [%here];
-            assert (value o = 1 (* not 14 *))
-          ;;
-
-          let%expect_test _ =
-            (* a frozen node remains valid, even if its original scope isn't *)
-            let x = Var.create_ [%here] 13 in
-            let r = ref None in
-            let o1 =
-              observe
-                (watch x
-                 >>= fun i ->
-                 if Option.is_none !r then r := Some (freeze (const i));
-                 const ())
-            in
-            stabilize_ [%here];
-            let f = Option.value_exn !r in
-            Var.set x 15;
-            stabilize_ [%here];
-            let o2 = observe f in
-            stabilize_ [%here];
-            assert (is_const f);
-            assert (value o2 = 13);
-            disallow_future_use o1;
-            stabilize_ [%here]
-          ;;
-
-          let%expect_test _ =
-            (* a frozen node remains valid, even if the node it froze isn't *)
-            let x = Var.create_ [%here] 13 in
-            let r = ref (const 14) in
-            let o1 =
-              observe
-                (watch x
-                 >>= fun i ->
-                 r := const i;
-                 const ())
-            in
-            stabilize_ [%here];
-            let o2 = observe (freeze !r) in
-            stabilize_ [%here];
-            Var.set x 15;
-            stabilize_ [%here];
-            assert (value o2 = 13);
-            disallow_future_use o1
-          ;;
-
-          let%expect_test _ =
-            (* [freeze ~when] *)
-            let x = Var.create_ [%here] 13 in
-            let o = observe (freeze (watch x) ~when_:(fun i -> i >= 15)) in
-            let check where expect =
-              stabilize_ where;
-              [%test_result: int] (value o) ~expect
-            in
-            check [%here] 13;
-            Var.set x 14;
-            check [%here] 14;
-            Var.set x 15;
-            check [%here] 15;
-            Var.set x 16;
-            check [%here] 15;
-            Var.set x 14;
-            check [%here] 15
-          ;;
-
-          let%expect_test _ =
-            (* a freeze that is invalidated before it is frozen. *)
-            let r = ref None in
-            let x = Var.create_ [%here] 13 in
-            let o =
-              observe
-                (bind (watch x) ~f:(fun i ->
-                   r := Some (const i);
-                   return ()))
-            in
-            stabilize_ [%here];
-            let f = freeze (Option.value_exn !r) ~when_:(fun _ -> false) in
-            Var.set x 14;
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid f));
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* a freeze that is stabilized and invalidated before it is frozen. *)
-            let r = ref None in
-            let x = Var.create_ [%here] 13 in
-            let o =
-              observe
-                (bind (watch x) ~f:(fun i ->
-                   r := Some (const i);
-                   return ()))
-            in
-            stabilize_ [%here];
-            let f = freeze (Option.value_exn !r) ~when_:(fun _ -> false) in
-            stabilize_ [%here];
-            Var.set x 14;
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid f));
-            disallow_future_use o
+            let o = observe (watch x) in
+            assert (is_error (value o));
+            assert (does_raise (fun () -> value_exn o))
           ;;
 
-          let depend_on = depend_on
-
           let%expect_test _ =
+            (* calling [value] on a just-created observer of an already computed
+               incremental before stabilizing returns error. *)
             let x = Var.create_ [%here] 13 in
-            let y = Var.create_ [%here] 14 in
-            let d = depend_on (watch x) ~depend_on:(watch y) in
-            let o = observe d in
-            let nx = ref 0 in
-            let incr_o r = function
-              | Observer.Update.Invalidated -> assert false
-              | Initialized _ | Changed _ -> incr r
-            in
-            let incr r = function
-              | Update.Invalidated -> assert false
-              | Unnecessary -> ()
-              | Necessary _ | Changed _ -> incr r
-            in
-            Observer.on_update_exn o ~f:(incr_o nx);
-            let ny = ref 0 in
-            on_update (Var.watch y) ~f:(incr ny);
-            let check where eo enx eny =
-              stabilize_ where;
-              [%test_result: int] (value o) ~expect:eo;
-              [%test_result: int] !nx ~expect:enx;
-              [%test_result: int] !ny ~expect:eny
-            in
-            check [%here] 13 1 1;
-            Var.set x 15;
-            check [%here] 15 2 1;
-            Var.set y 16;
-            check [%here] 15 2 2;
-            Var.set x 17;
-            Var.set y 18;
-            check [%here] 17 3 3;
-            Var.set x 17;
-            check [%here] 17 3 3;
-            Var.set y 18;
-            check [%here] 17 3 3;
-            disallow_future_use o;
-            let check where enx eny =
-              stabilize_ where;
-              [%test_result: int] !nx ~expect:enx;
-              [%test_result: int] !ny ~expect:eny
-            in
-            Var.set x 19;
-            Var.set y 20;
-            check [%here] 3 3;
-            let o = observe d in
-            Observer.on_update_exn o ~f:(incr_o nx);
-            check [%here] 4 4;
-            [%test_result: int] (value o) ~expect:19
-          ;;
-
-          let%expect_test _ =
-            (* propagating the first argument of [depend_on] while the result of
-             [depend_on] is not observable *)
-            let var = Var.create 1 in
-            let depend = depend_on (Var.watch var) ~depend_on:(const ()) in
-            let o = observe depend in
-            stabilize_ [%here];
-            assert (Observer.value_exn o = 1);
-            disallow_future_use o;
-            let o = observe (Var.watch var) in
-            Var.set var 2;
+            let o = observe (watch x) in
             stabilize_ [%here];
-            assert (Observer.value_exn o = 2);
             disallow_future_use o;
-            let o = observe depend in
-            stabilize_ [%here];
-            [%test_eq: int] (Observer.value_exn o) 2
-          ;;
-
-          let%expect_test _ =
-            (* depend_on doesn't cutoff using phys_equal *)
-            let v1 = Var.create () in
-            let v2 = Var.create 1 in
-            set_cutoff (Var.watch v1) Cutoff.never;
-            let o = observe (depend_on (Var.watch v1) ~depend_on:(Var.watch v2)) in
-            let updates = ref 0 in
-            Observer.on_update_exn o ~f:(fun _ -> incr updates);
-            [%test_eq: int] !updates 0;
-            stabilize_ [%here];
-            [%test_eq: int] !updates 1;
-            Var.set v2 2;
-            stabilize_ [%here];
-            [%test_eq: int] !updates 1;
-            Var.set v1 ();
-            stabilize_ [%here];
-            [%test_eq: int] !updates 2;
-            disallow_future_use o
-          ;;
-
-          let necessary_if_alive = necessary_if_alive
-
-          let%expect_test _ =
-            (* dead => unnecessary *)
-            let x = Var.create 13 in
-            let push, check = on_update_queue () in
-            on_update (watch x) ~f:push;
-            stabilize_ [%here];
-            check [ Unnecessary ];
-            let t = necessary_if_alive (watch x) in
-            stabilize_ [%here];
-            check [ Necessary 13 ];
             Var.set x 14;
             stabilize_ [%here];
-            check [ Changed (13, 14) ];
-            Gc.keep_alive t;
-            Gc.full_major ();
-            stabilize_ [%here];
-            check [ Unnecessary ]
+            Var.set x 15;
+            let o = observe (watch x) in
+            assert (is_error (value o));
+            assert (does_raise (fun () -> value_exn o))
           ;;
 
           let%expect_test _ =
-            (* cutoff is preserved *)
-            let x = Var.create 13 in
-            set_cutoff (watch x) Cutoff.never;
-            let t = necessary_if_alive (watch x) in
-            let o = observe t in
-            let push, check = on_update_queue () in
-            on_update t ~f:push;
-            stabilize_ [%here];
-            check [ Necessary 13 ];
-            Var.set x 14;
-            stabilize_ [%here];
-            check [ Changed (13, 14) ];
-            Var.set x 14;
+            (* calling [value] after [disallow_future_use] returns error. *)
+            let x = Var.create_ [%here] 0 in
+            let o = observe (watch x) in
             stabilize_ [%here];
-            check [ Changed (14, 14) ];
             disallow_future_use o;
-            Gc.full_major ();
-            stabilize_ [%here];
-            check [ Unnecessary ]
-          ;;
-
-          let all = all
-          let both = both
-          let exists = exists
-          let for_all = for_all
-
-          let test q list_f =
-            for num_vars = 0 to 3 do
-              let vars = List.init num_vars ~f:(fun _ -> Var.create_ [%here] true) in
-              let q = observe (q (Array.of_list_map vars ~f:watch)) in
-              let all = observe (all (List.map vars ~f:watch)) in
-              let rec loop vars =
-                match vars with
-                | [] ->
-                  stabilize_ [%here];
-                  [%test_eq: Bool.t] (value q) (list_f (value all) ~f:Fn.id)
-                | var :: vars ->
-                  List.iter [ false; true ] ~f:(fun b ->
-                    Var.set var b;
-                    loop vars)
-              in
-              loop vars
-            done
-          ;;
-
-          let%expect_test _ = test exists List.exists
-          let%expect_test _ = test for_all List.for_all
-          let array_fold = array_fold
-
-          let%expect_test _ =
-            (* empty array *)
-            let o = observe (array_fold [||] ~init:13 ~f:(fun _ -> assert false)) in
-            stabilize_ [%here];
-            assert (value o = 13)
-          ;;
-
-          let%expect_test _ =
-            let x = Var.create_ [%here] 13 in
-            let y = Var.create_ [%here] 14 in
-            let o =
-              observe
-                (array_fold [| watch y; watch x |] ~init:[] ~f:(fun ac x -> x :: ac))
-            in
-            let check where expect =
-              stabilize_ where;
-              [%test_result: int list] (value o) ~expect
-            in
-            check [%here] [ 13; 14 ];
-            Var.set x 15;
-            check [%here] [ 15; 14 ];
-            Var.set y 16;
-            check [%here] [ 15; 16 ];
-            Var.set x 17;
-            Var.set y 18;
-            check [%here] [ 17; 18 ]
+            assert (is_error (value o));
+            assert (does_raise (fun () -> value_exn o))
           ;;
 
-          let reduce_balanced = reduce_balanced
-
-          let reduce_balanced_exn a ~f ~reduce =
-            Option.value_exn (reduce_balanced a ~f ~reduce)
-          ;;
-
-          let%expect_test _ =
-            (* empty array *)
-            let f =
-              reduce_balanced
-                [||]
-                ~f:(fun _ -> assert false)
-                ~reduce:(fun _ _ -> assert false)
-            in
-            assert (Option.is_none f)
-          ;;
-
-          let%expect_test _ =
-            (* singular value *)
-            let f =
-              reduce_balanced_exn
-                [| watch (Var.create_ [%here] 1) |]
-                ~f:Fn.id
-                ~reduce:( + )
-            in
-            let o = observe f in
-            stabilize_ [%here];
-            assert (value o = 1)
-          ;;
-
-          let%expect_test _ =
-            (* non-commutative function test *)
-            let list = [ "a"; "b"; "c"; "d"; "e"; "f"; "g" ] in
-            let list = List.map list ~f:(Var.create_ [%here]) in
-            let array = Array.of_list_map ~f:Var.watch list in
-            let reduce_calls = ref 0 in
-            let f =
-              reduce_balanced_exn array ~f:Fn.id ~reduce:(fun x y ->
-                incr reduce_calls;
-                x ^ y)
-            in
-            let o = observe f in
-            stabilize_ [%here];
-            [%test_eq: string] (value o) "abcdefg";
-            [%test_eq: int] !reduce_calls 6;
-            Var.set (List.hd_exn list) "z";
-            stabilize_ [%here];
-            [%test_eq: string] (value o) "zbcdefg";
-            [%test_eq: int] !reduce_calls 9
-          ;;
-
-          let%expect_test _ =
-            (* observability changes *)
-            let observe_stabilize_disallow node =
-              let o = observe node in
-              stabilize_ [%here];
-              let v = value o in
-              disallow_future_use o;
-              v
-            in
-            let v = Var.create_ [%here] 0 in
-            let res = observe_stabilize_disallow (Var.watch v) in
-            assert (res = 0);
-            (* stabilize a reduce_balanced_exn node with already stabilized children *)
-            let f = reduce_balanced_exn [| watch v |] ~f:Fn.id ~reduce:( + ) in
-            let res = observe_stabilize_disallow f in
-            assert (res = 0);
-            (* re-stabilize a reduce_balanced_exn with a stale cache of its stabilized
-             children. *)
-            Var.set v 1;
-            let res = observe_stabilize_disallow (Var.watch v) in
-            assert (res = 1);
-            let res = observe_stabilize_disallow f in
-            assert (res = 1)
-          ;;
-
-          let%expect_test _ =
-            (* multiple occurences of a node in the fold. *)
-            let x = Var.create_ [%here] 1 in
-            let f = reduce_balanced_exn [| watch x; watch x |] ~f:Fn.id ~reduce:( + ) in
-            let o = observe f in
-            let f2 =
-              reduce_balanced_exn [| watch x; watch x; watch x |] ~f:Fn.id ~reduce:( + )
-            in
-            let o2 = observe f2 in
-            stabilize_ [%here];
-            assert (value o = 2);
-            assert (value o2 = 3);
-            Var.set x 3;
-            stabilize_ [%here];
-            assert (value o = 6);
-            assert (value o2 = 9);
-            disallow_future_use o;
-            disallow_future_use o2;
-            stabilize_ [%here];
-            Var.set x 4;
-            stabilize_ [%here];
-            let o = observe f in
-            let o2 = observe f2 in
-            stabilize_ [%here];
-            assert (value o = 8);
-            assert (value o2 = 12)
-          ;;
-
-          let%expect_test _ =
-            (* general creation and updating *)
-            let module Test_value = struct
-              type t =
-                { var : int Var.t
-                ; update1 : int option
-                ; update2 : int option
-                ; update3 : int option
-                }
-
-              let quickcheck_generator =
-                let open Quickcheck.Generator.Let_syntax in
-                let update_gen =
-                  let%bind weight = Float.gen_uniform_excl 0.0 3.0 in
-                  Quickcheck.Generator.weighted_union
-                    [ 1.0, Quickcheck.Generator.singleton None
-                    ; weight, Int.quickcheck_generator >>| Option.some
-                    ]
-                in
-                let%map var = Int.quickcheck_generator >>| Var.create_ [%here]
-                and update1 = update_gen
-                and update2 = update_gen
-                and update3 = update_gen in
-                { var; update1; update2; update3 }
-              ;;
-            end
-            in
-            Quickcheck.test
-              (let open Quickcheck.Let_syntax in
-               let%map test_value = List.gen_non_empty Test_value.quickcheck_generator in
-               test_value)
-              (* Trials limited because incremental tests can take time on the order of
-               milliseconds each, due to the invariant checking. *)
-              ~trials:100
-              ~f:(fun test_values ->
-                let array =
-                  Array.of_list_map test_values ~f:(fun test_value ->
-                    watch test_value.var)
-                in
-                let len = Array.length array in
-                let reduce_count = ref 0 in
-                let fold_count = ref 0 in
-                let update_count = ref 0 in
-                let assert_expected_reductions_and_reset () =
-                  if !update_count = 0
-                  then (
-                    assert (!fold_count = 0);
-                    assert (!reduce_count = 0))
-                  else (
-                    assert (!fold_count = len);
-                    assert (
-                      !reduce_count
-                      <= Int.min (len - 1) (Int.ceil_log2 len * !update_count)));
-                  fold_count := 0;
-                  reduce_count := 0;
-                  update_count := 0
-                in
-                let reduce_f =
-                  reduce_balanced_exn array ~f:Fn.id ~reduce:(fun a b ->
-                    incr reduce_count;
-                    a * b)
-                in
-                let fold_f =
-                  array_fold array ~init:1 ~f:(fun a b ->
-                    incr fold_count;
-                    a * b)
-                in
-                update_count := len;
-                let reduce_o = observe reduce_f in
-                let fold_o = observe fold_f in
-                stabilize_ [%here];
-                assert (value fold_o = value reduce_o);
-                assert_expected_reductions_and_reset ();
-                List.iter test_values ~f:(fun test_value ->
-                  Option.iter test_value.update1 ~f:(fun a ->
-                    Var.set test_value.var a;
-                    incr update_count));
-                stabilize_ [%here];
-                assert (value fold_o = value reduce_o);
-                assert_expected_reductions_and_reset ();
-                List.iter test_values ~f:(fun test_value ->
-                  let updated = ref false in
-                  Option.iter test_value.update2 ~f:(fun a ->
-                    Var.set test_value.var a;
-                    updated := true);
-                  Option.iter test_value.update3 ~f:(fun a ->
-                    Var.set test_value.var a;
-                    updated := true);
-                  if !updated then incr update_count);
-                stabilize_ [%here];
-                assert (value fold_o = value reduce_o);
-                assert_expected_reductions_and_reset ())
-          ;;
-
-          module Unordered_array_fold_update = Unordered_array_fold_update
-
-          let unordered_array_fold = unordered_array_fold
-
-          let%expect_test _ =
-            (* empty array *)
-            let o =
-              observe
-                (unordered_array_fold
-                   ~full_compute_every_n_changes:0
-                   [||]
-                   ~init:13
-                   ~f:(fun _ -> assert false)
-                   ~update:(F_inverse (fun _ -> assert false)))
-            in
-            stabilize_ [%here];
-            assert (value o = 13)
-          ;;
-
-          let%expect_test _ =
-            (* an unnecessary [unordered_array_fold] isn't computed. *)
-            let x = Var.create_ [%here] 1 in
-            let num_f_inverse = ref 0 in
-            let ox = observe (Var.watch x) in
-            let fold =
-              unordered_array_fold
-                [| Var.watch x |]
-                ~init:0
-                ~f:( + )
-                ~update:
-                  (F_inverse
-                     (fun b a ->
-                       incr num_f_inverse;
-                       b - a))
-            in
-            let r = observe fold in
-            stabilize_ [%here];
-            assert (value r = 1);
-            assert (!num_f_inverse = 0);
-            Var.set x 2;
-            stabilize_ [%here];
-            assert (value r = 2);
-            assert (!num_f_inverse = 1);
-            disallow_future_use r;
-            Var.set x 3;
-            stabilize_ [%here];
-            assert (!num_f_inverse = 1);
-            assert (value ox = 3);
-            let r = observe fold in
-            stabilize_ [%here];
-            [%test_result: int] (value r) ~expect:3;
-            assert (!num_f_inverse = 1)
-          ;;
-
-          let%expect_test _ =
-            (* multiple occurences of a node in the fold. *)
-            let x = Var.create_ [%here] 1 in
-            let f =
-              unordered_array_fold
-                [| watch x; watch x |]
-                ~init:0
-                ~f:( + )
-                ~update:(F_inverse ( - ))
-            in
-            let o = observe f in
-            stabilize_ [%here];
-            assert (value o = 2);
-            Var.set x 3;
-            stabilize_ [%here];
-            assert (value o = 6);
-            disallow_future_use o;
-            stabilize_ [%here];
-            Var.set x 4;
-            stabilize_ [%here];
-            let o = observe f in
-            stabilize_ [%here];
-            assert (value o = 8)
-          ;;
-
-          let%expect_test "[~update:(Update _)]" =
-            let x = Var.create_ [%here] 1 in
-            let fold =
-              unordered_array_fold
-                [| Var.watch x |]
-                ~init:0
-                ~f:( + )
-                ~update:
-                  (Update (fun acc ~old_value ~new_value -> acc - old_value + new_value))
-            in
-            let r = observe fold in
-            let print () =
-              stabilize_ [%here];
-              let r = value r in
-              print_s [%sexp (r : int)]
-            in
-            print ();
-            [%expect {| 1 |}];
-            Var.set x 3;
-            print ();
-            [%expect {| 3 |}]
-          ;;
-
-          let opt_unordered_array_fold = opt_unordered_array_fold
-
-          let%expect_test _ =
-            let o =
-              observe
-                (opt_unordered_array_fold
-                   [||]
-                   ~init:()
-                   ~f:(fun _ -> assert false)
-                   ~f_inverse:(fun _ -> assert false))
-            in
-            stabilize_ [%here];
-            assert (is_some (value o))
-          ;;
-
-          let%expect_test _ =
-            let x = Var.create_ [%here] None in
-            let y = Var.create_ [%here] None in
-            let t =
-              observe
-                (opt_unordered_array_fold
-                   [| watch x; watch y |]
-                   ~init:0
-                   ~f:( + )
-                   ~f_inverse:( - ))
-            in
-            let check where expect =
-              stabilize_ where;
-              [%test_eq: int option] (value t) expect
-            in
-            check [%here] None;
-            Var.set x (Some 13);
-            check [%here] None;
-            Var.set y (Some 14);
-            check [%here] (Some 27);
-            Var.set y None;
-            check [%here] None
-          ;;
-
-          let sum = sum
-
-          let%expect_test _ =
-            (* empty *)
-            let o =
-              observe
-                (sum
-                   [||]
-                   ~zero:13
-                   ~add:(fun _ -> assert false)
-                   ~sub:(fun _ -> assert false))
-            in
-            stabilize_ [%here];
-            assert (value o = 13)
-          ;;
-
-          let%expect_test _ =
-            (* full recompute *)
-            let x = Var.create_ [%here] 13. in
-            let y = Var.create_ [%here] 15. in
-            let num_adds = ref 0 in
-            let add a b =
-              incr num_adds;
-              a +. b
-            in
-            let num_subs = ref 0 in
-            let sub a b =
-              incr num_subs;
-              a -. b
-            in
-            let z =
-              observe
-                (sum
-                   [| watch x; watch y |]
-                   ~zero:0.
-                   ~add
-                   ~sub
-                   ~full_compute_every_n_changes:2)
-            in
-            stabilize_ [%here];
-            assert (!num_adds = 2);
-            assert (!num_subs = 0);
-            assert (Float.equal (value z) 28.);
-            Var.set x 17.;
-            stabilize_ [%here];
-            assert (!num_adds = 3);
-            assert (!num_subs = 1);
-            assert (Float.equal (value z) 32.);
-            Var.set y 19.;
-            stabilize_ [%here];
-            (* [num_adds] increases 2 for the full recompute.  [num_subs] doesn't change
-             because of the full recompute. *)
-            [%test_result: int] !num_adds ~expect:5;
-            [%test_result: int] !num_subs ~expect:1;
-            assert (Float.equal (value z) 36.)
-          ;;
-
-          let opt_sum = opt_sum
-
-          let%expect_test _ =
-            let t =
-              observe
-                (opt_sum
-                   [||]
-                   ~zero:()
-                   ~add:(fun _ -> assert false)
-                   ~sub:(fun _ -> assert false))
-            in
-            stabilize_ [%here];
-            assert (is_some (value t))
-          ;;
-
-          let%expect_test _ =
-            let x = Var.create_ [%here] None in
-            let y = Var.create_ [%here] None in
-            let t =
-              observe (opt_sum [| watch x; watch y |] ~zero:0 ~add:( + ) ~sub:( - ))
-            in
-            let check where expect =
-              stabilize_ where;
-              [%test_eq: int option] (value t) expect
-            in
-            check [%here] None;
-            Var.set x (Some 13);
-            check [%here] None;
-            Var.set y (Some 14);
-            check [%here] (Some 27);
-            Var.set y None;
-            check [%here] None
-          ;;
-
-          let sum_int = sum_int
-          let sum_float = sum_float
-
-          let test_sum (type a) sum (of_int : int -> a) equal =
-            let x = Var.create_ [%here] (of_int 13) in
-            let y = Var.create_ [%here] (of_int 15) in
-            let z = observe (sum [| watch x; watch y |]) in
-            stabilize_ [%here];
-            assert (equal (value z) (of_int 28));
-            stabilize_ [%here];
-            Var.set x (of_int 17);
-            stabilize_ [%here];
-            assert (equal (value z) (of_int 32));
-            Var.set x (of_int 19);
-            Var.set y (of_int 21);
-            stabilize_ [%here];
-            assert (equal (value z) (of_int 40))
-          ;;
-
-          let%expect_test _ = test_sum sum_int Fn.id Int.equal
-          let%expect_test _ = test_sum sum_float Float.of_int Float.equal
-
-          let%expect_test _ =
-            let o = observe (sum_float [||]) in
-            stabilize_ [%here];
-            [%test_result: Float.t] (value o) ~expect:0.
-          ;;
-
-          module Clock = Clock
-
-          let%expect_test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let w = observe (Clock.watch_now clock) in
-            stabilize_ [%here];
-            let before_advance = Clock.now clock in
-            assert (Time_ns.equal before_advance (value w));
-            let to_ = Time_ns.add before_advance (sec 1.) in
-            Clock.advance_clock clock ~to_;
-            assert (Time_ns.equal (Clock.now clock) to_);
-            assert (Time_ns.equal (value w) before_advance);
-            (* we didn't yet stabilize *)
-            stabilize_ [%here];
-            assert (Time_ns.equal (value w) to_)
-          ;;
-
-          let%expect_test "[advance_clock] backwards" =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let o = observe (Clock.watch_now clock) in
-            let show_now () =
-              stabilize_ [%here];
-              print_s [%sexp (Clock.now clock : Time_ns.t), (value o : Time_ns.t)]
-            in
-            show_now ();
-            [%expect
-              {|
-            ((1969-12-31 19:00:00.000000000-05:00)
-             (1969-12-31 19:00:00.000000000-05:00))
-            |}];
-            Clock.advance_clock clock ~to_:(Time_ns.add Time_ns.epoch (sec 1.));
-            show_now ();
-            [%expect
-              {|
-            ((1969-12-31 19:00:01.000000000-05:00)
-             (1969-12-31 19:00:01.000000000-05:00))
-            |}];
-            Clock.advance_clock clock ~to_:Time_ns.epoch;
-            show_now ();
-            [%expect
-              {|
-            ((1969-12-31 19:00:01.000000000-05:00)
-             (1969-12-31 19:00:01.000000000-05:00))
-            |}]
-          ;;
-
-          let is observer v = Poly.equal (value observer) v
-
-          let%expect_test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let o = observe (Clock.after clock (sec 1.)) in
-            let show () =
-              stabilize_ [%here];
-              print_s [%sexp (value o : Before_or_after.t)]
-            in
-            show ();
-            [%expect {| Before |}];
-            Clock.advance_clock_by clock (sec 1.);
-            show ();
-            [%expect {| After |}];
-            Clock.advance_clock_by clock (Clock.alarm_precision clock);
-            show ();
-            [%expect {| After |}]
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            is_invalidated_on_bind_rhs (fun _ ->
-              Clock.at clock (Time_ns.add (Clock.now clock) (sec 1.)))
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
-            is_invalidated_on_bind_rhs (fun _ ->
-              Clock.at clock (Time_ns.add (Clock.now clock) (sec (-1.))))
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            is_invalidated_on_bind_rhs (fun _ -> Clock.after clock (sec 1.))
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
-            is_invalidated_on_bind_rhs (fun _ -> Clock.after clock (sec (-1.)))
-          ;;
-
-          let%expect_test _ =
-            let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
-            let now = Clock.now clock in
-            let at span = observe (Clock.at clock (Time_ns.add now span)) in
-            let i1 = at (sec (-1.)) in
-            let i2 = at (sec (-0.1)) in
-            let i3 = at (sec 1.) in
-            stabilize_ [%here];
-            assert (is i1 After);
-            assert (is i2 After);
-            assert (is i3 Before);
-            Clock.advance_clock_by clock (sec 0.5);
-            stabilize_ [%here];
-            assert (is i1 After);
-            assert (is i2 After);
-            assert (is i3 Before);
-            Clock.advance_clock_by clock (sec 1.);
-            stabilize_ [%here];
-            assert (is i1 After);
-            assert (is i2 After);
-            assert (is i3 After)
-          ;;
-
-          let%expect_test _ =
-            (* advancing the clock in the same stabilization cycle as creation *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = observe (Clock.after clock (sec 1.)) in
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            assert (is i After)
-          ;;
-
-          let%expect_test _ =
-            (* firing an unnecessary [after] and then observing it *)
-            let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
-            let i = Clock.after clock (sec (-1.)) in
-            stabilize_ [%here];
-            let o = observe i in
-            stabilize_ [%here];
-            assert (is o After);
-            let r = ref 0 in
-            let i =
-              Clock.after clock (sec 1.)
-              >>| fun z ->
-              incr r;
-              z
-            in
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            assert (!r = 0);
-            stabilize_ [%here];
-            let o = observe i in
-            stabilize_ [%here];
-            assert (!r = 1);
-            assert (is o After)
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            does_raise (fun () -> Clock.at_intervals clock (sec (-1.)))
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            does_raise (fun () -> Clock.at_intervals clock (sec 0.))
-          ;;
-
-          let%test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            is_invalidated_on_bind_rhs (fun _ -> Clock.at_intervals clock (sec 1.))
-          ;;
-
-          let%expect_test _ =
-            (* advancing the clock does nothing by itself *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let r = ref 0 in
-            let i = Clock.at_intervals clock (sec 1.) >>| fun () -> incr r in
-            let o = observe i in
-            assert (!r = 0);
-            Clock.advance_clock_by clock (sec 2.);
-            assert (!r = 0);
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let r = ref (-1) in
-            let i = Clock.at_intervals clock (sec 1.) >>| fun () -> incr r in
-            let o = observe i in
-            stabilize_ [%here];
-            let show_r () = print_s [%sexp (!r : int)] in
-            show_r ();
-            [%expect {| 0 |}];
-            Clock.advance_clock_by clock (sec 0.5);
-            stabilize_ [%here];
-            show_r ();
-            [%expect {| 0 |}];
-            Clock.advance_clock_by clock (sec 1.);
-            stabilize_ [%here];
-            show_r ();
-            [%expect {| 1 |}];
-            Clock.advance_clock_by clock (sec 1.);
-            show_r ();
-            [%expect {| 1 |}];
-            Clock.advance_clock_by clock (sec 1.);
-            show_r ();
-            [%expect {| 1 |}];
-            Clock.advance_clock_by clock (sec 1.);
-            show_r ();
-            [%expect {| 1 |}];
-            stabilize_ [%here];
-            show_r ();
-            [%expect {| 2 |}];
-            Clock.advance_clock_by clock (sec 10.);
-            stabilize_ [%here];
-            show_r ();
-            [%expect {| 3 |}];
-            disallow_future_use o;
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            show_r ();
-            [%expect {| 3 |}];
-            let o = observe i in
-            stabilize_ [%here];
-            show_r ();
-            [%expect {| 4 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* advancing exactly to intervals doesn't skip any *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let r = ref (-1) in
-            let o = observe (Clock.at_intervals clock (sec 1.) >>| fun () -> incr r) in
-            stabilize_ [%here];
-            [%test_result: int] !r ~expect:0;
-            let base = Clock.now clock in
-            let curr = ref base in
-            for i = 1 to 20 do
-              curr := Time_ns.next_multiple ~base ~after:!curr ~interval:(sec 1.) ();
-              Clock.advance_clock clock ~to_:!curr;
-              stabilize_ [%here];
-              [%test_result: int] !r ~expect:i
-            done;
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* [interval < alarm precision] raises *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            assert (does_raise (fun () -> Clock.at_intervals clock (sec 0.0005)))
-          ;;
-
-          let%expect_test _ =
-            (* [at] in the past *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            assert (
-              is_error
-                (Clock.snapshot
-                   clock
-                   (const 14)
-                   ~at:(Time_ns.sub (Clock.now clock) (sec 1.))
-                   ~before:13))
-          ;;
-
-          let%expect_test _ =
-            (* [at] in the future *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let o =
-              observe
-                (ok_exn
-                   (Clock.snapshot
-                      clock
-                      (const 14)
-                      ~at:(Time_ns.add (Clock.now clock) (sec 1.))
-                      ~before:13))
-            in
-            stabilize_ [%here];
-            assert (value o = 13);
-            stabilize_ [%here];
-            Clock.advance_clock_by clock (sec 2.);
-            assert (value o = 13);
-            stabilize_ [%here];
-            assert (value o = 14)
-          ;;
-
-          let%expect_test _ =
-            (* [at] in the future, unobserved *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x = Var.create_ [%here] 13 in
-            let i =
-              ok_exn
-                (Clock.snapshot
-                   clock
-                   (Var.watch x)
-                   ~at:(Time_ns.add (Clock.now clock) (sec 1.))
-                   ~before:15)
-            in
-            stabilize_ [%here];
-            Var.set x 17;
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            Var.set x 19;
-            let o = observe i in
-            stabilize_ [%here];
-            assert (value o = 17)
-          ;;
-
-          let%expect_test _ =
-            (* [advance_clock] past [at] prior to stabilization. *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let o =
-              observe
-                (ok_exn
-                   (Clock.snapshot
-                      clock
-                      (const 15)
-                      ~at:(Time_ns.add (Clock.now clock) (sec 1.))
-                      ~before:13))
-            in
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            assert (value o = 15)
-          ;;
-
-          let%expect_test _ =
-            (* unobserved, [advance_clock] past [at] prior to stabilization. *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x = Var.create_ [%here] 13 in
-            let i =
-              ok_exn
-                (Clock.snapshot
-                   clock
-                   (Var.watch x)
-                   ~at:(Time_ns.add (Clock.now clock) (sec 1.))
-                   ~before:15)
-            in
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            Var.set x 17;
-            let o = observe i in
-            stabilize_ [%here];
-            assert (value o = 13)
-          ;;
-
-          let%expect_test _ =
-            (* invalidated *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let t =
-              ok_exn
-                (Clock.snapshot
-                   clock
-                   invalid
-                   ~at:(Time_ns.add (Clock.now clock) (sec 1.))
-                   ~before:13)
-            in
-            let o = observe t in
-            stabilize_ [%here];
-            assert (value o = 13);
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            assert (skip_invalidity_check || not (is_valid t));
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* [snapshot] nodes increment [num_nodes_became_necessary] *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i1 = State.(num_nodes_became_necessary t) in
-            let c = const () in
-            for _ = 1 to 5 do
-              ignore
-                (ok_exn
-                   (Clock.snapshot
-                      clock
-                      c
-                      ~at:(Time_ns.add (Clock.now clock) (sec 1.))
-                      ~before:())
-                  : _ t)
-            done;
-            Clock.advance_clock_by clock (sec 2.);
-            let i2 = State.(num_nodes_became_necessary t) in
-            (* the 5 [snapshot]s that became [freeze] plus the [const] *)
-            [%test_result: int] i2 ~expect:(i1 + 6)
-          ;;
-
-          let relative_step_function clock ~init steps =
-            let now = Clock.now clock in
-            Step_function.create_exn
-              ~init
-              ~steps:
-                (List.map steps ~f:(fun (after, a) ->
-                   Time_ns.add now (sec (Float.of_int after)), a))
-          ;;
-
-          let relative_step_function_incr clock ~init steps =
-            Clock.step_function
-              clock
-              ~init
-              (List.map steps ~f:(fun (after, a) ->
-                 Time_ns.add (Clock.now clock) (sec (Float.of_int after)), a))
-          ;;
-
-          let%expect_test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            require
-              [%here]
-              (is_invalidated_on_bind_rhs (fun i -> Clock.step_function clock ~init:i []))
-          ;;
-
-          let%expect_test _ =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            require
-              [%here]
-              (is_invalidated_on_bind_rhs (fun i ->
-                 relative_step_function_incr clock ~init:i [ 1, i + 1 ]))
-          ;;
-
-          let%expect_test _ =
-            (* no steps *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = Clock.step_function clock ~init:13 [] in
-            let o = observe i in
-            stabilize_ [%here];
-            print_s [%sexp (value o : int)];
-            [%expect {| 13 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* one step at a time *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = relative_step_function_incr clock ~init:13 [ 1, 14; 2, 15 ] in
-            let o = observe i in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 13 |}];
-            Clock.advance_clock_by clock (sec 1.5);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 14 |}];
-            Clock.advance_clock_by clock (sec 1.);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 15 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* all steps in the past *)
-            let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 2.)) () in
-            let i = relative_step_function_incr clock ~init:13 [ -2, 14; -1, 15 ] in
-            let o = observe i in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 15 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* some steps in the past *)
-            let clock = Clock.create ~start:(Time_ns.add Time_ns.epoch (sec 1.)) () in
-            let i = relative_step_function_incr clock ~init:13 [ -1, 14; 1, 15 ] in
-            let o = observe i in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 14 |}];
-            Clock.advance_clock_by clock (sec 1.5);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 15 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* cross multiple steps in one stabilization cycle *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = relative_step_function_incr clock ~init:13 [ 1, 14; 2, 15 ] in
-            let o = observe i in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 13 |}];
-            Clock.advance_clock_by clock (sec 1.5);
-            Clock.advance_clock_by clock (sec 1.);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 15 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* cross step in same stabilization as creation *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = relative_step_function_incr clock ~init:13 [ 1, 14 ] in
-            let o = observe i in
-            let show () = print_s [%sexp (value o : int)] in
-            Clock.advance_clock_by clock (sec 2.);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 14 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* observe after step *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = relative_step_function_incr clock ~init:13 [ 1, 14 ] in
-            stabilize_ [%here];
-            Clock.advance_clock_by clock (sec 1.5);
-            stabilize_ [%here];
-            let o = observe i in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 14 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* advancing exactly to steps doesn't skip steps *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let base = Clock.now clock in
-            let curr = ref base in
-            let steps = ref [] in
-            for i = 1 to 20 do
-              curr := Time_ns.next_multiple ~base ~after:!curr ~interval:(sec 1.) ();
-              steps := (!curr, i) :: !steps
-            done;
-            let steps = List.rev !steps in
-            let o = observe (Clock.step_function clock ~init:0 steps) in
-            List.iter steps ~f:(fun (to_, _) ->
-              Clock.advance_clock clock ~to_;
-              stabilize_ [%here];
-              print_s [%sexp (value o : int)]);
-            [%expect
-              {|
-            1
-            2
-            3
-            4
-            5
-            6
-            7
-            8
-            9
-            10
-            11
-            12
-            13
-            14
-            15
-            16
-            17
-            18
-            19
-            20
-            |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test "[incremental_step_function]" =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x = Var.create (Step_function.constant 1) in
-            let o = observe (Clock.incremental_step_function clock (watch x)) in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 1 |}];
-            Var.set x (Step_function.constant 2);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 2 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test "incremental step function with step in the past, present, and \
-                           future"
-            =
-            let test ~step_at =
-              let clock = Clock.create ~start:Time_ns.epoch () in
-              let x = Var.create (Step_function.constant 1) in
-              let o = observe (Clock.incremental_step_function clock (watch x)) in
-              let show () = print_s [%sexp (value o : int)] in
-              stabilize_ [%here];
-              show ();
-              [%expect {| 1 |}];
-              Var.set x (relative_step_function clock ~init:2 [ step_at, 3 ]);
-              stabilize_ [%here];
-              show ();
-              disallow_future_use o
-            in
-            test ~step_at:(-1);
-            [%expect {| 3 |}];
-            test ~step_at:0;
-            [%expect {| 3 |}];
-            test ~step_at:1;
-            [%expect {| 2 |}]
-          ;;
-
-          let%expect_test "incremental step function; advance time and change function" =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x = Var.create (relative_step_function clock ~init:13 [ 1, 14 ]) in
-            let o = observe (Clock.incremental_step_function clock (watch x)) in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 13 |}];
-            Var.set x (relative_step_function clock ~init:15 [ 1, 16 ]);
-            Clock.advance_clock_by clock (sec 1.);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 16 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test "incremental step function; change to const and then advance \
-                           time"
-            =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x = Var.create (relative_step_function clock ~init:13 [ 1, 14 ]) in
-            let o = observe (Clock.incremental_step_function clock (watch x)) in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 13 |}];
-            Var.set x (Step_function.constant 15);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 15 |}];
-            Clock.advance_clock_by clock (sec 1.);
-            stabilize_ [%here];
-            show ();
-            [%expect {| 15 |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test "incremental step function is invalidated when child is" =
-            let b = Var.create true in
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let t =
-              Clock.incremental_step_function
-                clock
-                (if_ (watch b) ~then_:(const 0) ~else_:invalid >>| Step_function.constant)
-            in
-            let o = observe t in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 0 |}];
-            Var.set b false;
-            stabilize_ [%here];
-            print_s [%sexp (check_invalidity && is_valid t : bool)];
-            [%expect {| false |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test "incremental step function that becomes observable in a \
-                           stabilization after its child stabilizes"
-            =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x = Var.create (Step_function.constant 13) in
-            let ox = observe (watch x) in
-            let t = Clock.incremental_step_function clock (watch x) in
-            stabilize_ [%here];
-            let o = observe t in
-            let show () = print_s [%sexp (value o : int)] in
-            stabilize_ [%here];
-            show ();
-            [%expect {| 13 |}];
-            disallow_future_use ox;
-            disallow_future_use o
-          ;;
-
-          let%expect_test "incremental step function of const used in other places" =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let c = const (Step_function.constant 13) in
-            let c1 = c >>| fun s -> s in
-            let o1 = observe c1 in
-            let x = Clock.incremental_step_function clock c in
-            let ox = observe x in
-            stabilize_ [%here];
-            disallow_future_use o1;
-            disallow_future_use ox
-          ;;
-
-          let%expect_test _ =
-            (* Equivalence between [step_function] and reimplementation with [at] *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let my_step_function ~init steps =
-              let xs =
-                Array.map (Array.of_list steps) ~f:(fun (time, x) ->
-                  map (Clock.at clock time) ~f:(function
-                    | Before -> None
-                    | After -> Some x))
-              in
-              array_fold xs ~init ~f:(fun acc x -> Option.value x ~default:acc)
-            in
-            let base = Clock.now clock in
-            let steps =
-              List.map
-                ~f:(fun (d, v) -> Time_ns.add base (sec d), v)
-                [ 1.0, 1
-                ; 1.99999, 2
-                  (* It is unspecified whether this alarm has fired when the
-                 time is 2. but this test relies on the two
-                 step_functions having the same unspecified behaviour. *)
-                ; 2.0, 3
-                ; 3.00001, 4
-                ; 4.0, 5
-                ; 4.00001, 6
-                ; 5.0, 6
-                ; 6.0, 7
-                ]
-            in
-            let o1 = observe (Clock.step_function clock ~init:0 steps) in
-            let o2 = observe (my_step_function ~init:0 steps) in
-            stabilize_ [%here];
-            for i = 1 to 7 do
-              Clock.advance_clock clock ~to_:(Time_ns.add base (sec (Float.of_int i)));
-              stabilize_ [%here];
-              print_s [%sexp (value o1 : int), (value o2 : int)];
-              require [%here] (value o1 = value o2)
-            done;
-            [%expect
-              {|
-            (1 1)
-            (3 3)
-            (3 3)
-            (5 5)
-            (6 6)
-            (7 7)
-            (7 7)
-            |}];
-            disallow_future_use o1;
-            disallow_future_use o2
-          ;;
-
-          let%expect_test "[Step_function.create_from_sequence]" =
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let x =
-              Var.create
-                (Step_function.create_from_sequence
-                   ~init:13
-                   ~steps:
-                     (Sequence.unfold
-                        ~init:(Clock.now clock, 14)
-                        ~f:(fun (at, i) ->
-                          print_s [%message "unfold" (i : int)];
-                          Some ((at, i), (Time_ns.add at (sec 1.), i + 1)))))
-            in
-            let o = observe (Clock.incremental_step_function clock (watch x)) in
-            let show () = print_s [%sexp (value o : int)] in
-            for _ = 1 to 5 do
-              Clock.advance_clock_by clock (sec 1.);
-              stabilize_ [%here];
-              show ()
-            done;
-            [%expect
-              {|
-            (unfold (i 14))
-            (unfold (i 15))
-            (unfold (i 16))
-            (unfold (i 16))
-            15
-            (unfold (i 16))
-            (unfold (i 17))
-            (unfold (i 17))
-            16
-            (unfold (i 17))
-            (unfold (i 18))
-            (unfold (i 18))
-            17
-            (unfold (i 18))
-            (unfold (i 19))
-            (unfold (i 19))
-            18
-            (unfold (i 19))
-            (unfold (i 20))
-            (unfold (i 20))
-            19
-            |}];
-            disallow_future_use o
-          ;;
-
-          let%expect_test _ =
-            (* Advancing to a scheduled time shouldn't break things. *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let fut = Time_ns.add (Clock.now clock) (sec 1.0) in
-            let o1 = observe (Clock.at clock fut) in
-            let o2 =
-              observe (ok_exn (Clock.snapshot clock (const 1) ~at:fut ~before:0))
-            in
-            Clock.advance_clock clock ~to_:fut;
-            stabilize_ [%here];
-            disallow_future_use o1;
-            disallow_future_use o2
-          ;;
-
-          let%expect_test _ =
-            (* alarms get cleaned up for invalidated time-based incrementals *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            List.iter
-              [ (fun () -> Clock.after clock (sec 1.) >>| fun _ -> ())
-              ; (fun () -> Clock.at_intervals clock (sec 1.))
-              ; (fun () -> relative_step_function_incr clock ~init:() [ 1, () ])
-              ]
-              ~f:(fun create_time_based_incremental ->
-                let num_alarms = Clock.timing_wheel_length clock in
-                let x = Var.create_ [%here] 0 in
-                let o =
-                  observe
-                    (bind (Var.watch x) ~f:(fun i ->
-                       if i >= 0 then create_time_based_incremental () else return ()))
-                in
-                stabilize_ [%here];
-                for i = 1 to 10 do
-                  Var.set x i;
-                  stabilize_ [%here];
-                  if check_invalidity
-                  then
-                    [%test_result: int]
-                      ~expect:(num_alarms + 1)
-                      (Clock.timing_wheel_length clock)
-                done;
-                Var.set x (-1);
-                stabilize_ [%here];
-                if check_invalidity
-                then
-                  [%test_result: int] ~expect:num_alarms (Clock.timing_wheel_length clock);
-                disallow_future_use o)
-          ;;
-
-          module Observer = struct
-            open Observer
-
-            type nonrec 'a t = 'a t [@@deriving sexp_of]
-
-            let%expect_test "[sexp_of_t]" =
-              let t = observe (watch (Var.create 13)) in
-              let show_t () = print_s [%sexp (t : int t)] in
-              show_t ();
-              [%expect {| <unstabilized> |}];
-              stabilize_ [%here];
-              show_t ();
-              [%expect {| 13 |}];
-              disallow_future_use t;
-              show_t ();
-              [%expect {| <disallowed> |}]
-            ;;
-
-            let invariant = invariant
-            let observing = observing
-
-            let%expect_test _ =
-              let x = Var.create_ [%here] 0 in
-              let o = observe (watch x) in
-              assert (phys_same (observing o) (watch x))
-            ;;
-
-            let use_is_allowed = use_is_allowed
-
-            let%expect_test _ =
-              let o = observe (watch (Var.create_ [%here] 0)) in
-              assert (use_is_allowed o);
-              disallow_future_use o;
-              assert (not (use_is_allowed o))
-            ;;
-
-            let disallow_future_use = disallow_future_use
-            let value = value
-            let value_exn = value_exn
-
-            let%expect_test _ =
-              (* calling [value] before stabilizing returns error. *)
-              let x = Var.create_ [%here] 0 in
-              let o = observe (watch x) in
-              assert (is_error (value o));
-              assert (does_raise (fun () -> value_exn o))
-            ;;
-
-            let%expect_test _ =
-              (* calling [value] on a just-created observer of an already computed
-               incremental before stabilizing returns error. *)
-              let x = Var.create_ [%here] 13 in
-              let o = observe (watch x) in
-              stabilize_ [%here];
-              disallow_future_use o;
-              Var.set x 14;
-              stabilize_ [%here];
-              Var.set x 15;
-              let o = observe (watch x) in
-              assert (is_error (value o));
-              assert (does_raise (fun () -> value_exn o))
-            ;;
-
-            let%expect_test _ =
-              (* calling [value] after [disallow_future_use] returns error. *)
-              let x = Var.create_ [%here] 0 in
-              let o = observe (watch x) in
-              stabilize_ [%here];
-              disallow_future_use o;
-              assert (is_error (value o));
-              assert (does_raise (fun () -> value_exn o))
-            ;;
-
-            let%expect_test _ =
-              (* [disallow_future_use] disables on-update handlers. *)
-              let x = Var.create_ [%here] 13 in
-              let o = observe (Var.watch x) in
-              let r = ref 0 in
-              Observer.on_update_exn o ~f:(fun _ -> incr r);
-              stabilize_ [%here];
-              assert (!r = 1);
-              disallow_future_use o;
-              Var.set x 14;
-              stabilize_ [%here];
-              assert (!r = 1)
-            ;;
-
-            let%expect_test _ =
-              (* finalizers work *)
-              Gc.full_major ();
-              stabilize_ [%here];
-              (* clean up pre-existing finalizers *)
-              let before = State.(num_active_observers t) in
-              let x = Var.create_ [%here] 13 in
-              let o = observe (Var.watch x) in
-              assert (State.(num_active_observers t) = before + 1);
-              stabilize_ [%here];
-              assert (value_exn o = 13);
-              Gc.full_major ();
-              assert (State.(num_active_observers t) = before + 1);
-              stabilize_ [%here];
-              assert (State.(num_active_observers t) = before)
-            ;;
-
-            let%expect_test _ =
-              (* finalizers don't disable on-update handlers *)
-              let x = Var.create_ [%here] 13 in
-              let o = observe (Var.watch x) in
-              let r = ref 0 in
-              Observer.on_update_exn o ~f:(fun _ -> incr r);
-              stabilize_ [%here];
-              assert (!r = 1);
-              Gc.full_major ();
-              Var.set x 14;
-              stabilize_ [%here];
-              assert (!r = 2)
-            ;;
-
-            let%expect_test _ =
-              (* finalizers cause an [Unnecessary] update to be sent *)
-              let x = Var.create 13 in
-              let o = observe (watch x) in
-              let push, check = on_update_queue () in
-              on_update (watch x) ~f:push;
-              stabilize_ [%here];
-              check [ Necessary 13 ];
-              Gc.keep_alive o;
-              Gc.full_major ();
-              stabilize_ [%here];
-              check [ Unnecessary ]
-            ;;
-
-            let%expect_test _ =
-              (* [disallow_future_use] and finalize in the same stabilization. *)
-              let x = Var.create_ [%here] 1 in
-              let o = observe (Var.watch x) in
-              stabilize_ [%here];
-              disallow_future_use o;
-              Gc.full_major ();
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* finalize after disallow_future_use *)
-              let x = Var.create_ [%here] 1 in
-              let o = observe (Var.watch x) in
-              stabilize_ [%here];
-              disallow_future_use o;
-              stabilize_ [%here];
-              (* This [full_major] + [stabilize] causes the finalizer for [o] to run and
-               makes sure that it doesn't do anything wrong, given that
-               [disallow_future_use o] has already been called. *)
-              Gc.full_major ();
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* after user resurrection of an observer, it is still disallowed *)
-              let x = Var.create_ [%here] 13 in
-              let o = observe (Var.watch x) in
-              stabilize_ [%here];
-              Gc.keep_alive o;
-              let r = ref None in
-              Gc.Expert.add_finalizer_exn o (fun o -> r := Some o);
-              Gc.full_major ();
-              stabilize_ [%here];
-              let o = Option.value_exn !r in
-              assert (not (use_is_allowed o))
-            ;;
-
-            let%expect_test _ =
-              (* lots of observers on the same node isn't quadratic. *)
-              (* We can't run this test with debugging, because it's too slow. *)
-              if not debug
-              then (
-                let t = const 13 in
-                let observers = List.init 100_000 ~f:(fun _ -> observe t) in
-                let cpu_used () =
-                  let module R = Unix.Resource_usage in
-                  let { R.utime; stime; _ } = R.get `Self in
-                  Time_ns.Span.of_sec (utime +. stime)
-                in
-                let before = cpu_used () in
-                (* Don't use [stabilize_], which runs the invariant, which is too slow
-                 here. *)
-                stabilize ();
-                List.iter observers ~f:Observer.disallow_future_use;
-                stabilize ();
-                let consumed = Time_ns.Span.( - ) (cpu_used ()) before in
-                assert (Time_ns.Span.( < ) consumed (sec 1.)))
-            ;;
-
-            module Update = Update
-
-            let on_update_exn = on_update_exn
-
-            let%expect_test _ =
-              let x = Var.create_ [%here] 13 in
-              let parent = map (watch x) ~f:(fun x -> x + 1) in
-              let parent_o = observe parent in
-              let num_calls = ref 0 in
-              let r = ref 0 in
-              on_update_exn parent_o ~f:(function
-                | Initialized i | Changed (_, i) ->
-                  num_calls := !num_calls + 1;
-                  r := i
-                | Invalidated -> assert false);
-              stabilize_ [%here];
-              assert (!num_calls = 1);
-              Var.set x 15;
-              stabilize_ [%here];
-              assert (!num_calls = 2);
-              assert (!r = 16);
-              disallow_future_use parent_o;
-              Var.set x 17;
-              stabilize_ [%here];
-              assert (!num_calls = 2);
-              assert (!r = 16)
-            ;;
-
-            let%expect_test _ =
-              (* [on_update_exn] of an invalid node, not during a stabilization *)
-              let o = observe invalid in
-              on_update_exn o ~f:(fun _ -> assert false);
-              disallow_future_use o
-            ;;
-
-            let%expect_test _ =
-              (* [on_update_exn] of an invalid node *)
-              let o = observe invalid in
-              let is_ok = ref false in
-              on_update_exn o ~f:(function
-                | Invalidated -> is_ok := true
-                | _ -> assert (skip_invalidity_check || false));
-              stabilize_ [%here];
-              assert (skip_invalidity_check || !is_ok)
-            ;;
-
-            let%expect_test _ =
-              (* stabilizing with an on-update handler of a node that is invalidated *)
-              let x = Var.create 0 in
-              let r = ref None in
-              let o1 =
-                observe
-                  (bind (watch x) ~f:(fun i ->
-                     let t = const i in
-                     r := Some t;
-                     t))
-              in
-              stabilize_ [%here];
-              let o2 = observe (Option.value_exn !r) in
-              let invalidated = ref false in
-              Observer.on_update_exn o2 ~f:(function
-                | Invalidated -> invalidated := true
-                | _ -> ());
-              stabilize_ [%here];
-              assert (not !invalidated);
-              Var.set x 1;
-              stabilize_ [%here];
-              assert (skip_invalidity_check || !invalidated);
-              disallow_future_use o1;
-              disallow_future_use o2
-            ;;
-
-            let%expect_test _ =
-              (* [on_update_exn] of a disallowed observer *)
-              let o = observe (const 5) in
-              disallow_future_use o;
-              assert (does_raise (fun () -> on_update_exn o ~f:(fun _ -> assert false)))
-            ;;
-
-            let%expect_test _ =
-              (* [disallow_future_use] before first stabilization *)
-              let o = observe (const 5) in
-              disallow_future_use o;
-              stabilize_ [%here];
-              disallow_future_use o
-            ;;
-
-            let%expect_test _ =
-              (* [disallow_future_use] during an on-update handler *)
-              let x = Var.create_ [%here] 13 in
-              let o = observe (watch x) in
-              on_update_exn o ~f:(fun _ -> disallow_future_use o);
-              stabilize_ [%here];
-              assert (is_error (value o))
-            ;;
-
-            let%expect_test _ =
-              (* disallowing other on-update handlers in an on-update handler *)
-              let x = Var.create_ [%here] 13 in
-              let o = observe (watch x) in
-              for _ = 1 to 2 do
-                on_update_exn o ~f:(fun _ ->
-                  assert (use_is_allowed o);
-                  disallow_future_use o)
-              done;
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* disallowing other observers of the same node an on-update handler *)
-              let x = Var.create_ [%here] 13 in
-              let o1 = observe (watch x) in
-              let o2 = observe (watch x) in
-              let o3 = observe (watch x) in
-              List.iter [ o1; o3 ] ~f:(fun o ->
-                on_update_exn o ~f:(fun _ -> assert (use_is_allowed o)));
-              on_update_exn o2 ~f:(fun _ ->
-                disallow_future_use o1;
-                disallow_future_use o3);
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* disallowing observers of other nodes in an on-update handler *)
-              let o () = observe (watch (Var.create_ [%here] 13)) in
-              let o1 = o () in
-              let o2 = o () in
-              let o3 = o () in
-              List.iter [ o1; o3 ] ~f:(fun o ->
-                on_update_exn o ~f:(fun _ -> assert (use_is_allowed o)));
-              on_update_exn o2 ~f:(fun _ ->
-                disallow_future_use o1;
-                disallow_future_use o3);
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* adding an on-update-handler to an already stable node *)
-              let x = watch (Var.create 13) in
-              let o = observe x in
-              stabilize_ [%here];
-              let did_run = ref false in
-              on_update_exn (observe x) ~f:(fun _ -> did_run := true);
-              assert (not !did_run);
-              stabilize_ [%here];
-              assert !did_run;
-              disallow_future_use o
-            ;;
-
-            let%expect_test _ =
-              (* adding an on-update handler after a change *)
-              let x = Var.create 13 in
-              let o = observe (watch x) in
-              let push1, check1 = on_observer_update_queue () in
-              Observer.on_update_exn o ~f:push1;
-              stabilize_ [%here];
-              check1 [ Initialized 13 ];
-              Var.set x 14;
-              stabilize_ [%here];
-              check1 [ Changed (13, 14) ];
-              let push2, check2 = on_observer_update_queue () in
-              Observer.on_update_exn o ~f:push2;
-              stabilize_ [%here];
-              check2 [ Initialized 14 ];
-              Var.set x 15;
-              stabilize_ [%here];
-              check1 [ Changed (14, 15) ];
-              check2 [ Changed (14, 15) ]
-            ;;
-
-            let%expect_test _ =
-              (* adding an on-update handler in an on-update handler. *)
-              let x = Var.create 13 in
-              let o = observe (watch x) in
-              let did_run = ref false in
-              on_update_exn o ~f:(fun _ ->
-                on_update_exn (observe (watch x)) ~f:(fun _ -> did_run := true));
-              stabilize_ [%here];
-              assert (not !did_run);
-              Var.set x 14;
-              stabilize_ [%here];
-              assert !did_run;
-              Gc.full_major ();
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* adding an on-update-handler to an invalid node in an on-update
-               handler. *)
-              let module I = Make () in
-              let open I in
-              let o = observe (watch (Var.create 13)) in
-              let is_ok = ref false in
-              Observer.on_update_exn o ~f:(fun _ ->
-                Observer.on_update_exn (observe invalid) ~f:(function
-                  | Invalidated -> is_ok := true
-                  | _ -> assert (skip_invalidity_check || false)));
-              stabilize_ [%here];
-              assert (not !is_ok);
-              stabilize_ [%here];
-              assert (skip_invalidity_check || !is_ok)
-            ;;
-
-            let%expect_test _ =
-              (* on-update-handlers added during the firing of other on-update-handlers
-               should not fire now but instead after the next stabilization *)
-              List.iter
-                [ const 1; invalid ]
-                ~f:(fun node ->
-                  let o1 = observe (const 1) in
-                  let o2 = observe node in
-                  let ran = ref 0 in
-                  Observer.on_update_exn o1 ~f:(fun _ ->
-                    Observer.on_update_exn o2 ~f:(fun _ -> incr ran));
-                  Observer.on_update_exn o2 ~f:(fun _ -> ());
-                  assert (!ran = 0);
-                  stabilize_ [%here];
-                  assert (!ran = 0);
-                  stabilize_ [%here];
-                  assert (!ran = 1);
-                  stabilize_ [%here];
-                  assert (!ran = 1);
-                  disallow_future_use o1;
-                  disallow_future_use o2)
-            ;;
-
-            let%expect_test _ =
-              (* on-update handler set up during stabilization fires after the
-               stabilization *)
-              let called = ref false in
-              let unit = const () in
-              let o_unit = observe unit in
-              let o =
-                observe
-                  (map unit ~f:(fun () ->
-                     on_update_exn o_unit ~f:(fun _ -> called := true)))
-              in
-              assert (not !called);
-              stabilize_ [%here];
-              assert !called;
-              disallow_future_use o;
-              disallow_future_use o_unit
-            ;;
-
-            let%expect_test _ =
-              (* on-update handlers are initialized once *)
-              let v = Var.create (const 0) in
-              let i = Var.watch v in
-              let o = observe i in
-              let old_val_is_none_once () =
-                let is_first_call = ref true in
-                function
-                | Observer.Update.Initialized _ ->
-                  assert !is_first_call;
-                  is_first_call := false
-                | Changed _ -> assert (not !is_first_call)
-                | Invalidated -> assert false
-              in
-              Observer.on_update_exn o ~f:(old_val_is_none_once ());
-              stabilize ();
-              Observer.on_update_exn o ~f:(old_val_is_none_once ());
-              stabilize ()
-            ;;
-
-            let%expect_test _ =
-              (* creating an observer during stabilization *)
-              let x = Var.create 13 in
-              let r = ref None in
-              let o1 =
-                observe
-                  (Var.watch x
-                   >>| fun _ ->
-                   let o2 = observe (Var.watch x) in
-                   assert (use_is_allowed o2);
-                   assert (is_error (value o2));
-                   r := Some o2;
-                   0)
-              in
-              stabilize_ [%here];
-              let o2 = Option.value_exn !r in
-              assert (use_is_allowed o2);
-              assert (is_error (value o2));
-              stabilize_ [%here];
-              assert (value_exn o2 = 13);
-              disallow_future_use o1;
-              disallow_future_use o2;
-              stabilize_ [%here];
-              assert (is_error (value o2))
-            ;;
-
-            let%expect_test _ =
-              (* creating an observer and adding on_update handler during
-               stabilization *)
-              let v = Var.create 0 in
-              let push, check = on_observer_update_queue () in
-              let inner_obs = ref None in
-              let o =
-                observe
-                  (Var.watch v
-                   >>| fun i ->
-                   let observer = observe (Var.watch v) in
-                   inner_obs := Some observer;
-                   on_update_exn observer ~f:push;
-                   i)
-              in
-              check [];
-              stabilize_ [%here];
-              check [];
-              stabilize_ [%here];
-              check [ Initialized 0 ];
-              disallow_future_use o;
-              disallow_future_use (Option.value_exn !inner_obs)
-            ;;
-
-            let%expect_test _ =
-              (* disallow_future_use during stabilization *)
-              let x = Var.create 13 in
-              let handler_ran = ref false in
-              let o1 = observe (Var.watch x) in
-              let o2 =
-                observe
-                  (Var.watch x
-                   >>| fun i ->
-                   on_update_exn o1 ~f:(fun _ -> handler_ran := true);
-                   disallow_future_use o1;
-                   assert (not (use_is_allowed o1));
-                   i)
-              in
-              assert (use_is_allowed o1);
-              assert (not !handler_ran);
-              stabilize_ [%here];
-              assert (not (use_is_allowed o1));
-              assert (not !handler_ran);
-              disallow_future_use o2
-            ;;
-
-            let%expect_test _ =
-              (* creating an observer and disallowing use during stabilization *)
-              let x = Var.create 13 in
-              let r = ref None in
-              let o1 =
-                observe
-                  (Var.watch x
-                   >>| fun _ ->
-                   let o2 = observe (Var.watch x) in
-                   r := Some o2;
-                   disallow_future_use o2;
-                   0)
-              in
-              stabilize_ [%here];
-              let o2 = Option.value_exn !r in
-              assert (not (use_is_allowed o2));
-              disallow_future_use o1;
-              stabilize_ [%here]
-            ;;
-
-            let%expect_test _ =
-              (* creating an observer and finalizing it during stabilization *)
-              let x = Var.create 13 in
-              let o =
-                observe
-                  (Var.watch x
-                   >>| fun _ ->
-                   Fn.ignore (observe (Var.watch x) : _ Observer.t);
-                   Gc.full_major ();
-                   0)
-              in
-              stabilize_ [%here];
-              stabilize_ [%here];
-              disallow_future_use o
-            ;;
-          end
-
-          let on_update = on_update
-
           let%expect_test _ =
-            let v = Var.create_ [%here] 13 in
-            let push, check = on_update_queue () in
-            let o = observe (watch v) in
-            on_update (watch v) ~f:push;
+            (* [disallow_future_use] disables on-update handlers. *)
+            let x = Var.create_ [%here] 13 in
+            let o = observe (Var.watch x) in
+            let r = ref 0 in
+            Observer.on_update_exn o ~f:(fun _ -> incr r);
             stabilize_ [%here];
-            check [ Necessary 13 ];
+            assert (!r = 1);
+            disallow_future_use o;
+            Var.set x 14;
             stabilize_ [%here];
-            check [];
-            Var.set v 14;
+            assert (!r = 1)
+          ;;
+
+          let%expect_test _ =
+            (* finalizers work *)
+            Gc.full_major ();
             stabilize_ [%here];
-            check [ Changed (13, 14) ];
-            disallow_future_use o;
-            Var.set v 15;
+            (* clean up pre-existing finalizers *)
+            let before = State.(num_active_observers t) in
+            let x = Var.create_ [%here] 13 in
+            let o = observe (Var.watch x) in
+            assert (State.(num_active_observers t) = before + 1);
             stabilize_ [%here];
-            check [ Unnecessary ]
+            assert (value_exn o = 13);
+            Gc.full_major ();
+            assert (State.(num_active_observers t) = before + 1);
+            stabilize_ [%here];
+            assert (State.(num_active_observers t) = before)
           ;;
 
           let%expect_test _ =
-            (* on-change handlers of a node that changes but is not necessary at the end
-             of a stabilization *)
-            let v = Var.create_ [%here] 0 in
-            let n = Var.watch v in
-            let push, check = on_update_queue () in
-            on_update n ~f:push;
-            let o = observe n in
+            (* finalizers don't disable on-update handlers *)
+            let x = Var.create_ [%here] 13 in
+            let o = observe (Var.watch x) in
+            let r = ref 0 in
+            Observer.on_update_exn o ~f:(fun _ -> incr r);
             stabilize_ [%here];
-            check [ Necessary 0 ];
-            disallow_future_use o;
-            Var.set v 1;
-            let o = observe (freeze n) in
+            assert (!r = 1);
+            Gc.full_major ();
+            Var.set x 14;
             stabilize_ [%here];
-            check [ Unnecessary ];
-            disallow_future_use o
+            assert (!r = 2)
           ;;
 
           let%expect_test _ =
-            (* value changing with different observers *)
-            let v = Var.create_ [%here] 13 in
-            let o = observe (watch v) in
+            (* finalizers cause an [Unnecessary] update to be sent *)
+            let x = Var.create 13 in
+            let o = observe (watch x) in
             let push, check = on_update_queue () in
-            on_update (watch v) ~f:push;
+            on_update (watch x) ~f:push;
             stabilize_ [%here];
             check [ Necessary 13 ];
-            disallow_future_use o;
+            Gc.keep_alive o;
+            Gc.full_major ();
             stabilize_ [%here];
-            check [ Unnecessary ];
-            Var.set v 14;
-            let o = observe (watch v) in
+            check [ Unnecessary ]
+          ;;
+
+          let%expect_test _ =
+            (* [disallow_future_use] and finalize in the same stabilization. *)
+            let x = Var.create_ [%here] 1 in
+            let o = observe (Var.watch x) in
+            stabilize_ [%here];
+            disallow_future_use o;
+            Gc.full_major ();
+            stabilize_ [%here]
+          ;;
+
+          let%expect_test _ =
+            (* finalize after disallow_future_use *)
+            let x = Var.create_ [%here] 1 in
+            let o = observe (Var.watch x) in
             stabilize_ [%here];
             disallow_future_use o;
-            check [ Necessary 14 ]
+            stabilize_ [%here];
+            (* This [full_major] + [stabilize] causes the finalizer for [o] to run and
+               makes sure that it doesn't do anything wrong, given that
+               [disallow_future_use o] has already been called. *)
+            Gc.full_major ();
+            stabilize_ [%here]
           ;;
 
           let%expect_test _ =
-            (* call at next stabilization *)
-            let v = Var.create_ [%here] 13 in
-            let o = observe (Var.watch v) in
+            (* after user resurrection of an observer, it is still disallowed *)
+            let x = Var.create_ [%here] 13 in
+            let o = observe (Var.watch x) in
+            stabilize_ [%here];
+            Gc.keep_alive o;
+            let r = ref None in
+            Gc.Expert.add_finalizer_exn o (fun o -> r := Some o);
+            Gc.full_major ();
             stabilize_ [%here];
+            let o = Option.value_exn !r in
+            assert (not (use_is_allowed o))
+          ;;
+
+          let%expect_test _ =
+            (* lots of observers on the same node isn't quadratic. *)
+            (* We can't run this test with debugging, because it's too slow. *)
+            if not debug
+            then (
+              let t = const 13 in
+              let observers = List.init 100_000 ~f:(fun _ -> observe t) in
+              let cpu_used () =
+                let module R = Unix.Resource_usage in
+                let { R.utime; stime; _ } = R.get `Self in
+                Time_ns.Span.of_sec (utime +. stime)
+              in
+              let before = cpu_used () in
+              (* Don't use [stabilize_], which runs the invariant, which is too slow
+                 here. *)
+              stabilize ();
+              List.iter observers ~f:Observer.disallow_future_use;
+              stabilize ();
+              let consumed = Time_ns.Span.( - ) (cpu_used ()) before in
+              assert (Time_ns.Span.( < ) consumed (sec 1.)))
+          ;;
+
+          module Update = Update
+
+          let on_update_exn = on_update_exn
+
+          let%expect_test _ =
+            let x = Var.create_ [%here] 13 in
+            let parent = map (watch x) ~f:(fun x -> x + 1) in
+            let parent_o = observe parent in
+            let num_calls = ref 0 in
             let r = ref 0 in
-            on_update (Var.watch v) ~f:(fun _ -> incr r);
+            on_update_exn parent_o ~f:(function
+              | Initialized i | Changed (_, i) ->
+                num_calls := !num_calls + 1;
+                r := i
+              | Invalidated -> assert false);
             stabilize_ [%here];
-            assert (!r = 1);
+            assert (!num_calls = 1);
+            Var.set x 15;
+            stabilize_ [%here];
+            assert (!num_calls = 2);
+            assert (!r = 16);
+            disallow_future_use parent_o;
+            Var.set x 17;
+            stabilize_ [%here];
+            assert (!num_calls = 2);
+            assert (!r = 16)
+          ;;
+
+          let%expect_test _ =
+            (* [on_update_exn] of an invalid node, not during a stabilization *)
+            let o = observe invalid in
+            on_update_exn o ~f:(fun _ -> assert false);
             disallow_future_use o
           ;;
 
           let%expect_test _ =
-            (* called at next stabilization with [Unnecessary] update *)
-            let v = Var.create_ [%here] 13 in
-            let o = observe (Var.watch v) in
-            stabilize_ [%here];
-            let push, check = on_update_queue () in
-            on_update (watch v) ~f:push;
-            disallow_future_use o;
+            (* [on_update_exn] of an invalid node *)
+            let o = observe invalid in
+            let is_ok = ref false in
+            on_update_exn o ~f:(function
+              | Invalidated -> is_ok := true
+              | _ -> assert (skip_invalidity_check || false));
             stabilize_ [%here];
-            check [ Unnecessary ]
+            assert (skip_invalidity_check || !is_ok)
           ;;
 
           let%expect_test _ =
-            (* transition from unnecessary to necessary and back *)
-            let x = Var.create 13 in
-            let push, check = on_update_queue () in
-            on_update (watch x) ~f:push;
+            (* stabilizing with an on-update handler of a node that is invalidated *)
+            let x = Var.create 0 in
+            let r = ref None in
+            let o1 =
+              observe
+                (bind (watch x) ~f:(fun i ->
+                   let t = const i in
+                   r := Some t;
+                   t))
+            in
             stabilize_ [%here];
-            check [ Unnecessary ];
-            let o = observe (watch x) in
+            let o2 = observe (Option.value_exn !r) in
+            let invalidated = ref false in
+            Observer.on_update_exn o2 ~f:(function
+              | Invalidated -> invalidated := true
+              | _ -> ());
             stabilize_ [%here];
-            check [ Necessary 13 ];
-            Var.set x 14;
+            assert (not !invalidated);
+            Var.set x 1;
             stabilize_ [%here];
-            check [ Changed (13, 14) ];
+            assert (skip_invalidity_check || !invalidated);
+            disallow_future_use o1;
+            disallow_future_use o2
+          ;;
+
+          let%expect_test _ =
+            (* [on_update_exn] of a disallowed observer *)
+            let o = observe (const 5) in
+            disallow_future_use o;
+            assert (does_raise (fun () -> on_update_exn o ~f:(fun _ -> assert false)))
+          ;;
+
+          let%expect_test _ =
+            (* [disallow_future_use] before first stabilization *)
+            let o = observe (const 5) in
             disallow_future_use o;
             stabilize_ [%here];
-            check [ Unnecessary ]
+            disallow_future_use o
           ;;
 
           let%expect_test _ =
-            (* an indirectly necessary node *)
+            (* [disallow_future_use] during an on-update handler *)
             let x = Var.create_ [%here] 13 in
-            let push, check = on_update_queue () in
-            on_update (Var.watch x) ~f:push;
-            let t = Var.watch x >>| fun i -> i + 1 in
+            let o = observe (watch x) in
+            on_update_exn o ~f:(fun _ -> disallow_future_use o);
+            stabilize_ [%here];
+            assert (is_error (value o))
+          ;;
+
+          let%expect_test _ =
+            (* disallowing other on-update handlers in an on-update handler *)
+            let x = Var.create_ [%here] 13 in
+            let o = observe (watch x) in
+            for _ = 1 to 2 do
+              on_update_exn o ~f:(fun _ ->
+                assert (use_is_allowed o);
+                disallow_future_use o)
+            done;
+            stabilize_ [%here]
+          ;;
+
+          let%expect_test _ =
+            (* disallowing other observers of the same node an on-update handler *)
+            let x = Var.create_ [%here] 13 in
+            let o1 = observe (watch x) in
+            let o2 = observe (watch x) in
+            let o3 = observe (watch x) in
+            List.iter [ o1; o3 ] ~f:(fun o ->
+              on_update_exn o ~f:(fun _ -> assert (use_is_allowed o)));
+            on_update_exn o2 ~f:(fun _ ->
+              disallow_future_use o1;
+              disallow_future_use o3);
+            stabilize_ [%here]
+          ;;
+
+          let%expect_test _ =
+            (* disallowing observers of other nodes in an on-update handler *)
+            let o () = observe (watch (Var.create_ [%here] 13)) in
+            let o1 = o () in
+            let o2 = o () in
+            let o3 = o () in
+            List.iter [ o1; o3 ] ~f:(fun o ->
+              on_update_exn o ~f:(fun _ -> assert (use_is_allowed o)));
+            on_update_exn o2 ~f:(fun _ ->
+              disallow_future_use o1;
+              disallow_future_use o3);
+            stabilize_ [%here]
+          ;;
+
+          let%expect_test _ =
+            (* adding an on-update-handler to an already stable node *)
+            let x = watch (Var.create 13) in
+            let o = observe x in
             stabilize_ [%here];
-            check [ Unnecessary ];
-            let o = observe t in
+            let did_run = ref false in
+            on_update_exn (observe x) ~f:(fun _ -> did_run := true);
+            assert (not !did_run);
             stabilize_ [%here];
-            check [ Necessary 13 ];
-            disallow_future_use o;
+            assert !did_run;
+            disallow_future_use o
+          ;;
+
+          let%expect_test _ =
+            (* adding an on-update handler after a change *)
+            let x = Var.create 13 in
+            let o = observe (watch x) in
+            let push1, check1 = on_observer_update_queue () in
+            Observer.on_update_exn o ~f:push1;
             stabilize_ [%here];
-            check [ Unnecessary ];
-            let o = observe t in
+            check1 [ Initialized 13 ];
+            Var.set x 14;
             stabilize_ [%here];
-            check [ Necessary 13 ];
-            disallow_future_use o;
+            check1 [ Changed (13, 14) ];
+            let push2, check2 = on_observer_update_queue () in
+            Observer.on_update_exn o ~f:push2;
             stabilize_ [%here];
-            check [ Unnecessary ]
+            check2 [ Initialized 14 ];
+            Var.set x 15;
+            stabilize_ [%here];
+            check1 [ Changed (14, 15) ];
+            check2 [ Changed (14, 15) ]
           ;;
 
           let%expect_test _ =
-            (* [on_update] doesn't make a node necessary *)
-            let v = Var.create_ [%here] 13 in
-            let push, check = on_update_queue () in
-            on_update (watch v) ~f:push;
-            stabilize_ [%here];
-            check [ Unnecessary ];
-            Var.set v 14;
+            (* adding an on-update handler in an on-update handler. *)
+            let x = Var.create 13 in
+            let o = observe (watch x) in
+            let did_run = ref false in
+            on_update_exn o ~f:(fun _ ->
+              on_update_exn (observe (watch x)) ~f:(fun _ -> did_run := true));
             stabilize_ [%here];
-            check [];
-            let o = observe (Var.watch v) in
+            assert (not !did_run);
+            Var.set x 14;
             stabilize_ [%here];
-            check [ Necessary 14 ];
-            disallow_future_use o
+            assert !did_run;
+            Gc.full_major ();
+            stabilize_ [%here]
           ;;
 
           let%expect_test _ =
-            (* invalid from the start *)
-            let push, check = on_update_queue () in
-            on_update invalid ~f:push;
+            (* adding an on-update-handler to an invalid node in an on-update
+               handler. *)
+            let module I = Make () in
+            let open I in
+            let o = observe (watch (Var.create 13)) in
+            let is_ok = ref false in
+            Observer.on_update_exn o ~f:(fun _ ->
+              Observer.on_update_exn (observe invalid) ~f:(function
+                | Invalidated -> is_ok := true
+                | _ -> assert (skip_invalidity_check || false)));
             stabilize_ [%here];
-            if check_invalidity then check [ Invalidated ]
+            assert (not !is_ok);
+            stabilize_ [%here];
+            assert (skip_invalidity_check || !is_ok)
           ;;
 
           let%expect_test _ =
-            (* invalidation of an unnecessary node *)
-            let v = Var.create_ [%here] 13 in
-            let r = ref None in
+            (* on-update-handlers added during the firing of other on-update-handlers
+               should not fire now but instead after the next stabilization *)
+            List.iter
+              [ const 1; invalid ]
+              ~f:(fun node ->
+                let o1 = observe (const 1) in
+                let o2 = observe node in
+                let ran = ref 0 in
+                Observer.on_update_exn o1 ~f:(fun _ ->
+                  Observer.on_update_exn o2 ~f:(fun _ -> incr ran));
+                Observer.on_update_exn o2 ~f:(fun _ -> ());
+                assert (!ran = 0);
+                stabilize_ [%here];
+                assert (!ran = 0);
+                stabilize_ [%here];
+                assert (!ran = 1);
+                stabilize_ [%here];
+                assert (!ran = 1);
+                disallow_future_use o1;
+                disallow_future_use o2)
+          ;;
+
+          let%expect_test _ =
+            (* on-update handler set up during stabilization fires after the
+               stabilization *)
+            let called = ref false in
+            let unit = const () in
+            let o_unit = observe unit in
             let o =
               observe
-                (bind (watch v) ~f:(fun i ->
-                   r := Some (const i);
-                   return ()))
+                (map unit ~f:(fun () -> on_update_exn o_unit ~f:(fun _ -> called := true)))
             in
+            assert (not !called);
             stabilize_ [%here];
-            let i = Option.value_exn !r in
-            let push, check = on_update_queue () in
-            on_update i ~f:push;
-            stabilize_ [%here];
-            check [ Unnecessary ];
-            Var.set v 14;
-            stabilize_ [%here];
-            if check_invalidity then check [ Invalidated ];
-            disallow_future_use o
+            assert !called;
+            disallow_future_use o;
+            disallow_future_use o_unit
+          ;;
+
+          let%expect_test _ =
+            (* on-update handlers are initialized once *)
+            let v = Var.create (const 0) in
+            let i = Var.watch v in
+            let o = observe i in
+            let old_val_is_none_once () =
+              let is_first_call = ref true in
+              function
+              | Observer.Update.Initialized _ ->
+                assert !is_first_call;
+                is_first_call := false
+              | Changed _ -> assert (not !is_first_call)
+              | Invalidated -> assert false
+            in
+            Observer.on_update_exn o ~f:(old_val_is_none_once ());
+            stabilize ();
+            Observer.on_update_exn o ~f:(old_val_is_none_once ());
+            stabilize ()
           ;;
 
           let%expect_test _ =
-            (* invalidation of a necessary node *)
-            let v = Var.create_ [%here] 13 in
+            (* creating an observer during stabilization *)
+            let x = Var.create 13 in
             let r = ref None in
             let o1 =
               observe
-                (bind (watch v) ~f:(fun i ->
-                   r := Some (const i);
-                   return ()))
+                (Var.watch x
+                 >>| fun _ ->
+                 let o2 = observe (Var.watch x) in
+                 assert (use_is_allowed o2);
+                 assert (is_error (value o2));
+                 r := Some o2;
+                 0)
             in
             stabilize_ [%here];
-            let i = Option.value_exn !r in
-            let o2 = observe i in
-            let push, check = on_update_queue () in
-            on_update i ~f:push;
-            stabilize_ [%here];
-            check [ Necessary 13 ];
-            Var.set v 14;
+            let o2 = Option.value_exn !r in
+            assert (use_is_allowed o2);
+            assert (is_error (value o2));
             stabilize_ [%here];
-            if check_invalidity then check [ Invalidated ];
+            assert (value_exn o2 = 13);
             disallow_future_use o1;
-            disallow_future_use o2
+            disallow_future_use o2;
+            stabilize_ [%here];
+            assert (is_error (value o2))
           ;;
 
           let%expect_test _ =
-            (* invalidation of a necessary node after a change *)
-            let v = Var.create_ [%here] 13 in
-            let w = Var.create_ [%here] 14 in
-            let r = ref None in
-            let o1 =
+            (* creating an observer and adding on_update handler during
+               stabilization *)
+            let v = Var.create 0 in
+            let push, check = on_observer_update_queue () in
+            let inner_obs = ref None in
+            let o =
               observe
-                (bind (watch v) ~f:(fun _ ->
-                   r := Some (watch w >>| Fn.id);
-                   return ()))
+                (Var.watch v
+                 >>| fun i ->
+                 let observer = observe (Var.watch v) in
+                 inner_obs := Some observer;
+                 on_update_exn observer ~f:push;
+                 i)
             in
+            check [];
             stabilize_ [%here];
-            let i = Option.value_exn !r in
-            let o2 = observe i in
-            let push, check = on_update_queue () in
-            on_update i ~f:push;
-            stabilize_ [%here];
-            check [ Necessary 14 ];
-            Var.set w 15;
+            check [];
             stabilize_ [%here];
-            check [ Changed (14, 15) ];
-            Var.set v 16;
+            check [ Initialized 0 ];
+            disallow_future_use o;
+            disallow_future_use (Option.value_exn !inner_obs)
+          ;;
+
+          let%expect_test _ =
+            (* disallow_future_use during stabilization *)
+            let x = Var.create 13 in
+            let handler_ran = ref false in
+            let o1 = observe (Var.watch x) in
+            let o2 =
+              observe
+                (Var.watch x
+                 >>| fun i ->
+                 on_update_exn o1 ~f:(fun _ -> handler_ran := true);
+                 disallow_future_use o1;
+                 assert (not (use_is_allowed o1));
+                 i)
+            in
+            assert (use_is_allowed o1);
+            assert (not !handler_ran);
             stabilize_ [%here];
-            if check_invalidity then check [ Invalidated ];
-            disallow_future_use o1;
+            assert (not (use_is_allowed o1));
+            assert (not !handler_ran);
             disallow_future_use o2
           ;;
 
           let%expect_test _ =
-            (* making a node necessary from an on-update handler *)
-            let x = Var.create_ [%here] 13 in
-            let y = Var.create_ [%here] 14 in
+            (* creating an observer and disallowing use during stabilization *)
+            let x = Var.create 13 in
             let r = ref None in
-            let push_x, check_x = on_update_queue () in
-            on_update (watch x) ~f:push_x;
-            let o = observe (watch y) in
-            let push_o, check_o = on_observer_update_queue () in
-            Observer.on_update_exn o ~f:(fun u ->
-              push_o u;
-              r := Some (observe (watch x)));
-            stabilize_ [%here];
-            check_x [ Unnecessary ];
-            check_o [ Initialized 14 ];
-            let ox = Option.value_exn !r in
-            Var.set x 15;
+            let o1 =
+              observe
+                (Var.watch x
+                 >>| fun _ ->
+                 let o2 = observe (Var.watch x) in
+                 r := Some o2;
+                 disallow_future_use o2;
+                 0)
+            in
             stabilize_ [%here];
-            check_x [ Necessary 15 ];
-            check_o [];
-            disallow_future_use o;
-            disallow_future_use ox
+            let o2 = Option.value_exn !r in
+            assert (not (use_is_allowed o2));
+            disallow_future_use o1;
+            stabilize_ [%here]
           ;;
 
           let%expect_test _ =
-            (* calling [advance_clock] in an on-update handler *)
-            let clock = Clock.create ~start:Time_ns.epoch () in
-            let i = Clock.after clock (sec 1.) in
-            let o = observe i in
-            let num_fires = ref 0 in
-            on_update i ~f:(fun _ ->
-              incr num_fires;
-              Clock.advance_clock_by clock (sec 2.));
-            assert (!num_fires = 0);
+            (* creating an observer and finalizing it during stabilization *)
+            let x = Var.create 13 in
+            let o =
+              observe
+                (Var.watch x
+                 >>| fun _ ->
+                 Fn.ignore (observe (Var.watch x) : _ Observer.t);
+                 Gc.full_major ();
+                 0)
+            in
             stabilize_ [%here];
-            assert (!num_fires = 1);
             stabilize_ [%here];
-            assert (!num_fires = 2);
             disallow_future_use o
           ;;
+        end
+
+        let on_update = on_update
+
+        let%expect_test _ =
+          let v = Var.create_ [%here] 13 in
+          let push, check = on_update_queue () in
+          let o = observe (watch v) in
+          on_update (watch v) ~f:push;
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          stabilize_ [%here];
+          check [];
+          Var.set v 14;
+          stabilize_ [%here];
+          check [ Changed (13, 14) ];
+          disallow_future_use o;
+          Var.set v 15;
+          stabilize_ [%here];
+          check [ Unnecessary ]
+        ;;
+
+        let%expect_test _ =
+          (* on-change handlers of a node that changes but is not necessary at the end
+             of a stabilization *)
+          let v = Var.create_ [%here] 0 in
+          let n = Var.watch v in
+          let push, check = on_update_queue () in
+          on_update n ~f:push;
+          let o = observe n in
+          stabilize_ [%here];
+          check [ Necessary 0 ];
+          disallow_future_use o;
+          Var.set v 1;
+          let o = observe (freeze n) in
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* value changing with different observers *)
+          let v = Var.create_ [%here] 13 in
+          let o = observe (watch v) in
+          let push, check = on_update_queue () in
+          on_update (watch v) ~f:push;
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          disallow_future_use o;
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          Var.set v 14;
+          let o = observe (watch v) in
+          stabilize_ [%here];
+          disallow_future_use o;
+          check [ Necessary 14 ]
+        ;;
+
+        let%expect_test _ =
+          (* call at next stabilization *)
+          let v = Var.create_ [%here] 13 in
+          let o = observe (Var.watch v) in
+          stabilize_ [%here];
+          let r = ref 0 in
+          on_update (Var.watch v) ~f:(fun _ -> incr r);
+          stabilize_ [%here];
+          assert (!r = 1);
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* called at next stabilization with [Unnecessary] update *)
+          let v = Var.create_ [%here] 13 in
+          let o = observe (Var.watch v) in
+          stabilize_ [%here];
+          let push, check = on_update_queue () in
+          on_update (watch v) ~f:push;
+          disallow_future_use o;
+          stabilize_ [%here];
+          check [ Unnecessary ]
+        ;;
+
+        let%expect_test _ =
+          (* transition from unnecessary to necessary and back *)
+          let x = Var.create 13 in
+          let push, check = on_update_queue () in
+          on_update (watch x) ~f:push;
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          let o = observe (watch x) in
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          Var.set x 14;
+          stabilize_ [%here];
+          check [ Changed (13, 14) ];
+          disallow_future_use o;
+          stabilize_ [%here];
+          check [ Unnecessary ]
+        ;;
+
+        let%expect_test _ =
+          (* an indirectly necessary node *)
+          let x = Var.create_ [%here] 13 in
+          let push, check = on_update_queue () in
+          on_update (Var.watch x) ~f:push;
+          let t = Var.watch x >>| fun i -> i + 1 in
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          let o = observe t in
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          disallow_future_use o;
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          let o = observe t in
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          disallow_future_use o;
+          stabilize_ [%here];
+          check [ Unnecessary ]
+        ;;
+
+        let%expect_test _ =
+          (* [on_update] doesn't make a node necessary *)
+          let v = Var.create_ [%here] 13 in
+          let push, check = on_update_queue () in
+          on_update (watch v) ~f:push;
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          Var.set v 14;
+          stabilize_ [%here];
+          check [];
+          let o = observe (Var.watch v) in
+          stabilize_ [%here];
+          check [ Necessary 14 ];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* invalid from the start *)
+          let push, check = on_update_queue () in
+          on_update invalid ~f:push;
+          stabilize_ [%here];
+          if check_invalidity then check [ Invalidated ]
+        ;;
+
+        let%expect_test _ =
+          (* invalidation of an unnecessary node *)
+          let v = Var.create_ [%here] 13 in
+          let r = ref None in
+          let o =
+            observe
+              (bind (watch v) ~f:(fun i ->
+                 r := Some (const i);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let i = Option.value_exn !r in
+          let push, check = on_update_queue () in
+          on_update i ~f:push;
+          stabilize_ [%here];
+          check [ Unnecessary ];
+          Var.set v 14;
+          stabilize_ [%here];
+          if check_invalidity then check [ Invalidated ];
+          disallow_future_use o
+        ;;
+
+        let%expect_test _ =
+          (* invalidation of a necessary node *)
+          let v = Var.create_ [%here] 13 in
+          let r = ref None in
+          let o1 =
+            observe
+              (bind (watch v) ~f:(fun i ->
+                 r := Some (const i);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let i = Option.value_exn !r in
+          let o2 = observe i in
+          let push, check = on_update_queue () in
+          on_update i ~f:push;
+          stabilize_ [%here];
+          check [ Necessary 13 ];
+          Var.set v 14;
+          stabilize_ [%here];
+          if check_invalidity then check [ Invalidated ];
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test _ =
+          (* invalidation of a necessary node after a change *)
+          let v = Var.create_ [%here] 13 in
+          let w = Var.create_ [%here] 14 in
+          let r = ref None in
+          let o1 =
+            observe
+              (bind (watch v) ~f:(fun _ ->
+                 r := Some (watch w >>| Fn.id);
+                 return ()))
+          in
+          stabilize_ [%here];
+          let i = Option.value_exn !r in
+          let o2 = observe i in
+          let push, check = on_update_queue () in
+          on_update i ~f:push;
+          stabilize_ [%here];
+          check [ Necessary 14 ];
+          Var.set w 15;
+          stabilize_ [%here];
+          check [ Changed (14, 15) ];
+          Var.set v 16;
+          stabilize_ [%here];
+          if check_invalidity then check [ Invalidated ];
+          disallow_future_use o1;
+          disallow_future_use o2
+        ;;
+
+        let%expect_test _ =
+          (* making a node necessary from an on-update handler *)
+          let x = Var.create_ [%here] 13 in
+          let y = Var.create_ [%here] 14 in
+          let r = ref None in
+          let push_x, check_x = on_update_queue () in
+          on_update (watch x) ~f:push_x;
+          let o = observe (watch y) in
+          let push_o, check_o = on_observer_update_queue () in
+          Observer.on_update_exn o ~f:(fun u ->
+            push_o u;
+            r := Some (observe (watch x)));
+          stabilize_ [%here];
+          check_x [ Unnecessary ];
+          check_o [ Initialized 14 ];
+          let ox = Option.value_exn !r in
+          Var.set x 15;
+          stabilize_ [%here];
+          check_x [ Necessary 15 ];
+          check_o [];
+          disallow_future_use o;
+          disallow_future_use ox
+        ;;
+
+        let%expect_test _ =
+          (* calling [advance_clock] in an on-update handler *)
+          let clock = Clock.create ~start:Time_ns.epoch () in
+          let i = Clock.after clock (sec 1.) in
+          let o = observe i in
+          let num_fires = ref 0 in
+          on_update i ~f:(fun _ ->
+            incr num_fires;
+            Clock.advance_clock_by clock (sec 2.));
+          assert (!num_fires = 0);
+          stabilize_ [%here];
+          assert (!num_fires = 1);
+          stabilize_ [%here];
+          assert (!num_fires = 2);
+          disallow_future_use o
+        ;;
+
+        module Cutoff = struct
+          open Cutoff
 
-          module Cutoff = struct
-            open Cutoff
-
-            type nonrec 'a t = 'a t
-
-            let sexp_of_t = sexp_of_t
-            let invariant = invariant
-            let create = create
-
-            (* tested below *)
-
-            let _ = create
-            let of_compare = of_compare
-            let of_equal = of_equal
-            let should_cutoff = should_cutoff
-
-            let%expect_test _ =
-              let t = of_compare Int.compare in
-              assert (should_cutoff t ~old_value:0 ~new_value:0);
-              assert (not (should_cutoff t ~old_value:0 ~new_value:1))
-            ;;
-
-            let%expect_test _ =
-              let t = of_equal Int.equal in
-              assert (should_cutoff t ~old_value:0 ~new_value:0);
-              assert (not (should_cutoff t ~old_value:0 ~new_value:1))
-            ;;
-
-            let always = always
-
-            let%expect_test _ =
-              let x = Var.create_ [%here] 0 in
-              set_cutoff (watch x) always;
-              let r = ref 0 in
-              let o = observe (watch x >>| fun _i -> incr r) in
-              stabilize_ [%here];
-              assert (!r = 1);
-              List.iter
-                [ 1, 1; 0, 1 ]
-                ~f:(fun (v, expect) ->
-                  Var.set x v;
-                  stabilize_ [%here];
-                  assert (!r = expect));
-              disallow_future_use o
-            ;;
-
-            let never = never
-
-            let%expect_test _ =
-              let x = Var.create_ [%here] 0 in
-              set_cutoff (watch x) never;
-              let r = ref 0 in
-              let o = observe (watch x >>| fun _i -> incr r) in
-              stabilize_ [%here];
-              assert (!r = 1);
-              List.iter
-                [ 1, 2; 1, 3; 1, 4 ]
-                ~f:(fun (v, expect) ->
-                  Var.set x v;
-                  stabilize_ [%here];
-                  assert (!r = expect));
-              disallow_future_use o
-            ;;
-
-            let phys_equal = phys_equal
+          type nonrec 'a t = 'a t
 
-            let%expect_test _ =
-              let r1 = ref () in
-              let r2 = ref () in
-              let x = Var.create_ [%here] r1 in
-              set_cutoff (watch x) phys_equal;
-              let r = ref 0 in
-              let o = observe (watch x >>| fun _i -> incr r) in
-              stabilize_ [%here];
-              assert (!r = 1);
-              List.iter
-                [ r1, 1; r2, 2; r2, 2; r1, 3 ]
-                ~f:(fun (v, expect) ->
-                  Var.set x v;
-                  stabilize_ [%here];
-                  assert (!r = expect));
-              disallow_future_use o
-            ;;
+          let sexp_of_t = sexp_of_t
+          let invariant = invariant
+          let create = create
 
-            let poly_equal = poly_equal
+          (* tested below *)
 
-            let%expect_test _ =
-              let r1a = ref 1 in
-              let r1b = ref 1 in
-              let r2 = ref 2 in
-              let x = Var.create_ [%here] r1a in
-              set_cutoff (watch x) poly_equal;
-              let r = ref 0 in
-              let o = observe (watch x >>| fun _i -> incr r) in
-              stabilize_ [%here];
-              assert (!r = 1);
-              List.iter
-                [ r1a, 1; r1b, 1; r2, 2; r1a, 3 ]
-                ~f:(fun (v, expect) ->
-                  Var.set x v;
-                  stabilize_ [%here];
-                  assert (!r = expect));
-              disallow_future_use o
-            ;;
+          let _ = create
+          let of_compare = of_compare
+          let of_equal = of_equal
+          let should_cutoff = should_cutoff
 
-            let equal = equal
-            let%test _ = equal never never
-            let%test _ = not (equal never always)
-          end
+          let%expect_test _ =
+            let t = of_compare Int.compare in
+            assert (should_cutoff t ~old_value:0 ~new_value:0);
+            assert (not (should_cutoff t ~old_value:0 ~new_value:1))
+          ;;
+
+          let%expect_test _ =
+            let t = of_equal Int.equal in
+            assert (should_cutoff t ~old_value:0 ~new_value:0);
+            assert (not (should_cutoff t ~old_value:0 ~new_value:1))
+          ;;
 
-          let get_cutoff = get_cutoff
-          let set_cutoff = set_cutoff
+          let always = always
 
           let%expect_test _ =
-            let i = Var.watch (Var.create_ [%here] 0) in
-            assert (Cutoff.equal (get_cutoff i) Cutoff.phys_equal);
-            set_cutoff i Cutoff.never;
-            assert (Cutoff.equal (get_cutoff i) Cutoff.never)
+            let x = Var.create_ [%here] 0 in
+            set_cutoff (watch x) always;
+            let r = ref 0 in
+            let o = observe (watch x >>| fun _i -> incr r) in
+            stabilize_ [%here];
+            assert (!r = 1);
+            List.iter
+              [ 1, 1; 0, 1 ]
+              ~f:(fun (v, expect) ->
+                Var.set x v;
+                stabilize_ [%here];
+                assert (!r = expect));
+            disallow_future_use o
           ;;
 
+          let never = never
+
           let%expect_test _ =
-            let a = Var.create_ [%here] 0 in
-            let n = map ~f:Fn.id (watch a) in
-            set_cutoff
-              n
-              (Cutoff.create (fun ~old_value ~new_value ->
-                 abs (old_value - new_value) <= 1));
-            let a' = observe n in
-            stabilize_ [%here];
-            assert (value a' = 0);
+            let x = Var.create_ [%here] 0 in
+            set_cutoff (watch x) never;
+            let r = ref 0 in
+            let o = observe (watch x >>| fun _i -> incr r) in
+            stabilize_ [%here];
+            assert (!r = 1);
             List.iter
-              [ 1, 0; 2, 2; 2, 2 ]
+              [ 1, 2; 1, 3; 1, 4 ]
               ~f:(fun (v, expect) ->
-                Var.set a v;
+                Var.set x v;
                 stabilize_ [%here];
-                assert (value a' = expect))
+                assert (!r = expect));
+            disallow_future_use o
           ;;
 
-          module Scope = struct
-            open Scope
+          let phys_equal = phys_equal
 
-            type nonrec t = t
+          let%expect_test _ =
+            let r1 = ref () in
+            let r2 = ref () in
+            let x = Var.create_ [%here] r1 in
+            set_cutoff (watch x) phys_equal;
+            let r = ref 0 in
+            let o = observe (watch x >>| fun _i -> incr r) in
+            stabilize_ [%here];
+            assert (!r = 1);
+            List.iter
+              [ r1, 1; r2, 2; r2, 2; r1, 3 ]
+              ~f:(fun (v, expect) ->
+                Var.set x v;
+                stabilize_ [%here];
+                assert (!r = expect));
+            disallow_future_use o
+          ;;
 
-            let top = top
-            let is_top = is_top
+          let poly_equal = poly_equal
 
-            let%expect_test _ =
-              let t = current () in
-              assert (phys_equal t top)
-            ;;
+          let%expect_test _ =
+            let r1a = ref 1 in
+            let r1b = ref 1 in
+            let r2 = ref 2 in
+            let x = Var.create_ [%here] r1a in
+            set_cutoff (watch x) poly_equal;
+            let r = ref 0 in
+            let o = observe (watch x >>| fun _i -> incr r) in
+            stabilize_ [%here];
+            assert (!r = 1);
+            List.iter
+              [ r1a, 1; r1b, 1; r2, 2; r1a, 3 ]
+              ~f:(fun (v, expect) ->
+                Var.set x v;
+                stabilize_ [%here];
+                assert (!r = expect));
+            disallow_future_use o
+          ;;
 
-            let current = current
-            let within = within
+          let equal = equal
+          let%test _ = equal never never
+          let%test _ = not (equal never always)
+        end
 
-            let%expect_test _ =
-              let o = observe (within (current ()) ~f:(fun () -> const 13)) in
-              stabilize_ [%here];
-              assert (value o = 13)
-            ;;
+        let get_cutoff = get_cutoff
+        let set_cutoff = set_cutoff
 
-            let%expect_test _ =
-              (* escaping a [bind] *)
-              let s = current () in
-              let r = ref None in
-              let x = Var.create_ [%here] 13 in
-              let o =
-                observe
-                  (bind (watch x) ~f:(fun i ->
-                     r := Some (within s ~f:(fun () -> const i));
-                     return ()))
-              in
-              stabilize_ [%here];
-              let o2 = observe (Option.value_exn !r) in
-              stabilize_ [%here];
-              assert (value o2 = 13);
-              Var.set x 14;
-              stabilize_ [%here];
-              assert (value o2 = 13);
-              disallow_future_use o;
-              stabilize_ [%here];
-              assert (value o2 = 13)
-            ;;
+        let%expect_test _ =
+          let i = Var.watch (Var.create_ [%here] 0) in
+          assert (Cutoff.equal (get_cutoff i) Cutoff.phys_equal);
+          set_cutoff i Cutoff.never;
+          assert (Cutoff.equal (get_cutoff i) Cutoff.never)
+        ;;
 
-            let%expect_test _ =
-              (* returning to a [bind] *)
-              let r = ref None in
-              let x = Var.create_ [%here] 13 in
-              let o1 =
-                observe
-                  (bind (watch x) ~f:(fun _i ->
-                     r := Some (current ());
-                     return ()))
-              in
-              stabilize_ [%here];
-              let s = Option.value_exn !r in
-              let o2 = observe (within s ~f:(fun () -> const 13)) in
+        let%expect_test _ =
+          let a = Var.create_ [%here] 0 in
+          let n = map ~f:Fn.id (watch a) in
+          set_cutoff
+            n
+            (Cutoff.create (fun ~old_value ~new_value -> abs (old_value - new_value) <= 1));
+          let a' = observe n in
+          stabilize_ [%here];
+          assert (value a' = 0);
+          List.iter
+            [ 1, 0; 2, 2; 2, 2 ]
+            ~f:(fun (v, expect) ->
+              Var.set a v;
               stabilize_ [%here];
-              assert (value o2 = 13);
-              Var.set x 14;
-              disallow_future_use o2;
-              stabilize_ [%here];
-              disallow_future_use o1
-            ;;
+              assert (value a' = expect))
+        ;;
 
-            let%test "top is top" = is_top top
+        module Scope = struct
+          open Scope
 
-            let%expect_test "scope inside bind is not top" =
-              let i = Var.create_ [%here] true in
-              let o =
-                observe
-                  (bind (watch i) ~f:(fun b ->
-                     assert (not (is_top (current ())));
-                     return b))
-              in
-              stabilize_ [%here];
-              print_s [%sexp (value o : bool)];
-              [%expect {| true |}];
-              Var.set i false;
-              stabilize_ [%here];
-              print_s [%sexp (value o : bool)];
-              [%expect {| false |}]
-            ;;
-          end
+          type nonrec t = t
 
-          let lazy_from_fun = lazy_from_fun
+          let top = top
+          let is_top = is_top
 
           let%expect_test _ =
-            (* laziness *)
-            let r = ref 0 in
-            let l = lazy_from_fun (fun () -> incr r) in
-            assert (!r = 0);
-            force l;
-            assert (!r = 1);
-            force l;
-            assert (!r = 1)
+            let t = current () in
+            assert (phys_equal t top)
           ;;
 
+          let current = current
+          let within = within
+
           let%expect_test _ =
-            (* nodes created when forcing are in the right scope *)
-            let l = lazy_from_fun (fun () -> const 13) in
-            let x = Var.create_ [%here] 13 in
-            let o = observe (bind (watch x) ~f:(fun _i -> force l)) in
-            stabilize_ [%here];
-            assert (value o = 13);
-            Var.set x 14;
+            let o = observe (within (current ()) ~f:(fun () -> const 13)) in
             stabilize_ [%here];
             assert (value o = 13)
           ;;
 
-          let default_hash_table_initial_size = default_hash_table_initial_size
-          let memoize_fun = memoize_fun
-          let memoize_fun_by_key = memoize_fun_by_key
-          let weak_memoize_fun = weak_memoize_fun
-          let weak_memoize_fun_by_key = weak_memoize_fun_by_key
-
-          let test_memoize_fun (memoize_fun : int Base.Hashtbl.Key.t -> _ -> _) =
+          let%expect_test _ =
+            (* escaping a [bind] *)
+            let s = current () in
+            let r = ref None in
             let x = Var.create_ [%here] 13 in
-            let y = Var.create_ [%here] 14 in
-            let z = Var.create_ [%here] 15 in
-            let num_calls = ref 0 in
             let o =
               observe
-                (bind
-                   (bind (watch x) ~f:(fun i1 ->
-                      let f i2 =
-                        incr num_calls;
-                        map (watch y) ~f:(fun i3 -> i1 + i2 + i3)
-                      in
-                      return (unstage (memoize_fun (module Int) f))))
-                   ~f:(fun f -> bind (watch z) ~f))
+                (bind (watch x) ~f:(fun i ->
+                   r := Some (within s ~f:(fun () -> const i));
+                   return ()))
             in
             stabilize_ [%here];
-            [%test_eq: int] (value o) 42;
-            assert (!num_calls = 1);
-            Var.set z 16;
-            stabilize_ [%here];
-            [%test_eq: int] (value o) 43;
-            assert (!num_calls = 2);
-            Var.set z 17;
-            stabilize_ [%here];
-            assert (!num_calls = 3);
-            [%test_eq: int] (value o) 44;
-            Var.set z 16;
+            let o2 = observe (Option.value_exn !r) in
             stabilize_ [%here];
-            assert (!num_calls = 3);
-            [%test_eq: int] (value o) 43;
-            Var.set y 20;
+            assert (value o2 = 13);
+            Var.set x 14;
             stabilize_ [%here];
-            assert (!num_calls = 3);
-            [%test_eq: int] (value o) 49;
-            Var.set x 30;
+            assert (value o2 = 13);
+            disallow_future_use o;
             stabilize_ [%here];
-            assert (!num_calls = 4);
-            [%test_eq: int] (value o) 66
-          ;;
-
-          let%expect_test _ = test_memoize_fun memoize_fun
-
-          let%expect_test _ =
-            test_memoize_fun (fun hashable f -> memoize_fun_by_key hashable Fn.id f)
-          ;;
-
-          let%expect_test _ =
-            test_memoize_fun (fun hashable f ->
-              let memo_f =
-                unstage (weak_memoize_fun hashable (fun a -> Heap_block.create_exn (f a)))
-              in
-              stage (fun a -> Heap_block.value (memo_f a)))
+            assert (value o2 = 13)
           ;;
 
           let%expect_test _ =
-            test_memoize_fun (fun hashable f ->
-              let memo_f =
-                unstage
-                  (weak_memoize_fun_by_key hashable Fn.id (fun a ->
-                     Heap_block.create_exn (f a)))
-              in
-              stage (fun a -> Heap_block.value (memo_f a)))
+            (* returning to a [bind] *)
+            let r = ref None in
+            let x = Var.create_ [%here] 13 in
+            let o1 =
+              observe
+                (bind (watch x) ~f:(fun _i ->
+                   r := Some (current ());
+                   return ()))
+            in
+            stabilize_ [%here];
+            let s = Option.value_exn !r in
+            let o2 = observe (within s ~f:(fun () -> const 13)) in
+            stabilize_ [%here];
+            assert (value o2 = 13);
+            Var.set x 14;
+            disallow_future_use o2;
+            stabilize_ [%here];
+            disallow_future_use o1
           ;;
 
-          let node_value = node_value
+          let%test "top is top" = is_top top
 
-          let%expect_test _ =
-            let show t = print_s [%sexp (node_value t : int Node_value.t)] in
-            if M.bind_lhs_change_should_invalidate_rhs
-            then (
-              show invalid;
-              [%expect {| Invalid |}]);
-            let x = Var.create 13 in
-            let t = watch x in
-            show t;
-            [%expect {| (Unnecessary_maybe_stale ()) |}];
-            let o = observe t in
-            show t;
-            [%expect {| (Unnecessary_maybe_stale ()) |}];
-            stabilize_ [%here];
-            show t;
-            [%expect {| (Necessary_maybe_stale (13)) |}];
-            Observer.disallow_future_use o;
+          let%expect_test "scope inside bind is not top" =
+            let i = Var.create_ [%here] true in
+            let o =
+              observe
+                (bind (watch i) ~f:(fun b ->
+                   assert (not (is_top (current ())));
+                   return b))
+            in
             stabilize_ [%here];
-            show t;
-            [%expect {| (Unnecessary_maybe_stale (13)) |}]
-          ;;
-
-          let%expect_test _ =
-            (* removal of unused data *)
-            let num_calls = ref 0 in
-            let f =
-              unstage
-                (weak_memoize_fun
-                   (module Int)
-                   (function
-                    | i ->
+            print_s [%sexp (value o : bool)];
+            [%expect {| true |}];
+            Var.set i false;
+            stabilize_ [%here];
+            print_s [%sexp (value o : bool)];
+            [%expect {| false |}]
+          ;;
+        end
+
+        let lazy_from_fun = lazy_from_fun
+
+        let%expect_test _ =
+          (* laziness *)
+          let r = ref 0 in
+          let l = lazy_from_fun (fun () -> incr r) in
+          assert (!r = 0);
+          force l;
+          assert (!r = 1);
+          force l;
+          assert (!r = 1)
+        ;;
+
+        let%expect_test _ =
+          (* nodes created when forcing are in the right scope *)
+          let l = lazy_from_fun (fun () -> const 13) in
+          let x = Var.create_ [%here] 13 in
+          let o = observe (bind (watch x) ~f:(fun _i -> force l)) in
+          stabilize_ [%here];
+          assert (value o = 13);
+          Var.set x 14;
+          stabilize_ [%here];
+          assert (value o = 13)
+        ;;
+
+        let default_hash_table_initial_size = default_hash_table_initial_size
+        let memoize_fun = memoize_fun
+        let memoize_fun_by_key = memoize_fun_by_key
+        let weak_memoize_fun = weak_memoize_fun
+        let weak_memoize_fun_by_key = weak_memoize_fun_by_key
+
+        let test_memoize_fun (memoize_fun : int Base.Hashtbl.Key.t -> _ -> _) =
+          let x = Var.create_ [%here] 13 in
+          let y = Var.create_ [%here] 14 in
+          let z = Var.create_ [%here] 15 in
+          let num_calls = ref 0 in
+          let o =
+            observe
+              (bind
+                 (bind (watch x) ~f:(fun i1 ->
+                    let f i2 =
                       incr num_calls;
-                      Heap_block.create_exn (ref i)))
+                      map (watch y) ~f:(fun i3 -> i1 + i2 + i3)
+                    in
+                    return (unstage (memoize_fun (module Int) f))))
+                 ~f:(fun f -> bind (watch z) ~f))
+          in
+          stabilize_ [%here];
+          [%test_eq: int] (value o) 42;
+          assert (!num_calls = 1);
+          Var.set z 16;
+          stabilize_ [%here];
+          [%test_eq: int] (value o) 43;
+          assert (!num_calls = 2);
+          Var.set z 17;
+          stabilize_ [%here];
+          assert (!num_calls = 3);
+          [%test_eq: int] (value o) 44;
+          Var.set z 16;
+          stabilize_ [%here];
+          assert (!num_calls = 3);
+          [%test_eq: int] (value o) 43;
+          Var.set y 20;
+          stabilize_ [%here];
+          assert (!num_calls = 3);
+          [%test_eq: int] (value o) 49;
+          Var.set x 30;
+          stabilize_ [%here];
+          assert (!num_calls = 4);
+          [%test_eq: int] (value o) 66
+        ;;
+
+        let%expect_test _ = test_memoize_fun memoize_fun
+
+        let%expect_test _ =
+          test_memoize_fun (fun hashable f -> memoize_fun_by_key hashable Fn.id f)
+        ;;
+
+        let%expect_test _ =
+          test_memoize_fun (fun hashable f ->
+            let memo_f =
+              unstage (weak_memoize_fun hashable (fun a -> Heap_block.create_exn (f a)))
             in
-            let f i = Heap_block.value (f i) in
-            let x0 = f 13 in
-            let x0' = f 13 in
-            let x1 = f 15 in
-            assert (!num_calls = 2);
-            assert (!x0 + !x0' + !x1 = 41);
-            Gc.full_major ();
-            assert (!num_calls = 2);
-            let _x0 = f 13 in
-            assert (!num_calls = 3);
-            assert (phys_equal (f 15) x1);
-            assert (!num_calls = 3);
-            Gc.keep_alive x1
-          ;;
+            stage (fun a -> Heap_block.value (memo_f a)))
+        ;;
 
-          let%expect_test _ =
-            (* removing a parent is constant time *)
-            (* We can't run this test with debugging, because it's too slow. *)
-            if not debug
-            then
-              for e = 0 to 5 do
-                let num_observers = Float.to_int (10. ** Float.of_int e) in
-                let t = const 13 in
-                let observers =
-                  List.init num_observers ~f:(fun _ -> observe (map t ~f:Fn.id))
-                in
-                let cpu_used () =
-                  let module R = Unix.Resource_usage in
-                  let { R.utime; stime; _ } = R.get `Self in
-                  Time_ns.Span.of_sec (utime +. stime)
-                in
-                let before = cpu_used () in
-                (* Don't use [stabilize_], which runs the invariant, which is too slow
+        let%expect_test _ =
+          test_memoize_fun (fun hashable f ->
+            let memo_f =
+              unstage
+                (weak_memoize_fun_by_key hashable Fn.id (fun a ->
+                   Heap_block.create_exn (f a)))
+            in
+            stage (fun a -> Heap_block.value (memo_f a)))
+        ;;
+
+        let node_value = node_value
+
+        let%expect_test _ =
+          let show t = print_s [%sexp (node_value t : int Node_value.t)] in
+          if M.bind_lhs_change_should_invalidate_rhs
+          then (
+            show invalid;
+            [%expect {| Invalid |}]);
+          let x = Var.create 13 in
+          let t = watch x in
+          show t;
+          [%expect {| (Unnecessary_maybe_stale ()) |}];
+          let o = observe t in
+          show t;
+          [%expect {| (Unnecessary_maybe_stale ()) |}];
+          stabilize_ [%here];
+          show t;
+          [%expect {| (Necessary_maybe_stale (13)) |}];
+          Observer.disallow_future_use o;
+          stabilize_ [%here];
+          show t;
+          [%expect {| (Unnecessary_maybe_stale (13)) |}]
+        ;;
+
+        let%expect_test _ =
+          (* removal of unused data *)
+          let num_calls = ref 0 in
+          let f =
+            unstage
+              (weak_memoize_fun
+                 (module Int)
+                 (function
+                   | i ->
+                     incr num_calls;
+                     Heap_block.create_exn (ref i)))
+          in
+          let f i = Heap_block.value (f i) in
+          let x0 = f 13 in
+          let x0' = f 13 in
+          let x1 = f 15 in
+          assert (!num_calls = 2);
+          assert (!x0 + !x0' + !x1 = 41);
+          Gc.full_major ();
+          assert (!num_calls = 2);
+          let _x0 = f 13 in
+          assert (!num_calls = 3);
+          assert (phys_equal (f 15) x1);
+          assert (!num_calls = 3);
+          Gc.keep_alive x1
+        ;;
+
+        let%expect_test _ =
+          (* removing a parent is constant time *)
+          (* We can't run this test with debugging, because it's too slow. *)
+          if not debug
+          then
+            for e = 0 to 5 do
+              let num_observers = Float.to_int (10. ** Float.of_int e) in
+              let t = const 13 in
+              let observers =
+                List.init num_observers ~f:(fun _ -> observe (map t ~f:Fn.id))
+              in
+              let cpu_used () =
+                let module R = Unix.Resource_usage in
+                let { R.utime; stime; _ } = R.get `Self in
+                Time_ns.Span.of_sec (utime +. stime)
+              in
+              let before = cpu_used () in
+              (* Don't use [stabilize_], which runs the invariant, which is too slow
                  here. *)
-                stabilize ();
-                List.iter observers ~f:disallow_future_use;
-                stabilize ();
-                let consumed = Time_ns.Span.( - ) (cpu_used ()) before in
-                assert (Time_ns.Span.( < ) consumed (sec 1.))
-              done
-          ;;
+              stabilize ();
+              List.iter observers ~f:disallow_future_use;
+              stabilize ();
+              let consumed = Time_ns.Span.( - ) (cpu_used ()) before in
+              assert (Time_ns.Span.( < ) consumed (sec 1.))
+            done
+        ;;
 
-          let%expect_test _ =
-            (* Deleting a parent from a child in such a way that it is replaced by a
+        let%expect_test _ =
+          (* Deleting a parent from a child in such a way that it is replaced by a
              second parent, and the two parents have different child_indexes for the
              child. *)
-            let c1 = const 12 in
-            let c2 = const 12 in
-            let o1 = observe (map2 c1 c2 ~f:( + )) in
-            (* c2 is child 1, o1 is parent 0 *)
+          let c1 = const 12 in
+          let c2 = const 12 in
+          let o1 = observe (map2 c1 c2 ~f:( + )) in
+          (* c2 is child 1, o1 is parent 0 *)
+          stabilize_ [%here];
+          let o2 = observe (map c2 ~f:Fn.id) in
+          (* c2 is child 0, o2 is parent 1 *)
+          stabilize_ [%here];
+          Observer.disallow_future_use o1;
+          (* o2 is parent 0, so c2 is child 1 for that index *)
+          stabilize_ [%here];
+          Observer.disallow_future_use o2;
+          stabilize_ [%here]
+        ;;
+
+        let%expect_test _ =
+          (* [bind_lhs_change_should_invalidate_rhs = false] *)
+          if not M.bind_lhs_change_should_invalidate_rhs
+          then (
+            let va = Var.create 0 in
+            let vb = Var.create 0 in
+            let r = ref None in
+            let o1 =
+              observe
+                (bind (watch va) ~f:(fun a ->
+                   let t = map (watch vb) ~f:(fun b -> a + b) in
+                   if a = 0 then r := Some t;
+                   t))
+            in
             stabilize_ [%here];
-            let o2 = observe (map c2 ~f:Fn.id) in
-            (* c2 is child 0, o2 is parent 1 *)
+            let o2 = observe (Option.value_exn !r) in
+            Var.set va 1;
             stabilize_ [%here];
-            Observer.disallow_future_use o1;
-            (* o2 is parent 0, so c2 is child 1 for that index *)
+            [%test_result: int] (Observer.value_exn o2) ~expect:0;
+            Var.set vb 1;
             stabilize_ [%here];
-            Observer.disallow_future_use o2;
-            stabilize_ [%here]
-          ;;
-
-          let%expect_test _ =
-            (* [bind_lhs_change_should_invalidate_rhs = false] *)
-            if not M.bind_lhs_change_should_invalidate_rhs
-            then (
-              let va = Var.create 0 in
-              let vb = Var.create 0 in
-              let r = ref None in
-              let o1 =
-                observe
-                  (bind (watch va) ~f:(fun a ->
-                     let t = map (watch vb) ~f:(fun b -> a + b) in
-                     if a = 0 then r := Some t;
-                     t))
-              in
-              stabilize_ [%here];
-              let o2 = observe (Option.value_exn !r) in
-              Var.set va 1;
-              stabilize_ [%here];
-              [%test_result: int] (Observer.value_exn o2) ~expect:0;
-              Var.set vb 1;
-              stabilize_ [%here];
-              [%test_result: int] (Observer.value_exn o2) ~expect:1;
-              Var.set vb 2;
-              stabilize_ [%here];
-              [%test_result: int] (Observer.value_exn o2) ~expect:2;
-              disallow_future_use o1;
-              stabilize_ [%here];
-              [%test_result: int] (Observer.value_exn o2) ~expect:2;
-              Var.set vb 3;
-              stabilize_ [%here];
-              [%test_result: int] (Observer.value_exn o2) ~expect:3;
-              disallow_future_use o2)
-          ;;
+            [%test_result: int] (Observer.value_exn o2) ~expect:1;
+            Var.set vb 2;
+            stabilize_ [%here];
+            [%test_result: int] (Observer.value_exn o2) ~expect:2;
+            disallow_future_use o1;
+            stabilize_ [%here];
+            [%test_result: int] (Observer.value_exn o2) ~expect:2;
+            Var.set vb 3;
+            stabilize_ [%here];
+            [%test_result: int] (Observer.value_exn o2) ~expect:3;
+            disallow_future_use o2)
+        ;;
 
-          module Expert = Expert
-          module E = Expert
+        module Expert = Expert
+        module E = Expert
 
-          module _ = struct
-            (* This tests add_dependency/remove_dependency, invalidity (in particular a node
+        module _ = struct
+          (* This tests add_dependency/remove_dependency, invalidity (in particular a node
              becomes invalid before being replaced by a valid one). *)
-            include Join (struct
+          include Join (struct
               let join : type a. a t t -> a t =
                 fun t ->
                 let prev_rhs = ref None in
@@ -4377,34 +4345,34 @@ struct
               ;;
             end)
 
-            let%expect_test _ =
-              (* plugging an already invalid incremental node make
+          let%expect_test _ =
+            (* plugging an already invalid incremental node make
                the expert node invalid *)
-              let t = E.Node.create ignore in
-              E.Node.add_dependency t (E.Dependency.create invalid);
-              assert (is_invalid (E.Node.watch t))
-            ;;
+            let t = E.Node.create ignore in
+            E.Node.add_dependency t (E.Dependency.create invalid);
+            assert (is_invalid (E.Node.watch t))
+          ;;
 
-            let%expect_test _ =
-              (* [invalidate] does invalidate *)
-              let var = Var.create `Valid in
-              let result = E.Node.create ignore in
-              let result_incr = E.Node.watch result in
-              let lhs_change =
-                map (Var.watch var) ~f:(function
-                  | `Valid -> ()
-                  | `Invalid -> E.Node.invalidate result)
-              in
-              E.Node.add_dependency result (E.Dependency.create lhs_change);
-              let o = observe result_incr in
-              stabilize_ [%here];
-              Observer.disallow_future_use o;
-              assert (is_valid result_incr);
-              Var.set var `Invalid;
-              assert (is_invalid result_incr)
-            ;;
+          let%expect_test _ =
+            (* [invalidate] does invalidate *)
+            let var = Var.create `Valid in
+            let result = E.Node.create ignore in
+            let result_incr = E.Node.watch result in
+            let lhs_change =
+              map (Var.watch var) ~f:(function
+                | `Valid -> ()
+                | `Invalid -> E.Node.invalidate result)
+            in
+            E.Node.add_dependency result (E.Dependency.create lhs_change);
+            let o = observe result_incr in
+            stabilize_ [%here];
+            Observer.disallow_future_use o;
+            assert (is_valid result_incr);
+            Var.set var `Invalid;
+            assert (is_invalid result_incr)
+          ;;
 
-            (* This tests
+          (* This tests
              - whether we can actually write such a thing with the intf of incremental
              - add_dependency/remove_dependency with an actually variable set of
                children, unlike join
@@ -4412,50 +4380,50 @@ struct
                complexities we're trying to get.
              - behavior when observability if turned off and on
           *)
-            let map_filter_mapi
-              : type k v1 v2.
-                on_event:
-                  ([ `Left of k
-                   | `Lhs_change
-                   | `Main
-                   | `On_change of k * v2 option
-                   | `Per_key of k
-                   | `Right of k
-                   | `Unequal of k
-                   ]
-                   -> unit)
-                -> (k, v1, 'comparator) Map.t t
-                -> f:(k -> v1 t -> v2 option t)
-                -> (k, v2, 'comparator) Map.t t
-              =
-              fun ~on_event lhs ~f ->
-              let prev_map = ref None in
-              let prev_nodes = ref None in
-              let acc = ref None in
-              let result =
-                E.Node.create (fun () ->
-                  on_event `Main;
-                  Option.value_exn !acc)
-              in
-              let rec lhs_change =
-                lazy
-                  (map lhs ~f:(fun map ->
-                     on_event `Lhs_change;
-                     let empty_map =
-                       Map.Using_comparator.empty ~comparator:(Map.comparator map)
-                     in
-                     if Option.is_none !acc then acc := Some empty_map;
-                     let symmetric_diff =
-                       Map.symmetric_diff
-                         ~data_equal:phys_equal
-                         (Option.value !prev_map ~default:empty_map)
-                         map
-                     in
-                     let new_nodes =
-                       Sequence.fold
-                         symmetric_diff
-                         ~init:(Option.value !prev_nodes ~default:empty_map)
-                         ~f:(fun nodes (key, changed) ->
+          let map_filter_mapi
+            : type k v1 v2.
+              on_event:
+                ([ `Left of k
+                 | `Lhs_change
+                 | `Main
+                 | `On_change of k * v2 option
+                 | `Per_key of k
+                 | `Right of k
+                 | `Unequal of k
+                 ]
+                 -> unit)
+              -> (k, v1, 'comparator) Map.t t
+              -> f:(k -> v1 t -> v2 option t)
+              -> (k, v2, 'comparator) Map.t t
+            =
+            fun ~on_event lhs ~f ->
+            let prev_map = ref None in
+            let prev_nodes = ref None in
+            let acc = ref None in
+            let result =
+              E.Node.create (fun () ->
+                on_event `Main;
+                Option.value_exn !acc)
+            in
+            let rec lhs_change =
+              lazy
+                (map lhs ~f:(fun map ->
+                   on_event `Lhs_change;
+                   let empty_map =
+                     Map.Using_comparator.empty ~comparator:(Map.comparator map)
+                   in
+                   if Option.is_none !acc then acc := Some empty_map;
+                   let symmetric_diff =
+                     Map.symmetric_diff
+                       ~data_equal:phys_equal
+                       (Option.value !prev_map ~default:empty_map)
+                       map
+                   in
+                   let new_nodes =
+                     Sequence.fold
+                       symmetric_diff
+                       ~init:(Option.value !prev_nodes ~default:empty_map)
+                       ~f:(fun nodes (key, changed) ->
                          match changed with
                          | `Unequal _ ->
                            on_event (`Unequal key);
@@ -4487,395 +4455,392 @@ struct
                                  on_event (`On_change (key, opt));
                                  let old = Option.value_exn !acc in
                                  acc
-                                   := Some
-                                        (match opt with
-                                         | None ->
-                                           if Map.mem old key
-                                           then Map.remove old key
-                                           else old
-                                         | Some v -> Map.set old ~key ~data:v))
+                                 := Some
+                                      (match opt with
+                                       | None ->
+                                         if Map.mem old key
+                                         then Map.remove old key
+                                         else old
+                                       | Some v -> Map.set old ~key ~data:v))
                            in
                            E.Node.add_dependency result user_function_dep;
                            Map.set nodes ~key ~data:(node, user_function_dep))
-                     in
-                     prev_nodes := Some new_nodes;
-                     prev_map := Some map))
-              in
-              E.Node.add_dependency result (E.Dependency.create (force lhs_change));
-              E.Node.watch result
-            ;;
-
-            let%expect_test _ =
-              let module M =
-                On_update_queue (struct
-                  type 'a t =
-                    [ `Left of string
-                    | `Lhs_change
-                    | `Main
-                    | `On_change of string * int option
-                    | `Per_key of string
-                    | `Right of string
-                    | `Unequal of string
-                    ]
-                  [@@deriving compare, sexp_of]
-                end)
-              in
-              let push, check = M.on_update_queue () in
-              let var = Var.create (String.Map.of_alist_exn [ "a", 1; "b", 2; "c", 3 ]) in
-              let increment = Var.create 1 in
-              let assert_incremental_computation_is_correct observer =
-                let from_scratch =
-                  let map = Var.latest_value var in
-                  let j = Var.latest_value increment in
-                  Map.filter_mapi map ~f:(fun ~key:_ ~data:i ->
-                    if (i + j) mod 10 = 0 then None else Some (i + j))
-                in
-                [%test_result: int String.Map.t] (value observer) ~expect:from_scratch
-              in
-              let result =
-                map_filter_mapi ~on_event:push (Var.watch var) ~f:(fun _key value_incr ->
-                  map2 value_incr (Var.watch increment) ~f:(fun i j ->
-                    if (i + j) mod 10 = 0 then None else Some (i + j)))
+                   in
+                   prev_nodes := Some new_nodes;
+                   prev_map := Some map))
+            in
+            E.Node.add_dependency result (E.Dependency.create (force lhs_change));
+            E.Node.watch result
+          ;;
+
+          let%expect_test _ =
+            let module M =
+              On_update_queue (struct
+                type 'a t =
+                  [ `Left of string
+                  | `Lhs_change
+                  | `Main
+                  | `On_change of string * int option
+                  | `Per_key of string
+                  | `Right of string
+                  | `Unequal of string
+                  ]
+                [@@deriving compare, sexp_of]
+              end)
+            in
+            let push, check = M.on_update_queue () in
+            let var = Var.create (String.Map.of_alist_exn [ "a", 1; "b", 2; "c", 3 ]) in
+            let increment = Var.create 1 in
+            let assert_incremental_computation_is_correct observer =
+              let from_scratch =
+                let map = Var.latest_value var in
+                let j = Var.latest_value increment in
+                Map.filter_mapi map ~f:(fun ~key:_ ~data:i ->
+                  if (i + j) mod 10 = 0 then None else Some (i + j))
               in
-              let o = observe result in
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Right "a"
-                ; `Right "b"
-                ; `Right "c"
-                ; `Per_key "c"
-                ; `Per_key "b"
-                ; `Per_key "a"
-                ; `On_change ("a", Some 2)
-                ; `On_change ("b", Some 3)
-                ; `On_change ("c", Some 4)
-                ; `Main
-                ];
-              let update f = Var.set var (f (Var.value var)) in
-              update (fun map -> Map.set map ~key:"b2" ~data:12);
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Right "b2"
-                ; `Per_key "b2"
-                ; `On_change ("b2", Some 13)
-                ; `Main
-                ];
-              update (fun map -> Map.set map ~key:"b2" ~data:18);
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Unequal "b2"
-                ; `Per_key "b2"
-                ; `On_change ("b2", Some 19)
-                ; `Main
-                ];
-              update (fun map -> Map.set map ~key:"b2" ~data:19);
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Unequal "b2"
-                ; `Per_key "b2"
-                ; `On_change ("b2", None)
-                ; `Main
-                ];
-              update (fun map -> Map.set map ~key:"b2" ~data:18);
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Unequal "b2"
-                ; `Per_key "b2"
-                ; `On_change ("b2", Some 19)
-                ; `Main
-                ];
-              update (fun map -> Map.remove map "b2");
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check [ `Lhs_change; `Left "b2"; `Main ];
-              Var.set increment 9;
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `On_change ("a", None)
-                ; `On_change ("c", Some 12)
-                ; `On_change ("b", Some 11)
-                ; `Main
-                ];
-              update (fun map -> Map.remove map "a");
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check [ `Lhs_change; `Left "a"; `Main ];
-              update (fun map ->
-                Map.set (Map.remove (Map.remove map "b") "c") ~key:"a" ~data:2);
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Right "a"
-                ; `Left "b"
-                ; `Left "c"
-                ; `Per_key "a"
-                ; `On_change ("a", Some 11)
-                ; `Main
-                ];
-              disallow_future_use o;
-              stabilize_ [%here];
-              check [];
-              update (fun map -> Map.set map ~key:"a" ~data:3);
-              stabilize_ [%here];
-              check [];
-              let o = observe result in
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Lhs_change
-                ; `Unequal "a"
-                ; `Per_key "a"
-                ; `On_change ("a", Some 12)
-                ; `Main
-                ]
-            ;;
+              [%test_result: int String.Map.t] (value observer) ~expect:from_scratch
+            in
+            let result =
+              map_filter_mapi ~on_event:push (Var.watch var) ~f:(fun _key value_incr ->
+                map2 value_incr (Var.watch increment) ~f:(fun i j ->
+                  if (i + j) mod 10 = 0 then None else Some (i + j)))
+            in
+            let o = observe result in
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Right "a"
+              ; `Right "b"
+              ; `Right "c"
+              ; `Per_key "c"
+              ; `Per_key "b"
+              ; `Per_key "a"
+              ; `On_change ("a", Some 2)
+              ; `On_change ("b", Some 3)
+              ; `On_change ("c", Some 4)
+              ; `Main
+              ];
+            let update f = Var.set var (f (Var.value var)) in
+            update (fun map -> Map.set map ~key:"b2" ~data:12);
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Right "b2"
+              ; `Per_key "b2"
+              ; `On_change ("b2", Some 13)
+              ; `Main
+              ];
+            update (fun map -> Map.set map ~key:"b2" ~data:18);
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Unequal "b2"
+              ; `Per_key "b2"
+              ; `On_change ("b2", Some 19)
+              ; `Main
+              ];
+            update (fun map -> Map.set map ~key:"b2" ~data:19);
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Unequal "b2"
+              ; `Per_key "b2"
+              ; `On_change ("b2", None)
+              ; `Main
+              ];
+            update (fun map -> Map.set map ~key:"b2" ~data:18);
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Unequal "b2"
+              ; `Per_key "b2"
+              ; `On_change ("b2", Some 19)
+              ; `Main
+              ];
+            update (fun map -> Map.remove map "b2");
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check [ `Lhs_change; `Left "b2"; `Main ];
+            Var.set increment 9;
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `On_change ("a", None)
+              ; `On_change ("c", Some 12)
+              ; `On_change ("b", Some 11)
+              ; `Main
+              ];
+            update (fun map -> Map.remove map "a");
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check [ `Lhs_change; `Left "a"; `Main ];
+            update (fun map ->
+              Map.set (Map.remove (Map.remove map "b") "c") ~key:"a" ~data:2);
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Right "a"
+              ; `Left "b"
+              ; `Left "c"
+              ; `Per_key "a"
+              ; `On_change ("a", Some 11)
+              ; `Main
+              ];
+            disallow_future_use o;
+            stabilize_ [%here];
+            check [];
+            update (fun map -> Map.set map ~key:"a" ~data:3);
+            stabilize_ [%here];
+            check [];
+            let o = observe result in
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Lhs_change
+              ; `Unequal "a"
+              ; `Per_key "a"
+              ; `On_change ("a", Some 12)
+              ; `Main
+              ]
+          ;;
 
-            (* This one checks
+          (* This one checks
              - expressivity of the interface, again
              - on_observability_change callback
           *)
-            let staged_eq
-              : type a.
-                on_event:
-                  ([ `Scheduling
-                   | `Is_eq of a
-                   | `Add_reverse_dep of a
-                   | `Remove_reverse_dep of a
-                   ]
-                   -> unit)
-                -> a Hashtbl.Hashable.t
-                -> a t
-                -> (a -> bool t) Staged.t
-              =
-              fun ~on_event hashable incr ->
-              let last = ref None in
-              let reverse_dependencies = Hashtbl.Using_hashable.create ~hashable () in
-              let scheduling_node =
-                I.map incr ~f:(fun v ->
-                  on_event `Scheduling;
-                  Option.iter !last ~f:(fun old_v ->
-                    Option.iter
-                      (Hashtbl.find reverse_dependencies old_v)
-                      ~f:E.Node.make_stale);
-                  Option.iter (Hashtbl.find reverse_dependencies v) ~f:E.Node.make_stale;
-                  last := Some v)
-              in
-              Staged.stage (fun a ->
-                let rec result =
-                  lazy
-                    (E.Node.create
-                       (fun () ->
-                         let v = Option.value_exn !last in
-                         on_event (`Is_eq a);
-                         hashable.compare a v = 0)
-                       ~on_observability_change:(fun ~is_now_observable ->
-                         if is_now_observable
-                         then (
-                           on_event (`Add_reverse_dep a);
-                           Hashtbl.add_exn
-                             reverse_dependencies
-                             ~key:a
-                             ~data:(force result))
-                         else (
-                           on_event (`Remove_reverse_dep a);
-                           Hashtbl.remove reverse_dependencies a)))
-                in
-                let dep = E.Dependency.create scheduling_node in
-                E.Node.add_dependency (force result) dep;
-                E.Node.watch (force result))
-            ;;
-
-            let%expect_test _ =
-              let module M =
-                On_update_queue (struct
-                  type 'a t =
-                    [ `Scheduling
-                    | `Is_eq of int
-                    | `Add_reverse_dep of int
-                    | `Remove_reverse_dep of int
-                    ]
-                  [@@deriving compare, sexp_of]
-                end)
-              in
-              let push, check = M.on_update_queue () in
-              let var = Var.create 2 in
-              let switch = Var.create true in
-              let input = if_ (Var.watch switch) ~then_:(Var.watch var) ~else_:invalid in
-              let is_focused =
-                Staged.unstage (staged_eq Int.hashable ~on_event:push input)
-              in
-              let all = all (List.init 5 ~f:is_focused) in
-              let assert_incremental_computation_is_correct observer =
-                let from_scratch = List.init 5 ~f:(( = ) (Var.latest_value var)) in
-                [%test_result: bool list] (value observer) ~expect:from_scratch
+          let staged_eq
+            : type a.
+              on_event:
+                ([ `Scheduling
+                 | `Is_eq of a
+                 | `Add_reverse_dep of a
+                 | `Remove_reverse_dep of a
+                 ]
+                 -> unit)
+              -> a Hashtbl.Hashable.t
+              -> a t
+              -> (a -> bool t) Staged.t
+            =
+            fun ~on_event hashable incr ->
+            let last = ref None in
+            let reverse_dependencies = Hashtbl.Using_hashable.create ~hashable () in
+            let scheduling_node =
+              I.map incr ~f:(fun v ->
+                on_event `Scheduling;
+                Option.iter !last ~f:(fun old_v ->
+                  Option.iter
+                    (Hashtbl.find reverse_dependencies old_v)
+                    ~f:E.Node.make_stale);
+                Option.iter (Hashtbl.find reverse_dependencies v) ~f:E.Node.make_stale;
+                last := Some v)
+            in
+            Staged.stage (fun a ->
+              let rec result =
+                lazy
+                  (E.Node.create
+                     (fun () ->
+                       let v = Option.value_exn !last in
+                       on_event (`Is_eq a);
+                       hashable.compare a v = 0)
+                     ~on_observability_change:(fun ~is_now_observable ->
+                       if is_now_observable
+                       then (
+                         on_event (`Add_reverse_dep a);
+                         Hashtbl.add_exn reverse_dependencies ~key:a ~data:(force result))
+                       else (
+                         on_event (`Remove_reverse_dep a);
+                         Hashtbl.remove reverse_dependencies a)))
               in
-              let o = observe all in
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Add_reverse_dep 4
-                ; `Add_reverse_dep 3
-                ; `Add_reverse_dep 2
-                ; `Add_reverse_dep 1
-                ; `Add_reverse_dep 0
-                ; `Scheduling
-                ; `Is_eq 0
-                ; `Is_eq 1
-                ; `Is_eq 2
-                ; `Is_eq 3
-                ; `Is_eq 4
-                ];
-              Var.set var 0;
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check [ `Scheduling; `Is_eq 0; `Is_eq 2 ];
-              disallow_future_use o;
-              stabilize_ [%here];
-              check
-                [ `Remove_reverse_dep 4
-                ; `Remove_reverse_dep 3
-                ; `Remove_reverse_dep 2
-                ; `Remove_reverse_dep 1
-                ; `Remove_reverse_dep 0
-                ];
-              Var.set var 1;
-              stabilize_ [%here];
-              check [];
-              let o = observe all in
-              stabilize_ [%here];
-              assert_incremental_computation_is_correct o;
-              check
-                [ `Add_reverse_dep 4
-                ; `Add_reverse_dep 3
-                ; `Add_reverse_dep 2
-                ; `Add_reverse_dep 1
-                ; `Add_reverse_dep 0
-                ; `Scheduling
-                ; `Is_eq 1
-                ; `Is_eq 0
-                ];
-              Var.set switch false;
-              stabilize_ [%here];
-              assert (skip_invalidity_check || not (is_valid all));
-              disallow_future_use o
-            ;;
+              let dep = E.Dependency.create scheduling_node in
+              E.Node.add_dependency (force result) dep;
+              E.Node.watch (force result))
+          ;;
+
+          let%expect_test _ =
+            let module M =
+              On_update_queue (struct
+                type 'a t =
+                  [ `Scheduling
+                  | `Is_eq of int
+                  | `Add_reverse_dep of int
+                  | `Remove_reverse_dep of int
+                  ]
+                [@@deriving compare, sexp_of]
+              end)
+            in
+            let push, check = M.on_update_queue () in
+            let var = Var.create 2 in
+            let switch = Var.create true in
+            let input = if_ (Var.watch switch) ~then_:(Var.watch var) ~else_:invalid in
+            let is_focused =
+              Staged.unstage (staged_eq Int.hashable ~on_event:push input)
+            in
+            let all = all (List.init 5 ~f:is_focused) in
+            let assert_incremental_computation_is_correct observer =
+              let from_scratch = List.init 5 ~f:(( = ) (Var.latest_value var)) in
+              [%test_result: bool list] (value observer) ~expect:from_scratch
+            in
+            let o = observe all in
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Add_reverse_dep 4
+              ; `Add_reverse_dep 3
+              ; `Add_reverse_dep 2
+              ; `Add_reverse_dep 1
+              ; `Add_reverse_dep 0
+              ; `Scheduling
+              ; `Is_eq 0
+              ; `Is_eq 1
+              ; `Is_eq 2
+              ; `Is_eq 3
+              ; `Is_eq 4
+              ];
+            Var.set var 0;
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check [ `Scheduling; `Is_eq 0; `Is_eq 2 ];
+            disallow_future_use o;
+            stabilize_ [%here];
+            check
+              [ `Remove_reverse_dep 4
+              ; `Remove_reverse_dep 3
+              ; `Remove_reverse_dep 2
+              ; `Remove_reverse_dep 1
+              ; `Remove_reverse_dep 0
+              ];
+            Var.set var 1;
+            stabilize_ [%here];
+            check [];
+            let o = observe all in
+            stabilize_ [%here];
+            assert_incremental_computation_is_correct o;
+            check
+              [ `Add_reverse_dep 4
+              ; `Add_reverse_dep 3
+              ; `Add_reverse_dep 2
+              ; `Add_reverse_dep 1
+              ; `Add_reverse_dep 0
+              ; `Scheduling
+              ; `Is_eq 1
+              ; `Is_eq 0
+              ];
+            Var.set switch false;
+            stabilize_ [%here];
+            assert (skip_invalidity_check || not (is_valid all));
+            disallow_future_use o
+          ;;
 
-            (* Ensure we can make changes to an unnecessary expert node from a necessary
+          (* Ensure we can make changes to an unnecessary expert node from a necessary
              child. *)
-            let%expect_test _ =
-              let weird_unzip
-                : type a b c. a list t -> (a t -> (b * c) t) -> b list t * c list t
-                =
-                (* This function doesn't do anything really interesting, the point is more
+          let%expect_test _ =
+            let weird_unzip
+              : type a b c. a list t -> (a t -> (b * c) t) -> b list t * c list t
+              =
+              (* This function doesn't do anything really interesting, the point is more
                  that the caller can make it call add_dependency or remove_dependency as
                  desired. And we can check the correctness of the results. *)
-                fun t f ->
-                let f_result = ref None in
-                let fs1 = ref None in
-                let fs2 = ref None in
-                let parent1 = E.Node.create (fun () -> Option.value_exn !fs1 ()) in
-                let parent2 = E.Node.create (fun () -> Option.value_exn !fs2 ()) in
-                let lhs_change =
-                  map t ~f:(fun l ->
-                    (match !f_result with
-                     | Some (len, (deps1, deps2)) when len <> List.length l ->
-                       (* remove_dependency does something different for the last
+              fun t f ->
+              let f_result = ref None in
+              let fs1 = ref None in
+              let fs2 = ref None in
+              let parent1 = E.Node.create (fun () -> Option.value_exn !fs1 ()) in
+              let parent2 = E.Node.create (fun () -> Option.value_exn !fs2 ()) in
+              let lhs_change =
+                map t ~f:(fun l ->
+                  (match !f_result with
+                   | Some (len, (deps1, deps2)) when len <> List.length l ->
+                     (* remove_dependency does something different for the last
                         child. So iterate in different orders so we cover both cases. *)
-                       List.iter deps1 ~f:(E.Node.remove_dependency parent1);
-                       List.iter (List.rev deps2) ~f:(E.Node.remove_dependency parent2);
-                       f_result := None
-                     | _ -> ());
-                    match !f_result with
-                    | Some _ -> ()
-                    | None ->
-                      let deps, new_refs =
-                        List.unzip
-                          (List.init (List.length l) ~f:(fun i ->
-                             let incr = f (map t ~f:(fun l -> List.nth_exn l i)) in
-                             let r1 = ref None in
-                             let dep1 =
-                               E.Dependency.create incr ~on_change:(fun x ->
-                                 r1 := Some (fst x))
-                             in
-                             let r2 = ref None in
-                             let dep2 =
-                               E.Dependency.create incr ~on_change:(fun x ->
-                                 r2 := Some (snd x))
-                             in
-                             E.Node.add_dependency parent1 dep1;
-                             E.Node.add_dependency parent2 dep2;
-                             (dep1, dep2), (r1, r2)))
-                      in
-                      let compute_result l f () =
-                        List.map l ~f:(fun r -> Option.value_exn !(f r))
-                      in
-                      fs1 := Some (compute_result new_refs fst);
-                      fs2 := Some (compute_result new_refs snd);
-                      f_result := Some (List.length l, List.unzip deps))
-                in
-                E.Node.add_dependency parent1 (E.Dependency.create lhs_change);
-                E.Node.add_dependency parent2 (E.Dependency.create lhs_change);
-                E.Node.watch parent1, E.Node.watch parent2
+                     List.iter deps1 ~f:(E.Node.remove_dependency parent1);
+                     List.iter (List.rev deps2) ~f:(E.Node.remove_dependency parent2);
+                     f_result := None
+                   | _ -> ());
+                  match !f_result with
+                  | Some _ -> ()
+                  | None ->
+                    let deps, new_refs =
+                      List.unzip
+                        (List.init (List.length l) ~f:(fun i ->
+                           let incr = f (map t ~f:(fun l -> List.nth_exn l i)) in
+                           let r1 = ref None in
+                           let dep1 =
+                             E.Dependency.create incr ~on_change:(fun x ->
+                               r1 := Some (fst x))
+                           in
+                           let r2 = ref None in
+                           let dep2 =
+                             E.Dependency.create incr ~on_change:(fun x ->
+                               r2 := Some (snd x))
+                           in
+                           E.Node.add_dependency parent1 dep1;
+                           E.Node.add_dependency parent2 dep2;
+                           (dep1, dep2), (r1, r2)))
+                    in
+                    let compute_result l f () =
+                      List.map l ~f:(fun r -> Option.value_exn !(f r))
+                    in
+                    fs1 := Some (compute_result new_refs fst);
+                    fs2 := Some (compute_result new_refs snd);
+                    f_result := Some (List.length l, List.unzip deps))
               in
-              Ref.set_temporarily sexp_style To_string_hum ~f:(fun () ->
-                let v1 = Var.create [ 2 ] in
-                let n1, n2 =
-                  weird_unzip (Var.watch v1) (fun t -> map t ~f:(fun x -> x, -x))
-                in
-                (* We add/remove dependencies with only n2 necessary, both necessary
+              E.Node.add_dependency parent1 (E.Dependency.create lhs_change);
+              E.Node.add_dependency parent2 (E.Dependency.create lhs_change);
+              E.Node.watch parent1, E.Node.watch parent2
+            in
+            Ref.set_temporarily sexp_style To_string_hum ~f:(fun () ->
+              let v1 = Var.create [ 2 ] in
+              let n1, n2 =
+                weird_unzip (Var.watch v1) (fun t -> map t ~f:(fun x -> x, -x))
+              in
+              (* We add/remove dependencies with only n2 necessary, both necessary
                  and only n1 necessary.  *)
-                let o2 = observe n2 in
-                stabilize_ ();
-                print_s [%sexp (value o2 : int list)];
-                [%expect "(-2)"];
-                Var.set v1 [ 3 ];
-                stabilize_ ();
-                print_s [%sexp (value o2 : int list)];
-                [%expect "(-3)"];
-                Var.set v1 [ 3; 4; 5 ];
-                stabilize_ ();
-                print_s [%sexp (value o2 : int list)];
-                [%expect "(-3 -4 -5)"];
-                Var.set v1 [];
-                stabilize_ ();
-                print_s [%sexp (value o2 : int list)];
-                [%expect "()"];
-                Var.set v1 [ 3; 4; 5 ];
-                stabilize_ ();
-                let o1 = observe n1 in
-                stabilize_ ();
-                print_s [%sexp (value o1 : int list), (value o2 : int list)];
-                [%expect "((3 4 5) (-3 -4 -5))"];
-                Var.set v1 [ 6 ];
-                stabilize_ ();
-                print_s [%sexp (value o1 : int list), (value o2 : int list)];
-                [%expect "((6) (-6))"];
-                disallow_future_use o2;
-                Var.set v1 [ 7; 8; 9 ];
-                stabilize_ ();
-                print_s [%sexp (value o1 : int list)];
-                [%expect "(7 8 9)"];
-                Var.set v1 [];
-                stabilize_ ();
-                disallow_future_use o1)
-            ;;
-          end
-        end :
-          (* This signature constraint is here to remind us to add a unit test
+              let o2 = observe n2 in
+              stabilize_ ();
+              print_s [%sexp (value o2 : int list)];
+              [%expect "(-2)"];
+              Var.set v1 [ 3 ];
+              stabilize_ ();
+              print_s [%sexp (value o2 : int list)];
+              [%expect "(-3)"];
+              Var.set v1 [ 3; 4; 5 ];
+              stabilize_ ();
+              print_s [%sexp (value o2 : int list)];
+              [%expect "(-3 -4 -5)"];
+              Var.set v1 [];
+              stabilize_ ();
+              print_s [%sexp (value o2 : int list)];
+              [%expect "()"];
+              Var.set v1 [ 3; 4; 5 ];
+              stabilize_ ();
+              let o1 = observe n1 in
+              stabilize_ ();
+              print_s [%sexp (value o1 : int list), (value o2 : int list)];
+              [%expect "((3 4 5) (-3 -4 -5))"];
+              Var.set v1 [ 6 ];
+              stabilize_ ();
+              print_s [%sexp (value o1 : int list), (value o2 : int list)];
+              [%expect "((6) (-6))"];
+              disallow_future_use o2;
+              Var.set v1 [ 7; 8; 9 ];
+              stabilize_ ();
+              print_s [%sexp (value o1 : int list)];
+              [%expect "(7 8 9)"];
+              Var.set v1 [];
+              stabilize_ ();
+              disallow_future_use o1)
+          ;;
+        end
+      end :
+        (* This signature constraint is here to remind us to add a unit test
            whenever Incremental's interface changes. *)
-          Incremental.S)
+        Incremental.S)
 
       (* Situations that cause failures. *)
 
diff --git a/test/test_non_debug.ml b/test/test_non_debug.ml
index 943c8f9..f44d70e 100644
--- a/test/test_non_debug.ml
+++ b/test/test_non_debug.ml
@@ -33,9 +33,9 @@ let%expect_test "stabilization that propagates values through an existing graph
      stabilization, either on purpose or by accident. *)
   stabilize ();
   Var.set v' 4;
-  Expect_test_helpers_core.require_no_allocation [%here] stabilize;
+  Expect_test_helpers_core.require_no_allocation stabilize;
   Var.set v' 5;
   Var.set w' 5;
-  Expect_test_helpers_core.require_no_allocation [%here] stabilize;
+  Expect_test_helpers_core.require_no_allocation stabilize;
   Observer.disallow_future_use o
 ;;
diff --git a/test/test_skeleton.ml b/test/test_skeleton.ml
new file mode 100644
index 0000000..e639c9f
--- /dev/null
+++ b/test/test_skeleton.ml
@@ -0,0 +1,317 @@
+open! Core
+
+let%expect_test "render dot file" =
+  let module Incr = Incremental.Make () in
+  let open Incr.Let_syntax in
+  let n1 = Incr.const 1 in
+  let n2 = Incr.const 2 in
+  let res =
+    let%bind n1 = n1 in
+    if n1 % 2 = 0
+    then (
+      let%map n2 = n2 in
+      n1 * n2)
+    else n2
+  in
+  let observer = Incr.observe res in
+  Incr.stabilize ();
+  let result = Incr.Observer.value_exn observer in
+  print_s [%message (result : int)];
+  [%expect {| (result 2) |}];
+  let skeleton = Incremental_skeleton.snapshot ~normalize:true Incr.State.t in
+  print_s [%message (skeleton : Incremental_skeleton.t)];
+  [%expect
+    {|
+    (skeleton
+     ((nodes
+       (((id 4) (kind Bind_main) (children (3 2)) (recomputed_at 0)
+         (changed_at 0) (height 2))
+        ((id 3) (kind Bind_lhs_change) (children (1)) (recomputed_at 0)
+         (cutoff Never) (changed_at 0) (height 1))
+        ((id 1) (kind Const) (recomputed_at 0) (changed_at 0) (height 0))
+        ((id 2) (kind Const) (recomputed_at 0) (changed_at 0) (height 0))))
+      (seen (1 2 3 4)) (num_stabilizes 1)))
+    |}];
+  let dot = Incremental_skeleton.to_dot ~render_target:Dot skeleton in
+  let grapheasy_dot = Incremental_skeleton.to_dot ~render_target:Graph_easy skeleton in
+  Expect_test_patdiff.print_patdiff dot grapheasy_dot;
+  [%expect
+    {|
+    -1,11 +1,11
+      digraph G {
+        rankdir = TB
+        bgcolor = transparent
+    -|    n4 [shape=Mrecord label="{{n4|Bind_main|height=2}}"  "fontname"="Sans Serif"]
+    +|    n4 [shape=box label="{{n4|Bind_main|height=2}}" ]
+    -|    n3 [shape=Mrecord label="{{n3|Bind_lhs_change|height=1}}"  "fontname"="Sans Serif"]
+    +|    n3 [shape=box label="{{n3|Bind_lhs_change|height=1}}" ]
+    -|    n1 [shape=Mrecord label="{{n1|Const|height=0}}"  "fontname"="Sans Serif"]
+    +|    n1 [shape=box label="{{n1|Const|height=0}}" ]
+    -|    n2 [shape=Mrecord label="{{n2|Const|height=0}}"  "fontname"="Sans Serif"]
+    +|    n2 [shape=box label="{{n2|Const|height=0}}" ]
+        n3 -> n4
+        n2 -> n4
+        n1 -> n3
+      }
+    |}]
+;;
+
+let%expect_test "no binds" =
+  let module Incr = Incremental.Make () in
+  let node = Incr.return "hello" in
+  let node = Incr.map node ~f:(fun x -> x ^ "!") in
+  let result = Incr.observe node in
+  Incr.stabilize ();
+  let result = Incr.Observer.value_exn result in
+  print_s [%message (result : string)];
+  [%expect {| (result hello!) |}];
+  let skeleton = Incremental_skeleton.snapshot ~normalize:true Incr.State.t in
+  print_s [%message (skeleton : Incremental_skeleton.t)];
+  [%expect
+    {|
+    (skeleton
+     ((nodes
+       (((id 2) (kind Map) (children (1)) (recomputed_at 0) (changed_at 0)
+         (height 1))
+        ((id 1) (kind Const) (recomputed_at 0) (changed_at 0) (height 0))))
+      (seen (1 2)) (num_stabilizes 1)))
+    |}];
+  let dot = Incremental_skeleton.to_dot ~render_target:Graph_easy skeleton in
+  print_endline dot;
+  [%expect
+    {|
+    digraph G {
+      rankdir = TB
+      bgcolor = transparent
+        n2 [shape=box label="{{n2|Map|height=1}}" ]
+        n1 [shape=box label="{{n1|Const|height=0}}" ]
+      n1 -> n2
+    }
+    |}];
+  Expect_test_graphviz.print_dot_blocking dot;
+  [%expect
+    {|
+    
+     {{n1|Const|height=0}} 
+    
+      
+      
+      
+    
+      {{n2|Map|height=1}}  
+    
+    |}]
+;;
+
+let%expect_test "with binds" =
+  let module Incr = Incremental.Make () in
+  let open Incr.Let_syntax in
+  let mk_incr i =
+    let v = Incr.Var.create i in
+    Incr.Var.watch v, v
+  in
+  let a, ai = mk_incr 0 in
+  let b, _bi = mk_incr 3 in
+  let c, _ci = mk_incr 4 in
+  let node =
+    let is_even =
+      let%map a = a in
+      a % 2 = 0
+    in
+    let%bind is_even = is_even in
+    if is_even
+    then return 0
+    else (
+      let%map b = b
+      and c = c in
+      b * c)
+  in
+  let observer = Incr.observe node in
+  Incr.stabilize ();
+  let result = Incr.Observer.value_exn observer in
+  print_s [%message (result : int)];
+  [%expect {| (result 0) |}];
+  let skeleton = Incremental_skeleton.snapshot ~normalize:true Incr.State.t in
+  print_s [%message (skeleton : Incremental_skeleton.t)];
+  [%expect
+    {|
+    (skeleton
+     ((nodes
+       (((id 6) (kind Bind_main) (children (5 7)) (recomputed_at 0)
+         (changed_at 0) (height 4))
+        ((id 5) (kind Bind_lhs_change) (children (4)) (bind_children (7))
+         (recomputed_at 0) (cutoff Never) (changed_at 0) (height 2))
+        ((id 4) (kind Map) (children (1)) (recomputed_at 0) (changed_at 0)
+         (height 1))
+        ((id 1) (kind Var) (recomputed_at 0) (changed_at 0) (height 0))
+        ((id 7) (kind Const) (recomputed_at 0) (changed_at 0) (height 3))))
+      (seen (1 4 5 6 7)) (num_stabilizes 1)))
+    |}];
+  Incr.Var.set ai 3;
+  Incr.stabilize ();
+  let result = Incr.Observer.value_exn observer in
+  print_s [%message (result : int)];
+  [%expect {| (result 12) |}];
+  let new_skeleton = Incremental_skeleton.snapshot ~normalize:true Incr.State.t in
+  Expect_test_sexp_diff.print_sexp_diff
+    ([%sexp_of: Incremental_skeleton.t] skeleton)
+    ([%sexp_of: Incremental_skeleton.t] new_skeleton);
+  [%expect
+    {|
+     ((nodes                      ((nodes
+       (((id 6)                     (((id 6)
+         (kind Bind_main)             (kind Bind_main)
+         (children                    (children
+          (5                           (5
+    -      7                     +      9
+          ))                           ))
+         (recomputed_at               (recomputed_at
+    -     0                      +     1
+         )                            )
+         (changed_at                  (changed_at
+    -     0                      +     1
+         )                            )
+         (height                      (height
+    -     4                      +     5
+         ))                           ))
+        ((id 5)                      ((id 5)
+         (kind Bind_lhs_change)       (kind Bind_lhs_change)
+         (children (4))               (children (4))
+         (bind_children               (bind_children
+    -     (7)                    +     (9 8)
+         )                            )
+         (recomputed_at               (recomputed_at
+    -     0                      +     1
+         )                            )
+         (cutoff Never)               (cutoff Never)
+         (changed_at                  (changed_at
+    -     0                      +     1
+         )                            )
+         (height 2))                  (height 2))
+        ((id 4)                      ((id 4)
+         (kind Map)                   (kind Map)
+         (children (1))               (children (1))
+         (recomputed_at               (recomputed_at
+    -     0                      +     1
+         )                            )
+         (changed_at                  (changed_at
+    -     0                      +     1
+         )                            )
+         (height 1))                  (height 1))
+        ((id 1)                      ((id 1)
+         (kind Var)                   (kind Var)
+         (recomputed_at               (recomputed_at
+    -     0                      +     1
+         )                            )
+         (changed_at                  (changed_at
+    -     0                      +     1
+         )                            )
+         (height 0))                  (height 0))
+                                 +   ((id 9) (kind Map) (children (8)) (recomputed_at 1) (changed_at 1)
+                                 +    (height 4))
+        ((id                         ((id
+    -     7                      +     8
+         )                            )
+         (kind                        (kind
+    -     Const                  +     Map2
+         )                            )
+                                 +    (children (2 3))
+         (recomputed_at               (recomputed_at
+    -     0                      +     1
+         )                            )
+         (changed_at                  (changed_at
+    -     0                      +     1
+         )                            )
+         (height 3))                  (height 3))
+                                 +   ((id 2) (kind Var) (recomputed_at 1) (changed_at 1) (height 0))
+                                 +   ((id 3) (kind Var) (recomputed_at 1) (changed_at 1) (height 0))
+       ))                           ))
+      (seen                        (seen
+       (1                           (1
+                                 +   2
+                                 +   3
+        4                            4
+        5                            5
+        6                            6
+                                 +   8
+    -   7                        +   9
+       ))                           ))
+      (num_stabilizes              (num_stabilizes
+    -  1                         +  2
+      ))                           ))
+    |}];
+  let dot = Incremental_skeleton.to_dot ~render_target:Graph_easy skeleton in
+  print_endline dot;
+  [%expect
+    {|
+    digraph G {
+      rankdir = TB
+      bgcolor = transparent
+        n6 [shape=box label="{{n6|Bind_main|height=4}}" ]
+        n5 [shape=box label="{{n5|Bind_lhs_change|height=2}}" ]
+        n4 [shape=box label="{{n4|Map|height=1}}" ]
+        n1 [shape=box label="{{n1|Var|height=0}}" ]
+        n7 [shape=box label="{{n7|Const|height=3}}" ]
+      n5 -> n6
+      n7 -> n6
+      n4 -> n5
+      n1 -> n4
+      n5 -> n7 [style=dashed]
+    }
+    |}];
+  Expect_test_graphviz.print_dot_blocking dot;
+  [%expect
+    {|
+    
+           {{n1|Var|height=0}}       
+    
+      
+      
+      
+    
+           {{n4|Map|height=1}}       
+    
+      
+      
+      
+    
+     {{n5|Bind_lhs_change|height=2}}  
+      
+                                        
+                                        
+                                        
+      
+          {{n7|Const|height=3}}        
+      
+                                        
+                                        
+                                        
+      
+        {{n6|Bind_main|height=4}}     
+    
+    |}]
+;;
+
+let%expect_test "unobserved incr graph" =
+  let module Incr = Incremental.Make () in
+  let node = Incr.return "hello" in
+  let node = Incr.map node ~f:(fun x -> x ^ "!") in
+  let result = Incr.observe node in
+  Incr.stabilize ();
+  let skeleton = Incremental_skeleton.snapshot ~normalize:true Incr.State.t in
+  print_s [%message (skeleton : Incremental_skeleton.t)];
+  [%expect
+    {|
+    (skeleton
+     ((nodes
+       (((id 2) (kind Map) (children (1)) (recomputed_at 0) (changed_at 0)
+         (height 1))
+        ((id 1) (kind Const) (recomputed_at 0) (changed_at 0) (height 0))))
+      (seen (1 2)) (num_stabilizes 1)))
+    |}];
+  Incr.Observer.disallow_future_use result;
+  Incr.stabilize ();
+  let skeleton = Incremental_skeleton.snapshot ~normalize:true Incr.State.t in
+  print_s [%message (skeleton : Incremental_skeleton.t)];
+  [%expect {| (skeleton ((nodes ()) (seen ()) (num_stabilizes 2))) |}]
+;;
diff --git a/test/test_skeleton.mli b/test/test_skeleton.mli
new file mode 100644
index 0000000..e69de29
