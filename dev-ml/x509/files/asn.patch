Index: x509-0.16.5/lib/algorithm.ml
===================================================================
--- x509-0.16.5.orig/lib/algorithm.ml
+++ x509-0.16.5/lib/algorithm.ml
@@ -65,19 +65,19 @@ type t =
   | HMAC_SHA512
 
   (* symmetric block ciphers *)
-  | AES128_CBC of Cstruct.t
-  | AES192_CBC of Cstruct.t
-  | AES256_CBC of Cstruct.t
+  | AES128_CBC of string
+  | AES192_CBC of string
+  | AES256_CBC of string
 
   (* PBE encryption algorithms *)
-  | SHA_RC4_128 of Cstruct.t * int
-  | SHA_RC4_40 of Cstruct.t * int
-  | SHA_3DES_CBC of Cstruct.t * int
-  | SHA_2DES_CBC of Cstruct.t * int
-  | SHA_RC2_128_CBC of Cstruct.t * int
-  | SHA_RC2_40_CBC of Cstruct.t * int
+  | SHA_RC4_128 of string * int
+  | SHA_RC4_40 of string * int
+  | SHA_3DES_CBC of string * int
+  | SHA_2DES_CBC of string * int
+  | SHA_RC2_128_CBC of string * int
+  | SHA_RC2_40_CBC of string * int
 
-  | PBKDF2 of Cstruct.t * int * int option * t
+  | PBKDF2 of string * int * int option * t
   | PBES2 of t * t
 
 let to_string = function
@@ -406,17 +406,15 @@ let identifier =
            (choice4 null oid pbkdf2_or_pbe_or_pbes2_params octet_string)))
 
 let ecdsa_sig =
-  let f (r, s) =
+  let f (r', s') =
+    let r = Mirage_crypto_pk.Z_extra.of_cstruct_be (Cstruct.of_string r') in
+    let s = Mirage_crypto_pk.Z_extra.of_cstruct_be (Cstruct.of_string s') in
     if Z.sign r < 0 then
       Asn.S.parse_error "ECDSA signature: r < 0"
     else if Z.sign s < 0 then
       Asn.S.parse_error "ECDSA signature: s < 0"
-    else
-      Mirage_crypto_pk.Z_extra.to_cstruct_be r,
-      Mirage_crypto_pk.Z_extra.to_cstruct_be s
-  and g (r, s) =
-    Mirage_crypto_pk.Z_extra.of_cstruct_be r,
-    Mirage_crypto_pk.Z_extra.of_cstruct_be s
+    else (r',s')
+  and g (r, s) = (r,s)
   in
   map f g @@
   sequence2
Index: x509-0.16.5/lib/asn_grammars.ml
===================================================================
--- x509-0.16.5.orig/lib/asn_grammars.ml
+++ x509-0.16.5/lib/asn_grammars.ml
@@ -5,7 +5,7 @@ let ( let* ) = Result.bind
 
 let decode codec cs =
   let* a, cs = Asn.decode codec cs in
-  if Cstruct.length cs = 0 then Ok a else Error (`Parse "Leftover")
+  if String.length cs = 0 then Ok a else Error (`Parse "Leftover")
 
 let projections_of encoding asn =
   let c = Asn.codec encoding asn in (decode c, Asn.encode c)
@@ -41,6 +41,8 @@ let project_exn asn =
     | Error err -> Asn.S.error err in
   (dec, Asn.encode c)
 
+let project_exn_cs c = let d,e = project_exn c in (fun x -> d (Cstruct.to_string x)), (fun x -> Cstruct.of_string (e x))
+
 let err_to_msg f = Result.map_error (function `Parse msg -> `Msg msg) f
 
 (* specified in RFC 5280 4.1.2.5.2 - "MUST NOT include fractional seconds" *)
Index: x509-0.16.5/lib/authenticator.ml
===================================================================
--- x509-0.16.5.orig/lib/authenticator.ml
+++ x509-0.16.5/lib/authenticator.ml
@@ -73,7 +73,7 @@ let of_string str =
       List.fold_left (fun acc s ->
           let* acc = acc in
           let* der = Base64.decode ~pad:false s in
-          let* cert = Certificate.decode_der (Cstruct.of_string der) in
+          let* cert = Certificate.decode_der der in
           Ok (cert :: acc))
         (Ok []) certs
     in
Index: x509-0.16.5/lib/certificate.ml
===================================================================
--- x509-0.16.5.orig/lib/certificate.ml
+++ x509-0.16.5/lib/certificate.ml
@@ -9,15 +9,15 @@ type tBSCertificate = {
   validity   : Ptime.t * Ptime.t ;
   subject    : Distinguished_name.t ;
   pk_info    : Public_key.t ;
-  issuer_id  : Cstruct.t option ;
-  subject_id : Cstruct.t option ;
+  issuer_id  : string option ;
+  subject_id : string option ;
   extensions : Extension.t
 }
 
 type certificate = {
   tbs_cert       : tBSCertificate ;
   signature_algo : Algorithm.t ;
-  signature_val  : Cstruct.t
+  signature_val  : string
 }
 
 (*
@@ -31,7 +31,7 @@ type certificate = {
  *)
 type t = {
   asn : certificate ;
-  raw : Cstruct.t
+  raw : string
 }
 
 module Asn = struct
@@ -57,13 +57,13 @@ module Asn = struct
       (required ~label:"not before" time)
       (required ~label:"not after"  time)
 
-  let unique_identifier = bit_string_cs
+  let unique_identifier = bit_string_octets
 
   let tBSCertificate =
     let f = fun (a, (b, (c, (d, (e, (f, (g, (h, (i, j))))))))) ->
       let extn = match j with None -> Extension.empty | Some xs -> xs
       in
-      { version    = def `V1 a ; serial     = b ;
+      { version    = def `V1 a ; serial     = Z.of_string b ;
         signature  = c         ; issuer     = d ;
         validity   = e         ; subject    = f ;
         pk_info    = g         ; issuer_id  = h ;
@@ -76,7 +76,7 @@ module Asn = struct
         subject_id = i ; extensions = j } ->
       let extn = if Extension.is_empty j then None else Some j
       in
-      (def' `V1 a, (b, (c, (d, (e, (f, (g, (h, (i, extn)))))))))
+      (def' `V1 a, (Z.to_string b, (c, (d, (e, (f, (g, (h, (i, extn)))))))))
     in
     map f g @@
     sequence @@
@@ -108,7 +108,7 @@ module Asn = struct
     sequence3
       (required ~label:"tbsCertificate"     tBSCertificate)
       (required ~label:"signatureAlgorithm" Algorithm.identifier)
-      (required ~label:"signatureValue"     bit_string_cs)
+      (required ~label:"signatureValue"     bit_string_octets)
 
   let (certificate_of_cstruct, certificate_to_cstruct) =
     projections_of Asn.der certificate
@@ -148,17 +148,17 @@ let decode_pem_multiple cs =
   let certs =
     List.filter (fun (t, _) -> String.equal "CERTIFICATE" t) data
   in
-  Pem.foldM (fun (_, cs) -> decode_der cs) certs
+  Pem.foldM (fun (_, cs) -> decode_der (Cstruct.to_string cs)) certs
 
 let decode_pem cs =
   let* certs = decode_pem_multiple cs in
   Pem.exactly_one ~what:"certificate" certs
 
 let encode_pem v =
-  Pem.unparse ~tag:"CERTIFICATE" (encode_der v)
+  Pem.unparse ~tag:"CERTIFICATE" (Cstruct.of_string (encode_der v))
 
 let encode_pem_multiple cs =
-  Cstruct.concat (List.map encode_pem cs)
+  String.concat "" (List.map (fun x -> Cstruct.to_string (encode_pem x)) cs)
 
 let pp_version ppf v =
   Fmt.string ppf (match v with `V1 -> "1" | `V2 -> "2" | `V3 -> "3")
@@ -183,7 +183,7 @@ let pp ppf { asn ; _ } =
     Distinguished_name.pp tbs.subject
     Extension.pp tbs.extensions
 
-let fingerprint hash cert = Mirage_crypto.Hash.digest hash cert.raw
+let fingerprint hash cert = Mirage_crypto.Hash.digest hash (Cstruct.of_string cert.raw)
 
 let issuer { asn ; _ } = asn.tbs_cert.issuer
 
Index: x509-0.16.5/lib/crl.ml
===================================================================
--- x509-0.16.5.orig/lib/crl.ml
+++ x509-0.16.5/lib/crl.ml
@@ -17,7 +17,7 @@ type tBS_CRL = {
 type crl = {
   tbs_crl : tBS_CRL ;
   signature_algo : Algorithm.t ;
-  signature_val : Cstruct.t
+  signature_val : string
 }
 
 module Asn = struct
@@ -27,9 +27,11 @@ module Asn = struct
   let revokedCertificate =
     let f (serial, date, e) =
       let extensions = match e with None -> Extension.empty | Some xs -> xs in
+      let serial = Z.of_string serial in
       { serial ; date ; extensions }
     and g { serial ; date ; extensions } =
       let e = if Extension.is_empty extensions then None else Some extensions in
+      let serial = Z.to_string serial in
       (serial, date, e)
     in
     map f g @@
@@ -81,7 +83,7 @@ module Asn = struct
     sequence3
       (required ~label:"tbsCertList" @@ tBSCertList)
       (required ~label:"signatureAlgorithm" @@ Algorithm.identifier)
-      (required ~label:"signatureValue" @@ bit_string_cs)
+      (required ~label:"signatureValue" @@ bit_string_octets)
 
   let (crl_of_cstruct, crl_to_cstruct) =
     projections_of Asn.der certificateList
@@ -91,7 +93,7 @@ module Asn = struct
 end
 
 type t = {
-  raw : Cstruct.t ;
+  raw : string ;
   asn : crl ;
 }
 
@@ -124,9 +126,9 @@ let signature_algorithm { asn ; _ } =
   Algorithm.to_signature_algorithm asn.signature_algo
 
 let validate { raw ; asn } ?(allowed_hashes = Validation.sha2) pub =
-  let tbs_raw = Validation.raw_cert_hack raw in
+  let tbs_raw = Validation.raw_cert_hack (Cstruct.of_string raw) in
   Validation.validate_raw_signature asn.tbs_crl.issuer allowed_hashes
-    tbs_raw asn.signature_algo asn.signature_val pub
+    tbs_raw asn.signature_algo (Cstruct.of_string asn.signature_val) pub
 
 type verification_error = [
   | Validation.signature_error
@@ -207,7 +209,7 @@ let sign_tbs (tbs : tBS_CRL) key =
   | None -> Error (`Msg "couldn't parse signature algorithm")
   | Some (_, hash) ->
     let scheme = Key_type.x509_default_scheme (Private_key.key_type key) in
-    let* signature_val = Private_key.sign hash ~scheme key (`Message tbs_raw) in
+    let* signature_val = Result.map Cstruct.to_string (Private_key.sign hash ~scheme key (`Message (Cstruct.of_string tbs_raw))) in
     let asn = { tbs_crl = tbs ; signature_algo = tbs.signature ; signature_val } in
     let raw = Asn.crl_to_cstruct asn in
     Ok { asn ; raw }
Index: x509-0.16.5/lib/extension.ml
===================================================================
--- x509-0.16.5.orig/lib/extension.ml
+++ x509-0.16.5/lib/extension.ml
@@ -51,11 +51,11 @@ let pp_extended_key_usage ppf = function
   | `Ocsp_signing -> Fmt.string ppf "ocsp signing"
   | `Other oid -> Asn.OID.pp ppf oid
 
-type authority_key_id = Cstruct.t option * General_name.t * Z.t option
+type authority_key_id = string option * General_name.t * Z.t option
 
 let pp_authority_key_id ppf (id, issuer, serial) =
   Fmt.pf ppf "identifier %a@ issuer %a@ serial %s@ "
-    Fmt.(option ~none:(any "none") Cstruct.hexdump_pp) id
+    Fmt.(option ~none:(any "none") (Fmt.fmt "%S")) id
     General_name.pp issuer
     (match serial with None -> "none" | Some x -> Z.to_string x)
 
@@ -172,10 +172,10 @@ let pp_issuing_distribution_point ppf (n
 type 'a extension = bool * 'a
 
 type _ k =
-  | Unsupported : Asn.oid -> Cstruct.t extension k
+  | Unsupported : Asn.oid -> string extension k
   | Subject_alt_name : General_name.t extension k
   | Authority_key_id : authority_key_id extension k
-  | Subject_key_id : Cstruct.t extension k
+  | Subject_key_id : string extension k
   | Issuer_alt_name : General_name.t extension k
   | Key_usage : key_usage list extension k
   | Ext_key_usage : extended_key_usage list extension k
@@ -203,7 +203,7 @@ let pp_one : type a. a k -> Format.forma
       pp_authority_key_id kid
   | Subject_key_id, (crit, kid) ->
     Fmt.pf ppf "%ssubjectKeyIdentifier %a" (c_to_str crit)
-      Cstruct.hexdump_pp kid
+      (Fmt.fmt "%S") kid
   | Issuer_alt_name, (crit, alt) ->
     Fmt.pf ppf "%sissuerAlternativeNames %a" (c_to_str crit)
       General_name.pp alt
@@ -246,7 +246,7 @@ let pp_one : type a. a k -> Format.forma
       Fmt.(list ~sep:(any "; ") pp_policy) pols
   | Unsupported oid, (crit, cs) ->
     Fmt.pf ppf "%sunsupported %a: %a" (c_to_str crit) Asn.OID.pp oid
-      Cstruct.hexdump_pp cs
+      (Fmt.fmt "%S") cs
 
 module ID = Registry.Cert_extn
 
@@ -352,7 +352,6 @@ let ips exts =
     | Some xs ->
       let ips =
         List.fold_left (fun acc ip ->
-          let ip = Cstruct.to_string ip in
           match
             match String.length ip with
             | 4 -> Result.map (fun ip -> Ipaddr.V4 ip) (Ipaddr.V4.of_octets ip)
@@ -427,8 +426,8 @@ module Asn = struct
       (optional ~label:"pathLen" int)
 
   let authority_key_id =
-    map (fun (a, b, c) -> (a, def  General_name.empty b, c))
-        (fun (a, b, c) -> (a, def' General_name.empty b, c))
+    map (fun (a, b, c) -> (a, def  General_name.empty b, Option.map Z.of_string c))
+        (fun (a, b, c) -> (a, def' General_name.empty b, Option.map Z.to_string c))
     @@
     sequence3
       (optional ~label:"keyIdentifier"  @@ implicit 0 octet_string)
Index: x509-0.16.5/lib/general_name.ml
===================================================================
--- x509-0.16.5.orig/lib/general_name.ml
+++ x509-0.16.5/lib/general_name.ml
@@ -6,7 +6,7 @@ type _ k =
   | Directory : Distinguished_name.t list k
   | EDI_party : (string option * string) list k
   | URI : string list k
-  | IP : Cstruct.t list k
+  | IP : string list k
   | Registered_id : Asn.oid list k
 
 module K = struct
@@ -47,7 +47,7 @@ let pp_k : type a. a k -> Format.formatt
                (pair ~sep:(any ", ")
                   (option ~none:(any "") string) string)) xs
   | URI, x -> Fmt.pf ppf "uri %a" pp_strs x
-  | IP, x -> Fmt.pf ppf "ip %a" Fmt.(list ~sep:(any ";") Cstruct.hexdump_pp) x
+  | IP, x -> Fmt.pf ppf "ip %a" Fmt.(list ~sep:(any ";") (fmt "%S")) x
   | Registered_id, x ->
     Fmt.pf ppf "registered id %a"
       Fmt.(list ~sep:(any ";") Asn.OID.pp) x
Index: x509-0.16.5/lib/ocsp.ml
===================================================================
--- x509-0.16.5.orig/lib/ocsp.ml
+++ x509-0.16.5/lib/ocsp.ml
@@ -11,20 +11,24 @@ let version_v1 = 0
 *)
 type cert_id = {
   hashAlgorithm: Algorithm.t;
-  issuerNameHash: Cstruct.t;
-  issuerKeyHash: Cstruct.t;
+  issuerNameHash: string ;
+  issuerKeyHash: string ;
   serialNumber: Z.t;
 }
 
 let create_cert_id ?(hash=`SHA1) issuer serialNumber =
   let hashAlgorithm = Algorithm.of_hash hash in
   let issuerNameHash =
+    Cstruct.to_string (
     Certificate.subject issuer
     |> Distinguished_name.encode_der
-    |> Mirage_crypto.Hash.digest hash
+    |> Cstruct.of_string
+    |> Mirage_crypto.Hash.digest hash)
   in
   let issuerKeyHash =
+    Cstruct.to_string (
     Public_key.fingerprint ~hash (Certificate.public_key issuer)
+    )
   in
   {hashAlgorithm;issuerNameHash;issuerKeyHash;serialNumber}
 
@@ -33,8 +37,8 @@ let cert_id_serial {serialNumber;_} = se
 let pp_cert_id ppf {hashAlgorithm;issuerNameHash;issuerKeyHash;serialNumber} =
   Fmt.pf ppf "CertID @[<1>{@ algo=%a;@ issuerNameHash=%a;@ issuerKeyHash=%a;@ serialNumber=%a@ }@]"
     Algorithm.pp hashAlgorithm
-    Cstruct.hexdump_pp issuerNameHash
-    Cstruct.hexdump_pp issuerKeyHash
+    (Fmt.fmt "%S") issuerNameHash
+    (Fmt.fmt "%S") issuerKeyHash
     Z.pp_print serialNumber
 
 module Asn_common = struct
@@ -42,12 +46,14 @@ module Asn_common = struct
 
   let cert_id =
     let f (hashAlgorithm, issuerNameHash, issuerKeyHash, serialNumber) =
+      let serialNumber = Z.of_string serialNumber in
       {hashAlgorithm;
        issuerNameHash;
        issuerKeyHash;
        serialNumber;}
     in
     let g {hashAlgorithm;issuerNameHash;issuerKeyHash;serialNumber;} =
+      let serialNumber = Z.to_string serialNumber in
       (hashAlgorithm, issuerNameHash, issuerKeyHash, serialNumber)
     in
     map f g @@
@@ -139,7 +145,7 @@ module Request = struct
   }
 
   type t = {
-    raw : Cstruct.t ;
+    raw : string ;
     asn : req ;
   }
 
@@ -198,6 +204,7 @@ module Request = struct
 
     let signature =
       let f (signatureAlgorithm,signature,certs) =
+        let signature = Cstruct.of_string signature in
         let certs = match certs with
           | None -> None
           | Some certs ->
@@ -210,6 +217,7 @@ module Request = struct
         {signatureAlgorithm;signature;certs}
       in
       let g {signatureAlgorithm;signature;certs} =
+        let signature = Cstruct.to_string signature in
         let certs = match certs with
           | None -> None
           | Some certs ->
@@ -220,7 +228,7 @@ module Request = struct
       map f g @@
       sequence3
         (required ~label:"signatureAlgorithm" Algorithm.identifier)
-        (required ~label:"signature" bit_string_cs)
+        (required ~label:"signature" bit_string_octets)
         (optional ~label:"certs" @@ explicit 0 @@
          sequence_of Certificate.Asn.certificate)
 
@@ -263,7 +271,7 @@ module Request = struct
         let scheme = Key_type.x509_default_scheme (Private_key.key_type key) in
         let signatureAlgorithm = Algorithm.of_signature_algorithm scheme digest in
         let tbs_der = Asn.tbs_request_to_cs tbsRequest in
-        let* signature = Private_key.sign digest ~scheme key (`Message tbs_der) in
+        let* signature = Private_key.sign digest ~scheme key (`Message (Cstruct.of_string tbs_der)) in
         Ok (Some { signature ; signatureAlgorithm ; certs; })
     in
     let asn = { tbsRequest ; optionalSignature } in
@@ -274,7 +282,7 @@ module Request = struct
     match asn.optionalSignature with
     | None -> Error `No_signature
     | Some sign ->
-      let tbs_raw = Validation.raw_cert_hack raw in
+      let tbs_raw = Validation.raw_cert_hack (Cstruct.of_string raw) in
       let dn =
         let cn = "OCSP" in
         [ Distinguished_name.(Relative_distinguished_name.singleton (CN cn)) ]
@@ -396,16 +404,16 @@ module Response = struct
   *)
   type responder_id = [
     | `ByName of Distinguished_name.t
-    | `ByKey of Cstruct.t
+    | `ByKey of string
   ]
 
   let create_responder_id pubkey =
     let pubkey_fp = Public_key.fingerprint ~hash:`SHA1 pubkey in
-    `ByKey pubkey_fp
+    `ByKey (Cstruct.to_string pubkey_fp)
 
   let pp_responder_id ppf = function
     | `ByName dn -> Fmt.pf ppf "ByName %a" Distinguished_name.pp dn
-    | `ByKey hash -> Fmt.pf ppf "ByKey %a" Cstruct.hexdump_pp hash
+    | `ByKey hash -> Fmt.pf ppf "ByKey %a" (Fmt.fmt "%S") hash
 
   (* ResponseData ::= SEQUENCE {
    *  version              [0] EXPLICIT Version DEFAULT v1,
@@ -563,6 +571,7 @@ module Response = struct
 
     let basic_ocsp_response =
       let f (tbsResponseData,signatureAlgorithm,signature,certs) =
+        let signature = Cstruct.of_string signature in
         let certs = match certs with
           | None -> None
           | Some certs ->
@@ -575,6 +584,7 @@ module Response = struct
         {tbsResponseData;signatureAlgorithm;signature;certs}
       in
       let g {tbsResponseData;signatureAlgorithm;signature;certs} =
+        let signature = Cstruct.to_string signature in
         let certs = match certs with
           | None -> None
           | Some certs ->
@@ -586,7 +596,7 @@ module Response = struct
       sequence4
         (required ~label:"tbsResponseData" response_data)
         (required ~label:"signatureAlgorithm" Algorithm.identifier)
-        (required ~label:"signature" bit_string_cs)
+        (required ~label:"signature" bit_string_octets)
         (optional ~label:"certs" @@ explicit 0 @@
          sequence_of Certificate.Asn.certificate)
 
@@ -605,7 +615,7 @@ module Response = struct
             | Error e -> error e
             | Ok basic_response ->
               {responseStatus=`Successful;
-               responseBytes=Some (oid, basic_response, response)}
+               responseBytes=Some (oid, basic_response, (Cstruct.of_string response))}
           else
             parse_error "expected OID ad_ocsp_basic"
         | (`InternalError
@@ -618,7 +628,7 @@ module Response = struct
       in
       let g {responseStatus;responseBytes} =
         let responseBytes = match responseBytes with
-          | Some (oid, _basic_response, response) -> Some (oid, response)
+          | Some (oid, _basic_response, response) -> Some (oid, (Cstruct.to_string response))
           | None -> None
         in
         (responseStatus,responseBytes)
@@ -652,7 +662,7 @@ module Response = struct
       responseExtensions;
     } in
     let resp_der = Asn.response_data_to_cs tbsResponseData in
-    let* signature = Private_key.sign digest ~scheme key (`Message resp_der) in
+    let* signature = Private_key.sign digest ~scheme key (`Message (Cstruct.of_string resp_der)) in
     Ok { tbsResponseData ; signatureAlgorithm ; signature;certs }
 
   let create_success ?digest ?certs ?response_extensions
@@ -662,7 +672,7 @@ module Response = struct
         ?digest ?certs ?response_extensions private_key
         responderID producedAt responses
     in
-    let raw_resp = Asn.basic_ocsp_response_to_cs response in
+    let raw_resp = Cstruct.of_string (Asn.basic_ocsp_response_to_cs response) in
     let responseBytes = Some (Asn.ocsp_basic_oid, response, raw_resp) in
     Ok { responseStatus = `Successful ; responseBytes }
 
Index: x509-0.16.5/lib/p12.ml
===================================================================
--- x509-0.16.5.orig/lib/p12.ml
+++ x509-0.16.5/lib/p12.ml
@@ -6,13 +6,13 @@
    some definitions from PKCS7 (RFC 2315) are implemented as well, as needed
 *)
 
-type content_info = Asn.oid * Cstruct.t
+type content_info = Asn.oid * string
 
-type digest_info = Algorithm.t * Cstruct.t
+type digest_info = Algorithm.t * string
 
-type mac_data = digest_info * Cstruct.t * int
+type mac_data = digest_info * string * int
 
-type t = Cstruct.t * mac_data
+type t = string * mac_data
 
 module Asn = struct
   open Asn_grammars
@@ -310,8 +310,8 @@ let pkcs12_decrypt algo password data =
     | SHA_RC2_40_CBC (s, i) -> Ok (s, i, 5, 8)
     | _ -> Error (`Msg "unsupported algorithm")
   in
-  let key = pbes hash `Encryption password salt count key_len
-  and iv = pbes hash `Iv password salt count iv_len
+  let key = pbes hash `Encryption password (Cstruct.of_string salt) count key_len
+  and iv = pbes hash `Iv password (Cstruct.of_string salt) count iv_len
   in
   let* data =
     match algo with
@@ -350,14 +350,14 @@ let pkcs5_2_decrypt kdf enc password dat
     | _ -> Error (`Msg "expected kdf being pbkdf2")
   in
   let password = Cstruct.of_string password in
-  let key = Pbkdf.pbkdf2 ~prf ~password ~salt ~count ~dk_len in
+  let key = Pbkdf.pbkdf2 ~prf ~password ~salt:(Cstruct.of_string salt) ~count ~dk_len in
   let key = Mirage_crypto.Cipher_block.AES.CBC.of_secret key in
-  let msg = Mirage_crypto.Cipher_block.AES.CBC.decrypt ~key ~iv data in
+  let msg = Mirage_crypto.Cipher_block.AES.CBC.decrypt ~key ~iv:(Cstruct.of_string iv) data in
   Ok (unpad msg)
 
 let pkcs5_2_encrypt (mac : [ `SHA1 | `SHA224 | `SHA256 | `SHA384 | `SHA512 ]) count algo password data =
   let bs = Mirage_crypto.Cipher_block.AES.CBC.block_size in
-  let iv = Mirage_crypto_rng.generate bs in
+  let iv = Cstruct.to_string (Mirage_crypto_rng.generate bs) in
   let enc, dk_len =
     match algo with
     | `AES128_CBC -> Algorithm.AES128_CBC iv, 16l
@@ -370,9 +370,9 @@ let pkcs5_2_encrypt (mac : [ `SHA1 | `SH
   let key = Mirage_crypto.Cipher_block.AES.CBC.of_secret key in
   let padded_data = pad bs data in
   let enc_data =
-    Mirage_crypto.Cipher_block.AES.CBC.encrypt ~key ~iv padded_data
+    Mirage_crypto.Cipher_block.AES.CBC.encrypt ~key ~iv:(Cstruct.of_string iv) padded_data
   in
-  let kdf = Algorithm.PBKDF2 (salt, count, None, Algorithm.of_hmac mac) in
+  let kdf = Algorithm.PBKDF2 (Cstruct.to_string salt, count, None, Algorithm.of_hmac mac) in
   Algorithm.PBES2 (kdf, enc), enc_data
 
 let decrypt algo password data =
@@ -387,7 +387,7 @@ let decrypt algo password data =
 let password_decrypt password (algo, data) =
   match data with
   | None -> Error (`Msg "no data to decrypt")
-  | Some data -> decrypt algo password data
+  | Some data -> decrypt algo password (Cstruct.of_string data)
 
 let verify password (data, ((algorithm, digest), salt, iterations)) =
   let* hash =
@@ -396,19 +396,19 @@ let verify password (data, ((algorithm,
       (Algorithm.to_hash algorithm)
   in
   let key =
-    pbes hash `Hmac password salt iterations (Mirage_crypto.Hash.digest_size hash)
+    pbes hash `Hmac password (Cstruct.of_string salt) iterations (Mirage_crypto.Hash.digest_size hash)
   in
-  let computed = Mirage_crypto.Hash.mac hash ~key data in
-  if Cstruct.equal computed digest then begin
+  let computed = Mirage_crypto.Hash.mac hash ~key (Cstruct.of_string data) in
+  if Cstruct.equal computed (Cstruct.of_string digest) then begin
     let* content = Asn_grammars.err_to_msg (Asn.auth_safe_of_cs data) in
     let* safe_contents =
       List.fold_left (fun acc c ->
           let* acc = acc in
           match c with
-          | `Data data -> Ok (data :: acc)
+          | `Data data -> Ok ((Cstruct.of_string data) :: acc)
           | `Encrypted data ->
             let* data = password_decrypt password data in
-            Ok (data :: acc))
+            Ok ( data :: acc))
         (Ok []) content
     in
     List.fold_left (fun acc cs ->
@@ -421,20 +421,20 @@ let verify password (data, ((algorithm,
             | `Crl c, _ -> Ok (`Crl c :: acc)
             | `Private_key p, _ -> Ok (`Private_key p :: acc)
             | `Encrypted_private_key (algo, enc_data), _ ->
-              let* data = decrypt algo password enc_data in
+              let* data = decrypt algo password (Cstruct.of_string enc_data) in
               let* p =
-                Asn_grammars.err_to_msg (Private_key.Asn.private_of_cstruct data)
+                Asn_grammars.err_to_msg (Private_key.Asn.private_of_cstruct (Cstruct.to_string data))
               in
               Ok (`Decrypted_private_key p :: acc))
           (Ok acc) bags)
-      (Ok []) safe_contents
+      (Ok []) (List.map Cstruct.to_string safe_contents)
   end else
     Error (`Msg "invalid signature")
 
 let create ?(mac = `SHA256) ?(algorithm = `AES256_CBC) ?(iterations = 2048) password certificates private_key =
   let key_fp pub = Public_key.fingerprint pub in
   let priv_fp = key_fp (Private_key.public private_key) in
-  let attributes = [ Registry.PKCS9.local_key_id, [ priv_fp ]] in
+  let attributes = [ Registry.PKCS9.local_key_id, [ Cstruct.to_string priv_fp ]] in
   let maybe_attr c =
     if Cstruct.equal priv_fp (key_fp (Certificate.public_key c)) then
       Some attributes
@@ -444,13 +444,13 @@ let create ?(mac = `SHA256) ?(algorithm
   let cert_sc =
     Asn.safe_contents_to_cs (List.map (fun c -> `Certificate c, maybe_attr c) certificates)
   and priv_sc =
-    let data = Private_key.Asn.private_to_cstruct private_key in
+    let data = Cstruct.of_string (Private_key.Asn.private_to_cstruct private_key) in
     let algo, data = pkcs5_2_encrypt mac iterations algorithm password data in
-    Asn.safe_contents_to_cs [ `Encrypted_private_key (algo, data), Some attributes ]
+    Asn.safe_contents_to_cs [ `Encrypted_private_key (algo, (Cstruct.to_string data)), Some attributes ]
   in
   let cert_sc_enc =
-    let algo, data = pkcs5_2_encrypt mac iterations algorithm password cert_sc in
-    algo, Some data
+    let algo, data = pkcs5_2_encrypt mac iterations algorithm password (Cstruct.of_string cert_sc) in
+    algo, Some (Cstruct.to_string data)
   in
   let auth_data =
     Asn.auth_safe_to_cs [ `Encrypted cert_sc_enc ; `Data priv_sc ]
@@ -458,8 +458,8 @@ let create ?(mac = `SHA256) ?(algorithm
   let mac_size = Mirage_crypto.Hash.digest_size mac in
   let salt = Mirage_crypto_rng.generate mac_size in
   let key = pbes mac `Hmac password salt iterations mac_size in
-  let digest = Mirage_crypto.Hash.mac mac ~key auth_data in
-  auth_data, ((Algorithm.of_hash mac, digest), salt, iterations)
+  let digest = Mirage_crypto.Hash.mac mac ~key (Cstruct.of_string auth_data) in
+  auth_data, ((Algorithm.of_hash mac, (Cstruct.to_string digest)), (Cstruct.to_string salt), iterations)
 
 let decode_der cs = Asn_grammars.err_to_msg (Asn.pfx_of_cs cs)
 
Index: x509-0.16.5/lib/private_key.ml
===================================================================
--- x509-0.16.5.orig/lib/private_key.ml
+++ x509-0.16.5/lib/private_key.ml
@@ -85,7 +85,7 @@ let public = function
 let sign hash ?scheme key data =
   let open Mirage_crypto_ec in
   let hashed () = Public_key.hashed hash data
-  and ecdsa_to_cs s = Algorithm.ecdsa_sig_to_cstruct s
+  and ecdsa_to_cs s = Algorithm.ecdsa_sig_to_cstruct ((fun (a,b) -> (Cstruct.to_string a,Cstruct.to_string b)) s)
   in
   let scheme = Key_type.opt_signature_scheme ?scheme (key_type key) in
   try
@@ -105,11 +105,11 @@ let sign hash ?scheme key data =
       end
     | #ecdsa as key, `ECDSA ->
       let* d = hashed () in
-      Ok (ecdsa_to_cs (match key with
+      Ok (Cstruct.of_string (ecdsa_to_cs (match key with
           | `P224 key -> P224.Dsa.(sign ~key (Public_key.trunc byte_length d))
           | `P256 key -> P256.Dsa.(sign ~key (Public_key.trunc byte_length d))
           | `P384 key -> P384.Dsa.(sign ~key (Public_key.trunc byte_length d))
-          | `P521 key -> P521.Dsa.(sign ~key (Public_key.trunc byte_length d))))
+          | `P521 key -> P521.Dsa.(sign ~key (Public_key.trunc byte_length d)))))
     | _ -> Error (`Msg "invalid key and signature scheme combination")
   with
   | Mirage_crypto_pk.Rsa.Insufficient_key ->
@@ -132,13 +132,13 @@ module Asn = struct
     let f (v, (n, (e, (d, (p, (q, (dp, (dq, (q', other))))))))) =
       match (v, other) with
       | (0, None) ->
-        begin match Rsa.priv ~e ~d ~n ~p ~q ~dp ~dq ~q' with
+        begin match Rsa.priv ~e:(Z.of_string e) ~d:(Z.of_string d) ~n:(Z.of_string n) ~p:(Z.of_string p) ~q:(Z.of_string q) ~dp:(Z.of_string dp) ~dq:(Z.of_string dq) ~q':(Z.of_string q') with
           | Ok p -> p
           | Error (`Msg m) -> parse_error "bad RSA private key %s" m
         end
       | _         -> parse_error "multi-prime RSA keys not supported"
     and g { Rsa.e; d; n; p; q; dp; dq; q' } =
-      (0, (n, (e, (d, (p, (q, (dp, (dq, (q', None))))))))) in
+      (0, (Z.to_string n, (Z.to_string e, (Z.to_string d, (Z.to_string p, (Z.to_string q, (Z.to_string dp, (Z.to_string dq, (Z.to_string q', None))))))))) in
     map f g @@
     sequence @@
         (required ~label:"version"         int)
@@ -212,7 +212,7 @@ module Asn = struct
       | Some c ->
         Result.map_error
           (fun e -> `Parse (Fmt.to_to_string Mirage_crypto_ec.pp_error e))
-          (reparse_ec_private c priv)
+          (reparse_ec_private c (Cstruct.of_string priv))
 
   let ec_of_cs ?curve cs =
     let (priv, named_curve, _pub) = ec_of_cs cs in
@@ -223,7 +223,7 @@ module Asn = struct
       | Some c, Some c' -> if c = c' then c else parse_error "conflicting curve"
       | None, None -> parse_error "unknown curve"
     in
-    ec_to_err (reparse_ec_private nc priv)
+    ec_to_err (reparse_ec_private nc (Cstruct.of_string priv))
 
   let ec_to_cs ?curve ?pub key = ec_to_cs (key, curve, pub)
 
@@ -232,7 +232,7 @@ module Asn = struct
     | (0, Algorithm.RSA, cs) -> `RSA (rsa_priv_of_cs cs)
     | (0, Algorithm.ED25519, cs) ->
       let data = ed25519_of_cs cs in
-      `ED25519 (ec_to_err (Mirage_crypto_ec.Ed25519.priv_of_cstruct data))
+      `ED25519 (ec_to_err (Mirage_crypto_ec.Ed25519.priv_of_cstruct (Cstruct.of_string data)))
     | (0, Algorithm.EC_pub curve, cs) -> ec_of_cs ~curve cs
     | _ -> parse_error "unknown private key info"
 
@@ -242,11 +242,11 @@ module Asn = struct
     let alg, cs =
       match p with
       | `RSA pk -> RSA, rsa_priv_to_cs pk
-      | `ED25519 pk -> ED25519, ed25519_to_cs (Ed25519.priv_to_cstruct pk)
-      | `P224 pk -> EC_pub `SECP224R1, ec_to_cs (P224.Dsa.priv_to_cstruct pk)
-      | `P256 pk -> EC_pub `SECP256R1, ec_to_cs (P256.Dsa.priv_to_cstruct pk)
-      | `P384 pk -> EC_pub `SECP384R1, ec_to_cs (P384.Dsa.priv_to_cstruct pk)
-      | `P521 pk -> EC_pub `SECP521R1, ec_to_cs (P521.Dsa.priv_to_cstruct pk)
+      | `ED25519 pk -> ED25519, ed25519_to_cs (Cstruct.to_string (Ed25519.priv_to_cstruct pk))
+      | `P224 pk -> EC_pub `SECP224R1, ec_to_cs (Cstruct.to_string (P224.Dsa.priv_to_cstruct pk))
+      | `P256 pk -> EC_pub `SECP256R1, ec_to_cs (Cstruct.to_string (P256.Dsa.priv_to_cstruct pk))
+      | `P384 pk -> EC_pub `SECP384R1, ec_to_cs (Cstruct.to_string (P384.Dsa.priv_to_cstruct pk))
+      | `P521 pk -> EC_pub `SECP521R1, ec_to_cs (Cstruct.to_string (P521.Dsa.priv_to_cstruct pk))
     in
     (0, alg, cs)
 
@@ -281,18 +281,18 @@ let decode_pem cs =
   in
   let* k =
     Pem.foldM (fun (_, k) ->
-        let* k = Asn_grammars.err_to_msg (Asn.rsa_private_of_cstruct k) in
+        let* k = Asn_grammars.err_to_msg (Asn.rsa_private_of_cstruct (Cstruct.to_string k)) in
         Ok (`RSA k)) r
   in
   let* k' =
     Pem.foldM (fun (_, k) ->
-        Asn_grammars.err_to_msg (Asn.ec_priv_of_cs k)) ec
+        Asn_grammars.err_to_msg (Asn.ec_priv_of_cs (Cstruct.to_string k))) ec
   in
   let* k'' =
     Pem.foldM (fun (_, k) ->
-        Asn_grammars.err_to_msg (Asn.private_of_cstruct k)) p
+        Asn_grammars.err_to_msg (Asn.private_of_cstruct (Cstruct.to_string k))) p
   in
   Pem.exactly_one ~what:"private key" (k @ k' @ k'')
 
 let encode_pem p =
-  Pem.unparse ~tag:"PRIVATE KEY" (Asn.private_to_cstruct p)
+  Pem.unparse ~tag:"PRIVATE KEY" (Cstruct.of_string (Asn.private_to_cstruct p))
Index: x509-0.16.5/lib/public_key.ml
===================================================================
--- x509-0.16.5.orig/lib/public_key.ml
+++ x509-0.16.5/lib/public_key.ml
@@ -21,10 +21,13 @@ module Asn = struct
   open Mirage_crypto_pk
 
   let rsa_public_key =
-    let f (n, e) = match Rsa.pub ~e ~n with
+    let f (n', e') = 
+    let n = Mirage_crypto_pk.Z_extra.of_cstruct_be (Cstruct.of_string n') in
+    let e = Mirage_crypto_pk.Z_extra.of_cstruct_be (Cstruct.of_string e') in
+    match Rsa.pub ~e ~n with
       | Ok p -> p
       | Error (`Msg m) -> parse_error "bad RSA public key %s" m
-    and g ({ Rsa.n; e } : Rsa.pub) = (n, e) in
+    and g ({ Rsa.n; e } : Rsa.pub) = (Cstruct.to_string (Mirage_crypto_pk.Z_extra.to_cstruct_be n), Cstruct.to_string (Mirage_crypto_pk.Z_extra.to_cstruct_be e)) in
     map f g @@
     sequence2
       (required ~label:"modulus"        integer)
@@ -46,11 +49,11 @@ module Asn = struct
     let open Algorithm in
     function
     | (RSA      , cs) -> `RSA (rsa_pub_of_cs cs)
-    | (ED25519  , cs) -> `ED25519 (to_err (Ed25519.pub_of_cstruct cs))
-    | (EC_pub `SECP224R1, cs) -> `P224 (to_err (P224.Dsa.pub_of_cstruct cs))
-    | (EC_pub `SECP256R1, cs) -> `P256 (to_err (P256.Dsa.pub_of_cstruct cs))
-    | (EC_pub `SECP384R1, cs) -> `P384 (to_err (P384.Dsa.pub_of_cstruct cs))
-    | (EC_pub `SECP521R1, cs) -> `P521 (to_err (P521.Dsa.pub_of_cstruct cs))
+    | (ED25519  , cs) -> `ED25519 (to_err (Ed25519.pub_of_cstruct (Cstruct.of_string cs)))
+    | (EC_pub `SECP224R1, cs) -> `P224 (to_err (P224.Dsa.pub_of_cstruct (Cstruct.of_string cs)))
+    | (EC_pub `SECP256R1, cs) -> `P256 (to_err (P256.Dsa.pub_of_cstruct (Cstruct.of_string cs)))
+    | (EC_pub `SECP384R1, cs) -> `P384 (to_err (P384.Dsa.pub_of_cstruct (Cstruct.of_string cs)))
+    | (EC_pub `SECP521R1, cs) -> `P521 (to_err (P521.Dsa.pub_of_cstruct (Cstruct.of_string cs)))
     | _ -> parse_error "unknown public key algorithm"
 
   let unparse_pk =
@@ -58,17 +61,17 @@ module Asn = struct
     let open Algorithm in
     function
     | `RSA pk    -> (RSA, rsa_pub_to_cs pk)
-    | `ED25519 pk -> (ED25519, Ed25519.pub_to_cstruct pk)
-    | `P224 pk -> (EC_pub `SECP224R1, P224.Dsa.pub_to_cstruct pk)
-    | `P256 pk -> (EC_pub `SECP256R1, P256.Dsa.pub_to_cstruct pk)
-    | `P384 pk -> (EC_pub `SECP384R1, P384.Dsa.pub_to_cstruct pk)
-    | `P521 pk -> (EC_pub `SECP521R1, P521.Dsa.pub_to_cstruct pk)
+    | `ED25519 pk -> (ED25519, Cstruct.to_string (Ed25519.pub_to_cstruct pk))
+    | `P224 pk -> (EC_pub `SECP224R1, Cstruct.to_string (P224.Dsa.pub_to_cstruct pk))
+    | `P256 pk -> (EC_pub `SECP256R1, Cstruct.to_string (P256.Dsa.pub_to_cstruct pk))
+    | `P384 pk -> (EC_pub `SECP384R1, Cstruct.to_string (P384.Dsa.pub_to_cstruct pk))
+    | `P521 pk -> (EC_pub `SECP521R1, Cstruct.to_string (P521.Dsa.pub_to_cstruct pk))
 
   let pk_info_der =
     map reparse_pk unparse_pk @@
     sequence2
       (required ~label:"algorithm" Algorithm.identifier)
-      (required ~label:"subjectPK" bit_string_cs)
+      (required ~label:"subjectPK" bit_string_octets)
 
   let (pub_info_of_cstruct, pub_info_to_cstruct) =
     projections_of Asn.der pk_info_der
@@ -77,16 +80,16 @@ end
 let id k =
   let data = match k with
     | `RSA p -> Asn.rsa_public_to_cstruct p
-    | `ED25519 pk -> Mirage_crypto_ec.Ed25519.pub_to_cstruct pk
-    | `P224 pk -> Mirage_crypto_ec.P224.Dsa.pub_to_cstruct pk
-    | `P256 pk -> Mirage_crypto_ec.P256.Dsa.pub_to_cstruct pk
-    | `P384 pk -> Mirage_crypto_ec.P384.Dsa.pub_to_cstruct pk
-    | `P521 pk -> Mirage_crypto_ec.P521.Dsa.pub_to_cstruct pk
+    | `ED25519 pk -> Cstruct.to_string (Mirage_crypto_ec.Ed25519.pub_to_cstruct pk)
+    | `P224 pk -> Cstruct.to_string (Mirage_crypto_ec.P224.Dsa.pub_to_cstruct pk)
+    | `P256 pk -> Cstruct.to_string (Mirage_crypto_ec.P256.Dsa.pub_to_cstruct pk)
+    | `P384 pk -> Cstruct.to_string (Mirage_crypto_ec.P384.Dsa.pub_to_cstruct pk)
+    | `P521 pk -> Cstruct.to_string (Mirage_crypto_ec.P521.Dsa.pub_to_cstruct pk)
   in
-  Mirage_crypto.Hash.digest `SHA1 data
+  Mirage_crypto.Hash.digest `SHA1 (Cstruct.of_string data)
 
 let fingerprint ?(hash = `SHA256) pub =
-  Mirage_crypto.Hash.digest hash (Asn.pub_info_to_cstruct pub)
+  Mirage_crypto.Hash.digest hash (Cstruct.of_string (Asn.pub_info_to_cstruct pub))
 
 let key_type = function
   | `RSA _ -> `RSA
@@ -122,9 +125,11 @@ let trunc len data =
 let verify hash ?scheme ~signature key data =
   let open Mirage_crypto_ec in
   let ok_if_true p = if p then Ok () else Error (`Msg "bad signature") in
+  let map_pair f (a,b) = (f a , f b) in
   let ecdsa_of_cs cs =
+    Result.map (map_pair Cstruct.of_string) (
     Result.map_error (function `Parse s -> `Msg s)
-      (Algorithm.ecdsa_sig_of_cstruct cs)
+      (Algorithm.ecdsa_sig_of_cstruct (Cstruct.to_string cs)))
   in
   let scheme = Key_type.opt_signature_scheme ?scheme (key_type key) in
   match key, scheme with
@@ -160,8 +165,8 @@ let decode_der cs = Asn_grammars.err_to_
 let decode_pem cs =
   let* data = Pem.parse cs in
   let pks = List.filter (fun (t, _) -> String.equal "PUBLIC KEY" t) data in
-  let* keys = Pem.foldM (fun (_, k) -> decode_der k) pks in
+  let* keys = Pem.foldM (fun (_, k) -> decode_der (Cstruct.to_string k)) pks in
   Pem.exactly_one ~what:"public key" keys
 
 let encode_pem v =
-  Pem.unparse ~tag:"PUBLIC KEY" (encode_der v)
+  Pem.unparse ~tag:"PUBLIC KEY" (Cstruct.of_string (encode_der v))
Index: x509-0.16.5/lib/signing_request.ml
===================================================================
--- x509-0.16.5.orig/lib/signing_request.ml
+++ x509-0.16.5/lib/signing_request.ml
@@ -38,12 +38,12 @@ type request_info = {
 type request = {
   info : request_info ;
   signature_algorithm : Algorithm.t ;
-  signature : Cstruct.t
+  signature : string
 }
 
 type t = {
   asn : request ;
-  raw : Cstruct.t ;
+  raw : string ;
 }
 
 module Asn = struct
@@ -106,7 +106,7 @@ module Asn = struct
     sequence3
       (required ~label:"certificationRequestInfo" request_info)
       (required ~label:"signatureAlgorithm" Algorithm.identifier)
-      (required ~label:"signature" bit_string_cs)
+      (required ~label:"signature" bit_string_octets)
 
   let signing_request_of_cs, signing_request_to_cs =
     projections_of Asn.der signing_request
@@ -134,9 +134,9 @@ let hostnames csr =
     | None -> subj
 
 let validate_signature allowed_hashes { asn ; raw } =
-  let raw_data = Validation.raw_cert_hack raw in
+  let raw_data = Validation.raw_cert_hack (Cstruct.of_string raw) in
   Validation.validate_raw_signature asn.info.subject allowed_hashes raw_data
-    asn.signature_algorithm asn.signature asn.info.public_key
+    asn.signature_algorithm (Cstruct.of_string asn.signature) asn.info.public_key
 
 let decode_der ?(allowed_hashes = Validation.sha2) cs =
   let* csr = Asn_grammars.err_to_msg (Asn.signing_request_of_cs cs) in
@@ -155,11 +155,11 @@ let decode_pem cs =
   let crs =
     List.filter (fun (t, _) -> String.equal "CERTIFICATE REQUEST" t) data
   in
-  let* csrs = Pem.foldM (fun (_, cs) -> decode_der cs) crs in
+  let* csrs = Pem.foldM (fun (_, cs) -> decode_der (Cstruct.to_string cs)) crs in
   Pem.exactly_one ~what:"certificate request" csrs
 
 let encode_pem v =
-  Pem.unparse ~tag:"CERTIFICATE REQUEST" (encode_der v)
+  Pem.unparse ~tag:"CERTIFICATE REQUEST" (Cstruct.of_string (encode_der v))
 
 let digest_of_key = function
   | `RSA _ -> `SHA256
@@ -178,7 +178,7 @@ let create subject ?digest ?(extensions
   let info : request_info = { subject ; public_key ; extensions } in
   let info_cs = Asn.request_info_to_cs info in
   let scheme = Key_type.x509_default_scheme (Private_key.key_type key) in
-  let* signature = Private_key.sign hash ~scheme key (`Message info_cs) in
+  let* signature = Result.map Cstruct.to_string (Private_key.sign hash ~scheme key (`Message (Cstruct.of_string info_cs))) in
   let signature_algorithm = Algorithm.of_signature_algorithm scheme hash in
   let asn = { info ; signature_algorithm ; signature } in
   let raw = Asn.signing_request_to_cs asn in
@@ -213,7 +213,7 @@ let sign signing_request
   } in
   let tbs_raw = Certificate.Asn.tbs_certificate_to_cstruct tbs_cert in
   let scheme = Key_type.x509_default_scheme (Private_key.key_type key) in
-  let* signature_val = Private_key.sign hash ~scheme key (`Message tbs_raw) in
+  let* signature_val = Result.map Cstruct.to_string (Private_key.sign hash ~scheme key (`Message (Cstruct.of_string tbs_raw))) in
   let asn = {
     Certificate.tbs_cert ;
     signature_algo ;
Index: x509-0.16.5/lib/validation.ml
===================================================================
--- x509-0.16.5.orig/lib/validation.ml
+++ x509-0.16.5/lib/validation.ml
@@ -97,9 +97,9 @@ let raw_cert_hack raw =
   Cstruct.sub cert_buf 0 cert_len
 
 let validate_signature allowed_hashes { Certificate.asn = trusted ; _ } { Certificate.asn ; raw } =
-  let tbs_raw = raw_cert_hack raw in
+  let tbs_raw = raw_cert_hack (Cstruct.of_string raw) in
   validate_raw_signature asn.tbs_cert.subject allowed_hashes tbs_raw
-    asn.signature_algo asn.signature_val trusted.tbs_cert.pk_info
+    asn.signature_algo (Cstruct.of_string asn.signature_val) trusted.tbs_cert.pk_info
 
 let validate_time time { Certificate.asn = cert ; _ } =
   match time with
@@ -201,7 +201,7 @@ let ext_authority_matches_subject truste
                    find Subject_key_id (Certificate.extensions trusted))
   with
   | (_, None) | (None, _)                       -> true (* not mandatory *)
-  | Some (_, (Some auth, _, _)), Some (_, au)   -> Cstruct.equal auth au
+  | Some (_, (Some auth, _, _)), Some (_, au)   -> String.equal auth au
   (* TODO: check exact rules in RFC5280 *)
   | Some (_, (None, _, _)), _                   -> true (* not mandatory *)
 
Index: x509-0.16.5/lib/x509.mli
===================================================================
--- x509-0.16.5.orig/lib/x509.mli
+++ x509-0.16.5/lib/x509.mli
@@ -153,10 +153,10 @@ module Public_key : sig
   (** {1 Decoding and encoding in ASN.1 DER and PEM format} *)
 
   (** [encode_der pk] is [buffer], the ASN.1 encoding of the given public key. *)
-  val encode_der : t -> Cstruct.t
+  val encode_der : t -> string
 
   (** [decode_der buffer] is [pubkey], the public key of the ASN.1 encoded buffer. *)
-  val decode_der : Cstruct.t -> (t, [> `Msg of string ]) result
+  val decode_der : string -> (t, [> `Msg of string ]) result
 
   (** [decode_pem pem] is [t], where the public key of [pem] is extracted *)
   val decode_pem : Cstruct.t -> (t, [> `Msg of string ]) result
@@ -227,11 +227,11 @@ module Private_key : sig
   (** [decode_der der] is [t], where the private key of [der] is
       extracted. It must be in PKCS8 (RFC 5208, Section 5) PrivateKeyInfo
       structure. *)
-  val decode_der : Cstruct.t -> (t, [> `Msg of string ]) result
+  val decode_der : string -> (t, [> `Msg of string ]) result
 
   (** [encode_der key] is [der], the encoded private key as PKCS8 (RFC 5208,
       Section 5) PrivateKeyInfo structure. *)
-  val encode_der : t -> Cstruct.t
+  val encode_der : t -> string
 
   (** [decode_pem pem] is [t], where the private key of [pem] is
       extracted. Both RSA PRIVATE KEY and PRIVATE KEY stanzas are supported. *)
@@ -322,11 +322,11 @@ module Distinguished_name : sig
   val common_name : t -> string option
 
   (** [decode_der cs] is [dn], the ASN.1 decoded distinguished name of [cs]. *)
-  val decode_der : Cstruct.t -> (t, [> `Msg of string ]) result
+  val decode_der : string -> (t, [> `Msg of string ]) result
 
   (** [encode_der dn] is [cstruct], the ASN.1 encoded representation of the
       distinguished name [dn]. *)
-  val encode_der : t -> Cstruct.t
+  val encode_der : t -> string
 end
 
 (** A list of [general_name]s is the value of both
@@ -343,7 +343,7 @@ module General_name : sig
     | Directory : Distinguished_name.t list k
     | EDI_party : (string option * string) list k
     | URI : string list k
-    | IP : Cstruct.t list k
+    | IP : string list k
     | Registered_id : Asn.oid list k
 
   include Gmap.S with type 'a key = 'a k
@@ -388,7 +388,7 @@ module Extension : sig
   (** The authority key identifier, as present in the
       {{:https://tools.ietf.org/html/rfc5280#section-4.2.1.1}Authority Key Identifier}
       extension. *)
-  type authority_key_id = Cstruct.t option * General_name.t * Z.t option
+  type authority_key_id = string option * General_name.t * Z.t option
 
   (** The private key usage period, as defined in
       {{:https://tools.ietf.org/html/rfc3280#section-4.2.1.4}RFC 3280}. *)
@@ -443,10 +443,10 @@ module Extension : sig
       {{:https://tools.ietf.org/html/rfc5280#section-4.2}X509v3} and
       {{:https://tools.ietf.org/html/rfc5280#section-5.2}CRL} extensions. *)
   type _ k =
-    | Unsupported : Asn.oid -> Cstruct.t extension k
+    | Unsupported : Asn.oid -> string extension k
     | Subject_alt_name : General_name.t extension k
     | Authority_key_id : authority_key_id extension k
-    | Subject_key_id : Cstruct.t extension k
+    | Subject_key_id : string extension k
     | Issuer_alt_name : General_name.t extension k
     | Key_usage : key_usage list extension k
     | Ext_key_usage : extended_key_usage list extension k
@@ -477,12 +477,12 @@ module Certificate : sig
 
   (** [decode_pkcs1_digest_info buffer] is [hash, signature], the hash and raw
       signature of the given [buffer] in ASN.1 DER encoding, or an error. *)
-  val decode_pkcs1_digest_info : Cstruct.t ->
-    (Mirage_crypto.Hash.hash * Cstruct.t, [> `Msg of string ]) result
+  val decode_pkcs1_digest_info : string ->
+    (Mirage_crypto.Hash.hash * string, [> `Msg of string ]) result
 
   (** [encode_pkcs1_digest_info (hash, signature)] is [data], the ASN.1 DER
       encoded hash and signature. *)
-  val encode_pkcs1_digest_info : Mirage_crypto.Hash.hash * Cstruct.t -> Cstruct.t
+  val encode_pkcs1_digest_info : Mirage_crypto.Hash.hash * string -> string
 
   (** {1 Abstract certificate type} *)
 
@@ -496,11 +496,11 @@ module Certificate : sig
 
   (** [decode_der cstruct] is [certificate], the ASN.1 decoded [certificate]
       or an error. *)
-  val decode_der : Cstruct.t -> (t, [> `Msg of string ]) result
+  val decode_der : string -> (t, [> `Msg of string ]) result
 
   (** [encode_der certificate] is [cstruct], the ASN.1 encoded representation of
       the [certificate]. *)
-  val encode_der  : t -> Cstruct.t
+  val encode_der  : t -> string
 
   (** [decode_pem_multiple pem] is [t list], where all certificates of the [pem]
        are extracted *)
@@ -511,7 +511,7 @@ module Certificate : sig
   val decode_pem : Cstruct.t -> (t, [> `Msg of string ]) result
 
   (** [encode_pem_multiple certificates] is [pem], the pem encoded certificates. *)
-  val encode_pem_multiple : t list -> Cstruct.t
+  val encode_pem_multiple : t list -> string
 
   (** [encode_pem certificate] is [pem], the pem encoded certificate. *)
   val encode_pem : t -> Cstruct.t
@@ -776,11 +776,11 @@ module Signing_request : sig
       decoded [cstruct] or an error. The signature on the signing request
       is validated, and its hash algorithm must be in [allowed_hashes] (by
       default only SHA-2 is accepted). *)
-  val decode_der : ?allowed_hashes:Mirage_crypto.Hash.hash list -> Cstruct.t ->
+  val decode_der : ?allowed_hashes:Mirage_crypto.Hash.hash list -> string ->
     (t, [> `Msg of string ]) result
 
   (** [encode_der sr] is [cstruct], the ASN.1 encoded representation of the [sr]. *)
-  val encode_der : t -> Cstruct.t
+  val encode_der : t -> string
 
   (** [decode_pem pem] is [t], where the single signing request of the [pem] is extracted *)
   val decode_pem : Cstruct.t -> (t, [> `Msg of string ]) result
@@ -874,11 +874,11 @@ module CRL : sig
 
   (** [encode_der crl] is [buffer], the ASN.1 DER encoding of the given
       certificate revocation list. *)
-  val encode_der : t -> Cstruct.t
+  val encode_der : t -> string
 
   (** [decode_der buffer] is [crl], the certificate revocation list of the
       ASN.1 encoded buffer. *)
-  val decode_der : Cstruct.t -> (t, [> `Msg of string ]) result
+  val decode_der : string -> (t, [> `Msg of string ]) result
 
   (** {1 Operations on CRLs} *)
 
@@ -1045,10 +1045,10 @@ module PKCS12 : sig
   type t
 
   (** [decode_der buffer] is [t], the PKCS12 archive of [buffer]. *)
-  val decode_der : Cstruct.t -> (t, [> `Msg of string ]) result
+  val decode_der : string -> (t, [> `Msg of string ]) result
 
   (** [encode_der t] is [buf], the PKCS12 encoded archive of [t]. *)
-  val encode_der : t -> Cstruct.t
+  val encode_der : t -> string
 
   (** [verify password t] verifies and decrypts the PKCS12 archive [t]. The
       result is the contents of the archive. *)
@@ -1117,10 +1117,10 @@ module OCSP : sig
     val cert_ids : t -> cert_id list
 
     (** [decode_der buffer] decodes request in buffer *)
-    val decode_der : Cstruct.t -> (t, Asn.error) result
+    val decode_der : string -> (t, Asn.error) result
 
     (** [encode_der request] encodes request into buffer *)
-    val encode_der : t -> Cstruct.t
+    val encode_der : t -> string
   end
 
   (** Module for encoding and decoding OCSP responses. *)
@@ -1171,7 +1171,7 @@ module OCSP : sig
 
     (** type for ResponderID *)
     type responder_id = [
-      | `ByKey of Cstruct.t
+      | `ByKey of string
       | `ByName of Distinguished_name.t
     ]
 
@@ -1220,10 +1220,10 @@ module OCSP : sig
     val responses : t -> (single_response list, [> `Msg of string ]) result
 
     (** [decode_der buffer] decodes response in buffer *)
-    val decode_der : Cstruct.t -> (t, Asn.error) result
+    val decode_der : string -> (t, Asn.error) result
 
     (** [encode_der request] encodes response into buffer *)
-    val encode_der : t -> Cstruct.t
+    val encode_der : t -> string
 
     (** [validate response key] validates the signature of [response]
         with the pulic [key]. *)
