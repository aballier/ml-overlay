diff --git code/src/equeue-tcl/tclqueue.c code/src/equeue-tcl/tclqueue.c
index 5b89e886..5f8b9748 100644
--- code/src/equeue-tcl/tclqueue.c
+++ code/src/equeue-tcl/tclqueue.c
@@ -45,7 +45,7 @@ value caml_Tcl_CreateFileHandler(value callback_fn,
     int m, tcl_m;
     CAMLparam3(callback_fn, file_descriptor, mask);
 
-    h = (filehandler *) (stat_alloc(sizeof(filehandler)));
+    h = (filehandler *) (caml_stat_alloc(sizeof(filehandler)));
     /* This must be a malloc'ed data block. */
 
     register_global_root(&(h->callback_fn));
@@ -101,7 +101,7 @@ value caml_Tcl_CreateTimerHandler(value callback_fn,
     timerhandler *h;
     CAMLparam2(callback_fn, milliseconds);
 
-    h = (timerhandler *) (stat_alloc(sizeof(timerhandler)));
+    h = (timerhandler *) (caml_stat_alloc(sizeof(timerhandler)));
     /* This must be a malloc'ed data block. */
 
     register_global_root(&(h->callback_fn));
diff --git code/src/equeue/Makefile code/src/equeue/Makefile
index 8627abe3..e447750a 100644
--- code/src/equeue/Makefile
+++ code/src/equeue/Makefile
@@ -21,6 +21,7 @@ DOBJECTS = equeue.mli unixqueue.mli unixqueue_pollset.mli \
 
 INCLUDES += $(INC_NETSYS)
 INCLUDES += $(INC_NETSTRING)
+REQUIRES += camlp-streams
 
 OCAMLC_OPTIONS += $(STRING_OPTS)
 OCAMLOPT_OPTIONS += $(STRING_OPTS)
diff --git code/src/equeue/unixqueue_pollset.ml code/src/equeue/unixqueue_pollset.ml
index 691493ff..d6605cfa 100644
--- code/src/equeue/unixqueue_pollset.ml
+++ code/src/equeue/unixqueue_pollset.ml
@@ -16,7 +16,7 @@ open Printf
 
 module Float = struct
   type t = float
-(*  let compare = ( Pervasives.compare : float -> float -> int ) *)
+(*  let compare = ( Stdlib.compare : float -> float -> int ) *)
   let compare (x:float) y =
     if x < y then (-1) else if x = y then 0 else 1
       (* does not work for non-normal numbers but we don't care *)
diff --git code/src/equeue/unixqueue_select.ml code/src/equeue/unixqueue_select.ml
index ca557357..eb6a7f7a 100644
--- code/src/equeue/unixqueue_select.ml
+++ code/src/equeue/unixqueue_select.ml
@@ -35,7 +35,7 @@ end
 module Fdescr = struct
   type t = Unix.file_descr
 
-  let compare (a:t) (b:t) = Pervasives.compare a b
+  let compare (a:t) (b:t) = Stdlib.compare a b
 
 end;;
 
@@ -59,7 +59,7 @@ module RID = struct
   type t = operation
 
   (* let compare (rid1:t) (rid2:t) =
-        Pervasives.compare rid1 rid2
+        Stdlib.compare rid1 rid2
    *)
 
   let equal (rid1:t) (rid2:t) =
diff --git code/src/equeue/unixqueue_util.ml code/src/equeue/unixqueue_util.ml
index 42d2f0b7..be27e200 100644
--- code/src/equeue/unixqueue_util.ml
+++ code/src/equeue/unixqueue_util.ml
@@ -179,7 +179,7 @@ let string_of_event ev =
 let fd_cmp =
   match Sys.os_type with
     | "Win32" ->
-	Pervasives.compare
+	Stdlib.compare
     | _ ->
 	(fun (fd1:Unix.file_descr) fd2 ->
 	   (Obj.magic fd1 : int) - (Obj.magic fd2 : int)
diff --git code/src/equeue/uq_engines.ml code/src/equeue/uq_engines.ml
index 819ba82a..42eac3c6 100644
--- code/src/equeue/uq_engines.ml
+++ code/src/equeue/uq_engines.ml
@@ -121,7 +121,7 @@ module IntSet =
   Set.Make
     (struct
        type t = int
-       let compare (x:t) (y:t) = Pervasives.compare x y
+       let compare (x:t) (y:t) = Stdlib.compare x y
      end
     )
 
diff --git code/src/netcgi2-apache/apache.c code/src/netcgi2-apache/apache.c
index 5e21c458..aa784e44 100644
--- code/src/netcgi2-apache/apache.c
+++ code/src/netcgi2-apache/apache.c
@@ -78,7 +78,7 @@ netcgi2_apache_table_get (value tv, value str)
   table *t = Table_val (tv);
   const char *res = apr_table_get(t, String_val (str));
   if (res)
-    CAMLreturn (copy_string (res));
+    CAMLreturn (caml_copy_string (res));
   else
     raise_not_found ();
 }
@@ -89,7 +89,7 @@ netcgi2_apache_table_get_loop(void *res, const char *key, const char *val)
   CAMLparam0();
   CAMLlocal1(cons); /* head cell of new list */
   cons = alloc(2, 0); /* :: */
-  Store_field(cons, 0, copy_string(val)); /* value :: */
+  Store_field(cons, 0, caml_copy_string(val)); /* value :: */
   Store_field(cons, 1, *((value *) res)); /* :: previous list */
   *((value *) res) = cons;
   CAMLreturn(1);
@@ -117,8 +117,8 @@ netcgi2_apache_table_fields_loop(void *res, const char *key, const char *val)
   CAMLparam0();
   CAMLlocal2(cons, pair);
   pair = alloc_tuple(2); /* (,) */
-  Store_field(pair, 0, copy_string(key));
-  Store_field(pair, 1, copy_string(val));
+  Store_field(pair, 0, caml_copy_string(key));
+  Store_field(pair, 1, caml_copy_string(val));
 /*   fprintf(stderr, "(%s, %s)\n", key, val); /\* DEBUG *\/ */
   cons = alloc(2, 0); /* :: */
   Store_field(cons, 0, pair); /* pair :: */
@@ -176,7 +176,7 @@ netcgi2_apache_server_hostname (value sv)
   CAMLparam1(sv);
   server_rec *s = Server_rec_val(sv);
   if (s->server_hostname)
-    CAMLreturn(copy_string(s->server_hostname));
+    CAMLreturn(caml_copy_string(s->server_hostname));
   else
     raise_not_found ();
 }
@@ -187,7 +187,7 @@ netcgi2_apache_server_admin(value sv)
   CAMLparam1(sv);
   server_rec *s = Server_rec_val(sv);
   if (s->server_admin)
-    CAMLreturn(copy_string(s->server_admin));
+    CAMLreturn(caml_copy_string(s->server_admin));
   else
     raise_not_found();
 }
@@ -209,7 +209,7 @@ netcgi2_apache_connection_ ## suffix (value cv)        \
   CAMLparam1 (cv);                              \
   conn_rec *c = Conn_rec_val (cv);              \
   if (c->field)                                 \
-    CAMLreturn (copy_string (c->field));        \
+    CAMLreturn (caml_copy_string (c->field));        \
   else                                          \
     raise_not_found ();                         \
 }
@@ -289,7 +289,7 @@ netcgi2_apache_request_the_request (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->the_request)
-    CAMLreturn (copy_string (r->the_request));
+    CAMLreturn (caml_copy_string (r->the_request));
   else
     raise_not_found ();
 }
@@ -316,7 +316,7 @@ netcgi2_apache_request_protocol (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->protocol)
-    CAMLreturn (copy_string (r->protocol));
+    CAMLreturn (caml_copy_string (r->protocol));
   else
     raise_not_found ();
 }
@@ -335,7 +335,7 @@ netcgi2_apache_request_hostname (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->hostname)
-    CAMLreturn (copy_string (r->hostname));
+    CAMLreturn (caml_copy_string (r->hostname));
   else
     raise_not_found ();
 }
@@ -354,7 +354,7 @@ netcgi2_apache_request_status_line (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->status_line)
-    CAMLreturn (copy_string (r->status_line));
+    CAMLreturn (caml_copy_string (r->status_line));
   else
     raise_not_found ();
 }
@@ -390,7 +390,7 @@ netcgi2_apache_request_method (value rv)
 {
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
-  CAMLreturn (copy_string (r->method));
+  CAMLreturn (caml_copy_string (r->method));
 }
 
 CAMLprim value
@@ -447,7 +447,7 @@ netcgi2_apache_request_content_type (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->content_type)
-    CAMLreturn (copy_string (r->content_type));
+    CAMLreturn (caml_copy_string (r->content_type));
   else
     raise_not_found ();
 }
@@ -468,10 +468,10 @@ netcgi2_apache_request_user (value rv)
   request_rec *r = Request_rec_val (rv);
 #if APACHE2
   if (r->user)
-    CAMLreturn (copy_string (r->user));
+    CAMLreturn (caml_copy_string (r->user));
 #else
   if (r->connection->user)
-    CAMLreturn (copy_string (r->connection->user));
+    CAMLreturn (caml_copy_string (r->connection->user));
 #endif
   else
     raise_not_found ();
@@ -483,7 +483,7 @@ netcgi2_apache_request_uri (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->uri)
-    CAMLreturn (copy_string (r->uri));
+    CAMLreturn (caml_copy_string (r->uri));
   else
     raise_not_found ();
 }
@@ -513,7 +513,7 @@ netcgi2_apache_request_filename (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->filename)
-    CAMLreturn (copy_string (r->filename));
+    CAMLreturn (caml_copy_string (r->filename));
   else
     raise_not_found ();
 }
@@ -533,7 +533,7 @@ netcgi2_apache_request_path_info (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->path_info)
-    CAMLreturn (copy_string (r->path_info));
+    CAMLreturn (caml_copy_string (r->path_info));
   else
     raise_not_found ();
 }
@@ -553,7 +553,7 @@ netcgi2_apache_request_args (value rv)
   CAMLparam1 (rv);
   request_rec *r = Request_rec_val (rv);
   if (r->args)
-    CAMLreturn (copy_string (r->args));
+    CAMLreturn (caml_copy_string (r->args));
   else
     raise_not_found ();
 }
@@ -604,7 +604,7 @@ CAMLprim value netcgi2_apache_request_finfo (value rv)
 	copy_double ((double) apr_time_sec (r->finfo.ctime)) :
 	copy_double (0.);
 
-      sb = alloc_small (12, 0);
+      sb = caml_alloc_small (12, 0);
       Field (sb, 0) = Val_int (r->finfo.device);
       Field (sb, 1) = Val_int (r->finfo.inode);
       Field (sb, 2) =
@@ -636,7 +636,7 @@ else
       mtime = copy_double ((double) r->finfo.st_mtime);
       ctime = copy_double ((double) r->finfo.st_ctime);
 
-      sb = alloc_small (12, 0);
+      sb = caml_alloc_small (12, 0);
       Field (sb, 0) = Val_int (r->finfo.st_dev);
       Field (sb, 1) = Val_int (r->finfo.st_ino);
       Field (sb, 2) =
@@ -755,10 +755,10 @@ CAMLprim value netcgi2_apache_auth_type(value rv)
   request_rec *r = Request_rec_val(rv);
 #if APACHE2
   if (r->ap_auth_type)
-    CAMLreturn(copy_string(r->ap_auth_type));
+    CAMLreturn(caml_copy_string(r->ap_auth_type));
 #else
   if (r->connection->ap_auth_type)
-    CAMLreturn(copy_string(r->connection->ap_auth_type));
+    CAMLreturn(caml_copy_string(r->connection->ap_auth_type));
 #endif
   else
     raise_not_found();
@@ -834,7 +834,7 @@ netcgi2_apache_request_print_char (value rv, value cv)
   request_rec *r = Request_rec_val (rv);
   int c = Int_val (cv);
   if (ap_rputc (c, r) == EOF)
-    raise_sys_error(copy_string("Netcgi_mod#out_channel#output_char"));
+    raise_sys_error(caml_copy_string("Netcgi_mod#out_channel#output_char"));
   CAMLreturn (Val_unit);
 }
 
diff --git code/src/netcgi2-apache/handler.c code/src/netcgi2-apache/handler.c
index cc0901c1..b4810e44 100644
--- code/src/netcgi2-apache/handler.c
+++ code/src/netcgi2-apache/handler.c
@@ -275,7 +275,7 @@ static const char *                                                    \
 name (cmd_parms *parms, void *dummy, const char *strarg)               \
 {                                                                      \
   static value *f = NULL;                                              \
-  value arg = copy_string (strarg);                                    \
+  value arg = caml_copy_string (strarg);                                    \
   value exn;                                                           \
   if (f == NULL) f = caml_named_value("netcgi2_apache_" #name);        \
   exn = callback_exn(*f, arg);                                         \
@@ -297,7 +297,7 @@ cmd_translate_handler (cmd_parms *parms, void *dummy, const char *name)
   value *sconfig = (value *)
     ap_get_module_config (parms->server->module_config, &netcgi_module);
   static value *f = NULL;
-  value arg = copy_string(name);
+  value arg = caml_copy_string(name);
   value exn;
   if (f == NULL) f = caml_named_value("netcgi2_apache_cmd_translate_handler");
   exn = callback2_exn(*f, *sconfig, arg);
@@ -313,7 +313,7 @@ static const char *						\
 name (cmd_parms *parms, void *dconfig, const char *name)	\
 {								\
   value *f = NULL;						\
-  value arg = copy_string(name);				\
+  value arg = caml_copy_string(name);				\
   value exn;							\
   if (f == NULL) f = caml_named_value("netcgi2_apache_" #name);	\
   exn = callback2_exn(*f, *(value *) dconfig, arg);		\
diff --git code/src/netcgi2-apache/wrappers.c code/src/netcgi2-apache/wrappers.c
index 6df24836..d85b0038 100644
--- code/src/netcgi2-apache/wrappers.c
+++ code/src/netcgi2-apache/wrappers.c
@@ -40,8 +40,8 @@ Val_optstring (const char *str)
     {
       CAMLparam0();
       CAMLlocal2(rv, s);
-      s = copy_string (str);
-      rv = alloc_small (1, 0);
+      s = caml_copy_string (str);
+      rv = caml_alloc_small (1, 0);
       Field(rv, 0) = s;
       CAMLreturn(rv);
     }
diff --git code/src/netgss-system/gssapi.c code/src/netgss-system/gssapi.c
index 62be2a15..3fb1ce9f 100644
--- code/src/netgss-system/gssapi.c
+++ code/src/netgss-system/gssapi.c
@@ -59,7 +59,7 @@ static void netgss_free_buffer_contents(long tag, gss_buffer_t buf) {
                 fprintf(stderr, "Netgss: error from gss_release_buffer\n");
         } else {
             if (tag == 1) {
-                stat_free(buf->value);
+                caml_stat_free(buf->value);
             }
         }
     }
@@ -71,13 +71,13 @@ static void netgss_free_buffer_contents(long tag, gss_buffer_t buf) {
 static void netgss_free_buffer(long tag, gss_buffer_t buf) {
     netgss_free_buffer_contents(tag, buf);
     /* The descriptor is always allocated by us: */
-    stat_free(buf);
+    caml_stat_free(buf);
 }
 
 
 static gss_buffer_t netgss_alloc_buffer(void) {
     gss_buffer_t buf;
-    buf = (gss_buffer_t) stat_alloc(sizeof(gss_buffer_desc));
+    buf = (gss_buffer_t) caml_stat_alloc(sizeof(gss_buffer_desc));
     buf->value = NULL;
     buf->length = 0;
     return buf;
@@ -105,10 +105,10 @@ CAMLprim value netgss_buffer_of_string(value s, value pos, value len) {
     gss_buffer_t buf;
     if (Long_val(len) < 0 || Long_val(pos) < 0 ||
         Long_val(pos) > caml_string_length(s) - Long_val(len))
-        invalid_argument("buffer_of_string");
+        caml_invalid_argument("buffer_of_string");
     buf = netgss_alloc_buffer();
     buf->length = Long_val(len);
-    buf->value = stat_alloc(buf->length);
+    buf->value = caml_stat_alloc(buf->length);
     memcpy(buf->value, String_val(s) + Long_val(pos), buf->length);
     return twrap_gss_buffer_t(1, buf);
 }
@@ -155,14 +155,14 @@ static void netgss_free_oid(long tag, gss_OID buf) {
     if (tag == 0 || buf == GSS_C_NO_OID) {
         /* OIDs from the provider are to be considered as read-only */
     } else {
-        stat_free(buf->elements);
-        stat_free(buf);
+        caml_stat_free(buf->elements);
+        caml_stat_free(buf);
     }
 }
 
 
 static gss_OID netgss_alloc_oid(void) {
-    return (gss_OID) stat_alloc(sizeof(gss_OID_desc));
+    return (gss_OID) caml_stat_alloc(sizeof(gss_OID_desc));
 }
 
 
@@ -173,7 +173,7 @@ static gss_OID netgss_copy_oid(gss_OID buf) {
     } else {
         out = netgss_alloc_oid();
         out->length = buf->length;
-        out->elements = stat_alloc(buf->length);
+        out->elements = caml_stat_alloc(buf->length);
         memcpy(out->elements, buf->elements, buf->length);
     }
     return out;
@@ -184,7 +184,7 @@ CAMLprim value netgss_oid_of_string(value s) {
     gss_OID buf;
     buf = netgss_alloc_oid();
     buf->length = caml_string_length(s);
-    buf->elements = stat_alloc(buf->length);
+    buf->elements = caml_stat_alloc(buf->length);
     memcpy(buf->elements, String_val(s), buf->length);
     return twrap_gss_OID(1, buf);
 }
@@ -213,14 +213,14 @@ static void netgss_free_oid_set(long tag, gss_OID_set set) {
         for (k=0; k < set->count; k++) {
             netgss_free_oid(1, set->elements+k);
         }
-        stat_free(set->elements);
-        stat_free(set);
+        caml_stat_free(set->elements);
+        caml_stat_free(set);
     }
 }
 
 
 static gss_OID_set netgss_alloc_oid_set(void) {
-    return (gss_OID_set) stat_alloc(sizeof(gss_OID_set_desc));
+    return (gss_OID_set) caml_stat_alloc(sizeof(gss_OID_set_desc));
 }
 
 
@@ -254,7 +254,7 @@ CAMLprim value netgss_oid_set_of_array(value varg) {
         return twrap_gss_OID_set(1, GSS_C_NO_OID_SET);
     set = netgss_alloc_oid_set();
     set->count = Wosize_val(varg);
-    set->elements = stat_alloc(sizeof(gss_OID) * set->count);
+    set->elements = caml_stat_alloc(sizeof(gss_OID) * set->count);
     for (k=0; k<set->count; k++) {
         v1 = Field(varg, k);
         buf = unwrap_gss_OID(v1);
@@ -308,17 +308,17 @@ CAMLprim value netgss_map_cb(value iaddrty, value iaddr, value aaddrty,
     aaddr_len = caml_string_length(aaddr);
     data_len = caml_string_length(data);
     cb = (gss_channel_bindings_t)
-            stat_alloc(sizeof(struct gss_channel_bindings_struct));
+            caml_stat_alloc(sizeof(struct gss_channel_bindings_struct));
     cb->initiator_addrtype = Int_val(iaddrty);
     cb->initiator_address.length = iaddr_len;
-    cb->initiator_address.value = stat_alloc(iaddr_len);
+    cb->initiator_address.value = caml_stat_alloc(iaddr_len);
     memcpy(cb->initiator_address.value, String_val(iaddr), iaddr_len);
     cb->acceptor_addrtype = Int_val(aaddrty);
     cb->acceptor_address.length = aaddr_len;
-    cb->acceptor_address.value = stat_alloc(aaddr_len);
+    cb->acceptor_address.value = caml_stat_alloc(aaddr_len);
     memcpy(cb->acceptor_address.value, String_val(aaddr), aaddr_len);
     cb->application_data.length = data_len;
-    cb->application_data.value = stat_alloc(data_len);
+    cb->application_data.value = caml_stat_alloc(data_len);
     memcpy(cb->application_data.value, String_val(data), data_len);
     return wrap_gss_channel_bindings_t(cb);
 }
@@ -364,8 +364,8 @@ CAMLprim value netgss_no_oid_set(value dummy) {
 
 static void netgss_free_cb(gss_channel_bindings_t x) {
     if (x != NULL) {
-        stat_free(x->initiator_address.value);
-        stat_free(x->acceptor_address.value);
-        stat_free(x->application_data.value);
+        caml_stat_free(x->initiator_address.value);
+        caml_stat_free(x->acceptor_address.value);
+        caml_stat_free(x->application_data.value);
     }
 }
diff --git code/src/nethttpd/nethttpd_services.ml code/src/nethttpd/nethttpd_services.ml
index 9a338b25..bf274969 100644
--- code/src/nethttpd/nethttpd_services.ml
+++ code/src/nethttpd/nethttpd_services.ml
@@ -107,10 +107,10 @@ object(self)
       try
 	let req_name = env # input_header_field "Host" in
 	let (req_host, req_port_opt) = split_host_port req_name in
-	let req_host = String.lowercase req_host in
+	let req_host = String.lowercase_ascii req_host in
 	let req_port = match req_port_opt with Some p -> p | None -> 80 in  (* CHECK *)
 	List.find
-	  (fun (n,p) -> (n = "*" || String.lowercase n = req_host) && 
+	  (fun (n,p) -> (n = "*" || String.lowercase_ascii n = req_host) && 
 	                (p = 0 || p = req_port))
 	  host.server_names
       with
diff --git code/src/netplex/Makefile code/src/netplex/Makefile
index 1c1526e4..236b5db3 100644
--- code/src/netplex/Makefile
+++ code/src/netplex/Makefile
@@ -28,6 +28,8 @@ PP_OPTIONS = -pp "$(CPPO) $(PP_BYTES) $(PP_DEPRECATED)"
 
 INCLUDES += $(INC_EQUEUE) $(INC_RPC) $(INC_NETSTRING) $(INC_NETSYS)
 
+REQUIRES += camlp-streams
+
 ALL_EXTRA = netplex-admin$(EXEC_SUFFIX) netplex-packlist 
 
 PACKLIST = netplex-packlist
@@ -36,7 +38,7 @@ include $(TOP_DIR)/Makefile.rules
 
 netplex-admin$(EXEC_SUFFIX): netplex.cma netplex_admin.cmo
 	$(OCAMLC) -o netplex-admin -custom \
-	        -package "bytes unix bigarray str" -linkpkg \
+	        -package "bytes unix str" -linkpkg \
 		netsys_oothr.cma netsys.cma netstring.cma equeue.cma \
 		rpc.cma netplex.cma netplex_admin.cmo
 
diff --git code/src/netplex/netplex_kit.ml code/src/netplex/netplex_kit.ml
index 87d661fb..8cfd2d19 100644
--- code/src/netplex/netplex_kit.ml
+++ code/src/netplex/netplex_kit.ml
@@ -89,7 +89,7 @@ end
 
 module PTYPE = struct
   type t = parallelization_type
-  let compare (x:t) (y:t) = Pervasives.compare x y
+  let compare (x:t) (y:t) = Stdlib.compare x y
 end
 
 module PSet = Set.Make(PTYPE)
diff --git code/src/netplex/netplex_workload.ml code/src/netplex/netplex_workload.ml
index 1484b922..8d046849 100644
--- code/src/netplex/netplex_workload.ml
+++ code/src/netplex/netplex_workload.ml
@@ -119,7 +119,7 @@ end
 
 module ContId = struct
   type t = container_id
-  let (compare : t -> t -> int) = Pervasives.compare
+  let (compare : t -> t -> int) = Stdlib.compare
 end
 
 
diff --git code/src/netshm/netshm.ml code/src/netshm/netshm.ml
index 974e5ee8..9d586229 100644
--- code/src/netshm/netshm.ml
+++ code/src/netshm/netshm.ml
@@ -133,7 +133,7 @@ open Printf
 
 module Int = struct
   type t = int
-  let compare = (Pervasives.compare : int -> int -> int)
+  let compare = (Stdlib.compare : int -> int -> int)
 end
 
 module IntMap = Map.Make(Int)
diff --git code/src/netstring/Makefile code/src/netstring/Makefile
index 08b81e25..09c488ed 100644
--- code/src/netstring/Makefile
+++ code/src/netstring/Makefile
@@ -28,7 +28,7 @@ OBJECTS  = netconst.cmo netstring_str.cmo netbuffer.cmo netunichar.cmo \
 
 PKGNAME  = netstring
 
-REQUIRES += $(REGEXP_PROVIDER_MAKE) bigarray
+REQUIRES += $(REGEXP_PROVIDER_MAKE) camlp-streams
 INCLUDES += $(INC_NETSYS)
 INCLUDES += -I ../netstring-pcre
 
diff --git code/src/netstring/netaccel_c.c code/src/netstring/netaccel_c.c
index b7c4ffdc..dbb732d8 100644
--- code/src/netstring/netaccel_c.c
+++ code/src/netstring/netaccel_c.c
@@ -25,7 +25,7 @@ value netstring_int_blit_ml (value src, value srcpos,
 	srcpos_c+len_c > Wosize_val(src) ||
 	destpos_c < 0 ||
 	destpos_c+len_c > Wosize_val(dest))
-	invalid_argument("Netaccel.int_blit");
+	caml_invalid_argument("Netaccel.int_blit");
     
     if (src != dest || destpos_c <= srcpos_c) {
 	for (i=0; i<len_c; i++) {
@@ -59,7 +59,7 @@ value netstring_int_series_ml (value src, value srcpos,
 	srcpos_c+len_c > Wosize_val(src) ||
 	destpos_c < 0 ||
 	destpos_c+len_c > Wosize_val(dest))
-	invalid_argument("Netaccel.int_series");
+	caml_invalid_argument("Netaccel.int_series");
 
     s = n_c;
     for (i=0; i<len_c; i++) {
@@ -99,9 +99,9 @@ value netstring_read_iso88591_ml (value maxcode, value enc,
     slice_char_len = Wosize_val(slice_char);
 
     if (slice_char_len != Wosize_val(slice_blen)) 
-	invalid_argument("Netaccel.read_iso88591");
-    if (p_in_c < 0 || l_in_c < 0 || p_in_c + l_in_c > string_length(s_in)) 
-	invalid_argument("Netaccel.read_iso88591");
+	caml_invalid_argument("Netaccel.read_iso88591");
+    if (p_in_c < 0 || l_in_c < 0 || p_in_c + l_in_c > caml_string_length(s_in)) 
+	caml_invalid_argument("Netaccel.read_iso88591");
 
     m = l_in_c;
     if (slice_char_len < m) m = slice_char_len;
@@ -110,11 +110,11 @@ value netstring_read_iso88591_ml (value maxcode, value enc,
 	ch = Byte_u(s_in, p_in_c+k);
 	if (ch > maxcode_c) {
 	    Field(slice_char, k) = Val_long(-1);
-	    r = alloc_tuple(3);
+	    r = caml_alloc_tuple(3);
 	    Store_field(r, 0, Val_long(k));
 	    Store_field(r, 1, Val_long(k));
 	    Store_field(r, 2, enc);
-	    raise_with_arg(*caml_named_value("Netconversion.Malformed_code_read"),
+	    caml_raise_with_arg(*caml_named_value("Netconversion.Malformed_code_read"),
 			   r);
 	};
 	Field(slice_char, k) = Val_int((signed int) ch);
@@ -124,7 +124,7 @@ value netstring_read_iso88591_ml (value maxcode, value enc,
 	Field(slice_char, m) = Val_long(-1);
     };
 
-    r = alloc_tuple(3);
+    r = caml_alloc_tuple(3);
     Store_field(r, 0, Val_long(m));
     Store_field(r, 1, Val_long(m));
     Store_field(r, 2, enc);
@@ -164,9 +164,9 @@ value netstring_read_utf8_ml (value is_java,
     slice_char_len = Wosize_val(slice_char);
 
     if (slice_char_len != Wosize_val(slice_blen)) 
-	invalid_argument("Netaccel.read_utf8");
-    if (p_in_c < 0 || l_in_c < 0 || p_in_c + l_in_c > string_length(s_in)) 
-	invalid_argument("Netaccel.read_utf8");
+	caml_invalid_argument("Netaccel.read_utf8");
+    if (p_in_c < 0 || l_in_c < 0 || p_in_c + l_in_c > caml_string_length(s_in)) 
+	caml_invalid_argument("Netaccel.read_utf8");
 
     p = p_in_c;
     p_max = p_in_c + l_in_c;
@@ -249,20 +249,20 @@ value netstring_read_utf8_ml (value is_java,
 	Field(slice_char, n_ret) = Val_long(-1);
     }
 
-    r = alloc_tuple(3);
+    r = caml_alloc_tuple(3);
     Store_field(r, 0, Val_long(n_ret));
     Store_field(r, 1, Val_long(p-p_in_c));
-    Store_field(r, 2, hash_variant("Enc_utf8"));
+    Store_field(r, 2, caml_hash_variant("Enc_utf8"));
 
     CAMLreturn(r);
 
  malformed_code:
     Field(slice_char, n) = Val_long(-1);
-    r = alloc_tuple(3);
+    r = caml_alloc_tuple(3);
     Store_field(r, 0, Val_long(n));
     Store_field(r, 1, Val_long(p-p_in_c));
-    Store_field(r, 2, hash_variant("Enc_utf8"));
-    raise_with_arg(*caml_named_value("Netconversion.Malformed_code_read"),
+    Store_field(r, 2, caml_hash_variant("Enc_utf8"));
+    caml_raise_with_arg(*caml_named_value("Netconversion.Malformed_code_read"),
 		   r);
 
     /* Cannot reach this point! */
diff --git code/src/netstring/netchannels.ml code/src/netstring/netchannels.ml
index e916b70d..b9cfa011 100644
--- code/src/netstring/netchannels.ml
+++ code/src/netstring/netchannels.ml
@@ -213,45 +213,45 @@ object (self)
     if closed then self # complain_closed();
     try
       if len=0 then raise Sys_blocked_io;
-      let n = Pervasives.input ch buf pos len in
+      let n = Stdlib.input ch buf pos len in
       if n=0 then raise End_of_file else n
     with
 	Sys_blocked_io -> 0
 
   method really_input buf pos len = 
     if closed then self # complain_closed();
-    Pervasives.really_input ch buf pos len 
+    Stdlib.really_input ch buf pos len 
 
   method really_input_string len = 
     if closed then self # complain_closed();
     #ifdef HAVE_BYTES
-      Pervasives.really_input_string ch len 
+      Stdlib.really_input_string ch len 
     #else
       let buf = String.create len in
-      Pervasives.really_input ch buf 0 len;
+      Stdlib.really_input ch buf 0 len;
       buf
     #endif
 
   method input_char () =
     if closed then self # complain_closed();
-    Pervasives.input_char ch 
+    Stdlib.input_char ch 
 
   method input_line () =
     if closed then self # complain_closed();
-    Pervasives.input_line ch 
+    Stdlib.input_line ch 
 
   method input_byte () =
     if closed then self # complain_closed();
-    Pervasives.input_byte ch 
+    Stdlib.input_byte ch 
 
   method close_in () =
     if not closed then (
-      Pervasives.close_in ch; closed <- true; onclose()
+      Stdlib.close_in ch; closed <- true; onclose()
     )
 
   method pos_in =
     if closed then self # complain_closed();
-    Pervasives.pos_in ch 
+    Stdlib.pos_in ch 
 end
 ;;
 
@@ -999,17 +999,17 @@ object (self)
 
   method output buf pos len =
     if closed then self # complain_closed();
-    (* Pervasives.output does not support non-blocking I/O directly.
+    (* Stdlib.output does not support non-blocking I/O directly.
      * Work around it:
      *)
-    let p0 = Pervasives.pos_out ch in
+    let p0 = Stdlib.pos_out ch in
     try 
-      Pervasives.output ch buf pos len;
+      Stdlib.output ch buf pos len;
       errflag := false;
       len
     with
       | Sys_blocked_io ->
-	  let p1 = Pervasives.pos_out ch in
+	  let p1 = Stdlib.pos_out ch in
 	  errflag := false;
 	  p1 - p0
       | error ->
@@ -1018,35 +1018,35 @@ object (self)
 
   method really_output buf pos len =
     if closed then self # complain_closed();
-    monitored (Pervasives.output ch buf pos) len
+    monitored (Stdlib.output ch buf pos) len
 
   method really_output_string buf pos len =
     if closed then self # complain_closed();
     #ifdef HAVE_BYTES
-      monitored (Pervasives.output_substring ch buf pos) len
+      monitored (Stdlib.output_substring ch buf pos) len
     #else
-      monitored (Pervasives.output ch buf pos) len
+      monitored (Stdlib.output ch buf pos) len
     #endif
 
   method output_char c =
     if closed then self # complain_closed();
-    monitored (Pervasives.output_char ch) c
+    monitored (Stdlib.output_char ch) c
 
   method output_string s =
     if closed then self # complain_closed();
-    monitored (Pervasives.output_string ch) s
+    monitored (Stdlib.output_string ch) s
 
   method output_bytes s =
     if closed then self # complain_closed();
     #ifdef HAVE_BYTES
-      monitored (Pervasives.output_bytes ch) s
+      monitored (Stdlib.output_bytes ch) s
     #else
-      monitored (Pervasives.output_string ch) s
+      monitored (Stdlib.output_string ch) s
     #endif
 
   method output_byte b =
     if closed then self # complain_closed();
-    monitored (Pervasives.output_byte ch) b
+    monitored (Stdlib.output_byte ch) b
 
   method output_buffer b =
     if closed then self # complain_closed();
@@ -1061,7 +1061,7 @@ object (self)
 
   method flush() =
     if closed then self # complain_closed();
-    monitored Pervasives.flush ch
+    monitored Stdlib.flush ch
 
   method close_out() =
     if not closed then (
@@ -1071,9 +1071,9 @@ object (self)
 	     exception handler
 	   *)
 	  if !errflag then
-	    Pervasives.close_out_noerr ch
+	    Stdlib.close_out_noerr ch
 	  else
-	    Pervasives.close_out ch; 
+	    Stdlib.close_out ch; 
 	  closed <- true; 
 	with
 	  | error ->
@@ -1082,7 +1082,7 @@ object (self)
 		"Netchannels.output_channel: \
                    Suppressed error in close_out: %s - backtrace: %s"
 		(Netexn.to_string error) bt;
-	      Pervasives.close_out_noerr ch;
+	      Stdlib.close_out_noerr ch;
 	      closed <- true; 
       );
       onclose()
@@ -1090,7 +1090,7 @@ object (self)
 
   method pos_out = 
     if closed then self # complain_closed();
-    Pervasives.pos_out ch
+    Stdlib.pos_out ch
 
 end
 ;;
@@ -1844,7 +1844,7 @@ object (self)
                   Suppressed error in close_out: %s - backtrace: %s"
 		(Netexn.to_string error) bt;
       );
-      Pervasives.close_in transch_in;
+      Stdlib.close_in transch_in;
       trans # close_out();      (* closes transch_out *)
       out # close_out();
       closed := true
@@ -1859,7 +1859,7 @@ object (self)
     need_clear <- true;
     let len = trans # pos_out in
     trans # flush();
-    Pervasives.seek_in transch_in 0;
+    Stdlib.seek_in transch_in 0;
     let trans' = new input_channel transch_in in
     ( try 
         out # output_channel ~len trans';
@@ -1876,7 +1876,7 @@ object (self)
   method private clear() =
     (* delete the contents of the file *)
     (* First empty the file and reset the output channel: *)
-    Pervasives.seek_out transch_out 0;
+    Stdlib.seek_out transch_out 0;
     Unix.ftruncate (Unix.descr_of_out_channel transch_out) 0;
     (* Renew the input channel. We create a new channel to avoid problems
      * with the internal buffer of the channel.
diff --git code/src/netstring/nethtml.ml code/src/netstring/nethtml.ml
index b79e48bf..b3882eae 100644
--- code/src/netstring/nethtml.ml
+++ code/src/netstring/nethtml.ml
@@ -283,7 +283,7 @@ let hashtbl_from_alist l =
 
 module S = struct
   type t = string
-  let compare = (Pervasives.compare : string -> string -> int)
+  let compare = (Stdlib.compare : string -> string -> int)
 end
 
 module Strset = Set.Make(S);;
diff --git code/src/netstring/nethttp.ml code/src/netstring/nethttp.ml
index d3417a8b..e80ccc78 100644
--- code/src/netstring/nethttp.ml
+++ code/src/netstring/nethttp.ml
@@ -1009,7 +1009,7 @@ module Header = struct
       snd
       (List.stable_sort
 	 (fun (q1, tok_param1) (q2, tok_param2) ->
-	    Pervasives.compare q2 q1)
+	    Stdlib.compare q2 q1)
 	 (List.filter
 	    (fun (q, tok_param) ->
 	       q > 0.0)
diff --git code/src/netstring/netmime.ml code/src/netstring/netmime.ml
index 70235f86..3f95f302 100644
--- code/src/netstring/netmime.ml
+++ code/src/netstring/netmime.ml
@@ -71,7 +71,7 @@ module CI : sig  (* case-insensitive strings *)
 end = struct
   type t = string
   let compare (a_ci:t) (b_ci:t) =
-    Pervasives.compare a_ci b_ci
+    Stdlib.compare a_ci b_ci
   let make s = STRING_LOWERCASE s
 end
 
diff --git code/src/netsys/META.in code/src/netsys/META.in
index d0813481..f18ea56f 100644
--- code/src/netsys/META.in
+++ code/src/netsys/META.in
@@ -1,5 +1,5 @@
 description = "Ocamlnet - OS-specific functions"
-requires = "bytes,unix,bigarray"
+requires = "bytes,unix"
 version = "@VERSION@"
 archive(byte) = "netsys_oothr.cma netsys.cma"
 archive(native) = "netsys_oothr.cmxa netsys.cmxa"
diff --git code/src/netsys/netlog.ml code/src/netsys/netlog.ml
index edb237c2..7613265f 100644
--- code/src/netsys/netlog.ml
+++ code/src/netsys/netlog.ml
@@ -129,7 +129,7 @@ let channel_logger ch max_lev lev msg =
     
 
 let current_logger =
-  ref(channel_logger Pervasives.stderr `Debug)
+  ref(channel_logger Stdlib.stderr `Debug)
 
 
 let log lev msg =
diff --git code/src/netsys/netsys_c.c code/src/netsys/netsys_c.c
index 31b7f5d5..067b4289 100644
--- code/src/netsys/netsys_c.c
+++ code/src/netsys/netsys_c.c
@@ -12,13 +12,13 @@ CAMLprim value netsys_int64_of_file_descr(value fd) {
 #ifdef _WIN32
     switch (Descr_kind_val(fd)) {
     case KIND_HANDLE:
-	return copy_int64((intnat) (Handle_val(fd)));
+	return caml_copy_int64((intnat) (Handle_val(fd)));
     case KIND_SOCKET:
-	return copy_int64((intnat) (Socket_val(fd)));
+	return caml_copy_int64((intnat) (Socket_val(fd)));
     }
-    return copy_int64(0);
+    return caml_copy_int64(0);
 #else
-    return copy_int64(Long_val(fd));
+    return caml_copy_int64(Long_val(fd));
 #endif
 }
 
@@ -45,18 +45,18 @@ CAMLprim value netsys_unix_error_of_code(value n) {
     win32_maperr(e);
     e = errno;
 #endif
-    return(unix_error_of_code(e));
+    return(caml_unix_error_of_code(e));
 }
 
 CAMLprim value netsys_get_nonblock(value fd)
 {
 #ifdef _WIN32
-    invalid_argument("Netsys_posix.get_nonblcok not avaiable");
+    caml_invalid_argument("Netsys_posix.get_nonblcok not avaiable");
 #else
     int r;
 
     r = fcntl(Int_val(fd), F_GETFL, 0);
-    if (r == -1) uerror("fcntl", Nothing);
+    if (r == -1) caml_uerror("fcntl", Nothing);
 
     return Val_bool((r & O_NONBLOCK) != 0);
 #endif
@@ -67,7 +67,7 @@ CAMLprim value netsys__exit (value n) {
     _exit(Int_val(n));
     return Val_int(0);
 #else
-    invalid_argument("Netsys._exit not available");
+    caml_invalid_argument("Netsys._exit not available");
 #endif
 }
 
@@ -76,7 +76,7 @@ CAMLprim value netsys_sysconf_open_max (value unit) {
 #ifdef HAVE_SYSCONF
     return Val_long(sysconf(_SC_OPEN_MAX));
 #else
-    invalid_argument("Netsys.sysconf_open_max not available");
+    caml_invalid_argument("Netsys.sysconf_open_max not available");
 #endif
 }
 
@@ -86,10 +86,10 @@ CAMLprim value netsys_getpgid (value pid) {
     int pgid;
 
     pgid = getpgid(Int_val(pid));
-    if (pgid == -1) uerror("getpgid", Nothing);
+    if (pgid == -1) caml_uerror("getpgid", Nothing);
     return Val_int(pgid);
 #else
-    invalid_argument("Netsys.getpgid not available");
+    caml_invalid_argument("Netsys.getpgid not available");
 #endif
 }
 
@@ -99,10 +99,10 @@ CAMLprim value netsys_setpgid (value pid, value pgid) {
     int r;
 
     r = setpgid(Int_val(pid), Int_val(pgid));
-    if (r == -1) uerror("setpgid", Nothing);
+    if (r == -1) caml_uerror("setpgid", Nothing);
     return Val_int(0);
 #else
-    invalid_argument("Netsys.setpgid not available");
+    caml_invalid_argument("Netsys.setpgid not available");
 #endif
 }
 
@@ -112,10 +112,10 @@ CAMLprim value netsys_tcgetpgrp (value fd) {
     int pgid;
 
     pgid = tcgetpgrp(Int_val(fd));
-    if (pgid == -1) uerror("tcgetpgrp", Nothing);
+    if (pgid == -1) caml_uerror("tcgetpgrp", Nothing);
     return Val_int(pgid);
 #else
-    invalid_argument("Netsys.tcgetpgrp not available");
+    caml_invalid_argument("Netsys.tcgetpgrp not available");
 #endif
 }
 
@@ -125,10 +125,10 @@ CAMLprim value netsys_tcsetpgrp (value fd, value pgid) {
     int r;
     
     r = tcsetpgrp(Int_val(fd), Int_val(pgid));
-    if (r == -1) uerror("tcsetpgrp", Nothing);
+    if (r == -1) caml_uerror("tcsetpgrp", Nothing);
     return Val_int(0);
 #else
-    invalid_argument("Netsys.tcsetpgrp not available");
+    caml_invalid_argument("Netsys.tcsetpgrp not available");
 #endif
 }
 
@@ -137,10 +137,10 @@ CAMLprim value netsys_ctermid (value unit) {
 #ifdef HAVE_POSIX_TTY
     char *s;
     s = NULL;
-    return copy_string(ctermid(s));
+    return caml_copy_string(ctermid(s));
     /* ctermid is always successful; however it can return an empty string */
 #else
-    invalid_argument("Netsys.ctermid not available");
+    caml_invalid_argument("Netsys.ctermid not available");
 #endif
 }
 
@@ -150,10 +150,10 @@ CAMLprim value netsys_ttyname (value fd) {
     char *s;
 
     s = ttyname(Int_val(fd));
-    if ( s == NULL ) uerror("ttyname", Nothing);
-    return copy_string(s);
+    if ( s == NULL ) caml_uerror("ttyname", Nothing);
+    return caml_copy_string(s);
 #else
-    invalid_argument("Netsys.ttyname not available");
+    caml_invalid_argument("Netsys.ttyname not available");
 #endif
 }
 
@@ -163,10 +163,10 @@ CAMLprim value netsys_getsid (value pid) {
     int sid;
 
     sid = getsid(Int_val(pid));
-    if ( sid == -1 )  uerror("getsid", Nothing);
+    if ( sid == -1 )  caml_uerror("getsid", Nothing);
     return Val_int(sid);
 #else
-    invalid_argument("Netsys.getsid not available");
+    caml_invalid_argument("Netsys.getsid not available");
 #endif
 }
 
@@ -176,10 +176,10 @@ CAMLprim value netsys_setreuid(value ruid, value euid) {
     int r;
 
     r = setreuid(Int_val(ruid), Int_val(euid));
-    if (r == -1) uerror("setreuid", Nothing);
+    if (r == -1) caml_uerror("setreuid", Nothing);
     return Val_int(0);
 #else
-    invalid_argument("Netsys.setreuid not available");
+    caml_invalid_argument("Netsys.setreuid not available");
 #endif
 }
 
@@ -189,10 +189,10 @@ CAMLprim value netsys_setregid(value rgid, value egid) {
     int r;
 
     r = setregid(Int_val(rgid), Int_val(egid));
-    if (r == -1) uerror("setregid", Nothing);
+    if (r == -1) caml_uerror("setregid", Nothing);
     return Val_int(0);
 #else
-    invalid_argument("Netsys.setregid not available");
+    caml_invalid_argument("Netsys.setregid not available");
 #endif
 }
 
@@ -206,11 +206,11 @@ CAMLprim value netsys_initgroups(value user, value gid) {
     gid_i = Long_val(gid);
 
     e = initgroups(user_s, gid_i);
-    if (e < 0) uerror("initgroups", Nothing);
+    if (e < 0) caml_uerror("initgroups", Nothing);
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.initgroups not available");
+    caml_invalid_argument("Netsys_posix.initgroups not available");
 #endif
 }
 
@@ -220,10 +220,10 @@ CAMLprim value netsys_fsync(value fd) {
     int r;
     r = fsync(Int_val(fd));
     if (r == -1) 
-	uerror("fsync", Nothing);
+	caml_uerror("fsync", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.fsync not available");
+    caml_invalid_argument("Netsys.fsync not available");
 #endif
 }
 
@@ -237,19 +237,19 @@ CAMLprim value netsys_fdatasync(value fd) {
     r = fdatasync(Int_val(fd));
 #endif
     if (r == -1) 
-	uerror("fdatasync", Nothing);
+	caml_uerror("fdatasync", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.fdatasync not available");
+    caml_invalid_argument("Netsys.fdatasync not available");
 #endif
 }
 
 CAMLprim value netsys_fchdir(value fd) {
 #ifdef HAVE_FCHDIR
-    if (fchdir(Int_val(fd)) == -1) uerror("fchdir", Nothing);
+    if (fchdir(Int_val(fd)) == -1) caml_uerror("fchdir", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.fchdir not available");
+    caml_invalid_argument("Netsys_posix.fchdir not available");
 #endif
 }
 
@@ -259,12 +259,12 @@ CAMLprim value netsys_fdopendir(value fd)
   DIR * d;
   value res;
   d = fdopendir(Int_val(fd));
-  if (d == (DIR *) NULL) uerror("fdopendir", Nothing);
-  res = alloc_small(1, Abstract_tag);
+  if (d == (DIR *) NULL) caml_uerror("fdopendir", Nothing);
+  res = caml_alloc_small(1, Abstract_tag);
   DIR_Val(res) = d;
   return res;
 #else
-  invalid_argument("Netsys_posix.fdopendir not available");
+  caml_invalid_argument("Netsys_posix.fdopendir not available");
 #endif
 }
 
@@ -278,15 +278,15 @@ CAMLprim value netsys_realpath (value name)    /* POSIX.1-2001 */
     const char *name_in_s = String_val(name);
     name_out_s = realpath(name_in_s, NULL);   /* Note: GNU extension! */
     if (name_out_s == NULL) {
-	uerror("realpath", Nothing);
+	caml_uerror("realpath", Nothing);
     }
     else {
-	name_out = copy_string(name_out_s);
+	name_out = caml_copy_string(name_out_s);
 	free(name_out_s);
     }
     return name_out;
 #else
-    invalid_argument("Netsys_posix.realpath not available");
+    caml_invalid_argument("Netsys_posix.realpath not available");
 #endif
 }
 
@@ -296,10 +296,10 @@ CAMLprim value netsys_grantpt (value fd)    /* POSIX.1-2001 */
 #ifdef HAVE_PTY
     int e;
     e = grantpt(Int_val(fd));
-    if ( e < 0 ) uerror("grantpt", Nothing);
+    if ( e < 0 ) caml_uerror("grantpt", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.granpt not available");
+    caml_invalid_argument("Netsys_posix.granpt not available");
 #endif
 }
 
@@ -309,10 +309,10 @@ CAMLprim value netsys_unlockpt (value fd)    /* POSIX.1-2001 */
 #ifdef HAVE_PTY
     int e;
     e = unlockpt(Int_val(fd));
-    if ( e < 0 ) uerror("unlockpt", Nothing);
+    if ( e < 0 ) caml_uerror("unlockpt", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.unlockpt not available");
+    caml_invalid_argument("Netsys_posix.unlockpt not available");
 #endif
 }
 
@@ -323,10 +323,10 @@ CAMLprim value netsys_ptsname (value fd)    /* POSIX.1-2001 */
     char *s;
 
     s = ptsname(Int_val(fd));
-    if ( s == NULL ) uerror("ptsname", Nothing);
-    return copy_string(s);
+    if ( s == NULL ) caml_uerror("ptsname", Nothing);
+    return caml_copy_string(s);
 #else
-    invalid_argument("Netsys_posix.ptsname not available");
+    caml_invalid_argument("Netsys_posix.ptsname not available");
 #endif
 }
 
@@ -345,10 +345,10 @@ CAMLprim value netsys_posix_openpt(value noctty)     /* POSIX.1-2001 */
     fd = open("/dev/ptmx", flags);
 #endif
 
-    if (fd == -1) uerror("openpt", Nothing);
+    if (fd == -1) caml_uerror("openpt", Nothing);
     return Val_int(fd);
 #else
-    invalid_argument("Netsys_posix.posix_openpt not available");
+    caml_invalid_argument("Netsys_posix.posix_openpt not available");
 #endif
 }
 
@@ -356,7 +356,7 @@ CAMLprim value netsys_posix_openpt(value noctty)     /* POSIX.1-2001 */
 CAMLprim value netsys_mknod (value name, value perm, value nt)
 {
 #ifdef _WIN32
-    invalid_argument("Netsys_posix.mknod not available");
+    caml_invalid_argument("Netsys_posix.mknod not available");
 #else
     mode_t m;
     dev_t d;
@@ -389,7 +389,7 @@ CAMLprim value netsys_mknod (value name, value perm, value nt)
     }
 
     e = mknod(String_val(name), m, d);
-    if (e < 0) uerror("mknod", Nothing);
+    if (e < 0) caml_uerror("mknod", Nothing);
 
     return Val_unit;
 #endif
@@ -460,7 +460,9 @@ static int open_cloexec_table[] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CLOEXEC, KEEPEXEC
 };
 #ifndef HAVE_O_KEEPEXEC
-#define unix_cloexec_default 0
+#ifndef caml_unix_cloexec_default
+#define caml_unix_cloexec_default 0
+#endif
 #endif
 
 #endif
@@ -473,34 +475,34 @@ CAMLprim value netsys_openat(value dirfd, value path, value flags, value perm)
     char * p;
 
     /* shamelessly copied from ocaml distro */
-    cv_flags = convert_flag_list(flags, open_flag_table);
-    clo_flags = convert_flag_list(flags, open_cloexec_table);
+    cv_flags = caml_convert_flag_list(flags, open_flag_table);
+    clo_flags = caml_convert_flag_list(flags, open_cloexec_table);
     if (clo_flags & CLOEXEC)
         cloexec = 1;
     else if (clo_flags & KEEPEXEC)
         cloexec = 0;
     else
-        cloexec = unix_cloexec_default;
+        cloexec = caml_unix_cloexec_default;
 #if defined(O_CLOEXEC)
     if (cloexec) cv_flags |= O_CLOEXEC;
 #endif
-    p = stat_alloc(string_length(path) + 1);
+    p = caml_stat_alloc(caml_string_length(path) + 1);
     strcpy(p, String_val(path));
-    enter_blocking_section();
+    caml_enter_blocking_section();
     ret = openat(Int_val(dirfd), p, cv_flags, Int_val(perm));
-    leave_blocking_section();
-    stat_free(p);
-    if (ret == -1) uerror("openat", path);
+    caml_leave_blocking_section();
+    caml_stat_free(p);
+    if (ret == -1) caml_uerror("openat", path);
 #if !defined(O_CLOEXEC)
     {
         int flags = fcntl(Int_val(dirfd), F_GETFD, 0);
         if (flags == -1 || fcntl(Int_val(dirfd), F_SETFD, flags | FD_CLOEXEC) == -1)
-          uerror("openat", path);
+          caml_uerror("openat", path);
     }
 #endif
     CAMLreturn (Val_int(ret));
 #else
-    invalid_argument("Netsys_posix.openat not available");
+    caml_invalid_argument("Netsys_posix.openat not available");
 #endif
 }
 
@@ -517,15 +519,15 @@ CAMLprim value netsys_faccessat(value dirfd, value path, value perms,
 {
 #ifdef HAVE_AT
     int ret, cv_perms, cv_flags;
-    cv_perms = convert_flag_list(perms, access_permission_table);
-    cv_flags = convert_flag_list(flags, at_flags_table);
+    cv_perms = caml_convert_flag_list(perms, access_permission_table);
+    cv_flags = caml_convert_flag_list(flags, at_flags_table);
     cv_flags &= (AT_EACCESS | AT_SYMLINK_NOFOLLOW);
     ret = faccessat(Int_val(dirfd), String_val(path), cv_perms, cv_flags);
     if (ret == -1)
-	uerror("faccessat", path);
+	caml_uerror("faccessat", path);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.faccessat not available");
+    caml_invalid_argument("Netsys_posix.faccessat not available");
 #endif
 }
 
@@ -534,10 +536,10 @@ CAMLprim value netsys_mkdirat(value dirfd, value path, value perm)
 {
 #ifdef HAVE_AT
     if (mkdirat(Int_val(dirfd), String_val(path), Int_val(perm)) == -1) 
-	uerror("mkdirat", path);
+	caml_uerror("mkdirat", path);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.mkdirat not available");
+    caml_invalid_argument("Netsys_posix.mkdirat not available");
 #endif
 }
 
@@ -548,10 +550,10 @@ CAMLprim value netsys_renameat(value olddirfd, value oldpath,
 #ifdef HAVE_AT
     if (renameat(Int_val(olddirfd), String_val(oldpath),
 		 Int_val(newdirfd), String_val(newpath)) == -1)
-	uerror("renameat", oldpath);
+	caml_uerror("renameat", oldpath);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.renameat not available");
+    caml_invalid_argument("Netsys_posix.renameat not available");
 #endif
 }
 
@@ -561,14 +563,14 @@ CAMLprim value netsys_linkat(value olddirfd, value oldpath,
 {
 #ifdef HAVE_AT
     int cv_flags;
-    cv_flags = convert_flag_list(flags, at_flags_table);
+    cv_flags = caml_convert_flag_list(flags, at_flags_table);
     cv_flags &= AT_SYMLINK_FOLLOW;  /* only allowed flag here */
     if (linkat(Int_val(olddirfd), String_val(oldpath),
 	       Int_val(newdirfd), String_val(newpath), cv_flags) == -1)
-	uerror("linkat", oldpath);
+	caml_uerror("linkat", oldpath);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.linkat not available");
+    caml_invalid_argument("Netsys_posix.linkat not available");
 #endif
 }
 
@@ -577,13 +579,13 @@ CAMLprim value netsys_unlinkat(value dirfd, value path, value flags)
 {
 #ifdef HAVE_AT
     int cv_flags;
-    cv_flags = convert_flag_list(flags, at_flags_table);
+    cv_flags = caml_convert_flag_list(flags, at_flags_table);
     cv_flags &= AT_REMOVEDIR;  /* only allowed flag here */
     if (unlinkat(Int_val(dirfd), String_val(path), cv_flags) == -1)
-	uerror("unlinkat", path);
+	caml_uerror("unlinkat", path);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.unlinkat not available");
+    caml_invalid_argument("Netsys_posix.unlinkat not available");
 #endif
 }
 
@@ -594,10 +596,10 @@ CAMLprim value netsys_symlinkat(value oldpath,
 #ifdef HAVE_AT
     if (symlinkat(String_val(oldpath),
 		  Int_val(newdirfd), String_val(newpath)) == -1)
-	uerror("symlinkat", oldpath);
+	caml_uerror("symlinkat", oldpath);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.symlinkat not available");
+    caml_invalid_argument("Netsys_posix.symlinkat not available");
 #endif
 }
 
@@ -606,10 +608,10 @@ CAMLprim value netsys_mkfifoat(value dirfd, value path, value mode)
 {
 #ifdef HAVE_MKFIFOAT
     if (mkfifoat(Int_val(dirfd), String_val(path), Int_val(mode)) == -1)
-	uerror("mkfifoat", path);
+	caml_uerror("mkfifoat", path);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.mkfifoat not available");
+    caml_invalid_argument("Netsys_posix.mkfifoat not available");
 #endif
 }
 
@@ -620,10 +622,10 @@ CAMLprim value netsys_readlinkat(value dirfd, value path)
   char buffer[PATH_MAX];
   int len;
   len = readlinkat(Int_val(dirfd), String_val(path), buffer, sizeof(buffer)-1);
-  if (len == -1) uerror("readlinkat", path);
+  if (len == -1) caml_uerror("readlinkat", path);
   buffer[len] = '\0';
-  return copy_string(buffer);
+  return caml_copy_string(buffer);
 #else
-    invalid_argument("Netsys_posix.readlinkat not available");
+    caml_invalid_argument("Netsys_posix.readlinkat not available");
 #endif
 }
diff --git code/src/netsys/netsys_c.h code/src/netsys/netsys_c.h
index d4d5a1a3..9d1abd74 100644
--- code/src/netsys/netsys_c.h
+++ code/src/netsys/netsys_c.h
@@ -68,6 +68,7 @@
 #include "caml/custom.h"
 #include "caml/callback.h"
 #include "caml/bigarray.h"
+#include "caml/unixsupport.h"
 #include "caml/version.h"
 
 #ifndef Bytes_val
@@ -171,25 +172,8 @@ extern void caml_darken (value, value *);
 /* From unixsupport.h                                                 */
 /**********************************************************************/
 
-#define Nothing ((value) 0)
-
 #ifdef _WIN32
-#include "caml/unixsupport.h"
 #define netsysw32_win_alloc_handle win_alloc_handle
-#else
-
-/* POSIX */
-
-/* Since OCaml 3.10 there is unixsupport.h, and we could also include
-   this file.
-*/
-
-extern value unix_error_of_code (int errcode);
-extern void unix_error (int errcode, char * cmdname, value arg) Noreturn;
-extern void uerror (char * cmdname, value arg) Noreturn;
-
-#define DIR_Val(v) *((DIR **) &Field(v, 0))
-
 #endif
 
 /**********************************************************************/
diff --git code/src/netsys/netsys_c_clock.c code/src/netsys/netsys_c_clock.c
index c5109288..1436aa0f 100644
--- code/src/netsys/netsys_c_clock.c
+++ code/src/netsys/netsys_c_clock.c
@@ -23,10 +23,10 @@ static void make_timespec(value tspair, struct timespec *ts) {
 
     d = Double_val(Field(tspair,0));
     if (!isfinite(d) || d < 0 || d > LONG_MAX-1)
-	failwith("Netsys_posix: time value out of range");
+	caml_failwith("Netsys_posix: time value out of range");
     n = Long_val(Field(tspair,1));
     if (n < 0 || n > 999999999)
-	failwith("Netsys_posix: time value out of range");
+	caml_failwith("Netsys_posix: time value out of range");
     i = floor(d);
     r = floor((d - i) * 1E9);
     r = r + n;
@@ -44,7 +44,7 @@ static void make_timespec(value tspair, struct timespec *ts) {
 static value alloc_timespec_pair(double sec, long nsec) {
     CAMLparam0();
     CAMLlocal1(tsout);
-    tsout = alloc(2,0);
+    tsout = caml_alloc(2,0);
     Store_field(tsout, 0, caml_copy_double(sec));
     Store_field(tsout, 1, Val_long(nsec));
     CAMLreturn(tsout);
@@ -65,7 +65,7 @@ static void clockid_val(value c, clockid_t *out) {
 	    *out = CLOCK_MONOTONIC;
 	    break;
 #else
-	    failwith("Netsys_posix: CLOCK_MONOTONIC is not supported");
+	    caml_failwith("Netsys_posix: CLOCK_MONOTONIC is not supported");
 #endif
 	}
     }
@@ -98,11 +98,11 @@ CAMLprim value netsys_nanosleep(value tspair, value tsref)
     tsout = alloc_timespec_pair(t_out.tv_sec, t_out.tv_nsec);
     Store_field(tsref, 0, tsout);
 
-    if (r == -1) unix_error(e, "nanosleep", Nothing);
+    if (r == -1) caml_unix_error(e, "nanosleep", Nothing);
    
     CAMLreturn(Val_unit);
 #else
-    invalid_argument("Netsys_posix.nanosleep not available");
+    caml_invalid_argument("Netsys_posix.nanosleep not available");
 #endif
 }
 
@@ -118,13 +118,13 @@ CAMLprim value netsys_clock_gettime(value clock)
 
     clockid_val(clock, &c);
     r = clock_gettime(c, &ts);
-    if (r == -1) uerror("clock_gettime", Nothing);
+    if (r == -1) caml_uerror("clock_gettime", Nothing);
     
     tsout = alloc_timespec_pair(ts.tv_sec, ts.tv_nsec);
     
     CAMLreturn(tsout);
 #else
-    invalid_argument("Netsys_posix.clock_gettime not available");
+    caml_invalid_argument("Netsys_posix.clock_gettime not available");
 #endif
 }
 
@@ -141,11 +141,11 @@ CAMLprim value netsys_clock_settime(value clock, value tspair)
     make_timespec(tspair, &ts);
 
     r = clock_settime(c, &ts);
-    if (r == -1) uerror("clock_settime", Nothing);
+    if (r == -1) caml_uerror("clock_settime", Nothing);
     
     CAMLreturn(Val_unit);
 #else
-    invalid_argument("Netsys_posix.clock_settime not available");
+    caml_invalid_argument("Netsys_posix.clock_settime not available");
 #endif
 }
 
@@ -162,13 +162,13 @@ CAMLprim value netsys_clock_getres(value clock)
     clockid_val(clock, &c);
 
     r = clock_getres(c, &ts);
-    if (r == -1) uerror("clock_getres", Nothing);
+    if (r == -1) caml_uerror("clock_getres", Nothing);
     
     tsout = alloc_timespec_pair(ts.tv_sec, ts.tv_nsec);
     
     CAMLreturn(tsout);
 #else
-    invalid_argument("Netsys_posix.clock_getres not available");
+    caml_invalid_argument("Netsys_posix.clock_getres not available");
 #endif
 }
 
@@ -182,7 +182,7 @@ CAMLprim value netsys_clock_getcpuclockid(value pid) {
     char *s;
 
     r = clock_getcpuclockid(Long_val(pid), &c);
-    if (r != 0) unix_error(r, "clock_getcpuclockid", Nothing);
+    if (r != 0) caml_unix_error(r, "clock_getcpuclockid", Nothing);
 
     v = caml_alloc_string(sizeof(clockid_t));
     s = String_val(v);
@@ -191,7 +191,7 @@ CAMLprim value netsys_clock_getcpuclockid(value pid) {
 
     CAMLreturn(v);
 #else
-    invalid_argument("Netsys_posix.clock_getcpuclockid not available");
+    caml_invalid_argument("Netsys_posix.clock_getcpuclockid not available");
 #endif
 }
 
@@ -263,7 +263,7 @@ CAMLprim value netsys_timer_create(value clock, value texp) {
 	    sev.sigev_value.sival_ptr = ne;
 	    break;
 #else
-	    failwith("Netsys_posix.timer_create: unsupported type of timer");
+	    caml_failwith("Netsys_posix.timer_create: unsupported type of timer");
 #endif
 #endif
 	}
@@ -280,7 +280,7 @@ CAMLprim value netsys_timer_create(value clock, value texp) {
 	    sev.sigev_value.sival_ptr = ne;
 	    break;
 #else
-	    failwith("Netsys_posix.timer_create: unsupported type of timer");
+	    caml_failwith("Netsys_posix.timer_create: unsupported type of timer");
 #endif
 	case 1:
 	    /* TEXP_SIGNAL */
@@ -294,7 +294,7 @@ CAMLprim value netsys_timer_create(value clock, value texp) {
     switch (tcase) {
     case 0:
 	code = timer_create(c, &sev, &tm);
-	if (code == -1) uerror("timer_create", Nothing);
+	if (code == -1) caml_uerror("timer_create", Nothing);
 	v = caml_alloc_string(sizeof(timer_t));
 	memcpy(Bytes_val(v), (char *) &tm, sizeof(timer_t));
 	v_timer = caml_alloc(1, 0);
@@ -313,7 +313,7 @@ CAMLprim value netsys_timer_create(value clock, value texp) {
     Store_field(v, 1, v_event);
     CAMLreturn(v);
 #else
-    invalid_argument("Netsys_posix.timer_create not available");
+    caml_invalid_argument("Netsys_posix.timer_create not available");
 #endif
 }
 
@@ -346,7 +346,7 @@ CAMLprim value netsys_timer_settime(value timer, value abstime,
 			     Bool_val(abstime) ? TIMER_ABSTIME : 0,
 			     &it,
 			     NULL);
-	if (code == -1) uerror("timer_settime", Nothing);
+	if (code == -1) caml_uerror("timer_settime", Nothing);
 	break;
 #ifdef HAVE_TIMERFD
     case 1:
@@ -356,14 +356,14 @@ CAMLprim value netsys_timer_settime(value timer, value abstime,
 			       Bool_val(abstime) ? TFD_TIMER_ABSTIME : 0,
 			       &it,
 			       NULL);
-	if (code == -1) uerror("timerfd_settime", Nothing);
+	if (code == -1) caml_uerror("timerfd_settime", Nothing);
 	break;
 #endif
     };
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.timer_settime not available");
+    caml_invalid_argument("Netsys_posix.timer_settime not available");
 #endif
 }
 
@@ -382,14 +382,14 @@ CAMLprim value netsys_timer_gettime(value timer) {
 	/* POSIX timer */
 	extract_timer(Field(Field(timer, 0), 0), &tm);
 	code = timer_gettime(tm, &it);
-	if (code == -1) uerror("timer_gettime", Nothing);
+	if (code == -1) caml_uerror("timer_gettime", Nothing);
 	break;
 #ifdef HAVE_TIMERFD
     case 1:
 	/* TIMERFD */
 	fd = Int_val(Field(Field(timer, 0), 0));
 	code = timerfd_gettime(fd, &it);
-	if (code == -1) uerror("timerfd_gettime", Nothing);
+	if (code == -1) caml_uerror("timerfd_gettime", Nothing);
 	break;
 #endif
     };
@@ -398,7 +398,7 @@ CAMLprim value netsys_timer_gettime(value timer) {
 			    it.it_value.tv_nsec);
     return r;
 #else
-    invalid_argument("Netsys_posix.timer_gettime not available");
+    caml_invalid_argument("Netsys_posix.timer_gettime not available");
 #endif
 }
 
@@ -413,7 +413,7 @@ CAMLprim value netsys_timer_delete(value timer) {
 	/* POSIX timer */
 	extract_timer(Field(Field(timer, 0), 0), &tm);
 	code = timer_delete(tm);
-	if (code == -1) uerror("timer_delete", Nothing);
+	if (code == -1) caml_uerror("timer_delete", Nothing);
 	break;
 #ifdef HAVE_TIMERFD
     case 1:
@@ -424,7 +424,7 @@ CAMLprim value netsys_timer_delete(value timer) {
     }
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.timer_delete not available");
+    caml_invalid_argument("Netsys_posix.timer_delete not available");
 #endif
 }
 
@@ -435,9 +435,9 @@ CAMLprim value netsys_timer_event(value timer) {
 	return Field(timer,1);
     }
     else {
-	failwith("Netsys_posix.timer_event: timer is not connected with event");
+	caml_failwith("Netsys_posix.timer_event: timer is not connected with event");
     }
 #else
-    invalid_argument("Netsys_posix.timer_delete not available");
+    caml_invalid_argument("Netsys_posix.timer_delete not available");
 #endif
 }
diff --git code/src/netsys/netsys_c_event.c code/src/netsys/netsys_c_event.c
index 6a2ce45f..dc73cf62 100644
--- code/src/netsys/netsys_c_event.c
+++ code/src/netsys/netsys_c_event.c
@@ -187,24 +187,24 @@ CAMLprim value netsys_create_not_event(value allow_user_add)
     p->allow_user_add = Bool_val(allow_user_add);
 #ifdef HAVE_PTHREAD
     x = pthread_mutex_init(&(p->mutex), NULL);
-    if (x != 0) unix_error(x, "pthread_mutex_init", Nothing);
+    if (x != 0) caml_unix_error(x, "pthread_mutex_init", Nothing);
 #endif
 
 #ifdef HAVE_EVENTFD
     p->type = NE_EVENTFD;
     x = eventfd(0, 0);
-    if (x == -1) uerror("eventfd", Nothing);
+    if (x == -1) caml_uerror("eventfd", Nothing);
     p->fd1 = x;
     x = fcntl(p->fd1, F_SETFD, FD_CLOEXEC);
     if (x == -1) {
 	e = errno;
 	close(p->fd1);
-	unix_error(e, "fcntl", Nothing);
+	caml_unix_error(e, "fcntl", Nothing);
     }
 #else
     p->type = NE_PIPE;
     x = pipe(pipefd);
-    if (x == -1) uerror("pipe", Nothing);
+    if (x == -1) caml_uerror("pipe", Nothing);
     p->fd1 = pipefd[0];
     p->fd2 = pipefd[1];
     x = fcntl(p->fd1, F_SETFD, FD_CLOEXEC);
@@ -212,19 +212,19 @@ CAMLprim value netsys_create_not_event(value allow_user_add)
 	e = errno;
 	close(p->fd1);
 	close(p->fd2);
-	unix_error(e, "fcntl", Nothing);
+	caml_unix_error(e, "fcntl", Nothing);
     }
     x = fcntl(p->fd2, F_SETFD, FD_CLOEXEC);
     if (x == -1) {
 	e = errno;
 	close(p->fd1);
 	close(p->fd2);
-	unix_error(e, "fcntl", Nothing);
+	caml_unix_error(e, "fcntl", Nothing);
     }
 #endif
     return r;
 #else
-    invalid_argument("Netsys_posix.create_event not available");
+    caml_invalid_argument("Netsys_posix.create_event not available");
 #endif
 }
 
@@ -246,13 +246,13 @@ CAMLprim value netsys_not_event_timerfd(int clockid)
 
     p->type = NE_TIMERFD;
     x = timerfd_create(clockid, 0);
-    if (x == -1) uerror("timerfd_create", Nothing);
+    if (x == -1) caml_uerror("timerfd_create", Nothing);
     p->fd1 = x;
     x = fcntl(p->fd1, F_SETFD, FD_CLOEXEC);
     if (x == -1) {
 	e = errno;
 	close(p->fd1);
-	unix_error(e, "fcntl", Nothing);
+	caml_unix_error(e, "fcntl", Nothing);
     }
     return r;
 }
@@ -268,17 +268,17 @@ CAMLprim value netsys_set_nonblock_not_event(value nev)
     ne = *(Not_event_val(nev));
 
     if (ne->fd1 == -1) 
-	failwith("Netsys_posix.set_nonblock_event: already destroyed");
+	caml_failwith("Netsys_posix.set_nonblock_event: already destroyed");
     
     x = fcntl(ne->fd1, F_GETFL, 0);
-    if (x == -1) uerror("fcntl", Nothing);
+    if (x == -1) caml_uerror("fcntl", Nothing);
 
     x = fcntl(ne->fd1, F_SETFL, x | O_NONBLOCK);
-    if (x == -1) uerror("fcntl", Nothing);
+    if (x == -1) caml_uerror("fcntl", Nothing);
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.set_nonblock_event not available");
+    caml_invalid_argument("Netsys_posix.set_nonblock_event not available");
 #endif
 }
 
@@ -290,10 +290,10 @@ CAMLprim value netsys_get_not_event_fd_nodup(value nev)
     int fd, code;
     ne = *(Not_event_val(nev));
     if (ne->fd1 == -1) 
-	failwith("Netsys_posix.get_event_fd_nodup: already destroyed");
+	caml_failwith("Netsys_posix.get_event_fd_nodup: already destroyed");
     return Val_int(ne->fd1);
 #else
-    invalid_argument("Netsys_posix.get_event_fd not available");
+    caml_invalid_argument("Netsys_posix.get_event_fd not available");
 #endif
 }
 
@@ -306,11 +306,11 @@ int netsys_return_not_event_fd(value nev)
     int fd;
     ne = *(Not_event_val(nev));
     if (ne->fd1 == -1) 
-	failwith("Netsys_posix.get_event_fd: already destroyed");
+	caml_failwith("Netsys_posix.get_event_fd: already destroyed");
     fd = ne->fd1;
     return fd;
 #else
-    invalid_argument("Netsys_posix.get_event_fd not available");
+    caml_invalid_argument("Netsys_posix.get_event_fd not available");
 #endif
 }
 
@@ -350,15 +350,15 @@ CAMLprim value netsys_set_not_event(value nev)
     CAMLparam1(nev);
     ne = *(Not_event_val(nev));
     if (ne->fd1 == -1) 
-	failwith("Netsys_posix.set_event: already destroyed");
+	caml_failwith("Netsys_posix.set_event: already destroyed");
     if (!ne->allow_user_add)
-	failwith("Netsys_posix.set_event: not allowed for this type of event");
+	caml_failwith("Netsys_posix.set_event: not allowed for this type of event");
     caml_enter_blocking_section();
     netsys_not_event_signal(ne);
     caml_leave_blocking_section();
     CAMLreturn(Val_unit);
 #else
-    invalid_argument("Netsys_posix.set_event not available");
+    caml_invalid_argument("Netsys_posix.set_event not available");
 #endif
 }
 
@@ -373,7 +373,7 @@ CAMLprim value netsys_wait_not_event(value nev)
     ne = *(Not_event_val(nev));
     
     if (ne->fd1 == -1) 
-	failwith("Netsys_posix.wait_event: already destroyed");
+	caml_failwith("Netsys_posix.wait_event: already destroyed");
 
     caml_enter_blocking_section();
     p.fd = ne->fd1;
@@ -383,10 +383,10 @@ CAMLprim value netsys_wait_not_event(value nev)
     e = errno;
     caml_leave_blocking_section();
 
-    if (code == -1) unix_error(e, "poll", Nothing);
+    if (code == -1) caml_unix_error(e, "poll", Nothing);
     CAMLreturn(Val_unit);
 #else
-    invalid_argument("Netsys_posix.wait_event not available");
+    caml_invalid_argument("Netsys_posix.wait_event not available");
 #endif
 }
 
@@ -402,7 +402,7 @@ CAMLprim value netsys_consume_not_event(value nev)
     ne = *(Not_event_val(nev));
     
     if (ne->fd1 == -1) 
-	failwith("Netsys_posix.consume_event: already destroyed");
+	caml_failwith("Netsys_posix.consume_event: already destroyed");
 
     caml_enter_blocking_section();
 
@@ -426,8 +426,8 @@ CAMLprim value netsys_consume_not_event(value nev)
 
     caml_leave_blocking_section();
 
-    if (code == -1) unix_error(e, "read", Nothing);
-    if (!ok) unix_error(EINVAL, "read (result invalid)", Nothing);
+    if (code == -1) caml_unix_error(e, "read", Nothing);
+    if (!ok) caml_unix_error(EINVAL, "read (result invalid)", Nothing);
 
     ne->state = 0;
     /* No need to block signals, or to use the mutex. The next signaller
@@ -436,6 +436,6 @@ CAMLprim value netsys_consume_not_event(value nev)
 
     CAMLreturn(Val_unit);
 #else
-    invalid_argument("Netsys_posix.wait_event not available");
+    caml_invalid_argument("Netsys_posix.wait_event not available");
 #endif
 }
diff --git code/src/netsys/netsys_c_fadvise.c code/src/netsys/netsys_c_fadvise.c
index a7c8067e..8ace202b 100644
--- code/src/netsys/netsys_c_fadvise.c
+++ code/src/netsys/netsys_c_fadvise.c
@@ -35,26 +35,26 @@ CAMLprim value netsys_fadvise(value fd, value start, value len, value adv) {
     case 3: case 9: adv_int = POSIX_FADV_NOREUSE; break;
     case 4: case 10: adv_int = POSIX_FADV_WILLNEED; break;
     case 5: case 11: adv_int = POSIX_FADV_DONTNEED; break;
-    default: invalid_argument("Netsys.fadvise");
+    default: caml_invalid_argument("Netsys.fadvise");
     };
 
     start_int = Int64_val(start);
     len_int = Int64_val(len);
 
     if ( ((int64_t) ((off_t) start_int)) != start_int )
-	failwith("Netsys.fadvise: large files not supported on this OS");
+	caml_failwith("Netsys.fadvise: large files not supported on this OS");
     if ( ((int64_t) ((off_t) len_int)) != len_int )
-	failwith("Netsys.fadvise: large files not supported on this OS");
+	caml_failwith("Netsys.fadvise: large files not supported on this OS");
 
     start_off = start_int;
     len_off = len_int;
 
     r = posix_fadvise(Int_val(fd), start_off, len_off, adv_int);
     if (r == -1) 
-	uerror("posix_fadvise64", Nothing);
+	caml_uerror("posix_fadvise64", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.fadvise not available");
+    caml_invalid_argument("Netsys.fadvise not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_fallocate.c code/src/netsys/netsys_c_fallocate.c
index 9f6dca96..11a165fa 100644
--- code/src/netsys/netsys_c_fallocate.c
+++ code/src/netsys/netsys_c_fallocate.c
@@ -28,9 +28,9 @@ CAMLprim value netsys_fallocate(value fd, value start, value len) {
     len_int = Int64_val(len);
 
     if ( ((int64_t) ((off_t) start_int)) != start_int )
-	failwith("Netsys.fadvise: large files not supported on this OS");
+	caml_failwith("Netsys.fadvise: large files not supported on this OS");
     if ( ((int64_t) ((off_t) len_int)) != len_int )
-	failwith("Netsys.fadvise: large files not supported on this OS");
+	caml_failwith("Netsys.fadvise: large files not supported on this OS");
 
     start_off = start_int;
     len_off = len_int;
@@ -38,10 +38,10 @@ CAMLprim value netsys_fallocate(value fd, value start, value len) {
     r = posix_fallocate(Int_val(fd), start_off, len_off);
     /* does not set errno! */
     if (r != 0) 
-	unix_error(r, "posix_fallocate64", Nothing);
+	caml_unix_error(r, "posix_fallocate64", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.fallocate not available");
+    caml_invalid_argument("Netsys.fallocate not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_ioprio.c code/src/netsys/netsys_c_ioprio.c
index 0f3e068a..99c2a0fb 100644
--- code/src/netsys/netsys_c_ioprio.c
+++ code/src/netsys/netsys_c_ioprio.c
@@ -89,11 +89,11 @@ CAMLprim value netsys_ioprio_get(value target) {
 	ioprio = ioprio_get(IOPRIO_WHO_USER, Int_val(Field(target, 0)));
 	break;
     default:
-	failwith("netsys_ioprio_get: internal error");
+	caml_failwith("netsys_ioprio_get: internal error");
     }
 
     if (ioprio == -1)
-	uerror("ioprio_get", Nothing);
+	caml_uerror("ioprio_get", Nothing);
 
     ioprio_class = ioprio >> IOPRIO_CLASS_SHIFT;
     ioprio_data = ioprio & IOPRIO_PRIO_MASK;
@@ -114,14 +114,14 @@ CAMLprim value netsys_ioprio_get(value target) {
 	result = Val_long(1);
 	break;
     default:
-	failwith("netsys_ioprio_get: Unexpected result");
+	caml_failwith("netsys_ioprio_get: Unexpected result");
     }
     
     return result;
 
 #else
     /* not ioprio_supported: */
-    unix_error(ENOSYS, "ioprio_get", Nothing);
+    caml_unix_error(ENOSYS, "ioprio_get", Nothing);
 #endif
     /* ioprio_supported */
 }
@@ -145,7 +145,7 @@ CAMLprim value netsys_ioprio_set(value target, value ioprio_arg) {
 	    ioprio_data = Int_val(Field(ioprio_arg, 0));
 	    break;
 	default:
-	    failwith("netsys_ioprio_set: internal error");
+	    caml_failwith("netsys_ioprio_set: internal error");
 	}
     } else {
 	switch (Long_val(ioprio_arg)) {
@@ -159,7 +159,7 @@ CAMLprim value netsys_ioprio_set(value target, value ioprio_arg) {
 	    ioprio_data = 7;
 	    break;
 	default:
-	    failwith("netsys_ioprio_set: internal error");
+	    caml_failwith("netsys_ioprio_set: internal error");
 	}
     };
 
@@ -176,16 +176,16 @@ CAMLprim value netsys_ioprio_set(value target, value ioprio_arg) {
 	sysres = ioprio_set(IOPRIO_WHO_USER, Int_val(Field(target, 0)), ioprio);
 	break;
     default:
-	failwith("netsys_ioprio_set: internal error");
+	caml_failwith("netsys_ioprio_set: internal error");
     }
 
     if (sysres == -1)
-	uerror("ioprio_set", Nothing);
+	caml_uerror("ioprio_set", Nothing);
 
     return Val_unit;
 #else
     /* not ioprio_supported: */
-    unix_error(ENOSYS, "ioprio_set", Nothing);
+    caml_unix_error(ENOSYS, "ioprio_set", Nothing);
 #endif
     /* ioprio_supported */
 }
diff --git code/src/netsys/netsys_c_ip6.c code/src/netsys/netsys_c_ip6.c
index be2d50bf..ff9ff04e 100644
--- code/src/netsys/netsys_c_ip6.c
+++ code/src/netsys/netsys_c_ip6.c
@@ -30,7 +30,7 @@ CAMLprim value netsys_test_for_ip6_global_addr(value dummy) {
     int family;
 
     if (getifaddrs(&ifaddr) == -1) {
-        uerror("getifaddrs", Nothing);
+        caml_uerror("getifaddrs", Nothing);
     }
 
     found = 0;
diff --git code/src/netsys/netsys_c_locale.c code/src/netsys/netsys_c_locale.c
index f4961abf..a7ea2c50 100644
--- code/src/netsys/netsys_c_locale.c
+++ code/src/netsys/netsys_c_locale.c
@@ -39,28 +39,28 @@ CAMLprim value netsys_query_langinfo(value locale)
 
     old_locale = setlocale(LC_ALL, NULL);
     if (old_locale == NULL)
-	failwith("Netsys_posix.query_locale: no locale support");
-    oldcopy_locale = stat_alloc(strlen(old_locale) + 1);
+	caml_failwith("Netsys_posix.query_locale: no locale support");
+    oldcopy_locale = caml_stat_alloc(strlen(old_locale) + 1);
     strcpy(oldcopy_locale, old_locale);
 
     new_locale = setlocale(LC_ALL, String_val(locale));
     if (new_locale == NULL) {
-	stat_free(oldcopy_locale);
-	failwith("Netsys_posix.query_locale: cannot set this locale");
+	caml_stat_free(oldcopy_locale);
+	caml_failwith("Netsys_posix.query_locale: cannot set this locale");
     }
     
     n = sizeof(locale_items_table) / sizeof(locale_items_table[0]);
-    s = alloc(n,0);
+    s = caml_alloc(n,0);
     for (k=0; k<n; k++) {
-	Store_field(s,k,copy_string(nl_langinfo(locale_items_table[k])));
+	Store_field(s,k,caml_copy_string(nl_langinfo(locale_items_table[k])));
     };
     
     setlocale(LC_ALL, oldcopy_locale);
-    stat_free(oldcopy_locale);
+    caml_stat_free(oldcopy_locale);
 
     CAMLreturn (s);
 #else
-    invalid_argument("Netsys_posix.query_locale not available");
+    caml_invalid_argument("Netsys_posix.query_locale not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_mem.c code/src/netsys/netsys_c_mem.c
index 0d7778e1..4a406b2d 100644
--- code/src/netsys/netsys_c_mem.c
+++ code/src/netsys/netsys_c_mem.c
@@ -4,6 +4,8 @@
 #include "netsys_c_htab.h"
 #include "netsys_c_queue.h"
 
+#define Bigarray_val Caml_ba_array_val
+
 #ifdef HAVE_MMAP
 #include <sys/types.h>
 #include <sys/mman.h>
@@ -30,7 +32,7 @@ CAMLprim value netsys_blit_memory_to_string(value memv,
 					    value soffv,
 					    value lenv)
 {
-    struct caml_bigarray *mem = Bigarray_val(memv);
+    struct caml_ba_array *mem = Bigarray_val(memv);
     char * s = Bytes_val(sv);
     long memoff = Long_val(memoffv);
     long soff = Long_val(soffv);
@@ -48,7 +50,7 @@ CAMLprim value netsys_blit_string_to_memory(value sv,
 					    value memoffv,
 					    value lenv)
 {
-    struct caml_bigarray *mem = Bigarray_val(memv);
+    struct caml_ba_array *mem = Bigarray_val(memv);
     const char * s = String_val(sv);
     long memoff = Long_val(memoffv);
     long soff = Long_val(soffv);
@@ -62,7 +64,7 @@ CAMLprim value netsys_blit_string_to_memory(value sv,
 
 CAMLprim value netsys_memory_address(value memv)
 {
-    struct caml_bigarray *mem = Bigarray_val(memv);
+    struct caml_ba_array *mem = Bigarray_val(memv);
     return caml_copy_nativeint((intnat) mem->data);
 }
 
@@ -72,7 +74,7 @@ CAMLprim value netsys_getpagesize(value dummy)
 #ifdef HAVE_SYSCONF
     return Val_long(sysconf(_SC_PAGESIZE));
 #else
-    invalid_argument("Netsys_mem.getpagesize not available");
+    caml_invalid_argument("Netsys_mem.getpagesize not available");
 #endif
 }
 
@@ -83,7 +85,7 @@ CAMLprim value netsys_grab(value addrv, value lenv)
 
     start = (void *) Nativeint_val(addrv);
     length = Long_val(lenv);
-    return alloc_bigarray_dims(BIGARRAY_C_LAYOUT | BIGARRAY_UINT8,
+    return caml_ba_alloc_dims(CAML_BA_C_LAYOUT | CAML_BA_UINT8,
 			       1, start, length);
 }
 
@@ -109,15 +111,15 @@ CAMLprim value netsys_alloc_memory_pages(value addrv, value pv, value execv)
 
     data = mmap(start, length, flags, 
 		MAP_PRIVATE | MAP_ANON, (-1), 0);
-    if (data == (void *) -1) uerror("mmap", Nothing);
+    if (data == (void *) -1) caml_uerror("mmap", Nothing);
 
-    r = alloc_bigarray_dims(BIGARRAY_C_LAYOUT | BIGARRAY_UINT8 | 
-			    BIGARRAY_MAPPED_FILE,
+    r = caml_ba_alloc_dims(CAML_BA_C_LAYOUT | CAML_BA_UINT8 | 
+			    CAML_BA_MAPPED_FILE,
 			    1, data, length);
 
     return r;
 #else
-    invalid_argument("Netsys_mem.alloc_memory_pages not available");
+    caml_invalid_argument("Netsys_mem.alloc_memory_pages not available");
 #endif
 }
 
@@ -125,7 +127,7 @@ CAMLprim value netsys_alloc_memory_pages(value addrv, value pv, value execv)
 CAMLprim value netsys_zero_pages(value memv, value offsv, value lenv)
 {
 #if defined(HAVE_MMAP) && defined(HAVE_SYSCONF) && defined(MAP_ANON) && defined (MAP_FIXED)
-    struct caml_bigarray *mem = Bigarray_val(memv);
+    struct caml_ba_array *mem = Bigarray_val(memv);
     long offs = Long_val(offsv);
     long len = Long_val(lenv);
     long pgsize = sysconf(_SC_PAGESIZE);
@@ -137,17 +139,17 @@ CAMLprim value netsys_zero_pages(value memv, value offsv, value lenv)
 	    data2 = mmap(data, len, PROT_READ|PROT_WRITE, 
 			 MAP_PRIVATE | MAP_ANON | MAP_FIXED,
 			 (-1), 0);
-	    if (data2 == (void *) -1) uerror("mmap", Nothing);
+	    if (data2 == (void *) -1) caml_uerror("mmap", Nothing);
 	    if (((void *) data) != data2)
-		failwith("Netsys_mem.zero_pages assertion failed");
+		caml_failwith("Netsys_mem.zero_pages assertion failed");
 	}
     }
     else
-	invalid_argument("Netsys_mem.zero_pages only for whole pages");
+	caml_invalid_argument("Netsys_mem.zero_pages only for whole pages");
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_mem.zero_pages not available");
+    caml_invalid_argument("Netsys_mem.zero_pages not available");
 #endif
 }
 
@@ -162,14 +164,14 @@ CAMLprim value netsys_alloc_aligned_memory(value alignv, value pv)
     value r;
 
     e = posix_memalign(&addr, align, size);
-    if (e != 0) unix_error(e, "posix_memalign", Nothing);
+    if (e != 0) caml_unix_error(e, "posix_memalign", Nothing);
 
-    r = alloc_bigarray_dims(BIGARRAY_C_LAYOUT | BIGARRAY_UINT8 | 
-			    BIGARRAY_MANAGED,
+    r = caml_ba_alloc_dims(CAML_BA_C_LAYOUT | CAML_BA_UINT8 | 
+			    CAML_BA_MANAGED,
 			    1, addr, size);
     return r;
 #else
-    invalid_argument("Netsys_mem.alloc_aligned_memory not available");
+    caml_invalid_argument("Netsys_mem.alloc_aligned_memory not available");
 #endif
 }
 
@@ -197,7 +199,7 @@ CAMLprim value netsys_map_file(value fdv,
     fd = Int_val(fdv);
     pos0 = Int64_val(posv);
     if (((int64_t) ((off_t) pos0)) != pos0)
-	failwith("Netsys_mem: large files not supported on this OS");
+	caml_failwith("Netsys_mem: large files not supported on this OS");
     pos = pos0;
     addr = (void *) Nativeint_val(addrv);
     if (addr == 0) addr = NULL;
@@ -206,36 +208,36 @@ CAMLprim value netsys_map_file(value fdv,
 
     pagesize = sysconf(_SC_PAGESIZE);
 
-    if (fstat(fd, &st) == -1) uerror("fstat", Nothing);
+    if (fstat(fd, &st) == -1) caml_uerror("fstat", Nothing);
     eofpos = st.st_size;
     
     if (size == -1) {
 	if (eofpos < pos) 
-	    failwith("Netsys_mem: cannot mmap - file position exceeds file size");
+	    caml_failwith("Netsys_mem: cannot mmap - file position exceeds file size");
 	basize0 = eofpos - pos;
 	if (((off_t) ((uintnat) basize0)) != basize0)
-	    failwith("Netsys_mem: cannot mmap - file too large");
+	    caml_failwith("Netsys_mem: cannot mmap - file too large");
 	basize = (uintnat) basize0;
     }
     else {
 	if (size < 0)
-	    invalid_argument("netsys_map_file");
+	    caml_invalid_argument("netsys_map_file");
 	if (eofpos - pos < size) {
 	    if (ftruncate(fd, pos + size) == -1)
-		uerror("ftruncate", Nothing);
+		caml_uerror("ftruncate", Nothing);
 	}
 	basize = size;
     }
     delta = (uintnat) (pos % pagesize);
     eff_addr = mmap(addr, basize + delta, PROT_READ | PROT_WRITE,
 		    shared, fd, pos - delta);
-    if (eff_addr == (void*) MAP_FAILED) uerror("mmap", Nothing);
+    if (eff_addr == (void*) MAP_FAILED) caml_uerror("mmap", Nothing);
     eff_addr = (void *) ((uintnat) eff_addr + delta);
 
-    return alloc_bigarray_dims(BIGARRAY_UINT8 | BIGARRAY_C_LAYOUT | 
-			       BIGARRAY_MAPPED_FILE, 1, eff_addr, basize);
+    return caml_ba_alloc_dims(CAML_BA_UINT8 | CAML_BA_C_LAYOUT | 
+			       CAML_BA_MAPPED_FILE, 1, eff_addr, basize);
 #else
-    invalid_argument("Netsys_mem.memory_map_file not available");
+    caml_invalid_argument("Netsys_mem.memory_map_file not available");
 #endif
 }
 
@@ -254,20 +256,20 @@ static void ba_unmap_file(void * addr, uintnat len)
 
 CAMLprim value netsys_memory_unmap_file(value memv) 
 {
-    struct caml_bigarray *b = Bigarray_val(memv);
-    if ((b->flags & BIGARRAY_MANAGED_MASK) == BIGARRAY_MAPPED_FILE) {
+    struct caml_ba_array *b = Bigarray_val(memv);
+    if ((b->flags & CAML_BA_MANAGED_MASK) == CAML_BA_MAPPED_FILE) {
 	if (b->proxy == NULL) {
 	    ba_unmap_file(b->data, b->dim[0]);
 	    b->data = NULL;
 	    b->flags = 
-		(b->flags & ~BIGARRAY_MANAGED_MASK) | BIGARRAY_EXTERNAL;
+		(b->flags & ~CAML_BA_MANAGED_MASK) | CAML_BA_EXTERNAL;
 	}
 	else if (b->proxy->refcount == 1) {
 	    ba_unmap_file(b->proxy->data, b->dim[0]);
 	    b->proxy->data = NULL;
 	    b->data = NULL;
 	    b->flags = 
-		(b->flags & ~BIGARRAY_MANAGED_MASK) | BIGARRAY_EXTERNAL;
+		(b->flags & ~CAML_BA_MANAGED_MASK) | CAML_BA_EXTERNAL;
 	}
     }
     return Val_unit;
@@ -278,8 +280,8 @@ extern value caml_ba_reshape(value bv, value dimv);
 
 CAMLprim value netsys_reshape(value bv)
 {
-    struct caml_bigarray *b;
-    struct caml_bigarray *mem;
+    struct caml_ba_array *b;
+    struct caml_ba_array *mem;
     uintnat size;
     int i,k;
     CAMLparam1(bv);
@@ -291,7 +293,7 @@ CAMLprim value netsys_reshape(value bv)
        to call caml_ba_reshape, and to fix the returned bigarray descriptor
        afterward.
     */
-    dimv = alloc(b->num_dims,0);
+    dimv = caml_alloc(b->num_dims,0);
     for (k=0; k < b->num_dims; k++) {
 	Store_field(dimv, k, Val_long(b->dim[k]));
     };
@@ -347,6 +349,7 @@ CAMLprim value netsys_hdr_address(value objv)
     return caml_copy_nativeint((intnat) Hp_val(objv));
 }
 
+/*
 CAMLprim value netsys_color(value objv)
 {
     return Val_int(Color_hd(Hd_val(objv)) >> 8);
@@ -359,6 +362,7 @@ CAMLprim value netsys_set_color(value objv, value colv)
     Hd_val(objv) = Whitehd_hd(Hd_val(objv)) | (col << 8);
     return Val_unit;
 }
+*/
 
 /**********************************************************************/
 /* I/O with Bigarrays                                                 */
@@ -379,16 +383,16 @@ CAMLprim value netsys_mem_read(value fdv, value memv, value offv, value lenv)
 #ifdef _WIN32
     if (Descr_kind_val(fdv) == KIND_SOCKET) {
 	SOCKET h = Socket_val(fdv);
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	ret = recv(h, data, numbytes, 0);
 	if (ret == SOCKET_ERROR) err = WSAGetLastError();
-	leave_blocking_section();
+	caml_leave_blocking_section();
 	ret = n;
     } else {
 	HANDLE h = Handle_val(fdv);
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	if (! ReadFile(h, data, numbytes, &n, NULL)) err = GetLastError();
-	leave_blocking_section();
+	caml_leave_blocking_section();
 	ret = n;
     }
     if (err) {
@@ -396,11 +400,11 @@ CAMLprim value netsys_mem_read(value fdv, value memv, value offv, value lenv)
 	ret = -1;
     }
 #else
-    enter_blocking_section();
+    caml_enter_blocking_section();
     ret = read(Int_val(fdv), data, (int) numbytes);
-    leave_blocking_section();   /* keeps errno intact */
+    caml_leave_blocking_section();   /* keeps errno intact */
 #endif
-    if (ret == -1) uerror("mem_read", Nothing);
+    if (ret == -1) caml_uerror("mem_read", Nothing);
     return Val_long(ret);
 }
 
@@ -420,16 +424,16 @@ CAMLprim value netsys_mem_write(value fdv, value memv, value offv, value lenv)
 #ifdef _WIN32
     if (Descr_kind_val(fdv) == KIND_SOCKET) {
 	SOCKET h = Socket_val(fdv);
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	ret = send(h, data, numbytes, 0);
 	if (ret == SOCKET_ERROR) err = WSAGetLastError();
-	leave_blocking_section();
+	caml_leave_blocking_section();
 	ret = n;
     } else {
 	HANDLE h = Handle_val(fdv);
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	if (! WriteFile(h, data, numbytes, &n, NULL)) err = GetLastError();
-	leave_blocking_section();
+	caml_leave_blocking_section();
 	ret = n;
     }
     if (err) {
@@ -437,11 +441,11 @@ CAMLprim value netsys_mem_write(value fdv, value memv, value offv, value lenv)
 	ret = -1;
     }
 #else
-    enter_blocking_section();
+    caml_enter_blocking_section();
     ret = write(Int_val(fdv), data, (int) numbytes);
-    leave_blocking_section();
+    caml_leave_blocking_section();
 #endif
-    if (ret == -1) uerror("mem_write", Nothing);
+    if (ret == -1) caml_uerror("mem_write", Nothing);
     return Val_long(ret);
 }
 
@@ -467,7 +471,7 @@ CAMLprim value netsys_mem_recv(value fdv, value memv, value offv, value lenv,
 
     numbytes = Long_val(lenv);
     data = ((char *) (Bigarray_val(memv)->data)) + Long_val(offv);
-    flags = convert_flag_list(flagsv, msg_flag_table);
+    flags = caml_convert_flag_list(flagsv, msg_flag_table);
 
 #ifdef _WIN32
     s = Socket_val(fdv);
@@ -475,22 +479,22 @@ CAMLprim value netsys_mem_recv(value fdv, value memv, value offv, value lenv,
     s = Int_val(fdv);
 #endif
 
-    enter_blocking_section();
+    caml_enter_blocking_section();
     ret = recv(s, data, (int) numbytes, flags);
 
 #ifdef _WIN32
     if (ret == -1) err = WSAGetLastError();
-    leave_blocking_section();
+    caml_leave_blocking_section();
     if (ret == -1) win32_maperr(err);
 #else
-    leave_blocking_section();
+    caml_leave_blocking_section();
 #endif
 
-    if (ret == -1) uerror("mem_recv", Nothing);
+    if (ret == -1) caml_uerror("mem_recv", Nothing);
     return Val_long(ret);
 }
 
-
+/*
 CAMLprim value netsys_mem_send(value fdv, value memv, value offv, value lenv,
 			       value flagsv)
 {
@@ -507,7 +511,7 @@ CAMLprim value netsys_mem_send(value fdv, value memv, value offv, value lenv,
 
     numbytes = Long_val(lenv);
     data = ((char *) (Bigarray_val(memv)->data)) + Long_val(offv);
-    flags = convert_flag_list(flagsv, msg_flag_table);
+    flags = cam_caml_convert_flag_list(flagsv, msg_flag_table);
 
 #ifdef _WIN32
     s = Socket_val(fdv);
@@ -515,20 +519,21 @@ CAMLprim value netsys_mem_send(value fdv, value memv, value offv, value lenv,
     s = Int_val(fdv);
 #endif
 
-    enter_blocking_section();
+    caml_enter_blocking_section();
     ret = send(s, data, (int) numbytes, flags);
 
 #ifdef _WIN32
     if (ret == -1) err = WSAGetLastError();
-    leave_blocking_section();
+    caml_leave_blocking_section();
     if (ret == -1) win32_maperr(err);
 #else
-    leave_blocking_section();
+    caml_leave_blocking_section();
 #endif
 
-    if (ret == -1) uerror("mem_send", Nothing);
+    if (ret == -1) caml_uerror("mem_send", Nothing);
     return Val_long(ret);
 }
+*/
 
 
 /**********************************************************************/
@@ -537,44 +542,44 @@ CAMLprim value netsys_mem_send(value fdv, value memv, value offv, value lenv,
 
 CAMLprim value netsys_as_value(value memv, value offv) 
 {
-    struct caml_bigarray *b = Bigarray_val(memv);
+    struct caml_ba_array *b = Bigarray_val(memv);
     return (value) (b->data + Long_val(offv));
 }
 
 CAMLprim value netsys_value_area_add(value memv) 
 {
 #ifdef FANCY_PAGE_TABLES
-    struct caml_bigarray *b = Bigarray_val(memv);
+    struct caml_ba_array *b = Bigarray_val(memv);
     int code;
     code = caml_page_table_add(In_static_data,
 			       b->data,
 			       b->data + b->dim[0]);
     if (code != 0) 
-	failwith("Netsys_mem.value_area: error");
+	caml_failwith("Netsys_mem.value_area: error");
     return Val_unit;
 #else
-    invalid_argument("Netsys_mem.value_area");
+    caml_invalid_argument("Netsys_mem.value_area");
 #endif
 }
 
 CAMLprim value netsys_value_area_remove(value memv) 
 {
 #ifdef FANCY_PAGE_TABLES
-    struct caml_bigarray *b = Bigarray_val(memv);
+    struct caml_ba_array *b = Bigarray_val(memv);
     caml_page_table_remove(In_static_data,
                            b->data,
                            b->data + b->dim[0]);
     /* Silently ignore errors... */
     return Val_unit;
 #else
-    invalid_argument("Netsys_mem.value_area");
+    caml_invalid_argument("Netsys_mem.value_area");
 #endif
 }
 
 CAMLprim value netsys_init_header(value memv, value offv, value tagv,
 				  value sizev)
 {
-    struct caml_bigarray *b = Bigarray_val(memv);
+    struct caml_ba_array *b = Bigarray_val(memv);
     intnat off = Long_val(offv);
     intnat size = Long_val(sizev);
     int tag = Int_val(tagv);
@@ -582,10 +587,10 @@ CAMLprim value netsys_init_header(value memv, value offv, value tagv,
 
 #ifdef ARCH_SIXTYFOUR
     if (off % 8 != 0)
-	invalid_argument("Netsys_mem.init_header");
+	caml_invalid_argument("Netsys_mem.init_header");
 #else
     if (off % 4 != 0)
-	invalid_argument("Netsys_mem.init_header");
+	caml_invalid_argument("Netsys_mem.init_header");
 #endif
 
     m = (value *) (((char *) b->data) + off);
@@ -619,7 +624,7 @@ CAMLprim value netsys_cmp_string(value s1, value s2)
 
 CAMLprim value netsys_init_string(value memv, value offv, value lenv) 
 {
-    struct caml_bigarray *b = Bigarray_val(memv);
+    struct caml_ba_array *b = Bigarray_val(memv);
     intnat off = Long_val(offv);
     intnat len = Long_val(lenv);
     value *m;
@@ -629,10 +634,10 @@ CAMLprim value netsys_init_string(value memv, value offv, value lenv)
 
 #ifdef ARCH_SIXTYFOUR
     if (off % 8 != 0)
-	invalid_argument("Netsys_mem.init_string");
+	caml_invalid_argument("Netsys_mem.init_string");
 #else
     if (off % 4 != 0)
-	invalid_argument("Netsys_mem.init_string");
+	caml_invalid_argument("Netsys_mem.init_string");
 #endif
 
     m = (value *) (((char *) b->data) + off);
@@ -671,6 +676,7 @@ extern uintnat caml_allocated_words;
      2 = copy them to buffer memory
 */
 
+#if 0
 int netsys_init_value_1(struct htab *t,
 			struct nqueue *q,
 			char *dest,
@@ -1035,7 +1041,7 @@ int netsys_init_value_1(struct htab *t,
 			dest_cur += size_aligned;
 		    } else if (!simulation) {
 			data_header = NULL;
-			data_copy = stat_alloc(size_aligned);
+			data_copy = caml_stat_alloc(size_aligned);
 		    };
 
 		    if (!simulation) {
@@ -1134,6 +1140,7 @@ int netsys_init_value_1(struct htab *t,
 
     return 0;
 }
+#endif
 
 
 static int init_value_flags[] = { 1, 2, 4, 8, 16, 32 };
@@ -1198,6 +1205,7 @@ static void unprep_stat_queue(void)
 	netsys_queue_free(stat_queue);
 }
 
+#if 0
 
 value netsys_init_value(value memv, 
 			value offv, 
@@ -1254,8 +1262,8 @@ value netsys_init_value(value memv,
 	old_ops = ops;
 	pair = Field(target_custom_ops,0);
 	ops = (struct named_custom_ops*) 
-	          stat_alloc(sizeof(struct named_custom_ops));
-	ops->name = stat_alloc(caml_string_length(Field(pair,0))+1);
+	          caml_stat_alloc(sizeof(struct named_custom_ops));
+	ops->name = caml_stat_alloc(caml_string_length(Field(pair,0))+1);
 	strcmp(ops->name, String_val(Field(pair,0)));
 	ops->ops = (void *) Nativeint_val(Field(pair,1));
 	ops->next = old_ops;
@@ -1287,8 +1295,8 @@ value netsys_init_value(value memv,
 
     while (ops != NULL) {
 	next_ops = ops->next;
-	stat_free(ops->name);
-	stat_free(ops);
+	caml_stat_free(ops->name);
+	caml_stat_free(ops);
 	ops = next_ops;
     };
     
@@ -1304,16 +1312,16 @@ value netsys_init_value(value memv,
 
     switch(code) {
     case (-1):
-	unix_error(errno, "netsys_init_value", Nothing);
+	caml_unix_error(errno, "netsys_init_value", Nothing);
     case (-2):
 #ifdef DEBUG
         fprintf(stderr, "Lib err\n");
 #endif
-	failwith("Netsys_mem.init_value: Library error");
+	caml_failwith("Netsys_mem.init_value: Library error");
     case (-4):
 	caml_raise_constant(*caml_named_value("Netsys_mem.Out_of_space"));
     default:
-	failwith("Netsys_mem.init_value: Unknown error");
+	caml_failwith("Netsys_mem.init_value: Unknown error");
     }
 }
 
@@ -1389,7 +1397,7 @@ value netsys_copy_value(value flags, value orig)
     */
     bigarray_ops.name = BIGARRAY_MARSHAL_ID;
     bigarray_ops.ops = 
-	Custom_ops_val(alloc_bigarray_dims(CAML_BA_UINT8 | BIGARRAY_C_LAYOUT, 
+	Custom_ops_val(caml_ba_alloc_dims(CAML_BA_UINT8 | BIGARRAY_C_LAYOUT, 
 					   1, NULL, 1));
     bigarray_ops.next = &int32_ops;
 
@@ -1398,7 +1406,7 @@ value netsys_copy_value(value flags, value orig)
     int32_ops.next = &int64_ops;
 
     int64_ops.name = "_j";
-    int64_ops.ops = Custom_ops_val(caml_copy_int64(0));
+    int64_ops.ops = Custom_ops_val(caml_caml_copy_int64(0));
     int64_ops.next = &nativeint_ops;
 
     nativeint_ops.name = "_n";
@@ -1490,15 +1498,16 @@ value netsys_copy_value(value flags, value orig)
 
     switch(code) {
     case (-1):
-	unix_error(errno, "netsys_copy_value", Nothing);
+	caml_unix_error(errno, "netsys_copy_value", Nothing);
     case (-2):
-	failwith("Netsys_mem.copy_value: Library error");
+	caml_failwith("Netsys_mem.copy_value: Library error");
     case (-4):
 	caml_raise_constant(*caml_named_value("Netsys_mem.Out_of_space"));
     default:
-	failwith("Netsys_mem.copy_value: Unknown error");
+	caml_failwith("Netsys_mem.copy_value: Unknown error");
     }
 }
+#endif
 
 
 value netsys_get_custom_ops (value v) 
@@ -1509,12 +1518,12 @@ value netsys_get_custom_ops (value v)
 
     if (Is_block(v) && Tag_val(v) == Custom_tag) {
 	custom_ops = Custom_ops_val(v);
-	r = alloc_small(2,0);
+	r = caml_alloc_small(2,0);
 	Field(r,0) = caml_copy_string(custom_ops->identifier);
 	Field(r,1) = caml_copy_nativeint((intnat) custom_ops);
     }
     else 
-	invalid_argument("Netsys_mem.get_custom_ops");
+	caml_invalid_argument("Netsys_mem.get_custom_ops");
 
     CAMLreturn(r);
 }
diff --git code/src/netsys/netsys_c_multicast.c code/src/netsys/netsys_c_multicast.c
index 26c19bb6..5ec3dc2a 100644
--- code/src/netsys/netsys_c_multicast.c
+++ code/src/netsys/netsys_c_multicast.c
@@ -33,7 +33,7 @@ static int socket_domain(int fd) {
 
     l = sizeof(addr);
     if (getsockname(fd, &addr.s_gen, &l) == -1) 
-        uerror("getsockname", Nothing);
+        caml_uerror("getsockname", Nothing);
 
     switch (addr.s_gen.sa_family) {
     case AF_INET:
@@ -43,7 +43,7 @@ static int socket_domain(int fd) {
         return PF_INET6;
 #endif
     default:
-	invalid_argument("Not an Internet socket");
+	caml_invalid_argument("Not an Internet socket");
     }
 
     return 0;
@@ -77,11 +77,11 @@ CAMLprim value netsys_mcast_set_loop(value fd, value flag) {
 #endif
 #endif
     default:
-	invalid_argument("Netsys.mcast_set_loop");
+	caml_invalid_argument("Netsys.mcast_set_loop");
     };
 
     if (r == -1)
-        uerror("setsockopt",Nothing);
+        caml_uerror("setsockopt",Nothing);
 
     return Val_unit;
 }
@@ -93,7 +93,7 @@ CAMLprim value netsys_mcast_set_ttl(value fd, value ttl) {
 
 #ifdef _WIN32
     if (Descr_kind_val(fd) != KIND_SOCKET)
-	invalid_argument("Netsys.mcast_set_ttl");
+	caml_invalid_argument("Netsys.mcast_set_ttl");
     fd_sock = Socket_val(fd);
 #else
     fd_sock = Int_val(fd);
@@ -123,11 +123,11 @@ CAMLprim value netsys_mcast_set_ttl(value fd, value ttl) {
 #endif
 #endif
     default:
-	invalid_argument("Netsys.mcast_set_ttl");
+	caml_invalid_argument("Netsys.mcast_set_ttl");
     };
 
     if (r == -1)
-        uerror("setsockopt",Nothing);
+        caml_uerror("setsockopt",Nothing);
 
     return Val_unit;
 }
@@ -141,7 +141,7 @@ CAMLprim value netsys_mcast_add_membership(value fd,
 
 #ifdef _WIN32
     if (Descr_kind_val(fd) != KIND_SOCKET)
-	invalid_argument("Netsys.mcast_add_membership");
+	caml_invalid_argument("Netsys.mcast_add_membership");
     fd_sock = Socket_val(fd);
 #else
     fd_sock = Int_val(fd);
@@ -154,8 +154,8 @@ CAMLprim value netsys_mcast_add_membership(value fd,
 #ifdef IP_ADD_MEMBERSHIP
     case PF_INET: {
         struct ip_mreq mreq;
-        if (string_length(group_addr) != 4 || string_length(if_addr) != 4 )
-            invalid_argument("Netsys.mcast_add_membership: Not an IPV4 address");
+        if (caml_string_length(group_addr) != 4 || caml_string_length(if_addr) != 4 )
+            caml_invalid_argument("Netsys.mcast_add_membership: Not an IPV4 address");
         memcpy(&mreq.imr_multiaddr,
                &GET_INET_ADDR(group_addr),
                4);
@@ -173,8 +173,8 @@ CAMLprim value netsys_mcast_add_membership(value fd,
 #ifdef IPV6_ADD_MEMBERSHIP
     case PF_INET6: {
         struct ipv6_mreq mreq;
-        if (string_length(group_addr) != 16 || string_length(if_addr) != 16 )
-            invalid_argument("Netsys.mcast_add_membership: Not an IPV6 address");
+        if (caml_string_length(group_addr) != 16 || caml_string_length(if_addr) != 16 )
+            caml_invalid_argument("Netsys.mcast_add_membership: Not an IPV6 address");
         memcpy(&mreq.ipv6mr_multiaddr,
                &GET_INET6_ADDR(group_addr),
                16);
@@ -193,10 +193,10 @@ CAMLprim value netsys_mcast_add_membership(value fd,
 #endif
 #endif
     default:
-	invalid_argument("Netsys.mcast_add_membership");
+	caml_invalid_argument("Netsys.mcast_add_membership");
     };
     if (r == -1)
-        uerror("setsockopt",Nothing);
+        caml_uerror("setsockopt",Nothing);
 
     return Val_unit;
 }
@@ -210,7 +210,7 @@ CAMLprim value netsys_mcast_drop_membership(value fd,
 
 #ifdef _WIN32
     if (Descr_kind_val(fd) != KIND_SOCKET)
-	invalid_argument("Netsys.mcast_drop_membership");
+	caml_invalid_argument("Netsys.mcast_drop_membership");
     fd_sock = Socket_val(fd);
 #else
     fd_sock = Int_val(fd);
@@ -223,8 +223,8 @@ CAMLprim value netsys_mcast_drop_membership(value fd,
 #ifdef IP_DROP_MEMBERSHIP
     case PF_INET: {
         struct ip_mreq mreq;
-        if (string_length(group_addr) != 4 || string_length(if_addr) != 4 )
-            invalid_argument("Netsys.mcast_drop_membership: Not an IPV4 address");
+        if (caml_string_length(group_addr) != 4 || caml_string_length(if_addr) != 4 )
+            caml_invalid_argument("Netsys.mcast_drop_membership: Not an IPV4 address");
         memcpy(&mreq.imr_multiaddr,
                &GET_INET_ADDR(group_addr),
                4);
@@ -242,8 +242,8 @@ CAMLprim value netsys_mcast_drop_membership(value fd,
 #ifdef IPV6_DROP_MEMBERSHIP
     case PF_INET6: {
         struct ipv6_mreq mreq;
-        if (string_length(group_addr) != 16 || string_length(if_addr) != 16 )
-            invalid_argument("Netsys.mcast_drop_membership: Not an IPV6 address");
+        if (caml_string_length(group_addr) != 16 || caml_string_length(if_addr) != 16 )
+            caml_invalid_argument("Netsys.mcast_drop_membership: Not an IPV6 address");
         memcpy(&mreq.ipv6mr_multiaddr,
                &GET_INET6_ADDR(group_addr),
                16);
@@ -262,11 +262,11 @@ CAMLprim value netsys_mcast_drop_membership(value fd,
 #endif
 #endif
     default:
-	invalid_argument("Netsys.mcast_drop_membership");
+	caml_invalid_argument("Netsys.mcast_drop_membership");
     };
 
     if (r == -1)
-        uerror("setsockopt",Nothing);
+        caml_uerror("setsockopt",Nothing);
 
     return Val_unit;
 }
diff --git code/src/netsys/netsys_c_poll.c code/src/netsys/netsys_c_poll.c
index 61c3f388..8e386831 100644
--- code/src/netsys/netsys_c_poll.c
+++ code/src/netsys/netsys_c_poll.c
@@ -75,7 +75,7 @@ CAMLprim value netsys_mk_poll_mem(value n) {
     };
     return s;
 #else
-    invalid_argument("netsys_mk_poll_mem");
+    caml_invalid_argument("netsys_mk_poll_mem");
 #endif
 }
 
@@ -89,7 +89,7 @@ CAMLprim value netsys_set_poll_mem(value s, value k, value fd, value ev, value r
     (*(Poll_mem_val(s)))[Int_val(k)] = p;
     return Val_unit;
 #else
-    invalid_argument("netsys_set_poll_mem");
+    caml_invalid_argument("netsys_set_poll_mem");
 #endif
 
 }
@@ -106,7 +106,7 @@ CAMLprim value netsys_get_poll_mem(value s, value k) {
     Store_field(triple, 2, Val_int(p.revents));
     return triple;
 #else
-    invalid_argument("netsys_get_poll_mem");
+    caml_invalid_argument("netsys_get_poll_mem");
 #endif
 }
 
@@ -120,7 +120,7 @@ CAMLprim value netsys_blit_poll_mem(value s1, value k1, value s2, value k2, valu
     memmove(p2 + Int_val(k2), p1 + Int_val(k1), l*sizeof(struct pollfd));
     return Val_unit;
 #else
-    invalid_argument("netsys_blit_poll_mem");
+    caml_invalid_argument("netsys_blit_poll_mem");
 #endif
 };
 
@@ -148,15 +148,15 @@ CAMLprim value netsys_poll(value s, value nv, value tv) {
     n = Int_val(nv);
     tmo = Long_val(tv);
     
-    enter_blocking_section();
+    caml_enter_blocking_section();
     r = poll(p, n, tmo);
-    leave_blocking_section();
+    caml_leave_blocking_section();
 
-    if (r == -1) uerror("poll", Nothing);
+    if (r == -1) caml_uerror("poll", Nothing);
     
     return Val_int(r);
 #else
-     invalid_argument("netsys_poll");
+     caml_invalid_argument("netsys_poll");
 #endif
 }
 
@@ -224,12 +224,12 @@ CAMLprim value netsys_create_event_aggreg(value cancelv)
 
 #ifdef USABLE_EPOLL
     fd = epoll_create(128);
-    if (fd == -1) uerror("epoll_create", Nothing);
+    if (fd == -1) caml_uerror("epoll_create", Nothing);
     code = fcntl(fd, F_SETFD, FD_CLOEXEC);
     if (code == -1) {
 	e = errno;
 	close(fd);
-	unix_error(e, "fcntl", Nothing);
+	caml_unix_error(e, "fcntl", Nothing);
     };
     r = alloc_poll_aggreg();
     pa = *(Poll_aggreg_val(r));
@@ -243,14 +243,14 @@ CAMLprim value netsys_create_event_aggreg(value cancelv)
 	if (cancel_fd == -1) {
 	    e = errno;
 	    close(fd);
-	    unix_error(e, "eventfd", Nothing);
+	    caml_unix_error(e, "eventfd", Nothing);
 	};
 	code = fcntl(cancel_fd, F_SETFD, FD_CLOEXEC);
 	if (code == -1) {
 	    e = errno;
 	    close(fd);
 	    close(cancel_fd);
-	    unix_error(e, "fcntl", Nothing);
+	    caml_unix_error(e, "fcntl", Nothing);
 	};
 	ee.events = EPOLLIN;  /* not oneshot! */
 	ee.data.u64 = 1;  /* reserved value */
@@ -259,14 +259,14 @@ CAMLprim value netsys_create_event_aggreg(value cancelv)
 	    e = errno;
 	    close(fd);
 	    close(cancel_fd);
-	    unix_error(e, "epoll_ctl (ADD)", Nothing);
+	    caml_unix_error(e, "epoll_ctl (ADD)", Nothing);
 	};
 	pa->cancel_fd = cancel_fd;
     };
 #endif
     return r;
 #else
-    invalid_argument("Netsys_posix.create_event_aggregator not available");
+    caml_invalid_argument("Netsys_posix.create_event_aggregator not available");
 #endif
 }
 
@@ -279,14 +279,14 @@ CAMLprim value netsys_destroy_event_aggreg(value pav)
 
     pa = *(Poll_aggreg_val(pav));
     code = close(pa->fd);
-    if (code == -1) uerror("close", Nothing);
+    if (code == -1) caml_uerror("close", Nothing);
     if (pa->cancel_fd >= 0) {
 	code = close(pa->cancel_fd);
-	if (code == -1) uerror("close", Nothing);
+	if (code == -1) caml_uerror("close", Nothing);
     };
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.destroy_event_aggregator not available");
+    caml_invalid_argument("Netsys_posix.destroy_event_aggregator not available");
 #endif
 }
 
@@ -299,7 +299,7 @@ CAMLprim value netsys_event_aggreg_fd(value pav)
     pa = *(Poll_aggreg_val(pav));
     return Val_int(pa->fd);
 #else
-    invalid_argument("Netsys_posix.event_aggregator_fd not available");
+    caml_invalid_argument("Netsys_posix.event_aggregator_fd not available");
 #endif
 }
 
@@ -348,12 +348,12 @@ CAMLprim value netsys_add_event_source(value pav, value pushv)
 	translate_to_epoll_events(Int_val(Field(pushv, 2))) | EPOLLONESHOT;
     ee.data.u64 = Long_val(Field(pushv, 0)) << 1;
     code = epoll_ctl(pa->fd, EPOLL_CTL_ADD, fd, &ee);
-    if (code == -1) uerror("epoll_ctl (ADD)", Nothing);
+    if (code == -1) caml_uerror("epoll_ctl (ADD)", Nothing);
 #endif
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.add_event_source not available");
+    caml_invalid_argument("Netsys_posix.add_event_source not available");
 #endif
 }
 
@@ -373,12 +373,12 @@ CAMLprim value netsys_del_event_source(value pav, value idv, value tagv)
 
 #ifdef USABLE_EPOLL
     code = epoll_ctl(pa->fd, EPOLL_CTL_DEL, fd, &ee);
-    if (code == -1) uerror("epoll_ctl (DEL)", Nothing);
+    if (code == -1) caml_uerror("epoll_ctl (DEL)", Nothing);
 #endif
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.del_event_source not available");
+    caml_invalid_argument("Netsys_posix.del_event_source not available");
 #endif
 }
 
@@ -394,11 +394,11 @@ CAMLprim value netsys_interrupt_aggreg(value pav)
         int n;
 	buf = 1;
 	n = write(pa->cancel_fd, (char *) &buf, 8);
-        if (n == -1) uerror("write", Nothing);
+        if (n == -1) caml_uerror("write", Nothing);
     };
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.interrupt_event_aggregator not available");
+    caml_invalid_argument("Netsys_posix.interrupt_event_aggregator not available");
 #endif
 }
 
@@ -427,12 +427,12 @@ CAMLprim value netsys_push_event_sources(value pav, value pushlistv)
 	    EPOLLONESHOT;
 	ee.data.u64 = Long_val(Field(v_pushlist_hd, 0)) << 1;
 	code = epoll_ctl(pa->fd, EPOLL_CTL_MOD, fd, &ee);
-	if (code == -1) uerror("epoll_ctl (MOD)", Nothing);
+	if (code == -1) caml_uerror("epoll_ctl (MOD)", Nothing);
 #endif
     };
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.push_event_sources not available");
+    caml_invalid_argument("Netsys_posix.push_event_sources not available");
 #endif
 }
 
@@ -459,7 +459,7 @@ CAMLprim value netsys_poll_event_sources(value pav, value tmov)
     code = epoll_wait(pa->fd, ee, EPOLL_NUM, tmo);
     e = errno;
     caml_leave_blocking_section();
-    if (code == -1) unix_error(e, "epoll_wait", Nothing);
+    if (code == -1) caml_unix_error(e, "epoll_wait", Nothing);
 
     r = Val_int(0);
     for (k=0; k<code; k++) {
@@ -467,7 +467,7 @@ CAMLprim value netsys_poll_event_sources(value pav, value tmov)
 	    uint64_t buf;
             int n;
 	    n = read(pa->cancel_fd, (char *) &buf, 8);
-            if (n == -1) unix_error(errno, "read", Nothing);
+            if (n == -1) caml_unix_error(errno, "read", Nothing);
 	}
 	else {
 	    r_item = caml_alloc(3,0);
@@ -486,6 +486,6 @@ CAMLprim value netsys_poll_event_sources(value pav, value tmov)
 
     CAMLreturn(r);
 #else
-    invalid_argument("Netsys_posix.pull_event_sources not available");
+    caml_invalid_argument("Netsys_posix.pull_event_sources not available");
 #endif
 }
diff --git code/src/netsys/netsys_c_sem.c code/src/netsys/netsys_c_sem.c
index 97c68fb4..55d48ce7 100644
--- code/src/netsys/netsys_c_sem.c
+++ code/src/netsys/netsys_c_sem.c
@@ -3,6 +3,8 @@
 
 #include "netsys_c.h"
 
+#define Bigarray_val Caml_ba_array_val
+
 #if defined(HAVE_POSIX_SEM_ANON) || defined(HAVE_POSIX_SEM_NAMED)
 #include <limits.h>
 #include <semaphore.h>
@@ -120,16 +122,16 @@ CAMLprim value netsys_sem_open(value namev,
     int flags;
 
     init = Long_val(initv);
-    flags = convert_flag_list(flagsv, sem_open_flag_table);
+    flags = caml_convert_flag_list(flagsv, sem_open_flag_table);
     s = sem_open(String_val(namev),
 		 flags,
 		 Int_val(modev),
 		 init);
-    if (s == (sem_t *) SEM_FAILED) uerror("sem_open", namev);
+    if (s == (sem_t *) SEM_FAILED) caml_uerror("sem_open", namev);
     r = alloc_sem_block(s, 1);
     return r;
 #else
-    invalid_argument("Netsys.sem_open not available");
+    caml_invalid_argument("Netsys.sem_open not available");
 #endif
 }
 
@@ -141,13 +143,13 @@ CAMLprim value netsys_sem_close(value srv)
 
     sb = Sem_block_val(srv);
     if (sb->sem_ptr == NULL)
-	invalid_argument ("Netsys.sem_close: stale semaphore");
+	caml_invalid_argument ("Netsys.sem_close: stale semaphore");
     code = sem_close(sb->sem_ptr);
-    if (code == -1) uerror("sem_close", Nothing);
+    if (code == -1) caml_uerror("sem_close", Nothing);
     sb->sem_ptr = NULL;
     return Val_unit;
 #else
-    invalid_argument("Netsys.sem_close not available");
+    caml_invalid_argument("Netsys.sem_close not available");
 #endif
 }
 
@@ -156,10 +158,10 @@ CAMLprim value netsys_sem_unlink(value namev)
 #ifdef HAVE_POSIX_SEM_NAMED
     int code;
     code = sem_unlink(String_val(namev));
-    if (code == -1) uerror("sem_unlink", Nothing);
+    if (code == -1) caml_uerror("sem_unlink", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.sem_unlink not available");
+    caml_invalid_argument("Netsys.sem_unlink not available");
 #endif
 }
 
@@ -177,11 +179,11 @@ CAMLprim value netsys_sem_init(value memv,
     init = Long_val(initv);
     s = (sem_t *) (((char *) Bigarray_val(memv)->data) + Long_val(posv));
     code = sem_init(s, Bool_val(psharedv), init);
-    if (code == -1) uerror("sem_init", Nothing);
+    if (code == -1) caml_uerror("sem_init", Nothing);
     r = alloc_sem_block(s, 0);
     return r;
 #else
-    invalid_argument("Netsys.sem_init not available");
+    caml_invalid_argument("Netsys.sem_init not available");
 #endif
 }
 
@@ -196,7 +198,7 @@ CAMLprim value netsys_as_sem(value memv,
     r = alloc_sem_block(s, 0);
     return r;
 #else
-    invalid_argument("Netsys.as_sem not available");
+    caml_invalid_argument("Netsys.as_sem not available");
 #endif
 }
 
@@ -209,13 +211,13 @@ CAMLprim value netsys_sem_destroy(value srv)
 
     sb = Sem_block_val(srv);
     if (sb->sem_ptr == NULL)
-	invalid_argument ("Netsys.sem_destroy: stale semaphore");
+	caml_invalid_argument ("Netsys.sem_destroy: stale semaphore");
     code = sem_destroy(sb->sem_ptr);
-    if (code == -1) uerror("sem_destroy", Nothing);
+    if (code == -1) caml_uerror("sem_destroy", Nothing);
     sb->sem_ptr = NULL;
     return Val_unit;
 #else
-    invalid_argument("Netsys.sem_destroy not available");
+    caml_invalid_argument("Netsys.sem_destroy not available");
 #endif
 }
 
@@ -229,16 +231,16 @@ CAMLprim value netsys_sem_getvalue(value srv)
 
     sb = Sem_block_val(srv);
     if (sb->sem_ptr == NULL)
-	invalid_argument ("Netsys.sem_getvalue: stale semaphore");
+	caml_invalid_argument ("Netsys.sem_getvalue: stale semaphore");
     code = sem_getvalue(sb->sem_ptr, &sval);
-    if (code == -1) uerror("sem_getvalue", Nothing);
+    if (code == -1) caml_uerror("sem_getvalue", Nothing);
     if (sval < 0) sval = 0;
 #ifndef ARCH_SIXTYFOUR
-    if (sval > 1073741823) unix_error(EINVAL, "sem_getvalue", Nothing);
+    if (sval > 1073741823) caml_unix_error(EINVAL, "sem_getvalue", Nothing);
 #endif
     return Val_int(sval);
 #else
-    invalid_argument("Netsys.sem_getvalue not available");
+    caml_invalid_argument("Netsys.sem_getvalue not available");
 #endif
 }
 
@@ -250,12 +252,12 @@ CAMLprim value netsys_sem_post(value srv)
 
     sb = Sem_block_val(srv);
     if (sb->sem_ptr == NULL)
-	invalid_argument ("Netsys.sem_post: stale semaphore");
+	caml_invalid_argument ("Netsys.sem_post: stale semaphore");
     code = sem_post(sb->sem_ptr);
-    if (code == -1) uerror("sem_post", Nothing);
+    if (code == -1) caml_uerror("sem_post", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.sem_post not available");
+    caml_invalid_argument("Netsys.sem_post not available");
 #endif
 }
 
@@ -270,19 +272,19 @@ CAMLprim value netsys_sem_wait(value srv, value bv)
 
     sb = Sem_block_val(srv);
     if (sb->sem_ptr == NULL)
-	invalid_argument ("Netsys.sem_wait: stale semaphore");
+	caml_invalid_argument ("Netsys.sem_wait: stale semaphore");
     tag = Int_val(bv);
     s = sb->sem_ptr;
-    enter_blocking_section();
+    caml_enter_blocking_section();
     if (tag == 0)
 	code = sem_wait(s);
     else
 	code = sem_trywait(s);
-    leave_blocking_section();
-    if (code == -1) uerror("sem_wait", Nothing);
+    caml_leave_blocking_section();
+    if (code == -1) caml_uerror("sem_wait", Nothing);
     return Val_unit;
 #else
-    invalid_argument("Netsys.sem_wait not available");
+    caml_invalid_argument("Netsys.sem_wait not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_shm.c code/src/netsys/netsys_c_shm.c
index e65f99f2..5fa5b780 100644
--- code/src/netsys/netsys_c_shm.c
+++ code/src/netsys/netsys_c_shm.c
@@ -36,15 +36,15 @@ CAMLprim value netsys_shm_open(value path, value flags, value perm)
     int ret, cv_flags;
     char * p;
 
-    cv_flags = convert_flag_list(flags, shm_open_flag_table);
-    p = stat_alloc(string_length(path) + 1);
+    cv_flags = caml_convert_flag_list(flags, shm_open_flag_table);
+    p = caml_stat_alloc(caml_string_length(path) + 1);
     strcpy(p, String_val(path));
     ret = shm_open(p, cv_flags, Int_val(perm));
-    stat_free(p);
-    if (ret == -1) uerror("shm_open", path);
+    caml_stat_free(p);
+    if (ret == -1) caml_uerror("shm_open", path);
     CAMLreturn (Val_int(ret));
 #else
-    invalid_argument("Netsys.shm_open not available");
+    caml_invalid_argument("Netsys.shm_open not available");
 #endif
 }
 
@@ -55,10 +55,10 @@ CAMLprim value netsys_shm_unlink(value path)
     int ret;
 
     ret = shm_unlink(String_val(path));
-    if (ret == -1) uerror("shm_unlink", path);
+    if (ret == -1) caml_uerror("shm_unlink", path);
     return Val_unit;
 #else
-    invalid_argument("Netsys.shm_unlink not available");
+    caml_invalid_argument("Netsys.shm_unlink not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_spawn.c code/src/netsys/netsys_c_spawn.c
index 7ead37d8..cba4f635 100644
--- code/src/netsys/netsys_c_spawn.c
+++ code/src/netsys/netsys_c_spawn.c
@@ -25,8 +25,8 @@ typedef union {
 } marshalled_error;
 
 
-#define MAIN_ERROR(e,f) { uerror_errno = e; uerror_function = f; goto main_exit; }
-#define SUB_ERROR(e,f) { uerror_errno = e; uerror_function = f; goto sub_error; }
+#define MAIN_ERROR(e,f) { caml_uerror_errno = e; caml_uerror_function = f; goto main_exit; }
+#define SUB_ERROR(e,f) { caml_uerror_errno = e; caml_uerror_function = f; goto sub_error; }
 
 
 
@@ -44,8 +44,8 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
 				value v_cmd,
 				value v_args) {
 #if defined(HAVE_FORK_EXEC) && defined(HAVE_POSIX_SIGNALS)
-    int   uerror_errno;
-    char *uerror_function;
+    int   caml_uerror_errno;
+    char *caml_uerror_function;
     value return_value;
 
     int code;
@@ -88,7 +88,7 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
     int j, k, nofile;
     int fd1, fd2;
 
-    uerror_errno = 0;
+    caml_uerror_errno = 0;
     cleanup_mask = 0;
     cleanup_pipe0 = 0;
     cleanup_pipe1 = 0;
@@ -99,7 +99,7 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
     sub_argv = NULL;
     sub_env = NULL;
     return_value = Val_int(0);
-    uerror_function = "<uninit>";
+    caml_uerror_function = "<uninit>";
 
     nofile = sysconf(_SC_OPEN_MAX);
 
@@ -112,19 +112,19 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
        In the calling process, the mask is reset below at [exit].
     */
     code = sigfillset(&mask);
-    if (code == -1) unix_error(EINVAL, "netsys_spawn/sigfillset [000]", 
+    if (code == -1) caml_unix_error(EINVAL, "netsys_spawn/sigfillset [000]", 
 			       Nothing);
 #ifdef HAVE_PTHREAD
     code = pthread_sigmask(SIG_SETMASK, &mask, &save_mask);
-    if (code != 0) unix_error(code, "netsys_spawn/pthread_sigmask [001]", 
+    if (code != 0) caml_unix_error(code, "netsys_spawn/pthread_sigmask [001]", 
 			      Nothing);
 #else
     code = sigprocmask(SIG_SETMASK, &mask, &save_mask);
-    if (code == -1) uerror("netsys_spawn/sigprocmask [002]", Nothing);
+    if (code == -1) caml_uerror("netsys_spawn/sigprocmask [002]", Nothing);
 #endif
     memcpy(&spawn_mask, &save_mask, sizeof(sigset_t));
 
-    /* From now on, we don't jump out with uerror, but leave via "exit" 
+    /* From now on, we don't jump out with caml_uerror, but leave via "exit" 
        below.
     */
     cleanup_mask = 1;
@@ -156,7 +156,7 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
     /* caml_enter_blocking_section();
        cleanup_bsection = 1;
        -- TODO: check this more carefully before enabling it
-       -- see also leave_blocking_section below
+       -- see also caml_leave_blocking_section below
     */
 
     /* Fork the process. */
@@ -364,9 +364,9 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
     SUB_ERROR(EINVAL, "netsys_spawn/assert_execve [291]");
 
  sub_error:
-    /* Marshal the error in uerror_errno and uerror_function */
-    me.decoded.b_errno = uerror_errno;
-    strcpy(me.decoded.b_function, uerror_function);
+    /* Marshal the error in caml_uerror_errno and caml_uerror_function */
+    me.decoded.b_errno = caml_uerror_errno;
+    strcpy(me.decoded.b_function, caml_uerror_function);
     
     n = write(ctrl_pipe[1], me.buffer, sizeof(me.buffer));
     /* it doesn't make much sense here to check for write errors */
@@ -387,16 +387,16 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
 
     code = close(ctrl_pipe[1]);
     if (code == -1) {
-	uerror_errno = errno;
-	uerror_function = "netsys_spawn/close [300]";
+	caml_uerror_errno = errno;
+	caml_uerror_function = "netsys_spawn/close [300]";
 	goto main_exit;
     };
     cleanup_pipe1 = 0;   /* it's already closed */
 
     n = read(ctrl_pipe[0], me.buffer, sizeof(me.buffer));
     if (n == (ssize_t) -1) {
-	uerror_errno = errno;
-	uerror_function = "netsys_spawn/read [301]";
+	caml_uerror_errno = errno;
+	caml_uerror_function = "netsys_spawn/read [301]";
 	goto main_exit;
     };
 
@@ -408,8 +408,8 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
     
     /* There is an error message in me. Look at it. */
     if (n != (ssize_t) sizeof(me.buffer)) {
-	uerror_errno = EINVAL;
-	uerror_function = "netsys_spawn/assert_me [302]";
+	caml_uerror_errno = EINVAL;
+	caml_uerror_function = "netsys_spawn/assert_me [302]";
     }
 
     /* Also don't forget to wait on the child to avoid zombies: */
@@ -419,8 +419,8 @@ CAMLprim value netsys_spawn_nat(value v_chdir,
 	code = (code == -1 && errno == EINTR);
     };
 
-    uerror_errno = me.decoded.b_errno;
-    uerror_function = me.decoded.b_function;
+    caml_uerror_errno = me.decoded.b_errno;
+    caml_uerror_function = me.decoded.b_function;
     /* now exit... */
 
 main_exit:
@@ -435,32 +435,32 @@ main_exit:
     if (cleanup_mask) {
 #ifdef HAVE_PTHREAD
 	code = pthread_sigmask(SIG_SETMASK, &save_mask, NULL);
-	if (code != 0 && uerror_errno == 0) {
-	    uerror_errno = code;
-	    uerror_function = "netsys_spawn/pthread_sigmask [400]";
+	if (code != 0 && caml_uerror_errno == 0) {
+	    caml_uerror_errno = code;
+	    caml_uerror_function = "netsys_spawn/pthread_sigmask [400]";
 	}
 #else
 	code = sigprocmask(SIG_SETMASK, &save_mask, NULL);
-	if (code == -1 && uerror_errno == 0) {
-	    uerror_errno = errno;
-	    uerror_function = "netsys_spawn/sigprocmask [401]";
+	if (code == -1 && caml_uerror_errno == 0) {
+	    caml_uerror_errno = errno;
+	    caml_uerror_function = "netsys_spawn/sigprocmask [401]";
 	}
 #endif
     };
 
     if (cleanup_pipe0) {
 	code = close(ctrl_pipe[0]);
-	if (code == -1 && uerror_errno == 0) {
-	    uerror_errno = errno;
-	    uerror_function = "netsys_spawn/close [410]";
+	if (code == -1 && caml_uerror_errno == 0) {
+	    caml_uerror_errno = errno;
+	    caml_uerror_function = "netsys_spawn/close [410]";
 	}
     }
 
     if (cleanup_pipe1) {
 	code = close(ctrl_pipe[1]);
-	if (code == -1 && uerror_errno == 0) {
-	    uerror_errno = errno;
-	    uerror_function = "netsys_spawn/close [411]";
+	if (code == -1 && caml_uerror_errno == 0) {
+	    caml_uerror_errno = errno;
+	    caml_uerror_function = "netsys_spawn/close [411]";
 	}
     }
 
@@ -472,12 +472,12 @@ main_exit:
 	free(sub_env);
     }
 
-    if (uerror_errno != 0)
-	unix_error(uerror_errno, uerror_function, Nothing);
+    if (caml_uerror_errno != 0)
+	caml_unix_error(caml_uerror_errno, caml_uerror_function, Nothing);
 
     return return_value;
 #else
-     invalid_argument("netsys_spawn");
+     caml_invalid_argument("netsys_spawn");
 #endif
 }
 
@@ -505,8 +505,8 @@ CAMLprim value netsys_posix_spawn_nat(value v_pg,
 				      value v_cmd,
 				      value v_args) {
 #ifdef HAVE_POSIX_SPAWN
-    int   uerror_errno;
-    char *uerror_function;
+    int   caml_uerror_errno;
+    char *caml_uerror_function;
     value return_value;
     int code;
     short flags;
@@ -541,7 +541,7 @@ CAMLprim value netsys_posix_spawn_nat(value v_pg,
     long j,k;
     long nofile;
 
-    uerror_errno = 0;
+    caml_uerror_errno = 0;
     cleanup_sub_argv = 0;
     cleanup_sub_env = 0;
     cleanup_fd_actions = 0;
@@ -551,7 +551,7 @@ CAMLprim value netsys_posix_spawn_nat(value v_pg,
     sub_argv = NULL;
     sub_env = NULL;
     return_value = Val_int(0);
-    uerror_function = "<uninit>";
+    caml_uerror_function = "<uninit>";
     flags = 0;
     fd_known = 0;
     use_fork_exec = 0;
@@ -614,7 +614,7 @@ CAMLprim value netsys_posix_spawn_nat(value v_pg,
 	    flags |= POSIX_SPAWN_SETPGROUP;
 	    break;
 	case 2: /* Pg_new_fg_group */
-	    invalid_argument
+	    caml_invalid_argument
 		("Netsys_posix.posix_spawn: Pg_new_fg_group not supported");
 	    break;
 	default:
@@ -638,7 +638,7 @@ CAMLprim value netsys_posix_spawn_nat(value v_pg,
 	    flags |= POSIX_SPAWN_SETSIGDEF;
 	    break;
 	case 1: /* Sig_ignore */
-	    invalid_argument
+	    caml_invalid_argument
 		("Netsys_posix.posix_spawn: Sig_ignore not supported");
 	    break;
 	case 2: /* Sig_mask */
@@ -799,16 +799,16 @@ main_exit:
 	posix_spawnattr_destroy(&attr);
     };
 
-    if (uerror_errno != 0)
-	unix_error(uerror_errno, uerror_function, Nothing);
+    if (caml_uerror_errno != 0)
+	caml_unix_error(caml_uerror_errno, caml_uerror_function, Nothing);
 
     if (use_fork_exec != 0)
-	failwith("USE_FORK_EXEC");
+	caml_failwith("USE_FORK_EXEC");
 
     return return_value;
 
 #else
-     invalid_argument("netsys_posix_spawn not available");
+     caml_invalid_argument("netsys_posix_spawn not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_subprocess.c code/src/netsys/netsys_c_subprocess.c
index a9401753..a3cf4b11 100644
--- code/src/netsys/netsys_c_subprocess.c
+++ code/src/netsys/netsys_c_subprocess.c
@@ -282,7 +282,7 @@ CAMLprim value netsys_install_sigchld_handler(value dummy) {
 	    (struct sigchld_atom *) malloc(sigchld_list_len * 
 					   sizeof(struct sigchld_atom));
 	if (sigchld_list == NULL) 
-	    failwith("Cannot allocate memory");
+	    caml_failwith("Cannot allocate memory");
 
 	for (k=0; k<sigchld_list_len; k++)
 	    sigchld_list[k].pid = 0;
@@ -295,14 +295,14 @@ CAMLprim value netsys_install_sigchld_handler(value dummy) {
 	code = errno;
 	sigchld_unlock(1);
 	errno = code;
-	uerror("sigaction", Nothing);
+	caml_uerror("sigaction", Nothing);
     };
 
     sigchld_unlock(1);
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.install_subprocess_handler not available");
+    caml_invalid_argument("Netsys_posix.install_subprocess_handler not available");
 #endif
 }
 
@@ -349,17 +349,17 @@ CAMLprim value netsys_watch_subprocess(value pid_v, value pgid_v,
     int status, code, kill_flag;
     
     if (sigchld_list == NULL)
-	failwith("Netsys_posix.watch_subprocess: uninitialized");
+	caml_failwith("Netsys_posix.watch_subprocess: uninitialized");
 
     if (pipe(pfd) == -1)
-	uerror("pipe", Nothing);
+	caml_uerror("pipe", Nothing);
 
     if (fcntl(pfd[0], F_SETFD, FD_CLOEXEC) == -1) {
 	code = errno;
 	close(pfd[0]);
 	close(pfd[1]);
 	errno = code;
-	uerror("set_close_on_exec", Nothing);
+	caml_uerror("set_close_on_exec", Nothing);
     };
 
     if (fcntl(pfd[1], F_SETFD, FD_CLOEXEC) == -1) {
@@ -367,7 +367,7 @@ CAMLprim value netsys_watch_subprocess(value pid_v, value pgid_v,
 	close(pfd[0]);
 	close(pfd[1]);
 	errno = code;
-	uerror("set_close_on_exec", Nothing);
+	caml_uerror("set_close_on_exec", Nothing);
     };
 
     pid = Int_val(pid_v);
@@ -391,7 +391,7 @@ CAMLprim value netsys_watch_subprocess(value pid_v, value pgid_v,
 	if (sigchld_init_mt() == -1) {
 	    int saved_errno = errno;
 	    sigchld_unlock(1);
-	    unix_error(saved_errno,
+	    caml_unix_error(saved_errno,
 		       "netsys_watch_subprocess [delayed init]",
 		       Nothing);
 	}
@@ -425,7 +425,7 @@ CAMLprim value netsys_watch_subprocess(value pid_v, value pgid_v,
 	    sigchld_unlock(1);
 	    close(pfd[0]);
 	    close(pfd[1]);
-	    failwith("Cannot allocate memory");
+	    caml_failwith("Cannot allocate memory");
 	};
 
 	for (k=old_size; k<sigchld_list_len; k++)
@@ -444,7 +444,7 @@ CAMLprim value netsys_watch_subprocess(value pid_v, value pgid_v,
 	close(pfd[0]);
 	close(pfd[1]);
 	errno = code;
-	uerror("waitpid", Nothing);
+	caml_uerror("waitpid", Nothing);
     };
 
     if (code == 0) {  /* not yet terminated */
@@ -469,13 +469,13 @@ CAMLprim value netsys_watch_subprocess(value pid_v, value pgid_v,
 
     sigchld_unlock(1);
 
-    r = alloc(2,0);
+    r = caml_alloc(2,0);
     Field(r,0) = Val_int(pfd[0]);
     Field(r,1) = Val_int(atom_idx);
     
     return r;
 #else
-    invalid_argument("Netsys_posix.watch_subprocess not available");
+    caml_invalid_argument("Netsys_posix.watch_subprocess not available");
 #endif
 }
 
@@ -498,7 +498,7 @@ CAMLprim value netsys_ignore_subprocess(value atom_idx_v) {
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.ignore_subprocess not available");
+    caml_invalid_argument("Netsys_posix.ignore_subprocess not available");
 #endif
 }
 
@@ -521,7 +521,7 @@ CAMLprim value netsys_forget_subprocess(value atom_idx_v) {
 
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.forget_subprocess not available");
+    caml_invalid_argument("Netsys_posix.forget_subprocess not available");
 #endif
 }
 
@@ -554,15 +554,15 @@ CAMLprim value netsys_get_subprocess_status(value atom_idx_v) {
 
     if (copy.terminated) {
 	if (WIFEXITED(copy.status)) {
-	    st = alloc_small(1, TAG_WEXITED);
+	    st = caml_alloc_small(1, TAG_WEXITED);
 	    Field(st, 0) = Val_int(WEXITSTATUS(copy.status));
 	}
 	else {
-	    st = alloc_small(1, TAG_WSIGNALED);
+	    st = caml_alloc_small(1, TAG_WSIGNALED);
 	    Field(st, 0) = 
 		Val_int(caml_rev_convert_signal_number(WTERMSIG(copy.status)));
 	};
-	r = alloc(1,0);
+	r = caml_alloc(1,0);
 	Field(r, 0) = st;
     }
     else {
@@ -571,7 +571,7 @@ CAMLprim value netsys_get_subprocess_status(value atom_idx_v) {
 
     return r;
 #else
-    invalid_argument("Netsys_posix.forget_subprocess not available");
+    caml_invalid_argument("Netsys_posix.forget_subprocess not available");
 #endif
 }
 
@@ -597,7 +597,7 @@ CAMLprim value netsys_kill_subprocess(value sig_v, value atom_idx_v) {
     return Val_unit;
 
 #else
-    invalid_argument("Netsys_posix.kill_subprocess not available");
+    caml_invalid_argument("Netsys_posix.kill_subprocess not available");
 #endif
 }
 
@@ -634,7 +634,7 @@ CAMLprim value netsys_killpg_subprocess(value sig_v, value atom_idx_v) {
     return Val_unit;
 
 #else
-    invalid_argument("Netsys_posix.killpg_subprocess not available");
+    caml_invalid_argument("Netsys_posix.killpg_subprocess not available");
 #endif
 }
 
@@ -648,7 +648,7 @@ CAMLprim value netsys_kill_all_subprocesses(value sig_v, value o_flag_v,
     int k;
 
     if (sigchld_list == NULL)
-	failwith("Netsys_posix.watch_subprocess: uninitialized");
+	caml_failwith("Netsys_posix.watch_subprocess: uninitialized");
 
     sig = caml_convert_signal_number(Int_val(sig_v));
     o_flag = Bool_val(o_flag_v);
@@ -672,7 +672,7 @@ CAMLprim value netsys_kill_all_subprocesses(value sig_v, value o_flag_v,
     return Val_unit;
 
 #else
-    invalid_argument("Netsys_posix.kill_all_subprocesses not available");
+    caml_invalid_argument("Netsys_posix.kill_all_subprocesses not available");
 #endif
 }
 
@@ -686,7 +686,7 @@ CAMLprim value netsys_killpg_all_subprocesses(value sig_v, value o_flag_v) {
     pid_t pgid;
 
     if (sigchld_list == NULL)
-	failwith("Netsys_posix.watch_subprocess: uninitialized");
+	caml_failwith("Netsys_posix.watch_subprocess: uninitialized");
 
     sig = caml_convert_signal_number(Int_val(sig_v));
     o_flag = Bool_val(o_flag_v);
@@ -722,7 +722,7 @@ CAMLprim value netsys_killpg_all_subprocesses(value sig_v, value o_flag_v) {
     return Val_unit;
 
 #else
-    invalid_argument("Netsys_posix.killpg_all_subprocesses not available");
+    caml_invalid_argument("Netsys_posix.killpg_all_subprocesses not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_syslog.c code/src/netsys/netsys_c_syslog.c
index 4552fe7d..f59ae47d 100644
--- code/src/netsys/netsys_c_syslog.c
+++ code/src/netsys/netsys_c_syslog.c
@@ -86,7 +86,7 @@ CAMLprim value netsys_openlog(value ident,
     id=NULL;
     if (Is_block(ident)) {
 	if (ident_buf == NULL) {
-	    ident_buf = stat_alloc(IDENT_BUF_LEN);
+	    ident_buf = caml_stat_alloc(IDENT_BUF_LEN);
 	};
 	strncpy(ident_buf, 
 		String_val(Field(ident, 0)),
@@ -94,12 +94,12 @@ CAMLprim value netsys_openlog(value ident,
 	ident_buf[IDENT_BUF_LEN-1] = 0;
 	id=ident_buf;
     };
-    options = convert_flag_list(opts, syslog_opt_flags);
+    options = caml_convert_flag_list(opts, syslog_opt_flags);
     facility = syslog_fac_flags[Int_val(fac)];
     openlog(id, options, facility);
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.openlog not available");
+    caml_invalid_argument("Netsys_posix.openlog not available");
 #endif
 }
 
@@ -114,7 +114,7 @@ CAMLprim value netsys_syslog(value fac, value lev, value msg)
     syslog(facility | level, "%s", String_val(msg));
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.syslog not available");
+    caml_invalid_argument("Netsys_posix.syslog not available");
 #endif
 }
 
@@ -125,7 +125,7 @@ CAMLprim value netsys_closelog(value dummy)
     closelog();
     return Val_unit;
 #else
-    invalid_argument("Netsys_posix.closelog not available");
+    caml_invalid_argument("Netsys_posix.closelog not available");
 #endif
 }
 
diff --git code/src/netsys/netsys_c_win32.c code/src/netsys/netsys_c_win32.c
index 0043336c..1f60c32f 100644
--- code/src/netsys/netsys_c_win32.c
+++ code/src/netsys/netsys_c_win32.c
@@ -45,19 +45,19 @@ CAMLprim value netsys_fill_random (value s) {
 				 PROV_RSA_FULL,
 				 CRYPT_VERIFYCONTEXT)) {
 	    win32_maperr(GetLastError());
-	    uerror("netsys_fill_random/CryptAcquireContext", Nothing);
+	    caml_uerror("netsys_fill_random/CryptAcquireContext", Nothing);
 	};
 	crypt_provider_init = 1;
     }
     if(!CryptGenRandom(crypt_provider,
-		       string_length(s),
+		       caml_string_length(s),
 		       String_val(s))) {
 	win32_maperr(GetLastError());
-	uerror("netsys_fill_random/CryptGenRandom", Nothing);
+	caml_uerror("netsys_fill_random/CryptGenRandom", Nothing);
     };
     return Val_unit;
 #else
-    invalid_argument("netsys_fill_random");
+    caml_invalid_argument("netsys_fill_random");
 #endif
 }
 
@@ -72,11 +72,11 @@ CAMLprim value netsys_get_full_path_name(value path) {
                         buffer,
                         NULL) == 0) {
         win32_maperr(GetLastError());
-	uerror("GetFullPathName", Nothing);
+	caml_uerror("GetFullPathName", Nothing);
     };
     return caml_copy_string(buffer);
 #else
-    invalid_argument("netsys_get_full_path_name");
+    caml_invalid_argument("netsys_get_full_path_name");
 #endif
 }
 
@@ -90,11 +90,11 @@ CAMLprim value netsys_get_long_path_name(value path) {
                         buffer, 
                         4096) == 0) {
         win32_maperr(GetLastError());
-	uerror("GetLongPathName", Nothing);
+	caml_uerror("GetLongPathName", Nothing);
     };
     return caml_copy_string(buffer);
 #else
-    invalid_argument("netsys_get_long_path_name");
+    caml_invalid_argument("netsys_get_long_path_name");
 #endif
 }
 
@@ -108,11 +108,11 @@ CAMLprim value netsys_modify_close_on_exec (value fd, value new_val) {
     if (!SetHandleInformation(Handle_val(fd), HANDLE_FLAG_INHERIT,
 			      flag ? 0 : HANDLE_FLAG_INHERIT)) {
 	win32_maperr(GetLastError());
-	uerror("netsys_modify_close_on_exec/SetHandleInformation", Nothing);
+	caml_uerror("netsys_modify_close_on_exec/SetHandleInformation", Nothing);
     }
     return Val_unit;
 #else
-    invalid_argument("netsys_modify_close_on_exec");
+    caml_invalid_argument("netsys_modify_close_on_exec");
 #endif
 }
 
@@ -124,14 +124,14 @@ CAMLprim value netsys_test_close_on_exec (value fd) {
     dprintf("netsys_test_close_on_exec fd=%u\n", Handle_val(fd));
     if (!GetHandleInformation(Handle_val(fd), &flags)) {
 	win32_maperr(GetLastError());
-	uerror("netsys_test_close_on_exec/GetHandleInformation", Nothing);
+	caml_uerror("netsys_test_close_on_exec/GetHandleInformation", Nothing);
     }
     r = (flags & HANDLE_FLAG_INHERIT) != 0;
     dprintf("netsys_test_close_on_exec fd=%u result=%s\n", 
 	    Handle_val(fd), r ? "true" : "false");
     return Val_bool(r);
 #else
-    invalid_argument("netsys_test_close_on_exec");
+    caml_invalid_argument("netsys_test_close_on_exec");
 #endif
 }
 
@@ -145,7 +145,7 @@ CAMLprim value netsys_is_crt_fd (value fd, value crt_fd) {
     else
 	return Val_bool(fd1 == Int_val(crt_fd));
 #else
-    invalid_argument("netsys_is_crt_fd");
+    caml_invalid_argument("netsys_is_crt_fd");
 #endif
 }
 
@@ -193,7 +193,7 @@ static value alloc_event(HANDLE e) {
 			   DUPLICATE_SAME_ACCESS);
     if (!flag) {
 	win32_maperr(GetLastError());
-	uerror("alloc_event/DuplicateHandle", Nothing);
+	caml_uerror("alloc_event/DuplicateHandle", Nothing);
     };
 
     r = caml_alloc_custom(&event_ops, sizeof(struct event), 1, 0);
@@ -219,12 +219,12 @@ CAMLprim value netsys_create_event(value dummy) {
     e = CreateEvent(NULL, 1, 0, NULL);
     if (e == NULL) {
 	win32_maperr(GetLastError());
-	uerror("netsys_create_event/CreateEvent", Nothing);
+	caml_uerror("netsys_create_event/CreateEvent", Nothing);
     };
 
     return alloc_event(e);
 #else
-    invalid_argument("netsys_create_event");
+    caml_invalid_argument("netsys_create_event");
 #endif
 }
 
@@ -246,7 +246,7 @@ CAMLprim value netsys_close_event(value ev) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_close_event");
+    caml_invalid_argument("netsys_close_event");
 #endif
 }
 
@@ -259,7 +259,7 @@ CAMLprim value netsys_set_auto_close_event_proxy(value ev, value flag) {
     e->auto_close = Bool_val(flag);
     return Val_unit;
 #else
-    invalid_argument("netsys_set_auto_close_event_proxy");
+    caml_invalid_argument("netsys_set_auto_close_event_proxy");
 #endif
 }
 
@@ -271,12 +271,12 @@ CAMLprim value netsys_set_event(value ev) {
     e = event_val(ev);
     if (!SetEvent(e->ev)) {
 	win32_maperr(GetLastError());
-	uerror("netsys_set_event/SetEvent", Nothing);
+	caml_uerror("netsys_set_event/SetEvent", Nothing);
     }
 
     return Val_unit;
 #else
-    invalid_argument("netsys_set_event");
+    caml_invalid_argument("netsys_set_event");
 #endif
 }
 
@@ -287,12 +287,12 @@ CAMLprim value netsys_reset_event(value ev) {
     e = event_val(ev);
     if (!ResetEvent(e->ev)) {
 	win32_maperr(GetLastError());
-	uerror(" netsys_reset_event/ResetEvent", Nothing);
+	caml_uerror(" netsys_reset_event/ResetEvent", Nothing);
     }
 
     return Val_unit;
 #else
-    invalid_argument("netsys_reset_event");
+    caml_invalid_argument("netsys_reset_event");
 #endif
 }
 
@@ -307,12 +307,12 @@ CAMLprim value netsys_test_event(value ev) {
     n = WaitForSingleObject(e->ev, 0);
     if (n == WAIT_FAILED) {
 	win32_maperr(GetLastError());
-	uerror("netsys_test_event/WaitForSingleObject", Nothing);
+	caml_uerror("netsys_test_event/WaitForSingleObject", Nothing);
     };
 
     return Val_bool(n == WAIT_OBJECT_0);
 #else
-    invalid_argument("netsys_test_event");
+    caml_invalid_argument("netsys_test_event");
 #endif
 }
 
@@ -331,18 +331,18 @@ CAMLprim value netsys_event_wait(value ev, value tmo) {
     };
 
     e = event_val(ev);
-    enter_blocking_section();
+    caml_enter_blocking_section();
     n = WaitForSingleObject(e->ev, wtmo);
     err = GetLastError();
-    leave_blocking_section();
+    caml_leave_blocking_section();
     if (n == WAIT_FAILED) {
 	win32_maperr(err);
-	uerror("netsys_event_wait/WaitForSingleObject", Nothing);
+	caml_uerror("netsys_event_wait/WaitForSingleObject", Nothing);
     };
 
     return Val_bool(n == WAIT_OBJECT_0);
 #else
-    invalid_argument("netsys_event_wait");
+    caml_invalid_argument("netsys_event_wait");
 #endif
 }
 
@@ -353,7 +353,7 @@ CAMLprim value netsys_event_descr(value ev) {
     e = event_val(ev);
     return netsysw32_win_alloc_handle(e->ev_proxy);
 #else
-    invalid_argument("netsys_event_descr");
+    caml_invalid_argument("netsys_event_descr");
 #endif
 }
 
@@ -378,12 +378,12 @@ CAMLprim value netsys_wsa_event_select(value ev, value fdv, value evmaskv) {
 
     if (WSAEventSelect(s, e->ev, m_win32) != 0) {
 	win32_maperr(WSAGetLastError());
-	uerror("netsys_wsa_event_select/WSAEventSelect", Nothing);
+	caml_uerror("netsys_wsa_event_select/WSAEventSelect", Nothing);
     }
 
     return Val_unit;
 #else
-    invalid_argument("netsys_wsa_event_select");
+    caml_invalid_argument("netsys_wsa_event_select");
 #endif
 }
 
@@ -391,7 +391,7 @@ CAMLprim value netsys_wsa_maximum_wait_events(value dummy) {
 #ifdef _WIN32
     return Val_int(WSA_MAXIMUM_WAIT_EVENTS);
 #else
-    invalid_argument("netsys_wsa_maximum_wait_events");
+    caml_invalid_argument("netsys_wsa_maximum_wait_events");
 #endif
 }
 
@@ -413,7 +413,7 @@ CAMLprim value netsys_wsa_wait_for_multiple_events(value fdarray, value tmov) {
 
     if (n > WSA_MAXIMUM_WAIT_EVENTS) {
 	win32_maperr(EINVAL);
-	uerror("netsys_wsa_wait_for_multiple_events", Nothing);
+	caml_uerror("netsys_wsa_wait_for_multiple_events", Nothing);
     };
 
     for (k=0; k < n; k++) {
@@ -428,13 +428,13 @@ CAMLprim value netsys_wsa_wait_for_multiple_events(value fdarray, value tmov) {
 	    tmo = tmo0;
 	else
 	    tmo = INFINITE;
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	r = SleepEx(tmo, 1);
-	leave_blocking_section();
+	caml_leave_blocking_section();
 	
 	if (r == WAIT_IO_COMPLETION) {
 	    win32_maperr(EINTR);
-	    uerror("netsys_wsa_wait_for_multiple_events/SleepEx", Nothing);
+	    caml_uerror("netsys_wsa_wait_for_multiple_events/SleepEx", Nothing);
 	}
 
 	return Val_int(0);    /* None */
@@ -445,10 +445,10 @@ CAMLprim value netsys_wsa_wait_for_multiple_events(value fdarray, value tmov) {
 	else
 	    tmo = INFINITE;
 	dprintf("WSAWaitForMultipleEvents start tmo=%u\n", tmo);
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	r = WSAWaitForMultipleEvents(n, earray, 0, tmo, 1);
 	err = WSAGetLastError();
-	leave_blocking_section();
+	caml_leave_blocking_section();
 	dprintf("WSAWaitForMultipleEvents end code=%u\n", r);
     
 	if (r == WSA_WAIT_FAILED) {
@@ -457,7 +457,7 @@ CAMLprim value netsys_wsa_wait_for_multiple_events(value fdarray, value tmov) {
 	    if (err == 0) 
 		return Val_int(0);
 	    win32_maperr(err);
-	    uerror("netsys_wsa_wait_for_multiple_events/WSAWaitForMultipleEvents", Nothing);
+	    caml_uerror("netsys_wsa_wait_for_multiple_events/WSAWaitForMultipleEvents", Nothing);
 	}
 	
 	if (r == WSA_WAIT_TIMEOUT)
@@ -466,7 +466,7 @@ CAMLprim value netsys_wsa_wait_for_multiple_events(value fdarray, value tmov) {
 	if (r == WSA_WAIT_IO_COMPLETION) {
 	    dprintf("WSAWaitForMultipleEvents error=EINTR\n");
 	    win32_maperr(EINTR);
-	    uerror("netsys_wsa_wait_for_multiple_events/WSAWaitForMultipleEvents", Nothing);
+	    caml_uerror("netsys_wsa_wait_for_multiple_events/WSAWaitForMultipleEvents", Nothing);
 	}
 	
 	if (r >= WSA_WAIT_EVENT_0 && r < WSA_WAIT_EVENT_0 + n) {
@@ -476,9 +476,9 @@ CAMLprim value netsys_wsa_wait_for_multiple_events(value fdarray, value tmov) {
 	}
     }
     
-    invalid_argument("netsys_wsa_wait_for_multiple_events: bad return value from Win32");
+    caml_invalid_argument("netsys_wsa_wait_for_multiple_events: bad return value from Win32");
 #else
-    invalid_argument("netsys_wsa_wait_for_multiple_events");
+    caml_invalid_argument("netsys_wsa_wait_for_multiple_events");
 #endif
 }
 
@@ -494,7 +494,7 @@ CAMLprim value netsys_wsa_enum_network_events(value fdv, value ev) {
 
     if (WSAEnumNetworkEvents(s, e->ev, &ne) != 0) {
 	win32_maperr(WSAGetLastError());
-	uerror("netsys_wsa_enum_network_events/WSAEnumNetworkEvents", Nothing);
+	caml_uerror("netsys_wsa_enum_network_events/WSAEnumNetworkEvents", Nothing);
     }
 
     /* printf("NetworkEvents=%ld\n", ne.lNetworkEvents); */
@@ -538,7 +538,7 @@ CAMLprim value netsys_wsa_enum_network_events(value fdv, value ev) {
 
     return Val_int(r);
 #else
-    invalid_argument("netsys_wsa_enum_network_events");
+    caml_invalid_argument("netsys_wsa_enum_network_events");
 #endif
 }
 
@@ -611,35 +611,35 @@ static struct pipe_helper * alloc_pipe_helper (HANDLE h, HANDLE cn_ev) {
     rd_ev = CreateEvent(NULL, 1, 0, NULL);
     if (rd_ev == NULL) {
 	win32_maperr(GetLastError());
-	uerror("alloc_pipe_helper/CreateEvent", Nothing);
+	caml_uerror("alloc_pipe_helper/CreateEvent", Nothing);
     };
 
     wr_ev = CreateEvent(NULL, 1, 0, NULL);
     if (wr_ev == NULL) {
 	win32_maperr(GetLastError());
-	uerror("alloc_pipe_helper/CreateEvent", Nothing);
+	caml_uerror("alloc_pipe_helper/CreateEvent", Nothing);
     };
 
     pd = CreateEvent(NULL, 1, 0, NULL);
     if (pd == NULL) {
 	win32_maperr(GetLastError());
-	uerror("alloc_pipe_helper/CreateEvent", Nothing);
+	caml_uerror("alloc_pipe_helper/CreateEvent", Nothing);
     };
 
-    rd_ovrlp = stat_alloc(sizeof(OVERLAPPED));
+    rd_ovrlp = caml_stat_alloc(sizeof(OVERLAPPED));
     ZeroMemory(rd_ovrlp, sizeof(OVERLAPPED));
     rd_ovrlp->hEvent = rd_ev;
 
-    wr_ovrlp = stat_alloc(sizeof(OVERLAPPED));
+    wr_ovrlp = caml_stat_alloc(sizeof(OVERLAPPED));
     ZeroMemory(wr_ovrlp, sizeof(OVERLAPPED));
     wr_ovrlp->hEvent = wr_ev;
 
-    cn_ovrlp = stat_alloc(sizeof(OVERLAPPED));
+    cn_ovrlp = caml_stat_alloc(sizeof(OVERLAPPED));
     ZeroMemory(cn_ovrlp, sizeof(OVERLAPPED));
     if (cn_ev != INVALID_HANDLE_VALUE)
 	cn_ovrlp->hEvent = cn_ev;
 
-    ph = stat_alloc(sizeof(struct pipe_helper));
+    ph = caml_stat_alloc(sizeof(struct pipe_helper));
     ph->pipe_handle = h;
     ph->pipe_is_open = 1;
     ph->pipe_is_server = 0;
@@ -680,10 +680,10 @@ static void free_pipe_helper(struct pipe_helper *ph) {
     if (ph->pipe_cn_ev != INVALID_HANDLE_VALUE)
 	CloseHandle(ph->pipe_cn_ev);
     /* do nothing about pipe_signal */
-    stat_free(ph->pipe_rd_ovrlp);
-    stat_free(ph->pipe_wr_ovrlp);
-    stat_free(ph->pipe_cn_ovrlp);
-    stat_free(ph);
+    caml_stat_free(ph->pipe_rd_ovrlp);
+    caml_stat_free(ph->pipe_wr_ovrlp);
+    caml_stat_free(ph->pipe_cn_ovrlp);
+    caml_stat_free(ph);
 }
 
 
@@ -888,7 +888,7 @@ void setup_sid(void) {
 				     &world_sid);
 	if (e == 0) {
 	    win32_maperr(GetLastError());
-	    uerror("setup_sid/AllocateAndInitializeSid", Nothing);
+	    caml_uerror("setup_sid/AllocateAndInitializeSid", Nothing);
 	};
     };
 
@@ -899,7 +899,7 @@ void setup_sid(void) {
 				     &network_sid);
 	if (e == 0) {
 	    win32_maperr(GetLastError());
-	    uerror("setup_sid/AllocateAndInitializeSid", Nothing);
+	    caml_uerror("setup_sid/AllocateAndInitializeSid", Nothing);
 	};
     }
 }
@@ -950,7 +950,7 @@ CAMLprim value netsys_create_local_named_pipe(value name, value mode,
 			NULL);
     if ( h == INVALID_HANDLE_VALUE ) {
 	win32_maperr(GetLastError());
-	uerror("netsys_create_local_named_pipe/CreateNamedPipe", Nothing);
+	caml_uerror("netsys_create_local_named_pipe/CreateNamedPipe", Nothing);
     }
 
     // ACE's must be added to pipe's DACL for:
@@ -997,14 +997,14 @@ CAMLprim value netsys_create_local_named_pipe(value name, value mode,
     if (e != ERROR_SUCCESS) {
 	win32_maperr(GetLastError());
 	CloseHandle(h);
-	uerror("netsys_create_local_named_pipe/GetSecurityInfo", Nothing);
+	caml_uerror("netsys_create_local_named_pipe/GetSecurityInfo", Nothing);
     };
 
     e = SetEntriesInAcl(2, explicit_access_list, pACL, &pNewACL);
     if (e != ERROR_SUCCESS) {
 	win32_maperr(GetLastError());
 	CloseHandle(h);
-	uerror("netsys_create_local_named_pipe/SetEntriesinAcl", Nothing);
+	caml_uerror("netsys_create_local_named_pipe/SetEntriesinAcl", Nothing);
     };
 
     e = SetSecurityInfo(h, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, 
@@ -1013,7 +1013,7 @@ CAMLprim value netsys_create_local_named_pipe(value name, value mode,
 	win32_maperr(GetLastError());
 	LocalFree(pNewACL);
 	CloseHandle(h);
-	uerror("netsys_create_local_named_pipe/SetSecurityInfo", Nothing);
+	caml_uerror("netsys_create_local_named_pipe/SetSecurityInfo", Nothing);
     };
 
     LocalFree(pNewACL);
@@ -1032,7 +1032,7 @@ CAMLprim value netsys_create_local_named_pipe(value name, value mode,
 	    ph->pipe_handle);
     return r;
 #else
-    invalid_argument("netsys_create_local_named_pipe");
+    caml_invalid_argument("netsys_create_local_named_pipe");
 #endif
 }
 
@@ -1053,22 +1053,22 @@ CAMLprim value netsys_pipe_listen(value phv) {
 
     if (!ph->pipe_is_open) {
 	errno = EBADF;
-	uerror("netsys_pipe_listen", Nothing);
+	caml_uerror("netsys_pipe_listen", Nothing);
     };
 
     if (!ph->pipe_is_server) {
 	errno = EPERM;
-	uerror("netsys_pipe_listen", Nothing);
+	caml_uerror("netsys_pipe_listen", Nothing);
     };
 
     if (ph->pipe_conn_state != PIPE_DEAF) {
 	errno = EISCONN;
-	uerror("netsys_pipe_listen", Nothing);
+	caml_uerror("netsys_pipe_listen", Nothing);
     };
 
     if (ph->pipe_cn_ovrlp_started) {
 	errno = EALREADY;
-	uerror("netsys_pipe_listen", Nothing);
+	caml_uerror("netsys_pipe_listen", Nothing);
     };
 
     dprintf("PIPE listen %u connecting\n",
@@ -1085,7 +1085,7 @@ CAMLprim value netsys_pipe_listen(value phv) {
 	n = WaitForSingleObject(ph->pipe_cn_ev, 0);
 	if (n == WAIT_FAILED) {
 	    win32_maperr(GetLastError());
-	    uerror("netsys_pipe_listen/WaitForSingleObject", Nothing);
+	    caml_uerror("netsys_pipe_listen/WaitForSingleObject", Nothing);
 	};
 	if (n == WAIT_OBJECT_0)
 	    set_cn_ev = 1;
@@ -1121,7 +1121,7 @@ CAMLprim value netsys_pipe_listen(value phv) {
 	    dprintf("PIPE listen %u error err=%u\n",
 		    ph->pipe_handle, err);
 	    win32_maperr(err);
-	    uerror("netsys_pipe_listen/ConnectNamedPipe", Nothing);
+	    caml_uerror("netsys_pipe_listen/ConnectNamedPipe", Nothing);
 	};
     };
 
@@ -1130,7 +1130,7 @@ CAMLprim value netsys_pipe_listen(value phv) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_pipe_listen");
+    caml_invalid_argument("netsys_pipe_listen");
 #endif
 }
 
@@ -1150,17 +1150,17 @@ CAMLprim value netsys_pipe_deafen(value phv) {
 
     if (!ph->pipe_is_open) {
 	errno = EBADF;
-	uerror("netsys_pipe_deafen", Nothing);
+	caml_uerror("netsys_pipe_deafen", Nothing);
     };
 
     if (!ph->pipe_is_server) {
 	errno = EPERM;
-	uerror("netsys_pipe_deafen", Nothing);
+	caml_uerror("netsys_pipe_deafen", Nothing);
     };
 
     if (ph->pipe_conn_state == PIPE_DEAF) {
 	errno = ENOTCONN;
-	uerror("netsys_pipe_deafen", Nothing);
+	caml_uerror("netsys_pipe_deafen", Nothing);
     };
 
     dprintf("PIPE deafen %u disconnecting\n",
@@ -1169,19 +1169,19 @@ CAMLprim value netsys_pipe_deafen(value phv) {
     flag = DisconnectNamedPipe(ph->pipe_handle);
     if (!flag) {
 	win32_maperr(GetLastError());
-	uerror("netsys_pipe_deafen/DisconnectNamedPipe", Nothing);
+	caml_uerror("netsys_pipe_deafen/DisconnectNamedPipe", Nothing);
     }
 
     /* Check whether the overlapped ops are done: */
     check_for_pending_operations(ph);
     if (ph->pipe_cn_ovrlp_started) {
-	failwith("netsys_pipe_unlisten: cannot stop pending ConnectNamedPipe");
+	caml_failwith("netsys_pipe_unlisten: cannot stop pending ConnectNamedPipe");
     };
     if (ph->pipe_rd_ovrlp_started) {
-	failwith("netsys_pipe_unlisten: cannot stop pending ReadFile");
+	caml_failwith("netsys_pipe_unlisten: cannot stop pending ReadFile");
     };
     if (ph->pipe_wr_ovrlp_started) {
-	failwith("netsys_pipe_unlisten: cannot stop pending WriteFile");
+	caml_failwith("netsys_pipe_unlisten: cannot stop pending WriteFile");
     };
 
     dprintf("PIPE deafen %u successful\n",
@@ -1202,7 +1202,7 @@ CAMLprim value netsys_pipe_deafen(value phv) {
     return Val_unit;
 
 #else
-    invalid_argument("netsys_pipe_unlisten");
+    caml_invalid_argument("netsys_pipe_unlisten");
 #endif
 }
 
@@ -1251,7 +1251,7 @@ CAMLprim value netsys_pipe_connect(value name, value mode) {
 	    errno = EAGAIN;
 	else
 	    win32_maperr(err);
-	uerror("netsys_pipe_connect/CreateFile", Nothing);
+	caml_uerror("netsys_pipe_connect/CreateFile", Nothing);
     };
 
     ph = alloc_pipe_helper(h, INVALID_HANDLE_VALUE);
@@ -1272,7 +1272,7 @@ CAMLprim value netsys_pipe_connect(value name, value mode) {
     return r;
 
 #else
-    invalid_argument("netsys_pipe_connect");
+    caml_invalid_argument("netsys_pipe_connect");
 #endif
 }
 
@@ -1294,7 +1294,7 @@ CAMLprim value netsys_pipe_read(value phv, value s, value pos, value len) {
 
     if (ph->pipe_error_rd != 0) {
 	win32_maperr(ph->pipe_error_rd);
-	uerror("netsys_pipe_read", Nothing);
+	caml_uerror("netsys_pipe_read", Nothing);
     };
 
     if (l == 0) 
@@ -1302,12 +1302,12 @@ CAMLprim value netsys_pipe_read(value phv, value s, value pos, value len) {
 
     if (!ph->pipe_is_open || !ph->pipe_mode_rd) {
 	errno = EBADF;
-	uerror("netsys_pipe_read", Nothing);
+	caml_uerror("netsys_pipe_read", Nothing);
     };
 
     if (ph->pipe_conn_state != PIPE_CONNECTED) {
 	errno = ENOTCONN;
-	uerror("netsys_pipe_read", Nothing);
+	caml_uerror("netsys_pipe_read", Nothing);
     };
 
     if (ph->pipe_rd_ovrlp_started) {
@@ -1315,7 +1315,7 @@ CAMLprim value netsys_pipe_read(value phv, value s, value pos, value len) {
 		ph->pipe_handle);
 
 	errno = EAGAIN;
-	uerror("netsys_pipe_read", Nothing);
+	caml_uerror("netsys_pipe_read", Nothing);
     };
 
     if (ph->pipe_rd_buf_size < l) 
@@ -1333,7 +1333,7 @@ CAMLprim value netsys_pipe_read(value phv, value s, value pos, value len) {
 
     return Val_int(l);
 #else
-    invalid_argument("netsys_pipe_read");
+    caml_invalid_argument("netsys_pipe_read");
 #endif
 }
 
@@ -1363,7 +1363,7 @@ CAMLprim value netsys_pipe_write(value phv, value s, value pos, value len) {
 	}
 	else
 	    win32_maperr(ph->pipe_error_wr);
-	uerror("netsys_pipe_write", Nothing);
+	caml_uerror("netsys_pipe_write", Nothing);
     };
 
     if (l == 0) 
@@ -1371,19 +1371,19 @@ CAMLprim value netsys_pipe_write(value phv, value s, value pos, value len) {
 
     if (!ph->pipe_is_open || !ph->pipe_mode_wr) {
 	errno = EBADF;
-	uerror("netsys_pipe_write", Nothing);
+	caml_uerror("netsys_pipe_write", Nothing);
     };
 
     if (ph->pipe_conn_state != PIPE_CONNECTED) {
 	errno = ENOTCONN;
-	uerror("netsys_pipe_write", Nothing);
+	caml_uerror("netsys_pipe_write", Nothing);
     };
 
     if (ph->pipe_wr_ovrlp_started) {
 	dprintf("PIPE write %u eagain\n",
 	       ph->pipe_handle);
 	errno = EAGAIN;
-	uerror("netsys_pipe_write", Nothing);
+	caml_uerror("netsys_pipe_write", Nothing);
     };
 
     if (l > PIPE_HELPER_BUF_SIZE) 
@@ -1400,7 +1400,7 @@ CAMLprim value netsys_pipe_write(value phv, value s, value pos, value len) {
 
     return Val_int(l);
 #else
-    invalid_argument("netsys_pipe_write");
+    caml_invalid_argument("netsys_pipe_write");
 #endif
 }
 
@@ -1418,13 +1418,13 @@ CAMLprim value netsys_pipe_shutdown(value phv) {
     if (ph->pipe_is_open) {
 	if (ph->pipe_conn_state == PIPE_DEAF) {
 	    errno = ENOTCONN;
-	    uerror("netsys_pipe_shutdown", Nothing);
+	    caml_uerror("netsys_pipe_shutdown", Nothing);
 	};
 
 	flag = CloseHandle(ph->pipe_handle);
 	if (!flag) {
 	    win32_maperr(GetLastError());
-	    uerror("netsys_pipe_shutdown/CloseHandle", Nothing);
+	    caml_uerror("netsys_pipe_shutdown/CloseHandle", Nothing);
 	};
 	ph->pipe_is_open = 0;
 	ph->pipe_conn_state = PIPE_DOWN;
@@ -1438,7 +1438,7 @@ CAMLprim value netsys_pipe_shutdown(value phv) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_pipe_shutdown");
+    caml_invalid_argument("netsys_pipe_shutdown");
 #endif
 }
 
@@ -1453,7 +1453,7 @@ CAMLprim value netsys_pipe_free(value phv) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_pipe_free");
+    caml_invalid_argument("netsys_pipe_free");
 #endif
 }
 
@@ -1469,7 +1469,7 @@ CAMLprim value netsys_pipe_conn_state(value phv) {
 
     return Val_int(ph->pipe_conn_state);
 #else
-    invalid_argument("netsys_pipe_conn_state");
+    caml_invalid_argument("netsys_pipe_conn_state");
 #endif
 }
 
@@ -1482,12 +1482,12 @@ CAMLprim value netsys_pipe_rd_event(value phv) {
 
     if (!ph->pipe_is_open) {
 	errno = EBADF;
-	uerror("netsys_pipe_rd_event", Nothing);
+	caml_uerror("netsys_pipe_rd_event", Nothing);
     };
 
     return alloc_event(ph->pipe_rd_ev);
 #else
-    invalid_argument("netsys_pipe_rd_event");
+    caml_invalid_argument("netsys_pipe_rd_event");
 #endif
 }
 
@@ -1500,12 +1500,12 @@ CAMLprim value netsys_pipe_wr_event(value phv) {
 
     if (!ph->pipe_is_open) {
 	errno = EBADF;
-	uerror("netsys_pipe_wr_event", Nothing);
+	caml_uerror("netsys_pipe_wr_event", Nothing);
     };
 
     return alloc_event(ph->pipe_wr_ev);
 #else
-    invalid_argument("netsys_pipe_wr_event");
+    caml_invalid_argument("netsys_pipe_wr_event");
 #endif
 }
 
@@ -1518,7 +1518,7 @@ CAMLprim value netsys_pipe_descr(value phv) {
 
     return netsysw32_win_alloc_handle(ph->pipe_descr);
 #else
-    invalid_argument("netsys_pipe_descr");
+    caml_invalid_argument("netsys_pipe_descr");
 #endif
 }
 
@@ -1530,7 +1530,7 @@ CAMLprim value netsys_set_auto_close_pipe_proxy(value phv, value flag) {
     ph->pipe_descr_auto_close = Bool_val(flag);
     return Val_unit;
 #else
-    invalid_argument("netsys_set_auto_close_pipe_proxy");
+    caml_invalid_argument("netsys_set_auto_close_pipe_proxy");
 #endif
 }
 
@@ -1546,7 +1546,7 @@ CAMLprim value netsys_pipe_signal(value phv, value ev) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_pipe_signal");
+    caml_invalid_argument("netsys_pipe_signal");
 #endif
 }
 
@@ -1582,7 +1582,7 @@ static value alloc_process(HANDLE proc, DWORD win_pid) {
     e_proxy = CreateEvent(NULL, 1, 0, NULL);
     if (e_proxy == NULL) {
 	win32_maperr(GetLastError());
-	uerror("alloc_process/CreateEvent", Nothing);
+	caml_uerror("alloc_process/CreateEvent", Nothing);
     };
 
     p0->proc = proc;
@@ -1658,7 +1658,7 @@ CAMLprim value netsys_create_process(value cmd,
 	      pass_std_handles = 1;
 	      break;
 	  default:
-	      invalid_argument("netsys_create_process [1]");
+	      caml_invalid_argument("netsys_create_process [1]");
 	  }
       }
       else {
@@ -1687,7 +1687,7 @@ CAMLprim value netsys_create_process(value cmd,
 	      pg_flags = 0;
 	      break;
 	  default:
-	      invalid_argument("netsys_create_process [2]");
+	      caml_invalid_argument("netsys_create_process [2]");
 	  }
       };
       opts_hd = Field(opts_hd,1);
@@ -1709,14 +1709,14 @@ CAMLprim value netsys_create_process(value cmd,
 		       &pi);
   if (!code) {
       win32_maperr(GetLastError());
-      uerror("create_process/CreateProcess", cmd);
+      caml_uerror("create_process/CreateProcess", cmd);
   };
   CloseHandle(pi.hThread);
   dprintf("netsys_create_process hProcess=%u processId=%u\n",
 	  pi.hProcess, pi.dwProcessId);
   return alloc_process(pi.hProcess, pi.dwProcessId);
 #else
-    invalid_argument("netsys_create_process");
+    caml_invalid_argument("netsys_create_process");
 #endif
 }
 
@@ -1751,7 +1751,7 @@ CAMLprim value netsys_search_path(value path_opt_v,
     if (pathlen < 256) pathlen = 256;
     cont = 1;
     while (cont) {
-	fullname = stat_alloc(pathlen);
+	fullname = caml_stat_alloc(pathlen);
 	code = SearchPath(path,
 			  file,
 			  ext,
@@ -1760,7 +1760,7 @@ CAMLprim value netsys_search_path(value path_opt_v,
 			  NULL);
 	cont = (code >= pathlen);
 	if (cont) {
-	    stat_free(fullname);
+	    caml_stat_free(fullname);
 	    pathlen = code+1;  /* space for NULL byte! */
 	}
     }
@@ -1768,16 +1768,16 @@ CAMLprim value netsys_search_path(value path_opt_v,
     caml_leave_blocking_section();
 
     if (code == 0) {
-	stat_free(fullname);
+	caml_stat_free(fullname);
 	errno = ENOENT;
-	uerror("netsys_search_path", file_v);
+	caml_uerror("netsys_search_path", file_v);
     };
 
     r = caml_copy_string(fullname);
-    stat_free(fullname);
+    caml_stat_free(fullname);
     return r;
 #else
-    invalid_argument("netsys_search_path");
+    caml_invalid_argument("netsys_search_path");
 #endif
 }
 
@@ -1790,11 +1790,11 @@ CAMLprim value netsys_terminate_process(value pv) {
 	    p0->proc, p0->win_pid);
     if (!TerminateProcess(p0->proc, 126)) {
       win32_maperr(GetLastError());
-      uerror("terminate_process/TerminateProcess", Nothing);
+      caml_uerror("terminate_process/TerminateProcess", Nothing);
     }
     return Val_unit;
 #else
-    invalid_argument("netsys_terminate_process");
+    caml_invalid_argument("netsys_terminate_process");
 #endif
 }
 
@@ -1807,7 +1807,7 @@ CAMLprim value netsys_process_descr(value pv) {
     p0 = process_val(pv);
     return netsysw32_win_alloc_handle(p0->proc_proxy);
 #else
-    invalid_argument("netsys_process_descr");
+    caml_invalid_argument("netsys_process_descr");
 #endif
 }
 
@@ -1819,7 +1819,7 @@ CAMLprim value netsys_set_auto_close_process_proxy(value pv, value flag) {
     p0->auto_close = Bool_val(flag);
     return Val_unit;
 #else
-    invalid_argument("netsys_set_auto_close_process_proxy");
+    caml_invalid_argument("netsys_set_auto_close_process_proxy");
 #endif
 }
 
@@ -1834,7 +1834,7 @@ CAMLprim value netsys_close_process(value pv) {
     };
     return Val_unit;
 #else
-    invalid_argument("netsys_close_process");
+    caml_invalid_argument("netsys_close_process");
 #endif
 }
 
@@ -1846,10 +1846,10 @@ CAMLprim value netsys_process_free(value pv) {
 	CloseHandle(p0->proc);
     if (p0->auto_close)
 	CloseHandle(p0->proc_proxy);
-    stat_free(p0);
+    caml_stat_free(p0);
     return Val_unit;
 #else
-    invalid_argument("netsys_close_process");
+    caml_invalid_argument("netsys_close_process");
 #endif
 }
 
@@ -1867,22 +1867,22 @@ CAMLprim value netsys_get_process_status(value pv) {
     };
     if (code == WAIT_FAILED) {
 	win32_maperr(GetLastError());
-	uerror("netsys_get_process_status/WaitForSingleObject", Nothing);
+	caml_uerror("netsys_get_process_status/WaitForSingleObject", Nothing);
     };
     if (code != WAIT_OBJECT_0) {
-	invalid_argument("netsys_get_process_status [1]");
+	caml_invalid_argument("netsys_get_process_status [1]");
     };
     /* Now get the status: */
     code = GetExitCodeProcess(p0->proc, &status);
     if (!code) {
 	win32_maperr(GetLastError());
-	uerror("netsys_get_process_status/getExitCodeProcess", Nothing);
+	caml_uerror("netsys_get_process_status/getExitCodeProcess", Nothing);
     }
     
     return Val_int(status);
 
 #else
-    invalid_argument("netsys_get_process_status");
+    caml_invalid_argument("netsys_get_process_status");
 #endif
 }
 
@@ -1893,7 +1893,7 @@ CAMLprim value netsys_as_process_event(value pv) {
     p0 = process_val(pv);
     return alloc_event(p0->proc);
 #else
-    invalid_argument("netsys_as_process_event");
+    caml_invalid_argument("netsys_as_process_event");
 #endif
 }
 
@@ -1911,11 +1911,11 @@ CAMLprim value netsys_emulated_pid(value pv) {
 			FALSE,
 			DUPLICATE_SAME_ACCESS)) {
 	win32_maperr(GetLastError());
-	uerror("netsys_emulated_pid/DuplicateHandle", Nothing);
+	caml_uerror("netsys_emulated_pid/DuplicateHandle", Nothing);
     };
     return Val_int(d);
 #else
-    invalid_argument("netsys_emulated_pid");
+    caml_invalid_argument("netsys_emulated_pid");
 #endif
 }
 
@@ -1926,7 +1926,7 @@ CAMLprim value netsys_win_pid(value pv) {
     p0 = process_val(pv);
     return Val_int(p0->win_pid);
 #else
-    invalid_argument("netsys_win_pid");
+    caml_invalid_argument("netsys_win_pid");
 #endif
 }
 
@@ -1935,7 +1935,7 @@ CAMLprim value netsys_has_console(value dummy) {
 #ifdef _WIN32
     return Val_bool(has_console());
 #else
-    invalid_argument("netsys_has_console");
+    caml_invalid_argument("netsys_has_console");
 #endif
 }
 
@@ -1950,7 +1950,7 @@ CAMLprim value netsys_is_console(value fd) {
     else
 	return Val_bool(1);
 #else
-    invalid_argument("netsys_is_console");
+    caml_invalid_argument("netsys_is_console");
 #endif
 }
 
@@ -1958,11 +1958,11 @@ CAMLprim value netsys_alloc_console(value dummy) {
 #ifdef _WIN32
     if (!AllocConsole()) {
 	win32_maperr(GetLastError());
-	uerror("netsys_alloc_console/AllocConsole", Nothing);
+	caml_uerror("netsys_alloc_console/AllocConsole", Nothing);
     }
     return Val_unit;
 #else
-    invalid_argument("netsys_alloc_console");
+    caml_invalid_argument("netsys_alloc_console");
 #endif
 }
 
@@ -1978,17 +1978,17 @@ CAMLprim value netsys_get_console_attr(value dummy) {
 			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conout == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_get_console_attr/CreateFile", Nothing);
+	caml_uerror("netsys_get_console_attr/CreateFile", Nothing);
     }
     if (!GetConsoleCursorInfo(conout, &cci)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_get_console_attr/GetConsoleCursorInfo", Nothing);
+	caml_uerror("netsys_get_console_attr/GetConsoleCursorInfo", Nothing);
     }
     if (!GetConsoleScreenBufferInfo(conout, &csbi)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_get_console_attr/GetConsoleScreenBufferInfo", Nothing);
+	caml_uerror("netsys_get_console_attr/GetConsoleScreenBufferInfo", Nothing);
     }
     CloseHandle(conout);
 
@@ -2001,7 +2001,7 @@ CAMLprim value netsys_get_console_attr(value dummy) {
 
     return r;
 #else
-    invalid_argument("netsys_get_console_attr");
+    caml_invalid_argument("netsys_get_console_attr");
 #endif
 }
 
@@ -2025,7 +2025,7 @@ CAMLprim value netsys_set_console_attr(value av) {
 			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conout == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_set_console_attr/CreateFile", Nothing);
+	caml_uerror("netsys_set_console_attr/CreateFile", Nothing);
     }
     
     cci.dwSize = csize;
@@ -2033,13 +2033,13 @@ CAMLprim value netsys_set_console_attr(value av) {
     if (!SetConsoleCursorInfo(conout, &cci)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_set_console_attr/SetConsoleCursorInfo", Nothing);
+	caml_uerror("netsys_set_console_attr/SetConsoleCursorInfo", Nothing);
     }
   
     if (!GetConsoleScreenBufferInfo(conout, &csbi)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_set_console_attr/GetConsoleScreenBufferInfo", Nothing);
+	caml_uerror("netsys_set_console_attr/GetConsoleScreenBufferInfo", Nothing);
     }
 
     pos.X = cx + csbi.srWindow.Left;
@@ -2047,20 +2047,20 @@ CAMLprim value netsys_set_console_attr(value av) {
     if (!SetConsoleCursorPosition(conout, pos)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_set_console_attr/SetConsoleCursorPosition", Nothing);
+	caml_uerror("netsys_set_console_attr/SetConsoleCursorPosition", Nothing);
     }
 
     if (!SetConsoleTextAttribute(conout, tattr)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_set_console_attr/SetConsoleTextAttributes", Nothing);
+	caml_uerror("netsys_set_console_attr/SetConsoleTextAttributes", Nothing);
     }
 
     CloseHandle(conout);
   
     return Val_unit;
 #else
-    invalid_argument("netsys_set_console_attr");
+    caml_invalid_argument("netsys_set_console_attr");
 #endif
 }
 
@@ -2076,13 +2076,13 @@ CAMLprim value netsys_get_console_info(value dummy) {
 			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conout == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_get_console_info/CreateFile", Nothing);
+	caml_uerror("netsys_get_console_info/CreateFile", Nothing);
     }
     
     if (!GetConsoleScreenBufferInfo(conout, &csbi)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_get_console_info/GetConsoleScreenBufferInfo", Nothing);
+	caml_uerror("netsys_get_console_info/GetConsoleScreenBufferInfo", Nothing);
     }
     CloseHandle(conout);
 
@@ -2092,7 +2092,7 @@ CAMLprim value netsys_get_console_info(value dummy) {
 
     return r;
 #else
-    invalid_argument("netsys_get_console_info");
+    caml_invalid_argument("netsys_get_console_info");
 #endif
 }
 
@@ -2108,13 +2108,13 @@ CAMLprim value netsys_get_console_mode(value dummy) {
 		       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conin == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_get_console_mode/CreateFile", Nothing);
+	caml_uerror("netsys_get_console_mode/CreateFile", Nothing);
     }
     
     if (!GetConsoleMode(conin, &modein)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conin);
-	uerror("netsys_get_console_mode/GetConsoleMode", Nothing);
+	caml_uerror("netsys_get_console_mode/GetConsoleMode", Nothing);
     }
 
     CloseHandle(conin);
@@ -2124,13 +2124,13 @@ CAMLprim value netsys_get_console_mode(value dummy) {
 			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conout == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_get_console_mode/CreateFile", Nothing);
+	caml_uerror("netsys_get_console_mode/CreateFile", Nothing);
     }
     
     if (!GetConsoleMode(conout, &modeout)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_get_console_mode/GetConsoleMode", Nothing);
+	caml_uerror("netsys_get_console_mode/GetConsoleMode", Nothing);
     }
 
     CloseHandle(conout),
@@ -2146,7 +2146,7 @@ CAMLprim value netsys_get_console_mode(value dummy) {
 
     return r;
 #else
-    invalid_argument("netsys_get_console_mode");
+    caml_invalid_argument("netsys_get_console_mode");
 #endif
 }
 
@@ -2162,13 +2162,13 @@ CAMLprim value netsys_set_console_mode(value mv) {
 		       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conin == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_set_console_mode/CreateFile", Nothing);
+	caml_uerror("netsys_set_console_mode/CreateFile", Nothing);
     }
     
     if (!GetConsoleMode(conin, &modein)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conin);
-	uerror("netsys_set_console_mode/GetConsoleMode", Nothing);
+	caml_uerror("netsys_set_console_mode/GetConsoleMode", Nothing);
     }
 
     modein &= ~ENABLE_ECHO_INPUT & ~ENABLE_INSERT_MODE & ~ENABLE_LINE_INPUT &
@@ -2183,7 +2183,7 @@ CAMLprim value netsys_set_console_mode(value mv) {
     if (!SetConsoleMode(conin, modein)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conin);
-	uerror("netsys_set_console_mode/SetConsoleMode", Nothing);
+	caml_uerror("netsys_set_console_mode/SetConsoleMode", Nothing);
     };
 
     CloseHandle(conin);
@@ -2193,13 +2193,13 @@ CAMLprim value netsys_set_console_mode(value mv) {
 			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conout == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_set_console_mode/CreateFile", Nothing);
+	caml_uerror("netsys_set_console_mode/CreateFile", Nothing);
     }
     
     if (!GetConsoleMode(conout, &modeout)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_set_console_mode/GetConsoleMode", Nothing);
+	caml_uerror("netsys_set_console_mode/GetConsoleMode", Nothing);
     }
 
     modeout &= ~ENABLE_PROCESSED_OUTPUT & ~ENABLE_WRAP_AT_EOL_OUTPUT;
@@ -2209,13 +2209,13 @@ CAMLprim value netsys_set_console_mode(value mv) {
     if (!SetConsoleMode(conout, modeout)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_set_console_mode/SetConsoleMode", Nothing);
+	caml_uerror("netsys_set_console_mode/SetConsoleMode", Nothing);
     };
 
     CloseHandle(conout);
     return Val_unit;
 #else
-    invalid_argument("netsys_set_console_mode");
+    caml_invalid_argument("netsys_set_console_mode");
 #endif
 }
 
@@ -2224,7 +2224,7 @@ CAMLprim value netsys_getacp(value dummy) {
 #ifdef _WIN32
     return Val_int(GetACP());
 #else
-    invalid_argument("netsys_getacp");
+    caml_invalid_argument("netsys_getacp");
 #endif
 }
 
@@ -2235,15 +2235,15 @@ CAMLprim value netsys_init_console_codepage(value dummy) {
     cp = GetACP();
     if (!SetConsoleCP(cp)) {
 	win32_maperr(GetLastError());
-	uerror("netsys_init_console_codepage/SetConsoleCP", Nothing);
+	caml_uerror("netsys_init_console_codepage/SetConsoleCP", Nothing);
     }
     if (!SetConsoleOutputCP(cp)) {
 	win32_maperr(GetLastError());
-	uerror("netsys_init_console_codepage/SetConsoleOutputCP", Nothing);
+	caml_uerror("netsys_init_console_codepage/SetConsoleOutputCP", Nothing);
     }
     return Val_unit;
 #else
-    invalid_argument("netsys_init_console_codepage");
+    caml_invalid_argument("netsys_init_console_codepage");
 #endif
 }
 
@@ -2257,13 +2257,13 @@ static void clear_eol(HANDLE conout, COORD p, DWORD right, int attr) {
 				    p, &nact)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_clear_console/FillConsoleOutputCharacter", Nothing);
+	caml_uerror("netsys_clear_console/FillConsoleOutputCharacter", Nothing);
     }
     if (!FillConsoleOutputAttribute(conout, attr, n, 
 				    p, &nact)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_clear_console/FillConsoleOutputAttribute", Nothing);
+	caml_uerror("netsys_clear_console/FillConsoleOutputAttribute", Nothing);
     }
 }
 #endif
@@ -2282,13 +2282,13 @@ CAMLprim value netsys_clear_console(value mode) {
 			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (conout == INVALID_HANDLE_VALUE) {
 	win32_maperr(GetLastError());
-	uerror("netsys_clear_console/CreateFile", Nothing);
+	caml_uerror("netsys_clear_console/CreateFile", Nothing);
     }
 
     if (!GetConsoleScreenBufferInfo(conout, &csbi)) {
 	win32_maperr(GetLastError());
 	CloseHandle(conout);
-	uerror("netsys_clear_console/GetConsoleScreenBufferInfo", Nothing);
+	caml_uerror("netsys_clear_console/GetConsoleScreenBufferInfo", Nothing);
     }
 
     switch (Int_val(mode)) {
@@ -2318,7 +2318,7 @@ CAMLprim value netsys_clear_console(value mode) {
 	if (!SetConsoleCursorPosition(conout, p)) {
 	    win32_maperr(GetLastError());
 	    CloseHandle(conout);
-	    uerror("netsys_clear_console/SetConsoleCursorPosition", Nothing);
+	    caml_uerror("netsys_clear_console/SetConsoleCursorPosition", Nothing);
 	};
 	width = csbi.srWindow.Right - csbi.srWindow.Left  + 1;
 	height = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
@@ -2329,7 +2329,7 @@ CAMLprim value netsys_clear_console(value mode) {
 	if (!SetConsoleWindowInfo(conout, TRUE, &new_win)) {
 	    win32_maperr(GetLastError());
 	    CloseHandle(conout);
-	    uerror("netsys_clear_console/SetConsoleWindowInfo", Nothing);
+	    caml_uerror("netsys_clear_console/SetConsoleWindowInfo", Nothing);
 	}
 	break;
     };
@@ -2338,7 +2338,7 @@ CAMLprim value netsys_clear_console(value mode) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_clear_console");
+    caml_invalid_argument("netsys_clear_console");
 #endif
 }
 
@@ -2347,7 +2347,7 @@ CAMLprim value netsys_get_current_thread_id(value dummy) {
 #ifdef _WIN32
     return caml_copy_int32(GetCurrentThreadId());
 #else
-    invalid_argument("netsys_get_current_thread_id");
+    caml_invalid_argument("netsys_get_current_thread_id");
 #endif
 }
 
@@ -2377,7 +2377,7 @@ CAMLprim value netsys_cancel_synchronous_io(value thread_id_val) {
 	thread = OpenThread(THREAD_TERMINATE,FALSE,thread_id);
 	if (thread == NULL) {
 	    win32_maperr(GetLastError());
-	    uerror("netsys_cancel_synchronous_io/OpenThread", Nothing);
+	    caml_uerror("netsys_cancel_synchronous_io/OpenThread", Nothing);
 	}
 	code = cancel_io_func(thread);
 	if (!code) {
@@ -2385,7 +2385,7 @@ CAMLprim value netsys_cancel_synchronous_io(value thread_id_val) {
 	    if (code != ERROR_NOT_FOUND) {  /* hide ERROR_NOT_FOUND */
 		CloseHandle(thread);
 		win32_maperr(GetLastError());
-		uerror("netsys_cancel_synchronous_io/CancelSynchronousIo",
+		caml_uerror("netsys_cancel_synchronous_io/CancelSynchronousIo",
 		       Nothing);
 	    }
 	};
@@ -2394,7 +2394,7 @@ CAMLprim value netsys_cancel_synchronous_io(value thread_id_val) {
 
     return Val_unit;
 #else
-    invalid_argument("netsys_cancel_synchronous_io");
+    caml_invalid_argument("netsys_cancel_synchronous_io");
 #endif
 }
 
@@ -2439,7 +2439,7 @@ static value fdset_to_fdlist(value fdlist, fd_set *fdset)
     for (/*nothing*/; fdlist != Val_int(0); fdlist = Field(fdlist, 1)) {
       s = Field(fdlist, 0);
       if (FD_ISSET(Socket_val(s), fdset)) {
-        value newres = alloc_small(2, 0);
+        value newres = caml_alloc_small(2, 0);
         Field(newres, 0) = s;
         Field(newres, 1) = res;
         res = newres;
@@ -2471,9 +2471,9 @@ CAMLprim value netsys_real_select(value readfds, value writefds,
 	&& writefds == Val_int(0)
 	&& exceptfds == Val_int(0)) {
       if ( tm > 0.0 ) {
-	enter_blocking_section();
+	caml_enter_blocking_section();
 	Sleep( (int)(tm * 1000));
-	leave_blocking_section();
+	caml_leave_blocking_section();
       }
       read_list = write_list = except_list = Val_int(0);
     } else {      
@@ -2487,19 +2487,19 @@ CAMLprim value netsys_real_select(value readfds, value writefds,
 	tv.tv_usec = (int) (1e6 * (tm - (int) tm));
 	tvp = &tv;
       }
-      enter_blocking_section();
+      caml_enter_blocking_section();
       if (select(FD_SETSIZE, &read, &write, &except, tvp) == -1)
         err = WSAGetLastError();
-      leave_blocking_section();
+      caml_leave_blocking_section();
       if (err) {
 	win32_maperr(err);
-	uerror("select", Nothing);
+	caml_uerror("select", Nothing);
       }
       read_list = fdset_to_fdlist(readfds, &read);
       write_list = fdset_to_fdlist(writefds, &write);
       except_list = fdset_to_fdlist(exceptfds, &except);
     }
-    res = alloc_small(3, 0);
+    res = caml_alloc_small(3, 0);
     Field(res, 0) = read_list;
     Field(res, 1) = write_list;
     Field(res, 2) = except_list;
@@ -2507,6 +2507,6 @@ CAMLprim value netsys_real_select(value readfds, value writefds,
   End_roots();
   return res;
 #else
-    invalid_argument("netsys_real_select");
+    caml_invalid_argument("netsys_real_select");
 #endif
 }
diff --git code/src/netsys/netsys_impl_util.ml code/src/netsys/netsys_impl_util.ml
index 561d26ab..fbd55145 100644
--- code/src/netsys/netsys_impl_util.ml
+++ code/src/netsys/netsys_impl_util.ml
@@ -67,7 +67,7 @@ let mem_sorted_array x a =
   let rec search l h =
     if l < h then (
       let m = (l+h) / 2 in
-      let r = Pervasives.compare x a.(m) in
+      let r = Stdlib.compare x a.(m) in
       if r = 0 then
 	true
       else
diff --git code/src/netsys/netsys_mem.ml code/src/netsys/netsys_mem.ml
index 847ef70a..f2abc0cc 100644
--- code/src/netsys/netsys_mem.ml
+++ code/src/netsys/netsys_mem.ml
@@ -219,6 +219,7 @@ type init_value_flag =
 
 type custom_ops = nativeint
 
+(*
 external netsys_init_value : 
   memory -> int -> 'a -> init_value_flag list -> nativeint -> 
   (string * custom_ops) list -> ((int*int) list) -> (int * int)
@@ -241,10 +242,12 @@ let init_value ?targetaddr ?(target_custom_ops=[]) ?(cc=[])
       ) 
       cc in
   netsys_init_value mem offset v flags taddr target_custom_ops cc
+*)
 
 external get_custom_ops : 'a -> string * custom_ops
   = "netsys_get_custom_ops"
 
+(*
 external copy_value : init_value_flag list -> 'a -> 'a
   = "netsys_copy_value"
 
@@ -255,6 +258,7 @@ external color : Obj.t -> color
 
 external set_color : Obj.t -> color -> unit
   = "netsys_set_color"
+*)
 
 external is_bigarray : Obj.t -> bool
   = "netsys_is_bigarray"
@@ -275,6 +279,7 @@ let mem_write fd mem off len =
     invalid_arg "Netsys_mem.mem_write";
   netsys_mem_write fd mem off len
 
+(*
 external netsys_mem_recv : 
   Unix.file_descr -> memory -> int -> int -> Unix.msg_flag list -> int
   = "netsys_mem_recv"
@@ -289,6 +294,7 @@ external netsys_mem_recvfrom :
 external netsys_mem_send :
   Unix.file_descr -> memory -> int -> int -> Unix.msg_flag list -> int
   = "netsys_mem_send"
+*)
 
 (*
 external netsys_mem_sendto :
@@ -300,7 +306,8 @@ external netsys_mem_sendto :
 let mem_recv fd mem off len flags =
   if len < 0 || off < 0 || len > Bigarray.Array1.dim mem - off then
     invalid_arg "Netsys_mem.mem_recv";
-  netsys_mem_recv fd mem off len flags
+(*   netsys_mem_recv fd mem off len flags *)
+  invalid_arg "mem_recv : disabled"
 
 (*
 let mem_recvfrom fd mem off len flags =
@@ -312,7 +319,8 @@ let mem_recvfrom fd mem off len flags =
 let mem_send fd mem off len flags =
   if len < 0 || off < 0 || len > Bigarray.Array1.dim mem - off then
     invalid_arg "Netsys_mem.mem_send";
-  netsys_mem_send fd mem off len flags
+(*   netsys_mem_send fd mem off len flags *)
+  invalid_arg "mem_send : disabled"
 
 (*
 let mem_sendto fd mem off len flags addr =
diff --git code/src/netsys/netsys_mem.mli code/src/netsys/netsys_mem.mli
index f10c4ad4..c8c3849b 100644
--- code/src/netsys/netsys_mem.mli
+++ code/src/netsys/netsys_mem.mli
@@ -309,6 +309,7 @@ val init_float_array_bytelen : int -> int
 
 type custom_ops = nativeint
 
+(*
 type init_value_flag = 
   | Copy_bigarray
   | Copy_custom_int
@@ -322,6 +323,7 @@ val init_value :
       ?target_custom_ops:(string * custom_ops) list ->
       ?cc:(nativeint * nativeint) list ->
       memory -> int -> 'a -> init_value_flag list -> (int * int)
+*)
   (** [let voffset, bytelen = init_value mem offset v flags]:
       Initializes the memory at [offset] and following bytes as
       copy of the boxed value [v]. 
@@ -393,7 +395,7 @@ val init_value :
 val get_custom_ops : 'a -> (string * custom_ops)
   (** Returns custom ops for a sample value (or [Invalid_argument]) *)
 
-val copy_value : init_value_flag list -> 'a -> 'a
+(* val copy_value : init_value_flag list -> 'a -> 'a *)
   (** [copy_value flags v]: Creates a deep copy of [v] and returns it.
       The copy is allocated in the normal Ocaml heap.
 
@@ -410,6 +412,7 @@ val copy_value : init_value_flag list -> 'a -> 'a
       Cyclic input values are supported. [Copy_simulate] is ignored.
    *)
 
+(*
 type color = White | Gray | Blue | Black
     (** GC colors *)
 
@@ -418,6 +421,7 @@ val color : Obj.t -> color
 
 val set_color : Obj.t -> color -> unit
   (** Set the GC color *)
+*)
 
 val is_bigarray : Obj.t -> bool
   (** Checks whether the objects ia actually a bigarray *)
diff --git code/src/netsys/netsys_pollset_win32.ml code/src/netsys/netsys_pollset_win32.ml
index 09b1264b..e08a29e4 100644
--- code/src/netsys/netsys_pollset_win32.ml
+++ code/src/netsys/netsys_pollset_win32.ml
@@ -27,9 +27,9 @@ let list_of_socket_sets ht in_set out_set pri_set =
   let in_arr  = Array.of_list in_set in
   let out_arr = Array.of_list out_set in
   let pri_arr = Array.of_list pri_set in
-  Array.sort Pervasives.compare in_arr;
-  Array.sort Pervasives.compare out_arr;
-  Array.sort Pervasives.compare pri_arr;
+  Array.sort Stdlib.compare in_arr;
+  Array.sort Stdlib.compare out_arr;
+  Array.sort Stdlib.compare pri_arr;
   Hashtbl.fold
     (fun fd (ev,_) l ->
        let m_in = Netsys_impl_util.mem_sorted_array fd in_arr in
diff --git code/src/netsys/netsys_posix.ml code/src/netsys/netsys_posix.ml
index 3bf3e7c9..9fb4e95d 100644
--- code/src/netsys/netsys_posix.ml
+++ code/src/netsys/netsys_posix.ml
@@ -337,9 +337,9 @@ let do_poll a k tmo =
 	let a_inp = Array.of_list o_inp in
 	let a_out = Array.of_list o_out in
 	let a_pri = Array.of_list o_pri in
-	Array.sort Pervasives.compare a_inp;
-	Array.sort Pervasives.compare a_out;
-	Array.sort Pervasives.compare a_pri;
+	Array.sort Stdlib.compare a_inp;
+	Array.sort Stdlib.compare a_out;
+	Array.sort Stdlib.compare a_pri;
 	let n = ref 0 in
 	for j = 0 to k-1 do
 	  let c = e.(j) in
@@ -679,7 +679,7 @@ end
 
 module PFH = struct
   type t = post_fork_handler
-  let compare = Pervasives.compare
+  let compare = Stdlib.compare
 end
 
 module PFH_Set = Set.Make(PFH)
diff --git code/src/netsys/unixsupport_w32.c code/src/netsys/unixsupport_w32.c
index 3f57c507..c3f57f1a 100644
--- code/src/netsys/unixsupport_w32.c
+++ code/src/netsys/unixsupport_w32.c
@@ -5,7 +5,7 @@
 
    To avoid name clashes, some functions have got a prefix (netsysw32_).
    The "#include" lines are adapted. cst_to_constr and
-   unix_error_of_code have been added.
+   caml_unix_error_of_code have been added.
 */
 
 /***********************************************************************/
@@ -167,7 +167,7 @@ void netsysw32_win32_maperr(DWORD errcode)
     }
   }
   /* Not found: save original error code, negated so that we can
-     recognize it in unix_error_message */
+     recognize it in caml_unix_error_message */
   errno = -errcode;
 }
 
@@ -226,9 +226,9 @@ int netsysw32_error_table[] = {
   EHOSTUNREACH, ELOOP, EOVERFLOW /*, EUNKNOWNERR */
 };
 
-static value * unix_error_exn = NULL;
+static value * caml_unix_error_exn = NULL;
 
-value netsysw32_unix_error_of_code (int errcode)
+value netsysw32_caml_unix_error_of_code (int errcode)
 {
   int errconstr;
   value err;
@@ -236,7 +236,7 @@ value netsysw32_unix_error_of_code (int errcode)
   errconstr = 
       cst_to_constr(errcode, netsysw32_error_table, sizeof(netsysw32_error_table)/sizeof(int), -1);
   if (errconstr == Val_int(-1)) {
-    err = alloc_small(1, 0);
+    err = caml_alloc_small(1, 0);
     Field(err, 0) = Val_int(errcode);
   } else {
     err = errconstr;
@@ -245,22 +245,22 @@ value netsysw32_unix_error_of_code (int errcode)
 }
 
 
-void netsysw32_unix_error(int errcode, char *cmdname, value cmdarg)
+void netsysw32_caml_unix_error(int errcode, char *cmdname, value cmdarg)
 {
   value res;
   value name = Val_unit, err = Val_unit, arg = Val_unit;
 
   Begin_roots3 (name, err, arg);
-    arg = cmdarg == Nothing ? copy_string("") : cmdarg;
-    name = copy_string(cmdname);
-    err = unix_error_of_code(errcode);
-    if (unix_error_exn == NULL) {
-      unix_error_exn = caml_named_value("Unix.Unix_error");
-      if (unix_error_exn == NULL)
-        invalid_argument("Exception Unix.Unix_error not initialized, please link unix.cma");
+    arg = cmdarg == Nothing ? caml_copy_string("") : cmdarg;
+    name = caml_copy_string(cmdname);
+    err = caml_unix_error_of_code(errcode);
+    if (caml_unix_error_exn == NULL) {
+      caml_unix_error_exn = caml_named_value("Unix.Unix_error");
+      if (caml_unix_error_exn == NULL)
+        caml_invalid_argument("Exception Unix.Unix_error not initialized, please link unix.cma");
     }
-    res = alloc_small(4, 0);
-    Field(res, 0) = *unix_error_exn;
+    res = caml_alloc_small(4, 0);
+    Field(res, 0) = *caml_unix_error_exn;
     Field(res, 1) = err;
     Field(res, 2) = name;
     Field(res, 3) = arg;
@@ -268,9 +268,9 @@ void netsysw32_unix_error(int errcode, char *cmdname, value cmdarg)
   mlraise(res);
 }
 
-void netsysw32_uerror(cmdname, cmdarg)
+void netsysw32_caml_uerror(cmdname, cmdarg)
      char * cmdname;
      value cmdarg;
 {
-  unix_error(errno, cmdname, cmdarg);
+  caml_unix_error(errno, cmdname, cmdarg);
 }
diff --git code/src/nettls-gnutls/gnutls.c code/src/nettls-gnutls/gnutls.c
index d8a0f05b..90f5f5d1 100644
--- code/src/nettls-gnutls/gnutls.c
+++ code/src/nettls-gnutls/gnutls.c
@@ -111,26 +111,26 @@ static value wrap_str_datum_p(const gnutls_datum_t *d) {
 static gnutls_datum_t unwrap_str_datum(value v) {
     gnutls_datum_t d;
     d.size = caml_string_length(v);
-    d.data = stat_alloc(d.size);
+    d.data = caml_stat_alloc(d.size);
     memcpy(d.data, String_val(v), d.size);
     return d;
 }
    
 static gnutls_datum_t * unwrap_str_datum_p(value v) {
     gnutls_datum_t *d;
-    d = stat_alloc(sizeof(gnutls_datum_t));
+    d = caml_stat_alloc(sizeof(gnutls_datum_t));
     *d = unwrap_str_datum(v);
     return d;
 }
    
 static void free_str_datum(gnutls_datum_t d) {
-    if (d.data != NULL) { stat_free(d.data); d.data = NULL; };
+    if (d.data != NULL) { caml_stat_free(d.data); d.data = NULL; };
 }
 
 static void free_str_datum_p(gnutls_datum_t *d) {
     if (d != NULL) {
-        if (d->data != NULL) stat_free(d->data);
-        stat_free(d);
+        if (d->data != NULL) caml_stat_free(d->data);
+        caml_stat_free(d);
     }
 }
    
@@ -405,7 +405,7 @@ static void attach_session_callbacks (gnutls_session_t s) {
     b_session_callbacks_t cb;
 
     cb = (b_session_callbacks_t) 
-            stat_alloc(sizeof(struct b_session_callbacks_st));
+            caml_stat_alloc(sizeof(struct b_session_callbacks_st));
     cb->session = s;
     cb->pull_fun = Val_int(0);
     cb->pull_timeout_fun = Val_int(0);
@@ -458,7 +458,7 @@ static void b_free_session(gnutls_session_t s) {
     caml_remove_generational_global_root(&(cb->db_store_fun));
     caml_remove_generational_global_root(&(cb->db_remove_fun));
 
-    stat_free(cb);
+    caml_stat_free(cb);
     gnutls_deinit(s);
 }
 
@@ -484,7 +484,7 @@ CAMLprim value net_b_set_pull_timeout_callback(value sv, value fun) {
     caml_modify_generational_global_root(&(cb->pull_timeout_fun), fun);
     return Val_unit;
 #else
-    invalid_argument("b_set_pull_timeout_callback");
+    caml_invalid_argument("b_set_pull_timeout_callback");
 #endif
 }
 
@@ -510,7 +510,7 @@ CAMLprim value net_b_set_verify_callback(value sv, value fun) {
     caml_modify_generational_global_root(&(cb->verify_fun), fun);
     return Val_unit;
 #else
-    invalid_argument("b_set_verify_callback");
+    caml_invalid_argument("b_set_verify_callback");
 #endif
 }
 
@@ -602,7 +602,7 @@ CAMLprim value net_gnutls_credentials_set(value sess, value creds) {
                                    );
         break;
     default:
-        failwith("net_gnutls_credentials_set");
+        caml_failwith("net_gnutls_credentials_set");
     };
     net_gnutls_error_check(error_code);
     attach_gnutls_session_t(sess, creds);
@@ -633,7 +633,7 @@ CAMLprim value net_gnutls_x509_crt_list_import(value datav, value formatv,
     code = gnutls_x509_crt_list_import(certs, &n, &data, format, 
                     flags | GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED);
     if (code == GNUTLS_E_SHORT_MEMORY_BUFFER) {
-        certs = (gnutls_x509_crt_t *) stat_alloc(n * sizeof(void *));
+        certs = (gnutls_x509_crt_t *) caml_stat_alloc(n * sizeof(void *));
         alloc_certs = 1;
         code = gnutls_x509_crt_list_import(certs, &n, &data, format, 
                                            flags);
@@ -646,7 +646,7 @@ CAMLprim value net_gnutls_x509_crt_list_import(value datav, value formatv,
         };
     };
     if (alloc_certs)
-        stat_free(certs);
+        caml_stat_free(certs);
     net_gnutls_error_check(code);
     CAMLreturn(array);
 }
@@ -676,7 +676,7 @@ CAMLprim value net_gnutls_x509_crl_list_import(value datav, value formatv,
     code = gnutls_x509_crl_list_import(certs, &n, &data, format, 
                     flags | GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED);
     if (code == GNUTLS_E_SHORT_MEMORY_BUFFER) {
-        certs = (gnutls_x509_crl_t *) stat_alloc(n * sizeof(void *));
+        certs = (gnutls_x509_crl_t *) caml_stat_alloc(n * sizeof(void *));
         alloc_certs = 1;
         code = gnutls_x509_crl_list_import(certs, &n, &data, format, 
                                            flags);
@@ -689,11 +689,11 @@ CAMLprim value net_gnutls_x509_crl_list_import(value datav, value formatv,
         };
     };
     if (alloc_certs)
-        stat_free(certs);
+        caml_stat_free(certs);
     net_gnutls_error_check(code);
     CAMLreturn(array);
 #else
-    invalid_argument("gnutls_x509_crl_list_import");
+    caml_invalid_argument("gnutls_x509_crl_list_import");
 #endif
 }
 
diff --git code/src/nettls-gnutls/nettle.c code/src/nettls-gnutls/nettle.c
index 77d00ff8..95ecae21 100644
--- code/src/nettls-gnutls/nettle.c
+++ code/src/nettls-gnutls/nettle.c
@@ -39,12 +39,12 @@ static void net_nettle_null_pointer(void) {
 static net_nettle_cipher_ctx_t
          net_nettle_create_cipher_ctx(net_nettle_cipher_t cipher) {
     void *p;
-    p = stat_alloc(cipher->context_size);
+    p = caml_stat_alloc(cipher->context_size);
     return p;
 }
 
 static void net_nettle_free(void *ctx) {
-    stat_free(ctx);
+    caml_stat_free(ctx);
 }
 
 static void net_nettle_destroy_cipher(net_nettle_cipher_t cipher) {
@@ -57,7 +57,7 @@ static void net_nettle_set_encrypt_key(net_nettle_cipher_t cipher,
                                        const uint8_t *key) {
 #ifdef HAVE_NETTLE_SET_KEY_WITH_TWO_ARGS
     if (length != cipher->key_size)
-        failwith("net_nettl_set_encrypt_key: key has wrong size");
+        caml_failwith("net_nettl_set_encrypt_key: key has wrong size");
     cipher->set_encrypt_key(ctx, key);
 #else
     cipher->set_encrypt_key(ctx, length, key);
@@ -71,7 +71,7 @@ static void net_nettle_set_decrypt_key(net_nettle_cipher_t cipher,
                                        const uint8_t *key) {
 #ifdef HAVE_NETTLE_SET_KEY_WITH_TWO_ARGS
     if (length != cipher->key_size)
-        failwith("net_nettl_set_decrypt_key: key has wrong size");
+        caml_failwith("net_nettl_set_decrypt_key: key has wrong size");
     cipher->set_decrypt_key(ctx, key);
 #else
     cipher->set_decrypt_key(ctx, length, key);
@@ -292,7 +292,7 @@ static void net_ext_ciphers(net_nettle_cipher_t **ciphers,
 
 static net_nettle_gcm_aes_ctx_t net_nettle_gcm_aes_init(void) {
 #ifdef HAVE_NETTLE_GCM_H
-    return stat_alloc(sizeof(struct gcm_aes_ctx));
+    return caml_stat_alloc(sizeof(struct gcm_aes_ctx));
 #else
     return NULL;
 #endif
@@ -321,7 +321,7 @@ static const char *net_nettle_hash_name(net_nettle_hash_t hash) {
 static net_nettle_hash_ctx_t
          net_nettle_create_hash_ctx(net_nettle_hash_t hash) {
     void *p;
-    p = stat_alloc(hash->context_size);
+    p = caml_stat_alloc(hash->context_size);
     return p;
 }
 
diff --git code/src/nettls-gnutls/nettls_gnutls.ml code/src/nettls-gnutls/nettls_gnutls.ml
index e9161814..385f18e3 100644
--- code/src/nettls-gnutls/nettls_gnutls.ml
+++ code/src/nettls-gnutls/nettls_gnutls.ml
@@ -4,7 +4,7 @@ open Printf
 
 module StrMap = Map.Make(String)
 module StrSet = Set.Make(String)
-module OID = struct type t = Netoid.t let compare = Pervasives.compare end
+module OID = struct type t = Netoid.t let compare = Stdlib.compare end
 module OIDMap = Map.Make(OID)
 
 module type GNUTLS_PROVIDER =
diff --git code/src/rpc-auth-local/rpclocal.c code/src/rpc-auth-local/rpclocal.c
index 905eef95..5656d473 100644
--- code/src/rpc-auth-local/rpclocal.c
+++ code/src/rpc-auth-local/rpclocal.c
@@ -35,8 +35,10 @@
 
 #define Nothing ((value) 0)
 
-extern void unix_error (int errcode, char * cmdname, value arg) Noreturn;
-extern void uerror (char * cmdname, value arg) Noreturn;
+/*
+extern void caml_unix_error (int errcode, char * cmdname, value arg) Noreturn;
+extern void caml_uerror (char * cmdname, value arg) Noreturn;
+*/
 
 /**********************************************************************/
 
@@ -58,7 +60,7 @@ value netsys_get_peer_credentials(value fd) {
     /* BSD, AIX, Cygwin */
     /* http://cr.yp.to/docs/secureipc.html */
     if (getpeereid(Int_val(fd), &uid, &gid) != 0) {
-	uerror("getpeereid", Nothing);
+	caml_uerror("getpeereid", Nothing);
     }
 
 #elif defined(SO_PEERCRED)
@@ -73,7 +75,7 @@ value netsys_get_peer_credentials(value fd) {
 		       SO_PEERCRED,
 		       &credentials,
 		       &len) == -1) {
-	    uerror("getsockopt",Nothing);
+	    caml_uerror("getsockopt",Nothing);
 	};
 	uid = credentials.uid;       /* Effective user ID */
 	gid = credentials.gid;       /* Effective group ID */
@@ -84,20 +86,20 @@ value netsys_get_peer_credentials(value fd) {
 	ucred_t    *ucred;
 	ucred = NULL;			/* must be initialized to NULL */
 	if (getpeerucred(Int_val(fd), &ucred) == -1) {
-	    uerror("getpeerucred",Nothing);
+	    caml_uerror("getpeerucred",Nothing);
 	};
 	if ((uid = ucred_geteuid(ucred)) == -1) {
-	    uerror("ucred_geteuid",Nothing);
+	    caml_uerror("ucred_geteuid",Nothing);
 	    ucred_free(ucred);
 	};
 	if ((gid = ucred_getegid(ucred)) == -1) {
-	    uerror("ucred_getegid",Nothing);
+	    caml_uerror("ucred_getegid",Nothing);
 	    ucred_free(ucred);
 	};
 	ucred_free(ucred);
     }
 #else
-    invalid_argument("get_peer_credentials");
+    caml_invalid_argument("get_peer_credentials");
 #endif
 
     /* Allocate a pair, and put the result into it: */
@@ -140,7 +142,7 @@ value netsys_peek_peer_credentials(value fd) {
 		       SO_PASSCRED,
 		       &one,
 		       sizeof(one)) < 0) {
-	    uerror("setsockopt", Nothing);
+	    caml_uerror("setsockopt", Nothing);
 	};
 
 	memset(&msg, 0, sizeof msg);
@@ -160,7 +162,7 @@ value netsys_peek_peer_credentials(value fd) {
 	 */
 
 	if (recvmsg(Int_val(fd), &msg, MSG_PEEK) < 0) {
-	    uerror("recvmsg", Nothing);
+	    caml_uerror("recvmsg", Nothing);
 	};
 
 	if (msg.msg_controllen == 0 ||
@@ -201,12 +203,12 @@ value netsys_peek_peer_credentials(value fd) {
 		       LOCAL_CREDS,
 		       &one,
 		       sizeof(one)) < 0) {
-	    uerror("setsockopt", Nothing);
+	    caml_uerror("setsockopt", Nothing);
 	};
 
 	memset(&msg, 0, sizeof msg);
 	crmsgsize = CMSG_SPACE(SOCKCREDSIZE(NGROUPS_MAX));
-	crmsg = stat_alloc(crmsgsize);
+	crmsg = caml_stat_alloc(crmsgsize);
 
 	memset(crmsg, 0, crmsgsize);
 	msg.msg_control = crmsg;
@@ -218,19 +220,19 @@ value netsys_peek_peer_credentials(value fd) {
 	iov.iov_len = 1;
 
 	if (recvmsg(Int_val(fd), &msg, MSG_PEEK) < 0) {
-	    stat_free(crmsg);
-	    uerror("recvmsg", Nothing);
+	    caml_stat_free(crmsg);
+	    caml_uerror("recvmsg", Nothing);
 	};
 
 	if (msg.msg_controllen == 0 ||
 	    (msg.msg_flags & MSG_CTRUNC) != 0) {
-	    stat_free(crmsg);
+	    caml_stat_free(crmsg);
 	    raise_not_found();
 	};
 	cmp = CMSG_FIRSTHDR(&msg);
 	if (cmp->cmsg_level != SOL_SOCKET ||
 	    cmp->cmsg_type != SCM_CREDS) {
-	    stat_free(crmsg);
+	    caml_stat_free(crmsg);
 	    raise_not_found();
 	};
 
@@ -241,7 +243,7 @@ value netsys_peek_peer_credentials(value fd) {
 	free(crmsg);
     }
 #else
-    invalid_argument("peek_peer_credentials");
+    caml_invalid_argument("peek_peer_credentials");
 #endif
 #endif
 
diff --git code/src/rpc-xti/rpcxti.c code/src/rpc-xti/rpcxti.c
index a4666d45..13b62703 100644
--- code/src/rpc-xti/rpcxti.c
+++ code/src/rpc-xti/rpcxti.c
@@ -24,8 +24,10 @@
 
 #define Nothing ((value) 0)
 
-extern void unix_error (int errcode, char * cmdname, value arg) Noreturn;
-extern void uerror (char * cmdname, value arg) Noreturn;
+/*
+extern void caml_unix_error (int errcode, char * cmdname, value arg) Noreturn;
+extern void caml_uerror (char * cmdname, value arg) Noreturn;
+*/
 
 /**********************************************************************/
 
@@ -41,7 +43,7 @@ void xti_error(int fd, char *cmdname) {
 
     if (fd >= 0) t_close(fd);
 
-    unix_error(n, cmdname, copy_string(error));
+    caml_unix_error(n, cmdname, caml_copy_string(error));
 }
 
 
@@ -76,13 +78,13 @@ value xti_cots_connect (value device, value addr) {
     sndcall.addr.maxlen = ABUFLEN;
     sndcall.sequence = 0;
 
-    if (string_length(addr) > sndcall.addr.maxlen) {
+    if (caml_string_length(addr) > sndcall.addr.maxlen) {
 	t_close(fd);
-	invalid_argument("cots_connect: address too long");
+	caml_invalid_argument("cots_connect: address too long");
     };
 
-    sndcall.addr.len = string_length(addr);
-    for (k=0; k<string_length(addr); k++) {
+    sndcall.addr.len = caml_string_length(addr);
+    for (k=0; k<caml_string_length(addr); k++) {
 	sndcall.addr.buf[k] = Byte(addr,k);
     };
     if (t_connect( fd, &sndcall, (struct t_call *) NULL) == -1 ) {
@@ -92,7 +94,7 @@ value xti_cots_connect (value device, value addr) {
     if (ioctl(fd, I_PUSH, "tirdwr") == -1) {
 	int e = errno;
 	t_close(fd);
-	unix_error(e, "ioctl(I_PUSH)", Nothing);
+	caml_unix_error(e, "ioctl(I_PUSH)", Nothing);
     }
 
     CAMLreturn(Val_int(fd));
diff --git code/src/rpc/rpc_client.ml code/src/rpc/rpc_client.ml
index 95ec6439..90b4c92a 100644
--- code/src/rpc/rpc_client.ml
+++ code/src/rpc/rpc_client.ml
@@ -49,7 +49,7 @@ let () =
 
 module SessionUint4 = struct
   type t = uint4
-  let compare = (Pervasives.compare : uint4 -> uint4 -> int)
+  let compare = (Stdlib.compare : uint4 -> uint4 -> int)
 end
 
 module SessionMap =
diff --git code/src/rpc/rpc_proxy.ml code/src/rpc/rpc_proxy.ml
index 76452a10..57562fc3 100644
--- code/src/rpc/rpc_proxy.ml
+++ code/src/rpc/rpc_proxy.ml
@@ -414,7 +414,7 @@ module ManagedClient = struct
       | `Up up -> up.serial
 
   let compare mc1 mc2 =
-    Pervasives.compare mc1.id mc2.id
+    Stdlib.compare mc1.id mc2.id
 
   let pending_calls mc =
     mc.pending_calls
@@ -1037,7 +1037,7 @@ module ManagedSet = struct
 	  (* Sort the services by total load first: *)
 	  Array.sort 
 	    (fun j1 j2 ->
-	       Pervasives.compare 
+	       Stdlib.compare 
 		 mset.total_load.(j1)
 		 mset.total_load.(j2)
 	    )
diff --git code/src/rpc/rpc_server.ml code/src/rpc/rpc_server.ml
index 43f9d396..3bb26adf 100644
--- code/src/rpc/rpc_server.ml
+++ code/src/rpc/rpc_server.ml
@@ -107,7 +107,7 @@ end
 module Uint4 = struct
   type t = uint4
   let compare (a:uint4) (b:uint4) =
-    (* avoid calling Pervasives.compare *)
+    (* avoid calling Stdlib.compare *)
     let a' = logical_int32_of_uint4 a in
     let b' = logical_int32_of_uint4 b in
     if a' = b' then
diff --git code/src/shell/Makefile code/src/shell/Makefile
index 86236b2b..1735097b 100644
--- code/src/shell/Makefile
+++ code/src/shell/Makefile
@@ -14,6 +14,8 @@ PP_OPTIONS = -pp "$(CPPO) $(PP_BYTES) $(PP_DEPRECATED)"
 
 INCLUDES += $(INC_EQUEUE) $(INC_NETSYS) $(INC_NETSTRING)
 
+REQUIRES += camlp-streams
+
 include $(TOP_DIR)/Makefile.rules
 
 include depend
