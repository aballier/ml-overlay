From 7589b17e3eeac885d2d7fb0676fd25028a8abbe4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Franc=CC=A7ois=20Pottier?= <francois.pottier@inria.fr>
Date: Sat, 27 Nov 2021 17:29:47 +0100
Subject: [PATCH 1/6] Specify (using menhir 2.0).

---
 dune-project | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dune-project b/dune-project
index df0efdaaf6..b07d263a99 100644
--- a/dune-project
+++ b/dune-project
@@ -1,4 +1,5 @@
 (lang dune 2.8)
+(using menhir 2.0)
 (name js_of_ocaml)
 
 (generate_opam_files true)

From df10f07aaad9a0a8fed22f3a24e76a3e7d4c61fb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Franc=CC=A7ois=20Pottier?= <francois.pottier@inria.fr>
Date: Sat, 27 Nov 2021 17:30:05 +0100
Subject: [PATCH 2/6] Build annot_parser using a (menhir) stanza.

This implicitly activates --infer and works around a bug of
the type-checker in OCaml 4.07-4.10.
---
 compiler/lib/dune | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/compiler/lib/dune b/compiler/lib/dune
index 7c60eb4b1f..c3467383a4 100644
--- a/compiler/lib/dune
+++ b/compiler/lib/dune
@@ -51,11 +51,10 @@
  (action
   (diff js_parser.conflicts.reference js_parser.conflicts)))
 
-(rule
- (targets annot_parser.mli annot_parser.ml)
- (deps standard.mly)
- (action
-  (run menhir --stdlib . --explain %{dep:annot_parser.mly})))
+(menhir
+  (modules annot_parser)
+  (flags --explain)
+)
 
 (rule
  (targets compiler_version.ml)

From 1ab9d4a56aed430fb76b44979c69cde1d4965058 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Franc=CC=A7ois=20Pottier?= <francois.pottier@inria.fr>
Date: Sat, 27 Nov 2021 17:38:00 +0100
Subject: [PATCH 3/6] js_parser.mly: remove [module J = Javascript] from the
 header.

This is a prerequisite for enabling --infer.
As a result, we have to use [open Javascript]
and remove explicit [J.] prefixes everywhere.
---
 compiler/lib/js_parser.mly | 254 ++++++++++++++++++-------------------
 1 file changed, 127 insertions(+), 127 deletions(-)

diff --git a/compiler/lib/js_parser.mly b/compiler/lib/js_parser.mly
index 94743e2cd8..09a43b3e17 100644
--- a/compiler/lib/js_parser.mly
+++ b/compiler/lib/js_parser.mly
@@ -29,9 +29,9 @@
  *  - jslint
  *)
 
-module J = Javascript
+open Javascript
 
-let var pi name = J.ident ~loc:(Pi pi) name
+let var pi name = ident ~loc:(Pi pi) name
 
 %}
 
@@ -147,9 +147,9 @@ standalone_expression:
 
 source_element:
  | statement
-   { let statement, pi = $1 in J.Statement statement, pi }
+   { let statement, pi = $1 in Statement statement, pi }
  | function_declaration
-   { let declaration, pi = $1 in J.Function_declaration declaration, pi }
+   { let declaration, pi = $1 in Function_declaration declaration, pi }
 
 (*************************************************************************)
 (* 1 statement                                                           *)
@@ -158,7 +158,7 @@ source_element:
 statement_no_semi:
  | block=curly_block(statement*)
    { let statements, pi_start, _pi_end = block in
-     J.Block statements, J.Pi pi_start }
+     Block statements, Pi pi_start }
  | s=if_statement
  | s=while_statement
  | s=for_statement
@@ -184,7 +184,7 @@ statement:
  | s=statement_need_semi either(T_SEMICOLON, T_VIRTUAL_SEMICOLON) { s }
 
 labeled_statement:
-| l=label T_COLON s=statement { J.Labelled_statement (l, s), J.N }
+| l=label T_COLON s=statement { Labelled_statement (l, s), N }
 
 block:
  | block=curly_block(statement*)
@@ -192,64 +192,64 @@ block:
 
 variable_statement:
  | pi=T_VAR list=separated_nonempty_list(T_COMMA, pair(variable, initializer_?))
-   { J.Variable_statement list, J.Pi pi }
+   { Variable_statement list, Pi pi }
 
 initializer_:
- | pi=T_ASSIGN e=assignment_expression { e, J.Pi pi }
+ | pi=T_ASSIGN e=assignment_expression { e, Pi pi }
 
 empty_statement:
- | pi=T_SEMICOLON { J.Empty_statement, J.Pi pi }
+ | pi=T_SEMICOLON { Empty_statement, Pi pi }
 
 debugger_statement:
- | pi=T_DEBUGGER { J.Debugger_statement, J.Pi pi }
+ | pi=T_DEBUGGER { Debugger_statement, Pi pi }
 
 expression_statement:
- | expression_no_statement { J.Expression_statement $1, J.N }
+ | expression_no_statement { Expression_statement $1, N }
 
 if_statement:
  | pi=T_IF condition=parenthesised(expression) t=statement T_ELSE e=statement
-     { (J.If_statement (condition, t, Some e), J.Pi pi) }
+     { (If_statement (condition, t, Some e), Pi pi) }
  | pi=T_IF condition=parenthesised(expression) t=statement %prec p_IF
-     { (J.If_statement (condition, t, None), J.Pi pi) }
+     { (If_statement (condition, t, None), Pi pi) }
 
 do_while_statement:
   | pi=T_DO body=statement T_WHILE condition=parenthesised(expression)
-    { (J.Do_while_statement (body, condition), J.Pi pi) }
+    { (Do_while_statement (body, condition), Pi pi) }
 
 while_statement:
  | pi=T_WHILE condition=parenthesised(expression) body=statement
-     { (J.While_statement (condition, body), J.Pi pi) }
+     { (While_statement (condition, body), Pi pi) }
 
 for_statement:
  | pi=T_FOR T_LPAREN initial=expression_no_in?
    T_SEMICOLON condition=expression? T_SEMICOLON increment=expression?
    T_RPAREN statement=statement
-   { J.For_statement (J.Left initial, condition, increment, statement), J.Pi pi }
+   { For_statement (Left initial, condition, increment, statement), Pi pi }
  | pi=T_FOR T_LPAREN T_VAR
    initial=separated_nonempty_list(T_COMMA, pair(variable, initializer_no_in?))
    T_SEMICOLON condition=expression?  T_SEMICOLON increment=expression?
    T_RPAREN statement=statement
-   { J.For_statement (J.Right initial, condition, increment, statement), J.Pi pi }
+   { For_statement (Right initial, condition, increment, statement), Pi pi }
 
 for_in_statement:
  | pi=T_FOR T_LPAREN left=left_hand_side_expression
    T_IN right=expression T_RPAREN body=statement
-   { J.ForIn_statement (J.Left left, right, body), J.Pi pi }
+   { ForIn_statement (Left left, right, body), Pi pi }
  | pi=T_FOR T_LPAREN T_VAR left=pair(variable, initializer_no_in?)
    T_IN right=expression T_RPAREN body=statement
-   { J.ForIn_statement (J.Right left, right, body), J.Pi pi }
+   { ForIn_statement (Right left, right, body), Pi pi }
 
 initializer_no_in:
- | T_ASSIGN assignment_expression_no_in { $2, J.Pi $1 }
+ | T_ASSIGN assignment_expression_no_in { $2, Pi $1 }
 
 continue_statement:
- | pi=T_CONTINUE label? { (J.Continue_statement $2,J.Pi pi) }
+ | pi=T_CONTINUE label? { (Continue_statement $2,Pi pi) }
 
 break_statement:
- | pi=T_BREAK label? { (J.Break_statement $2, J.Pi pi) }
+ | pi=T_BREAK label? { (Break_statement $2, Pi pi) }
 
 return_statement:
- | pi=T_RETURN expression? { (J.Return_statement $2, J.Pi pi) }
+ | pi=T_RETURN expression? { (Return_statement $2, Pi pi) }
 
 with_statement:
  | T_WITH parenthesised(expression) statement { assert false }
@@ -259,17 +259,17 @@ switch_statement:
    T_LCURLY pair=pair(case_clause*, pair(default_clause, case_clause*)?) T_RCURLY
    { let switch = match pair with
        | cases, None ->
-         J.Switch_statement (subject, cases, None, [])
+         Switch_statement (subject, cases, None, [])
        | cases, Some (default, more_cases) ->
-         J.Switch_statement (subject, cases, Some default, more_cases)
-      in switch, J.Pi pi }
+         Switch_statement (subject, cases, Some default, more_cases)
+      in switch, Pi pi }
 
 throw_statement:
- | pi=T_THROW expression { (J.Throw_statement $2, J.Pi pi) }
+ | pi=T_THROW expression { (Throw_statement $2, Pi pi) }
 
 try_statement:
- | pi=T_TRY block catch finally? { (J.Try_statement ($2, Some $3, $4), J.Pi pi) }
- | pi=T_TRY block       finally { (J.Try_statement ($2, None, Some $3), J.Pi pi) }
+ | pi=T_TRY block catch finally? { (Try_statement ($2, Some $3, $4), Pi pi) }
+ | pi=T_TRY block       finally { (Try_statement ($2, None, Some $3), Pi pi) }
 
 catch:
  | T_CATCH pair=pair(parenthesised(variable), block) { pair }
@@ -295,13 +295,13 @@ function_declaration:
  | pi=T_FUNCTION name=variable args=parenthesised(separated_list(T_COMMA, variable))
    block=curly_block(source_element*)
    { let elements, _pi_start, pi_end = block in
-     (name, args, elements, J.Pi pi_end), J.Pi pi }
+     (name, args, elements, Pi pi_end), Pi pi }
 
 function_expression:
  | pi=T_FUNCTION name=variable? args=parenthesised(separated_list(T_COMMA, variable))
    block=curly_block(source_element*)
    { let elements, _pi_start, _pi_end = block in
-     pi, J.EFun (name, args, elements, J.Pi pi) }
+     pi, EFun (name, args, elements, Pi pi) }
 
 (*************************************************************************)
 (* 1 expression                                                          *)
@@ -309,12 +309,12 @@ function_expression:
 
 expression:
  | assignment_expression { $1 }
- | expression T_COMMA assignment_expression { J.ESeq ($1, $3) }
+ | expression T_COMMA assignment_expression { ESeq ($1, $3) }
 
 assignment_expression:
  | conditional_expression { $1 }
  | left_hand_side_expression assignment_operator assignment_expression
-   { J.EBin ($2, $1, $3) }
+   { EBin ($2, $1, $3) }
 
 left_hand_side_expression:
  | new_expression  { snd $1 }
@@ -327,49 +327,49 @@ conditional_expression:
 ternary(condition, consequence):
  | condition=condition T_PLING consequence=consequence
                        T_COLON alternative=consequence
-   { J.ECond (condition, consequence, alternative) }
+   { ECond (condition, consequence, alternative) }
 
 post_in_expression:
  | pre_in_expression { $1 }
  | left=post_in_expression
    op=comparison_or_logical_or_bit_operator
    right=post_in_expression
-   { J.EBin (op, left, right) }
+   { EBin (op, left, right) }
 
 pre_in_expression:
  | left_hand_side_expression
    { $1 }
  | e=pre_in_expression op=postfix_operator
  | op=prefix_operator e=pre_in_expression
-   { J.EUn (op, e) }
+   { EUn (op, e) }
  | left=pre_in_expression
    op=arithmetic_or_shift_operator
    right=pre_in_expression
-   { J.EBin (op, left, right) }
+   { EBin (op, left, right) }
 
 call_expression:
  | member_expression arguments
-     { let (start, e) = $1 in (start, J.ECall(e, $2, J.Pi start)) }
+     { let (start, e) = $1 in (start, ECall(e, $2, Pi start)) }
  | call_expression arguments
-     { let (start, e) = $1 in (start, J.ECall(e, $2, J.Pi start)) }
+     { let (start, e) = $1 in (start, ECall(e, $2, Pi start)) }
  | call_expression T_LBRACKET expression T_RBRACKET
-     { let (start, e) = $1 in (start, J.EAccess (e, $3)) }
+     { let (start, e) = $1 in (start, EAccess (e, $3)) }
  | call_expression T_PERIOD identifier_or_kw
-     { let (start, e) = $1 in (start, J.EDot (e, $3)) }
+     { let (start, e) = $1 in (start, EDot (e, $3)) }
 
 new_expression:
  | member_expression    { $1 }
- | pi=T_NEW new_expression { (pi, J.ENew (snd $2,None)) }
+ | pi=T_NEW new_expression { (pi, ENew (snd $2,None)) }
 
 member_expression:
  | e=primary_expression
      { e }
  | member_expression T_LBRACKET e2=expression T_RBRACKET
-     { let (start, e1) = $1 in (start, J.EAccess (e1,e2)) }
+     { let (start, e1) = $1 in (start, EAccess (e1,e2)) }
  | member_expression T_PERIOD i=identifier_or_kw
-     { let (start, e1) = $1 in (start, J.EDot(e1,i)) }
+     { let (start, e1) = $1 in (start, EDot(e1,i)) }
  | pi=T_NEW e1=member_expression a=arguments
-     { (pi, J.ENew(snd e1, Some a)) }
+     { (pi, ENew(snd e1, Some a)) }
 
 primary_expression:
  | e=primary_expression_no_statement
@@ -377,12 +377,12 @@ primary_expression:
  | e=function_expression { e }
 
 primary_expression_no_statement:
- | pi=T_THIS         { (pi, J.EVar (var pi "this")) }
- | variable_with_loc { let (i, pi) = $1 in (pi, J.EVar i) }
+ | pi=T_THIS         { (pi, EVar (var pi "this")) }
+ | variable_with_loc { let (i, pi) = $1 in (pi, EVar i) }
  | n=null_literal    { n }
  | b=boolean_literal { b }
- | numeric_literal   { let (start, n) = $1 in (start, J.ENum (J.Num.of_string_unsafe n)) }
- | T_STRING          { let (s, start, _len) = $1 in (start, J.EStr (s, `Utf8)) }
+ | numeric_literal   { let (start, n) = $1 in (start, ENum (Num.of_string_unsafe n)) }
+ | T_STRING          { let (s, start, _len) = $1 in (start, EStr (s, `Utf8)) }
  | r=regex_literal                { r }
  | a=array_literal                { a }
  | pi=T_LPAREN e=expression T_RPAREN { (pi, e) }
@@ -393,12 +393,12 @@ primary_expression_no_statement:
 
 expression_no_in:
  | assignment_expression_no_in { $1 }
- | expression_no_in T_COMMA assignment_expression_no_in { J.ESeq ($1, $3) }
+ | expression_no_in T_COMMA assignment_expression_no_in { ESeq ($1, $3) }
 
 assignment_expression_no_in:
  | conditional_expression_no_in { $1 }
  | left_hand_side_expression assignment_operator assignment_expression_no_in
-     { J.EBin($2,$1,$3) }
+     { EBin($2,$1,$3) }
 
 conditional_expression_no_in:
  | post_in_expression_no_in { $1 }
@@ -409,7 +409,7 @@ post_in_expression_no_in:
  | left=post_in_expression_no_in
    op=comparison_or_logical_or_bit_operator_except_in
    right=post_in_expression
-   { J.EBin (op, left, right) }
+   { EBin (op, left, right) }
 
 (*----------------------------*)
 (* 2 (no statement)           *)
@@ -417,12 +417,12 @@ post_in_expression_no_in:
 
 expression_no_statement:
  | assignment_expression_no_statement { $1 }
- | expression_no_statement T_COMMA assignment_expression { J.ESeq($1,$3) }
+ | expression_no_statement T_COMMA assignment_expression { ESeq($1,$3) }
 
 assignment_expression_no_statement:
  | conditional_expression_no_statement { $1 }
  | left_hand_side_expression_no_statement assignment_operator assignment_expression
-   { J.EBin ($2,$1,$3) }
+   { EBin ($2,$1,$3) }
 
 conditional_expression_no_statement:
  | post_in_expression_no_statement { $1 }
@@ -433,18 +433,18 @@ post_in_expression_no_statement:
  | left=post_in_expression_no_statement
    op=comparison_or_logical_or_bit_operator
    right=post_in_expression
-   { J.EBin (op, left, right) }
+   { EBin (op, left, right) }
 
 pre_in_expression_no_statement:
  | left_hand_side_expression_no_statement
    { $1 }
  | e=pre_in_expression_no_statement op=postfix_operator
  | op=prefix_operator e=pre_in_expression
-   { J.EUn (op, e) }
+   { EUn (op, e) }
  | left=pre_in_expression_no_statement
    op=arithmetic_or_shift_operator
    right=pre_in_expression
-   { J.EBin (op, left, right) }
+   { EBin (op, left, right) }
 
 left_hand_side_expression_no_statement:
  | new_expression_no_statement { snd $1 }
@@ -452,38 +452,38 @@ left_hand_side_expression_no_statement:
 
 new_expression_no_statement:
  | member_expression_no_statement { $1 }
- | pi=T_NEW new_expression { (pi, J.ENew (snd $2,None)) }
+ | pi=T_NEW new_expression { (pi, ENew (snd $2,None)) }
 
 call_expression_no_statement:
  | member_expression_no_statement arguments
-   { let (start, e) = $1 in (start, J.ECall(e, $2, J.Pi start)) }
+   { let (start, e) = $1 in (start, ECall(e, $2, Pi start)) }
  | call_expression_no_statement arguments
-   { let (start, e) = $1 in (start, J.ECall(e, $2, J.Pi start)) }
+   { let (start, e) = $1 in (start, ECall(e, $2, Pi start)) }
  | call_expression_no_statement T_LBRACKET expression T_RBRACKET
-   { let (start, e) = $1 in (start, J.EAccess(e, $3)) }
+   { let (start, e) = $1 in (start, EAccess(e, $3)) }
  | call_expression_no_statement T_PERIOD identifier_or_kw
-   { let (start, e) = $1 in (start, J.EDot(e,$3)) }
+   { let (start, e) = $1 in (start, EDot(e,$3)) }
 
 member_expression_no_statement:
  | e=primary_expression_no_statement
    { e }
  | member_expression_no_statement T_LBRACKET e2=expression T_RBRACKET
-   { let (start, e1) = $1 in (start, J.EAccess(e1, e2)) }
+   { let (start, e1) = $1 in (start, EAccess(e1, e2)) }
  | member_expression_no_statement T_PERIOD i=identifier_or_kw
-   { let (start, e1) = $1 in (start, J.EDot(e1,i)) }
+   { let (start, e1) = $1 in (start, EDot(e1,i)) }
  | pi=T_NEW e=member_expression a=arguments
-   { (pi, J.ENew(snd e,Some a)) }
+   { (pi, ENew(snd e,Some a)) }
 
 (*----------------------------*)
 (* 2 scalar                   *)
 (*----------------------------*)
 
 null_literal:
- | pi=T_NULL { (pi, J.EVar (var pi "null")) }
+ | pi=T_NULL { (pi, EVar (var pi "null")) }
 
 boolean_literal:
- | pi=T_TRUE  { (pi, J.EBool true) }
- | pi=T_FALSE { (pi, J.EBool false) }
+ | pi=T_TRUE  { (pi, EBool true) }
+ | pi=T_FALSE { (pi, EBool false) }
 
 numeric_literal:
  | T_NUMBER { let (f, pi) = $1 in (pi, f) }
@@ -499,7 +499,7 @@ regex_literal:
        let i = String.rindex s '/' in
        String.sub s 1 (i - 1),Some (String.sub s (i+1) (len - i - 1))
    in
-   (pi, J.ERegexp (regexp, option)) }
+   (pi, ERegexp (regexp, option)) }
 
 (*----------------------------*)
 (* 2 array                    *)
@@ -507,13 +507,13 @@ regex_literal:
 
 array_literal:
  | pi=T_LBRACKET elison T_RBRACKET
-     { (pi, J.EArr $2) }
+     { (pi, EArr $2) }
  | pi=T_LBRACKET        T_RBRACKET
-     { (pi, J.EArr []) }
+     { (pi, EArr []) }
  | pi=T_LBRACKET element_list T_RBRACKET
-     { (pi, J.EArr $2) }
+     { (pi, EArr $2) }
  | pi=T_LBRACKET element_list_rev elison_rev T_RBRACKET
-     { (pi, J.EArr (List.rev_append $2 (List.rev $3))) }
+     { (pi, EArr (List.rev_append $2 (List.rev $3))) }
 
 element_list:
  | element_list_rev { List.rev $1 }
@@ -525,9 +525,9 @@ element_list_rev:
 
 object_literal:
  | block=curly_block(empty)
-   { let _pairs, pi_start, _pi_end = block in pi_start, J.EObj [] }
+   { let _pairs, pi_start, _pi_end = block in pi_start, EObj [] }
  | block=curly_block(separated_or_terminated_list(T_COMMA, object_key_value))
-   { let pairs, pi_start, _pi_end = block in pi_start, J.EObj pairs }
+   { let pairs, pi_start, _pi_end = block in pi_start, EObj pairs }
 
 object_key_value:
  | pair=separated_pair(property_name, T_COLON, assignment_expression) { pair }
@@ -594,13 +594,13 @@ variable_with_loc:
  | i=T_IDENTIFIER { let name, pi = i in var pi name, pi }
 
 label:
- | T_IDENTIFIER { J.Label.of_string (fst $1) }
+ | T_IDENTIFIER { Label.of_string (fst $1) }
 
 property_name:
- | i=identifier_or_kw { J.PNI i }
+ | i=identifier_or_kw { PNI i }
  | s=T_STRING         {
-    let s, _info, _len = s in J.PNS s }
- | n=numeric_literal  { J.PNN (J.Num.of_string_unsafe (snd n)) }
+    let s, _info, _len = s in PNS s }
+ | n=numeric_literal  { PNN (Num.of_string_unsafe (snd n)) }
 
 (*************************************************************************)
 (* 1 xxx_opt, xxx_list                                                   *)
@@ -621,65 +621,65 @@ curly_block(X):
 (*----------------------------*)
 
 %inline comparison_or_logical_or_bit_operator_except_in:
- | T_LESS_THAN          { J.Lt         }
- | T_GREATER_THAN       { J.Gt         }
- | T_LESS_THAN_EQUAL    { J.Le         }
- | T_GREATER_THAN_EQUAL { J.Ge         }
- | T_INSTANCEOF         { J.InstanceOf }
- | T_EQUAL              { J.EqEq       }
- | T_NOT_EQUAL          { J.NotEq      }
- | T_STRICT_EQUAL       { J.EqEqEq     }
- | T_STRICT_NOT_EQUAL   { J.NotEqEq    }
- | T_BIT_AND            { J.Band       }
- | T_BIT_XOR            { J.Bxor       }
- | T_BIT_OR             { J.Bor        }
- | T_AND                { J.And        }
- | T_OR                 { J.Or         }
+ | T_LESS_THAN          { Lt         }
+ | T_GREATER_THAN       { Gt         }
+ | T_LESS_THAN_EQUAL    { Le         }
+ | T_GREATER_THAN_EQUAL { Ge         }
+ | T_INSTANCEOF         { InstanceOf }
+ | T_EQUAL              { EqEq       }
+ | T_NOT_EQUAL          { NotEq      }
+ | T_STRICT_EQUAL       { EqEqEq     }
+ | T_STRICT_NOT_EQUAL   { NotEqEq    }
+ | T_BIT_AND            { Band       }
+ | T_BIT_XOR            { Bxor       }
+ | T_BIT_OR             { Bor        }
+ | T_AND                { And        }
+ | T_OR                 { Or         }
 
 %inline comparison_or_logical_or_bit_operator:
  | op=comparison_or_logical_or_bit_operator_except_in { op }
- | T_IN { J.In }
+ | T_IN { In }
 
 %inline arithmetic_or_shift_operator:
- | T_MULT    { J.Mul   }
- | T_DIV     { J.Div   }
- | T_MOD     { J.Mod   }
- | T_PLUS    { J.Plus  }
- | T_MINUS   { J.Minus }
- | T_LSHIFT  { J.Lsl   }
- | T_RSHIFT  { J.Asr   }
- | T_RSHIFT3 { J.Lsr   }
+ | T_MULT    { Mul   }
+ | T_DIV     { Div   }
+ | T_MOD     { Mod   }
+ | T_PLUS    { Plus  }
+ | T_MINUS   { Minus }
+ | T_LSHIFT  { Lsl   }
+ | T_RSHIFT  { Asr   }
+ | T_RSHIFT3 { Lsr   }
 
 %inline prefix_operator:
- | T_DELETE  { J.Delete }
- | T_VOID    { J.Void   }
- | T_TYPEOF  { J.Typeof }
- | T_INCR    { J.IncrB  }
- | T_INCR_NB { J.IncrB  }
- | T_DECR    { J.DecrB  }
- | T_DECR_NB { J.DecrB  }
- | T_PLUS    { J.Pl     }
- | T_MINUS   { J.Neg    }
- | T_BIT_NOT { J.Bnot   }
- | T_NOT     { J.Not    }
+ | T_DELETE  { Delete }
+ | T_VOID    { Void   }
+ | T_TYPEOF  { Typeof }
+ | T_INCR    { IncrB  }
+ | T_INCR_NB { IncrB  }
+ | T_DECR    { DecrB  }
+ | T_DECR_NB { DecrB  }
+ | T_PLUS    { Pl     }
+ | T_MINUS   { Neg    }
+ | T_BIT_NOT { Bnot   }
+ | T_NOT     { Not    }
 
 postfix_operator:
- | T_INCR_NB { J.IncrA }
- | T_DECR_NB { J.DecrA }
+ | T_INCR_NB { IncrA }
+ | T_DECR_NB { DecrA }
 
 assignment_operator:
- | T_ASSIGN         { J.Eq }
- | T_MULT_ASSIGN    { J.StarEq }
- | T_DIV_ASSIGN     { J.SlashEq }
- | T_MOD_ASSIGN     { J.ModEq }
- | T_PLUS_ASSIGN    { J.PlusEq }
- | T_MINUS_ASSIGN   { J.MinusEq }
- | T_LSHIFT_ASSIGN  { J.LslEq }
- | T_RSHIFT_ASSIGN  { J.AsrEq }
- | T_RSHIFT3_ASSIGN { J.LsrEq }
- | T_BIT_AND_ASSIGN { J.BandEq }
- | T_BIT_XOR_ASSIGN { J.BxorEq }
- | T_BIT_OR_ASSIGN  { J.BorEq }
+ | T_ASSIGN         { Eq }
+ | T_MULT_ASSIGN    { StarEq }
+ | T_DIV_ASSIGN     { SlashEq }
+ | T_MOD_ASSIGN     { ModEq }
+ | T_PLUS_ASSIGN    { PlusEq }
+ | T_MINUS_ASSIGN   { MinusEq }
+ | T_LSHIFT_ASSIGN  { LslEq }
+ | T_RSHIFT_ASSIGN  { AsrEq }
+ | T_RSHIFT3_ASSIGN { LsrEq }
+ | T_BIT_AND_ASSIGN { BandEq }
+ | T_BIT_XOR_ASSIGN { BxorEq }
+ | T_BIT_OR_ASSIGN  { BorEq }
 
 (* Library definitions *)
 

From a6927f424556fd9dc399cbadfedc0edfd13d82af Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Franc=CC=A7ois=20Pottier?= <francois.pottier@inria.fr>
Date: Sat, 27 Nov 2021 17:39:08 +0100
Subject: [PATCH 4/6] Build js_parser using a (menhir) stanza.

This implicitly enables --infer.
---
 compiler/lib/dune | 20 ++++++--------------
 1 file changed, 6 insertions(+), 14 deletions(-)

diff --git a/compiler/lib/dune b/compiler/lib/dune
index c3467383a4..c8b47c76b0 100644
--- a/compiler/lib/dune
+++ b/compiler/lib/dune
@@ -21,29 +21,21 @@
 
 ;; cp $(ocamlfind printconf path)/menhir/standard.mly standard.mly
 
-;; menhir is just noisy, both because this parser has conflicts, or
-;; because we don't use --infer (to avoid having to write  manually and
-;; badly specified dependencieds), so we just discard stderr.
-
-(rule
- (targets js_parser.mli js_parser.ml js_parser.conflicts)
- (deps standard.mly)
- (action
-  (run
-   menhir
-   --stdlib
-   .
+(menhir
+  (modules js_parser)
+  (flags
    --table
    --external-tokens
    Js_token
    --explain
-   %{dep:js_parser.mly}
    --unused-token
    TComment
    --unused-token
    TCommentLineDirective
    --unused-token
-   TUnknown)))
+   TUnknown
+  )
+)
 
 (rule
  (alias runtest)

From b450be205751f944a229a97ea7f10b0f838cb7ef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Franc=CC=A7ois=20Pottier?= <francois.pottier@inria.fr>
Date: Sat, 27 Nov 2021 17:40:43 +0100
Subject: [PATCH 5/6] Remove compiler/lib/standard.mly (unused by recent
 versions of Menhir).

Recent versions of Menhir have a built-in copy of standard.mly
and ignore --stdlib.
---
 compiler/lib/dune         |   2 -
 compiler/lib/standard.mly | 269 --------------------------------------
 2 files changed, 271 deletions(-)
 delete mode 100644 compiler/lib/standard.mly

diff --git a/compiler/lib/dune b/compiler/lib/dune
index c8b47c76b0..6f0377d696 100644
--- a/compiler/lib/dune
+++ b/compiler/lib/dune
@@ -19,8 +19,6 @@
 
 (ocamllex js_lexer annot_lexer)
 
-;; cp $(ocamlfind printconf path)/menhir/standard.mly standard.mly
-
 (menhir
   (modules js_parser)
   (flags
diff --git a/compiler/lib/standard.mly b/compiler/lib/standard.mly
deleted file mode 100644
index 2bf85a2154..0000000000
--- a/compiler/lib/standard.mly
+++ /dev/null
@@ -1,269 +0,0 @@
-/******************************************************************************/
-/*                                                                            */
-/*                                   Menhir                                   */
-/*                                                                            */
-/*                       François Pottier, Inria Paris                        */
-/*              Yann Régis-Gianas, PPS, Université Paris Diderot              */
-/*                                                                            */
-/*  Copyright Inria. All rights reserved. This file is distributed under the  */
-/*  terms of the GNU Library General Public License version 2, with a         */
-/*  special exception on linking, as described in the file LICENSE.           */
-/*                                                                            */
-/******************************************************************************/
-
-(* This is menhir's standard library. It offers a number of
-   parameterized nonterminal definitions, such as options and lists,
-   that should be useful in a number of circumstances. *)
-
-%%
-
-(* ------------------------------------------------------------------------- *)
-(* The identity. *)
-
-(* [endrule(X)] is the same as [X]. *)
-
-(* This allows placing an anonymous subrule in the middle of a rule, as in:
-
-     cat
-     endrule(dog { action1 })
-     cow
-     { action2 }
-
-   Because [endrule] is marked %inline, everything is expanded away. So,
-   this is equivalent to:
-
-     cat dog cow { action1; action2 }
-
-   Note that [action1] moves to the end of the rule. The anonymous subrule
-   can even have several branches, as in:
-
-     cat
-     endrule(dog { action1a } | fox { action1b })
-     cow
-     { action2 }
-
-   This is expanded to:
-
-     cat dog cow { action1a; action2 }
-   | cat fox cow { action1b; action2 }
-
-*)
-
-%public %inline endrule(X):
-x = X
-    { x }
-
-(* [anonymous(X)] is a deprecated synonym for [endrule(X)].
-   It was never documented. *)
-
-%public %inline anonymous(X):
-x = X
-    { x }
-
-(* [midrule(X)] is the same as [X]. *)
-
-(* This allows placing an anonymous subrule in the middle of a rule, as in:
-
-     cat
-     midrule(dog { action1 })
-     cow
-     { action2 }
-
-   Because [midrule] is not marked %inline, this is equivalent to:
-
-     cat xxx cow { action2 }
-
-   where the fresh nonterminal symbol [xxx] is separately defined by:
-
-     xxx: dog { action1 }
-
-   In particular, if there is no [dog], what we get is a semantic action
-   embedded in the middle of a rule. For instance,
-
-     cat midrule({ action1 }) cow { action2 }
-
-   is equivalent to:
-
-     cat xxx cow { action2 }
-
-   where [xxx] is separately defined by the rule:
-
-     xxx: { action1 }
-
-*)
-
-%public midrule(X):
-x = X
-    { x }
-
-(* [embedded(X)] is a deprecated synonym for [midrule(X)].
-   It was never documented. *)
-
-%public embedded(X):
-x = X
-    { x }
-
-(* ------------------------------------------------------------------------- *)
-(* Options. *)
-
-(* [option(X)] recognizes either nothing or [X]. It produces a value
-   of type ['a option] if [X] produces a value of type ['a]. *)
-
-%public option(X):
-  /* nothing */
-    { None }
-| x = X
-    { Some x }
-
-(* [ioption(X)] is identical to [option(X)], except its definition is
-   inlined. This has the effect of duplicating the production that
-   refers to it, possibly eliminating an LR(1) conflict. *)
-
-%public %inline ioption(X):
-  /* nothing */
-    { None }
-| x = X
-    { Some x }
-
-(* [boption(X)] recognizes either nothing or [X]. It produces a value
-   of type [bool]. *)
-
-%public boption(X):
-  /* nothing */
-    { false }
-| X
-    { true }
-
-(* [loption(X)] recognizes either nothing or [X]. It produces a value
-   of type ['a list] if [X] produces a value of type ['a list]. *)
-
-%public loption(X):
-  /* nothing */
-    { [] }
-| x = X
-    { x }
-
-(* ------------------------------------------------------------------------- *)
-(* Sequences. *)
-
-(* [epsilon] recognizes the empty word. It can be used instead of the
-   traditional /* empty */ comment. *)
-
-(* NOT YET ADDED because we first need to remove the limitation that
-   every symbol must be reachable from the start symbol!
-
-%public %inline epsilon:
-  /* empty */
-    { () }
-
- *)
-
-(* [pair(X, Y)] recognizes the sequence [X Y]. It produces a value of
-   type ['a * 'b] if [X] and [Y] produce values of type ['a] and ['b],
-   respectively. *)
-
-%public %inline pair(X, Y):
-  x = X; y = Y
-    { (x, y) }
-
-(* [separated_pair(X, sep, Y)] recognizes the sequence [X sep Y]. It
-   produces a value of type ['a * 'b] if [X] and [Y] produce values of
-   type ['a] and ['b], respectively. *)
-
-%public %inline separated_pair(X, sep, Y):
-  x = X; sep; y = Y
-    { (x, y) }
-
-(* [preceded(opening, X)] recognizes the sequence [opening X]. It
-   passes on the value produced by [X], so that it produces a value of
-   type ['a] if [X] produces a value of type ['a]. *)
-
-%public %inline preceded(opening, X):
-  opening; x = X
-    { x }
-
-(* [terminated(X, closing)] recognizes the sequence [X closing]. It
-   passes on the value produced by [X], so that it produces a value of
-   type ['a] if [X] produces a value of type ['a]. *)
-
-%public %inline terminated(X, closing):
-  x = X; closing
-    { x }
-
-(* [delimited(opening, X, closing)] recognizes the sequence [opening X
-   closing]. It passes on the value produced by [X], so that it
-   produces a value of type ['a] if [X] produces a value of type
-   ['a]. *)
-
-%public %inline delimited(opening, X, closing):
-  opening; x = X; closing
-    { x }
-
-(* ------------------------------------------------------------------------- *)
-(* Lists. *)
-
-(* [list(X)] recognizes a possibly empty list of [X]'s. It produces a
-   value of type ['a list] if [X] produces a value of type ['a]. The
-   front element of the list is the first element that was parsed. *)
-
-%public list(X):
-  /* nothing */
-    { [] }
-| x = X; xs = list(X)
-    { x :: xs }
-
-(* [nonempty_list(X)] recognizes a nonempty list of [X]'s. It produces
-   a value of type ['a list] if [X] produces a value of type ['a]. The
-   front element of the list is the first element that was parsed. *)
-
-%public nonempty_list(X):
-  x = X
-    { [ x ] }
-| x = X; xs = nonempty_list(X)
-    { x :: xs }
-
-(* [separated_list(separator, X)] recognizes a possibly empty list of
-   [X]'s, separated with [separator]'s. It produces a value of type
-   ['a list] if [X] produces a value of type ['a]. The front element
-   of the list is the first element that was parsed. *)
-
-%public %inline separated_list(separator, X):
-  xs = loption(separated_nonempty_list(separator, X))
-    { xs }
-
-(* [separated_nonempty_list(separator, X)] recognizes a nonempty list
-   of [X]'s, separated with [separator]'s. It produces a value of type
-   ['a list] if [X] produces a value of type ['a]. The front element
-   of the list is the first element that was parsed. *)
-
-%public separated_nonempty_list(separator, X):
-  x = X
-    { [ x ] }
-| x = X; separator; xs = separated_nonempty_list(separator, X)
-    { x :: xs }
-
-(* ------------------------------------------------------------------------- *)
-(* List manipulation and transformation. *)
-
-(* [rev(XS)] recognizes the same language as [XS], but reverses the resulting
-   OCaml list. (20181005) *)
-
-%public %inline rev(XS):
-  xs = XS
-    { List.rev xs }
-
-(* [flatten(XSS)] recognizes the same language as [XSS], and flattens the
-   resulting OCaml list of lists. (20181005) *)
-
-%public %inline flatten(XSS):
-  xss = XSS
-    { List.flatten xss }
-
-(* [append(XS, YS)] recognizes [XS YS], and appends (concatenates) the
-   resulting OCaml lists. (20181005) *)
-
-%public %inline append(XS, YS):
-  xs = XS ys = YS
-    { xs @ ys }
-
-%%

From 0dc9835820dcc18fcd8176fd63e21b772bc62293 Mon Sep 17 00:00:00 2001
From: Sora Morimoto <sora@morimoto.io>
Date: Sun, 28 Nov 2021 03:48:16 +0900
Subject: [PATCH 6/6] Remove an unnecessary runtest rule stanza

Signed-off-by: Sora Morimoto <sora@morimoto.io>
---
 compiler/lib/dune                          | 37 ++++++++--------------
 compiler/lib/js_parser.conflicts.reference |  0
 2 files changed, 14 insertions(+), 23 deletions(-)
 delete mode 100644 compiler/lib/js_parser.conflicts.reference

diff --git a/compiler/lib/dune b/compiler/lib/dune
index 6f0377d696..2fefafb3d0 100644
--- a/compiler/lib/dune
+++ b/compiler/lib/dune
@@ -20,31 +20,22 @@
 (ocamllex js_lexer annot_lexer)
 
 (menhir
-  (modules js_parser)
-  (flags
-   --table
-   --external-tokens
-   Js_token
-   --explain
-   --unused-token
-   TComment
-   --unused-token
-   TCommentLineDirective
-   --unused-token
-   TUnknown
-  )
-)
-
-(rule
- (alias runtest)
- (deps js_parser.conflicts.reference js_parser.conflicts)
- (action
-  (diff js_parser.conflicts.reference js_parser.conflicts)))
+ (modules js_parser)
+ (flags
+  --table
+  --external-tokens
+  Js_token
+  --explain
+  --unused-token
+  TComment
+  --unused-token
+  TCommentLineDirective
+  --unused-token
+  TUnknown))
 
 (menhir
-  (modules annot_parser)
-  (flags --explain)
-)
+ (modules annot_parser)
+ (flags --explain))
 
 (rule
  (targets compiler_version.ml)
diff --git a/compiler/lib/js_parser.conflicts.reference b/compiler/lib/js_parser.conflicts.reference
deleted file mode 100644
index e69de29bb2..0000000000
