Index: coq-8.16.0/clib/cThread.ml
===================================================================
--- coq-8.16.0.orig/clib/cThread.ml
+++ coq-8.16.0/clib/cThread.ml
@@ -118,7 +118,7 @@ let create f x =
 *)
 
 (* We inline the call to Mutex.unlock to avoid polling in bytecode mode *)
-external unlock: Mutex.t -> unit = "caml_mutex_unlock"
+external unlock: Mutex.t -> unit = "caml_ml_mutex_unlock"
 
 let[@inline never] with_lock m ~scope =
   let () = Mutex.lock m (* BEGIN ATOMIC *) in
Index: coq-8.16.0/dune-project
===================================================================
--- coq-8.16.0.orig/dune-project
+++ coq-8.16.0/dune-project
@@ -27,6 +27,7 @@
   (ocaml (>= 4.09.0))
   (ocamlfind (>= 1.8.1))
   (zarith (>= 1.11))
+  (camlp-streams (>= 5.0))
   (ounit2 :with-test))
  (synopsis "The Coq Proof Assistant -- Core Binaries and Tools")
  (description "Coq is a formal proof management system. It provides
Index: coq-8.16.0/kernel/byterun/coq_interp.c
===================================================================
--- coq-8.16.0.orig/kernel/byterun/coq_interp.c
+++ coq-8.16.0/kernel/byterun/coq_interp.c
@@ -567,7 +567,7 @@ value coq_interprete
       CHECK_STACK(0);
       /* We also check for signals */
 #if OCAML_VERSION >= 50000
-      if (Caml_check_gc_interrupt(Caml_state) || caml_check_for_pending_signals()) {
+      if (Caml_check_gc_interrupt(Caml_state) || caml_check_pending_signals()) {
         // FIXME: it should be caml_process_pending_actions_exn
         value res = caml_process_pending_signals_exn();
         Handle_potential_exception(res);
Index: coq-8.16.0/kernel/nativevalues.ml
===================================================================
--- coq-8.16.0.orig/kernel/nativevalues.ml
+++ coq-8.16.0/kernel/nativevalues.ml
@@ -96,14 +96,13 @@ let mk_accu (a : atom) : t =
     else
       let data = { data with acc_arg = x :: data.acc_arg } in
       let ans = Obj.repr (accumulate data) in
-      let () = Obj.set_tag ans accumulate_tag [@ocaml.warning "-3"] in
-      ans
+      Obj.with_tag accumulate_tag ans [@ocaml.warning "-3"] 
   in
   let acc = { acc_atm = a; acc_arg = [] } in
   let ans = Obj.repr (accumulate acc) in
   (** FIXME: use another representation for accumulators, this causes naked
       pointers. *)
-  let () = Obj.set_tag ans accumulate_tag [@ocaml.warning "-3"] in
+  let ans = Obj.with_tag accumulate_tag ans [@ocaml.warning "-3"] in
   (Obj.obj ans : t)
 
 let get_accu (k : accumulator) =
Index: coq-8.16.0/lib/dune
===================================================================
--- coq-8.16.0.orig/lib/dune
+++ coq-8.16.0/lib/dune
@@ -4,4 +4,4 @@
  (public_name coq-core.lib)
  (wrapped false)
  (modules_without_implementation xml_datatype)
- (libraries coq-core.boot coq-core.clib coq-core.config))
+ (libraries coq-core.boot coq-core.clib coq-core.config camlp-streams))
