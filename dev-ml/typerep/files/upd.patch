From db394f11d0f2aaba08c83d510ba9e46c467f3829 Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Tue, 13 Aug 2024 20:53:44 +0100
Subject: [PATCH] v0.17~preview.129.36+325

---
 lib/std_internal.ml            | 298 ++++++++++++++++++++++-----------
 lib/std_internal.mli           | 135 ++++++++++-----
 lib/type_equal.ml              |   4 +-
 lib/type_equal.mli             |   4 +-
 lib/type_generic.ml            |  72 ++++----
 lib/type_generic.mli           |  24 +--
 lib/type_generic_intf.ml       |  10 +-
 lib/typename.ml                |   4 +-
 lib/typename.mli               |   4 +-
 lib/typerep_obj.ml             |  11 ++
 lib/typerep_obj.mli            |   6 +
 lib/variant_and_record_intf.ml |  12 +-
 12 files changed, 384 insertions(+), 200 deletions(-)

diff --git a/lib/std_internal.ml b/lib/std_internal.ml
index 8197ddc..aec5dd4 100644
--- a/lib/std_internal.ml
+++ b/lib/std_internal.ml
@@ -21,6 +21,17 @@ module Name_of = struct
     M.typename_of_t
   ;;
 
+  let typename_of_int32_u =
+    let module M =
+      Typename.Make0 (struct
+        type t = unit -> int32
+
+        let name = "int32#"
+      end)
+    in
+    M.typename_of_t
+  ;;
+
   let typename_of_int64 =
     let module M =
       Typename.Make0 (struct
@@ -32,6 +43,17 @@ module Name_of = struct
     M.typename_of_t
   ;;
 
+  let typename_of_int64_u =
+    let module M =
+      Typename.Make0 (struct
+        type t = unit -> int64
+
+        let name = "int64#"
+      end)
+    in
+    M.typename_of_t
+  ;;
+
   let typename_of_nativeint =
     let module M =
       Typename.Make0 (struct
@@ -43,6 +65,17 @@ module Name_of = struct
     M.typename_of_t
   ;;
 
+  let typename_of_nativeint_u =
+    let module M =
+      Typename.Make0 (struct
+        type t = unit -> nativeint
+
+        let name = "nativeint#"
+      end)
+    in
+    M.typename_of_t
+  ;;
+
   let typename_of_char =
     let module M =
       Typename.Make0 (struct
@@ -65,6 +98,17 @@ module Name_of = struct
     M.typename_of_t
   ;;
 
+  let typename_of_float_u =
+    let module M =
+      Typename.Make0 (struct
+        type t = unit -> float
+
+        let name = "float#"
+      end)
+    in
+    M.typename_of_t
+  ;;
+
   let typename_of_string =
     let module M =
       Typename.Make0 (struct
@@ -110,119 +154,131 @@ module Name_of = struct
   ;;
 
   module M_option = Typename.Make1 (struct
-    type 'a t = 'a option
+      type 'a t = 'a option
 
-    let name = "option"
-  end)
+      let name = "option"
+    end)
 
   let typename_of_option = M_option.typename_of_t
 
   module M_list = Typename.Make1 (struct
-    type 'a t = 'a list
+      type 'a t = 'a list
 
-    let name = "list"
-  end)
+      let name = "list"
+    end)
 
   let typename_of_list = M_list.typename_of_t
 
   module M_array = Typename.Make1 (struct
-    type 'a t = 'a array
+      type 'a t = 'a array
 
-    let name = "array"
-  end)
+      let name = "array"
+    end)
 
   let typename_of_array = M_array.typename_of_t
 
   module M_lazy_t = Typename.Make1 (struct
-    type 'a t = 'a lazy_t
+      type 'a t = 'a lazy_t
 
-    let name = "lazy_t"
-  end)
+      let name = "lazy_t"
+    end)
 
   let typename_of_lazy_t = M_lazy_t.typename_of_t
 
   module M_ref = Typename.Make1 (struct
-    type 'a t = 'a ref
+      type 'a t = 'a ref
 
-    let name = "ref"
-  end)
+      let name = "ref"
+    end)
 
   let typename_of_ref = M_ref.typename_of_t
 
   module M_function = Typename.Make2 (struct
-    type ('a, 'b) t = 'a -> 'b
+      type ('a, 'b) t = 'a -> 'b
 
-    let name = "function"
-  end)
+      let name = "function"
+    end)
 
   let typename_of_function = M_function.typename_of_t
 
   type tuple0 = unit
 
   module M_tuple0 = Typename.Make0 (struct
-    type t = tuple0
+      type t = tuple0
 
-    let name = "tuple0"
-  end)
+      let name = "tuple0"
+    end)
 
   let typename_of_tuple0 = M_tuple0.typename_of_t
 
   module M_tuple2 = Typename.Make2 (struct
-    type ('a, 'b) t = 'a * 'b
+      type ('a, 'b) t = 'a * 'b
 
-    let name = "tuple2"
-  end)
+      let name = "tuple2"
+    end)
 
   let typename_of_tuple2 = M_tuple2.typename_of_t
 
   module M_tuple3 = Typename.Make3 (struct
-    type ('a, 'b, 'c) t = 'a * 'b * 'c
+      type ('a, 'b, 'c) t = 'a * 'b * 'c
 
-    let name = "tuple3"
-  end)
+      let name = "tuple3"
+    end)
 
   let typename_of_tuple3 = M_tuple3.typename_of_t
 
   module M_tuple4 = Typename.Make4 (struct
-    type ('a, 'b, 'c, 'd) t = 'a * 'b * 'c * 'd
+      type ('a, 'b, 'c, 'd) t = 'a * 'b * 'c * 'd
 
-    let name = "tuple4"
-  end)
+      let name = "tuple4"
+    end)
 
   let typename_of_tuple4 = M_tuple4.typename_of_t
 
   module M_tuple5 = Typename.Make5 (struct
-    type ('a, 'b, 'c, 'd, 'e) t = 'a * 'b * 'c * 'd * 'e
+      type ('a, 'b, 'c, 'd, 'e) t = 'a * 'b * 'c * 'd * 'e
 
-    let name = "tuple5"
-  end)
+      let name = "tuple5"
+    end)
 
   let typename_of_tuple5 = M_tuple5.typename_of_t
 end
 
 module rec Typerep : sig
-  type _ t =
-    | Int : int t
-    | Int32 : int32 t
-    | Int64 : int64 t
-    | Nativeint : nativeint t
-    | Char : char t
-    | Float : float t
-    | String : string t
-    | Bytes : bytes t
-    | Bool : bool t
-    | Unit : unit t
-    | Option : 'a t -> 'a option t
-    | List : 'a t -> 'a list t
-    | Array : 'a t -> 'a array t
-    | Lazy : 'a t -> 'a lazy_t t
-    | Ref : 'a t -> 'a ref t
-    | Function : ('dom t * 'rng t) -> ('dom -> 'rng) t
-    | Tuple : 'a Typerep.Tuple.t -> 'a t
-    | Record : 'a Typerep.Record.t -> 'a t
-    | Variant : 'a Typerep.Variant.t -> 'a t
-    | Named : ('a Typerep.Named.t * 'a t lazy_t option) -> 'a t
-
+  type value := [ `value ]
+  type non_value := [ `non_value ]
+
+  type (_, _) t_any =
+    | Int : (int, value) t_any
+    | Int32 : (int32, value) t_any
+    | Int64 : (int64, value) t_any
+    | Nativeint : (nativeint, value) t_any
+    | Char : (char, value) t_any
+    | Float : (float, value) t_any
+    | String : (string, value) t_any
+    | Bytes : (bytes, value) t_any
+    | Bool : (bool, value) t_any
+    | Unit : (unit, value) t_any
+    | Option : ('a, value) t_any -> ('a option, value) t_any
+    | List : ('a, value) t_any -> ('a list, value) t_any
+    | Array : ('a, value) t_any -> ('a array, value) t_any
+    | Lazy : ('a, value) t_any -> ('a lazy_t, value) t_any
+    | Ref : ('a, value) t_any -> ('a ref, value) t_any
+    | Function :
+        (('dom, value) t_any * ('rng, value) t_any)
+        -> ('dom -> 'rng, value) t_any
+    | Tuple : 'a Typerep.Tuple.t -> ('a, value) t_any
+    | Record : 'a Typerep.Record.t -> ('a, value) t_any
+    | Variant : 'a Typerep.Variant.t -> ('a, value) t_any
+    | Named : ('a Typerep.Named.t * ('a, value) t_any lazy_t option) -> ('a, value) t_any
+    | Int32_u : (unit -> int32, non_value) t_any
+    | Int64_u : (unit -> int64, non_value) t_any
+    | Nativeint_u : (unit -> nativeint, non_value) t_any
+    | Float_u : (unit -> float, non_value) t_any
+
+  type 'a t = ('a, value) t_any
+  type 'a t_non_value = (unit -> 'a, non_value) t_any
+  type 'a any_packed = T : ('a, _) t_any -> 'a any_packed
   type packed = T : 'a t -> packed
 
   module Named : sig
@@ -378,49 +434,70 @@ module rec Typerep : sig
     (* these constructors could be plunged at toplevel of Typerep.t, however it is less
        verbose that way *)
     type _ t =
-      | T2 : ('a Typerep.t * 'b Typerep.t) -> ('a * 'b) t
-      | T3 : ('a Typerep.t * 'b Typerep.t * 'c Typerep.t) -> ('a * 'b * 'c) t
+      | T2 : (('a, _) Typerep.t_any * ('b, _) Typerep.t_any) -> ('a * 'b) t
+      | T3 :
+          (('a, _) Typerep.t_any * ('b, _) Typerep.t_any * ('c, _) Typerep.t_any)
+          -> ('a * 'b * 'c) t
       | T4 :
-          ('a Typerep.t * 'b Typerep.t * 'c Typerep.t * 'd Typerep.t)
+          (('a, _) Typerep.t_any
+          * ('b, _) Typerep.t_any
+          * ('c, _) Typerep.t_any
+          * ('d, _) Typerep.t_any)
           -> ('a * 'b * 'c * 'd) t
       | T5 :
-          ('a Typerep.t * 'b Typerep.t * 'c Typerep.t * 'd Typerep.t * 'e Typerep.t)
+          (('a, _) Typerep.t_any
+          * ('b, _) Typerep.t_any
+          * ('c, _) Typerep.t_any
+          * ('d, _) Typerep.t_any
+          * ('e, _) Typerep.t_any)
           -> ('a * 'b * 'c * 'd * 'e) t
 
     val arity : _ t -> int
     val typename_of_t : 'a t -> 'a Typename.t
   end
 
-  include Variant_and_record_intf.S with type 'a t := 'a Typerep.t
+  include Variant_and_record_intf.S with type 'a t := 'a any_packed
 
-  val same : _ t -> _ t -> bool
-  val same_witness : 'a t -> 'b t -> ('a, 'b) Type_equal.t option
-  val same_witness_exn : 'a t -> 'b t -> ('a, 'b) Type_equal.t
-  val typename_of_t : 'a t -> 'a Typename.t
-  val head : 'a t -> 'a t
+  val same : _ t_any -> _ t_any -> bool
+  val same_witness : ('a, _) t_any -> ('b, _) t_any -> ('a, 'b) Type_equal.t option
+  val same_witness_exn : ('a, _) t_any -> ('b, _) t_any -> ('a, 'b) Type_equal.t
+  val typename_of_t : ('a, _) t_any -> 'a Typename.t
+  val head : ('a, 'index) t_any -> ('a, 'index) t_any
 end = struct
-  type _ t =
-    | Int : int t
-    | Int32 : int32 t
-    | Int64 : int64 t
-    | Nativeint : nativeint t
-    | Char : char t
-    | Float : float t
-    | String : string t
-    | Bytes : bytes t
-    | Bool : bool t
-    | Unit : unit t
-    | Option : 'a t -> 'a option t
-    | List : 'a t -> 'a list t
-    | Array : 'a t -> 'a array t
-    | Lazy : 'a t -> 'a lazy_t t
-    | Ref : 'a t -> 'a ref t
-    | Function : ('dom t * 'rng t) -> ('dom -> 'rng) t
-    | Tuple : 'a Typerep.Tuple.t -> 'a t
-    | Record : 'a Typerep.Record.t -> 'a t
-    | Variant : 'a Typerep.Variant.t -> 'a t
-    | Named : ('a Typerep.Named.t * 'a t lazy_t option) -> 'a t
-
+  type value = [ `value ]
+  type non_value = [ `non_value ]
+
+  type (_, _) t_any =
+    | Int : (int, value) t_any
+    | Int32 : (int32, value) t_any
+    | Int64 : (int64, value) t_any
+    | Nativeint : (nativeint, value) t_any
+    | Char : (char, value) t_any
+    | Float : (float, value) t_any
+    | String : (string, value) t_any
+    | Bytes : (bytes, value) t_any
+    | Bool : (bool, value) t_any
+    | Unit : (unit, value) t_any
+    | Option : ('a, value) t_any -> ('a option, value) t_any
+    | List : ('a, value) t_any -> ('a list, value) t_any
+    | Array : ('a, value) t_any -> ('a array, value) t_any
+    | Lazy : ('a, value) t_any -> ('a lazy_t, value) t_any
+    | Ref : ('a, value) t_any -> ('a ref, value) t_any
+    | Function :
+        (('dom, value) t_any * ('rng, value) t_any)
+        -> ('dom -> 'rng, value) t_any
+    | Tuple : 'a Typerep.Tuple.t -> ('a, value) t_any
+    | Record : 'a Typerep.Record.t -> ('a, value) t_any
+    | Variant : 'a Typerep.Variant.t -> ('a, value) t_any
+    | Named : ('a Typerep.Named.t * ('a, value) t_any lazy_t option) -> ('a, value) t_any
+    | Int32_u : (unit -> int32, non_value) t_any
+    | Int64_u : (unit -> int64, non_value) t_any
+    | Nativeint_u : (unit -> nativeint, non_value) t_any
+    | Float_u : (unit -> float, non_value) t_any
+
+  type 'a t = ('a, value) t_any
+  type 'a t_non_value = (unit -> 'a, non_value) t_any
+  type 'a any_packed = T : ('a, _) t_any -> 'a any_packed
   type packed = T : 'a t -> packed
 
   module Named = struct
@@ -604,13 +681,22 @@ end = struct
     (* these constructors could be plunged at toplevel of Typerep.t, however it is less
        verbose this way *)
     type _ t =
-      | T2 : ('a Typerep.t * 'b Typerep.t) -> ('a * 'b) t
-      | T3 : ('a Typerep.t * 'b Typerep.t * 'c Typerep.t) -> ('a * 'b * 'c) t
+      | T2 : (('a, _) Typerep.t_any * ('b, _) Typerep.t_any) -> ('a * 'b) t
+      | T3 :
+          (('a, _) Typerep.t_any * ('b, _) Typerep.t_any * ('c, _) Typerep.t_any)
+          -> ('a * 'b * 'c) t
       | T4 :
-          ('a Typerep.t * 'b Typerep.t * 'c Typerep.t * 'd Typerep.t)
+          (('a, _) Typerep.t_any
+          * ('b, _) Typerep.t_any
+          * ('c, _) Typerep.t_any
+          * ('d, _) Typerep.t_any)
           -> ('a * 'b * 'c * 'd) t
       | T5 :
-          ('a Typerep.t * 'b Typerep.t * 'c Typerep.t * 'd Typerep.t * 'e Typerep.t)
+          (('a, _) Typerep.t_any
+          * ('b, _) Typerep.t_any
+          * ('c, _) Typerep.t_any
+          * ('d, _) Typerep.t_any
+          * ('e, _) Typerep.t_any)
           -> ('a * 'b * 'c * 'd * 'e) t
 
     let arity : type a. a t -> int = function
@@ -645,17 +731,20 @@ end = struct
   end
 
   include Variant_and_record_intf.M (struct
-    type 'a rep = 'a t
-    type 'a t = 'a rep
-  end)
+      type 'a t = 'a any_packed
+    end)
 
-  let rec typename_of_t : type a. a t -> a Typename.t = function
+  let rec typename_of_t : type a index. (a, index) t_any -> a Typename.t = function
     | Int -> Name_of.typename_of_int
     | Int32 -> Name_of.typename_of_int32
+    | Int32_u -> Name_of.typename_of_int32_u
     | Int64 -> Name_of.typename_of_int64
+    | Int64_u -> Name_of.typename_of_int64_u
     | Nativeint -> Name_of.typename_of_nativeint
+    | Nativeint_u -> Name_of.typename_of_nativeint_u
     | Char -> Name_of.typename_of_char
     | Float -> Name_of.typename_of_float
+    | Float_u -> Name_of.typename_of_float_u
     | String -> Name_of.typename_of_string
     | Bytes -> Name_of.typename_of_bytes
     | Bool -> Name_of.typename_of_bool
@@ -673,7 +762,10 @@ end = struct
     | Named (name, _) -> Named.typename_of_t name
   ;;
 
-  let rec same_witness : type a b. a t -> b t -> (a, b) Type_equal.t option =
+  let rec same_witness
+    : type a b index1 index2.
+      (a, index1) t_any -> (b, index2) t_any -> (a, b) Type_equal.t option
+    =
     fun t1 t2 ->
     let module E = Type_equal in
     match t1, t2 with
@@ -698,10 +790,14 @@ end = struct
        | None -> None)
     | Int, Int -> Some E.T
     | Int32, Int32 -> Some E.T
+    | Int32_u, Int32_u -> Some E.T
     | Int64, Int64 -> Some E.T
+    | Int64_u, Int64_u -> Some E.T
     | Nativeint, Nativeint -> Some E.T
+    | Nativeint_u, Nativeint_u -> Some E.T
     | Char, Char -> Some E.T
     | Float, Float -> Some E.T
+    | Float_u, Float_u -> Some E.T
     | String, String -> Some E.T
     | Bytes, Bytes -> Some E.T
     | Bool, Bool -> Some E.T
@@ -775,10 +871,14 @@ end = struct
         (Typerep.Variant.typename_of_t r2)
     | Int, _ -> None
     | Int32, _ -> None
+    | Int32_u, _ -> None
     | Int64, _ -> None
+    | Int64_u, _ -> None
     | Nativeint, _ -> None
+    | Nativeint_u, _ -> None
     | Char, _ -> None
     | Float, _ -> None
+    | Float_u, _ -> None
     | String, _ -> None
     | Bytes, _ -> None
     | Bool, _ -> None
@@ -802,7 +902,7 @@ end = struct
     | None -> assert false
   ;;
 
-  let rec head = function
+  let rec head : type a index. (a, index) t_any -> (a, index) t_any = function
     | Typerep.Named (_, Some (lazy t)) -> head t
     | t -> t
   ;;
@@ -810,10 +910,14 @@ end
 
 let typerep_of_int = Typerep.Int
 let typerep_of_int32 = Typerep.Int32
+let typerep_of_int32_u = Typerep.Int32_u
 let typerep_of_int64 = Typerep.Int64
+let typerep_of_int64_u = Typerep.Int64_u
 let typerep_of_nativeint = Typerep.Nativeint
+let typerep_of_nativeint_u = Typerep.Nativeint_u
 let typerep_of_char = Typerep.Char
 let typerep_of_float = Typerep.Float
+let typerep_of_float_u = Typerep.Float_u
 let typerep_of_string = Typerep.String
 let typerep_of_bytes = Typerep.Bytes
 let typerep_of_bool = Typerep.Bool
diff --git a/lib/std_internal.mli b/lib/std_internal.mli
index 6a9ac30..c6bdea0 100644
--- a/lib/std_internal.mli
+++ b/lib/std_internal.mli
@@ -2,31 +2,53 @@
 
 (** runtime type representations *)
 module rec Typerep : sig
-  type _ t =
-    | Int : int t
-    | Int32 : int32 t
-    | Int64 : int64 t
-    | Nativeint : nativeint t
-    | Char : char t
-    | Float : float t
-    | String : string t
-    | Bytes : bytes t
-    | Bool : bool t
-    | Unit : unit t
-    | Option : 'a t -> 'a option t
-    | List : 'a t -> 'a list t
-    | Array : 'a t -> 'a array t
-    | Lazy : 'a t -> 'a lazy_t t
-    | Ref : 'a t -> 'a ref t
-    | Function : ('dom t * 'rng t) -> ('dom -> 'rng) t
-    | Tuple : 'a Typerep.Tuple.t -> 'a t
-    | Record : 'a Typerep.Record.t -> 'a t
-    | Variant : 'a Typerep.Variant.t -> 'a t
-        (** The [Named] constructor both allows for custom implementations of generics
+  type value := [ `value ]
+  type non_value := [ `non_value ]
+
+  (** A typerep for a type of layout value or an unboxed number. *)
+  type (_, _) t_any =
+    | Int : (int, value) t_any
+    | Int32 : (int32, value) t_any
+    | Int64 : (int64, value) t_any
+    | Nativeint : (nativeint, value) t_any
+    | Char : (char, value) t_any
+    | Float : (float, value) t_any
+    | String : (string, value) t_any
+    | Bytes : (bytes, value) t_any
+    | Bool : (bool, value) t_any
+    | Unit : (unit, value) t_any
+    | Option : ('a, value) t_any -> ('a option, value) t_any
+    | List : ('a, value) t_any -> ('a list, value) t_any
+    | Array : ('a, value) t_any -> ('a array, value) t_any
+    | Lazy : ('a, value) t_any -> ('a lazy_t, value) t_any
+    | Ref : ('a, value) t_any -> ('a ref, value) t_any
+    | Function :
+        (('dom, value) t_any * ('rng, value) t_any)
+        -> ('dom -> 'rng, value) t_any
+    | Tuple : 'a Typerep.Tuple.t -> ('a, value) t_any
+    | Record : 'a Typerep.Record.t -> ('a, value) t_any
+    | Variant : 'a Typerep.Variant.t -> ('a, value) t_any
+    (** The [Named] constructor both allows for custom implementations of generics
         based on name and provides a way to represent recursive types, the lazy
         part dealing with cycles *)
-    | Named : ('a Typerep.Named.t * 'a t lazy_t option) -> 'a t
-
+    | Named : ('a Typerep.Named.t * ('a, value) t_any lazy_t option) -> ('a, value) t_any
+    (* The constructors [Int32_u], [Int64_u], [Nativeint_u], and [Float_u] below look
+       pretty weird. It's necessary because the type parameter has layout [value], and
+       [unit -> int32#] has layout [value] while [int32#] does not. Making the type
+       parameter have layout [any] is not feasible at this point, so this hack will remain
+       until it becomes feasible *)
+    | Int32_u : (unit -> int32, non_value) t_any
+    | Int64_u : (unit -> int64, non_value) t_any
+    | Nativeint_u : (unit -> nativeint, non_value) t_any
+    | Float_u : (unit -> float, non_value) t_any
+
+  (** A typerep for a type of layout value. *)
+  type 'a t = ('a, value) t_any
+
+  (** A typerep for an unboxed number. *)
+  type 'a t_non_value = (unit -> 'a, non_value) t_any
+
+  type 'a any_packed = T : ('a, _) t_any -> 'a any_packed
   type packed = T : 'a t -> packed
 
   module Named : sig
@@ -177,20 +199,29 @@ module rec Typerep : sig
 
   module Tuple : sig
     type _ t =
-      | T2 : ('a Typerep.t * 'b Typerep.t) -> ('a * 'b) t
-      | T3 : ('a Typerep.t * 'b Typerep.t * 'c Typerep.t) -> ('a * 'b * 'c) t
+      | T2 : (('a, _) Typerep.t_any * ('b, _) Typerep.t_any) -> ('a * 'b) t
+      | T3 :
+          (('a, _) Typerep.t_any * ('b, _) Typerep.t_any * ('c, _) Typerep.t_any)
+          -> ('a * 'b * 'c) t
       | T4 :
-          ('a Typerep.t * 'b Typerep.t * 'c Typerep.t * 'd Typerep.t)
+          (('a, _) Typerep.t_any
+          * ('b, _) Typerep.t_any
+          * ('c, _) Typerep.t_any
+          * ('d, _) Typerep.t_any)
           -> ('a * 'b * 'c * 'd) t
       | T5 :
-          ('a Typerep.t * 'b Typerep.t * 'c Typerep.t * 'd Typerep.t * 'e Typerep.t)
+          (('a, _) Typerep.t_any
+          * ('b, _) Typerep.t_any
+          * ('c, _) Typerep.t_any
+          * ('d, _) Typerep.t_any
+          * ('e, _) Typerep.t_any)
           -> ('a * 'b * 'c * 'd * 'e) t
 
     val arity : _ t -> int
     val typename_of_t : 'a t -> 'a Typename.t
   end
 
-  include Variant_and_record_intf.S with type 'a t := 'a t
+  include Variant_and_record_intf.S with type 'a t := 'a any_packed
 
   (** [same t t'] will return a proof a equality if [t] and [t'] are the same type.
       One can think of two types being the [same] as two types whose values could be for
@@ -224,16 +255,16 @@ module rec Typerep : sig
       types, record types, and named types with no lazy definition exposed. This last case
       is about types that are defined [[@@deriving typerep ~abstract]].
   *)
-  val same : _ t -> _ t -> bool
+  val same : _ t_any -> _ t_any -> bool
 
-  val same_witness : 'a t -> 'b t -> ('a, 'b) Type_equal.t option
-  val same_witness_exn : 'a t -> 'b t -> ('a, 'b) Type_equal.t
-  val typename_of_t : 'a t -> 'a Typename.t
+  val same_witness : ('a, _) t_any -> ('b, _) t_any -> ('a, 'b) Type_equal.t option
+  val same_witness_exn : ('a, _) t_any -> ('b, _) t_any -> ('a, 'b) Type_equal.t
+  val typename_of_t : ('a, _) t_any -> 'a Typename.t
 
   (** [head ty] is used to traverse the [Named] constructor. It might be used when one
       care to pattern match directly on the representation in a low level way rather than
       going through a full generic. [head t] is [t] if [t] is not of the form [Named _] *)
-  val head : 'a t -> 'a t
+  val head : ('a, 'index) t_any -> ('a, 'index) t_any
 end
 
 (* basic *)
@@ -248,6 +279,10 @@ val typerep_of_string : string Typerep.t
 val typerep_of_bytes : bytes Typerep.t
 val typerep_of_bool : bool Typerep.t
 val typerep_of_unit : unit Typerep.t
+val typerep_of_int32_u : int32 Typerep.t_non_value
+val typerep_of_int64_u : int64 Typerep.t_non_value
+val typerep_of_nativeint_u : nativeint Typerep.t_non_value
+val typerep_of_float_u : float Typerep.t_non_value
 
 (* variant with no argument *)
 type tuple0
@@ -262,36 +297,44 @@ val typerep_of_lazy_t : 'a Typerep.t -> 'a lazy_t Typerep.t
 val typerep_of_ref : 'a Typerep.t -> 'a ref Typerep.t
 val typerep_of_function : 'a Typerep.t -> 'b Typerep.t -> ('a -> 'b) Typerep.t
 val typerep_of_tuple0 : tuple0 Typerep.t
-val typerep_of_tuple2 : 'a Typerep.t -> 'b Typerep.t -> ('a * 'b) Typerep.t
+
+val typerep_of_tuple2
+  :  ('a, _) Typerep.t_any
+  -> ('b, _) Typerep.t_any
+  -> ('a * 'b) Typerep.t
 
 val typerep_of_tuple3
-  :  'a Typerep.t
-  -> 'b Typerep.t
-  -> 'c Typerep.t
+  :  ('a, _) Typerep.t_any
+  -> ('b, _) Typerep.t_any
+  -> ('c, _) Typerep.t_any
   -> ('a * 'b * 'c) Typerep.t
 
 val typerep_of_tuple4
-  :  'a Typerep.t
-  -> 'b Typerep.t
-  -> 'c Typerep.t
-  -> 'd Typerep.t
+  :  ('a, _) Typerep.t_any
+  -> ('b, _) Typerep.t_any
+  -> ('c, _) Typerep.t_any
+  -> ('d, _) Typerep.t_any
   -> ('a * 'b * 'c * 'd) Typerep.t
 
 val typerep_of_tuple5
-  :  'a Typerep.t
-  -> 'b Typerep.t
-  -> 'c Typerep.t
-  -> 'd Typerep.t
-  -> 'e Typerep.t
+  :  ('a, _) Typerep.t_any
+  -> ('b, _) Typerep.t_any
+  -> ('c, _) Typerep.t_any
+  -> ('d, _) Typerep.t_any
+  -> ('e, _) Typerep.t_any
   -> ('a * 'b * 'c * 'd * 'e) Typerep.t
 
 val typename_of_int : int Typename.t
 val typename_of_int32 : int32 Typename.t
+val typename_of_int32_u : (unit -> int32) Typename.t
 val typename_of_int64 : int64 Typename.t
+val typename_of_int64_u : (unit -> int64) Typename.t
 val typename_of_nativeint : nativeint Typename.t
+val typename_of_nativeint_u : (unit -> nativeint) Typename.t
 val typename_of_int63 : Base.Int63.t Typename.t
 val typename_of_char : char Typename.t
 val typename_of_float : float Typename.t
+val typename_of_float_u : (unit -> float) Typename.t
 val typename_of_string : string Typename.t
 val typename_of_bytes : bytes Typename.t
 val typename_of_bool : bool Typename.t
diff --git a/lib/type_equal.ml b/lib/type_equal.ml
index 3f76eb0..9860954 100644
--- a/lib/type_equal.ml
+++ b/lib/type_equal.ml
@@ -5,8 +5,8 @@ let refl = T
 let conv : type a b. (a, b) t -> a -> b = fun T x -> x
 
 module Lift (X : sig
-  type 'a t
-end) =
+    type 'a t
+  end) =
 struct
   let lift (type a b) (T : (a, b) t) : (a X.t, b X.t) t = T
 end
diff --git a/lib/type_equal.mli b/lib/type_equal.mli
index bb8b3fa..1d70378 100644
--- a/lib/type_equal.mli
+++ b/lib/type_equal.mli
@@ -12,7 +12,7 @@ val refl : ('a, 'a) t
 
 (** needed in some cases even though t is exported and is a gadt *)
 module Lift (X : sig
-  type 'a t
-end) : sig
+    type 'a t
+  end) : sig
   val lift : ('a, 'b) t -> ('a X.t, 'b X.t) t
 end
diff --git a/lib/type_generic.ml b/lib/type_generic.ml
index 2dce6bf..c44e57a 100644
--- a/lib/type_generic.ml
+++ b/lib/type_generic.ml
@@ -119,10 +119,14 @@ module type Computation = sig
 
   val int : int t
   val int32 : int32 t
+  val int32_u : (unit -> int32) t
   val int64 : int64 t
+  val int64_u : (unit -> int64) t
   val nativeint : nativeint t
+  val nativeint_u : (unit -> nativeint) t
   val char : char t
   val float : float t
+  val float_u : (unit -> float) t
   val string : string t
   val bytes : bytes t
   val bool : bool t
@@ -145,10 +149,10 @@ end
 
 (* special functor application for computation as closure of the form [a -> b] *)
 module Make_named_for_closure (X : sig
-  type 'a input
-  type 'a output
-  type 'a t = 'a input -> 'a output
-end) =
+    type 'a input
+    type 'a output
+    type 'a t = 'a input -> 'a output
+  end) =
 struct
   module Context = struct
     type t = unit
@@ -346,23 +350,23 @@ end
 module type S = sig
   include Extending
 
-  val of_typerep : 'a Typerep.t -> [ `generic of 'a computation ]
+  val of_typerep : ('a, _) Typerep.t_any -> [ `generic of 'a computation ]
 
   module Computation : Computation with type 'a t = 'a t
 end
 
 module Make_S_implementation (X : sig
-  type 'a t
+    type 'a t
 
-  val name : string
-  val required : Ident.t list
-end) : S_implementation with type 'a t = 'a X.t = struct
+    val name : string
+    val required : Ident.t list
+  end) : S_implementation with type 'a t = 'a X.t = struct
   type 'a t = 'a X.t
   type 'a computation = 'a t
 
   include Type_generic_intf.M (struct
-    type 'a t = 'a computation
-  end)
+      type 'a t = 'a computation
+    end)
 
   (* we do not use core since we are earlier in the dependencies graph *)
   module Uid_table = struct
@@ -491,7 +495,7 @@ end) : S_implementation with type 'a t = 'a X.t = struct
           -> T.b computation
           -> T.c computation
           -> (T.a, T.b, T.c) T.named computation)
-         option
+           option
   end = struct
     let compute () =
       match Uid_table.find table3 (Typename.uid T.typename_of_t) with
@@ -525,7 +529,7 @@ end) : S_implementation with type 'a t = 'a X.t = struct
           -> T.c computation
           -> T.d computation
           -> (T.a, T.b, T.c, T.d) T.named computation)
-         option
+           option
   end = struct
     let compute () =
       match Uid_table.find table4 (Typename.uid T.typename_of_t) with
@@ -564,7 +568,7 @@ end) : S_implementation with type 'a t = 'a X.t = struct
           -> T.d computation
           -> T.e computation
           -> (T.a, T.b, T.c, T.d, T.e) T.named computation)
-         option
+           option
   end = struct
     let compute () =
       match Uid_table.find table5 (Typename.uid T.typename_of_t) with
@@ -685,7 +689,7 @@ end) : S_implementation with type 'a t = 'a X.t = struct
        | Some custom ->
          let custom =
            (custom (aux.generic T.a) (aux.generic T.b) (aux.generic T.c)
-             : (T.a, T.b, T.c) T.named computation)
+            : (T.a, T.b, T.c) T.named computation)
          in
          let Type_equal.T = T.witness in
          Some (custom : a computation)
@@ -697,7 +701,7 @@ end) : S_implementation with type 'a t = 'a X.t = struct
        | Some custom ->
          let custom =
            (custom (aux.generic T.a) (aux.generic T.b) (aux.generic T.c) (aux.generic T.d)
-             : (T.a, T.b, T.c, T.d) T.named computation)
+            : (T.a, T.b, T.c, T.d) T.named computation)
          in
          let Type_equal.T = T.witness in
          Some (custom : a computation)
@@ -714,7 +718,7 @@ end) : S_implementation with type 'a t = 'a X.t = struct
               (aux.generic T.c)
               (aux.generic T.d)
               (aux.generic T.e)
-             : (T.a, T.b, T.c, T.d, T.e) T.named computation)
+            : (T.a, T.b, T.c, T.d, T.e) T.named computation)
          in
          let Type_equal.T = T.witness in
          Some (custom : a computation)
@@ -741,33 +745,43 @@ end
 module _ = Hashtbl.Make (Typename.Key)
 
 module Make (X : sig
-  type 'a t
+    type 'a t
 
-  val name : string
-  val required : Ident.t list
+    val name : string
+    val required : Ident.t list
 
-  include Computation with type 'a t := 'a t
-end) =
+    include Computation with type 'a t := 'a t
+  end) =
 struct
   module Computation = X
   include Make_S_implementation (X)
 
   module Memo = Typename.Table (struct
-    type 'a t = 'a X.Named.t
-  end)
+      type 'a t = 'a X.Named.t
+    end)
+
+  module Typerep_any = struct
+    include Typerep
+
+    type 'a t = 'a Typerep.any_packed
+  end
 
-  module Helper = Helper (Typerep) (Computation)
+  module Helper = Helper (Typerep_any) (Computation)
 
   let of_typerep rep =
     let context = X.Named.Context.create () in
     let memo_table = Memo.create 32 in
-    let rec of_typerep : type a. a Typerep.t -> a t = function
+    let rec of_typerep : type a index. (a, index) Typerep.t_any -> a t = function
       | Typerep.Int -> X.int
       | Typerep.Int32 -> X.int32
+      | Typerep.Int32_u -> X.int32_u
       | Typerep.Int64 -> X.int64
+      | Typerep.Int64_u -> X.int64_u
       | Typerep.Nativeint -> X.nativeint
+      | Typerep.Nativeint_u -> X.nativeint_u
       | Typerep.Char -> X.char
       | Typerep.Float -> X.float
+      | Typerep.Float_u -> X.float_u
       | Typerep.String -> X.string
       | Typerep.Bytes -> X.bytes
       | Typerep.Bool -> X.bool
@@ -806,9 +820,11 @@ struct
            let re = of_typerep e in
            X.tuple5 ra rb rc rd re)
       | Typerep.Record record ->
-        X.record (Helper.map_record { Helper.map = of_typerep } record)
+        X.record
+          (Helper.map_record { Helper.map = (fun (T rep) -> of_typerep rep) } record)
       | Typerep.Variant variant ->
-        X.variant (Helper.map_variant { Helper.map = of_typerep } variant)
+        X.variant
+          (Helper.map_variant { Helper.map = (fun (T rep) -> of_typerep rep) } variant)
       | Typerep.Named (named, content) ->
         let typename = Typerep.Named.typename_of_t named in
         (match Memo.find memo_table typename with
diff --git a/lib/type_generic.mli b/lib/type_generic.mli
index 4d07732..9f12329 100644
--- a/lib/type_generic.mli
+++ b/lib/type_generic.mli
@@ -99,10 +99,14 @@ module type Computation = sig
 
   val int : int t
   val int32 : int32 t
+  val int32_u : (unit -> int32) t
   val int64 : int64 t
+  val int64_u : (unit -> int64) t
   val nativeint : nativeint t
+  val nativeint_u : (unit -> nativeint) t
   val char : char t
   val float : float t
+  val float_u : (unit -> float) t
   val string : string t
   val bytes : bytes t
   val bool : bool t
@@ -133,10 +137,10 @@ end
    it to build the [Named] module.
 *)
 module Make_named_for_closure (X : sig
-  type 'a input
-  type 'a output
-  type 'a t = 'a input -> 'a output
-end) : Named with type 'a computation := 'a X.t
+    type 'a input
+    type 'a output
+    type 'a t = 'a input -> 'a output
+  end) : Named with type 'a computation := 'a X.t
 
 module Ident : sig
   (**
@@ -190,7 +194,7 @@ module type S = sig
   val register : 'a Typerep.t -> 'a computation -> unit
 
   (** main function : compute the generic computation from the typerep *)
-  val of_typerep : 'a Typerep.t -> [ `generic of 'a computation ]
+  val of_typerep : ('a, _) Typerep.t_any -> [ `generic of 'a computation ]
 
   (** exported to build a computation on top of a previous one *)
   module Computation : Computation with type 'a t = 'a t
@@ -204,10 +208,10 @@ end
    other computation [A,B,C] then X.required shall be [ A.ident ; B.ident ; C.ident ]
 *)
 module Make (X : sig
-  type 'a t
+    type 'a t
 
-  val name : string
-  val required : Ident.t list
+    val name : string
+    val required : Ident.t list
 
-  include Computation with type 'a t := 'a t
-end) : S with type 'a t = 'a X.t
+    include Computation with type 'a t := 'a t
+  end) : S with type 'a t = 'a X.t
diff --git a/lib/type_generic_intf.ml b/lib/type_generic_intf.ml
index a42efd1..16239b9 100644
--- a/lib/type_generic_intf.ml
+++ b/lib/type_generic_intf.ml
@@ -1,6 +1,6 @@
 module M (X : sig
-  type 'a t
-end) =
+    type 'a t
+  end) =
 struct
   module type S = sig
     type t
@@ -61,7 +61,7 @@ module type S = sig
   type 'a t
 
   include module type of M (struct
-    type 'a computation = 'a t
-    type 'a t = 'a computation
-  end)
+      type 'a computation = 'a t
+      type 'a t = 'a computation
+    end)
 end
diff --git a/lib/typename.ml b/lib/typename.ml
index 23b3bf7..09b61b4 100644
--- a/lib/typename.ml
+++ b/lib/typename.ml
@@ -172,8 +172,8 @@ end
 module Key_table = Hashtbl.Make (Key)
 
 module Table (X : sig
-  type 'a t
-end) =
+    type 'a t
+  end) =
 struct
   type data = Data : 'a t * 'a X.t -> data
   type t = data Key_table.t
diff --git a/lib/typename.mli b/lib/typename.mli
index 74e10b0..36d3b85 100644
--- a/lib/typename.mli
+++ b/lib/typename.mli
@@ -94,8 +94,8 @@ module Make5 (X : Named_intf.S5) :
   S5 with type ('a, 'b, 'c, 'd, 'e) t := ('a, 'b, 'c, 'd, 'e) X.t
 
 module Table (X : sig
-  type 'a t
-end) : sig
+    type 'a t
+  end) : sig
   type t
 
   val create : int -> t
diff --git a/lib/typerep_obj.ml b/lib/typerep_obj.ml
index 4178b14..ffacd52 100644
--- a/lib/typerep_obj.ml
+++ b/lib/typerep_obj.ml
@@ -1,3 +1,5 @@
+open Std_internal
+
 (* using the hash_variant of pa_type_conv at compile time *)
 let repr_of_poly_variant : [> ] -> int =
   fun variant ->
@@ -28,6 +30,15 @@ let hash_variant s =
 let () = assert (repr_of_poly_variant `Latency_stats = hash_variant "Latency_stats")
 let () = assert (repr_of_poly_variant `zero = hash_variant "zero")
 let[@inline never] double_array_value () = Sys.opaque_identity (Obj.magic 0.)
+
+let double_array_non_value (type any) (typerep : any Typerep.t_non_value) : unit -> any =
+  match Typerep.head typerep with
+  | Float_u -> fun () -> 4.0
+  | Int32_u -> fun () -> 4l
+  | Int64_u -> fun () -> 4L
+  | Nativeint_u -> fun () -> 4n
+;;
+
 let has_double_array_tag a = Obj.double_array_tag = Obj.tag (Obj.repr a)
 
 let () =
diff --git a/lib/typerep_obj.mli b/lib/typerep_obj.mli
index 58a40bf..f100d3d 100644
--- a/lib/typerep_obj.mli
+++ b/lib/typerep_obj.mli
@@ -1,7 +1,13 @@
+open Std_internal
+
 (** some utils related to the runtime of ocaml, used both at compile time (camlp4) and
     runtime. to be considered the same way than [Obj] (internal, unsafe, etc.) *)
 val repr_of_poly_variant : [> ] -> int
 
 val hash_variant : string -> int
 val double_array_value : unit -> 'a
+
+(** creates a dummy value for typereps for unboxed types. *)
+val double_array_non_value : 'any. 'any Typerep.t_non_value -> unit -> 'any
+
 val has_double_array_tag : 'a -> bool
diff --git a/lib/variant_and_record_intf.ml b/lib/variant_and_record_intf.ml
index cfb3af2..21431ef 100644
--- a/lib/variant_and_record_intf.ml
+++ b/lib/variant_and_record_intf.ml
@@ -3,7 +3,7 @@
 *)
 
 module M (X : sig
-  (**
+    (**
        This functor is essentially there because we use this same interface in different
        contexts, with different types for ['a t].
 
@@ -18,8 +18,8 @@ module M (X : sig
        the typerep of the arguments in hopes of enforcing that no typerep traversal
        happens at runtime if the computation happen to be a function.
     *)
-  type 'a t
-end) =
+    type 'a t
+  end) =
 struct
   (* The functions prefixed by [internal] as well as the module suffixed by [_internal]
      are used by the code generated by the camlp4 extension [with typerep] as well as some
@@ -485,7 +485,7 @@ module type S = sig
   type 'a t
 
   include module type of M (struct
-    type 'a rep = 'a t
-    type 'a t = 'a rep
-  end)
+      type 'a rep = 'a t
+      type 'a t = 'a rep
+    end)
 end
