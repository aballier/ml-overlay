From c95825f3b31690ee647cde103b39a5ada4ea2ac2 Mon Sep 17 00:00:00 2001
From: public-release <as-public-release@janestreet.com>
Date: Tue, 13 Aug 2024 20:53:43 +0100
Subject: [PATCH] v0.17~preview.129.36+325

---
 ansi_kernel/src/ansi_kernel.ml                |   12 +-
 ansi_kernel/src/ansi_kernel.mli               |    8 +-
 ansi_kernel/src/color_256.ml                  |    2 +-
 ansi_kernel/src/color_256.mli                 |    2 +-
 .../test/test_balanced_reducer.ml             |   18 +-
 binary_packing/test/dune                      |    2 +-
 binary_packing/test/test_binary_packing.ml    |  364 ++---
 bounded_int_table/src/bounded_int_table.ml    |   14 +-
 bounded_int_table/src/bounded_int_table.mli   |    6 +-
 bounded_int_table/test/dune                   |    2 +-
 bus/bench/bench_bus.ml                        |    6 +-
 bus/bench/dune                                |    2 +-
 bus/src/bus.ml                                |  522 +++---
 bus/src/bus.mli                               |   41 +-
 bus/test/dune                                 |    3 +-
 bus/test/test_bus.ml                          | 1424 +++++++++--------
 enum/doc/README.mlt                           |    4 +-
 enum/src/dune                                 |    2 +-
 enum/src/enum.ml                              |   17 +-
 enum/src/enum_intf.ml                         |    6 +
 fheap/bench/dune                              |    2 +-
 fheap/src/fheap.ml                            |   10 +-
 fheap/test/dune                               |    2 +-
 flags/src/flags.ml                            |    4 +-
 flags/test/dune                               |    2 +-
 flags/test/test_flags.ml                      |   61 +-
 hash_heap/test/test_hash_heap.ml              |    2 +-
 iobuf/bench/dune                              |    2 +-
 iobuf/src/iobuf.ml                            |   84 +-
 iobuf/src/iobuf.mli                           |   40 +-
 iobuf/src/iobuf_intf.ml                       |    6 +-
 iobuf/test/dune                               |    3 +-
 iobuf/test/test_iobuf.ml                      |  621 +++----
 iobuf/test/test_iobuf_view.ml                 |  656 ++++----
 limiter/bench/dune                            |    2 +-
 limiter/src/limiter.ml                        |    8 +-
 limiter/test/dune                             |    2 +-
 limiter/test/test_limiter.ml                  |    4 +-
 moption/test/dune                             |    2 +-
 nonempty_list/src/dune                        |    2 +-
 nonempty_list/src/nonempty_list.ml            |   21 +-
 nonempty_list/src/nonempty_list.mli           |   13 +-
 nonempty_list/test/dune                       |    2 +-
 nonempty_list/test/nonempty_list_tests.ml     |   75 +-
 pairing_heap/bench/dune                       |    2 +-
 pairing_heap/src/pairing_heap.ml              |   10 +-
 pairing_heap/test/dune                        |    2 +-
 pairing_heap/test/test_pairing_heap.ml        |  239 +--
 pooled_hashtbl/src/dune                       |    2 +-
 pooled_hashtbl/src/pooled_hashtbl.ml          |  231 +--
 pooled_hashtbl/test/test_pooled_hashtbl.ml    |    6 +-
 .../src/sexp_hidden_in_test.ml                |   16 +-
 .../src/thread_pool_cpu_affinity.ml           |   20 +-
 .../bench/bench_thread_safe_queue.ml          |   12 +-
 thread_safe_queue/bench/dune                  |    2 +-
 thread_safe_queue/src/thread_safe_queue.ml    |   55 +-
 thread_safe_queue/src/thread_safe_queue.mli   |   50 +-
 thread_safe_queue/test/dune                   |    4 +-
 .../test/test_thread_safe_queue.ml            |  378 +++--
 timing_wheel/bench/dune                       |    2 +-
 timing_wheel/src/timing_wheel.ml              |   95 +-
 timing_wheel/src/timing_wheel_intf.ml         |    4 +-
 timing_wheel/test/test_timing_wheel.ml        |  181 +--
 total_map/src/dune                            |    2 +-
 total_map/src/enumeration.ml                  |    4 +-
 total_map/src/enumeration_intf.ml             |    4 +-
 total_map/src/total_map.ml                    |  274 +++-
 total_map/src/total_map_intf.ml               |  133 +-
 tuple_pool/src/tuple_pool.ml                  |    4 +-
 tuple_pool/src/tuple_pool_intf.ml             |   40 +-
 tuple_pool/src/tuple_type_intf.ml             |  209 +--
 tuple_pool/test-bin/dune                      |    2 +-
 tuple_pool/test/dune                          |    2 +-
 tuple_pool/test/test_tuple_pool.ml            |   22 +-
 univ/test/dune                                |    2 +-
 unpack_buffer/src/unpack_buffer.ml            |  102 +-
 unpack_buffer/test/dune                       |    2 +-
 unpack_buffer/test/test_unpack_buffer.ml      |   18 +-
 uopt/src/dune                                 |    2 +-
 uopt/src/uopt_core.mli                        |    3 +-
 uopt/test/dune                                |    2 +-
 uuid/src/uuid.ml                              |   12 +-
 uuid/src/uuid.mli                             |    6 +-
 uuid/test/dune                                |    2 +-
 vec/src/vec.ml                                |  128 +-
 vec/src/vec_intf.ml                           |   12 +-
 version_util/src/dune                         |    2 +-
 version_util/src/section.ml                   |    8 +-
 version_util/src/section.mli                  |   12 +-
 version_util/src/version_util.ml              |   77 +-
 version_util/src/version_util.mli             |    3 +
 version_util/src/version_util.wat             |   37 +
 version_util/test/check_build_info.ml         |   21 +-
 weak_array/test/dune                          |    2 +-
 weak_array/test/test_weak_array.ml            |   26 +-
 weak_hashtbl/src/weak_hashtbl.ml              |   10 +-
 weak_hashtbl/test/dune                        |    2 +-
 weak_hashtbl/test/test_weak_hashtbl.ml        |   40 +-
 weak_pointer/src/dune                         |    2 +-
 weak_pointer/src/weak_pointer.ml              |    5 +-
 weak_pointer/src/weak_pointer.mli             |    3 +-
 weak_pointer/test/dune                        |    2 +-
 weak_pointer/test/test_weak_pointer.ml        |   51 +-
 104 files changed, 3795 insertions(+), 2895 deletions(-)
 create mode 100644 version_util/src/version_util.wat

diff --git a/ansi_kernel/src/ansi_kernel.ml b/ansi_kernel/src/ansi_kernel.ml
index 0bc95551..02d68d73 100644
--- a/ansi_kernel/src/ansi_kernel.ml
+++ b/ansi_kernel/src/ansi_kernel.ml
@@ -17,13 +17,13 @@ module Stable = struct
         | `Cyan
         | `White
         ]
-      [@@deriving sexp, compare, hash, equal]
+      [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
       type t =
         [ primary
         | `Color_256 of Color_256.V1.t
         ]
-      [@@deriving sexp, compare, hash, equal]
+      [@@deriving compare, equal, hash, sexp, sexp_grammar]
     end
 
     module V2 = struct
@@ -37,14 +37,14 @@ module Stable = struct
         | `Cyan
         | `White
         ]
-      [@@deriving sexp, compare, hash, equal]
+      [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
       type t =
         [ primary
         | `Color_256 of Color_256.V1.t
         | `Default_color
         ]
-      [@@deriving sexp, compare, hash, equal]
+      [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
       let of_v1 (t : V1.t) = (t :> t)
 
@@ -71,7 +71,7 @@ module Stable = struct
         | Color.V1.t
         | `Bg of Color.V1.t
         ]
-      [@@deriving sexp, compare, hash, equal]
+      [@@deriving compare, equal, hash, sexp, sexp_grammar]
     end
 
     module V2 = struct
@@ -83,7 +83,7 @@ module Stable = struct
         | Color.V2.t
         | `Bg of Color.V2.t
         ]
-      [@@deriving sexp, compare, hash, equal]
+      [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
       let of_v1 (t : V1.t) = (t :> t)
 
diff --git a/ansi_kernel/src/ansi_kernel.mli b/ansi_kernel/src/ansi_kernel.mli
index 095146bd..2046ea51 100644
--- a/ansi_kernel/src/ansi_kernel.mli
+++ b/ansi_kernel/src/ansi_kernel.mli
@@ -66,12 +66,12 @@ module Stable : sig
   module Color : sig
     module V1 : sig
       type primary
-      type t [@@deriving sexp, compare, hash, equal]
+      type t [@@deriving compare, equal, hash, sexp, sexp_grammar]
     end
 
     module V2 : sig
       type primary = Color.primary
-      type t = Color.t [@@deriving sexp, compare, hash, equal]
+      type t = Color.t [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
       val of_v1 : V1.t -> t
       val to_v1 : t -> foreground:bool -> V1.t
@@ -82,11 +82,11 @@ module Stable : sig
 
   module Attr : sig
     module V1 : sig
-      type t [@@deriving sexp, compare, hash, equal]
+      type t [@@deriving compare, equal, hash, sexp, sexp_grammar]
     end
 
     module V2 : sig
-      type t = Attr.t [@@deriving sexp, compare, hash, equal]
+      type t = Attr.t [@@deriving compare, equal, hash, sexp, sexp_grammar]
 
       val of_v1 : V1.t -> t
       val to_v1 : t -> V1.t
diff --git a/ansi_kernel/src/color_256.ml b/ansi_kernel/src/color_256.ml
index 1cd1b4d6..261fdbc1 100644
--- a/ansi_kernel/src/color_256.ml
+++ b/ansi_kernel/src/color_256.ml
@@ -2,7 +2,7 @@ module Stable = struct
   open! Core.Core_stable
 
   module V1 = struct
-    type t = int [@@deriving sexp, compare, hash, equal]
+    type t = int [@@deriving compare, equal, hash, sexp, sexp_grammar]
   end
 end
 
diff --git a/ansi_kernel/src/color_256.mli b/ansi_kernel/src/color_256.mli
index 44a9b415..db4f310d 100644
--- a/ansi_kernel/src/color_256.mli
+++ b/ansi_kernel/src/color_256.mli
@@ -93,6 +93,6 @@ val to_rgb6 : t -> int * int * int
 
 module Stable : sig
   module V1 : sig
-    type nonrec t = t [@@deriving sexp, compare, hash, equal]
+    type nonrec t = t [@@deriving compare, equal, hash, sexp, sexp_grammar]
   end
 end
diff --git a/balanced_reducer/test/test_balanced_reducer.ml b/balanced_reducer/test/test_balanced_reducer.ml
index dd9743a1..b8d45eea 100644
--- a/balanced_reducer/test/test_balanced_reducer.ml
+++ b/balanced_reducer/test/test_balanced_reducer.ml
@@ -81,7 +81,8 @@ let%expect_test "[sexp_of_t]" =
   [%expect {| (((13))) |}];
   let t = create_exn ~len:2 in
   show t;
-  [%expect {|
+  [%expect
+    {|
     (()
      ())
     |}];
@@ -90,7 +91,8 @@ let%expect_test "[sexp_of_t]" =
   [%expect {| (((13)) ()) |}];
   set_exn t 1 14;
   show t;
-  [%expect {|
+  [%expect
+    {|
     (((13))
      ((14)))
     |}]
@@ -131,7 +133,8 @@ let%expect_test "[compute_exn] caches [reduce]" =
   set_exn t 0 13;
   set_exn t 1 14;
   compute_exn t;
-  [%expect {|
+  [%expect
+    {|
     (reduce
       (13)
       (14))
@@ -146,7 +149,8 @@ let%expect_test "[compute_exn] recomputes when input changes" =
   set_exn t 0 13;
   set_exn t 1 14;
   compute_exn t;
-  [%expect {|
+  [%expect
+    {|
     (reduce
       (13)
       (14))
@@ -154,7 +158,8 @@ let%expect_test "[compute_exn] recomputes when input changes" =
     |}];
   set_exn t 1 15;
   compute_exn t;
-  [%expect {|
+  [%expect
+    {|
     (reduce
       (13)
       (15))
@@ -178,7 +183,8 @@ let%expect_test "[compute_exn] only recomputes what's necessary" =
     |}];
   set_exn t 2 16;
   compute_exn t;
-  [%expect {|
+  [%expect
+    {|
     (reduce (13 14) (16))
     (computed (13 14 16))
     |}]
diff --git a/binary_packing/test/dune b/binary_packing/test/dune
index 27b0f158..c6538b1e 100644
--- a/binary_packing/test/dune
+++ b/binary_packing/test/dune
@@ -1,5 +1,5 @@
 (library
  (name binary_packing_test)
- (libraries binary_packing)
+ (libraries binary_packing core)
  (preprocess
   (pps ppx_jane)))
diff --git a/binary_packing/test/test_binary_packing.ml b/binary_packing/test/test_binary_packing.ml
index b4e5a255..082de0c8 100644
--- a/binary_packing/test/test_binary_packing.ml
+++ b/binary_packing/test/test_binary_packing.ml
@@ -4,21 +4,21 @@ open! Import
 open! Binary_packing
 
 module Make_inline_tests (A : sig
-  val num_bytes : int
-  val signed : bool
-
-  type t
-
-  val ns : t list
-  val of_int64 : int64 -> t
-  val to_int64 : t -> int64
-  val pack : byte_order:endian -> buf:bytes -> pos:int -> t -> unit
-  val unpack : byte_order:endian -> buf:bytes -> pos:int -> t
-  val pack_big_endian : buf:bytes -> pos:int -> t -> unit
-  val unpack_big_endian : buf:bytes -> pos:int -> t
-  val pack_little_endian : buf:bytes -> pos:int -> t -> unit
-  val unpack_little_endian : buf:bytes -> pos:int -> t
-end) =
+    val num_bytes : int
+    val signed : bool
+
+    type t
+
+    val ns : t list
+    val of_int64 : int64 -> t
+    val to_int64 : t -> int64
+    val pack : byte_order:endian -> buf:bytes -> pos:int -> t -> unit
+    val unpack : byte_order:endian -> buf:bytes -> pos:int -> t
+    val pack_big_endian : buf:bytes -> pos:int -> t -> unit
+    val unpack_big_endian : buf:bytes -> pos:int -> t
+    val pack_little_endian : buf:bytes -> pos:int -> t -> unit
+    val unpack_little_endian : buf:bytes -> pos:int -> t
+  end) =
 struct
   include A
 
@@ -55,130 +55,130 @@ struct
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack ~byte_order:`Little_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack ~byte_order:`Little_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack ~byte_order:`Little_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack ~byte_order:`Little_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack ~byte_order:`Big_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack ~byte_order:`Big_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack ~byte_order:`Big_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack ~byte_order:`Big_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack_little_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack_little_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack_little_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack_little_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack_big_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack_big_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack_big_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack_big_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns_rev
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack_big_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack_little_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack_big_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack_little_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns_rev
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack_little_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack_big_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack_little_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack_big_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack ~byte_order:`Big_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack_big_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack ~byte_order:`Big_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack_big_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack ~byte_order:`Little_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack_little_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack ~byte_order:`Little_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack_little_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack_big_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack ~byte_order:`Big_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack_big_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack ~byte_order:`Big_endian ~buf ~pos)
   ;;
 
   let%test _ =
     ns
     = List.map ns ~f:(fun n ->
-        let buf = Bytes.make buf_size padding in
-        pack_little_endian ~buf ~pos n;
-        test_rest_of_buf buf;
-        unpack ~byte_order:`Little_endian ~buf ~pos)
+      let buf = Bytes.make buf_size padding in
+      pack_little_endian ~buf ~pos n;
+      test_rest_of_buf buf;
+      unpack ~byte_order:`Little_endian ~buf ~pos)
   ;;
 end
 
 let%test_module "inline_unsigned_16" =
   (module Make_inline_tests (struct
-    let ns = [ 0x3f20; 0x7f20; 0xef20; 0; 0x7fff; 0x8000; 0xffff ]
-    let num_bytes = 2
-    let signed = false
-
-    type t = int
-
-    let of_int64 = Int64.to_int_trunc
-    let to_int64 = Int64.of_int
-    let pack = pack_unsigned_16
-    let unpack = unpack_unsigned_16
-    let pack_big_endian = pack_unsigned_16_big_endian
-    let unpack_big_endian = unpack_unsigned_16_big_endian
-    let pack_little_endian = pack_unsigned_16_little_endian
-    let unpack_little_endian = unpack_unsigned_16_little_endian
-  end))
+      let ns = [ 0x3f20; 0x7f20; 0xef20; 0; 0x7fff; 0x8000; 0xffff ]
+      let num_bytes = 2
+      let signed = false
+
+      type t = int
+
+      let of_int64 = Int64.to_int_trunc
+      let to_int64 = Int64.of_int
+      let pack = pack_unsigned_16
+      let unpack = unpack_unsigned_16
+      let pack_big_endian = pack_unsigned_16_big_endian
+      let unpack_big_endian = unpack_unsigned_16_big_endian
+      let pack_little_endian = pack_unsigned_16_little_endian
+      let unpack_little_endian = unpack_unsigned_16_little_endian
+    end))
 ;;
 
 let%test_module "inline_signed_16" =
   (module Make_inline_tests (struct
-    let ns = [ 0x3f20; 0x7f20; -0x7f20; -0x8000; 0; 1; 0x7fff ]
-    let num_bytes = 2
-    let signed = true
-
-    type t = int
-
-    let of_int64 = Int64.to_int_trunc
-    let to_int64 = Int64.of_int
-    let pack = pack_signed_16
-    let unpack = unpack_signed_16
-    let pack_big_endian = pack_signed_16_big_endian
-    let unpack_big_endian = unpack_signed_16_big_endian
-    let pack_little_endian = pack_signed_16_little_endian
-    let unpack_little_endian = unpack_signed_16_little_endian
-  end))
+      let ns = [ 0x3f20; 0x7f20; -0x7f20; -0x8000; 0; 1; 0x7fff ]
+      let num_bytes = 2
+      let signed = true
+
+      type t = int
+
+      let of_int64 = Int64.to_int_trunc
+      let to_int64 = Int64.of_int
+      let pack = pack_signed_16
+      let unpack = unpack_signed_16
+      let pack_big_endian = pack_signed_16_big_endian
+      let unpack_big_endian = unpack_signed_16_big_endian
+      let pack_little_endian = pack_signed_16_little_endian
+      let unpack_little_endian = unpack_signed_16_little_endian
+    end))
 ;;
 
 let signed_max = Int32.to_int_trunc Int32.max_value
@@ -186,58 +186,58 @@ let unsigned_max = Int64.to_int_trunc 0xffff_ffffL
 
 let%test_module ("inline_unsigned_32_int" [@tags "64-bits-only"]) =
   (module Make_inline_tests (struct
-    let ns =
-      [ 0x3f20_3040
-      ; Int64.to_int_exn 0x7f20_3040L
-      ; signed_max
-      ; signed_max + 1
-      ; unsigned_max
-      ; 0
-      ]
-    ;;
-
-    let num_bytes = 4
-    let signed = false
-
-    type t = int
-
-    let of_int64 = Int64.to_int_trunc
-    let to_int64 = Int64.of_int
-    let pack = pack_unsigned_32_int
-    let unpack = unpack_unsigned_32_int
-    let pack_big_endian = pack_unsigned_32_int_big_endian
-    let unpack_big_endian = unpack_unsigned_32_int_big_endian
-    let pack_little_endian = pack_unsigned_32_int_little_endian
-    let unpack_little_endian = unpack_unsigned_32_int_little_endian
-  end))
+      let ns =
+        [ 0x3f20_3040
+        ; Int64.to_int_exn 0x7f20_3040L
+        ; signed_max
+        ; signed_max + 1
+        ; unsigned_max
+        ; 0
+        ]
+      ;;
+
+      let num_bytes = 4
+      let signed = false
+
+      type t = int
+
+      let of_int64 = Int64.to_int_trunc
+      let to_int64 = Int64.of_int
+      let pack = pack_unsigned_32_int
+      let unpack = unpack_unsigned_32_int
+      let pack_big_endian = pack_unsigned_32_int_big_endian
+      let unpack_big_endian = unpack_unsigned_32_int_big_endian
+      let pack_little_endian = pack_unsigned_32_int_little_endian
+      let unpack_little_endian = unpack_unsigned_32_int_little_endian
+    end))
 ;;
 
 let%test_module ("inline_signed_32_int" [@tags "64-bits-only"]) =
   (module Make_inline_tests (struct
-    let ns =
-      [ 0x3f20_3040
-      ; Int64.to_int_exn 0x7f20_3040L
-      ; Int64.to_int_exn (-0x7f20_3040L)
-      ; signed_max
-      ; -(signed_max + 1)
-      ; 0
-      ]
-    ;;
-
-    let num_bytes = 4
-    let signed = true
-
-    type t = int
-
-    let of_int64 = Int64.to_int_trunc
-    let to_int64 = Int64.of_int
-    let pack = pack_signed_32_int
-    let unpack = unpack_signed_32_int
-    let pack_big_endian = pack_signed_32_int_big_endian
-    let unpack_big_endian = unpack_signed_32_int_big_endian
-    let pack_little_endian = pack_signed_32_int_little_endian
-    let unpack_little_endian = unpack_signed_32_int_little_endian
-  end))
+      let ns =
+        [ 0x3f20_3040
+        ; Int64.to_int_exn 0x7f20_3040L
+        ; Int64.to_int_exn (-0x7f20_3040L)
+        ; signed_max
+        ; -(signed_max + 1)
+        ; 0
+        ]
+      ;;
+
+      let num_bytes = 4
+      let signed = true
+
+      type t = int
+
+      let of_int64 = Int64.to_int_trunc
+      let to_int64 = Int64.of_int
+      let pack = pack_signed_32_int
+      let unpack = unpack_signed_32_int
+      let pack_big_endian = pack_signed_32_int_big_endian
+      let unpack_big_endian = unpack_signed_32_int_big_endian
+      let pack_little_endian = pack_signed_32_int_little_endian
+      let unpack_little_endian = unpack_signed_32_int_little_endian
+    end))
 ;;
 
 let%test_unit ("63 bits overflow" [@tags "64-bits-only"]) =
@@ -268,61 +268,61 @@ let%test_unit ("63 bits overflow" [@tags "64-bits-only"]) =
 
 let%test_module "inline_signed_64" =
   (module Make_inline_tests (struct
-    let ns =
-      [ 0x3f20_3040_5060_7080L
-      ; 0x7f20_3040_5060_7080L
-      ; -0x7f20_3040_5060_7080L
-      ; 0x7fff_ffff_ffff_ffffL
-      ; 0x8000_0000_0000_0000L
-      ; 0L
-      ]
-    ;;
-
-    let num_bytes = 8
-    let signed = true
-
-    type t = int64
-
-    let of_int64 = Fn.id
-    let to_int64 = Fn.id
-    let pack = pack_signed_64
-    let unpack = unpack_signed_64
-    let pack_big_endian = pack_signed_64_big_endian
-    let unpack_big_endian = unpack_signed_64_big_endian
-    let pack_little_endian = pack_signed_64_little_endian
-    let unpack_little_endian = unpack_signed_64_little_endian
-  end))
+      let ns =
+        [ 0x3f20_3040_5060_7080L
+        ; 0x7f20_3040_5060_7080L
+        ; -0x7f20_3040_5060_7080L
+        ; 0x7fff_ffff_ffff_ffffL
+        ; 0x8000_0000_0000_0000L
+        ; 0L
+        ]
+      ;;
+
+      let num_bytes = 8
+      let signed = true
+
+      type t = int64
+
+      let of_int64 = Fn.id
+      let to_int64 = Fn.id
+      let pack = pack_signed_64
+      let unpack = unpack_signed_64
+      let pack_big_endian = pack_signed_64_big_endian
+      let unpack_big_endian = unpack_signed_64_big_endian
+      let pack_little_endian = pack_signed_64_little_endian
+      let unpack_little_endian = unpack_signed_64_little_endian
+    end))
 ;;
 
 let%test_module ("inline_signed_64_int" [@tags "64-bits-only"]) =
   (module Make_inline_tests (struct
-    (* These numbers are written with one endianness and read with the opposite endianness,
+      (* These numbers are written with one endianness and read with the opposite endianness,
           so the smallest byte becomes the biggest byte. Because of this, the range restriction
           that applies to the biggest byte also applies to the smallest byte. *)
-    let ns =
-      [ "0x3f20_3040_5060_0708"
-      ; "0x7f20_3040_5060_0708"
-      ; "-0x7f20_3040_5060_0708"
-      ; "0x7fff_ffff_ffff_0000"
-      ; "0"
-      ]
-      |> List.map ~f:Int.of_string
-    ;;
-
-    let num_bytes = 8
-    let signed = true
-
-    type t = int
-
-    let of_int64 = Int64.to_int_trunc
-    let to_int64 = Int64.of_int
-    let pack = pack_signed_64_int
-    let unpack = unpack_signed_64_int
-    let pack_big_endian = pack_signed_64_int_big_endian
-    let unpack_big_endian = unpack_signed_64_int_big_endian
-    let pack_little_endian = pack_signed_64_int_little_endian
-    let unpack_little_endian = unpack_signed_64_int_little_endian
-  end))
+      let ns =
+        [ "0x3f20_3040_5060_0708"
+        ; "0x7f20_3040_5060_0708"
+        ; "-0x7f20_3040_5060_0708"
+        ; "0x7fff_ffff_ffff_0000"
+        ; "0"
+        ]
+        |> List.map ~f:Int.of_string
+      ;;
+
+      let num_bytes = 8
+      let signed = true
+
+      type t = int
+
+      let of_int64 = Int64.to_int_trunc
+      let to_int64 = Int64.of_int
+      let pack = pack_signed_64_int
+      let unpack = unpack_signed_64_int
+      let pack_big_endian = pack_signed_64_int_big_endian
+      let unpack_big_endian = unpack_signed_64_int_big_endian
+      let pack_little_endian = pack_signed_64_int_little_endian
+      let unpack_little_endian = unpack_signed_64_int_little_endian
+    end))
 ;;
 
 let%test_module "inline_tail_padded_fixed_string" =
diff --git a/bounded_int_table/src/bounded_int_table.ml b/bounded_int_table/src/bounded_int_table.ml
index 7d8ea53c..de9bd80b 100644
--- a/bounded_int_table/src/bounded_int_table.ml
+++ b/bounded_int_table/src/bounded_int_table.ml
@@ -21,7 +21,7 @@ type ('key, 'data) t_detailed =
      {[
        entries_by_key.( key_to_int key ) = Some { key; data; _ }
      ]}
-  *)
+      *)
   ; entries_by_key : ('key, 'data) Entry.t option array
       (* The first [length] elements of [defined_entries] hold the data in the table.  This is
      an optimization for fold, to keep us from wasting iterations when the array is
@@ -274,16 +274,16 @@ let for_all t ~f = for_alli t ~f:(fun ~key:_ ~data -> f data)
 let equal key_equal data_equal t1 t2 =
   length t1 = length t2
   && for_alli t1 ~f:(fun ~key ~data ->
-       match entry_opt t2 key with
-       | None -> false
-       | Some entry -> key_equal key entry.Entry.key && data_equal data entry.Entry.data)
+    match entry_opt t2 key with
+    | None -> false
+    | Some entry -> key_equal key entry.Entry.key && data_equal data entry.Entry.data)
 ;;
 
 module With_key (Key : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  val to_int : t -> int
-end) =
+    val to_int : t -> int
+  end) =
 struct
   type 'data t = (Key.t, 'data) table
   type 'data table = 'data t
diff --git a/bounded_int_table/src/bounded_int_table.mli b/bounded_int_table/src/bounded_int_table.mli
index ecf34a63..651d1e5b 100644
--- a/bounded_int_table/src/bounded_int_table.mli
+++ b/bounded_int_table/src/bounded_int_table.mli
@@ -87,10 +87,10 @@ val to_alist : ('key, 'data) t -> ('key * 'data) list
 val clear : (_, _) t -> unit
 
 module With_key (Key : sig
-  type t [@@deriving bin_io, sexp]
+    type t [@@deriving bin_io, sexp]
 
-  val to_int : t -> int
-end) : sig
+    val to_int : t -> int
+  end) : sig
   (** Serialization of a bounded int table using [bin_io] or [sexp] preserves [num_keys],
       but only takes space proportional to the [length] of the table. *)
   type 'data t = (Key.t, 'data) table [@@deriving bin_io, sexp]
diff --git a/bounded_int_table/test/dune b/bounded_int_table/test/dune
index ce9910be..f98f0101 100644
--- a/bounded_int_table/test/dune
+++ b/bounded_int_table/test/dune
@@ -1,5 +1,5 @@
 (library
  (name bounded_int_table_test)
- (libraries bounded_int_table)
+ (libraries bounded_int_table core)
  (preprocess
   (pps ppx_jane)))
diff --git a/bus/bench/bench_bus.ml b/bus/bench/bench_bus.ml
index 34e01c0a..df110323 100644
--- a/bus/bench/bench_bus.ml
+++ b/bus/bench/bench_bus.ml
@@ -22,9 +22,13 @@ let create_with_subscribers (type a) (arity : a Callback_arity.t) ~num_subscribe
              | Arity1 -> fun _ -> ()
              | Arity1_local -> fun _ -> ()
              | Arity2 -> fun _ _ -> ()
+             | Arity2_local -> fun _ _ -> ()
              | Arity3 -> fun _ _ _ -> ()
+             | Arity3_local -> fun _ _ _ -> ()
              | Arity4 -> fun _ _ _ _ -> ()
-             | Arity5 -> fun _ _ _ _ _ -> ()))
+             | Arity4_local -> fun _ _ _ _ -> ()
+             | Arity5 -> fun _ _ _ _ _ -> ()
+             | Arity5_local -> fun _ _ _ _ _ -> ()))
   in
   t, subscribers
 ;;
diff --git a/bus/bench/dune b/bus/bench/dune
index 4afd575c..f2c0248d 100644
--- a/bus/bench/dune
+++ b/bus/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name bus_bench)
- (libraries bus)
+ (libraries bus core)
  (preprocess
   (pps ppx_jane)))
diff --git a/bus/src/bus.ml b/bus/src/bus.ml
index 6e011251..48e65375 100644
--- a/bus/src/bus.ml
+++ b/bus/src/bus.ml
@@ -19,18 +19,26 @@ module Callback_arity = struct
     | Arity1 : ('a -> unit) t
     | Arity1_local : ('a -> unit) t
     | Arity2 : ('a -> 'b -> unit) t
+    | Arity2_local : ('a -> 'b -> unit) t
     | Arity3 : ('a -> 'b -> 'c -> unit) t
+    | Arity3_local : ('a -> 'b -> 'c -> unit) t
     | Arity4 : ('a -> 'b -> 'c -> 'd -> unit) t
+    | Arity4_local : ('a -> 'b -> 'c -> 'd -> unit) t
     | Arity5 : ('a -> 'b -> 'c -> 'd -> 'e -> unit) t
+    | Arity5_local : ('a -> 'b -> 'c -> 'd -> 'e -> unit) t
   [@@deriving sexp_of]
 
   let uses_local_args : type a. a t -> bool = function
     | Arity1 -> false
     | Arity1_local -> true
     | Arity2 -> false
+    | Arity2_local -> true
     | Arity3 -> false
+    | Arity3_local -> true
     | Arity4 -> false
+    | Arity4_local -> true
     | Arity5 -> false
+    | Arity5_local -> true
   ;;
 end
 
@@ -197,7 +205,7 @@ module Subscriber = struct
           ""
             ~subscribers_index:
               (if Ppx_inline_test_lib.am_running then None else Some subscribers_index
-                : (int option[@sexp.option]))
+               : (int option[@sexp.option]))
             (on_callback_raise : ((Error.t -> unit) option[@sexp.option]))
             ~extract_exn:
               (if extract_exn then Some true else None : (bool option[@sexp.option]))
@@ -500,211 +508,342 @@ let[@inline always] unsafe_get_callback a i =
   Option_array.unsafe_get_some_assuming_some a i
 ;;
 
-let write_non_optimized t callbacks a1 =
-  let len = t.num_subscribers in
-  let i = ref 0 in
-  while !i < len do
-    try
-      let callback = unsafe_get_callback callbacks !i in
-      incr i;
-      callback a1
-    with
-    | exn -> callback_raised t !i exn
-  done;
-  finish_write t
-;;
+module Write_variants_without_locals = struct
+  let write_non_optimized t callbacks a1 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
 
-let write_local_non_optimized t callbacks a1 =
-  let len = t.num_subscribers in
-  let i = ref 0 in
-  while !i < len do
-    try
-      let callback = unsafe_get_callback callbacks !i in
-      incr i;
-      callback a1
-    with
-    | exn -> callback_raised t !i exn
-  done;
-  finish_write t
-;;
+  let write2_non_optimized t callbacks a1 a2 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
 
-let write2_non_optimized t callbacks a1 a2 =
-  let len = t.num_subscribers in
-  let i = ref 0 in
-  while !i < len do
-    try
-      let callback = unsafe_get_callback callbacks !i in
-      incr i;
-      callback a1 a2
-    with
-    | exn -> callback_raised t !i exn
-  done;
-  finish_write t
-;;
+  let write3_non_optimized t callbacks a1 a2 a3 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2 a3
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
 
-let write3_non_optimized t callbacks a1 a2 a3 =
-  let len = t.num_subscribers in
-  let i = ref 0 in
-  while !i < len do
-    try
-      let callback = unsafe_get_callback callbacks !i in
-      incr i;
-      callback a1 a2 a3
-    with
-    | exn -> callback_raised t !i exn
-  done;
-  finish_write t
-;;
+  let write4_non_optimized t callbacks a1 a2 a3 a4 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2 a3 a4
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
 
-let write4_non_optimized t callbacks a1 a2 a3 a4 =
-  let len = t.num_subscribers in
-  let i = ref 0 in
-  while !i < len do
-    try
-      let callback = unsafe_get_callback callbacks !i in
-      incr i;
-      callback a1 a2 a3 a4
-    with
-    | exn -> callback_raised t !i exn
-  done;
-  finish_write t
-;;
+  let write5_non_optimized t callbacks a1 a2 a3 a4 a5 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2 a3 a4 a5
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
 
-let write5_non_optimized t callbacks a1 a2 a3 a4 a5 =
-  let len = t.num_subscribers in
-  let i = ref 0 in
-  while !i < len do
-    try
-      let callback = unsafe_get_callback callbacks !i in
-      incr i;
-      callback a1 a2 a3 a4 a5
-    with
-    | exn -> callback_raised t !i exn
-  done;
-  finish_write t
-;;
+  (* The [write_N] functions are written to minimise registers live across function calls
+     (these have to be spilled).  They are also annotated for partial inlining (the
+     one-callback case becomes inlined whereas the >1-callback-case requires a further
+     direct call). *)
 
-(* The [write_N] functions are written to minimise registers live across function calls
-   (these have to be spilled).  They are also annotated for partial inlining (the
-   one-callback case becomes inlined whereas the >1-callback-case requires a further
-   direct call). *)
+  let[@inline always] write t a1 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      (match t.last_value with
+       | None -> ()
+       | Some last_value -> Last_value.set1 last_value a1);
+      if t.num_subscribers > 0
+      then (
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write_non_optimized [@inlined never]) t callbacks a1)
+  ;;
 
-let[@inline always] write t a1 =
-  let callbacks = t.callbacks in
-  t.write_ever_called <- true;
-  match t.state with
-  | Closed | Write_in_progress -> start_write_failing t
-  | Ok_to_write ->
-    (match t.last_value with
-     | None -> ()
-     | Some last_value -> Last_value.set1 last_value a1);
-    if t.num_subscribers > 0
-    then (
-      t.state <- Write_in_progress;
-      if t.num_subscribers = 1
+  let[@inline always] write2 t a1 a2 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      (match t.last_value with
+       | None -> ()
+       | Some last_value -> Last_value.set2 last_value a1 a2);
+      if t.num_subscribers > 0
       then (
-        (try (unsafe_get_callback callbacks 0) a1 with
-         | exn -> callback_raised t 1 exn);
-        finish_write t)
-      else (write_non_optimized [@inlined never]) t callbacks a1)
-;;
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write2_non_optimized [@inlined never]) t callbacks a1 a2)
+  ;;
 
-let[@inline always] write_local t a1 =
-  let callbacks = t.callbacks in
-  t.write_ever_called <- true;
-  match t.state with
-  | Closed | Write_in_progress -> start_write_failing t
-  | Ok_to_write ->
-    if t.num_subscribers > 0
-    then (
-      t.state <- Write_in_progress;
-      if t.num_subscribers = 1
+  let[@inline always] write3 t a1 a2 a3 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      (match t.last_value with
+       | None -> ()
+       | Some last_value -> Last_value.set3 last_value a1 a2 a3);
+      if t.num_subscribers > 0
       then (
-        (try (unsafe_get_callback callbacks 0) a1 with
-         | exn -> callback_raised t 1 exn);
-        finish_write t)
-      else (write_local_non_optimized [@inlined never]) t callbacks a1)
-;;
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 a3 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write3_non_optimized [@inlined never]) t callbacks a1 a2 a3)
+  ;;
 
-let[@inline always] write2 t a1 a2 =
-  let callbacks = t.callbacks in
-  t.write_ever_called <- true;
-  match t.state with
-  | Closed | Write_in_progress -> start_write_failing t
-  | Ok_to_write ->
-    (match t.last_value with
-     | None -> ()
-     | Some last_value -> Last_value.set2 last_value a1 a2);
-    if t.num_subscribers > 0
-    then (
-      t.state <- Write_in_progress;
-      if t.num_subscribers = 1
+  let[@inline always] write4 t a1 a2 a3 a4 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      (match t.last_value with
+       | None -> ()
+       | Some last_value -> Last_value.set4 last_value a1 a2 a3 a4);
+      if t.num_subscribers > 0
       then (
-        (try (unsafe_get_callback callbacks 0) a1 a2 with
-         | exn -> callback_raised t 1 exn);
-        finish_write t)
-      else (write2_non_optimized [@inlined never]) t callbacks a1 a2)
-;;
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 a3 a4 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write4_non_optimized [@inlined never]) t callbacks a1 a2 a3 a4)
+  ;;
 
-let[@inline always] write3 t a1 a2 a3 =
-  let callbacks = t.callbacks in
-  t.write_ever_called <- true;
-  match t.state with
-  | Closed | Write_in_progress -> start_write_failing t
-  | Ok_to_write ->
-    (match t.last_value with
-     | None -> ()
-     | Some last_value -> Last_value.set3 last_value a1 a2 a3);
-    if t.num_subscribers > 0
-    then (
-      t.state <- Write_in_progress;
-      if t.num_subscribers = 1
+  let[@inline always] write5 t a1 a2 a3 a4 a5 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      (match t.last_value with
+       | None -> ()
+       | Some last_value -> Last_value.set5 last_value a1 a2 a3 a4 a5);
+      if t.num_subscribers > 0
       then (
-        (try (unsafe_get_callback callbacks 0) a1 a2 a3 with
-         | exn -> callback_raised t 1 exn);
-        finish_write t)
-      else (write3_non_optimized [@inlined never]) t callbacks a1 a2 a3)
-;;
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 a3 a4 a5 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write5_non_optimized [@inlined never]) t callbacks a1 a2 a3 a4 a5)
+  ;;
+end
 
-let[@inline always] write4 t a1 a2 a3 a4 =
-  let callbacks = t.callbacks in
-  t.write_ever_called <- true;
-  match t.state with
-  | Closed | Write_in_progress -> start_write_failing t
-  | Ok_to_write ->
-    (match t.last_value with
-     | None -> ()
-     | Some last_value -> Last_value.set4 last_value a1 a2 a3 a4);
-    if t.num_subscribers > 0
-    then (
-      t.state <- Write_in_progress;
-      if t.num_subscribers = 1
+module Write_variants_with_locals = struct
+  let write_local_non_optimized t callbacks a1 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
+
+  let write2_local_non_optimized t callbacks a1 a2 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
+
+  let write3_local_non_optimized t callbacks a1 a2 a3 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2 a3
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
+
+  let write4_local_non_optimized t callbacks a1 a2 a3 a4 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2 a3 a4
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
+
+  let write5_local_non_optimized t callbacks a1 a2 a3 a4 a5 =
+    let len = t.num_subscribers in
+    let i = ref 0 in
+    while !i < len do
+      try
+        let callback = unsafe_get_callback callbacks !i in
+        incr i;
+        callback a1 a2 a3 a4 a5
+      with
+      | exn -> callback_raised t !i exn
+    done;
+    finish_write t
+  ;;
+
+  let[@inline always] write_local t a1 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      if t.num_subscribers > 0
       then (
-        (try (unsafe_get_callback callbacks 0) a1 a2 a3 a4 with
-         | exn -> callback_raised t 1 exn);
-        finish_write t)
-      else (write4_non_optimized [@inlined never]) t callbacks a1 a2 a3 a4)
-;;
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write_local_non_optimized [@inlined never]) t callbacks a1)
+  ;;
 
-let[@inline always] write5 t a1 a2 a3 a4 a5 =
-  let callbacks = t.callbacks in
-  t.write_ever_called <- true;
-  match t.state with
-  | Closed | Write_in_progress -> start_write_failing t
-  | Ok_to_write ->
-    (match t.last_value with
-     | None -> ()
-     | Some last_value -> Last_value.set5 last_value a1 a2 a3 a4 a5);
-    if t.num_subscribers > 0
-    then (
-      t.state <- Write_in_progress;
-      if t.num_subscribers = 1
+  let[@inline always] write2_local t a1 a2 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      if t.num_subscribers > 0
       then (
-        (try (unsafe_get_callback callbacks 0) a1 a2 a3 a4 a5 with
-         | exn -> callback_raised t 1 exn);
-        finish_write t)
-      else (write5_non_optimized [@inlined never]) t callbacks a1 a2 a3 a4 a5)
-;;
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write2_local_non_optimized [@inlined never]) t callbacks a1 a2)
+  ;;
+
+  let[@inline always] write3_local t a1 a2 a3 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      if t.num_subscribers > 0
+      then (
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 a3 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write3_local_non_optimized [@inlined never]) t callbacks a1 a2 a3)
+  ;;
+
+  let[@inline always] write4_local t a1 a2 a3 a4 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      if t.num_subscribers > 0
+      then (
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 a3 a4 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write4_local_non_optimized [@inlined never]) t callbacks a1 a2 a3 a4)
+  ;;
+
+  let[@inline always] write5_local t a1 a2 a3 a4 a5 =
+    let callbacks = t.callbacks in
+    t.write_ever_called <- true;
+    match t.state with
+    | Closed | Write_in_progress -> start_write_failing t
+    | Ok_to_write ->
+      if t.num_subscribers > 0
+      then (
+        t.state <- Write_in_progress;
+        if t.num_subscribers = 1
+        then (
+          (try (unsafe_get_callback callbacks 0) a1 a2 a3 a4 a5 with
+           | exn -> callback_raised t 1 exn);
+          finish_write t)
+        else (write5_local_non_optimized [@inlined never]) t callbacks a1 a2 a3 a4 a5)
+  ;;
+end
+
+include Write_variants_with_locals
+include Write_variants_without_locals
 
 let allow_subscription_after_first_write t =
   On_subscription_after_first_write.allow_subscription_after_first_write
@@ -818,11 +957,8 @@ module Fold_arity = struct
     | Arity2 : ('a -> 'b -> unit, 's -> 'a -> 'b -> 's, 's) t
     | Arity3 : ('a -> 'b -> 'c -> unit, 's -> 'a -> 'b -> 'c -> 's, 's) t
     | Arity4 : ('a -> 'b -> 'c -> 'd -> unit, 's -> 'a -> 'b -> 'c -> 'd -> 's, 's) t
-    | Arity5
-        : ( 'a -> 'b -> 'c -> 'd -> 'e -> unit
-          , 's -> 'a -> 'b -> 'c -> 'd -> 'e -> 's
-          , 's )
-          t
+    | Arity5 :
+        ('a -> 'b -> 'c -> 'd -> 'e -> unit, 's -> 'a -> 'b -> 'c -> 'd -> 'e -> 's, 's) t
   [@@deriving sexp_of]
 end
 
diff --git a/bus/src/bus.mli b/bus/src/bus.mli
index 9324150d..32074691 100644
--- a/bus/src/bus.mli
+++ b/bus/src/bus.mli
@@ -14,23 +14,30 @@ open! Core
 (** [Callback_arity] states the type of callbacks stored in a bus. Using [Callback_arity]
     is an implementation technique that allows callbacks to be defined as ordinary n-ary
     curried functions (e.g., [a1 -> a2 -> a3 -> r]), instead of forcing n-ary-variadic
-    callbacks to use tuples (e.g., [a1 * a2 * a3 -> r]).  This also avoids extra
+    callbacks to use tuples (e.g., [a1 * a2 * a3 -> r]). This also avoids extra
     allocation.
 
     When reading the bus interface, keep in mind that each ['callback] is limited, through
     [create], to the types exposed by the variants in [Callback_arity].
 
-    Currently, only a 1-arity callback is provided with local_ annotations in order to
-    avoid an explosion due to the permutations of local_ args.  It is also relatively
-    cheap to make the one local arg a record with multiple fields. *)
+    For use cases where one requires an multi-arity bus with a more nuanced set of local
+    annotations than what is provided, consider packing the fields into a local record and
+    using [Arity1_local], as this is relatively cheap and avoids a blowup in the size of
+    [Callback_arity].
+*)
+
 module Callback_arity : sig
   type _ t =
     | Arity1 : ('a -> unit) t
     | Arity1_local : ('a -> unit) t
     | Arity2 : ('a -> 'b -> unit) t
+    | Arity2_local : ('a -> 'b -> unit) t
     | Arity3 : ('a -> 'b -> 'c -> unit) t
+    | Arity3_local : ('a -> 'b -> 'c -> unit) t
     | Arity4 : ('a -> 'b -> 'c -> 'd -> unit) t
+    | Arity4_local : ('a -> 'b -> 'c -> 'd -> unit) t
     | Arity5 : ('a -> 'b -> 'c -> 'd -> 'e -> unit) t
+    | Arity5_local : ('a -> 'b -> 'c -> 'd -> 'e -> unit) t
   [@@deriving sexp_of]
 end
 
@@ -102,9 +109,19 @@ val close : 'callback Read_write.t -> unit
 val write : ('a -> unit) Read_write.t -> 'a -> unit
 val write_local : ('a -> unit) Read_write.t -> 'a -> unit
 val write2 : ('a -> 'b -> unit) Read_write.t -> 'a -> 'b -> unit
+val write2_local : ('a -> 'b -> unit) Read_write.t -> 'a -> 'b -> unit
 val write3 : ('a -> 'b -> 'c -> unit) Read_write.t -> 'a -> 'b -> 'c -> unit
+val write3_local : ('a -> 'b -> 'c -> unit) Read_write.t -> 'a -> 'b -> 'c -> unit
 val write4 : ('a -> 'b -> 'c -> 'd -> unit) Read_write.t -> 'a -> 'b -> 'c -> 'd -> unit
 
+val write4_local
+  :  ('a -> 'b -> 'c -> 'd -> unit) Read_write.t
+  -> 'a
+  -> 'b
+  -> 'c
+  -> 'd
+  -> unit
+
 val write5
   :  ('a -> 'b -> 'c -> 'd -> 'e -> unit) Read_write.t
   -> 'a
@@ -114,6 +131,15 @@ val write5
   -> 'e
   -> unit
 
+val write5_local
+  :  ('a -> 'b -> 'c -> 'd -> 'e -> unit) Read_write.t
+  -> 'a
+  -> 'b
+  -> 'c
+  -> 'd
+  -> 'e
+  -> unit
+
 module Subscriber : sig
   type 'callback t [@@deriving sexp_of]
 end
@@ -159,11 +185,8 @@ module Fold_arity : sig
     | Arity2 : ('a -> 'b -> unit, 's -> 'a -> 'b -> 's, 's) t
     | Arity3 : ('a -> 'b -> 'c -> unit, 's -> 'a -> 'b -> 'c -> 's, 's) t
     | Arity4 : ('a -> 'b -> 'c -> 'd -> unit, 's -> 'a -> 'b -> 'c -> 'd -> 's, 's) t
-    | Arity5
-        : ( 'a -> 'b -> 'c -> 'd -> 'e -> unit
-          , 's -> 'a -> 'b -> 'c -> 'd -> 'e -> 's
-          , 's )
-          t
+    | Arity5 :
+        ('a -> 'b -> 'c -> 'd -> 'e -> unit, 's -> 'a -> 'b -> 'c -> 'd -> 'e -> 's, 's) t
   [@@deriving sexp_of]
 end
 
diff --git a/bus/test/dune b/bus/test/dune
index 00fa6a20..da733eac 100644
--- a/bus/test/dune
+++ b/bus/test/dune
@@ -1,5 +1,6 @@
 (library
  (name bus_test)
- (libraries bus expect_test_helpers_core)
+ (libraries bus core expect_test_helpers_core.expect_test_helpers_base
+   expect_test_helpers_core)
  (preprocess
   (pps ppx_jane)))
diff --git a/bus/test/test_bus.ml b/bus/test/test_bus.ml
index 3c0d5859..fa66b7f0 100644
--- a/bus/test/test_bus.ml
+++ b/bus/test/test_bus.ml
@@ -6,131 +6,134 @@ let () = Backtrace.elide := true
 let does_raise = Exn.does_raise
 
 include (
-  struct
-    module Callback_arity = Callback_arity
-
-    type nonrec ('a, 'b) t = ('a, 'b) t
-    type ('a, 'b) bus = ('a, 'b) t
-
-    module Read_only = struct
-      type 'a t = 'a Read_only.t [@@deriving sexp_of]
-
-      let invariant = Read_only.invariant
-    end
-
-    module Read_write = struct
-      type 'a t = 'a Read_write.t [@@deriving sexp_of]
-
-      let invariant = Read_write.invariant
-    end
-
-    module On_subscription_after_first_write = On_subscription_after_first_write
-    module Subscriber = Subscriber
-    module Fold_arity = Fold_arity
-
-    let callback_arity = callback_arity
-    let close = close
-    let create_exn = create_exn
-    let fold_exn = fold_exn
-    let is_closed = is_closed
-    let iter_exn = iter_exn
-    let num_subscribers = num_subscribers
-    let read_only = read_only
-    let subscribe_exn = subscribe_exn
-    let unsubscribe = unsubscribe
-    let write = write
-    let write_local = write_local
-    let write2 = write2
-    let write3 = write3
-    let write4 = write4
-    let write5 = write5
-
-    let create1 created_from ~on_subscription_after_first_write =
-      create_exn
-        created_from
-        Arity1
-        ~on_subscription_after_first_write
-        ~on_callback_raise:Error.raise
-    ;;
-
-    let create2 created_from ~on_subscription_after_first_write =
-      create_exn
-        created_from
-        Arity2
-        ~on_subscription_after_first_write
-        ~on_callback_raise:Error.raise
-    ;;
-
-    let sexp_of_t = sexp_of_t
-
-    let%test_module "arity1" =
-      (module struct
-        let%expect_test "sexp_of_t" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          ignore (subscribe_exn bus [%here] ~f:ignore : _ Subscriber.t);
-          ignore (bus |> [%sexp_of: (_, _) t] : Sexp.t)
-        ;;
-
-        let%expect_test "write to empty bus" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          write bus ()
-        ;;
-
-        let%expect_test "can subscribe and unsubscribe" =
-          let call_count = ref 0 in
-          let callback _v = incr call_count in
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          let print_bus () =
-            print_s
-              [%message
-                ""
-                  ~num_subscribers:(num_subscribers bus : int)
-                  ~is_closed:(is_closed bus : bool)
-                  (call_count : int ref)]
-          in
-          print_bus ();
-          [%expect
-            {|
+struct
+  module Callback_arity = Callback_arity
+
+  type nonrec ('a, 'b) t = ('a, 'b) t
+  type ('a, 'b) bus = ('a, 'b) t
+
+  module Read_only = struct
+    type 'a t = 'a Read_only.t [@@deriving sexp_of]
+
+    let invariant = Read_only.invariant
+  end
+
+  module Read_write = struct
+    type 'a t = 'a Read_write.t [@@deriving sexp_of]
+
+    let invariant = Read_write.invariant
+  end
+
+  module On_subscription_after_first_write = On_subscription_after_first_write
+  module Subscriber = Subscriber
+  module Fold_arity = Fold_arity
+
+  let callback_arity = callback_arity
+  let close = close
+  let create_exn = create_exn
+  let fold_exn = fold_exn
+  let is_closed = is_closed
+  let iter_exn = iter_exn
+  let num_subscribers = num_subscribers
+  let read_only = read_only
+  let subscribe_exn = subscribe_exn
+  let unsubscribe = unsubscribe
+  let write = write
+  let write_local = write_local
+  let write2 = write2
+  let write2_local = write2_local
+  let write3 = write3
+  let write3_local = write3_local
+  let write4 = write4
+  let write4_local = write4_local
+  let write5 = write5
+  let write5_local = write5_local
+
+  let create1 created_from ~on_subscription_after_first_write =
+    create_exn
+      created_from
+      Arity1
+      ~on_subscription_after_first_write
+      ~on_callback_raise:Error.raise
+  ;;
+
+  let create2 created_from ~on_subscription_after_first_write =
+    create_exn
+      created_from
+      Arity2
+      ~on_subscription_after_first_write
+      ~on_callback_raise:Error.raise
+  ;;
+
+  let sexp_of_t = sexp_of_t
+
+  let%test_module "arity1" =
+    (module struct
+      let%expect_test "sexp_of_t" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        ignore (subscribe_exn bus [%here] ~f:ignore : _ Subscriber.t);
+        ignore (bus |> [%sexp_of: (_, _) t] : Sexp.t)
+      ;;
+
+      let%expect_test "write to empty bus" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        write bus ()
+      ;;
+
+      let%expect_test "can subscribe and unsubscribe" =
+        let call_count = ref 0 in
+        let callback _v = incr call_count in
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        let print_bus () =
+          print_s
+            [%message
+              ""
+                ~num_subscribers:(num_subscribers bus : int)
+                ~is_closed:(is_closed bus : bool)
+                (call_count : int ref)]
+        in
+        print_bus ();
+        [%expect
+          {|
           ((num_subscribers 0)
            (is_closed       false)
            (call_count      0))
           |}];
-          let subscription = subscribe_exn bus [%here] ~f:callback in
-          print_bus ();
-          [%expect
-            {|
+        let subscription = subscribe_exn bus [%here] ~f:callback in
+        print_bus ();
+        [%expect
+          {|
           ((num_subscribers 1)
            (is_closed       false)
            (call_count      0))
           |}];
-          write bus ();
-          unsubscribe bus subscription;
-          print_bus ();
-          [%expect
-            {|
+        write bus ();
+        unsubscribe bus subscription;
+        print_bus ();
+        [%expect
+          {|
           ((num_subscribers 0)
            (is_closed       false)
            (call_count      1))
           |}];
-          write bus ();
-          print_bus ();
-          [%expect
-            {|
+        write bus ();
+        print_bus ();
+        [%expect
+          {|
           ((num_subscribers 0)
            (is_closed       false)
            (call_count      1))
           |}]
-        ;;
-
-        let%expect_test "subscriber raise" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          ignore
-            (subscribe_exn bus [%here] ~f:(fun _ ->
-               raise_s [%message "subscriber raising"])
-              : _ Subscriber.t);
-          show_raise ~hide_positions:true (fun () -> write bus ());
-          [%expect
-            {|
+      ;;
+
+      let%expect_test "subscriber raise" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        ignore
+          (subscribe_exn bus [%here] ~f:(fun _ -> raise_s [%message "subscriber raising"])
+           : _ Subscriber.t);
+        show_raise ~hide_positions:true (fun () -> write bus ());
+        [%expect
+          {|
           (raised (
             "Bus subscriber raised"
             (exn "subscriber raising")
@@ -138,180 +141,184 @@ include (
             (subscriber (
               Bus.Subscriber.t (subscribed_from lib/bus/test/test_bus.ml:LINE:COL)))))
           |}]
-        ;;
-
-        let%expect_test "~on_subscription_after_first_write:Raise" =
-          let callback _ = () in
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          write bus ();
-          require [%here] (does_raise (fun () -> subscribe_exn bus [%here] ~f:callback))
-        ;;
-
-        let%expect_test "~on_subscription_after_first_write:Allow" =
-          let call_count = ref 0 in
-          let callback _ = incr call_count in
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          write bus ();
-          ignore (subscribe_exn bus [%here] ~f:callback : _ Subscriber.t);
-          print_s [%message (call_count : int ref)];
-          [%expect {| (call_count 0) |}];
-          write bus ();
-          print_s [%message (call_count : int ref)];
-          [%expect {| (call_count 1) |}]
-        ;;
-
-        let%expect_test "on_close is called" =
-          let callback _ = () in
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          let on_close () = print_string "Closed" in
-          ignore (subscribe_exn bus [%here] ~on_close ~f:callback : _ Subscriber.t);
-          Bus.close bus;
-          [%expect {| Closed |}]
-        ;;
-
-        let%expect_test "on_close is not called if you unsubscribe" =
-          let callback _ = () in
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          let on_close () = print_string "Closed" in
-          Bus.unsubscribe bus (subscribe_exn bus [%here] ~on_close ~f:callback);
-          Bus.close bus;
-          [%expect {| |}]
-        ;;
-
-        let%expect_test "~on_subscription_after_first_write:Allow_and_send_last_value" =
-          let bus =
-            create_exn
-              [%here]
-              ~on_subscription_after_first_write:Allow_and_send_last_value
-              Arity1
-              ~on_callback_raise:Error.raise
-          in
-          let subscribe n =
-            ignore
-              (subscribe_exn bus [%here] ~f:(fun s ->
-                 printf "Subscriber %d, value received: %s\n" n s)
-                : _ Subscriber.t)
-          in
-          subscribe 1;
-          [%expect {| |}];
-          write bus "orange";
-          [%expect {| Subscriber 1, value received: orange |}];
-          subscribe 2;
-          [%expect {| Subscriber 2, value received: orange |}];
-          write bus "banana";
-          [%expect
-            {|
+      ;;
+
+      let%expect_test "~on_subscription_after_first_write:Raise" =
+        let callback _ = () in
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        write bus ();
+        require (does_raise (fun () -> subscribe_exn bus [%here] ~f:callback))
+      ;;
+
+      let%expect_test "~on_subscription_after_first_write:Allow" =
+        let call_count = ref 0 in
+        let callback _ = incr call_count in
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        write bus ();
+        ignore (subscribe_exn bus [%here] ~f:callback : _ Subscriber.t);
+        print_s [%message (call_count : int ref)];
+        [%expect {| (call_count 0) |}];
+        write bus ();
+        print_s [%message (call_count : int ref)];
+        [%expect {| (call_count 1) |}]
+      ;;
+
+      let%expect_test "on_close is called" =
+        let callback _ = () in
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        let on_close () = print_string "Closed" in
+        ignore (subscribe_exn bus [%here] ~on_close ~f:callback : _ Subscriber.t);
+        Bus.close bus;
+        [%expect {| Closed |}]
+      ;;
+
+      let%expect_test "on_close is not called if you unsubscribe" =
+        let callback _ = () in
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        let on_close () = print_string "Closed" in
+        Bus.unsubscribe bus (subscribe_exn bus [%here] ~on_close ~f:callback);
+        Bus.close bus;
+        [%expect {| |}]
+      ;;
+
+      let%expect_test "~on_subscription_after_first_write:Allow_and_send_last_value" =
+        let bus =
+          create_exn
+            [%here]
+            ~on_subscription_after_first_write:Allow_and_send_last_value
+            Arity1
+            ~on_callback_raise:Error.raise
+        in
+        let subscribe n =
+          ignore
+            (subscribe_exn bus [%here] ~f:(fun s ->
+               printf "Subscriber %d, value received: %s\n" n s)
+             : _ Subscriber.t)
+        in
+        subscribe 1;
+        [%expect {| |}];
+        write bus "orange";
+        [%expect {| Subscriber 1, value received: orange |}];
+        subscribe 2;
+        [%expect {| Subscriber 2, value received: orange |}];
+        write bus "banana";
+        [%expect
+          {|
           Subscriber 1, value received: banana
           Subscriber 2, value received: banana
           |}];
-          subscribe 3;
-          [%expect {| Subscriber 3, value received: banana |}]
-        ;;
-
-        let%expect_test "unsubscribe is idempotent" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          let subscriber = Bus.subscribe_exn bus [%here] ~f:ignore in
-          unsubscribe bus subscriber;
-          unsubscribe bus subscriber
-        ;;
-
-        let%expect_test "mid-callback unsubscribe takes effect for the next write" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          let subscriber2 = ref None in
-          let call_count1 = ref 0 in
-          let callback1 _ =
-            incr call_count1;
-            unsubscribe bus (Option.value_exn !subscriber2)
-          in
-          let subscriber1 = subscribe_exn bus [%here] ~f:callback1 in
-          let call_count2 = ref 0 in
-          let callback2 _ =
-            incr call_count2;
-            unsubscribe bus subscriber1
-          in
-          let print_call_counts () =
-            print_s [%message (call_count1 : int ref) (call_count2 : int ref)]
-          in
-          subscriber2 := Some (subscribe_exn bus [%here] ~f:callback2);
-          write bus ();
-          print_call_counts ();
-          [%expect {|
+        subscribe 3;
+        [%expect {| Subscriber 3, value received: banana |}]
+      ;;
+
+      let%expect_test "unsubscribe is idempotent" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        let subscriber = Bus.subscribe_exn bus [%here] ~f:ignore in
+        unsubscribe bus subscriber;
+        unsubscribe bus subscriber
+      ;;
+
+      let%expect_test "mid-callback unsubscribe takes effect for the next write" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        let subscriber2 = ref None in
+        let call_count1 = ref 0 in
+        let callback1 _ =
+          incr call_count1;
+          unsubscribe bus (Option.value_exn !subscriber2)
+        in
+        let subscriber1 = subscribe_exn bus [%here] ~f:callback1 in
+        let call_count2 = ref 0 in
+        let callback2 _ =
+          incr call_count2;
+          unsubscribe bus subscriber1
+        in
+        let print_call_counts () =
+          print_s [%message (call_count1 : int ref) (call_count2 : int ref)]
+        in
+        subscriber2 := Some (subscribe_exn bus [%here] ~f:callback2);
+        write bus ();
+        print_call_counts ();
+        [%expect
+          {|
           ((call_count1 1)
            (call_count2 1))
           |}];
-          write bus ();
-          print_call_counts ();
-          [%expect {|
+        write bus ();
+        print_call_counts ();
+        [%expect
+          {|
           ((call_count1 1)
            (call_count2 1))
           |}]
-        ;;
-
-        let%expect_test "subscribe_exn ~on_callback_raise" =
-          let r1 = ref 0 in
-          let r2 = ref 0 in
-          let print_rs () = print_s [%message (r1 : int ref) (r2 : int ref)] in
+      ;;
+
+      let%expect_test "subscribe_exn ~on_callback_raise" =
+        let r1 = ref 0 in
+        let r2 = ref 0 in
+        let print_rs () = print_s [%message (r1 : int ref) (r2 : int ref)] in
+        let bus =
+          create_exn
+            [%here]
+            Arity1
+            ~on_subscription_after_first_write:Allow
+            ~on_callback_raise:(fun _ -> incr r1)
+        in
+        ignore
+          (subscribe_exn
+             bus
+             [%here]
+             ~f:(fun () -> failwith "")
+             ~on_callback_raise:(fun _ -> incr r2)
+           : _ Subscriber.t);
+        print_rs ();
+        [%expect
+          {|
+          ((r1 0)
+           (r2 0))
+          |}];
+        write bus ();
+        print_rs ();
+        [%expect
+          {|
+          ((r1 0)
+           (r2 1))
+          |}]
+      ;;
+
+      let%expect_test "correct exception raised for [subscribe_exn ~extract_exn]" =
+        let print_error ~extract_exn ~error_handler error =
+          print_s
+            ~hide_positions:true
+            [%message
+              ""
+                (extract_exn : bool)
+                (error_handler : [ `Subscriber | `Bus ])
+                (error : Error.t)]
+        in
+        let test ~extract_exn ~on_callback_raise =
           let bus =
             create_exn
               [%here]
               Arity1
               ~on_subscription_after_first_write:Allow
-              ~on_callback_raise:(fun _ -> incr r1)
+              ~on_callback_raise:(print_error ~extract_exn ~error_handler:`Bus)
           in
           ignore
             (subscribe_exn
                bus
                [%here]
-               ~f:(fun () -> failwith "")
-               ~on_callback_raise:(fun _ -> incr r2)
-              : _ Subscriber.t);
-          print_rs ();
-          [%expect {|
-          ((r1 0)
-           (r2 0))
-          |}];
-          write bus ();
-          print_rs ();
-          [%expect {|
-          ((r1 0)
-           (r2 1))
-          |}]
-        ;;
-
-        let%expect_test "correct exception raised for [subscribe_exn ~extract_exn]" =
-          let print_error ~extract_exn ~error_handler error =
-            print_s
-              ~hide_positions:true
-              [%message
-                ""
-                  (extract_exn : bool)
-                  (error_handler : [ `Subscriber | `Bus ])
-                  (error : Error.t)]
-          in
-          let test ~extract_exn ~on_callback_raise =
-            let bus =
-              create_exn
-                [%here]
-                Arity1
-                ~on_subscription_after_first_write:Allow
-                ~on_callback_raise:(print_error ~extract_exn ~error_handler:`Bus)
-            in
-            ignore
-              (subscribe_exn
-                 bus
-                 [%here]
-                 ~extract_exn
-                 ~f:(fun () -> assert false)
-                 ?on_callback_raise:
-                   (match on_callback_raise with
-                    | `Fall_back_to_bus -> None
-                    | `Print -> Some (print_error ~extract_exn ~error_handler:`Subscriber))
-                : (unit -> _) Subscriber.t);
-            write bus ()
-          in
-          test ~extract_exn:false ~on_callback_raise:`Fall_back_to_bus;
-          [%expect
-            {|
+               ~extract_exn
+               ~f:(fun () -> assert false)
+               ?on_callback_raise:
+                 (match on_callback_raise with
+                  | `Fall_back_to_bus -> None
+                  | `Print -> Some (print_error ~extract_exn ~error_handler:`Subscriber))
+             : (unit -> _) Subscriber.t);
+          write bus ()
+        in
+        test ~extract_exn:false ~on_callback_raise:`Fall_back_to_bus;
+        [%expect
+          {|
           ((extract_exn   false)
            (error_handler Bus)
            (error (
@@ -321,9 +328,9 @@ include (
              (subscriber (
                Bus.Subscriber.t (subscribed_from lib/bus/test/test_bus.ml:LINE:COL))))))
           |}];
-          test ~extract_exn:false ~on_callback_raise:`Print;
-          [%expect
-            {|
+        test ~extract_exn:false ~on_callback_raise:`Print;
+        [%expect
+          {|
           ((extract_exn   false)
            (error_handler Subscriber)
            (error (
@@ -335,61 +342,61 @@ include (
                  (on_callback_raise <fun>)
                  (subscribed_from   lib/bus/test/test_bus.ml:LINE:COL)))))))
           |}];
-          test ~extract_exn:true ~on_callback_raise:`Fall_back_to_bus;
-          [%expect
-            {|
+        test ~extract_exn:true ~on_callback_raise:`Fall_back_to_bus;
+        [%expect
+          {|
           ((extract_exn   true)
            (error_handler Bus)
            (error         "Assert_failure test_bus.ml:LINE:COL"))
           |}];
-          test ~extract_exn:true ~on_callback_raise:`Print;
-          [%expect
-            {|
+        test ~extract_exn:true ~on_callback_raise:`Print;
+        [%expect
+          {|
           ((extract_exn   true)
            (error_handler Subscriber)
            (error         "Assert_failure test_bus.ml:LINE:COL"))
           |}]
-        ;;
+      ;;
 
-        let%expect_test "subscribe_exn ~on_callback_raise:raise" =
-          let r = ref 0 in
-          let print_r () = print_s [%message (r : int ref)] in
-          let bus =
-            create_exn
-              [%here]
-              Arity1
-              ~on_subscription_after_first_write:Allow
-              ~on_callback_raise:(fun _ -> incr r)
-          in
-          ignore
-            (subscribe_exn
-               bus
-               [%here]
-               ~f:(fun () -> failwith "")
-               ~on_callback_raise:Error.raise
-              : _ Subscriber.t);
-          print_r ();
-          [%expect {| (r 0) |}];
-          write bus ();
-          print_r ();
-          [%expect {| (r 1) |}]
-        ;;
-
-        let%expect_test "close is idempotent" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          close bus;
-          close bus
-        ;;
-
-        let%expect_test "write raises after close" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          write bus ();
-          close bus;
-          print_s [%message (is_closed bus : bool)];
-          [%expect {| ("is_closed bus" true) |}];
-          show_raise ~hide_positions:true (fun () -> write bus ());
-          [%expect
-            {|
+      let%expect_test "subscribe_exn ~on_callback_raise:raise" =
+        let r = ref 0 in
+        let print_r () = print_s [%message (r : int ref)] in
+        let bus =
+          create_exn
+            [%here]
+            Arity1
+            ~on_subscription_after_first_write:Allow
+            ~on_callback_raise:(fun _ -> incr r)
+        in
+        ignore
+          (subscribe_exn
+             bus
+             [%here]
+             ~f:(fun () -> failwith "")
+             ~on_callback_raise:Error.raise
+           : _ Subscriber.t);
+        print_r ();
+        [%expect {| (r 0) |}];
+        write bus ();
+        print_r ();
+        [%expect {| (r 1) |}]
+      ;;
+
+      let%expect_test "close is idempotent" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        close bus;
+        close bus
+      ;;
+
+      let%expect_test "write raises after close" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        write bus ();
+        close bus;
+        print_s [%message (is_closed bus : bool)];
+        [%expect {| ("is_closed bus" true) |}];
+        show_raise ~hide_positions:true (fun () -> write bus ());
+        [%expect
+          {|
           (raised (
             "[Bus.write] called on closed bus"
             ((callback_arity Arity1)
@@ -400,259 +407,259 @@ include (
              (subscribers ()))
             lib/bus/src/bus.ml:LINE:COL))
           |}]
-        ;;
-
-        let%expect_test "[subscribe_exn] does not raise after [close], and [on_close] is \
-                         not called"
-          =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          let bus_r = read_only bus in
-          close bus;
+      ;;
+
+      let%expect_test "[subscribe_exn] does not raise after [close], and [on_close] is \
+                       not called"
+        =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        let bus_r = read_only bus in
+        close bus;
+        ignore
+          (subscribe_exn
+             bus_r
+             [%here]
+             ~on_close:(fun () -> raise_s [%message "[on_close] should not be called"])
+             ~f:ignore
+           : _ Subscriber.t)
+      ;;
+
+      let%expect_test "during a write, [subscribe_exn] does not raise after [close], and \
+                       [on_close] is not called"
+        =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        let bus_r = read_only bus in
+        ignore
+          (subscribe_exn bus_r [%here] ~f:(fun () ->
+             close bus;
+             ignore
+               (subscribe_exn
+                  bus_r
+                  [%here]
+                  ~on_close:(fun () ->
+                    raise_s [%message "[on_close] should not be called"])
+                  ~f:ignore
+                : _ Subscriber.t))
+           : _ Subscriber.t);
+        write bus ()
+      ;;
+
+      let%expect_test "During write, if [close] and [subscribe_exn] are called, \
+                       [on_close] will be called only if the subscriptions happen before \
+                       [close]. This depends on the order of when the callbacks were \
+                       fired, which could change over time."
+        =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        let bus_r = read_only bus in
+        let subscribe_with_on_close i () =
           ignore
             (subscribe_exn
                bus_r
                [%here]
-               ~on_close:(fun () -> raise_s [%message "[on_close] should not be called"])
+               ~on_close:(fun () -> printf "[on_close] #%d called\n" i)
                ~f:ignore
-              : _ Subscriber.t)
-        ;;
-
-        let%expect_test "during a write, [subscribe_exn] does not raise after [close], \
-                         and [on_close] is not called"
-          =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          let bus_r = read_only bus in
-          ignore
-            (subscribe_exn bus_r [%here] ~f:(fun () ->
-               close bus;
-               ignore
-                 (subscribe_exn
-                    bus_r
-                    [%here]
-                    ~on_close:(fun () ->
-                      raise_s [%message "[on_close] should not be called"])
-                    ~f:ignore
-                   : _ Subscriber.t))
-              : _ Subscriber.t);
-          write bus ()
-        ;;
-
-        let%expect_test "During write, if [close] and [subscribe_exn] are called, \
-                         [on_close] will be called only if the subscriptions happen \
-                         before [close]. This depends on the order of when the callbacks \
-                         were fired, which could change over time."
-          =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          let bus_r = read_only bus in
-          let subscribe_with_on_close i () =
-            ignore
-              (subscribe_exn
-                 bus_r
-                 [%here]
-                 ~on_close:(fun () -> printf "[on_close] #%d called\n" i)
-                 ~f:ignore
-                : _ Subscriber.t)
-          in
-          let callbacks =
-            [ subscribe_with_on_close 0
-            ; (fun () ->
-                subscribe_with_on_close 1 ();
-                close bus;
-                subscribe_with_on_close 2 ())
-            ; subscribe_with_on_close 3
-            ]
-          in
-          List.iter callbacks ~f:(fun callback ->
-            ignore (subscribe_exn bus_r [%here] ~f:callback : _ Subscriber.t));
-          write bus ();
-          (* Since [close] is called after the [on_close] functions 0 and 1 are registered,
+             : _ Subscriber.t)
+        in
+        let callbacks =
+          [ subscribe_with_on_close 0
+          ; (fun () ->
+              subscribe_with_on_close 1 ();
+              close bus;
+              subscribe_with_on_close 2 ())
+          ; subscribe_with_on_close 3
+          ]
+        in
+        List.iter callbacks ~f:(fun callback ->
+          ignore (subscribe_exn bus_r [%here] ~f:callback : _ Subscriber.t));
+        write bus ();
+        (* Since [close] is called after the [on_close] functions 0 and 1 are registered,
            only those two are called. *)
-          [%expect
-            {|
+        [%expect
+          {|
           [on_close] #0 called
           [on_close] #1 called
           |}]
-        ;;
-
-        let%expect_test "During write, if [unsubscribe] is called before [close], then \
-                         the corresponding [on_close] will not be called. But if [close] \
-                         is called before [unsubscribe], [on_close] will be called."
-          =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
-          let bus_r = read_only bus in
-          let subscriber1 =
-            subscribe_exn
-              bus_r
-              [%here]
-              ~on_close:(fun () ->
-                require [%here] false;
-                print_s [%message "subscriber1 [on_close]"])
-              ~f:ignore
-          in
-          ignore
-            (subscribe_exn bus_r [%here] ~f:(fun () ->
-               print_s [%message "unsubscribing subscriber1"];
-               unsubscribe bus_r subscriber1;
-               print_s [%message "closing bus"];
-               close bus)
-              : _ Subscriber.t);
-          let subscriber2 =
-            subscribe_exn
-              bus_r
-              [%here]
-              ~on_close:(fun () -> print_s [%message "subcriber2 [on_close]"])
-              ~f:ignore
-          in
-          ignore
-            (subscribe_exn bus_r [%here] ~f:(fun () ->
-               print_s [%message "unsubscribing subscriber2"];
-               unsubscribe bus_r subscriber2)
-              : _ Subscriber.t);
-          write bus ();
-          [%expect
-            {|
+      ;;
+
+      let%expect_test "During write, if [unsubscribe] is called before [close], then the \
+                       corresponding [on_close] will not be called. But if [close] is \
+                       called before [unsubscribe], [on_close] will be called."
+        =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Allow in
+        let bus_r = read_only bus in
+        let subscriber1 =
+          subscribe_exn
+            bus_r
+            [%here]
+            ~on_close:(fun () ->
+              require false;
+              print_s [%message "subscriber1 [on_close]"])
+            ~f:ignore
+        in
+        ignore
+          (subscribe_exn bus_r [%here] ~f:(fun () ->
+             print_s [%message "unsubscribing subscriber1"];
+             unsubscribe bus_r subscriber1;
+             print_s [%message "closing bus"];
+             close bus)
+           : _ Subscriber.t);
+        let subscriber2 =
+          subscribe_exn
+            bus_r
+            [%here]
+            ~on_close:(fun () -> print_s [%message "subcriber2 [on_close]"])
+            ~f:ignore
+        in
+        ignore
+          (subscribe_exn bus_r [%here] ~f:(fun () ->
+             print_s [%message "unsubscribing subscriber2"];
+             unsubscribe bus_r subscriber2)
+           : _ Subscriber.t);
+        write bus ();
+        [%expect
+          {|
           "unsubscribing subscriber1"
           "closing bus"
           "unsubscribing subscriber2"
           "subcriber2 [on_close]"
           |}]
-        ;;
-
-        let%expect_test "after [close], [write t] without the value to be written" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          close bus;
-          show_raise ~hide_positions:true (fun () -> write bus);
-          [%expect {| "did not raise" |}]
-        ;;
-
-        let%expect_test "close takes effect after all writes" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          let call_count = ref 0 in
-          let callback () =
-            incr call_count;
-            close bus
-          in
-          let (_ : _ Subscriber.t) = subscribe_exn bus [%here] ~f:callback in
-          let (_ : _ Subscriber.t) = subscribe_exn bus [%here] ~f:callback in
-          write bus ();
-          print_s [%message (call_count : int ref)];
-          [%expect {| (call_count 2) |}]
-        ;;
-
-        let%expect_test "raising in [on_callback_raise] closes the bus" =
-          let t =
-            create_exn
-              [%here]
-              Arity1
-              ~on_subscription_after_first_write:Raise
-              ~on_callback_raise:Error.raise
-          in
-          iter_exn t [%here] ~f:(fun _ -> failwith "");
-          require [%here] (does_raise (fun () -> write t ()));
-          require [%here] (is_closed t)
-        ;;
-
-        let%expect_test "fold threads values through future calls" =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          let last1 = ref 0 in
-          let last2 = ref "" in
-          let print_lasts () =
-            print_s [%message (last1 : int ref) (last2 : string ref)]
-          in
-          fold_exn bus [%here] Arity1 ~init:0 ~f:(fun acc () ->
-            let this = acc + 1 in
-            last1 := this;
-            this);
-          fold_exn bus [%here] Arity1 ~init:"" ~f:(fun acc () ->
-            let this = acc ^ "." in
-            last2 := this;
-            this);
-          write bus ();
-          write bus ();
-          write bus ();
-          print_lasts ();
-          [%expect {|
+      ;;
+
+      let%expect_test "after [close], [write t] without the value to be written" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        close bus;
+        show_raise ~hide_positions:true (fun () -> write bus);
+        [%expect {| "did not raise" |}]
+      ;;
+
+      let%expect_test "close takes effect after all writes" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        let call_count = ref 0 in
+        let callback () =
+          incr call_count;
+          close bus
+        in
+        let (_ : _ Subscriber.t) = subscribe_exn bus [%here] ~f:callback in
+        let (_ : _ Subscriber.t) = subscribe_exn bus [%here] ~f:callback in
+        write bus ();
+        print_s [%message (call_count : int ref)];
+        [%expect {| (call_count 2) |}]
+      ;;
+
+      let%expect_test "raising in [on_callback_raise] closes the bus" =
+        let t =
+          create_exn
+            [%here]
+            Arity1
+            ~on_subscription_after_first_write:Raise
+            ~on_callback_raise:Error.raise
+        in
+        iter_exn t [%here] ~f:(fun _ -> failwith "");
+        require (does_raise (fun () -> write t ()));
+        require (is_closed t)
+      ;;
+
+      let%expect_test "fold threads values through future calls" =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        let last1 = ref 0 in
+        let last2 = ref "" in
+        let print_lasts () = print_s [%message (last1 : int ref) (last2 : string ref)] in
+        fold_exn bus [%here] Arity1 ~init:0 ~f:(fun acc () ->
+          let this = acc + 1 in
+          last1 := this;
+          this);
+        fold_exn bus [%here] Arity1 ~init:"" ~f:(fun acc () ->
+          let this = acc ^ "." in
+          last2 := this;
+          this);
+        write bus ();
+        write bus ();
+        write bus ();
+        print_lasts ();
+        [%expect
+          {|
           ((last1 3)
            (last2 ...))
           |}];
-          write bus ();
-          write bus ();
-          print_lasts ();
-          [%expect {|
+        write bus ();
+        write bus ();
+        print_lasts ();
+        [%expect
+          {|
           ((last1 5)
            (last2 .....))
           |}]
-        ;;
-
-        let%expect_test "subscribing during a write with \
-                         [~on_subscription_after_first_write=Allow_and_send_last_value]"
-          =
-          let bus =
-            create1 [%here] ~on_subscription_after_first_write:Allow_and_send_last_value
-          in
-          (* Create a new subscription during each write. *)
-          iter_exn bus [%here] ~f:(fun x ->
-            print_endline [%string "toplevel iter: x = %{x#Int}"];
-            iter_exn bus [%here] ~f:(fun y ->
-              print_endline [%string "nested iter:   x = %{x#Int}, y = %{y#Int}"]));
-          (* When a value is written, the new subscription immediately sees it. *)
-          write bus 1;
-          [%expect
-            {|
+      ;;
+
+      let%expect_test "subscribing during a write with \
+                       [~on_subscription_after_first_write=Allow_and_send_last_value]"
+        =
+        let bus =
+          create1 [%here] ~on_subscription_after_first_write:Allow_and_send_last_value
+        in
+        (* Create a new subscription during each write. *)
+        iter_exn bus [%here] ~f:(fun x ->
+          print_endline [%string "toplevel iter: x = %{x#Int}"];
+          iter_exn bus [%here] ~f:(fun y ->
+            print_endline [%string "nested iter:   x = %{x#Int}, y = %{y#Int}"]));
+        (* When a value is written, the new subscription immediately sees it. *)
+        write bus 1;
+        [%expect
+          {|
           toplevel iter: x = 1
           nested iter:   x = 1, y = 1
           |}];
-          (* Old subscriptions properly see new writes. *)
-          write bus 2;
-          [%expect
-            {|
+        (* Old subscriptions properly see new writes. *)
+        write bus 2;
+        [%expect
+          {|
           toplevel iter: x = 2
           nested iter:   x = 2, y = 2
           nested iter:   x = 1, y = 2
           |}];
-          write bus 3;
-          [%expect
-            {|
+        write bus 3;
+        [%expect
+          {|
           toplevel iter: x = 3
           nested iter:   x = 3, y = 3
           nested iter:   x = 1, y = 3
           nested iter:   x = 2, y = 3
           |}]
-        ;;
-
-        let%expect_test "unsubscribe second listener on first listeners callback" =
-          let bus =
-            create1 [%here] ~on_subscription_after_first_write:Allow_and_send_last_value
-          in
-          let sub2 = ref None in
-          let _sub1 =
-            subscribe_exn bus [%here] ~f:(fun x ->
-              print_endline [%string "permanent sub1: x = %{x#Int}"];
-              Option.iter !sub2 ~f:(fun sub2 -> unsubscribe bus sub2))
-          in
-          sub2
-            := subscribe_exn bus [%here] ~f:(fun x ->
-                 print_endline [%string "temporary sub2: x = %{x#Int}"])
-               |> Some;
-          write bus 1;
-          [%expect
-            {|
+      ;;
+
+      let%expect_test "unsubscribe second listener on first listeners callback" =
+        let bus =
+          create1 [%here] ~on_subscription_after_first_write:Allow_and_send_last_value
+        in
+        let sub2 = ref None in
+        let _sub1 =
+          subscribe_exn bus [%here] ~f:(fun x ->
+            print_endline [%string "permanent sub1: x = %{x#Int}"];
+            Option.iter !sub2 ~f:(fun sub2 -> unsubscribe bus sub2))
+        in
+        sub2
+        := subscribe_exn bus [%here] ~f:(fun x ->
+             print_endline [%string "temporary sub2: x = %{x#Int}"])
+           |> Some;
+        write bus 1;
+        [%expect
+          {|
           permanent sub1: x = 1
           temporary sub2: x = 1
           |}];
-          write bus 2;
-          [%expect {| permanent sub1: x = 2 |}];
-          write bus 3;
-          [%expect {| permanent sub1: x = 3 |}]
-        ;;
-
-        let%expect_test "subscribe and unsubscribe during a single write with \
-                         [~on_subscription_after_first_write=Allow_and_send_last_value]"
-          =
-          let bus =
-            create1 [%here] ~on_subscription_after_first_write:Allow_and_send_last_value
-          in
-          (* Create a new subscription and cancel it during each write.  While this behavior
+        write bus 2;
+        [%expect {| permanent sub1: x = 2 |}];
+        write bus 3;
+        [%expect {| permanent sub1: x = 3 |}]
+      ;;
+
+      let%expect_test "subscribe and unsubscribe during a single write with \
+                       [~on_subscription_after_first_write=Allow_and_send_last_value]"
+        =
+        let bus =
+          create1 [%here] ~on_subscription_after_first_write:Allow_and_send_last_value
+        in
+        (* Create a new subscription and cancel it during each write.  While this behavior
            is a bit strange, one write (of the current value) makes it to the subscriber.
            In other words, the callgraph for this test is:
 
@@ -667,79 +674,79 @@ include (
 
            It may seem weird, but I claim this is no different than when other
            subscribes happen during writes with [Allow_and_send_last_value]. *)
-          iter_exn bus [%here] ~f:(fun x ->
-            print_endline [%string "toplevel iter: x = %{x#Int}"];
-            let subscriber =
-              subscribe_exn bus [%here] ~f:(fun y ->
-                print_endline [%string "nested iter:   x = %{x#Int}, y = %{y#Int}"])
-            in
-            unsubscribe bus subscriber);
-          write bus 1;
-          [%expect
-            {|
+        iter_exn bus [%here] ~f:(fun x ->
+          print_endline [%string "toplevel iter: x = %{x#Int}"];
+          let subscriber =
+            subscribe_exn bus [%here] ~f:(fun y ->
+              print_endline [%string "nested iter:   x = %{x#Int}, y = %{y#Int}"])
+          in
+          unsubscribe bus subscriber);
+        write bus 1;
+        [%expect
+          {|
           toplevel iter: x = 1
           nested iter:   x = 1, y = 1
           |}];
-          write bus 2;
-          [%expect
-            {|
+        write bus 2;
+        [%expect
+          {|
           toplevel iter: x = 2
           nested iter:   x = 2, y = 2
           |}];
-          write bus 3;
-          [%expect
-            {|
+        write bus 3;
+        [%expect
+          {|
           toplevel iter: x = 3
           nested iter:   x = 3, y = 3
           |}]
-        ;;
+      ;;
 
-        let%expect_test "creating many new subscribers during a write with \
-                         [~on_subscription_after_first_write=Allow_and_send_last_value]"
-          =
-          let bus =
-            create_exn
-              [%here]
-              ~on_subscription_after_first_write:Allow_and_send_last_value
-              Arity1
-              ~on_callback_raise:Error.raise
-          in
-          let subscribe n =
-            ignore
-              (subscribe_exn bus [%here] ~f:(fun s ->
-                 printf "Subscriber %d, value received: %s\n" n s)
-                : _ Subscriber.t)
-          in
+      let%expect_test "creating many new subscribers during a write with \
+                       [~on_subscription_after_first_write=Allow_and_send_last_value]"
+        =
+        let bus =
+          create_exn
+            [%here]
+            ~on_subscription_after_first_write:Allow_and_send_last_value
+            Arity1
+            ~on_callback_raise:Error.raise
+        in
+        let subscribe n =
           ignore
-            (subscribe_exn bus [%here] ~f:(fun _ ->
-               subscribe 1;
-               subscribe 2)
-              : _ Subscriber.t);
-          write bus "hello";
-          [%expect
-            {|
+            (subscribe_exn bus [%here] ~f:(fun s ->
+               printf "Subscriber %d, value received: %s\n" n s)
+             : _ Subscriber.t)
+        in
+        ignore
+          (subscribe_exn bus [%here] ~f:(fun _ ->
+             subscribe 1;
+             subscribe 2)
+           : _ Subscriber.t);
+        write bus "hello";
+        [%expect
+          {|
           Subscriber 1, value received: hello
           Subscriber 2, value received: hello
           |}];
-          write bus "again";
-          [%expect
-            {|
+        write bus "again";
+        [%expect
+          {|
           Subscriber 1, value received: again
           Subscriber 2, value received: again
           Subscriber 1, value received: again
           Subscriber 2, value received: again
           |}]
-        ;;
-
-        let%expect_test "subscribing during a write with \
-                         [~on_subscription_after_first_write=Raise]"
-          =
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          (* Create a new subscription during each write *)
-          iter_exn bus [%here] ~f:(fun _ -> iter_exn bus [%here] ~f:ignore);
-          show_raise ~hide_positions:true (fun () -> write bus 1);
-          [%expect
-            {|
+      ;;
+
+      let%expect_test "subscribing during a write with \
+                       [~on_subscription_after_first_write=Raise]"
+        =
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        (* Create a new subscription during each write *)
+        iter_exn bus [%here] ~f:(fun _ -> iter_exn bus [%here] ~f:ignore);
+        show_raise ~hide_positions:true (fun () -> write bus 1);
+        [%expect
+          {|
           (raised (
             "Bus subscriber raised"
             (exn (
@@ -756,139 +763,138 @@ include (
             (subscriber (
               Bus.Subscriber.t (subscribed_from lib/bus/test/test_bus.ml:LINE:COL)))))
           |}]
-        ;;
-
-        let test_free which_unsubscribes =
-          let weak_references = Weak.create 2 in
-          let subscribed_index, unsubscribed_index =
-            match which_unsubscribes with
-            | `First -> 1, 0
-            | `Last -> 0, 1
-          in
-          let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
-          let bus_r = read_only bus in
-          (* Keep two subscribers.  One stays subscribed and the other won't.  The one that
+      ;;
+
+      let test_free which_unsubscribes =
+        let weak_references = Weak.create 2 in
+        let subscribed_index, unsubscribed_index =
+          match which_unsubscribes with
+          | `First -> 1, 0
+          | `Last -> 0, 1
+        in
+        let bus = create1 [%here] ~on_subscription_after_first_write:Raise in
+        let bus_r = read_only bus in
+        (* Keep two subscribers.  One stays subscribed and the other won't.  The one that
            stays subscribed is proof that we can still access the subscribers.  The
            unsubscribed one should be freed. *)
-          Weak.set
-            weak_references
-            subscribed_index
-            (subscribe_exn bus_r [%here] ~f:ignore |> Some);
-          let unsubscriber = ref None in
-          unsubscriber
-            := Some
-                 (subscribe_exn bus_r [%here] ~f:(fun () ->
-                    print_s [%message "unsubscribing" (unsubscribed_index : int)];
-                    unsubscribe bus_r (Option.value_exn !unsubscriber)));
-          Weak.set weak_references unsubscribed_index !unsubscriber;
-          (* Now write to the bus, triggering unsubscription. *)
-          write bus ();
-          (* Invoke a [Gc.full_major] in order to collect the unused subscriber. *)
-          Gc.full_major ();
-          require
-            [%here]
-            (Option.is_some (Weak.get weak_references subscribed_index))
-            ~if_false_then_print_s:(lazy [%message "Missing remaining subscriber"]);
-          require
-            [%here]
-            (Option.is_none (Weak.get weak_references unsubscribed_index))
-            ~if_false_then_print_s:(lazy [%message "Unsubscribed subscriber remains"]);
-          (* Use [bus] again here, otherwise it would be gc'd along with the subscribers
+        Weak.set
+          weak_references
+          subscribed_index
+          (subscribe_exn bus_r [%here] ~f:ignore |> Some);
+        let unsubscriber = ref None in
+        unsubscriber
+        := Some
+             (subscribe_exn bus_r [%here] ~f:(fun () ->
+                print_s [%message "unsubscribing" (unsubscribed_index : int)];
+                unsubscribe bus_r (Option.value_exn !unsubscriber)));
+        Weak.set weak_references unsubscribed_index !unsubscriber;
+        (* Now write to the bus, triggering unsubscription. *)
+        write bus ();
+        (* Invoke a [Gc.full_major] in order to collect the unused subscriber. *)
+        Gc.full_major ();
+        require
+          (Option.is_some (Weak.get weak_references subscribed_index))
+          ~if_false_then_print_s:(lazy [%message "Missing remaining subscriber"]);
+        require
+          (Option.is_none (Weak.get weak_references unsubscribed_index))
+          ~if_false_then_print_s:(lazy [%message "Unsubscribed subscriber remains"]);
+        (* Use [bus] again here, otherwise it would be gc'd along with the subscribers
            above. *)
-          write bus ()
-        ;;
+        write bus ()
+      ;;
 
-        (* There are two 'free' tests because [Bus] does some logic under the hood when
+      (* There are two 'free' tests because [Bus] does some logic under the hood when
          unsubscription occurs, and we should test multiple cases.  Also, there are no
          weak pointers in javascript, so exclude javascript testing. *)
-        let%expect_test ("free first subscriber" [@tags "no-js"]) =
-          test_free `First;
-          [%expect {| (unsubscribing (unsubscribed_index 0)) |}]
-        ;;
-
-        let%expect_test ("free last subscriber" [@tags "no-js"]) =
-          test_free `Last;
-          [%expect {| (unsubscribing (unsubscribed_index 1)) |}]
-        ;;
-      end)
-    ;;
-
-    let%test_module "arity1_local" =
-      (module struct
-        let%expect_test "create raises if you use [Allow_and_send_last_value]" =
-          Expect_test_helpers_base.require_does_raise [%here] (fun () ->
-            create_exn
-              [%here]
-              Arity1_local
-              ~on_subscription_after_first_write:Allow_and_send_last_value
-              ~on_callback_raise:ignore);
-          [%expect
-            {| ("Cannot save last value when using local args" (arity Arity1_local)) |}]
-        ;;
-
-        let%expect_test "[write_local] works as expected" =
-          let bus =
-            create_exn
-              [%here]
-              Arity1_local
-              ~on_subscription_after_first_write:Allow
-              ~on_callback_raise:ignore
-          in
-          Bus.iter_exn bus [%here] ~f:(fun x ->
-            let x =
-              (* hack to globalize the int (local immediates can be trivially globalized)
+      let%expect_test ("free first subscriber" [@tags "no-js"]) =
+        test_free `First;
+        [%expect {| (unsubscribing (unsubscribed_index 0)) |}]
+      ;;
+
+      let%expect_test ("free last subscriber" [@tags "no-js"]) =
+        test_free `Last;
+        [%expect {| (unsubscribing (unsubscribed_index 1)) |}]
+      ;;
+    end)
+  ;;
+
+  let%test_module "arity1_local" =
+    (module struct
+      let%expect_test "create raises if you use [Allow_and_send_last_value]" =
+        Expect_test_helpers_base.require_does_raise (fun () ->
+          create_exn
+            [%here]
+            Arity1_local
+            ~on_subscription_after_first_write:Allow_and_send_last_value
+            ~on_callback_raise:ignore);
+        [%expect
+          {| ("Cannot save last value when using local args" (arity Arity1_local)) |}]
+      ;;
+
+      let%expect_test "[write_local] works as expected" =
+        let bus =
+          create_exn
+            [%here]
+            Arity1_local
+            ~on_subscription_after_first_write:Allow
+            ~on_callback_raise:ignore
+        in
+        Bus.iter_exn bus [%here] ~f:(fun x ->
+          let x =
+            (* hack to globalize the int (local immediates can be trivially globalized)
             *)
-              x + 0
-            in
-            print_s [%sexp (x : int)]);
-          Bus.write_local bus 42;
-          [%expect {| 42 |}]
-        ;;
-      end)
-    ;;
-
-    let%test_module "arity2" =
-      (module struct
-        let%expect_test "on_callback_raise called for every error" =
-          let call_count = ref 0 in
-          let on_callback_raise _ = incr call_count in
-          let bus =
-            create_exn
-              [%here]
-              Arity2
-              ~on_subscription_after_first_write:Allow
-              ~on_callback_raise
+            x + 0
           in
-          let callback1 _ _ = failwith "callback1" in
-          let callback2 _ _ = failwith "callback2" in
-          ignore (subscribe_exn bus [%here] ~f:callback1 : _ Subscriber.t);
-          ignore (subscribe_exn bus [%here] ~f:callback2 : _ Subscriber.t);
-          write2 bus () ();
-          print_s [%message (call_count : int ref)];
-          [%expect {| (call_count 2) |}]
-        ;;
-
-        let%expect_test "mid-callback subscribe_exn takes effect for the next write" =
-          let bus = create2 [%here] ~on_subscription_after_first_write:Allow in
-          let call_count2 = ref 0 in
-          let callback2 _ _ = incr call_count2 in
-          let call_count1 = ref 0 in
-          let callback1 _ _ =
-            incr call_count1;
-            ignore (subscribe_exn bus [%here] ~f:callback2 : _ Subscriber.t)
-          in
-          ignore (subscribe_exn bus [%here] ~f:callback1 : _ Subscriber.t);
-          write2 bus () ();
-          write2 bus () ();
-          print_s [%message (call_count1 : int ref) (call_count2 : int ref)];
-          [%expect {|
+          print_s [%sexp (x : int)]);
+        Bus.write_local bus 42;
+        [%expect {| 42 |}]
+      ;;
+    end)
+  ;;
+
+  let%test_module "arity2" =
+    (module struct
+      let%expect_test "on_callback_raise called for every error" =
+        let call_count = ref 0 in
+        let on_callback_raise _ = incr call_count in
+        let bus =
+          create_exn
+            [%here]
+            Arity2
+            ~on_subscription_after_first_write:Allow
+            ~on_callback_raise
+        in
+        let callback1 _ _ = failwith "callback1" in
+        let callback2 _ _ = failwith "callback2" in
+        ignore (subscribe_exn bus [%here] ~f:callback1 : _ Subscriber.t);
+        ignore (subscribe_exn bus [%here] ~f:callback2 : _ Subscriber.t);
+        write2 bus () ();
+        print_s [%message (call_count : int ref)];
+        [%expect {| (call_count 2) |}]
+      ;;
+
+      let%expect_test "mid-callback subscribe_exn takes effect for the next write" =
+        let bus = create2 [%here] ~on_subscription_after_first_write:Allow in
+        let call_count2 = ref 0 in
+        let callback2 _ _ = incr call_count2 in
+        let call_count1 = ref 0 in
+        let callback1 _ _ =
+          incr call_count1;
+          ignore (subscribe_exn bus [%here] ~f:callback2 : _ Subscriber.t)
+        in
+        ignore (subscribe_exn bus [%here] ~f:callback1 : _ Subscriber.t);
+        write2 bus () ();
+        write2 bus () ();
+        print_s [%message (call_count1 : int ref) (call_count2 : int ref)];
+        [%expect
+          {|
           ((call_count1 2)
            (call_count2 1))
           |}]
-        ;;
-      end)
-    ;;
-  end
-  (* This signature constraint is here to remind us to add a unit test whenever
+      ;;
+    end)
+  ;;
+end
+(* This signature constraint is here to remind us to add a unit test whenever
    the interface to [Bus] changes. *) :
-    module type of Bus)
+  module type of Bus)
diff --git a/enum/doc/README.mlt b/enum/doc/README.mlt
index 32bf395d..8e8bf242 100644
--- a/enum/doc/README.mlt
+++ b/enum/doc/README.mlt
@@ -154,7 +154,7 @@ end
 
 let () =
   List.iter [%all: M.t] ~f:(fun m ->
-    require_compare_equal [%here] (module M) m (M.of_string (M.to_string m));
+    require_compare_equal (module M) m (M.of_string (M.to_string m));
     print_endline (M.to_string m))
 ;;
 
@@ -216,7 +216,7 @@ module T3 = struct
 end
 
 let () =
-  Expect_test_helpers_core.require_does_not_raise ~cr:CR [%here] (fun () ->
+  Expect_test_helpers_core.require_does_not_raise ~cr:CR (fun () ->
     ignore (T3.of_string "a" : T3.t))
 ;;
 
diff --git a/enum/src/dune b/enum/src/dune
index 684bcc83..3384cad7 100644
--- a/enum/src/dune
+++ b/enum/src/dune
@@ -3,4 +3,4 @@
  (public_name core_kernel.enum)
  (preprocess
   (pps ppx_jane))
- (libraries base core.command))
+ (libraries base core.command parsexp core.univ_map))
diff --git a/enum/src/enum.ml b/enum/src/enum.ml
index 833417e9..1636e5a0 100644
--- a/enum/src/enum.ml
+++ b/enum/src/enum.ml
@@ -162,6 +162,15 @@ let make_param_one_of_flags
        Command.Param.flag ?aliases name (Command.Param.no_arg_some enum) ~doc))
 ;;
 
+let make_param_optional_one_of_flags ?aliases ~doc m =
+  Command.Param.choose_one
+    ~if_nothing_chosen:Return_none
+    (List.map (enum m) ~f:(fun (name, enum) ->
+       let aliases = Option.map aliases ~f:(fun aliases -> aliases enum) in
+       let doc = doc enum in
+       Command.Param.flag ?aliases name (Command.Param.no_arg_some enum) ~doc))
+;;
+
 let comma_separated_extra_doc m =
   let options =
     enum m
@@ -268,9 +277,9 @@ module Make_stringable (M : S) : Stringable.S with type t := M.t = struct
   include Make_to_string (M)
 
   include Make_of_string (struct
-    type t = M.t
+      type t = M.t
 
-    let all = M.all
-    let to_string = to_string
-  end)
+      let all = M.all
+      let to_string = to_string
+    end)
 end
diff --git a/enum/src/enum_intf.ml b/enum/src/enum_intf.ml
index 02ef60e3..19371ed2 100644
--- a/enum/src/enum_intf.ml
+++ b/enum/src/enum_intf.ml
@@ -66,6 +66,12 @@ module type Enum = sig
     -> 'a t
     -> 'a Command.Param.t
 
+  val make_param_optional_one_of_flags
+    :  ?aliases:('a -> string list)
+    -> doc:('a -> string)
+    -> 'a t
+    -> 'a option Command.Param.t
+
   val make_param_optional_with_default_doc : default:'a -> ('a, 'a) make_param
 
   val make_param_optional_comma_separated
diff --git a/fheap/bench/dune b/fheap/bench/dune
index e52f8405..9b220fab 100644
--- a/fheap/bench/dune
+++ b/fheap/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name fheap_bench)
- (libraries fheap)
+ (libraries core fheap)
  (preprocess
   (pps ppx_jane)))
diff --git a/fheap/src/fheap.ml b/fheap/src/fheap.ml
index 36a0c76c..f23f87d1 100644
--- a/fheap/src/fheap.ml
+++ b/fheap/src/fheap.ml
@@ -113,12 +113,12 @@ let fold t ~init ~f =
 let length t = t.length
 
 module C = Container.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let fold = fold
-  let iter = `Define_using_fold
-  let length = `Custom length
-end)
+    let fold = fold
+    let iter = `Define_using_fold
+    let length = `Custom length
+  end)
 
 let is_empty t = Option.is_none t.heap
 let iter = C.iter
diff --git a/fheap/test/dune b/fheap/test/dune
index 61d460d2..b3de4f77 100644
--- a/fheap/test/dune
+++ b/fheap/test/dune
@@ -1,5 +1,5 @@
 (library
  (name fheap_test)
- (libraries fheap)
+ (libraries core fheap)
  (preprocess
   (pps ppx_jane)))
diff --git a/flags/src/flags.ml b/flags/src/flags.ml
index 24732e05..865f3e67 100644
--- a/flags/src/flags.ml
+++ b/flags/src/flags.ml
@@ -148,8 +148,8 @@ module Make (M : Make_arg) = struct
   ;;
 
   include Comparable.Make (struct
-    type nonrec t = t [@@deriving sexp, compare, hash]
-  end)
+      type nonrec t = t [@@deriving sexp, compare, hash]
+    end)
 
   (* [Comparable.Make] turns [equal] into a function call to [compare] rather than the
      much simpler (and equally correct) [Int63.(=)]. Restore it, as well as (=) and (<>). *)
diff --git a/flags/test/dune b/flags/test/dune
index 2c48c2f6..87bf7955 100644
--- a/flags/test/dune
+++ b/flags/test/dune
@@ -1,5 +1,5 @@
 (library
  (name flags_test)
- (libraries expect_test_helpers_core flags)
+ (libraries core expect_test_helpers_core flags)
  (preprocess
   (pps ppx_jane)))
diff --git a/flags/test/test_flags.ml b/flags/test/test_flags.ml
index 67283b9c..48bf135a 100644
--- a/flags/test/test_flags.ml
+++ b/flags/test/test_flags.ml
@@ -44,7 +44,7 @@ module M = Make (Flags)
 include M
 
 let%expect_test _ =
-  print_and_check_comparable_sexps [%here] (module M) [ a; b; c ];
+  print_and_check_comparable_sexps (module M) [ a; b; c ];
   [%expect
     {|
     (Set (
@@ -89,7 +89,7 @@ let%expect_test _ =
 
 (* [t_of_sexp] *)
 let check_t_of_sexp here expect string =
-  require here (equal expect (t_of_sexp (Sexp.of_string string)))
+  require ~here (equal expect (t_of_sexp (Sexp.of_string string)))
 ;;
 
 let%expect_test _ = check_t_of_sexp [%here] empty "()"
@@ -118,36 +118,36 @@ let%expect_test _ =
 ;;
 
 (* +, - *)
-let%expect_test _ = require [%here] (equal (a + a) a)
-let%expect_test _ = require [%here] (equal (a + b) (b + a))
-let%expect_test _ = require [%here] (equal (a - a) empty)
-let%expect_test _ = require [%here] (equal (a + b - a) b)
+let%expect_test _ = require (equal (a + a) a)
+let%expect_test _ = require (equal (a + b) (b + a))
+let%expect_test _ = require (equal (a - a) empty)
+let%expect_test _ = require (equal (a + b - a) b)
 
 (* [intersect] *)
-let%expect_test _ = require [%here] (equal (intersect a a) a)
-let%expect_test _ = require [%here] (equal (intersect a b) empty)
-let%expect_test _ = require [%here] (equal (intersect (a + b) a) a)
+let%expect_test _ = require (equal (intersect a a) a)
+let%expect_test _ = require (equal (intersect a b) empty)
+let%expect_test _ = require (equal (intersect (a + b) a) a)
 
 (* [complement] *)
-let%expect_test _ = require [%here] (equal (intersect (complement a) b) b)
+let%expect_test _ = require (equal (intersect (complement a) b) b)
 
 (* [do_intersect] *)
-let%expect_test _ = require [%here] (do_intersect a a)
-let%expect_test _ = require [%here] (not (do_intersect a b))
-let%expect_test _ = require [%here] (do_intersect (a + b) a)
-let%expect_test _ = require [%here] (do_intersect (a + b) b)
-let%expect_test _ = require [%here] (not (do_intersect (a + b) c))
+let%expect_test _ = require (do_intersect a a)
+let%expect_test _ = require (not (do_intersect a b))
+let%expect_test _ = require (do_intersect (a + b) a)
+let%expect_test _ = require (do_intersect (a + b) b)
+let%expect_test _ = require (not (do_intersect (a + b) c))
 
 (* [are_disjoint] *)
-let%expect_test _ = require [%here] (are_disjoint a empty)
-let%expect_test _ = require [%here] (not (are_disjoint a a))
-let%expect_test _ = require [%here] (are_disjoint a b)
-let%expect_test _ = require [%here] (are_disjoint b a)
-let%expect_test _ = require [%here] (not (are_disjoint (a + b) a))
-let%expect_test _ = require [%here] (are_disjoint (a + b) c)
+let%expect_test _ = require (are_disjoint a empty)
+let%expect_test _ = require (not (are_disjoint a a))
+let%expect_test _ = require (are_disjoint a b)
+let%expect_test _ = require (are_disjoint b a)
+let%expect_test _ = require (not (are_disjoint (a + b) a))
+let%expect_test _ = require (are_disjoint (a + b) c)
 
 (* compare *)
-let%expect_test _ = require [%here] (Int.( = ) (Int.compare 0 1) (-1))
+let%expect_test _ = require (Int.( = ) (Int.compare 0 1) (-1))
 let print_compare t1 t2 = print_s [%sexp (compare t1 t2 : int)]
 
 let%expect_test _ =
@@ -198,7 +198,7 @@ let%expect_test "[compare] is a total order consistent with [is_subset]" =
   [%expect {| -1 |}];
   let test_ordering ordered =
     List.is_sorted_strictly ordered ~compare:(fun f1 f2 ->
-      require [%here] (not (M.is_subset f2 ~of_:f1));
+      require (not (M.is_subset f2 ~of_:f1));
       M.compare f1 f2)
   in
   let known = List.map Flags.known ~f:fst in
@@ -218,7 +218,7 @@ let%expect_test "[compare] is a total order consistent with [is_subset]" =
       (b c)
       (a b c)))
     |}];
-  require [%here] (test_ordering ordered);
+  require (test_ordering ordered);
   let complements = List.map ordered ~f:M.complement in
   print_s [%message (complements : M.t list)];
   [%expect
@@ -235,10 +235,10 @@ let%expect_test "[compare] is a total order consistent with [is_subset]" =
     |}];
   (* complemented flags (forms a reversed ordering) *)
   let ordered = complements |> List.rev in
-  require [%here] (test_ordering ordered);
+  require (test_ordering ordered);
   (* With "unknown" flag [d] *)
   let ordered = combinations (known @ [ d ]) in
-  require [%here] (test_ordering ordered)
+  require (test_ordering ordered)
 ;;
 
 (* Check that conflicting flags leads to an error. *)
@@ -270,7 +270,7 @@ let%expect_test "ensure sexp representation of flags having only recognized bits
   List.iter t_list ~f:(fun t ->
     let sexp = [%sexp (t : t)] in
     let t_recovered = t_of_sexp sexp in
-    Expect_test_helpers_core.require_equal [%here] (module M) t t_recovered);
+    Expect_test_helpers_core.require_equal (module M) t t_recovered);
   [%expect {| |}]
 ;;
 
@@ -280,7 +280,7 @@ let%expect_test "ensure sexp representation of flag with unrecognized bits round
   print_s sexp;
   [%expect {| ((a b c) (unrecognized_bits 0x3ffffffffffffff0)) |}];
   let t_recovered = t_of_sexp sexp in
-  Expect_test_helpers_core.require_equal [%here] (module M) t t_recovered;
+  Expect_test_helpers_core.require_equal (module M) t t_recovered;
   print_s [%message (t : t) (t_recovered : t) (sexp : Sexp.t)];
   [%expect
     {|
@@ -323,7 +323,7 @@ let%expect_test "quickcheck test: ensure sexps round-trip for general scenarios"
     let t = M.of_int i in
     let sexp = [%sexp (t : M.t)] in
     let t_recovered = M.t_of_sexp sexp in
-    Expect_test_helpers_core.require_equal [%here] (module M) t t_recovered);
+    Expect_test_helpers_core.require_equal (module M) t t_recovered);
   [%expect {| |}]
 ;;
 
@@ -335,7 +335,7 @@ let%expect_test "quickcheck_test: existing hex representations can still be conv
   Quickcheck.test ~trials:1000 gen_int63 ~f:(fun int63 ->
     let old_format_hex_num = to_unsigned_hex_string_old int63 in
     let int63_recovered = of_unsigned_hex_string old_format_hex_num in
-    Expect_test_helpers_core.require_equal [%here] (module Int63) int63 int63_recovered);
+    Expect_test_helpers_core.require_equal (module Int63) int63 int63_recovered);
   [%expect {| |}]
 ;;
 
@@ -349,7 +349,6 @@ let%expect_test "old hex repr of 2^62 still deserializes correctly" =
   let old_hex_str = to_unsigned_hex_string_old num in
   let new_hex_str = to_unsigned_hex_string_new num in
   Expect_test_helpers_core.require_equal
-    [%here]
     (module Int63)
     (of_unsigned_hex_string old_hex_str)
     (of_unsigned_hex_string new_hex_str);
diff --git a/hash_heap/test/test_hash_heap.ml b/hash_heap/test/test_hash_heap.ml
index 1b356689..6befe3d0 100644
--- a/hash_heap/test/test_hash_heap.ml
+++ b/hash_heap/test/test_hash_heap.ml
@@ -2,7 +2,7 @@ open! Core
 open! Expect_test_helpers_base
 module Hash_heap = Hash_heap.Make (Int)
 
-let ( @? ) s b = require [%here] b ~if_false_then_print_s:(lazy [%message s])
+let ( @? ) s b = require b ~if_false_then_print_s:(lazy [%message s])
 let s = [ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11 ]
 
 let make () =
diff --git a/iobuf/bench/dune b/iobuf/bench/dune
index 0d4db3b1..85ecb14b 100644
--- a/iobuf/bench/dune
+++ b/iobuf/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name iobuf_bench)
- (libraries iobuf)
+ (libraries core iobuf)
  (preprocess
   (pps ppx_jane)))
diff --git a/iobuf/src/iobuf.ml b/iobuf/src/iobuf.ml
index 4cfced82..e0029e74 100644
--- a/iobuf/src/iobuf.ml
+++ b/iobuf/src/iobuf.ml
@@ -25,8 +25,7 @@ let arch_sixtyfour = Sys.word_size_in_bits = 64
 module T = struct
   (* WHEN YOU CHANGE THIS, CHANGE iobuf_fields IN iobuf.h AS WELL!!! *)
   type t =
-    { mutable
-        buf :
+    { mutable buf :
         (Bigstring.t
         [@sexp.opaque] (* The data in [buf] is at indices [lo], [lo+1], ... [hi-1]. *))
     ; mutable lo_min : int
@@ -48,6 +47,12 @@ type no_seek = Iobuf_intf.no_seek [@@deriving sexp_of]
 
 module type Bound = Iobuf_intf.Bound with type ('d, 'w) iobuf := ('d, 'w) t
 
+let globalize_phantom name _ =
+  failwithf "Unexpectedly called [Iobuf.globalize_%s]" name ()
+;;
+
+let globalize_seek = globalize_phantom "seek"
+let globalize_no_seek = globalize_phantom "no_seek"
 let globalize _ _ t = [%globalize: t_repr] t
 let read_only t = t
 let read_only_local t = t
@@ -183,7 +188,7 @@ let[@cold] bad_range_bstr ~pos ~len ~str_len =
 
 let check_range t ~pos ~len =
   if pos < 0 || len < 0 || len > length t - pos then bad_range ~pos ~len t
-  [@@inline always]
+[@@inline always]
 ;;
 
 let[@inline always] unsafe_bigstring_view ~pos ~len buf =
@@ -272,7 +277,7 @@ let set_bounds_and_buffer_sub ~pos ~len ~src ~dst =
   dst.hi <- hi;
   dst.hi_max <- hi;
   if not (phys_equal dst.buf src.buf) then dst.buf <- src.buf
-  [@@inline]
+[@@inline]
 ;;
 
 let set_bounds_and_buffer ~src ~dst =
@@ -298,7 +303,7 @@ let resize t ~len =
   let hi = t.lo + len in
   if hi > t.hi_max then bad_range t ~len ~pos:0;
   t.hi <- hi
-  [@@inline always]
+[@@inline always]
 ;;
 
 let unsafe_resize = if unsafe_is_safe then resize else unsafe_resize
@@ -510,7 +515,7 @@ let unsafe_advance t n = t.lo <- t.lo + n
 let advance t len =
   check_range t ~len ~pos:0;
   unsafe_advance t len
-  [@@inline always]
+[@@inline always]
 ;;
 
 let unsafe_advance = if unsafe_is_safe then advance else unsafe_advance
@@ -547,6 +552,7 @@ module Bytes_dst = struct
   ;;
 
   let create ~len = create len
+  let get t i = get t i
 end
 
 module String_dst = struct
@@ -613,14 +619,14 @@ module Consume = struct
   type src = (read, seek) t
 
   module To (Dst : sig
-    type t [@@deriving sexp_of]
-
-    val create : len:int -> t
-    val length : t -> int
-    val get : t -> int -> char
-    val set : t -> int -> char -> unit
-    val unsafe_blit : (T.t, t) Blit.blit
-  end) =
+      type t [@@deriving sexp_of]
+
+      val create : len:int -> t
+      val length : t -> int
+      val get : t -> int -> char
+      val set : t -> int -> char -> unit
+      val unsafe_blit : (T.t, t) Blit.blit
+    end) =
   struct
     include Base_for_tests.Test_blit.Make_distinct_and_test (Char_elt) (T_src) (Dst)
 
@@ -686,13 +692,13 @@ module Consume = struct
   let uadv t n x =
     unsafe_advance t n;
     x
-    [@@inline always]
+  [@@inline always]
   ;;
 
   let uadv_local t n x =
     unsafe_advance t n;
     x
-    [@@inline always]
+  [@@inline always]
   ;;
 
   let pos t len = buf_pos_exn t ~pos:0 ~len
@@ -1417,6 +1423,11 @@ module Peek = struct
     Option.map (Bigstring.find ~pos ~len c t.buf) ~f:(fun x -> x - t.lo) [@nontail]
   ;;
 
+  let rindex t ?(pos = 0) ?(len = length t - pos) c =
+    let pos = spos t ~len ~pos in
+    Option.map (Bigstring.rfind ~pos ~len c t.buf) ~f:(fun x -> x - t.lo) [@nontail]
+  ;;
+
   module Local = struct
     let tail_padded_fixed_string ~padding ~len t ~pos =
       Bigstring.get_tail_padded_fixed_string_local
@@ -2190,13 +2201,13 @@ module Unsafe = struct
     let uadv t n x =
       unsafe_advance t n;
       x
-      [@@inline always]
+    [@@inline always]
     ;;
 
     let uadv_local t n x =
       unsafe_advance t n;
       x
-      [@@inline always]
+    [@@inline always]
     ;;
 
     let upos t len = unsafe_buf_pos t ~pos:0 ~len
@@ -2446,6 +2457,7 @@ module Unsafe = struct
     ;;
 
     let bin_prot = Fill.bin_prot
+    let bin_prot_local = Fill.bin_prot_local
 
     open Bigstring
 
@@ -2679,6 +2691,12 @@ module Unsafe = struct
       if idx < 0 then -1 else idx - t.lo
     ;;
 
+    let rindex_or_neg t ~pos ~len c =
+      let pos = unsafe_buf_pos t ~pos ~len in
+      let idx = Bigstring.unsafe_rfind ~pos ~len t.buf c in
+      if idx < 0 then -1 else idx - t.lo
+    ;;
+
     module Local = struct
       let tail_padded_fixed_string ~padding ~len t ~pos =
         Bigstring.get_tail_padded_fixed_string_local
@@ -3198,25 +3216,25 @@ module For_hexdump = struct
   end
 
   module Window_and_limits = Make_compound_hexdump (struct
-    include Limits
+      include Limits
 
-    let parts =
-      [ (module Window_within_limits : Relative_indexable)
-      ; (module Limits_within_limits : Relative_indexable)
-      ]
-    ;;
-  end)
+      let parts =
+        [ (module Window_within_limits : Relative_indexable)
+        ; (module Limits_within_limits : Relative_indexable)
+        ]
+      ;;
+    end)
 
   module Window_and_limits_and_buffer = Make_compound_hexdump (struct
-    include Buffer
+      include Buffer
 
-    let parts =
-      [ (module Window_within_buffer : Relative_indexable)
-      ; (module Limits_within_buffer : Relative_indexable)
-      ; (module Buffer_within_buffer : Relative_indexable)
-      ]
-    ;;
-  end)
+      let parts =
+        [ (module Window_within_buffer : Relative_indexable)
+        ; (module Limits_within_buffer : Relative_indexable)
+        ; (module Buffer_within_buffer : Relative_indexable)
+        ]
+      ;;
+    end)
 end
 
 module Window = For_hexdump.Window
diff --git a/iobuf/src/iobuf.mli b/iobuf/src/iobuf.mli
index c4e7d21c..60677aa7 100644
--- a/iobuf/src/iobuf.mli
+++ b/iobuf/src/iobuf.mli
@@ -24,8 +24,8 @@
 open! Core
 open Iobuf_intf
 
-type nonrec seek = seek [@@deriving sexp_of]
-type nonrec no_seek = no_seek [@@deriving sexp_of]
+type nonrec seek = seek [@@deriving globalize, sexp_of]
+type nonrec no_seek = no_seek [@@deriving globalize, sexp_of]
 
 (** This type is a compiler witness that 'rw and 'seek do not affect layout; it enables
     wider use of unboxed GADTs. *)
@@ -389,9 +389,9 @@ module Consume : sig
 
   include
     Accessors_read
-      with type ('a, 'r, 's) t = (([> read ] as 'r), seek) t -> 'a
-      with type ('a, 'r, 's) t_local = (([> read ] as 'r), seek) t -> 'a
-      with type 'a bin_prot := 'a Bin_prot.Type_class.reader
+    with type ('a, 'r, 's) t = (([> read ] as 'r), seek) t -> 'a
+    with type ('a, 'r, 's) t_local = (([> read ] as 'r), seek) t -> 'a
+    with type 'a bin_prot := 'a Bin_prot.Type_class.reader
 end
 
 (** [Fill.bin_prot X.bin_write_t t x] writes [x] to [t] in bin-prot form, advancing past
@@ -399,9 +399,9 @@ end
 module Fill : sig
   include
     Accessors_write
-      with type ('a, 'd, 'w) t = (read_write, seek) t -> 'a -> unit
-      with type ('a, 'd, 'w) t_local = (read_write, seek) t -> 'a -> unit
-      with type 'a bin_prot := 'a Bin_prot.Type_class.writer
+    with type ('a, 'd, 'w) t = (read_write, seek) t -> 'a -> unit
+    with type ('a, 'd, 'w) t_local = (read_write, seek) t -> 'a -> unit
+    with type 'a bin_prot := 'a Bin_prot.Type_class.writer
 
   (** [decimal t int] is equivalent to [Iobuf.Fill.string t (Int.to_string int)], but with
       improved efficiency and no intermediate allocation.
@@ -421,6 +421,13 @@ module Fill : sig
       to [t]. [t] is advanced by 10 characters and no terminator is added. If sufficient
       space is not available, [date] will raise. *)
   val date_string_iso8601_extended : (Date.t, _, _) t
+
+  (** [bin_prot_local sizer writer bin] is similar to [bin_prot], but allows [bin] to be
+      locally allocated. *)
+  val bin_prot_local
+    :  'a Bin_prot.Size.sizer_local
+    -> 'a Bin_prot.Write.writer_local
+    -> ('a, _, _) t_local
 end
 
 (** [Peek] and [Poke] functions access a value at [pos] from the lower bound of the window
@@ -440,6 +447,13 @@ module Peek : sig
       @param pos default = 0
       @param len default = [length t - pos] *)
   val index : ([> read ], _) iobuf -> ?pos:int -> ?len:int -> char -> int option
+
+  (** [rindex ?pos ?len t c] returns [Some i] for the largest [i >= pos] such that [char t
+      i = c], or [None] if there is no such [i].
+
+      @param pos default = 0
+      @param len default = [length t - pos] *)
+  val rindex : ([> read ], _) iobuf -> ?pos:int -> ?len:int -> char -> int option
 end
 
 (** [Poke.bin_prot X.bin_write_t t x] writes [x] to the beginning of [t] in binary form
@@ -463,9 +477,9 @@ module Poke : sig
 
   include
     Accessors_write
-      with type ('a, 'd, 'w) t = (read_write, 'w) t -> pos:int -> 'a -> unit
-      with type ('a, 'd, 'w) t_local = (read_write, 'w) t -> pos:int -> 'a -> unit
-      with type 'a bin_prot := 'a Bin_prot.Type_class.writer
+    with type ('a, 'd, 'w) t = (read_write, 'w) t -> pos:int -> 'a -> unit
+    with type ('a, 'd, 'w) t_local = (read_write, 'w) t -> pos:int -> 'a -> unit
+    with type 'a bin_prot := 'a Bin_prot.Type_class.writer
 
   (** Same as [Fill.date_string_iso8601_extended t date], but does not advance [t]. *)
   val date_string_iso8601_extended : (Date.t, _, _) t
@@ -483,6 +497,10 @@ module Unsafe : sig
     (** Like [Peek.index] but with no bounds checks, and returns a negative number rather
         than [None] when the character is not found. *)
     val index_or_neg : ([> read ], _) iobuf -> pos:int -> len:int -> char -> int
+
+    (** Like [Peek.rindex] but with no bounds checks, and returns a negative number rather
+        than [None] when the character is not found. *)
+    val rindex_or_neg : ([> read ], _) iobuf -> pos:int -> len:int -> char -> int
   end
 
   module Poke : sig
diff --git a/iobuf/src/iobuf_intf.ml b/iobuf/src/iobuf_intf.ml
index c162638b..48f5b750 100644
--- a/iobuf/src/iobuf_intf.ml
+++ b/iobuf/src/iobuf_intf.ml
@@ -206,7 +206,7 @@ module type Peek = sig
 
   include
     Accessors_read
-      with type ('a, 'd, 'w) t = ('d, 'w) iobuf -> pos:int -> 'a
-      with type ('a, 'd, 'w) t_local = ('d, 'w) iobuf -> pos:int -> 'a
-      with type 'a bin_prot := 'a Bin_prot.Type_class.reader
+    with type ('a, 'd, 'w) t = ('d, 'w) iobuf -> pos:int -> 'a
+    with type ('a, 'd, 'w) t_local = ('d, 'w) iobuf -> pos:int -> 'a
+    with type 'a bin_prot := 'a Bin_prot.Type_class.reader
 end
diff --git a/iobuf/test/dune b/iobuf/test/dune
index 9e2c9d13..0918a1bb 100644
--- a/iobuf/test/dune
+++ b/iobuf/test/dune
@@ -1,5 +1,6 @@
 (library
  (name iobuf_test)
- (libraries expect_test_helpers_core iobuf int_repr)
+ (libraries expect_test_helpers_core iobuf core
+   expect_test_helpers_core.expect_test_helpers_base int_repr)
  (preprocess
   (pps ppx_jane)))
diff --git a/iobuf/test/test_iobuf.ml b/iobuf/test/test_iobuf.ml
index 3553c274..591b3672 100644
--- a/iobuf/test/test_iobuf.ml
+++ b/iobuf/test/test_iobuf.ml
@@ -276,13 +276,13 @@ module IR_Int64 = struct
 end
 
 module Accessors (Accessors : sig
-  module Consume : module type of Consume
-  module Fill : module type of Fill
-  module Peek : module type of Peek
-  module Poke : module type of Poke
+    module Consume : module type of Consume
+    module Fill : module type of Fill
+    module Peek : module type of Peek
+    module Poke : module type of Poke
 
-  val is_safe : bool
-end) =
+    val is_safe : bool
+  end) =
 struct
   open Accessors
 
@@ -805,7 +805,7 @@ struct
   let%expect_test "fill_bin_prot_local doesn't allocate" =
     let t = create ~len:2000 in
     let a : Example_bin_prot.t = D { a = 1; b = 2 } in
-    require_no_allocation [%here] (fun () ->
+    require_no_allocation (fun () ->
       fill_bin_prot_local
         t
         Example_bin_prot.bin_size_t__local
@@ -824,23 +824,23 @@ struct
   end
 
   module Intf_common (Intf : sig
-    include Iobuf.Accessors_common
-
-    val accessor_pos_1
-      :  without_value:(read_write, seek) Iobuf.t
-      -> value_len:int
-      -> ('a, read_write, seek) t
-      -> value:'a
-      -> with_value:string
-      -> (module Accessee with type t = 'a)
-      -> unit
-
-    val bin_prot_char : (char, 'd, 'w) t
-  end) :
+      include Iobuf.Accessors_common
+
+      val accessor_pos_1
+        :  without_value:(read_write, seek) Iobuf.t
+        -> value_len:int
+        -> ('a, read_write, seek) t
+        -> value:'a
+        -> with_value:string
+        -> (module Accessee with type t = 'a)
+        -> unit
+
+      val bin_prot_char : (char, 'd, 'w) t
+    end) :
     Iobuf.Accessors_common
-      with type ('a, 'b, 'c) t = ('a, 'b, 'c) Intf.t
-      with type ('a, 'b, 'c) t_local = ('a, 'b, 'c) Intf.t_local
-       and type 'a bin_prot = 'a Intf.bin_prot = struct
+    with type ('a, 'b, 'c) t = ('a, 'b, 'c) Intf.t
+    with type ('a, 'b, 'c) t_local = ('a, 'b, 'c) Intf.t_local
+     and type 'a bin_prot = 'a Intf.bin_prot = struct
     open Intf
 
     type nonrec ('a, 'd, 'w) t = ('a, 'd, 'w) Intf.t
@@ -872,23 +872,23 @@ struct
   end
 
   module Intf_read (Intf : sig
-    include Iobuf.Accessors_read with type 'a bin_prot := 'a Bin_prot.Type_class.reader
-
-    val accessor_pos_1
-      :  without_value:(read_write, seek) Iobuf.t
-      -> value_len:int
-      -> ('a, read_write, seek) t
-      -> value:'a
-      -> with_value:string
-      -> (module Accessee with type t = 'a)
-      -> unit
-
-    val bin_prot_char : (char, 'd, 'w) t
-  end) :
+      include Iobuf.Accessors_read with type 'a bin_prot := 'a Bin_prot.Type_class.reader
+
+      val accessor_pos_1
+        :  without_value:(read_write, seek) Iobuf.t
+        -> value_len:int
+        -> ('a, read_write, seek) t
+        -> value:'a
+        -> with_value:string
+        -> (module Accessee with type t = 'a)
+        -> unit
+
+      val bin_prot_char : (char, 'd, 'w) t
+    end) :
     Iobuf.Accessors_read
-      with type ('a, 'b, 'c) t = ('a, 'b, 'c) Intf.t
-       and type ('a, 'b, 'c) t_local = ('a, 'b, 'c) Intf.t_local
-       and type 'a bin_prot := 'a Bin_prot.Type_class.reader = struct
+    with type ('a, 'b, 'c) t = ('a, 'b, 'c) Intf.t
+     and type ('a, 'b, 'c) t_local = ('a, 'b, 'c) Intf.t_local
+     and type 'a bin_prot := 'a Bin_prot.Type_class.reader = struct
     open Intf
 
     let int8 = int8
@@ -1014,7 +1014,7 @@ struct
     module type String_accessee = sig
       include Accessee
 
-      val subo : (t, t) Base.Blit.subo
+      val subo : (t, t) Base.Blit.subo_global
     end
 
     module Bigstringable : String_accessee with type t = bigstring = struct
@@ -1099,10 +1099,10 @@ struct
     ;;
 
     include Intf_common (struct
-      include Intf
+        include Intf
 
-      type 'a bin_prot = 'a Bin_prot.Type_class.reader
-    end)
+        type 'a bin_prot = 'a Bin_prot.Type_class.reader
+      end)
 
     module Int_repr = Intf.Int_repr
 
@@ -1269,24 +1269,24 @@ struct
   end
 
   module Intf_write (Intf : sig
-    include Iobuf.Accessors_write with type 'a bin_prot := 'a Bin_prot.Type_class.writer
-
-    val accessor_pos_1
-      :  without_value:(read_write, seek) Iobuf.t
-      -> value_len:int
-      -> ('a, read_write, seek) t
-      -> value:'a
-      -> with_value:string
-      -> (module Accessee with type t = 'a)
-      -> unit
-
-    val bin_prot_char : (char, 'd, 'w) t
-    val ignore_locality : ('a, 'd, 'w) t_local -> ('a, 'd, 'w) t
-  end) :
+      include Iobuf.Accessors_write with type 'a bin_prot := 'a Bin_prot.Type_class.writer
+
+      val accessor_pos_1
+        :  without_value:(read_write, seek) Iobuf.t
+        -> value_len:int
+        -> ('a, read_write, seek) t
+        -> value:'a
+        -> with_value:string
+        -> (module Accessee with type t = 'a)
+        -> unit
+
+      val bin_prot_char : (char, 'd, 'w) t
+      val ignore_locality : ('a, 'd, 'w) t_local -> ('a, 'd, 'w) t
+    end) :
     Iobuf.Accessors_write
-      with type ('a, 'b, 'c) t = ('a, 'b, 'c) Intf.t
-       and type ('a, 'b, 'c) t_local = ('a, 'b, 'c) Intf.t_local
-       and type 'a bin_prot := 'a Bin_prot.Type_class.writer = struct
+    with type ('a, 'b, 'c) t = ('a, 'b, 'c) Intf.t
+     and type ('a, 'b, 'c) t_local = ('a, 'b, 'c) Intf.t_local
+     and type 'a bin_prot := 'a Bin_prot.Type_class.writer = struct
     open Intf
 
     let int8_trunc = int8_trunc
@@ -1377,7 +1377,7 @@ struct
     module type String_accessee = sig
       include Accessee
 
-      val subo : (t, t) Base.Blit.subo
+      val subo : (t, t) Base.Blit.subo_global
     end
 
     module Bigstringable : String_accessee with type t = bigstring = struct
@@ -1462,10 +1462,10 @@ struct
     ;;
 
     include Intf_common (struct
-      include Intf
+        include Intf
 
-      type 'a bin_prot = 'a Bin_prot.Type_class.writer
-    end)
+        type 'a bin_prot = 'a Bin_prot.Type_class.writer
+      end)
 
     module Int_repr = Intf.Int_repr
 
@@ -1653,38 +1653,41 @@ struct
 
   module Poke = struct
     include Intf_write (struct
-      include Poke
-
-      let accessor_pos_1
-        (type a)
-        ~without_value:buf
-        ~value_len:_
-        f
-        ~value:arg
-        ~with_value:str
-        (module Arg : Accessee with type t = a)
-        =
-        f buf ~pos:1 arg;
-        let buf_str = to_string buf in
-        if String.( <> ) str buf_str
-        then
-          raise_s
-            [%message
-              "Poke accessor_pos_1 failed" (str : string) (buf_str : string) (arg : Arg.t)]
-      ;;
+        include Poke
 
-      let bin_prot_char t ~pos a = bin_prot Char.bin_writer_t t ~pos a
-      let ignore_locality (f : ('a, 'd, 'w) t_local) = (f :> ('a, 'd, 'w) t)
+        let accessor_pos_1
+          (type a)
+          ~without_value:buf
+          ~value_len:_
+          f
+          ~value:arg
+          ~with_value:str
+          (module Arg : Accessee with type t = a)
+          =
+          f buf ~pos:1 arg;
+          let buf_str = to_string buf in
+          if String.( <> ) str buf_str
+          then
+            raise_s
+              [%message
+                "Poke accessor_pos_1 failed"
+                  (str : string)
+                  (buf_str : string)
+                  (arg : Arg.t)]
+        ;;
 
-      (* Static permission tests for the cases that do compile.  Since the functions
+        let bin_prot_char t ~pos a = bin_prot Char.bin_writer_t t ~pos a
+        let ignore_locality (f : ('a, 'd, 'w) t_local) = (f :> ('a, 'd, 'w) t)
+
+        (* Static permission tests for the cases that do compile.  Since the functions
            all use essentially the same type definitions, we don't need to test all of
            them.  We've already tested them on a (read_write, seek) Iobuf.t above. *)
-      let%test_unit _ =
-        char (of_string "a" : (_, no_seek) Iobuf.t) ~pos:0 'b';
-        char (of_string "a" : (_, seek) Iobuf.t) ~pos:0 'b';
-        char (of_string "a" : (read_write, _) Iobuf.t) ~pos:0 'b'
-      ;;
-    end)
+        let%test_unit _ =
+          char (of_string "a" : (_, no_seek) Iobuf.t) ~pos:0 'b';
+          char (of_string "a" : (_, seek) Iobuf.t) ~pos:0 'b';
+          char (of_string "a" : (read_write, _) Iobuf.t) ~pos:0 'b'
+        ;;
+      end)
 
     let decimal = Poke.decimal
 
@@ -1819,36 +1822,40 @@ struct
 
   module Peek = struct
     include Intf_read (struct
-      include Peek
-
-      let accessor_pos_1
-        (type a)
-        ~without_value:_
-        ~value_len:_
-        f
-        ~value:expected
-        ~with_value:str
-        (module Res : Accessee with type t = a)
-        =
-        let res = f (of_string str) ~pos:1 in
-        if not (Res.equal res expected)
-        then
-          raise_s
-            [%message
-              "Peek accessor_pos_1 failed" (res : Res.t) (expected : Res.t) (str : string)]
-      ;;
+        include Peek
+
+        let accessor_pos_1
+          (type a)
+          ~without_value:_
+          ~value_len:_
+          f
+          ~value:expected
+          ~with_value:str
+          (module Res : Accessee with type t = a)
+          =
+          let res = f (of_string str) ~pos:1 in
+          if not (Res.equal res expected)
+          then
+            raise_s
+              [%message
+                "Peek accessor_pos_1 failed"
+                  (res : Res.t)
+                  (expected : Res.t)
+                  (str : string)]
+        ;;
 
-      let bin_prot_char t ~pos = bin_prot Char.bin_reader_t t ~pos
+        let bin_prot_char t ~pos = bin_prot Char.bin_reader_t t ~pos
 
-      (* static permission tests; see above *)
-      let char_a_pos_0 iobuf = Char.( = ) 'a' (char iobuf ~pos:0)
-      let%test _ = char_a_pos_0 (of_string "a" : (_, no_seek) Iobuf.t)
-      let%test _ = char_a_pos_0 (of_string "a" : (_, seek) Iobuf.t)
-      let%test _ = char_a_pos_0 (of_string "a" : (read, _) Iobuf.t)
-      let%test _ = char_a_pos_0 (of_string "a" : (read_write, _) Iobuf.t)
-    end)
+        (* static permission tests; see above *)
+        let char_a_pos_0 iobuf = Char.( = ) 'a' (char iobuf ~pos:0)
+        let%test _ = char_a_pos_0 (of_string "a" : (_, no_seek) Iobuf.t)
+        let%test _ = char_a_pos_0 (of_string "a" : (_, seek) Iobuf.t)
+        let%test _ = char_a_pos_0 (of_string "a" : (read, _) Iobuf.t)
+        let%test _ = char_a_pos_0 (of_string "a" : (read_write, _) Iobuf.t)
+      end)
 
     let index = Peek.index
+    let rindex = Peek.rindex
 
     module _ = struct
       open Peek.To_bytes
@@ -1881,44 +1888,80 @@ struct
       assert (is_error (try_with (fun () -> Poke.char t ~pos:(String.length s) 'z'))))
   ;;
 
-  let%expect_test "index" =
+  let%expect_test "index and rindex" =
     let s = "hello" in
     let t = of_string s in
     let test ?pos ?len char =
       let index = Peek.index t ?pos ?len char in
+      let rindex = Peek.rindex t ?pos ?len char in
       print_s
         [%message
           (pos : (int option[@sexp.option]))
             (len : (int option[@sexp.option]))
             (char : char)
-            (index : int option)];
-      match index with
-      | None -> require [%here] (not (String.mem (String.subo ?pos ?len s) char))
-      | Some pos -> require_equal [%here] (module Char) (Peek.char t ~pos) char
+            (index : int option)
+            (rindex : int option)];
+      let check i =
+        match i with
+        | None -> require (not (String.mem (String.subo ?pos ?len s) char))
+        | Some pos -> require_equal (module Char) (Peek.char t ~pos) char
+      in
+      check index;
+      check rindex
     in
     let require_error here f =
       (* Do this instead of [require_does_raise] because the latter prints out the exn.
          We need to have the same output in the safe and unsafe variants. *)
-      require_error here [%sexp_of: unit] (try_with f)
+      require_error ~here [%sexp_of: unit] (try_with f)
     in
     test 'h';
     test 'l';
+    test 'l' ~pos:2;
     test 'l' ~pos:3;
+    test 'l' ~pos:4;
+    test 'l' ~len:3;
+    test 'l' ~len:4;
     test 'o';
     test 'o' ~len:3;
     test 'z';
     [%expect
       {|
-      ((char h) (index (0)))
-      ((char l) (index (2)))
+      ((char h)
+       (index  (0))
+       (rindex (0)))
+      ((char l)
+       (index  (2))
+       (rindex (3)))
+      ((pos  2)
+       (char l)
+       (index  (2))
+       (rindex (3)))
       ((pos  3)
        (char l)
-       (index (3)))
-      ((char o) (index (4)))
+       (index  (3))
+       (rindex (3)))
+      ((pos  4)
+       (char l)
+       (index  ())
+       (rindex ()))
+      ((len  3)
+       (char l)
+       (index  (2))
+       (rindex (2)))
+      ((len  4)
+       (char l)
+       (index  (2))
+       (rindex (3)))
+      ((char o)
+       (index  (4))
+       (rindex (4)))
       ((len  3)
        (char o)
-       (index ()))
-      ((char z) (index ()))
+       (index  ())
+       (rindex ()))
+      ((char z)
+       (index  ())
+       (rindex ()))
       |}];
     if is_safe
     then (
@@ -1953,72 +1996,72 @@ struct
 
   module Fill = struct
     include Intf_write (struct
-      include Fill
-
-      let accessor_pos_1
-        (type a)
-        ~without_value:buf
-        ~value_len:n
-        f
-        ~value:arg
-        ~with_value:str
-        (module Arg : Accessee with type t = a)
-        =
-        rewind buf;
-        advance buf 1;
-        f buf arg;
-        if Iobuf.length buf <> String.length str - 1 - n
-        then
-          raise_s
-            [%message
-              "Fill accessor_pos_1 post length check failed"
-                (buf : (_, _) Iobuf.Hexdump.t)
-                (str : string)
-                (n : int)
-                (arg : Arg.t)];
-        rewind buf;
-        let buf_str = to_string buf in
-        if String.( <> ) buf_str str
-        then
-          raise_s
-            [%message
-              "Fill accessor_pos_1 post rewind check failed"
-                (buf_str : string)
-                (str : string)
-                (n : int)
-                (arg : Arg.t)]
-      ;;
+        include Fill
 
-      let bin_prot_char t a = bin_prot Char.bin_writer_t t a
-      let ignore_locality (f : ('a, 'd, 'w) t_local) = (f :> ('a, 'd, 'w) t)
+        let accessor_pos_1
+          (type a)
+          ~without_value:buf
+          ~value_len:n
+          f
+          ~value:arg
+          ~with_value:str
+          (module Arg : Accessee with type t = a)
+          =
+          rewind buf;
+          advance buf 1;
+          f buf arg;
+          if Iobuf.length buf <> String.length str - 1 - n
+          then
+            raise_s
+              [%message
+                "Fill accessor_pos_1 post length check failed"
+                  (buf : (_, _) Iobuf.Hexdump.t)
+                  (str : string)
+                  (n : int)
+                  (arg : Arg.t)];
+          rewind buf;
+          let buf_str = to_string buf in
+          if String.( <> ) buf_str str
+          then
+            raise_s
+              [%message
+                "Fill accessor_pos_1 post rewind check failed"
+                  (buf_str : string)
+                  (str : string)
+                  (n : int)
+                  (arg : Arg.t)]
+        ;;
 
-      let%test_unit _ =
-        let t = of_string "abc" in
-        bin_prot Char.bin_writer_t t 'd';
-        bin_prot Char.bin_writer_t t 'e';
-        [%test_eq: string] "c" (to_string t);
-        flip_lo t;
-        assert (
-          try
-            bin_prot String.bin_writer_t t "fgh";
-            false
-          with
-          | _ -> true);
-        [%test_eq: string] "de" (to_string t);
-        reset t;
-        [%test_eq: string] "dec" (to_string t);
-        bin_prot Char.bin_writer_t t 'i';
-        bin_prot Char.bin_writer_t t 'j';
-        bin_prot Char.bin_writer_t t 'k';
-        assert (is_empty t);
-        flip_lo t;
-        [%test_eq: string] "ijk" (to_string t)
-      ;;
+        let bin_prot_char t a = bin_prot Char.bin_writer_t t a
+        let ignore_locality (f : ('a, 'd, 'w) t_local) = (f :> ('a, 'd, 'w) t)
+
+        let%test_unit _ =
+          let t = of_string "abc" in
+          bin_prot Char.bin_writer_t t 'd';
+          bin_prot Char.bin_writer_t t 'e';
+          [%test_eq: string] "c" (to_string t);
+          flip_lo t;
+          assert (
+            try
+              bin_prot String.bin_writer_t t "fgh";
+              false
+            with
+            | _ -> true);
+          [%test_eq: string] "de" (to_string t);
+          reset t;
+          [%test_eq: string] "dec" (to_string t);
+          bin_prot Char.bin_writer_t t 'i';
+          bin_prot Char.bin_writer_t t 'j';
+          bin_prot Char.bin_writer_t t 'k';
+          assert (is_empty t);
+          flip_lo t;
+          [%test_eq: string] "ijk" (to_string t)
+        ;;
 
-      (* static permission tests; see above *)
-      let%test_unit _ = char (of_string "a" : (_, seek) Iobuf.t) 'b'
-      let%test_unit _ = char (of_string "a" : (read_write, _) Iobuf.t) 'b'
-    end)
+        (* static permission tests; see above *)
+        let%test_unit _ = char (of_string "a" : (_, seek) Iobuf.t) 'b'
+        let%test_unit _ = char (of_string "a" : (read_write, _) Iobuf.t) 'b'
+      end)
 
     let decimal = Fill.decimal
 
@@ -2153,48 +2196,48 @@ struct
 
   module Consume = struct
     include Intf_read (struct
-      include Consume
-
-      let accessor_pos_1
-        (type r)
-        ~without_value:_
-        ~value_len:n
-        f
-        ~value:expected
-        ~with_value:str
-        (module Res : Accessee with type t = r)
-        =
-        let buf = of_string str in
-        advance buf 1;
-        let res = f buf in
-        if Iobuf.length buf <> String.length str - 1 - n
-        then
-          raise_s
-            [%message
-              "Consume accessor_pos_1 post length check failed"
-                (buf : (_, _) Iobuf.Hexdump.t)
-                (str : string)
-                (n : int)
-                (res : Res.t)];
-        rewind buf;
-        if not (Res.equal res expected)
-        then
-          raise_s
-            [%message
-              "Consume accessor_pos_1 post rewind check failed"
-                (res : Res.t)
-                (expected : Res.t)
-                (str : string)
-                (n : int)]
-      ;;
+        include Consume
 
-      let bin_prot_char t = bin_prot Char.bin_reader_t t
+        let accessor_pos_1
+          (type r)
+          ~without_value:_
+          ~value_len:n
+          f
+          ~value:expected
+          ~with_value:str
+          (module Res : Accessee with type t = r)
+          =
+          let buf = of_string str in
+          advance buf 1;
+          let res = f buf in
+          if Iobuf.length buf <> String.length str - 1 - n
+          then
+            raise_s
+              [%message
+                "Consume accessor_pos_1 post length check failed"
+                  (buf : (_, _) Iobuf.Hexdump.t)
+                  (str : string)
+                  (n : int)
+                  (res : Res.t)];
+          rewind buf;
+          if not (Res.equal res expected)
+          then
+            raise_s
+              [%message
+                "Consume accessor_pos_1 post rewind check failed"
+                  (res : Res.t)
+                  (expected : Res.t)
+                  (str : string)
+                  (n : int)]
+        ;;
 
-      (* static permission tests; see above *)
-      let%test _ = Char.( = ) 'a' (char (of_string "a" : (_, seek) Iobuf.t))
-      let%test _ = Char.( = ) 'a' (char (of_string "a" : (read, _) Iobuf.t))
-      let%test _ = Char.( = ) 'a' (char (of_string "a" : (read_write, _) Iobuf.t))
-    end)
+        let bin_prot_char t = bin_prot Char.bin_reader_t t
+
+        (* static permission tests; see above *)
+        let%test _ = Char.( = ) 'a' (char (of_string "a" : (_, seek) Iobuf.t))
+        let%test _ = Char.( = ) 'a' (char (of_string "a" : (read, _) Iobuf.t))
+        let%test _ = Char.( = ) 'a' (char (of_string "a" : (read_write, _) Iobuf.t))
+      end)
 
     open Consume
 
@@ -2410,16 +2453,16 @@ struct
     let%expect_test "blit_maximal" =
       let long = of_string (String.make 10 '.') in
       let short = of_string "ABCD" in
-      require_equal [%here] (module Int) 4 (blit_maximal ~src:short ~dst:long);
-      require_equal [%here] (module Int) 0 (blit_maximal ~src:short ~dst:long);
+      require_equal (module Int) 4 (blit_maximal ~src:short ~dst:long);
+      require_equal (module Int) 0 (blit_maximal ~src:short ~dst:long);
       Iobuf.reset short;
       print_s [%sexp (long : (_, _) Iobuf.Limits.Hexdump.Pretty.t)];
       [%expect {| ABCD...... |}];
-      require_equal [%here] (module Int) 4 (blit_maximal ~src:short ~dst:long);
+      require_equal (module Int) 4 (blit_maximal ~src:short ~dst:long);
       Iobuf.reset short;
       print_s [%sexp (long : (_, _) Iobuf.Limits.Hexdump.Pretty.t)];
       [%expect {| ABCDABCD.. |}];
-      require_equal [%here] (module Int) 2 (blit_maximal ~src:short ~dst:long);
+      require_equal (module Int) 2 (blit_maximal ~src:short ~dst:long);
       print_s [%sexp (long : (_, _) Iobuf.Limits.Hexdump.Pretty.t)];
       [%expect {| ABCDABCDAB |}]
     ;;
@@ -2468,7 +2511,7 @@ struct
       let long = of_string (String.make 10 '.') in
       let short = of_string "ABCD" in
       let t here expected actual =
-        require_equal here (module Int) expected actual;
+        require_equal ~here (module Int) expected actual;
         print_s [%sexp (long : (_, _) Iobuf.Limits.Hexdump.Pretty.t)]
       in
       t [%here] 4 (blit_maximal ~src:short ~dst:long ());
@@ -2550,24 +2593,27 @@ struct
       let long = of_string "ABCDEFGHIJ" in
       let short = of_string "...." in
       let t here expected actual =
-        require_equal here (module Int) expected actual;
+        require_equal ~here (module Int) expected actual;
         print_s
           [%message
             (long : (_, _) Iobuf.Window.Hexdump.Pretty.t)
               (short : (_, _) Iobuf.Window.Hexdump.Pretty.t)]
       in
       t [%here] 4 (blit_maximal ~src:long ~dst:short ());
-      [%expect {|
+      [%expect
+        {|
         ((long  EFGHIJ)
          (short ABCD))
         |}];
       t [%here] 3 (blit_maximal ~src:long ~dst_pos:1 ~dst:short ());
-      [%expect {|
+      [%expect
+        {|
         ((long  HIJ)
          (short AEFG))
         |}];
       t [%here] 3 (blit_maximal ~src:long ~dst:short ());
-      [%expect {|
+      [%expect
+        {|
         ((long  "")
          (short HIJG))
         |}]
@@ -2650,24 +2696,27 @@ struct
       let long = of_string (String.make 10 '.') in
       let short = of_string "ABCD" in
       let t here expected actual =
-        require_equal here (module Int) expected actual;
+        require_equal ~here (module Int) expected actual;
         print_s
           [%message
             (long : (_, _) Iobuf.Window.Hexdump.Pretty.t)
               (short : (_, _) Iobuf.Window.Hexdump.Pretty.t)]
       in
       t [%here] 4 (blit_maximal ~src:short ~dst:long ());
-      [%expect {|
+      [%expect
+        {|
         ((long  ABCD......)
          (short ABCD))
         |}];
       t [%here] 3 (blit_maximal ~src:short ~dst_pos:7 ~dst:long ());
-      [%expect {|
+      [%expect
+        {|
         ((long  ABCD...ABC)
          (short ABCD))
         |}];
       t [%here] 1 (blit_maximal ~src:short ~src_pos:3 ~dst:long ());
-      [%expect {|
+      [%expect
+        {|
         ((long  DBCD...ABC)
          (short ABCD))
         |}]
@@ -2864,29 +2913,35 @@ let%test_unit _ =
 ;;
 
 include Accessors (struct
-  module Consume = Consume
-  module Fill = Fill
-  module Peek = Peek
-  module Poke = Poke
+    module Consume = Consume
+    module Fill = Fill
+    module Peek = Peek
+    module Poke = Poke
 
-  let is_safe = true
-end)
+    let is_safe = true
+  end)
 
 module _ = Accessors (struct
-  include Unsafe
+    include Unsafe
 
-  module Peek = struct
-    include Peek
+    module Peek = struct
+      include Peek
 
-    let index t ?(pos = 0) ?(len = length t - pos) char =
-      match index_or_neg t ~pos ~len char with
-      | index when index < 0 -> None
-      | index -> Some index
-    ;;
-  end
+      let index t ?(pos = 0) ?(len = length t - pos) char =
+        match index_or_neg t ~pos ~len char with
+        | index when index < 0 -> None
+        | index -> Some index
+      ;;
 
-  let is_safe = false
-end)
+      let rindex t ?(pos = 0) ?(len = length t - pos) char =
+        match rindex_or_neg t ~pos ~len char with
+        | index when index < 0 -> None
+        | index -> Some index
+      ;;
+    end
+
+    let is_safe = false
+  end)
 
 let memcmp = memcmp
 let%test_unit _ = assert (memcmp (Iobuf.create ~len:0) (Iobuf.create ~len:0) = 0)
@@ -2909,7 +2964,7 @@ let%test_module "allocation" =
     let%expect_test "set_bounds_and_buffer_sub" =
       let src = Iobuf.of_string "123abcDEF" in
       let dst = Iobuf.create ~len:0 in
-      require_no_allocation [%here] (fun () ->
+      require_no_allocation (fun () ->
         Iobuf.set_bounds_and_buffer_sub ~src ~dst ~len:(Iobuf.length src) ~pos:0);
       [%expect {| |}]
     ;;
@@ -2921,16 +2976,16 @@ let%test_module "allocation" =
       let str_pos = Random.int (String.length str) in
       let len = Random.int (String.length str - str_pos) in
       let dst = Iobuf.create ~len in
-      require_no_allocation [%here] (fun () -> Iobuf.Fill.string dst str ~str_pos ~len);
+      require_no_allocation (fun () -> Iobuf.Fill.string dst str ~str_pos ~len);
       [%expect {| |}]
     ;;
 
     let%expect_test "of_bigstring_local" =
       let bigstring = Bigstring.of_string "abcdefghijklmnopqrstuvwxyz" in
-      require_no_allocation [%here] (fun () ->
+      require_no_allocation (fun () ->
         let buf = Iobuf.of_bigstring_local bigstring in
         ignore (Sys.opaque_identity buf : _ Iobuf.t));
-      require_no_allocation [%here] (fun () ->
+      require_no_allocation (fun () ->
         let buf = Iobuf.of_bigstring_local ~pos:1 ~len:10 bigstring in
         ignore (Sys.opaque_identity buf : _ Iobuf.t));
       [%expect {| |}]
@@ -2938,23 +2993,23 @@ let%test_module "allocation" =
 
     let%expect_test "sub_shared_local" =
       let buf = Iobuf.of_string "abcdefghijklmnopqrstuvwxyz" in
-      require_no_allocation [%here] (fun () ->
+      require_no_allocation (fun () ->
         let buf' = Iobuf.sub_shared_local buf in
         ignore (Sys.opaque_identity buf' : _ Iobuf.t));
-      require_no_allocation [%here] (fun () ->
+      require_no_allocation (fun () ->
         let buf' = Iobuf.sub_shared_local ~pos:1 ~len:5 buf in
         ignore (Sys.opaque_identity buf' : _ Iobuf.t));
       [%expect {| |}]
     ;;
 
     module Test_read_accessors
-      (I : Accessors_read with type 'a bin_prot := 'a Bin_prot.Type_class.reader)
-      (Apply : sig
-        type w
+        (I : Accessors_read with type 'a bin_prot := 'a Bin_prot.Type_class.reader)
+        (Apply : sig
+           type w
 
-        val apply : ('a, read, w) I.t -> (read, Iobuf.seek) Iobuf.t -> 'a
-        val apply_local : ('a, read, w) I.t_local -> (read, Iobuf.seek) Iobuf.t -> 'a
-      end) : Accessors_read with type 'a bin_prot := 'a Bin_prot.Type_class.reader =
+           val apply : ('a, read, w) I.t -> (read, Iobuf.seek) Iobuf.t -> 'a
+           val apply_local : ('a, read, w) I.t_local -> (read, Iobuf.seek) Iobuf.t -> 'a
+         end) : Accessors_read with type 'a bin_prot := 'a Bin_prot.Type_class.reader =
     struct
       open I
 
@@ -2963,15 +3018,13 @@ let%test_module "allocation" =
 
       let test ?(allocation_limit = 0) (f : ('a, 'd, 'w) t) len =
         let buf = Iobuf.of_bigstring (Bigstring.init len ~f:(const '\000')) in
-        require_allocation_does_not_exceed
-          (Minor_words allocation_limit)
-          [%here]
-          (fun () -> ignore (Apply.apply f buf : _))
+        require_allocation_does_not_exceed (Minor_words allocation_limit) (fun () ->
+          ignore (Apply.apply f buf : _))
       ;;
 
       let test_local (f : ('a, 'd, 'w) t_local) len =
         let buf = Iobuf.of_bigstring (Bigstring.init len ~f:(const '\000')) in
-        require_no_allocation [%here] (fun () -> ignore (Apply.apply_local f buf : _))
+        require_no_allocation (fun () -> ignore (Apply.apply_local f buf : _))
       ;;
 
       let test_padded_string (f : padding:char -> len:int -> ('a, 'd, 'w) t_local) =
@@ -2984,7 +3037,7 @@ let%test_module "allocation" =
                if pad_amt <= i && i < full_len - pad_amt then 'x' else padding))
         in
         let f = f ~padding ~len:full_len in
-        require_no_allocation [%here] (fun () -> ignore (Apply.apply_local f buf : _))
+        require_no_allocation (fun () -> ignore (Apply.apply_local f buf : _))
       ;;
 
       let test_string (f : str_pos:int -> len:int -> ('a, 'd, 'w) t_local) =
@@ -2995,7 +3048,7 @@ let%test_module "allocation" =
       let test_stringo (f : ?str_pos:int -> ?len:int -> ('a, 'd, 'w) t_local) =
         let len = 10 in
         let buf = Iobuf.of_bigstring (Bigstring.init len ~f:(const ' ')) in
-        require_no_allocation [%here] (fun () ->
+        require_no_allocation (fun () ->
           ignore (Apply.apply_local (f ~str_pos:0 ~len) buf : _))
       ;;
 
@@ -3391,7 +3444,7 @@ let%expect_test "check seek-indifferent r/w interfaces work on both kinds" =
   let t : (read_write, seek) Iobuf.t = Iobuf.create ~len:8 in
   let c = Iobuf.Peek.char t ~pos:0 in
   let c' = Iobuf.Peek.char (Iobuf.no_seek t) ~pos:0 in
-  require_equal [%here] (module Char) c c';
+  require_equal (module Char) c c';
   let src = Iobuf.create ~len:8 in
   Iobuf.Blit.blito ~dst:t ~src ();
   Iobuf.Blit.blito ~dst:(Iobuf.no_seek t) ~src ();
@@ -3417,7 +3470,7 @@ let%expect_test "transfer" =
   Iobuf.transfer ~src ~dst;
   let dump t = [%sexp (t : (_, _) Iobuf.Window.Hexdump.t)] in
   let src, dst = dump src, dump dst in
-  require_equal [%here] (module Sexp) src dst;
+  require_equal (module Sexp) src dst;
   print_s [%sexp (dst : Sexp.t)];
   [%expect
     {| ("00000000  68 6f 6c 79 20 67 75 61  63 61 6d 6f 6c 65 21     |holy guacamole!|") |}]
diff --git a/iobuf/test/test_iobuf_view.ml b/iobuf/test/test_iobuf_view.ml
index d0474ed8..6cb8fc66 100644
--- a/iobuf/test/test_iobuf_view.ml
+++ b/iobuf/test/test_iobuf_view.ml
@@ -29,347 +29,347 @@ end
 
 let%test_module "Window" =
   (module (
-             struct
-               open Iobuf.Window
-               include T
-
-               module Hexdump = struct
-                 open Hexdump
-                 include T
-
-                 let sexp_of_t = sexp_of_t
-
-                 let%expect_test "sexp_of_t" =
-                   print_s [%sexp (iobuf : (_, _) t)];
-                   [%expect
-                     {|
-           ("00000000  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
-            "00000010  6c 6c 61 62 69 63                                 |llabic|")
-           |}]
-                 ;;
-
-                 let to_string_hum = to_string_hum
-
-                 let%expect_test "to_string_hum" =
-                   print_endline (to_string_hum iobuf);
-                   [%expect
-                     {|
-           00000000  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|
-           00000010  6c 6c 61 62 69 63                                 |llabic|
-           |}]
-                 ;;
-
-                 let to_sequence = to_sequence
-
-                 let%expect_test "to_sequence" =
-                   print_s [%sexp (to_sequence iobuf |> Sequence.to_list : string list)];
-                   [%expect
-                     {|
-           ("00000000  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
-            "00000010  6c 6c 61 62 69 63                                 |llabic|")
-           |}]
-                 ;;
-
-                 module Pretty = struct
-                   include T
-
-                   let sexp_of_t = Pretty.sexp_of_t
-
-                   let%expect_test "sexp_of_t" =
-                     print_s [%sexp (iobuf : (_, _) t)];
-                     [%expect {| "`Boston' is disyllabic" |}]
-                   ;;
-                 end
-               end
-             end :
-               module type of Iobuf.Window))
+  struct
+    open Iobuf.Window
+    include T
+
+    module Hexdump = struct
+      open Hexdump
+      include T
+
+      let sexp_of_t = sexp_of_t
+
+      let%expect_test "sexp_of_t" =
+        print_s [%sexp (iobuf : (_, _) t)];
+        [%expect
+          {|
+          ("00000000  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
+           "00000010  6c 6c 61 62 69 63                                 |llabic|")
+          |}]
+      ;;
+
+      let to_string_hum = to_string_hum
+
+      let%expect_test "to_string_hum" =
+        print_endline (to_string_hum iobuf);
+        [%expect
+          {|
+          00000000  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|
+          00000010  6c 6c 61 62 69 63                                 |llabic|
+          |}]
+      ;;
+
+      let to_sequence = to_sequence
+
+      let%expect_test "to_sequence" =
+        print_s [%sexp (to_sequence iobuf |> Sequence.to_list : string list)];
+        [%expect
+          {|
+          ("00000000  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
+           "00000010  6c 6c 61 62 69 63                                 |llabic|")
+          |}]
+      ;;
+
+      module Pretty = struct
+        include T
+
+        let sexp_of_t = Pretty.sexp_of_t
+
+        let%expect_test "sexp_of_t" =
+          print_s [%sexp (iobuf : (_, _) t)];
+          [%expect {| "`Boston' is disyllabic" |}]
+        ;;
+      end
+    end
+  end :
+    module type of Iobuf.Window))
 ;;
 
 let%test_module "Limits" =
   (module (
-             struct
-               open Iobuf.Limits
-               include T
-
-               module Hexdump = struct
-                 open Hexdump
-                 include T
-
-                 let sexp_of_t = sexp_of_t
-
-                 let%expect_test "sexp_of_t" =
-                   print_s [%sexp (iobuf : (_, _) t)];
-                   [%expect
-                     {|
-           ("00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
-            "00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
-            "00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
-            "00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
-            "00000040  27 27 2e                                          |''.|")
-           |}]
-                 ;;
-
-                 let to_string_hum = to_string_hum
-
-                 let%expect_test "to_string_hum" =
-                   print_endline (to_string_hum iobuf);
-                   [%expect
-                     {|
-           00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|
-           00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|
-           00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|
-           00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|
-           00000040  27 27 2e                                          |''.|
-           |}]
-                 ;;
-
-                 let to_sequence = to_sequence
-
-                 let%expect_test "to_sequence" =
-                   print_s [%sexp (to_sequence iobuf |> Sequence.to_list : string list)];
-                   [%expect
-                     {|
-           ("00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
-            "00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
-            "00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
-            "00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
-            "00000040  27 27 2e                                          |''.|")
-           |}]
-                 ;;
-
-                 module Pretty = struct
-                   include T
-
-                   let sexp_of_t = Pretty.sexp_of_t
-
-                   let%expect_test "sexp_of_t" =
-                     print_s [%sexp (iobuf : (_, _) t)];
-                     [%expect
-                       {| "``Boston' is disyllabic' is about `Boston' and contains ``Boston''." |}]
-                   ;;
-                 end
-               end
-             end :
-               module type of Iobuf.Limits))
+  struct
+    open Iobuf.Limits
+    include T
+
+    module Hexdump = struct
+      open Hexdump
+      include T
+
+      let sexp_of_t = sexp_of_t
+
+      let%expect_test "sexp_of_t" =
+        print_s [%sexp (iobuf : (_, _) t)];
+        [%expect
+          {|
+          ("00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
+           "00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
+           "00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
+           "00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
+           "00000040  27 27 2e                                          |''.|")
+          |}]
+      ;;
+
+      let to_string_hum = to_string_hum
+
+      let%expect_test "to_string_hum" =
+        print_endline (to_string_hum iobuf);
+        [%expect
+          {|
+          00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|
+          00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|
+          00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|
+          00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|
+          00000040  27 27 2e                                          |''.|
+          |}]
+      ;;
+
+      let to_sequence = to_sequence
+
+      let%expect_test "to_sequence" =
+        print_s [%sexp (to_sequence iobuf |> Sequence.to_list : string list)];
+        [%expect
+          {|
+          ("00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
+           "00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
+           "00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
+           "00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
+           "00000040  27 27 2e                                          |''.|")
+          |}]
+      ;;
+
+      module Pretty = struct
+        include T
+
+        let sexp_of_t = Pretty.sexp_of_t
+
+        let%expect_test "sexp_of_t" =
+          print_s [%sexp (iobuf : (_, _) t)];
+          [%expect
+            {| "``Boston' is disyllabic' is about `Boston' and contains ``Boston''." |}]
+        ;;
+      end
+    end
+  end :
+    module type of Iobuf.Limits))
 ;;
 
 let%test_module "Hexdump" =
   (module (
-             struct
-               open Iobuf.Hexdump
-               include T
-
-               let sexp_of_t = sexp_of_t
-
-               let%expect_test "sexp_of_t" =
-                 print_s [%sexp (iobuf : (_, _) t)];
-                 [%expect
-                   {|
-         ((window (
-            "00000001  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
-            "00000011  6c 6c 61 62 69 63                                 |llabic|"))
-          (limits (
-            "00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
-            "00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
-            "00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
-            "00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
-            "00000040  27 27 2e                                          |''.|")))
-         |}]
-               ;;
-
-               let to_sequence = to_sequence
-
-               let%expect_test "to_sequence" =
-                 print_s [%sexp (Sequence.to_list (to_sequence iobuf) : string list)];
-                 [%expect
-                   {|
-         (Window
-          "  00000001  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
-          "  00000011  6c 6c 61 62 69 63                                 |llabic|"
-          Limits
-          "  00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
-          "  00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
-          "  00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
-          "  00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
-          "  00000040  27 27 2e                                          |''.|")
-         |}]
-               ;;
-
-               let to_string_hum = to_string_hum
-
-               let%expect_test "to_string_hum" =
-                 print_endline (to_string_hum iobuf);
-                 [%expect
-                   {|
-         Window
-           00000001  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|
-           00000011  6c 6c 61 62 69 63                                 |llabic|
+  struct
+    open Iobuf.Hexdump
+    include T
+
+    let sexp_of_t = sexp_of_t
+
+    let%expect_test "sexp_of_t" =
+      print_s [%sexp (iobuf : (_, _) t)];
+      [%expect
+        {|
+        ((window (
+           "00000001  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
+           "00000011  6c 6c 61 62 69 63                                 |llabic|"))
+         (limits (
+           "00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
+           "00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
+           "00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
+           "00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
+           "00000040  27 27 2e                                          |''.|")))
+        |}]
+    ;;
+
+    let to_sequence = to_sequence
+
+    let%expect_test "to_sequence" =
+      print_s [%sexp (Sequence.to_list (to_sequence iobuf) : string list)];
+      [%expect
+        {|
+        (Window
+         "  00000001  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
+         "  00000011  6c 6c 61 62 69 63                                 |llabic|"
          Limits
-           00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|
-           00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|
-           00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|
-           00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|
-           00000040  27 27 2e                                          |''.|
-         |}]
-               ;;
-             end :
-               module type of Iobuf.Hexdump))
+         "  00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
+         "  00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
+         "  00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
+         "  00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
+         "  00000040  27 27 2e                                          |''.|")
+        |}]
+    ;;
+
+    let to_string_hum = to_string_hum
+
+    let%expect_test "to_string_hum" =
+      print_endline (to_string_hum iobuf);
+      [%expect
+        {|
+        Window
+          00000001  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|
+          00000011  6c 6c 61 62 69 63                                 |llabic|
+        Limits
+          00000000  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|
+          00000010  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|
+          00000020  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|
+          00000030  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|
+          00000040  27 27 2e                                          |''.|
+        |}]
+    ;;
+  end :
+    module type of Iobuf.Hexdump))
 ;;
 
 let%test_module "Debug" =
   (module (
-             struct
-               open Iobuf.Debug
-               include T
-
-               module Hexdump = struct
-                 open Hexdump
-                 include T
-
-                 let sexp_of_t = sexp_of_t
-
-                 let%expect_test "sexp_of_t" =
-                   print_s [%sexp (iobuf : (_, _) t)];
-                   [%expect
-                     {|
-           ((window (
-              "0000003d  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
-              "0000004d  6c 6c 61 62 69 63                                 |llabic|"))
-            (limits (
-              "0000003c  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
-              "0000004c  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
-              "0000005c  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
-              "0000006c  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
-              "0000007c  27 27 2e                                          |''.|"))
-            (buffer (
-              "00000000  60 42 6f 73 74 6f 6e 20  69 73 20 70 6f 70 75 6c  |`Boston is popul|"
-              "00000010  6f 75 73 27 20 69 73 20  61 62 6f 75 74 20 42 6f  |ous' is about Bo|"
-              "00000020  73 74 6f 6e 20 61 6e 64  20 63 6f 6e 74 61 69 6e  |ston and contain|"
-              "00000030  73 20 60 42 6f 73 74 6f  6e 27 3b 20 60 60 42 6f  |s `Boston'; ``Bo|"
-              "00000040  73 74 6f 6e 27 20 69 73  20 64 69 73 79 6c 6c 61  |ston' is disylla|"
-              "00000050  62 69 63 27 20 69 73 20  61 62 6f 75 74 20 60 42  |bic' is about `B|"
-              "00000060  6f 73 74 6f 6e 27 20 61  6e 64 20 63 6f 6e 74 61  |oston' and conta|"
-              "00000070  69 6e 73 20 60 60 42 6f  73 74 6f 6e 27 27 2e 20  |ins ``Boston''. |"
-              "00000080  20 60 60 42 6f 73 74 6f  6e 27 27 20 64 65 73 69  | ``Boston'' desi|"
-              "00000090  67 6e 61 74 65 73 20 60  42 6f 73 74 6f 6e 27 2c  |gnates `Boston',|"
-              "000000a0  20 77 68 69 63 68 20 69  6e 20 74 75 72 6e 20 64  | which in turn d|"
-              "000000b0  65 73 69 67 6e 61 74 65  73 20 42 6f 73 74 6f 6e  |esignates Boston|"
-              "000000c0  2e 20 20 54 6f 20 6d 65  6e 74 69 6f 6e 20 42 6f  |.  To mention Bo|"
-              "000000d0  73 74 6f 6e 20 77 65 20  75 73 65 20 60 42 6f 73  |ston we use `Bos|"
-              "000000e0  74 6f 6e 27 20 6f 72 20  61 20 73 79 6e 6f 6e 79  |ton' or a synony|"
-              "000000f0  6d 2c 20 61 6e 64 20 74  6f 20 6d 65 6e 74 69 6f  |m, and to mentio|"
-              "00000100  6e 20 60 42 6f 73 74 6f  6e 27 20 77 65 20 75 73  |n `Boston' we us|"
-              "00000110  65 20 60 60 42 6f 73 74  6f 6e 27 27 20 6f 72 20  |e ``Boston'' or |"
-              "00000120  61 20 73 79 6e 6f 6e 79  6d 2e 20 20 60 60 42 6f  |a synonym.  ``Bo|"
-              "00000130  73 74 6f 6e 27 27 20 63  6f 6e 74 61 69 6e 73 20  |ston'' contains |"
-              "00000140  73 69 78 20 6c 65 74 74  65 72 73 20 61 6e 64 20  |six letters and |"
-              "00000150  6a 75 73 74 20 6f 6e 65  20 70 61 69 72 20 6f 66  |just one pair of|"
-              "00000160  20 71 75 6f 74 61 74 69  6f 6e 20 6d 61 72 6b 73  | quotation marks|"
-              "00000170  3b 20 60 42 6f 73 74 6f  6e 27 20 63 6f 6e 74 61  |; `Boston' conta|"
-              "00000180  69 6e 73 20 73 69 78 20  6c 65 74 74 65 72 73 20  |ins six letters |"
-              "00000190  61 6e 64 20 6e 6f 20 71  75 6f 74 61 74 69 6f 6e  |and no quotation|"
-              "000001a0  20 6d 61 72 6b 73 3b 20  61 6e 64 20 42 6f 73 74  | marks; and Bost|"
-              "000001b0  6f 6e 20 63 6f 6e 74 61  69 6e 73 20 73 6f 6d 65  |on contains some|"
-              "000001c0  20 38 30 30 2c 30 30 30  20 70 65 6f 70 6c 65 2e  | 800,000 people.|")))
-           |}]
-                 ;;
-
-                 let to_sequence = to_sequence
-
-                 let%expect_test "to_sequence" =
-                   print_s [%sexp (Sequence.to_list (to_sequence iobuf) : string list)];
-                   [%expect
-                     {|
-           (Window
-            "  0000003d  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
-            "  0000004d  6c 6c 61 62 69 63                                 |llabic|"
-            Limits
-            "  0000003c  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
-            "  0000004c  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
-            "  0000005c  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
-            "  0000006c  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
-            "  0000007c  27 27 2e                                          |''.|"
-            Buffer
-            "  00000000  60 42 6f 73 74 6f 6e 20  69 73 20 70 6f 70 75 6c  |`Boston is popul|"
-            "  00000010  6f 75 73 27 20 69 73 20  61 62 6f 75 74 20 42 6f  |ous' is about Bo|"
-            "  00000020  73 74 6f 6e 20 61 6e 64  20 63 6f 6e 74 61 69 6e  |ston and contain|"
-            "  00000030  73 20 60 42 6f 73 74 6f  6e 27 3b 20 60 60 42 6f  |s `Boston'; ``Bo|"
-            "  00000040  73 74 6f 6e 27 20 69 73  20 64 69 73 79 6c 6c 61  |ston' is disylla|"
-            "  00000050  62 69 63 27 20 69 73 20  61 62 6f 75 74 20 60 42  |bic' is about `B|"
-            "  00000060  6f 73 74 6f 6e 27 20 61  6e 64 20 63 6f 6e 74 61  |oston' and conta|"
-            "  00000070  69 6e 73 20 60 60 42 6f  73 74 6f 6e 27 27 2e 20  |ins ``Boston''. |"
-            "  00000080  20 60 60 42 6f 73 74 6f  6e 27 27 20 64 65 73 69  | ``Boston'' desi|"
-            "  00000090  67 6e 61 74 65 73 20 60  42 6f 73 74 6f 6e 27 2c  |gnates `Boston',|"
-            "  000000a0  20 77 68 69 63 68 20 69  6e 20 74 75 72 6e 20 64  | which in turn d|"
-            "  000000b0  65 73 69 67 6e 61 74 65  73 20 42 6f 73 74 6f 6e  |esignates Boston|"
-            "  000000c0  2e 20 20 54 6f 20 6d 65  6e 74 69 6f 6e 20 42 6f  |.  To mention Bo|"
-            "  000000d0  73 74 6f 6e 20 77 65 20  75 73 65 20 60 42 6f 73  |ston we use `Bos|"
-            "  000000e0  74 6f 6e 27 20 6f 72 20  61 20 73 79 6e 6f 6e 79  |ton' or a synony|"
-            "  000000f0  6d 2c 20 61 6e 64 20 74  6f 20 6d 65 6e 74 69 6f  |m, and to mentio|"
-            "  00000100  6e 20 60 42 6f 73 74 6f  6e 27 20 77 65 20 75 73  |n `Boston' we us|"
-            "  00000110  65 20 60 60 42 6f 73 74  6f 6e 27 27 20 6f 72 20  |e ``Boston'' or |"
-            "  00000120  61 20 73 79 6e 6f 6e 79  6d 2e 20 20 60 60 42 6f  |a synonym.  ``Bo|"
-            "  00000130  73 74 6f 6e 27 27 20 63  6f 6e 74 61 69 6e 73 20  |ston'' contains |"
-            "  00000140  73 69 78 20 6c 65 74 74  65 72 73 20 61 6e 64 20  |six letters and |"
-            "  00000150  6a 75 73 74 20 6f 6e 65  20 70 61 69 72 20 6f 66  |just one pair of|"
-            "  00000160  20 71 75 6f 74 61 74 69  6f 6e 20 6d 61 72 6b 73  | quotation marks|"
-            "  00000170  3b 20 60 42 6f 73 74 6f  6e 27 20 63 6f 6e 74 61  |; `Boston' conta|"
-            "  00000180  69 6e 73 20 73 69 78 20  6c 65 74 74 65 72 73 20  |ins six letters |"
-            "  00000190  61 6e 64 20 6e 6f 20 71  75 6f 74 61 74 69 6f 6e  |and no quotation|"
-            "  000001a0  20 6d 61 72 6b 73 3b 20  61 6e 64 20 42 6f 73 74  | marks; and Bost|"
-            "  000001b0  6f 6e 20 63 6f 6e 74 61  69 6e 73 20 73 6f 6d 65  |on contains some|"
-            "  000001c0  20 38 30 30 2c 30 30 30  20 70 65 6f 70 6c 65 2e  | 800,000 people.|")
-           |}]
-                 ;;
-
-                 let to_string_hum = to_string_hum
-
-                 let%expect_test "to_string_hum" =
-                   print_endline (to_string_hum iobuf);
-                   [%expect
-                     {|
-           Window
-             0000003d  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|
-             0000004d  6c 6c 61 62 69 63                                 |llabic|
+  struct
+    open Iobuf.Debug
+    include T
+
+    module Hexdump = struct
+      open Hexdump
+      include T
+
+      let sexp_of_t = sexp_of_t
+
+      let%expect_test "sexp_of_t" =
+        print_s [%sexp (iobuf : (_, _) t)];
+        [%expect
+          {|
+          ((window (
+             "0000003d  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
+             "0000004d  6c 6c 61 62 69 63                                 |llabic|"))
+           (limits (
+             "0000003c  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
+             "0000004c  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
+             "0000005c  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
+             "0000006c  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
+             "0000007c  27 27 2e                                          |''.|"))
+           (buffer (
+             "00000000  60 42 6f 73 74 6f 6e 20  69 73 20 70 6f 70 75 6c  |`Boston is popul|"
+             "00000010  6f 75 73 27 20 69 73 20  61 62 6f 75 74 20 42 6f  |ous' is about Bo|"
+             "00000020  73 74 6f 6e 20 61 6e 64  20 63 6f 6e 74 61 69 6e  |ston and contain|"
+             "00000030  73 20 60 42 6f 73 74 6f  6e 27 3b 20 60 60 42 6f  |s `Boston'; ``Bo|"
+             "00000040  73 74 6f 6e 27 20 69 73  20 64 69 73 79 6c 6c 61  |ston' is disylla|"
+             "00000050  62 69 63 27 20 69 73 20  61 62 6f 75 74 20 60 42  |bic' is about `B|"
+             "00000060  6f 73 74 6f 6e 27 20 61  6e 64 20 63 6f 6e 74 61  |oston' and conta|"
+             "00000070  69 6e 73 20 60 60 42 6f  73 74 6f 6e 27 27 2e 20  |ins ``Boston''. |"
+             "00000080  20 60 60 42 6f 73 74 6f  6e 27 27 20 64 65 73 69  | ``Boston'' desi|"
+             "00000090  67 6e 61 74 65 73 20 60  42 6f 73 74 6f 6e 27 2c  |gnates `Boston',|"
+             "000000a0  20 77 68 69 63 68 20 69  6e 20 74 75 72 6e 20 64  | which in turn d|"
+             "000000b0  65 73 69 67 6e 61 74 65  73 20 42 6f 73 74 6f 6e  |esignates Boston|"
+             "000000c0  2e 20 20 54 6f 20 6d 65  6e 74 69 6f 6e 20 42 6f  |.  To mention Bo|"
+             "000000d0  73 74 6f 6e 20 77 65 20  75 73 65 20 60 42 6f 73  |ston we use `Bos|"
+             "000000e0  74 6f 6e 27 20 6f 72 20  61 20 73 79 6e 6f 6e 79  |ton' or a synony|"
+             "000000f0  6d 2c 20 61 6e 64 20 74  6f 20 6d 65 6e 74 69 6f  |m, and to mentio|"
+             "00000100  6e 20 60 42 6f 73 74 6f  6e 27 20 77 65 20 75 73  |n `Boston' we us|"
+             "00000110  65 20 60 60 42 6f 73 74  6f 6e 27 27 20 6f 72 20  |e ``Boston'' or |"
+             "00000120  61 20 73 79 6e 6f 6e 79  6d 2e 20 20 60 60 42 6f  |a synonym.  ``Bo|"
+             "00000130  73 74 6f 6e 27 27 20 63  6f 6e 74 61 69 6e 73 20  |ston'' contains |"
+             "00000140  73 69 78 20 6c 65 74 74  65 72 73 20 61 6e 64 20  |six letters and |"
+             "00000150  6a 75 73 74 20 6f 6e 65  20 70 61 69 72 20 6f 66  |just one pair of|"
+             "00000160  20 71 75 6f 74 61 74 69  6f 6e 20 6d 61 72 6b 73  | quotation marks|"
+             "00000170  3b 20 60 42 6f 73 74 6f  6e 27 20 63 6f 6e 74 61  |; `Boston' conta|"
+             "00000180  69 6e 73 20 73 69 78 20  6c 65 74 74 65 72 73 20  |ins six letters |"
+             "00000190  61 6e 64 20 6e 6f 20 71  75 6f 74 61 74 69 6f 6e  |and no quotation|"
+             "000001a0  20 6d 61 72 6b 73 3b 20  61 6e 64 20 42 6f 73 74  | marks; and Bost|"
+             "000001b0  6f 6e 20 63 6f 6e 74 61  69 6e 73 20 73 6f 6d 65  |on contains some|"
+             "000001c0  20 38 30 30 2c 30 30 30  20 70 65 6f 70 6c 65 2e  | 800,000 people.|")))
+          |}]
+      ;;
+
+      let to_sequence = to_sequence
+
+      let%expect_test "to_sequence" =
+        print_s [%sexp (Sequence.to_list (to_sequence iobuf) : string list)];
+        [%expect
+          {|
+          (Window
+           "  0000003d  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|"
+           "  0000004d  6c 6c 61 62 69 63                                 |llabic|"
            Limits
-             0000003c  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|
-             0000004c  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|
-             0000005c  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|
-             0000006c  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|
-             0000007c  27 27 2e                                          |''.|
+           "  0000003c  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|"
+           "  0000004c  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|"
+           "  0000005c  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|"
+           "  0000006c  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|"
+           "  0000007c  27 27 2e                                          |''.|"
            Buffer
-             00000000  60 42 6f 73 74 6f 6e 20  69 73 20 70 6f 70 75 6c  |`Boston is popul|
-             00000010  6f 75 73 27 20 69 73 20  61 62 6f 75 74 20 42 6f  |ous' is about Bo|
-             00000020  73 74 6f 6e 20 61 6e 64  20 63 6f 6e 74 61 69 6e  |ston and contain|
-             00000030  73 20 60 42 6f 73 74 6f  6e 27 3b 20 60 60 42 6f  |s `Boston'; ``Bo|
-             00000040  73 74 6f 6e 27 20 69 73  20 64 69 73 79 6c 6c 61  |ston' is disylla|
-             00000050  62 69 63 27 20 69 73 20  61 62 6f 75 74 20 60 42  |bic' is about `B|
-             00000060  6f 73 74 6f 6e 27 20 61  6e 64 20 63 6f 6e 74 61  |oston' and conta|
-             00000070  69 6e 73 20 60 60 42 6f  73 74 6f 6e 27 27 2e 20  |ins ``Boston''. |
-             00000080  20 60 60 42 6f 73 74 6f  6e 27 27 20 64 65 73 69  | ``Boston'' desi|
-             00000090  67 6e 61 74 65 73 20 60  42 6f 73 74 6f 6e 27 2c  |gnates `Boston',|
-             000000a0  20 77 68 69 63 68 20 69  6e 20 74 75 72 6e 20 64  | which in turn d|
-             000000b0  65 73 69 67 6e 61 74 65  73 20 42 6f 73 74 6f 6e  |esignates Boston|
-             000000c0  2e 20 20 54 6f 20 6d 65  6e 74 69 6f 6e 20 42 6f  |.  To mention Bo|
-             000000d0  73 74 6f 6e 20 77 65 20  75 73 65 20 60 42 6f 73  |ston we use `Bos|
-             000000e0  74 6f 6e 27 20 6f 72 20  61 20 73 79 6e 6f 6e 79  |ton' or a synony|
-             000000f0  6d 2c 20 61 6e 64 20 74  6f 20 6d 65 6e 74 69 6f  |m, and to mentio|
-             00000100  6e 20 60 42 6f 73 74 6f  6e 27 20 77 65 20 75 73  |n `Boston' we us|
-             00000110  65 20 60 60 42 6f 73 74  6f 6e 27 27 20 6f 72 20  |e ``Boston'' or |
-             00000120  61 20 73 79 6e 6f 6e 79  6d 2e 20 20 60 60 42 6f  |a synonym.  ``Bo|
-             00000130  73 74 6f 6e 27 27 20 63  6f 6e 74 61 69 6e 73 20  |ston'' contains |
-             00000140  73 69 78 20 6c 65 74 74  65 72 73 20 61 6e 64 20  |six letters and |
-             00000150  6a 75 73 74 20 6f 6e 65  20 70 61 69 72 20 6f 66  |just one pair of|
-             00000160  20 71 75 6f 74 61 74 69  6f 6e 20 6d 61 72 6b 73  | quotation marks|
-             00000170  3b 20 60 42 6f 73 74 6f  6e 27 20 63 6f 6e 74 61  |; `Boston' conta|
-             00000180  69 6e 73 20 73 69 78 20  6c 65 74 74 65 72 73 20  |ins six letters |
-             00000190  61 6e 64 20 6e 6f 20 71  75 6f 74 61 74 69 6f 6e  |and no quotation|
-             000001a0  20 6d 61 72 6b 73 3b 20  61 6e 64 20 42 6f 73 74  | marks; and Bost|
-             000001b0  6f 6e 20 63 6f 6e 74 61  69 6e 73 20 73 6f 6d 65  |on contains some|
-             000001c0  20 38 30 30 2c 30 30 30  20 70 65 6f 70 6c 65 2e  | 800,000 people.|
-           |}]
-                 ;;
-               end
-             end :
-               module type of Iobuf.Debug))
+           "  00000000  60 42 6f 73 74 6f 6e 20  69 73 20 70 6f 70 75 6c  |`Boston is popul|"
+           "  00000010  6f 75 73 27 20 69 73 20  61 62 6f 75 74 20 42 6f  |ous' is about Bo|"
+           "  00000020  73 74 6f 6e 20 61 6e 64  20 63 6f 6e 74 61 69 6e  |ston and contain|"
+           "  00000030  73 20 60 42 6f 73 74 6f  6e 27 3b 20 60 60 42 6f  |s `Boston'; ``Bo|"
+           "  00000040  73 74 6f 6e 27 20 69 73  20 64 69 73 79 6c 6c 61  |ston' is disylla|"
+           "  00000050  62 69 63 27 20 69 73 20  61 62 6f 75 74 20 60 42  |bic' is about `B|"
+           "  00000060  6f 73 74 6f 6e 27 20 61  6e 64 20 63 6f 6e 74 61  |oston' and conta|"
+           "  00000070  69 6e 73 20 60 60 42 6f  73 74 6f 6e 27 27 2e 20  |ins ``Boston''. |"
+           "  00000080  20 60 60 42 6f 73 74 6f  6e 27 27 20 64 65 73 69  | ``Boston'' desi|"
+           "  00000090  67 6e 61 74 65 73 20 60  42 6f 73 74 6f 6e 27 2c  |gnates `Boston',|"
+           "  000000a0  20 77 68 69 63 68 20 69  6e 20 74 75 72 6e 20 64  | which in turn d|"
+           "  000000b0  65 73 69 67 6e 61 74 65  73 20 42 6f 73 74 6f 6e  |esignates Boston|"
+           "  000000c0  2e 20 20 54 6f 20 6d 65  6e 74 69 6f 6e 20 42 6f  |.  To mention Bo|"
+           "  000000d0  73 74 6f 6e 20 77 65 20  75 73 65 20 60 42 6f 73  |ston we use `Bos|"
+           "  000000e0  74 6f 6e 27 20 6f 72 20  61 20 73 79 6e 6f 6e 79  |ton' or a synony|"
+           "  000000f0  6d 2c 20 61 6e 64 20 74  6f 20 6d 65 6e 74 69 6f  |m, and to mentio|"
+           "  00000100  6e 20 60 42 6f 73 74 6f  6e 27 20 77 65 20 75 73  |n `Boston' we us|"
+           "  00000110  65 20 60 60 42 6f 73 74  6f 6e 27 27 20 6f 72 20  |e ``Boston'' or |"
+           "  00000120  61 20 73 79 6e 6f 6e 79  6d 2e 20 20 60 60 42 6f  |a synonym.  ``Bo|"
+           "  00000130  73 74 6f 6e 27 27 20 63  6f 6e 74 61 69 6e 73 20  |ston'' contains |"
+           "  00000140  73 69 78 20 6c 65 74 74  65 72 73 20 61 6e 64 20  |six letters and |"
+           "  00000150  6a 75 73 74 20 6f 6e 65  20 70 61 69 72 20 6f 66  |just one pair of|"
+           "  00000160  20 71 75 6f 74 61 74 69  6f 6e 20 6d 61 72 6b 73  | quotation marks|"
+           "  00000170  3b 20 60 42 6f 73 74 6f  6e 27 20 63 6f 6e 74 61  |; `Boston' conta|"
+           "  00000180  69 6e 73 20 73 69 78 20  6c 65 74 74 65 72 73 20  |ins six letters |"
+           "  00000190  61 6e 64 20 6e 6f 20 71  75 6f 74 61 74 69 6f 6e  |and no quotation|"
+           "  000001a0  20 6d 61 72 6b 73 3b 20  61 6e 64 20 42 6f 73 74  | marks; and Bost|"
+           "  000001b0  6f 6e 20 63 6f 6e 74 61  69 6e 73 20 73 6f 6d 65  |on contains some|"
+           "  000001c0  20 38 30 30 2c 30 30 30  20 70 65 6f 70 6c 65 2e  | 800,000 people.|")
+          |}]
+      ;;
+
+      let to_string_hum = to_string_hum
+
+      let%expect_test "to_string_hum" =
+        print_endline (to_string_hum iobuf);
+        [%expect
+          {|
+          Window
+            0000003d  60 42 6f 73 74 6f 6e 27  20 69 73 20 64 69 73 79  |`Boston' is disy|
+            0000004d  6c 6c 61 62 69 63                                 |llabic|
+          Limits
+            0000003c  60 60 42 6f 73 74 6f 6e  27 20 69 73 20 64 69 73  |``Boston' is dis|
+            0000004c  79 6c 6c 61 62 69 63 27  20 69 73 20 61 62 6f 75  |yllabic' is abou|
+            0000005c  74 20 60 42 6f 73 74 6f  6e 27 20 61 6e 64 20 63  |t `Boston' and c|
+            0000006c  6f 6e 74 61 69 6e 73 20  60 60 42 6f 73 74 6f 6e  |ontains ``Boston|
+            0000007c  27 27 2e                                          |''.|
+          Buffer
+            00000000  60 42 6f 73 74 6f 6e 20  69 73 20 70 6f 70 75 6c  |`Boston is popul|
+            00000010  6f 75 73 27 20 69 73 20  61 62 6f 75 74 20 42 6f  |ous' is about Bo|
+            00000020  73 74 6f 6e 20 61 6e 64  20 63 6f 6e 74 61 69 6e  |ston and contain|
+            00000030  73 20 60 42 6f 73 74 6f  6e 27 3b 20 60 60 42 6f  |s `Boston'; ``Bo|
+            00000040  73 74 6f 6e 27 20 69 73  20 64 69 73 79 6c 6c 61  |ston' is disylla|
+            00000050  62 69 63 27 20 69 73 20  61 62 6f 75 74 20 60 42  |bic' is about `B|
+            00000060  6f 73 74 6f 6e 27 20 61  6e 64 20 63 6f 6e 74 61  |oston' and conta|
+            00000070  69 6e 73 20 60 60 42 6f  73 74 6f 6e 27 27 2e 20  |ins ``Boston''. |
+            00000080  20 60 60 42 6f 73 74 6f  6e 27 27 20 64 65 73 69  | ``Boston'' desi|
+            00000090  67 6e 61 74 65 73 20 60  42 6f 73 74 6f 6e 27 2c  |gnates `Boston',|
+            000000a0  20 77 68 69 63 68 20 69  6e 20 74 75 72 6e 20 64  | which in turn d|
+            000000b0  65 73 69 67 6e 61 74 65  73 20 42 6f 73 74 6f 6e  |esignates Boston|
+            000000c0  2e 20 20 54 6f 20 6d 65  6e 74 69 6f 6e 20 42 6f  |.  To mention Bo|
+            000000d0  73 74 6f 6e 20 77 65 20  75 73 65 20 60 42 6f 73  |ston we use `Bos|
+            000000e0  74 6f 6e 27 20 6f 72 20  61 20 73 79 6e 6f 6e 79  |ton' or a synony|
+            000000f0  6d 2c 20 61 6e 64 20 74  6f 20 6d 65 6e 74 69 6f  |m, and to mentio|
+            00000100  6e 20 60 42 6f 73 74 6f  6e 27 20 77 65 20 75 73  |n `Boston' we us|
+            00000110  65 20 60 60 42 6f 73 74  6f 6e 27 27 20 6f 72 20  |e ``Boston'' or |
+            00000120  61 20 73 79 6e 6f 6e 79  6d 2e 20 20 60 60 42 6f  |a synonym.  ``Bo|
+            00000130  73 74 6f 6e 27 27 20 63  6f 6e 74 61 69 6e 73 20  |ston'' contains |
+            00000140  73 69 78 20 6c 65 74 74  65 72 73 20 61 6e 64 20  |six letters and |
+            00000150  6a 75 73 74 20 6f 6e 65  20 70 61 69 72 20 6f 66  |just one pair of|
+            00000160  20 71 75 6f 74 61 74 69  6f 6e 20 6d 61 72 6b 73  | quotation marks|
+            00000170  3b 20 60 42 6f 73 74 6f  6e 27 20 63 6f 6e 74 61  |; `Boston' conta|
+            00000180  69 6e 73 20 73 69 78 20  6c 65 74 74 65 72 73 20  |ins six letters |
+            00000190  61 6e 64 20 6e 6f 20 71  75 6f 74 61 74 69 6f 6e  |and no quotation|
+            000001a0  20 6d 61 72 6b 73 3b 20  61 6e 64 20 42 6f 73 74  | marks; and Bost|
+            000001b0  6f 6e 20 63 6f 6e 74 61  69 6e 73 20 73 6f 6d 65  |on contains some|
+            000001c0  20 38 30 30 2c 30 30 30  20 70 65 6f 70 6c 65 2e  | 800,000 people.|
+          |}]
+      ;;
+    end
+  end :
+    module type of Iobuf.Debug))
 ;;
diff --git a/limiter/bench/dune b/limiter/bench/dune
index ded86a27..bbb19d0d 100644
--- a/limiter/bench/dune
+++ b/limiter/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name limiter_bench)
- (libraries limiter)
+ (libraries core limiter)
  (preprocess
   (pps ppx_jane)))
diff --git a/limiter/src/limiter.ml b/limiter/src/limiter.ml
index 6e9cfd4f..8e59c105 100644
--- a/limiter/src/limiter.ml
+++ b/limiter/src/limiter.ml
@@ -144,18 +144,18 @@ end
 type t =
   { start_time : Time_ns.t
   ; mutable time : Time_ns.t
-      (** The current time of the rate limiter.  Note that when this is moved forward,
+  (** The current time of the rate limiter.  Note that when this is moved forward,
       [in_hopper] must be updated accordingly. *)
   ; time_in_token_space : int Iofm.t
-      (** the amount of time that has passed expressed in token terms, since start_time. *)
+  (** the amount of time that has passed expressed in token terms, since start_time. *)
   ; mutable in_bucket : int (** number of tokens in the bucket *)
   ; in_hopper : int Iofm.t (** number of tokens in the hopper.  May be [inf] *)
   ; mutable in_flight : int
-      (** Everything that has been taken from bucket but not returned to hopper *)
+  (** Everything that has been taken from bucket but not returned to hopper *)
   ; mutable bucket_limit : int (** maximum size allowable in the bucket *)
   ; in_flight_limit : int Iofm.t (** maximum size allowable in flight *)
   ; mutable hopper_to_bucket_rate_per_ns : Tokens_per_ns.t Iofm.t
-      (** rate at which tokens "fall" from the hopper into the bucket *)
+  (** rate at which tokens "fall" from the hopper into the bucket *)
   }
 [@@deriving sexp_of]
 
diff --git a/limiter/test/dune b/limiter/test/dune
index 839d95a6..d9fd78cb 100644
--- a/limiter/test/dune
+++ b/limiter/test/dune
@@ -1,5 +1,5 @@
 (library
  (name limiter_test)
- (libraries limiter)
+ (libraries core limiter)
  (preprocess
   (pps ppx_jane)))
diff --git a/limiter/test/test_limiter.ml b/limiter/test/test_limiter.ml
index 746b8e76..6c9cd9f5 100644
--- a/limiter/test/test_limiter.ml
+++ b/limiter/test/test_limiter.ml
@@ -242,7 +242,7 @@ let%test_module "Step_test" =
                             (sustained_rate_per_sec : float)
                             (old_burst_size : int)
                             (old_sustained_rate_per_sec
-                              : float Limiter.Infinite_or_finite.t)]
+                             : float Limiter.Infinite_or_finite.t)]
                   | Unable ->
                     if expect
                     then
@@ -253,7 +253,7 @@ let%test_module "Step_test" =
                             (sustained_rate_per_sec : float)
                             (old_burst_size : int)
                             (old_sustained_rate_per_sec
-                              : float Limiter.Infinite_or_finite.t)])
+                             : float Limiter.Infinite_or_finite.t)])
             ; debug_sexp =
                 [%message
                   "Reconfigure"
diff --git a/moption/test/dune b/moption/test/dune
index 4f3e3f25..226fb2bd 100644
--- a/moption/test/dune
+++ b/moption/test/dune
@@ -1,5 +1,5 @@
 (library
  (name moption_test)
- (libraries expect_test_helpers_core moption)
+ (libraries core expect_test_helpers_core moption)
  (preprocess
   (pps ppx_jane)))
diff --git a/nonempty_list/src/dune b/nonempty_list/src/dune
index df3fd276..2bd862bf 100644
--- a/nonempty_list/src/dune
+++ b/nonempty_list/src/dune
@@ -1,6 +1,6 @@
 (library
  (name nonempty_list)
  (public_name core_kernel.nonempty_list)
- (libraries core reversed_list)
+ (libraries core reversed_list ppx_stable_witness.stable_witness)
  (preprocess
   (pps ppx_jane)))
diff --git a/nonempty_list/src/nonempty_list.ml b/nonempty_list/src/nonempty_list.ml
index d1d50df8..5d511d1e 100644
--- a/nonempty_list/src/nonempty_list.ml
+++ b/nonempty_list/src/nonempty_list.ml
@@ -3,7 +3,8 @@ open Core.Core_stable
 module Stable = struct
   module V3 = struct
     module T = struct
-      type nonrec 'a t = ( :: ) of 'a * 'a list [@@deriving compare, equal, hash]
+      type nonrec 'a t = ( :: ) of 'a * 'a list
+      [@@deriving compare, equal, globalize, hash]
 
       let to_list (hd :: tl) : _ list = hd :: tl
 
@@ -303,16 +304,16 @@ let reverse (hd :: tl) =
 let append (hd :: tl) l = hd :: List.append tl l
 
 include Monad.Make_local (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let return hd = [ hd ]
-  let map = `Custom map
+    let return hd = [ hd ]
+    let map = `Custom map
 
-  let bind (hd :: tl) ~f =
-    let f_hd = f hd in
-    append f_hd (List.concat_map tl ~f:(fun x -> to_list (f x)))
-  ;;
-end)
+    let bind (hd :: tl) ~f =
+      let f_hd = f hd in
+      append f_hd (List.concat_map tl ~f:(fun x -> to_list (f x)))
+    ;;
+  end)
 
 let unzip ((hd1, hd2) :: tl) =
   let tl1, tl2 = List.unzip tl in
@@ -345,8 +346,10 @@ let to_sequence t =
 
 let sort t ~compare = List.sort (to_list t) ~compare |> of_list_exn
 let stable_sort t ~compare = List.stable_sort (to_list t) ~compare |> of_list_exn
+let stable_dedup t ~compare = List.stable_dedup (to_list t) ~compare |> of_list_exn
 let dedup_and_sort t ~compare = List.dedup_and_sort ~compare (to_list t) |> of_list_exn
 let permute ?random_state t = List.permute ?random_state (to_list t) |> of_list_exn
+let random_element ?random_state t = to_list t |> List.random_element_exn ?random_state
 
 let min_elt' (hd :: tl) ~compare =
   List.fold tl ~init:hd ~f:(fun min elt -> if compare min elt > 0 then elt else min) [@nontail
diff --git a/nonempty_list/src/nonempty_list.mli b/nonempty_list/src/nonempty_list.mli
index 508f2053..c42c10a4 100644
--- a/nonempty_list/src/nonempty_list.mli
+++ b/nonempty_list/src/nonempty_list.mli
@@ -47,8 +47,10 @@ val drop_last : 'a t -> 'a list
 val to_sequence : 'a t -> 'a Sequence.t
 val sort : 'a t -> compare:('a -> 'a -> int) -> 'a t
 val stable_sort : 'a t -> compare:('a -> 'a -> int) -> 'a t
+val stable_dedup : 'a t -> compare:('a -> 'a -> int) -> 'a t
 val dedup_and_sort : 'a t -> compare:('a -> 'a -> int) -> 'a t
 val permute : ?random_state:Random.State.t -> 'a t -> 'a t
+val random_element : ?random_state:Random.State.t -> 'a t -> 'a
 val iteri : 'a t -> f:(int -> 'a -> unit) -> unit
 val cartesian_product : 'a t -> 'b t -> ('a * 'b) t
 val fold_nonempty : 'a t -> init:('a -> 'acc) -> f:('acc -> 'a -> 'acc) -> 'acc
@@ -194,18 +196,23 @@ module Stable : sig
       is represented as [(1 2)]. *)
   module V3 : sig
     type nonrec 'a t = 'a t
-    [@@deriving bin_io, compare, equal, sexp, sexp_grammar, hash, stable_witness]
+    [@@deriving
+      bin_io, compare, equal, globalize, sexp, sexp_grammar, hash, stable_witness]
   end
 
   (** Represents a [t] as an ordinary list for sexp conversions, but uses a record [{hd :
-      'a; tl ; 'a list}] for bin_io conversions. *)
+      'a; tl ; 'a list}] for bin_io conversions. This module is provided for compatibility
+      with existing protocols; there's no reason not to use the latest version if you're
+      writing a new protocol. *)
   module V2 : sig
     type nonrec 'a t = 'a t
     [@@deriving bin_io, compare, equal, sexp, hash, stable_witness]
   end
 
   (** Represents a [t] as an ordinary list for sexps, but as a pair for bin_io conversions
-      (i.e., a ['a t] is represented as the type ['a * 'a list]). *)
+      (i.e., a ['a t] is represented as the type ['a * 'a list]). This module is provided
+      for compatibility with existing protocols; there's no reason not to use the latest
+      version if you're writing a new protocol. *)
   module V1 : sig
     type nonrec 'a t = 'a t [@@deriving bin_io, compare, equal, sexp, stable_witness]
   end
diff --git a/nonempty_list/test/dune b/nonempty_list/test/dune
index 4dc09200..4ad0f82e 100644
--- a/nonempty_list/test/dune
+++ b/nonempty_list/test/dune
@@ -1,6 +1,6 @@
 (library
  (name nonempty_list_tests)
- (libraries accessor_base base_test_helpers composition_infix core
+ (libraries accessor accessor_base base_test_helpers composition_infix core
    expect_test_helpers_core nonempty_list nonempty_list_accessor)
  (preprocess
   (pps ppx_jane)))
diff --git a/nonempty_list/test/nonempty_list_tests.ml b/nonempty_list/test/nonempty_list_tests.ml
index fa0bfa93..58f2234d 100644
--- a/nonempty_list/test/nonempty_list_tests.ml
+++ b/nonempty_list/test/nonempty_list_tests.ml
@@ -8,7 +8,7 @@ include (
 
     let of_list l = if List.is_empty l then `Skip_test else `Ok (of_list_exn l)
   end) :
-    sig end)
+  sig end)
 
 (* Note that at least one expect test must be included for the above functor's tests to
    run.
@@ -63,7 +63,8 @@ let%expect_test "map2" =
   test [ 1; 2 ] [ 3; 4 ];
   test [ 1 ] [ 2; 3 ];
   test [ 1; 2 ] [ 3 ];
-  [%expect {|
+  [%expect
+    {|
     (Ok (2))
     (Ok (3 8))
     Unequal_lengths
@@ -128,7 +129,8 @@ let%expect_test "filter" =
   test [ 2 ] ~f:is_even;
   test [ 1; 2 ] ~f:is_even;
   test [ 2; 2; 3; 4 ] ~f:is_even;
-  [%expect {|
+  [%expect
+    {|
     ()
     (2)
     (2)
@@ -144,7 +146,8 @@ let%expect_test "filteri" =
   test [ 1; 2 ] ~f:index_plus_value_is_even;
   test [ 2; 2; 3; 4 ] ~f:index_plus_value_is_even;
   test [ 2; 2; 4; 3 ] ~f:index_plus_value_is_even;
-  [%expect {|
+  [%expect
+    {|
     ()
     (2)
     ()
@@ -160,7 +163,8 @@ let%expect_test "filter_map" =
   test [ 2 ] ~f:double_if_even;
   test [ 1; 2 ] ~f:double_if_even;
   test [ 2; 2; 3; 4 ] ~f:double_if_even;
-  [%expect {|
+  [%expect
+    {|
     ()
     (4)
     (4)
@@ -178,7 +182,8 @@ let%expect_test "filter_mapi" =
   test [ 1; 2 ] ~f:double_if_index_plus_value_is_even;
   test [ 2; 2; 3; 4 ] ~f:double_if_index_plus_value_is_even;
   test [ 2; 2; 4; 3 ] ~f:double_if_index_plus_value_is_even;
-  [%expect {|
+  [%expect
+    {|
     ()
     (4)
     ()
@@ -193,7 +198,8 @@ let%expect_test "concat" =
   test [ [ 1 ]; [ 2 ]; [ 3 ] ];
   test [ [ 1; 2; 3 ] ];
   test [ [ 1 ]; [ 2; 3 ]; [ 4; 5; 6 ] ];
-  [%expect {|
+  [%expect
+    {|
     (1)
     (1 2 3)
     (1 2 3)
@@ -207,7 +213,8 @@ let%expect_test "nth" =
   test 0 [ 1; 2; 3 ];
   test 2 [ 1; 2; 3 ];
   test 3 [ 1; 2; 3 ];
-  [%expect {|
+  [%expect
+    {|
     ()
     (1)
     (3)
@@ -239,7 +246,8 @@ let%expect_test "last" =
   test [ 1 ];
   test [ 1; 2 ];
   test [ 1; 2; 3 ];
-  [%expect {|
+  [%expect
+    {|
     1
     2
     3
@@ -251,7 +259,8 @@ let%expect_test "drop_last" =
   test [ 1 ];
   test [ 1; 2 ];
   test [ 1; 2; 3 ];
-  [%expect {|
+  [%expect
+    {|
     ()
     (1)
     (1 2)
@@ -263,7 +272,8 @@ let%expect_test "to_sequence" =
   test [ 1 ];
   test [ 1; 2; 3 ];
   test [ 0; 2; 4; 6 ];
-  [%expect {|
+  [%expect
+    {|
     (1)
     (1 2 3)
     (0 2 4 6)
@@ -274,7 +284,8 @@ let%expect_test "sort" =
   let test t = print_s [%sexp (sort ~compare:Int.compare t : int t)] in
   test [ 1 ];
   test [ 2; 4; 1; 4 ];
-  [%expect {|
+  [%expect
+    {|
     (1)
     (1 2 4 4)
     |}]
@@ -285,7 +296,7 @@ let%expect_test "stable_sort" =
     print_s
       [%sexp
         (stable_sort ~compare:(fun a b -> Comparable.lift ~f:fst Int.compare a b) t
-          : (int * string) t)]
+         : (int * string) t)]
   in
   test [ 1, "_" ];
   test [ 2, "_"; 4, "a"; 1, "_"; 4, "b" ];
@@ -298,11 +309,30 @@ let%expect_test "stable_sort" =
     |}]
 ;;
 
+let%expect_test "stable_dedup" =
+  let test t =
+    print_s
+      [%sexp
+        (stable_dedup ~compare:(fun a b -> Comparable.lift ~f:fst Int.compare a b) t
+         : (int * string) t)]
+  in
+  test [ 1, "_" ];
+  test [ 2, "_"; 4, "a"; 1, "_"; 4, "b" ];
+  test [ 2, "_"; 4, "b"; 1, "_"; 4, "a" ];
+  [%expect
+    {|
+    ((1 _))
+    ((2 _) (4 a) (1 _))
+    ((2 _) (4 b) (1 _))
+    |}]
+;;
+
 let%expect_test "dedup_and_sort" =
   let test t = print_s [%sexp (dedup_and_sort ~compare:Int.compare t : int t)] in
   test [ 1 ];
   test [ 2; 4; 1; 4 ];
-  [%expect {|
+  [%expect
+    {|
     (1)
     (1 2 4)
     |}]
@@ -331,7 +361,8 @@ let%expect_test "map_of_alist_multi" =
   in
   test [];
   test [ 0, 0; 0, 1; 1, 1 ];
-  [%expect {|
+  [%expect
+    {|
     ()
     ((0 (1 0)) (1 (1)))
     |}]
@@ -343,11 +374,12 @@ let%expect_test "map_of_list_with_key_multi" =
     print_s
       [%sexp
         (map_of_list_with_key_multi alist ~comparator:(module Int) ~get_key
-          : Date.t t Int.Map.t)]
+         : Date.t t Int.Map.t)]
   in
   test [];
   test ([ "2023-01-01"; "2023-03-03"; "2024-12-24" ] |> List.map ~f:Date.of_string);
-  [%expect {|
+  [%expect
+    {|
     ()
     ((2023 (2023-03-03 2023-01-01)) (2024 (2024-12-24)))
     |}]
@@ -360,7 +392,8 @@ let%expect_test "map_of_sequence_multi" =
   in
   test Sequence.empty;
   test (Sequence.of_list [ 0, 0; 0, 1; 1, 1 ]);
-  [%expect {|
+  [%expect
+    {|
     ()
     ((0 (1 0)) (1 (1)))
     |}]
@@ -733,9 +766,9 @@ let%expect_test "init" =
   [%expect {| (0 1) |}];
   test 1;
   [%expect {| (0) |}];
-  Expect_test_helpers_core.require_does_raise [%here] (fun () -> test 0);
+  Expect_test_helpers_core.require_does_raise (fun () -> test 0);
   [%expect {| (Invalid_argument "Nonempty_list.init 0") |}];
-  Expect_test_helpers_core.require_does_raise [%here] (fun () -> test (-1));
+  Expect_test_helpers_core.require_does_raise (fun () -> test (-1));
   [%expect {| (Invalid_argument "Nonempty_list.init -1") |}];
   ()
 ;;
@@ -856,7 +889,7 @@ let%expect_test "Option" =
 let%expect_test "Option does not allocate" =
   run_on_empty_and_nonempty_lists (fun l ->
     let round_tripped =
-      Expect_test_helpers_core.require_no_allocation [%here] (fun () ->
+      Expect_test_helpers_core.require_no_allocation (fun () ->
         match%optional.Nonempty_list.Option l with
         | None -> Sys.opaque_identity Nonempty_list.Option.none
         | Some nonempty ->
diff --git a/pairing_heap/bench/dune b/pairing_heap/bench/dune
index fcb25a03..c8dc02b0 100644
--- a/pairing_heap/bench/dune
+++ b/pairing_heap/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name pairing_heap_bench)
- (libraries pairing_heap)
+ (libraries core pairing_heap)
  (preprocess
   (pps ppx_jane)))
diff --git a/pairing_heap/src/pairing_heap.ml b/pairing_heap/src/pairing_heap.ml
index 3330ff1c..67d6842f 100644
--- a/pairing_heap/src/pairing_heap.ml
+++ b/pairing_heap/src/pairing_heap.ml
@@ -497,12 +497,12 @@ let iter t ~f =
 let length t = Node.Pool.length t.pool
 
 module C = Container.Make (struct
-  type nonrec 'a t = 'a t
+    type nonrec 'a t = 'a t
 
-  let fold = fold
-  let iter = `Custom iter
-  let length = `Custom length
-end)
+    let fold = fold
+    let iter = `Custom iter
+    let length = `Custom length
+  end)
 
 let is_empty t = Node.is_empty t.root
 let mem = C.mem
diff --git a/pairing_heap/test/dune b/pairing_heap/test/dune
index 43146773..2791c1b1 100644
--- a/pairing_heap/test/dune
+++ b/pairing_heap/test/dune
@@ -1,5 +1,5 @@
 (library
  (name pairing_heap_test)
- (libraries base_test_helpers expect_test_helpers_core pairing_heap)
+ (libraries base_test_helpers core expect_test_helpers_core pairing_heap)
  (preprocess
   (pps ppx_jane)))
diff --git a/pairing_heap/test/test_pairing_heap.ml b/pairing_heap/test/test_pairing_heap.ml
index c9034722..b38206b9 100644
--- a/pairing_heap/test/test_pairing_heap.ml
+++ b/pairing_heap/test/test_pairing_heap.ml
@@ -6,21 +6,21 @@ module Heap = Pairing_heap
 (* Container tests.  Heap has no t_of_sexp because there is no way to deserialize a
    comparison function, so we simulate it. *)
 include Base_test_helpers.Test_container.Test_S0 (struct
-  include Heap
+    include Heap
 
-  module Elt = struct
-    type t = int [@@deriving sexp]
+    module Elt = struct
+      type t = int [@@deriving sexp]
 
-    let of_int = Fn.id
-    let to_int = Fn.id
-  end
+      let of_int = Fn.id
+      let to_int = Fn.id
+    end
 
-  type nonrec t = int t [@@deriving sexp_of]
+    type nonrec t = int t [@@deriving sexp_of]
 
-  let mem t int = mem t int ~equal:Int.equal
-  let of_list ints = of_list ints ~cmp:Int.compare
-  let t_of_sexp sexp = sexp |> [%of_sexp: int list] |> of_list
-end)
+    let mem t int = mem t int ~equal:Int.equal
+    let of_list ints = of_list ints ~cmp:Int.compare
+    let t_of_sexp sexp = sexp |> [%of_sexp: int list] |> of_list
+  end)
 
 let%expect_test "Heap.sexp_of_t" =
   let test list =
@@ -36,12 +36,14 @@ let%expect_test "Heap.sexp_of_t" =
   test [];
   [%expect {| () |}];
   test [ 3 ];
-  [%expect {|
+  [%expect
+    {|
     (3)
     ()
     |}];
   test [ 3; 1; 4 ];
-  [%expect {|
+  [%expect
+    {|
     (1 3 4)
     (3 4)
     (4)
@@ -77,12 +79,14 @@ let%expect_test "Heap.sexp_of_t with removes" =
   test [];
   [%expect {| () |}];
   test [ 3 ];
-  [%expect {|
+  [%expect
+    {|
     (3)
     ()
     |}];
   test [ 3; 1; 4 ];
-  [%expect {|
+  [%expect
+    {|
     (1 3 4)
     (1 4)
     (4)
@@ -256,88 +260,127 @@ let%test_module _ =
       That_heap.invariant Fn.ignore that_t
     ;;
 
-    let test_dual_ops () =
-      let t = create () in
-      let rec loop ops =
-        if ops = 0
-        then ()
-        else (
-          let r = Random.int 100 in
-          if r < 40
-          then add t (Random.int 100_000)
-          else if r < 70
-          then pop t
-          else if r < 80
-          then top t
-          else if r < 90
-          then remove_top t
-          else internal_check t;
-          loop (ops - 1))
+    let%expect_test _ =
+      let generator =
+        let add =
+          let%map.Quickcheck.Generator i = Int.gen_uniform_incl 0 100 in
+          `Add i
+        in
+        let return = Quickcheck.Generator.return in
+        Quickcheck.Generator.weighted_union
+          (* This is biased towards adding (0.5 probability of add, 0.3 probability of
+             pop or remove top), so the heap will tend to grow over time. This should test
+             more interesting cases compared to always testing small heaps. *)
+          [ 0.5, add
+          ; 0.2, return `Pop
+          ; 0.1, return `Top
+          ; 0.1, return `Remove_top
+          ; 0.1, return `Internal_check
+          ]
+        |> Quickcheck.Generator.list
       in
-      loop 1_000
+      Quickcheck.test generator ~sizes:(Sequence.repeat 10_000) ~trials:100 ~f:(fun ops ->
+        let t = create () in
+        List.iter ops ~f:(function
+          | `Add i -> add t i
+          | `Pop -> pop t
+          | `Top -> top t
+          | `Remove_top -> remove_top t
+          | `Internal_check -> internal_check t))
     ;;
-
-    let%test_unit _ = test_dual_ops ()
   end)
 ;;
 
-let integers n =
-  let t = create ~cmp:Int.compare () in
-  for i = 1 to n do
-    add t i;
-    if i % 10 = 0
-       (* We need to pop from time to time to trigger the amortized tree reorganizations.  If
-       we don't do this the resulting structure is just a linked list and the caller is
-       not flexed as completely as it should be. *)
-    then (
-      ignore (pop t : int option);
-      add t i)
-  done;
-  t
+let integer_test f =
+  let generator =
+    let%map.Quickcheck.Generator ops =
+      let add =
+        let%map.Quickcheck.Generator i =
+          Int.gen_uniform_incl Int.min_value Int.max_value
+        in
+        `Add i
+      in
+      (* We need to pop from time to time to trigger the amortized tree reorganizations.
+         If we don't do this the resulting structure is just a linked list and the caller
+         is not flexed as completely as it should be. *)
+      Quickcheck.Generator.weighted_union
+        [ 0.1, Quickcheck.Generator.return `Pop; 0.9, add ]
+      |> Quickcheck.Generator.list
+    in
+    let t = create ~cmp:Int.compare () in
+    List.iter ops ~f:(function
+      | `Add i -> add t i
+      | `Pop -> ignore (pop t : int option));
+    t
+  in
+  Quickcheck.test generator ~f
 ;;
 
 let%test_unit "clear" =
-  let t = integers 99 in
-  clear t;
-  if length t <> 0
-  then failwithf "not empty after clear: contains %d elements" (length t) ()
+  integer_test (fun t ->
+    let initial_elts = to_list t in
+    clear t;
+    if length t <> 0
+    then
+      raise_s
+        [%message
+          "not empty after clear"
+            (initial_elts : int list)
+            ~length_after_clear:(length t : int)])
 ;;
 
 let test_copy ~add_removable ~remove =
   let sum t = fold t ~init:0 ~f:(fun acc i -> acc + i) in
-  let t = integers 99 in
-  let token = add_removable t 100 in
-  invariant Fn.ignore t;
-  let t' = copy t in
-  invariant Fn.ignore t';
-  assert (sum t = sum t');
-  assert (to_list t = to_list t');
-  remove t token;
-  assert (sum t = sum t' - 100)
+  integer_test (fun t ->
+    let token = add_removable t 100 in
+    invariant Fn.ignore t;
+    let t' = copy t in
+    invariant Fn.ignore t';
+    assert (sum t = sum t');
+    assert (to_list t = to_list t');
+    remove t token;
+    assert (sum t = sum t' - 100))
 ;;
 
 let%test_unit _ = test_copy ~add_removable ~remove
 let%test_unit _ = test_copy ~add_removable:Unsafe.add_removable ~remove:Unsafe.remove
 
 let test_removal ~add_removable ~remove ~elt_value_exn =
-  let t = create ~cmp:Int.compare () in
-  let tokens = ref [] in
-  for i = 1 to 10_000 do
-    tokens := add_removable t i :: !tokens
-  done;
-  invariant Fn.ignore t;
-  List.iter !tokens ~f:(fun token ->
-    if elt_value_exn token t % 2 <> 0 then remove t token);
-  invariant Fn.ignore t;
-  let rec loop count =
-    if count % 1000 = 0 then invariant Fn.ignore t;
-    match pop t with
-    | None -> assert (count = 10_000 / 2)
-    | Some v ->
-      assert ((1 + count) * 2 = v);
-      loop (count + 1)
+  let generator =
+    let%map.Quickcheck.Generator elts =
+      Int.gen_uniform_incl Int.min_value Int.max_value |> Quickcheck.Generator.list
+    in
+    let t = create ~cmp:Int.compare () in
+    let tokens = List.map elts ~f:(fun i -> i, add_removable t i) in
+    t, tokens
   in
-  loop 0
+  Quickcheck.test
+    generator
+    (* This replaced an old test that added exactly 10k elements, and this combination of
+       sizes and trials produces a few of about that size. Reaching this exact size is
+       probably not all that important. *)
+    ~sizes:(Sequence.repeat 30_000)
+    ~trials:20
+    ~f:(fun (t, tokens) ->
+      invariant Fn.ignore t;
+      assert (length t = List.length tokens);
+      let even_elts =
+        List.filter_map tokens ~f:(fun (elt, token) ->
+          assert (elt_value_exn token t = elt);
+          if elt % 2 = 0
+          then Some elt
+          else (
+            remove t token;
+            None))
+      in
+      assert (length t = List.length even_elts);
+      invariant Fn.ignore t;
+      List.iteri (List.sort ~compare:Int.compare even_elts) ~f:(fun i elt ->
+        if i % 1000 = 0 then invariant Fn.ignore t;
+        match pop t with
+        | None -> assert false
+        | Some v -> assert (v = elt));
+      assert (is_empty t))
 ;;
 
 let%test_unit "remove" =
@@ -351,23 +394,27 @@ let%test_unit "remove" =
     ~elt_value_exn:Unsafe.Elt.value
 ;;
 
-let test_ordering () =
-  let t = create ~cmp:Int.compare () in
-  for _ = 1 to 10_000 do
-    add t (Random.int 100_000)
-  done;
-  let rec loop last count =
-    if count % 1_000 = 0 then invariant Fn.ignore t;
-    match pop t with
-    | None -> ()
-    | Some v ->
-      assert (v >= last);
-      loop v (count + 1)
+let%test_unit _ =
+  let generator =
+    let%map.Quickcheck.Generator elts =
+      Int.gen_uniform_incl Int.min_value Int.max_value |> Quickcheck.Generator.list
+    in
+    let t = create ~cmp:Int.compare () in
+    List.iter elts ~f:(fun elt -> add t elt);
+    t
   in
-  loop (-1) 0
+  Quickcheck.test generator ~sizes:(Sequence.repeat 30_000) ~trials:20 ~f:(fun t ->
+    let rec loop last count =
+      if count % 1_000 = 0 then invariant Fn.ignore t;
+      match pop t with
+      | None -> ()
+      | Some v ->
+        assert (v >= last);
+        loop v (count + 1)
+    in
+    loop Int.min_value 0)
 ;;
 
-let%test_unit _ = test_ordering ()
 let%test_unit _ = ignore (of_array [||] ~cmp:Int.compare : int t)
 
 let%expect_test "operations on removed elements" =
@@ -376,7 +423,7 @@ let%expect_test "operations on removed elements" =
   print_s [%sexp (elt : int Elt.t)];
   [%expect {| (1) |}];
   ignore (pop_exn h : int);
-  require_does_raise [%here] (fun () -> Elt.value_exn elt);
+  require_does_raise (fun () -> Elt.value_exn elt);
   [%expect {| (Failure "Heap.value_exn: node was removed from the heap") |}];
   print_s [%sexp (elt : int Elt.t)];
   [%expect {| () |}]
@@ -387,18 +434,18 @@ let%expect_test "pop_if" =
   let show () = print_s [%sexp (heap : int Heap.t)] in
   show ();
   [%expect {| (-1 1 2 3) |}];
-  require_some ~print_some:[%sexp_of: int] [%here] (Heap.pop_if heap (fun i -> i < 0));
+  require_some ~print_some:[%sexp_of: int] (Heap.pop_if heap (fun i -> i < 0));
   [%expect {| -1 |}];
   show ();
   [%expect {| (1 2 3) |}];
-  require_none [%here] [%sexp_of: int] (Heap.pop_if heap (fun i -> i < 0));
+  require_none [%sexp_of: int] (Heap.pop_if heap (fun i -> i < 0));
   show ();
   [%expect {| (1 2 3) |}]
 ;;
 
 let%expect_test "pop_if on empty heap" =
   let empty = Heap.create ~cmp:Int.compare () in
-  require_none [%here] [%sexp_of: int] (Heap.pop_if empty (fun _ -> true))
+  require_none [%sexp_of: int] (Heap.pop_if empty (fun _ -> true))
 ;;
 
 let test_pop_while_negative values =
diff --git a/pooled_hashtbl/src/dune b/pooled_hashtbl/src/dune
index 67543d98..612fd309 100644
--- a/pooled_hashtbl/src/dune
+++ b/pooled_hashtbl/src/dune
@@ -1,6 +1,6 @@
 (library
  (name pooled_hashtbl)
  (public_name core_kernel.pooled_hashtbl)
- (libraries core tuple_pool)
+ (libraries core sexplib ppx_stable_witness.stable_witness tuple_pool)
  (preprocess
   (pps ppx_jane)))
diff --git a/pooled_hashtbl/src/pooled_hashtbl.ml b/pooled_hashtbl/src/pooled_hashtbl.ml
index 34df1630..ec1052ce 100644
--- a/pooled_hashtbl/src/pooled_hashtbl.ml
+++ b/pooled_hashtbl/src/pooled_hashtbl.ml
@@ -212,12 +212,12 @@ let resize =
 let on_grow ~before ~after =
   let old_before = !on_grow in
   on_grow
-    := fun () ->
-         let old_after = Staged.unstage (old_before ()) in
-         let v = before () in
-         Staged.stage (fun ~old_capacity ~new_capacity ->
-           old_after ~old_capacity ~new_capacity;
-           after v ~old_capacity ~new_capacity)
+  := fun () ->
+       let old_after = Staged.unstage (old_before ()) in
+       let v = before () in
+       Staged.stage (fun ~old_capacity ~new_capacity ->
+         old_after ~old_capacity ~new_capacity;
+         after v ~old_capacity ~new_capacity)
 ;;
 
 let rec find_entry t ~key ~it =
@@ -932,13 +932,12 @@ let map_inplace t ~f = mapi_inplace t ~f:(fun ~key:_ ~data -> f data) [@nontail]
 let equal equal t t' =
   length t = length t'
   && with_return (fun r ->
-       iteri t ~f:(fun ~key ~data ->
-         match find t' key with
-         | None -> r.return false
-         | Some data' ->
-           if not (without_mutating t' (fun () -> equal data data') ())
-           then r.return false);
-       true)
+    iteri t ~f:(fun ~key ~data ->
+      match find t' key with
+      | None -> r.return false
+      | Some data' ->
+        if not (without_mutating t' (fun () -> equal data data') ()) then r.return false);
+    true)
 ;;
 
 let similar = equal
@@ -1042,20 +1041,20 @@ module type Key_stable = Key_stable
 module type For_deriving = For_deriving
 
 module Creators (Key : sig
-  type 'a t
+    type 'a t
 
-  val hashable : 'a t Hashable.t
-end) : sig
+    val hashable : 'a t Hashable.t
+  end) : sig
   type ('a, 'b) t_ = ('a Key.t, 'b) t
 
   val t_of_sexp : (Sexp.t -> 'a Key.t) -> (Sexp.t -> 'b) -> Sexp.t -> ('a, 'b) t_
 
   include
     Creators
-      with type ('a, 'b) t := ('a, 'b) t_
-      with type 'a key := 'a Key.t
-      with type ('key, 'data, 'a) create_options :=
-        ('key, 'data, 'a) create_options_without_hashable
+    with type ('a, 'b) t := ('a, 'b) t_
+    with type 'a key := 'a Key.t
+    with type ('key, 'data, 'a) create_options :=
+      ('key, 'data, 'a) create_options_without_hashable
 end = struct
   let hashable = Key.hashable
 
@@ -1114,10 +1113,10 @@ module Poly = struct
   let invariant = invariant
 
   include Creators (struct
-    type 'a t = 'a
+      type 'a t = 'a
 
-    let hashable = hashable
-  end)
+      let hashable = hashable
+    end)
 
   include Accessors
 
@@ -1128,36 +1127,76 @@ module Poly = struct
   ;;
 
   include Bin_prot.Utils.Make_iterable_binable2 (struct
-    type ('a, 'b) z = ('a, 'b) t
-    type ('a, 'b) t = ('a, 'b) z
-    type ('a, 'b) el = 'a * 'b [@@deriving bin_io]
+      type ('a, 'b) z = ('a, 'b) t
+      type ('a, 'b) t = ('a, 'b) z
+      type ('a, 'b) el = 'a * 'b [@@deriving bin_io]
+
+      let caller_identity =
+        Bin_prot.Shape.Uuid.of_string "a9b0d5e8-4992-11e6-a717-dfe192342aee"
+      ;;
+
+      let module_name = Some "Pooled_hashtbl"
+      let length = length
+
+      let[@inline always] iter t ~f =
+        iteri t ~f:(fun ~key ~data -> f (key, data)) [@nontail]
+      ;;
+
+      let init ~len ~next =
+        let t = create ~size:len () in
+        for _i = 0 to len - 1 do
+          let key, data = next () in
+          match find t key with
+          | None -> replace t ~key ~data
+          | Some _ -> failwith "Pooled_hashtbl.bin_read_t_: duplicate key"
+        done;
+        t
+      ;;
+    end)
+end
+
+module Provide_bin_io (Key : sig
+    type t [@@deriving bin_io]
+
+    include Key_plain with type t := t
+  end) =
+Bin_prot.Utils.Make_iterable_binable1 (struct
+    type nonrec 'v t = (Key.t, 'v) t
+    type 'v el = Key.t * 'v [@@deriving bin_io]
 
     let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "a9b0d5e8-4992-11e6-a717-dfe192342aee"
+      Bin_prot.Shape.Uuid.of_string "aa942e1a-4992-11e6-8f73-876922b0953c"
     ;;
 
     let module_name = Some "Pooled_hashtbl"
     let length = length
-    let iter t ~f = iteri t ~f:(fun ~key ~data -> f (key, data))
+
+    let[@inline always] iter t ~f =
+      iteri t ~f:(fun ~key ~data -> f (key, data)) [@nontail]
+    ;;
 
     let init ~len ~next =
-      let t = create ~size:len () in
+      let t = create ~size:len ~hashable:(Hashable.of_key (module Key)) () in
       for _i = 0 to len - 1 do
         let key, data = next () in
         match find t key with
         | None -> replace t ~key ~data
-        | Some _ -> failwith "Pooled_hashtbl.bin_read_t_: duplicate key"
+        | Some _ ->
+          failwiths
+            ~here:[%here]
+            "Pooled_hashtbl.bin_read_t: duplicate key"
+            key
+            [%sexp_of: Key.t]
       done;
       t
     ;;
   end)
-end
 
 module Make_plain_with_hashable (T : sig
-  module Key : Key_plain
+    module Key : Key_plain
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   let hashable = T.hashable
 
@@ -1169,68 +1208,39 @@ struct
   let invariant invariant_data t = invariant ignore invariant_data t
 
   include Creators (struct
-    type 'a t = T.Key.t
+      type 'a t = T.Key.t
 
-    let hashable = hashable
-  end)
+      let hashable = hashable
+    end)
 
   include Accessors
 
   let sexp_of_t sexp_of_v t = Poly.sexp_of_t T.Key.sexp_of_t sexp_of_v t
 
   module Provide_of_sexp
-    (X : sig
-      type t [@@deriving of_sexp]
-    end
-    with type t := key) =
+      (X : sig
+             type t [@@deriving of_sexp]
+           end
+           with type t := key) =
   struct
     let t_of_sexp v_of_sexp sexp = t_of_sexp X.t_of_sexp v_of_sexp sexp
   end
 
   module Provide_bin_io
-    (X : sig
-      type t [@@deriving bin_io]
-    end
-    with type t := key) =
-  Bin_prot.Utils.Make_iterable_binable1 (struct
-    module Key = struct
+      (Key' : sig
+                type t [@@deriving bin_io]
+              end
+              with type t := key) =
+  Provide_bin_io (struct
       include T.Key
-      include X
-    end
-
-    type nonrec 'a t = 'a t
-    type 'a el = Key.t * 'a [@@deriving bin_io]
-
-    let caller_identity =
-      Bin_prot.Shape.Uuid.of_string "aa942e1a-4992-11e6-8f73-876922b0953c"
-    ;;
-
-    let module_name = Some "Pooled_hashtbl"
-    let length = length
-    let iter t ~f = iteri t ~f:(fun ~key ~data -> f (key, data))
-
-    let init ~len ~next =
-      let t = create ~size:len () in
-      for _i = 0 to len - 1 do
-        let key, data = next () in
-        match find t key with
-        | None -> replace t ~key ~data
-        | Some _ ->
-          failwiths
-            ~here:[%here]
-            "Pooled_hashtbl.bin_read_t: duplicate key"
-            key
-            [%sexp_of: Key.t]
-      done;
-      t
-    ;;
-  end)
+      include Key'
+    end)
 
   module Provide_stable_witness
-    (Key' : sig
-      type t [@@deriving stable_witness]
-    end
-    with type t := key) =
+      (Key' : sig
+                type t [@@deriving stable_witness]
+              end
+              with type t := key) =
   struct
     (* I'm not sure whether it makes sense for pooled hashtbl to be used as a stable type,
        since pooling seems like an in-process thing, but in order to satisfy the entire
@@ -1252,42 +1262,42 @@ struct
 end
 
 module Make_with_hashable (T : sig
-  module Key : Key
+    module Key : Key
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   include Make_plain_with_hashable (T)
   include Provide_of_sexp (T.Key)
 end
 
 module Make_binable_with_hashable (T : sig
-  module Key : Key_binable
+    module Key : Key_binable
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   include Make_with_hashable (T)
   include Provide_bin_io (T.Key)
 end
 
 module Make_stable_with_hashable (T : sig
-  module Key : Key_stable
+    module Key : Key_stable
 
-  val hashable : Key.t Hashable.t
-end) =
+    val hashable : Key.t Hashable.t
+  end) =
 struct
   include Make_binable_with_hashable (T)
   include Provide_stable_witness (T.Key)
 end
 
 module Make_plain (Key : Key_plain) = Make_plain_with_hashable (struct
-  module Key = Key
+    module Key = Key
 
-  let hashable =
-    { Hashable.hash = Key.hash; compare = Key.compare; sexp_of_t = Key.sexp_of_t }
-  ;;
-end)
+    let hashable =
+      { Hashable.hash = Key.hash; compare = Key.compare; sexp_of_t = Key.sexp_of_t }
+    ;;
+  end)
 
 module Make (Key : Key) = struct
   include Make_plain (Key)
@@ -1295,9 +1305,9 @@ module Make (Key : Key) = struct
 end
 
 module Make_binable (Key : sig
-  include Key
-  include Binable.S with type t := t
-end) =
+    include Key
+    include Binable.S with type t := t
+  end) =
 struct
   include Make (Key)
   include Provide_bin_io (Key)
@@ -1436,3 +1446,28 @@ let quickcheck_shrinker_m__t
   [%quickcheck.shrinker: (Key.t * data) List.t]
   |> Quickcheck.Shrinker.filter_map ~f:(of_alist_option (module Key)) ~f_inverse:to_alist
 ;;
+
+let bin_shape_m__t (type t) (module Key : Key_binable with type t = t) =
+  let module M = Provide_bin_io (Key) in
+  M.bin_shape_t
+;;
+
+let bin_size_m__t (type t) (module Key : Key_binable with type t = t) =
+  let module M = Provide_bin_io (Key) in
+  M.bin_size_t
+;;
+
+let bin_write_m__t (type t) (module Key : Key_binable with type t = t) =
+  let module M = Provide_bin_io (Key) in
+  M.bin_write_t
+;;
+
+let bin_read_m__t (type t) (module Key : Key_binable with type t = t) =
+  let module M = Provide_bin_io (Key) in
+  M.bin_read_t
+;;
+
+let __bin_read_m__t__ (type t) (module Key : Key_binable with type t = t) =
+  let module M = Provide_bin_io (Key) in
+  M.__bin_read_t__
+;;
diff --git a/pooled_hashtbl/test/test_pooled_hashtbl.ml b/pooled_hashtbl/test/test_pooled_hashtbl.ml
index 24a2ecee..b664f25e 100644
--- a/pooled_hashtbl/test/test_pooled_hashtbl.ml
+++ b/pooled_hashtbl/test/test_pooled_hashtbl.ml
@@ -7,10 +7,10 @@ let%test_module _ =
       include Pooled_hashtbl
 
       include Pooled_hashtbl.Make (struct
-        include Int
+          include Int
 
-        let hash x = x
-      end)
+          let hash x = x
+        end)
     end
 
     let%test_unit "growing test/copy test" =
diff --git a/sexp_hidden_in_test/src/sexp_hidden_in_test.ml b/sexp_hidden_in_test/src/sexp_hidden_in_test.ml
index 02839861..f2a67d85 100644
--- a/sexp_hidden_in_test/src/sexp_hidden_in_test.ml
+++ b/sexp_hidden_in_test/src/sexp_hidden_in_test.ml
@@ -1,8 +1,8 @@
 open! Core
 
 module Make (M : sig
-  val am_running_test : bool
-end) =
+    val am_running_test : bool
+  end) =
 struct
   type 'a t = 'a [@@deriving bin_io, compare, equal, sexp]
 
@@ -19,16 +19,16 @@ let%test_module _ =
   (module struct
     module Turned_off = struct
       module Sexp_hidden_in_test_turned_off = Make (struct
-        let am_running_test = false
-      end)
+          let am_running_test = false
+        end)
 
       type nonrec t = int Sexp_hidden_in_test_turned_off.t [@@deriving sexp_of]
     end
 
     module Turned_on = struct
       module Sexp_hidden_in_test_turned_on = Make (struct
-        let am_running_test = true
-      end)
+          let am_running_test = true
+        end)
 
       type nonrec t = int Sexp_hidden_in_test_turned_on.t [@@deriving sexp_of]
     end
@@ -46,5 +46,5 @@ let%test_module _ =
 ;;
 
 include Make (struct
-  let am_running_test = am_running_test
-end)
+    let am_running_test = am_running_test
+  end)
diff --git a/thread_pool_cpu_affinity/src/thread_pool_cpu_affinity.ml b/thread_pool_cpu_affinity/src/thread_pool_cpu_affinity.ml
index 0f688b45..42af515a 100644
--- a/thread_pool_cpu_affinity/src/thread_pool_cpu_affinity.ml
+++ b/thread_pool_cpu_affinity/src/thread_pool_cpu_affinity.ml
@@ -3,18 +3,18 @@ open! Import
 
 module Cpuset = struct
   include Validated.Make (struct
-    type t = Int.Set.t [@@deriving sexp]
+      type t = Int.Set.t [@@deriving sexp]
 
-    let here = [%here]
+      let here = [%here]
 
-    let validate t =
-      Validate.first_failure
-        (Int.validate_lbound ~min:(Incl 1) (Set.length t))
-        (Set.to_list t
-         |> List.map ~f:Int.validate_non_negative
-         |> Validate.name_list "Thread_pool_cpuset")
-    ;;
-  end)
+      let validate t =
+        Validate.first_failure
+          (Int.validate_lbound ~min:(Incl 1) (Set.length t))
+          (Set.to_list t
+           |> List.map ~f:Int.validate_non_negative
+           |> Validate.name_list "Thread_pool_cpuset")
+      ;;
+    end)
 
   let equal t1 t2 = Int.Set.equal (t1 |> raw) (t2 |> raw)
 end
diff --git a/thread_safe_queue/bench/bench_thread_safe_queue.ml b/thread_safe_queue/bench/bench_thread_safe_queue.ml
index 743a57f8..08448b1f 100644
--- a/thread_safe_queue/bench/bench_thread_safe_queue.ml
+++ b/thread_safe_queue/bench/bench_thread_safe_queue.ml
@@ -8,30 +8,30 @@ open! Thread_safe_queue
 let%bench_fun "enqueue + dequeue_exn of immediate" =
   let t = create () in
   enqueue t ();
-  ignore (dequeue_exn t : unit);
+  ignore (dequeue t : unit Dequeue_result.t);
   Gc.full_major ();
   fun () ->
     enqueue t ();
-    ignore (dequeue_exn t : unit)
+    ignore (dequeue t : unit Dequeue_result.t)
 ;;
 
 let%bench_fun "enqueue + dequeue_exn of young object" =
   let t = create () in
   enqueue t (ref ());
-  ignore (dequeue_exn t : unit ref);
+  ignore (dequeue t : unit ref Dequeue_result.t);
   Gc.full_major ();
   fun () ->
     enqueue t (ref ());
-    ignore (dequeue_exn t : unit ref)
+    ignore (dequeue t : unit ref Dequeue_result.t)
 ;;
 
 let%bench_fun "enqueue + dequeue_exn of old object" =
   let r = ref () in
   let t = create () in
   enqueue t r;
-  ignore (dequeue_exn t : unit ref);
+  ignore (dequeue t : unit ref Dequeue_result.t);
   Gc.full_major ();
   fun () ->
     enqueue t r;
-    ignore (dequeue_exn t : unit ref)
+    ignore (dequeue t : unit ref Dequeue_result.t)
 ;;
diff --git a/thread_safe_queue/bench/dune b/thread_safe_queue/bench/dune
index 3c3de2a7..f26298e3 100644
--- a/thread_safe_queue/bench/dune
+++ b/thread_safe_queue/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name thread_safe_queue_bench)
- (libraries thread_safe_queue)
+ (libraries core thread_safe_queue)
  (preprocess
   (pps ppx_jane)))
diff --git a/thread_safe_queue/src/thread_safe_queue.ml b/thread_safe_queue/src/thread_safe_queue.ml
index 59d9cd01..5b4834bb 100644
--- a/thread_safe_queue/src/thread_safe_queue.ml
+++ b/thread_safe_queue/src/thread_safe_queue.ml
@@ -2,10 +2,11 @@
    certain conditions.  It can therefore avoid using mutexes.
 
    Given the semantics of the current OCaml runtime (and for the foreseeable future), code
-   sections documented as atomic below will never contain a context-switch.  The deciding
-   criterion is whether they contain allocations or calls to external/builtin functions.
-   If there is none, a context-switch cannot happen.  Assignments without allocations,
-   field access, pattern-matching, etc., do not trigger context-switches.
+   sections documented as atomic below will never contain a context-switch. Allocations
+   and calls to external/builtin functions can always cause a context switch. Loops and
+   calls to other functions can sometimes cause a context switch - see the documentation
+   on OCaml's "safe points". Assignments without allocations, field access,
+   pattern-matching, etc., do not trigger context-switches.
 
    Code reviewers should therefore make sure that the sections documented as atomic below
    do not violate the above assumptions.  It is prudent to disassemble the .o file (using
@@ -104,20 +105,42 @@ let[@inline never] [@specialise never] [@local never] return_unused_elt t (elt :
   ()
 ;;
 
-let[@inline never] [@specialise never] [@local never] raise_dequeue_empty t =
-  failwiths ~here:[%here] "Thread_safe_queue.dequeue_exn of empty queue" t [%sexp_of: _ t]
-;;
+module Dequeue_result = struct
+  (* It's important that dequeue does not allocate.
+     - We could accomplish this by having it raise an exception when the queue is
+       empty. But that would have poor performance in javascript (and this library is used
+       by javascript applications via incremental).
+     - We could use Uopt, as this module does internally. But using Uopt correctly is
+       subtle, so we prefer not to expose it to users.
+     - Instead we employ a local (stack allocated) return of the below type.
+  *)
+  type 'a t =
+    | Empty
+    | Not_empty of { elt : 'a }
+  [@@deriving sexp, compare]
+end
 
-let[@inline never] [@specialise never] [@local never] dequeue_exn t =
+let[@inline never] [@specialise never] [@local never] dequeue t =
   (* BEGIN ATOMIC SECTION *)
-  if t.length = 0 then raise_dequeue_empty t;
-  let elt = t.front in
-  let a = elt.value in
-  t.front <- Uopt.unsafe_value elt.next;
-  t.length <- t.length - 1;
-  (* END ATOMIC SECTION *)
-  return_unused_elt t elt;
-  Uopt.unsafe_value a
+  if t.length = 0
+  then Dequeue_result.Empty
+  else (
+    let elt = t.front in
+    let a = elt.value in
+    t.front <- Uopt.unsafe_value elt.next;
+    t.length <- t.length - 1;
+    (* END ATOMIC SECTION *)
+    return_unused_elt t elt;
+    Not_empty { elt = Uopt.unsafe_value a })
+;;
+
+let[@inline] dequeue_until_empty ~f t =
+  let keep_going = ref true in
+  while !keep_going do
+    match dequeue t with
+    | Not_empty { elt } -> f elt
+    | Empty -> keep_going := false
+  done
 ;;
 
 let clear_internal_pool t = t.unused_elts <- Uopt.none
diff --git a/thread_safe_queue/src/thread_safe_queue.mli b/thread_safe_queue/src/thread_safe_queue.mli
index 04c6eb79..eea0f74d 100644
--- a/thread_safe_queue/src/thread_safe_queue.mli
+++ b/thread_safe_queue/src/thread_safe_queue.mli
@@ -17,27 +17,35 @@ val create : unit -> 'a t
 val length : _ t -> int
 val enqueue : 'a t -> 'a -> unit
 
-(** [dequeue_exn t] raises if [length t = 0].  The idiom for dequeueing a single element
-    is:
-
-    {[
-      if length t > 0 then dequeue_exn t else ...
-    ]}
-
-    The idiom for dequeueing until empty is:
-
-    {[
-      while length t > 0 do
-        let a = dequeue_exn t in
-        ...
-      done
-    ]}
-
-    These idioms work in the presence of threads because OCaml will not context switch
-    between the [length t > 0] test and the call to [dequeue_exn].  Also, if one has only
-    a single thread calling [dequeue_exn], then the idiom is obviously OK even in the
-    presence of a context switch. *)
-val dequeue_exn : 'a t -> 'a
+module Dequeue_result : sig
+  type 'a t =
+    | Empty
+    | Not_empty of { elt : 'a }
+  [@@deriving sexp, compare]
+end
+
+(** [dequeue t] returns [Dequeue_result.Empty] if [length t = 0], and
+    [Dequeue_result.Not_empty] otherwise. To dequeue a single result, match on this
+    result. The return value is locally allocated, so this can be used safely in
+    zero_alloc code.
+
+    To dequeue until empty, use [dequeue_until_empty] below.
+
+    Note that testing the length of the queue immediately before calling [dequeue] does
+    not guarantee it will return [Not_empty].  This is because the OCaml compiler is
+    allowed to insert a polling point (also called a "safe point") at the beginning of
+    [dequeue], which may give other threads an opportunity to run.  You must always handle
+    the possibility of [Not_empty] when calling this function. *)
+val dequeue : 'a t -> 'a Dequeue_result.t
+
+(** [dequeue_until_empty ~f t] iteratively dequeues elements of [t] and applies [f] to
+    them until the queue is empty.
+
+    Recall that if you want [dequeue_until_empty]'s arguments to be locally allocated, it
+    can not be a tailcall.  To achieve this for a call to [dequeue_until_empty] in tail
+    position, mark the call with [@nontail].
+*)
+val dequeue_until_empty : f:('a -> unit) -> 'a t -> unit
 
 (** The queue maintains an internal pool of unused elements, which are used by [enqueue]
     and returned to the pool by [dequeue_exn].  [enqueue] creates a new element if the
diff --git a/thread_safe_queue/test/dune b/thread_safe_queue/test/dune
index 2cb7aab9..e00739ac 100644
--- a/thread_safe_queue/test/dune
+++ b/thread_safe_queue/test/dune
@@ -1,6 +1,6 @@
 (library
  (name thread_safe_queue_test)
- (libraries core core_unix.core_thread thread_safe_queue
-   core_unix.time_float_unix)
+ (libraries core core_unix.core_thread expect_test_helpers_core
+   thread_safe_queue core_unix.time_float_unix)
  (preprocess
   (pps ppx_jane)))
diff --git a/thread_safe_queue/test/test_thread_safe_queue.ml b/thread_safe_queue/test/test_thread_safe_queue.ml
index b49d9bad..850b8d89 100644
--- a/thread_safe_queue/test/test_thread_safe_queue.ml
+++ b/thread_safe_queue/test/test_thread_safe_queue.ml
@@ -4,160 +4,228 @@ module Time = Time_float_unix
 
 let%test_module "Thread_safe_queue" =
   (module (
-             struct
-               let () = Debug.should_print_backtrace := false
-
-               open Thread_safe_queue
-
-               module Private = struct
-                 module Uopt = struct
-                   include Private.Uopt
-
-                   let%test _ = is_none none
-                   let%test _ = is_some (some ())
-                 end
-               end
-
-               type nonrec 'a t = 'a t
-
-               let invariant = invariant
-               let sexp_of_t = sexp_of_t
-               let%test_unit _ = ignore (create () |> [%sexp_of: unit t] : Sexp.t)
-
-               let%test_unit _ =
-                 let t = create () in
-                 enqueue t 1;
-                 enqueue t 2;
-                 enqueue t 3;
-                 ignore (t |> [%sexp_of: int t] : Sexp.t)
-               ;;
-
-               let create = create
-               let dequeue_exn = dequeue_exn
-               let enqueue = enqueue
-               let length = length
-
-               let%test_unit _ =
-                 let t = create () in
-                 invariant ignore t;
-                 assert (length t = 0);
-                 enqueue t ();
-                 invariant ignore t;
-                 assert (length t = 1);
-                 enqueue t ();
-                 invariant ignore t;
-                 assert (length t = 2);
-                 dequeue_exn t;
-                 invariant ignore t;
-                 assert (length t = 1);
-                 dequeue_exn t;
-                 invariant ignore t;
-                 assert (length t = 0)
-               ;;
-
-               let%test_unit _ =
-                 (* invariant passes with element from pool in the queue *)
-                 let t = create () in
-                 for _ = 1 to 3 do
-                   enqueue t ()
-                 done;
-                 for _ = 1 to 2 do
-                   dequeue_exn t
-                 done;
-                 enqueue t ();
-                 invariant ignore t
-               ;;
-
-               let%test_unit _ =
-                 let verbose = false in
-                 let sec = Time.Span.of_sec in
-                 let quick_pause () = Time.pause (sec 0.00001) in
-                 let num_elts = 100_000 in
-                 let batch_size = 10_000 in
-                 for num_enqueuers = 1 to 1 do
-                   for num_dequeuers = 1 to 1 do
-                     if verbose
-                     then
-                       Debug.eprints
-                         "testing"
-                         (num_enqueuers, num_dequeuers)
-                         [%sexp_of: int * int];
-                     let enqueue_counts = Array.create ~len:num_enqueuers 0 in
-                     let dequeue_counts = Array.create ~len:num_dequeuers 0 in
-                     let t = create () in
-                     let all_threads = ref [] in
-                     let create_thread f =
-                       let thread =
-                         Thread.create f () ~on_uncaught_exn:`Print_to_stderr
-                       in
-                       all_threads := thread :: !all_threads
-                     in
-                     let num_enqueues = ref 0 in
-                     let num_dequeues = ref 0 in
-                     create_thread (fun () ->
-                       while !num_enqueues < num_elts || !num_dequeues < num_elts do
-                         if verbose
-                         then
-                           Debug.eprints
-                             "current"
-                             (!num_enqueues, !num_dequeues)
-                             [%sexp_of: int * int];
-                         Time.pause (sec 1.)
-                       done);
-                     for i = 0 to num_enqueuers - 1 do
-                       create_thread (fun () ->
-                         let num_in_batch = ref 0 in
-                         while !num_enqueues < num_elts do
-                           num_in_batch := 0;
-                           while !num_enqueues < num_elts && !num_in_batch < batch_size do
-                             incr num_in_batch;
-                             incr num_enqueues;
-                             enqueue_counts.(i) <- enqueue_counts.(i) + 1;
-                             enqueue t ()
-                           done;
-                           quick_pause ()
-                         done)
-                     done;
-                     for i = 0 to num_dequeuers - 1 do
-                       create_thread (fun () ->
-                         let num_in_batch = ref 0 in
-                         while !num_dequeues < num_elts do
-                           num_in_batch := 0;
-                           while !num_dequeues < num_elts && !num_in_batch < batch_size do
-                             if length t = 0
-                             then quick_pause ()
-                             else (
-                               dequeue_exn t;
-                               incr num_dequeues;
-                               dequeue_counts.(i) <- dequeue_counts.(i) + 1)
-                           done
-                         done)
-                     done;
-                     List.iter !all_threads ~f:Thread.join;
-                     if verbose
-                     then
-                       Debug.eprints
-                         "counts"
-                         (enqueue_counts, dequeue_counts)
-                         [%sexp_of: int array * int array]
-                   done
-                 done
-               ;;
-
-               let clear_internal_pool = clear_internal_pool
-
-               let%test_unit _ =
-                 let t = create () in
-                 clear_internal_pool t;
-                 enqueue t ();
-                 clear_internal_pool t;
-                 dequeue_exn t;
-                 clear_internal_pool t;
-                 enqueue t ();
-                 clear_internal_pool t
-               ;;
-             end
-             (* This signature constraint is here to remind us to add a unit test whenever the
+  struct
+    let () = Debug.should_print_backtrace := false
+
+    open Thread_safe_queue
+
+    module Private = struct
+      module Uopt = struct
+        include Private.Uopt
+
+        let%test _ = is_none none
+        let%test _ = is_some (some ())
+      end
+    end
+
+    type nonrec 'a t = 'a t
+
+    let invariant = invariant
+    let sexp_of_t = sexp_of_t
+    let%test_unit _ = ignore (create () |> [%sexp_of: unit t] : Sexp.t)
+
+    let%test_unit _ =
+      let t = create () in
+      enqueue t 1;
+      enqueue t 2;
+      enqueue t 3;
+      ignore (t |> [%sexp_of: int t] : Sexp.t)
+    ;;
+
+    module Dequeue_result = struct
+      type 'a t = 'a Dequeue_result.t =
+        | Empty
+        | Not_empty of { elt : 'a }
+      [@@deriving sexp, compare]
+    end
+
+    let create = create
+    let dequeue = dequeue
+
+    let dequeue_exn t =
+      match dequeue t with
+      | Not_empty { elt } -> elt
+      | Empty -> raise_s [%sexp "dequeue_exn of empty queue"]
+    ;;
+
+    let enqueue = enqueue
+    let length = length
+
+    let%test_unit _ =
+      let t = create () in
+      invariant ignore t;
+      assert (length t = 0);
+      enqueue t ();
+      invariant ignore t;
+      assert (length t = 1);
+      enqueue t ();
+      invariant ignore t;
+      assert (length t = 2);
+      dequeue_exn t;
+      invariant ignore t;
+      assert (length t = 1);
+      dequeue_exn t;
+      invariant ignore t;
+      assert (length t = 0)
+    ;;
+
+    let%test_unit _ =
+      (* invariant passes with element from pool in the queue *)
+      let t = create () in
+      for _ = 1 to 3 do
+        enqueue t ()
+      done;
+      for _ = 1 to 2 do
+        dequeue_exn t
+      done;
+      enqueue t ();
+      invariant ignore t
+    ;;
+
+    let%test_unit _ =
+      let verbose = false in
+      let sec = Time.Span.of_sec in
+      let quick_pause () = Time.pause (sec 0.00001) in
+      let num_elts = 100_000 in
+      let batch_size = 10_000 in
+      for num_enqueuers = 1 to 1 do
+        for num_dequeuers = 1 to 1 do
+          if verbose
+          then
+            Debug.eprints "testing" (num_enqueuers, num_dequeuers) [%sexp_of: int * int];
+          let enqueue_counts = Array.create ~len:num_enqueuers 0 in
+          let dequeue_counts = Array.create ~len:num_dequeuers 0 in
+          let t = create () in
+          let all_threads = ref [] in
+          let create_thread f =
+            let thread = Thread.create f () ~on_uncaught_exn:`Print_to_stderr in
+            all_threads := thread :: !all_threads
+          in
+          let num_enqueues = ref 0 in
+          let num_dequeues = ref 0 in
+          create_thread (fun () ->
+            while !num_enqueues < num_elts || !num_dequeues < num_elts do
+              if verbose
+              then
+                Debug.eprints
+                  "current"
+                  (!num_enqueues, !num_dequeues)
+                  [%sexp_of: int * int];
+              Time.pause (sec 1.)
+            done);
+          for i = 0 to num_enqueuers - 1 do
+            create_thread (fun () ->
+              let num_in_batch = ref 0 in
+              while !num_enqueues < num_elts do
+                num_in_batch := 0;
+                while !num_enqueues < num_elts && !num_in_batch < batch_size do
+                  incr num_in_batch;
+                  incr num_enqueues;
+                  enqueue_counts.(i) <- enqueue_counts.(i) + 1;
+                  enqueue t ()
+                done;
+                quick_pause ()
+              done)
+          done;
+          for i = 0 to num_dequeuers - 1 do
+            create_thread (fun () ->
+              let num_in_batch = ref 0 in
+              while !num_dequeues < num_elts do
+                num_in_batch := 0;
+                while !num_dequeues < num_elts && !num_in_batch < batch_size do
+                  if length t = 0
+                  then quick_pause ()
+                  else (
+                    dequeue_exn t;
+                    incr num_dequeues;
+                    dequeue_counts.(i) <- dequeue_counts.(i) + 1)
+                done
+              done)
+          done;
+          List.iter !all_threads ~f:Thread.join;
+          if verbose
+          then
+            Debug.eprints
+              "counts"
+              (enqueue_counts, dequeue_counts)
+              [%sexp_of: int array * int array]
+        done
+      done
+    ;;
+
+    let clear_internal_pool = clear_internal_pool
+
+    let%test_unit _ =
+      let t = create () in
+      clear_internal_pool t;
+      enqueue t ();
+      clear_internal_pool t;
+      dequeue_exn t;
+      clear_internal_pool t;
+      enqueue t ();
+      clear_internal_pool t
+    ;;
+
+    let dequeue_until_empty = dequeue_until_empty
+
+    let%test_unit _ =
+      let t = create () in
+      enqueue t ();
+      enqueue t ();
+      enqueue t ();
+      let r = ref 0 in
+      dequeue_until_empty ~f:(fun () -> incr r) t;
+      assert (length t = 0);
+      assert (!r = 3)
+    ;;
+
+    (* Allocation tests *)
+    let%expect_test ("dequeue_until_empty does not allocate at all with inlining" [@tags
+                                                                                    "fast-flambda"])
+      =
+      let t = create () in
+      for _i = 1 to 100 do
+        enqueue t ()
+      done;
+      let r = Sys.opaque_identity (Random.int 42) in
+      Expect_test_helpers_core.require_no_allocation (fun () ->
+        (dequeue_until_empty [@inlined hint]) t ~f:(fun [@inline] () ->
+          let (_ : int) = Sys.opaque_identity (r + 1) in
+          ()))
+    ;;
+
+    let%expect_test "dequeue_until_empty only allocates locally without inlining" =
+      let t = create () in
+      for _i = 1 to 100 do
+        enqueue t ()
+      done;
+      let r = Sys.opaque_identity (Random.int 42) in
+      Expect_test_helpers_core.require_no_allocation (fun () ->
+        (dequeue_until_empty [@inlined never]) t ~f:(fun () ->
+          let (_ : int) = Sys.opaque_identity (r + 1) in
+          ()) [@nontail])
+    ;;
+
+    (* Dequeueing from an empty queue yields "Empty" *)
+    let%test_unit _ =
+      let t = create () in
+      match dequeue t with
+      | Dequeue_result.Empty -> ()
+      | Not_empty _ -> assert false
+    ;;
+
+    let%test_unit _ =
+      let t = create () in
+      enqueue t ();
+      (match dequeue t with
+       | Dequeue_result.Empty -> assert false
+       | Not_empty { elt } -> elt);
+      match dequeue t with
+      | Dequeue_result.Empty -> ()
+      | Not_empty _ -> assert false
+    ;;
+  end
+  (* This signature constraint is here to remind us to add a unit test whenever the
       interface to [Thread_safe_queue] changes. *) :
-               module type of Thread_safe_queue))
+    module type of Thread_safe_queue))
 ;;
diff --git a/timing_wheel/bench/dune b/timing_wheel/bench/dune
index b04338cf..a07d2b0b 100644
--- a/timing_wheel/bench/dune
+++ b/timing_wheel/bench/dune
@@ -1,5 +1,5 @@
 (library
  (name timing_wheel_bench)
- (libraries timing_wheel)
+ (libraries core timing_wheel)
  (preprocess
   (pps ppx_jane)))
diff --git a/timing_wheel/src/timing_wheel.ml b/timing_wheel/src/timing_wheel.ml
index 2e59beeb..10dea830 100644
--- a/timing_wheel/src/timing_wheel.ml
+++ b/timing_wheel/src/timing_wheel.ml
@@ -525,12 +525,12 @@ end = struct
         for the slots in the pool tuple representing a level element. *)
     type 'a pool_slots =
       ( Key.t
-      , Time_ns.t
-      , 'a
-      , int
-      , 'a pool_slots Pointer.t
-      , 'a pool_slots Pointer.t )
-      Pool.Slots.t6
+        , Time_ns.t
+        , 'a
+        , int
+        , 'a pool_slots Pointer.t
+        , 'a pool_slots Pointer.t )
+        Pool.Slots.t6
     [@@deriving sexp_of]
 
     type 'a t = 'a pool_slots Pointer.t [@@deriving sexp_of]
@@ -866,10 +866,10 @@ end = struct
         (let r = ref [] in
          internal_iter t ~f:(fun elt ->
            r
-             := { Pretty.Elt.key = Internal_elt.key pool elt
-                ; value = Internal_elt.value pool elt
-                }
-                :: !r);
+           := { Pretty.Elt.key = Internal_elt.key pool elt
+              ; value = Internal_elt.value pool elt
+              }
+              :: !r);
          List.rev !r)
     }
   ;;
@@ -925,9 +925,9 @@ end = struct
                assert (
                  length
                  = Array.fold level.slots ~init:0 ~f:(fun n elt ->
-                     if Internal_elt.is_null elt
-                     then n
-                     else n + Internal_elt.length pool elt))))
+                   if Internal_elt.is_null elt
+                   then n
+                   else n + Internal_elt.length pool elt))))
           ~min_allowed_key:
             (check (fun min_allowed_key ->
                assert (Key.( >= ) min_allowed_key Key.zero);
@@ -1213,7 +1213,7 @@ end = struct
     done;
     level.min_allowed_key <- desired_min_allowed_key;
     level.max_allowed_key
-      <- Key.add_clamp_to_max desired_min_allowed_key level.diff_max_min_allowed_key
+    <- Key.add_clamp_to_max desired_min_allowed_key level.diff_max_min_allowed_key
   ;;
 
   module Increase_min_allowed_key_result = struct
@@ -1277,38 +1277,40 @@ end = struct
             index
             (bits_per_slot, max_level_min_allowed_key, levels)
             (level_bits : Num_key_bits.t)
-            ->
-        let keys_per_slot = Key.num_keys bits_per_slot in
-        let diff_max_min_allowed_key =
-          compute_diff_max_min_allowed_key ~level_bits ~bits_per_slot
-        in
-        let min_key_in_same_slot_mask = Min_key_in_same_slot_mask.create ~bits_per_slot in
-        let min_allowed_key =
-          Key.min_key_in_same_slot max_level_min_allowed_key min_key_in_same_slot_mask
-        in
-        let max_allowed_key =
-          Key.add_clamp_to_max min_allowed_key diff_max_min_allowed_key
-        in
-        let level =
-          { Level.index
-          ; bits = level_bits
-          ; slots_mask = Slots_mask.create ~level_bits
-          ; bits_per_slot
-          ; keys_per_slot
-          ; min_key_in_same_slot_mask
-          ; diff_max_min_allowed_key
-          ; length = 0
-          ; min_allowed_key
-          ; max_allowed_key
-          ; slots =
-              Array.create
-                ~len:(Int63.to_int_exn (Num_key_bits.pow2 level_bits))
-                (Internal_elt.null ())
-          }
-        in
-        ( Num_key_bits.( + ) level_bits bits_per_slot
-        , Key.succ_clamp_to_max max_allowed_key
-        , level :: levels ))
+          ->
+          let keys_per_slot = Key.num_keys bits_per_slot in
+          let diff_max_min_allowed_key =
+            compute_diff_max_min_allowed_key ~level_bits ~bits_per_slot
+          in
+          let min_key_in_same_slot_mask =
+            Min_key_in_same_slot_mask.create ~bits_per_slot
+          in
+          let min_allowed_key =
+            Key.min_key_in_same_slot max_level_min_allowed_key min_key_in_same_slot_mask
+          in
+          let max_allowed_key =
+            Key.add_clamp_to_max min_allowed_key diff_max_min_allowed_key
+          in
+          let level =
+            { Level.index
+            ; bits = level_bits
+            ; slots_mask = Slots_mask.create ~level_bits
+            ; bits_per_slot
+            ; keys_per_slot
+            ; min_key_in_same_slot_mask
+            ; diff_max_min_allowed_key
+            ; length = 0
+            ; min_allowed_key
+            ; max_allowed_key
+            ; slots =
+                Array.create
+                  ~len:(Int63.to_int_exn (Num_key_bits.pow2 level_bits))
+                  (Internal_elt.null ())
+            }
+          in
+          ( Num_key_bits.( + ) level_bits bits_per_slot
+          , Key.succ_clamp_to_max max_allowed_key
+          , level :: levels ))
     in
     { length = 0
     ; pool = Internal_elt.Pool.create ?capacity ()
@@ -1432,6 +1434,7 @@ type 'a t =
 type 'a timing_wheel = 'a t
 type 'a t_now = 'a t
 
+let[@zero_alloc] now t = t.now
 let sexp_of_t_now _ t = [%sexp (t.now : Time_ns.t)]
 let alarm_precision t = Config.alarm_precision t.config
 
diff --git a/timing_wheel/src/timing_wheel_intf.ml b/timing_wheel/src/timing_wheel_intf.ml
index e2e02ad8..927a0dd1 100644
--- a/timing_wheel/src/timing_wheel_intf.ml
+++ b/timing_wheel/src/timing_wheel_intf.ml
@@ -131,7 +131,7 @@ module type Alarm_precision = sig
   include Equal.S with type t := t
 
   val of_span : Time_ns.Span.t -> t
-    [@@deprecated "[since 2018-01] Use [of_span_floor_pow2_ns]"]
+  [@@deprecated "[since 2018-01] Use [of_span_floor_pow2_ns]"]
 
   (** [of_span_floor_pow2_ns span] returns the largest alarm precision less than or equal
       to [span] that is a power of two number of nanoseconds. *)
@@ -284,7 +284,7 @@ module type Timing_wheel = sig
   (** Accessors *)
   val alarm_precision : _ t -> Time_ns.Span.t
 
-  val now : _ t -> Time_ns.t
+  val now : _ t -> Time_ns.t [@@zero_alloc]
   val start : _ t -> Time_ns.t
 
   (** One can think of a timing wheel as a set of alarms.  Here are various container
diff --git a/timing_wheel/test/test_timing_wheel.ml b/timing_wheel/test/test_timing_wheel.ml
index 4e710f0a..346ef78c 100644
--- a/timing_wheel/test/test_timing_wheel.ml
+++ b/timing_wheel/test/test_timing_wheel.ml
@@ -96,15 +96,14 @@ module Alarm_precision = struct
       ; one_nanosecond
       ]
       ~f:(fun t ->
-      require [%here] (equal t (t |> to_span |> of_span_floor_pow2_ns));
-      if Time_ns.Span.( > ) (t |> to_span) Time_ns.Span.nanosecond
-      then
-        require
-          [%here]
-          (equal
-             t
-             (Time_ns.Span.( + ) (t |> to_span) Time_ns.Span.nanosecond
-              |> of_span_floor_pow2_ns)));
+        require (equal t (t |> to_span |> of_span_floor_pow2_ns));
+        if Time_ns.Span.( > ) (t |> to_span) Time_ns.Span.nanosecond
+        then
+          require
+            (equal
+               t
+               (Time_ns.Span.( + ) (t |> to_span) Time_ns.Span.nanosecond
+                |> of_span_floor_pow2_ns)));
     List.iter [ 1.; 1E-3; 1E-6 ] ~f:(fun span ->
       let span = Time_ns.Span.of_sec span in
       print_s
@@ -141,8 +140,8 @@ let%expect_test _ =
 
 let%expect_test "invalid level bits" =
   let test level_bits =
-    require_does_raise [%here] (fun () -> Level_bits.create_exn level_bits);
-    require_does_raise [%here] ~hide_positions:true (fun () ->
+    require_does_raise (fun () -> Level_bits.create_exn level_bits);
+    require_does_raise ~hide_positions:true (fun () ->
       [%of_sexp: Level_bits.t] ([%sexp_of: int list] level_bits))
   in
   test [];
@@ -257,7 +256,6 @@ let%expect_test "[Level_bits.num_bits]" =
     print_s [%sexp (Level_bits.num_bits level_bits : int)];
     let sexp = [%sexp (level_bits : Level_bits.t)] in
     require_equal
-      [%here]
       (module Sexp)
       sexp
       (sexp |> [%of_sexp: Level_bits.t] |> [%sexp_of: Level_bits.t])
@@ -278,8 +276,7 @@ let create_config ?extend_to_max_num_bits ?level_bits ~alarm_precision () =
 ;;
 
 let%expect_test "[Config.create] with negative alarm precision" =
-  require_does_raise [%here] (fun () ->
-    create_config ~alarm_precision:(gibi_nanos (-1.)) ());
+  require_does_raise (fun () -> create_config ~alarm_precision:(gibi_nanos (-1.)) ());
   [%expect
     {|
     ("[Alarm_precision.of_span_floor_pow2_ns] got non-positive span"
@@ -288,7 +285,7 @@ let%expect_test "[Config.create] with negative alarm precision" =
 ;;
 
 let%expect_test "[Config.create] with zero alarm precision" =
-  require_does_raise [%here] (fun () -> create_config ~alarm_precision:(gibi_nanos 0.) ());
+  require_does_raise (fun () -> create_config ~alarm_precision:(gibi_nanos 0.) ());
   [%expect
     {| ("[Alarm_precision.of_span_floor_pow2_ns] got non-positive span" (span 0s)) |}]
 ;;
@@ -308,7 +305,7 @@ let%expect_test "[Config.durations]" =
               ~alarm_precision:(gibi_nanos 1.)
               ~level_bits
               ())
-          : Time_ns.Span.t list)]
+         : Time_ns.Span.t list)]
   in
   durations [ 1 ];
   [%expect {| (2.147483648s) |}];
@@ -382,7 +379,7 @@ let%expect_test "[level_bits], [config], and [max_allowed_alarm_time]" =
                 (config : Config.t)
                 ~max_allowed_alarm_time:
                   (max_allowed_alarm_time (create ~config ~start:Time_ns.epoch)
-                    : Time_ns.t)]));
+                   : Time_ns.t)]));
   [%expect
     {|
     ((level_bits (11 10 10 10 10 10 1))
@@ -486,7 +483,6 @@ let%expect_test "[min_allowed_alarm_interval_num], [max_allowed_alarm_interval_n
   let test level_bits =
     let t = create_unit () ~level_bits in
     require_equal
-      [%here]
       (module Interval_num)
       (min_allowed_alarm_interval_num t)
       Interval_num.zero;
@@ -538,8 +534,8 @@ let%expect_test "[min_allowed_alarm_interval_num], [max_allowed_alarm_interval_n
 
 let%expect_test "[is_empty], [interval_num], [length], [mem]" =
   let t = create_unit () ~level_bits:[ 1 ] in
-  require [%here] (is_empty t);
-  require [%here] (length t = 0);
+  require (is_empty t);
+  require (length t = 0);
   let a1 = add_at_interval_num t ~at:Interval_num.zero () in
   let a2 = add_at_interval_num t ~at:Interval_num.zero () in
   let show () =
@@ -550,10 +546,10 @@ let%expect_test "[is_empty], [interval_num], [length], [mem]" =
           ~is_empty:(is_empty t : bool)
           ~interval_num1:
             (Or_error.try_with (fun () -> Alarm.interval_num t a1)
-              : Interval_num.t Or_error.t)
+             : Interval_num.t Or_error.t)
           ~interval_num2:
             (Or_error.try_with (fun () -> Alarm.interval_num t a2)
-              : Interval_num.t Or_error.t)
+             : Interval_num.t Or_error.t)
           ~mem1:(mem t a1 : bool)
           ~mem2:(mem t a2 : bool)]
   in
@@ -589,7 +585,7 @@ let%expect_test "[is_empty], [interval_num], [length], [mem]" =
      (mem1 false)
      (mem2 true))
     |}];
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     reschedule_at_interval_num t a1 ~at:(Interval_num.of_int 1));
   [%expect {| (Failure "Timing_wheel cannot reschedule alarm not in timing wheel") |}];
   remove t a2;
@@ -625,7 +621,7 @@ let%expect_test "[add] failures" =
       ; Interval_num.succ (max_allowed_alarm_interval_num t)
       ; Interval_num.max_value
       ]
-      ~f:(fun at -> require_does_raise [%here] (fun () -> add ~at))
+      ~f:(fun at -> require_does_raise (fun () -> add ~at))
   in
   check_adds_fail ();
   [%expect
@@ -745,7 +741,7 @@ let%expect_test "[advance_clock] to max interval num" =
   let add ~at = ignore (add_at_interval_num t ~at () : _ Alarm.t) in
   add ~at:Interval_num.zero;
   add ~at:Interval_num.one;
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     advance_clock_to_interval_num t ~to_:Interval_num.max_value ~handle_fired:ignore);
   [%expect
     {|
@@ -786,10 +782,10 @@ let%expect_test "[advance_clock_to_interval_num]" =
     results.(0) <- [ [] ];
     for i = 1 to n do
       results.(i)
-        <- List.concat
-             (List.init i ~f:(fun j ->
-                let first = j + 1 in
-                List.map results.(i - first) ~f:(fun rest -> first :: rest)))
+      <- List.concat
+           (List.init i ~f:(fun j ->
+              let first = j + 1 in
+              List.map results.(i - first) ~f:(fun rest -> first :: rest)))
     done;
     results.(n)
   in
@@ -823,12 +819,10 @@ let%expect_test "[advance_clock_to_interval_num]" =
         ~to_:initial_min_allowed_interval_num
         ~handle_fired:ignore;
       require_equal
-        [%here]
         (module Interval_num)
         (min_allowed_alarm_interval_num t)
         initial_min_allowed_interval_num;
       require
-        [%here]
         (Interval_num.( >= )
            (max_allowed_alarm_interval_num t)
            (Interval_num.add
@@ -850,7 +844,7 @@ let%expect_test "[advance_clock_to_interval_num]" =
       List.iter interval_nums ~f:(fun at ->
         ignore (add_at_interval_num t ~at () : _ Alarm.t);
         incr n;
-        require [%here] (length t = !n));
+        require (length t = !n));
       let removed = ref [] in
       while length t > 0 do
         let interval_nums_removed =
@@ -863,12 +857,10 @@ let%expect_test "[advance_clock_to_interval_num]" =
         in
         removed := interval_nums_removed @ !removed;
         List.iter interval_nums_removed ~f:(fun interval_num ->
-          require
-            [%here]
-            (Interval_num.( < ) interval_num (min_allowed_alarm_interval_num t)))
+          require (Interval_num.( < ) interval_num (min_allowed_alarm_interval_num t)))
       done;
       let interval_nums_removed = List.sort !removed ~compare:Interval_num.compare in
-      require [%here] (Poly.equal interval_nums_removed interval_nums)
+      require (Poly.equal interval_nums_removed interval_nums)
     with
     | exn -> failwiths ~here:[%here] "failure" (exn, t) [%sexp_of: exn * _ t]
   in
@@ -877,14 +869,14 @@ let%expect_test "[advance_clock_to_interval_num]" =
   List.iter
     Initial_min_allowed_interval_num.all
     ~f:(fun initial_min_allowed_interval_num ->
-    for step = 1 to 1 lsl num_bits do
-      List.iter all_sums ~f:(fun level_bits ->
-        test
-          ~num_bits
-          ~level_bits
-          ~initial_min_allowed_interval_num
-          ~step:(Interval_num.Span.of_int step))
-    done);
+      for step = 1 to 1 lsl num_bits do
+        List.iter all_sums ~f:(fun level_bits ->
+          test
+            ~num_bits
+            ~level_bits
+            ~initial_min_allowed_interval_num
+            ~step:(Interval_num.Span.of_int step))
+      done);
   print_s [%message (num_tests : int ref)];
   [%expect {| (num_tests 4_096) |}]
 ;;
@@ -897,20 +889,17 @@ end
 
 let%expect_test "[advance_clock]" =
   let t = create_unit () ~level_bits:[ 1; 1; 1; 1 ] in
-  require [%here] (is_none (min_alarm_interval_num t));
+  require (is_none (min_alarm_interval_num t));
   let _elt = add_at_interval_num t ~at:Interval_num.zero () in
   require_equal
-    [%here]
     (module Interval_num_option)
     (min_alarm_interval_num t)
     (Some Interval_num.zero);
   let max_interval_num = 10 in
   for interval_num = 1 to max_interval_num do
     let at = Interval_num.of_int interval_num in
-    require_does_not_raise [%here] (fun () ->
-      ignore (add_at_interval_num t ~at () : _ Alarm.t));
+    require_does_not_raise (fun () -> ignore (add_at_interval_num t ~at () : _ Alarm.t));
     require_equal
-      [%here]
       (module Interval_num_option)
       (min_alarm_interval_num t)
       (Some Interval_num.zero)
@@ -921,14 +910,9 @@ let%expect_test "[advance_clock]" =
        advance_clock_to_interval_num_return_removed_interval_nums t ~to_:interval_num
      with
      | [ interval_num' ] ->
-       require_equal
-         [%here]
-         (module Interval_num)
-         interval_num'
-         (Interval_num.pred interval_num)
-     | _ -> require [%here] false);
+       require_equal (module Interval_num) interval_num' (Interval_num.pred interval_num)
+     | _ -> require false);
     require_equal
-      [%here]
       (module Interval_num_option)
       (min_alarm_interval_num t)
       (if Interval_num.( <= ) interval_num (Interval_num.of_int max_interval_num)
@@ -950,7 +934,6 @@ let%expect_test "[min_alarm_interval_num]" =
     let interval_num = Alarm.interval_num t elt in
     remove t elt;
     require_equal
-      [%here]
       (module Interval_num_option)
       (min_alarm_interval_num t)
       (if Interval_num.( < ) interval_num max_interval_num
@@ -994,7 +977,7 @@ let%expect_test "[iter]" =
     List.sort elts ~compare:(fun elt1 elt2 ->
       Interval_num.compare (Alarm.interval_num t elt1) (Alarm.interval_num t elt2))
   in
-  require [%here] (List.equal phys_equal (sort !elts) (sort !elts'))
+  require (List.equal phys_equal (sort !elts) (sort !elts'))
 ;;
 
 let%expect_test "start after epoch" =
@@ -1004,7 +987,7 @@ let%expect_test "start after epoch" =
 
 let%expect_test "invalid alarm precision" =
   let test alarm_precision =
-    require_does_raise [%here] (fun () -> create_unit ~alarm_precision ())
+    require_does_raise (fun () -> create_unit ~alarm_precision ())
   in
   test (gibi_nanos (-1.));
   [%expect
@@ -1030,7 +1013,7 @@ let%expect_test "[Private.interval_num_internal]" =
                     (Alarm_precision.of_span_floor_pow2_ns
                        (Time_ns.Span.of_int63_ns (Int63.of_int 4)))
                   ~time:(Time_ns.of_int_ns_since_epoch time))
-              : int)]
+             : int)]
   done;
   [%expect
     {|
@@ -1059,7 +1042,7 @@ let%expect_test "[Private.interval_num_internal]" =
 
 let%expect_test "[interval_num_start], [interval_start]" =
   let t = create_unit () in
-  require [%here] (not (mem t (Alarm.null ())));
+  require (not (mem t (Alarm.null ())));
   let start = start t in
   let test after =
     let time = Time_ns.add start (gibi_nanos after) in
@@ -1072,7 +1055,7 @@ let%expect_test "[interval_num_start], [interval_start]" =
           (interval_num : Interval_num.t)
           (interval_num_start : Time_ns.t)
           (interval_start : Time_ns.t)];
-    require [%here] (Time_ns.equal interval_num_start interval_start)
+    require (Time_ns.equal interval_num_start interval_start)
   in
   test 0.;
   [%expect
@@ -1160,7 +1143,6 @@ let%expect_test "min alarm at [max_time]" =
       ignore (add t ~at:max_time () : _ Alarm.t);
       print_s [%message "" (advance_to_max : bool) (ns : int)];
       require_equal
-        [%here]
         (module Interval_num)
         (min_alarm_interval_num_exn t)
         (interval_num t max_time)));
@@ -1181,7 +1163,7 @@ let%expect_test "[advance_clock ~to_:max_time]" =
   List.iter [ 1; 2; 4 ] ~f:(fun ns ->
     let alarm_precision = Time_ns.Span.scale_int Time_ns.Span.nanosecond ns in
     for level0_bits = 1 to 3 do
-      require_does_not_raise [%here] ~cr:CR_soon (fun () ->
+      require_does_not_raise ~cr:CR_soon (fun () ->
         let t =
           create_unit
             ~alarm_precision
@@ -1196,7 +1178,7 @@ let%expect_test "[advance_clock ~to_:max_time]" =
                t
                ~at:(Time_ns.sub max_time (Time_ns.Span.of_int_ns i))
                (fun () -> print_s [%message "alarm" (i : int)])
-              : _ Alarm.t)
+             : _ Alarm.t)
         done;
         for i = 10 downto 0 do
           print_s [%message "advance" (i : int)];
@@ -1412,19 +1394,22 @@ let%expect_test "[is_empty], [length]" =
     print_s [%message "" ~is_empty:(is_empty t : bool) ~length:(length t : int)]
   in
   show ();
-  [%expect {|
+  [%expect
+    {|
     ((is_empty true)
      (length   0))
     |}];
   let alarm = add t ~at:(now t) () in
   show ();
-  [%expect {|
+  [%expect
+    {|
     ((is_empty false)
      (length   1))
     |}];
   remove t alarm;
   show ();
-  [%expect {|
+  [%expect
+    {|
     ((is_empty true)
      (length   0))
     |}]
@@ -1432,19 +1417,19 @@ let%expect_test "[is_empty], [length]" =
 
 let%expect_test "[iter]" =
   let t = create_unit () in
-  iter t ~f:(fun _ -> require [%here] false);
+  iter t ~f:(fun _ -> require false);
   let alarm1 = add t ~at:(now t) () in
-  iter t ~f:(fun alarm -> require [%here] (phys_equal alarm alarm1));
+  iter t ~f:(fun alarm -> require (phys_equal alarm alarm1));
   let alarm2 = add t ~at:(now t) () in
   let r = ref 0 in
   iter t ~f:(fun alarm ->
-    require [%here] (phys_equal alarm alarm1 || phys_equal alarm alarm2);
+    require (phys_equal alarm alarm1 || phys_equal alarm alarm2);
     incr r);
   print_s [%message (r : int ref)];
   [%expect {| (r 2) |}];
   remove t alarm1;
   remove t alarm2;
-  iter t ~f:(fun _ -> require [%here] false)
+  iter t ~f:(fun _ -> require false)
 ;;
 
 let%expect_test "access to a removed alarm doesn't segfault" =
@@ -1460,11 +1445,11 @@ let%expect_test "access to a removed alarm doesn't segfault" =
   remove t alarm;
   show_mem ();
   [%expect {| false |}];
-  require_does_raise [%here] (fun _ -> Alarm.interval_num t alarm);
+  require_does_raise (fun _ -> Alarm.interval_num t alarm);
   [%expect {| "Timing_wheel got invalid alarm" |}];
-  require_does_raise [%here] (fun _ -> Alarm.at t alarm);
+  require_does_raise (fun _ -> Alarm.at t alarm);
   [%expect {| "Timing_wheel got invalid alarm" |}];
-  require_does_raise [%here] (fun _ -> Alarm.value t alarm);
+  require_does_raise (fun _ -> Alarm.value t alarm);
   [%expect {| "Timing_wheel got invalid alarm" |}]
 ;;
 
@@ -1495,7 +1480,7 @@ let test_reschedule reschedule =
   reschedule t alarm1 ~at:(epoch_plus 15.);
   show ();
   print_endline "Advance time past alarm1's original time; nothing fires.";
-  advance_clock t ~to_:(epoch_plus 7.) ~handle_fired:(fun _ -> require [%here] false);
+  advance_clock t ~to_:(epoch_plus 7.) ~handle_fired:(fun _ -> require false);
   show ();
   print_endline "Reschedule alarm1 before alarm2 again; alarm1 becomes next.";
   reschedule t alarm1 ~at:(epoch_plus 8.);
@@ -1504,13 +1489,13 @@ let test_reschedule reschedule =
   advance_clock t ~to_:(epoch_plus 9.) ~handle_fired:ignore;
   show ();
   print_endline "Cannot reschedule the already-fired alarm1.";
-  require_does_raise [%here] (fun _ -> reschedule t alarm1 ~at:(epoch_plus 20.));
+  require_does_raise (fun _ -> reschedule t alarm1 ~at:(epoch_plus 20.));
   show ();
   print_endline "Cannot reschedule before current time.";
-  require_does_raise [%here] (fun _ -> reschedule t alarm2 ~at:(epoch_plus 8.));
+  require_does_raise (fun _ -> reschedule t alarm2 ~at:(epoch_plus 8.));
   show ();
   print_endline "Cannot reschedule arbitrarily far in the future.";
-  require_does_raise [%here] (fun _ ->
+  require_does_raise (fun _ ->
     reschedule t alarm2 ~at:(Time_ns.add (max_allowed_alarm_time t) (gibi_nanos 1.)));
   print_endline "Fire alarm2.";
   advance_clock t ~to_:(epoch_plus 11.) ~handle_fired:ignore;
@@ -1633,17 +1618,12 @@ let%expect_test "[advance_clock] fires alarms at the right time" =
       let at =
         Time_ns.add (now t) (Time_ns.Span.scale alarm_separation (Float.of_int i))
       in
-      ignore
-        (add t ~at (fun () -> require [%here] (Time_ns.( <= ) at (now t))) : _ Alarm.t)
+      ignore (add t ~at (fun () -> require (Time_ns.( <= ) at (now t))) : _ Alarm.t)
     done;
     while not (is_empty t) do
       let to_ = Time_ns.add (now t) advance_by in
       advance_clock t ~to_ ~handle_fired:(fun alarm -> Alarm.value t alarm ());
-      require_equal
-        [%here]
-        (module Interval_num)
-        (now_interval_num t)
-        (interval_num t to_)
+      require_equal (module Interval_num) (now_interval_num t) (interval_num t to_)
     done
   in
   List.iter
@@ -1672,7 +1652,7 @@ let%expect_test "[add] and [advance_clock]" =
       ~to_:(Time_ns.add (now t) by)
       ~handle_fired:(fun alarm -> Alarm.value t alarm ())
   in
-  require_does_raise [%here] (fun () -> add ~after:(gibi_nanos (-1.)) ignore);
+  require_does_raise (fun () -> add ~after:(gibi_nanos (-1.)) ignore);
   [%expect
     {|
     ("Timing_wheel cannot schedule alarm before start of current interval"
@@ -1680,7 +1660,6 @@ let%expect_test "[add] and [advance_clock]" =
      (now_interval_num_start "1970-01-01 00:00:00Z"))
     |}];
   require_equal
-    [%here]
     (module Time_ns)
     (Time_ns.add (max_allowed_alarm_time t) Time_ns.Span.nanosecond)
     (Time_ns.add (now t) (gibi_nanos 1024.));
@@ -1738,7 +1717,7 @@ let%expect_test "[next_alarm_fires_at]" =
           ~next_alarm_fires_after:
             (Option.map (next_alarm_fires_at t) ~f:(fun time ->
                Time_ns.diff time Time_ns.epoch)
-              : Time_ns.Span.t option)]
+             : Time_ns.Span.t option)]
   in
   let add_at at =
     ignore (add t ~at:(Time_ns.add Time_ns.epoch at) () : _ Alarm.t);
@@ -1775,7 +1754,7 @@ let%expect_test "[next_alarm_fires_at] with an alarm at [max_time]" =
   ignore (add t ~at:max_time () : _ Alarm.t);
   print_s [%sexp (next_alarm_fires_at t : Time_ns.t option)];
   [%expect {| () |}];
-  require_does_raise [%here] (fun () -> next_alarm_fires_at_exn t);
+  require_does_raise (fun () -> next_alarm_fires_at_exn t);
   [%expect
     {|
     ("Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval"
@@ -1816,20 +1795,13 @@ let%expect_test "[fire_past_alarms] - all possible subsets of alarms in the firs
         List.iter ats ~f:(fun at ->
           let alarm = add t ~at () in
           require_equal
-            [%here]
             (module Interval_num)
             (Alarm.interval_num t alarm)
             Interval_num.zero);
-        advance_clock t ~to_:at1 ~handle_fired:(fun _ -> require [%here] false);
+        advance_clock t ~to_:at1 ~handle_fired:(fun _ -> require false);
         fire_past_alarms t ~handle_fired:(fun alarm ->
-          if Time_ns.equal (Alarm.at t alarm) at1
-          then incr num_fired
-          else require [%here] false);
-        require_equal
-          [%here]
-          (module Int)
-          !num_fired
-          (List.count ats ~f:(Time_ns.equal at1)))
+          if Time_ns.equal (Alarm.at t alarm) at1 then incr num_fired else require false);
+        require_equal (module Int) !num_fired (List.count ats ~f:(Time_ns.equal at1)))
     in
     loop num_elts []
   done;
@@ -1844,7 +1816,7 @@ let%expect_test "alarm buckets" =
   in
   let handle_fired (a : bool ref Alarm.t) : unit =
     let r = Alarm.value t a in
-    require [%here] (not !r);
+    require (not !r);
     r := true
   in
   let precision = alarm_precision t in
@@ -1988,7 +1960,8 @@ let%expect_test "multiple alarms at the same time are fired in insertion order"
   done;
   advance_clock t ~to_:(Time_ns.add at delta) ~handle_fired:(fun alarm ->
     print_s [%sexp (Alarm.value t alarm : int)]);
-  [%expect {|
+  [%expect
+    {|
     0
     1
     2
@@ -2006,14 +1979,14 @@ let%expect_test "max_alarm_time can not be exceeded by [add] or [add_at_interval
     r
   in
   let bad_time = succ (max_allowed_alarm_time t) in
-  require_does_raise [%here] (fun () -> add t ~at:bad_time ());
+  require_does_raise (fun () -> add t ~at:bad_time ());
   [%expect
     {|
     ("Timing_wheel cannot schedule alarm that far in the future"
      (at "1970-01-01 00:18:19.511627776Z")
      (max_allowed_alarm_time "1970-01-01 00:18:19.511627775Z"))
     |}];
-  require_does_raise [%here] (fun () ->
+  require_does_raise (fun () ->
     add_at_interval_num
       t
       ~at:(Interval_num.succ (interval_num t (max_allowed_alarm_time t)))
diff --git a/total_map/src/dune b/total_map/src/dune
index b37fc547..f2137037 100644
--- a/total_map/src/dune
+++ b/total_map/src/dune
@@ -1,6 +1,6 @@
 (library
  (name total_map)
  (public_name core_kernel.total_map)
- (libraries core)
+ (libraries bin_prot.shape core)
  (preprocess
   (pps ppx_jane)))
diff --git a/total_map/src/enumeration.ml b/total_map/src/enumeration.ml
index 314c493f..893314b5 100644
--- a/total_map/src/enumeration.ml
+++ b/total_map/src/enumeration.ml
@@ -10,8 +10,8 @@ module type S_fc =
   Enumeration_intf.S_fc with type ('a, 'witness) enumeration := ('a, 'witness) t
 
 module Make (T : sig
-  type t [@@deriving enumerate]
-end) =
+    type t [@@deriving enumerate]
+  end) =
 struct
   type enumeration_witness
 
diff --git a/total_map/src/enumeration_intf.ml b/total_map/src/enumeration_intf.ml
index 29661637..e1c5a627 100644
--- a/total_map/src/enumeration_intf.ml
+++ b/total_map/src/enumeration_intf.ml
@@ -23,8 +23,8 @@ module type Enumeration = sig
   module type S_fc = S_fc with type ('a, 'witness) enumeration := ('a, 'witness) t
 
   module Make (T : sig
-    type t [@@deriving enumerate]
-  end) : S with type t := T.t
+      type t [@@deriving enumerate]
+    end) : S with type t := T.t
 
   val make : all:'a list -> (module S_fc with type enumerable_t = 'a)
 end
diff --git a/total_map/src/total_map.ml b/total_map/src/total_map.ml
index 925b4e7e..5dfc5363 100644
--- a/total_map/src/total_map.ml
+++ b/total_map/src/total_map.ml
@@ -1,5 +1,37 @@
 include Total_map_intf
 
+open struct
+  open Core
+
+  let validate_map_from_serialization
+    (type t cmp)
+    (module Key : Key_with_witnesses with type t = t and type comparator_witness = cmp)
+    (map : (t, _, cmp) Map.t)
+    =
+    let all_set = Set.of_list (module Key) Key.all in
+    let keys = Map.key_set map in
+    let keys_minus_all = Set.diff keys all_set in
+    let all_minus_keys = Set.diff all_set keys in
+    Validate.maybe_raise
+      (Validate.of_list
+         [ (if Set.is_empty keys_minus_all
+            then Validate.pass
+            else
+              Validate.fails
+                "map from serialization has keys not provided in the enumeration"
+                keys_minus_all
+                [%sexp_of: Set.M(Key).t])
+         ; (if Set.is_empty all_minus_keys
+            then Validate.pass
+            else
+              Validate.fails
+                "map from serialization doesn't have keys it should have"
+                all_minus_keys
+                [%sexp_of: Set.M(Key).t])
+         ])
+  ;;
+end
+
 module Stable = struct
   open Core.Core_stable
 
@@ -7,11 +39,19 @@ module Stable = struct
     type ('key, 'a, 'cmp, 'enum) t = ('key, 'a, 'cmp) Map.V1.t
 
     module type S =
-      Stable_V1_S with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
+      Stable_S with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
+
+    module type S_with_stable_witness =
+      Stable_S_with_stable_witness
+      with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
 
     module type For_include_functor =
-      Stable_V1_For_include_functor
-        with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+      Stable_For_include_functor
+      with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+
+    module type For_include_functor_with_stable_witness =
+      Stable_For_include_functor_with_stable_witness
+      with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
 
     module Make_with_witnesses (Key : Key_with_witnesses) = struct
       module Key = struct
@@ -27,6 +67,129 @@ module Stable = struct
     module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) = struct
       module Total_map = Make_with_witnesses (Key)
     end
+
+    module Make_with_stable_witness (Key : Key_with_stable_witness) = struct
+      module Key = struct
+        include Key
+        include Comparable.V1.With_stable_witness.Make (Key)
+      end
+
+      type comparator_witness = Key.comparator_witness
+      type enumeration_witness = Key.enumeration_witness
+      type nonrec 'a t = 'a Key.Map.t [@@deriving bin_io, sexp, compare, stable_witness]
+    end
+
+    module Make_for_include_functor_with_stable_witness (Key : Key_with_stable_witness) =
+    struct
+      module Total_map = Make_with_stable_witness (Key)
+    end
+  end
+
+  module V2 = struct
+    type ('key, 'a, 'cmp, 'enum) t = ('key, 'a, 'cmp) Map.V1.t
+
+    module type S =
+      Stable_S with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
+
+    module type S_with_stable_witness =
+      Stable_S_with_stable_witness
+      with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
+
+    module type For_include_functor =
+      Stable_For_include_functor
+      with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+
+    module type For_include_functor_with_stable_witness =
+      Stable_For_include_functor_with_stable_witness
+      with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+
+    module Make_common
+        (Key : sig
+           include Key_with_witnesses
+
+           include
+             Comparable.V1.S
+             with type comparable := t
+              and type comparator_witness := comparator_witness
+         end)
+        (M : sig
+           type 'a t = 'a Key.Map.t
+         end) =
+    struct
+      open M
+
+      type comparator_witness = Key.comparator_witness
+      type enumeration_witness = Key.enumeration_witness
+
+      include
+        Sexpable.Of_sexpable1.V1
+          (Key.Map)
+          (struct
+            type nonrec 'a t = 'a t
+
+            let to_sexpable t = t
+
+            let of_sexpable map =
+              validate_map_from_serialization (module Key) map;
+              map
+            ;;
+          end)
+
+      include
+        Binable.Of_binable1.V2
+          (Key.Map)
+          (struct
+            type nonrec 'a t = 'a t
+
+            let to_binable t = t
+
+            let of_binable map =
+              validate_map_from_serialization (module Key) map;
+              map
+            ;;
+
+            let caller_identity =
+              Bin_shape.Uuid.of_string "9cb8901d-3d76-43b9-6f50-7b2a92d415f4"
+            ;;
+          end)
+    end
+
+    module Make_with_witnesses (Key : Key_with_witnesses) = struct
+      module Key = struct
+        include Key
+        include Comparable.V1.Make (Key)
+      end
+
+      module T = struct
+        type nonrec 'a t = 'a Key.Map.t [@@deriving compare]
+      end
+
+      include T
+      include Make_common (Key) (T)
+    end
+
+    module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) = struct
+      module Total_map = Make_with_witnesses (Key)
+    end
+
+    module Make_with_stable_witness (Key : Key_with_stable_witness) = struct
+      module Key = struct
+        include Key
+        include Comparable.V1.With_stable_witness.Make (Key)
+      end
+
+      module T = struct
+        type nonrec 'a t = 'a Key.Map.t [@@deriving compare, stable_witness]
+      end
+
+      include T
+      include Make_common (Key) (T)
+    end
+
+    module Make_for_include_functor_with_stable_witness (Key : Key_with_stable_witness) =
+    struct
+      module Total_map = Make_with_stable_witness (Key)
+    end
   end
 end
 
@@ -41,13 +204,13 @@ module type S_plain =
 
 module type For_include_functor_plain =
   For_include_functor_plain
-    with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+  with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
 
 module type S = S with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
 
 module type For_include_functor =
   For_include_functor
-    with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+  with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
 
 let to_map t = t
 
@@ -94,6 +257,12 @@ let map2 t1 t2 ~f =
     Some (f v1 v2))
 ;;
 
+let mapi2 t1 t2 ~f =
+  Map.merge t1 t2 ~f:(fun ~key v ->
+    let v1, v2 = pair t1 t2 key v in
+    Some (f key v1 v2))
+;;
+
 let set t key data = Map.set t ~key ~data
 
 module Sequence3 (A : Applicative.S3) = struct
@@ -137,7 +306,8 @@ module Make_plain_with_witnesses (Key : Key_plain_with_witnesses) = struct
   type 'a t = 'a Key.Map.t [@@deriving sexp_of, compare, equal]
 
   let create f =
-    List.fold Key.all ~init:Key.Map.empty ~f:(fun t key -> Map.set t ~key ~data:(f key))
+    List.fold Key.all ~init:Key.Map.empty ~f:(fun t key -> Map.set t ~key ~data:(f key)) [@nontail
+                                                                                          ]
   ;;
 
   let create_const x = create (fun _ -> x)
@@ -146,27 +316,36 @@ module Make_plain_with_witnesses (Key : Key_plain_with_witnesses) = struct
     { set = Key.Set.of_list Key.all; name = "[Key.all]" }
   ;;
 
-  let of_map_exn map =
-    Set.Named.equal named_key_set { set = Map.key_set map; name = "[Map.key_set map]" }
-    |> ok_exn;
+  let of_map map ~if_missing =
     create (fun key ->
       match Map.find map key with
       | Some value -> value
-      | None ->
-        raise_s
-          [%message
-            "impossible: all keys must be present in the map as verified by the key set"])
+      | None -> if_missing ())
+  ;;
+
+  let of_map_exn map =
+    Set.Named.equal named_key_set { set = Map.key_set map; name = "[Map.key_set map]" }
+    |> ok_exn;
+    of_map map ~if_missing:(fun () ->
+      raise_s
+        [%message
+          "impossible: all keys must be present in the map as verified by the key set"])
   ;;
 
   let of_alist_exn alist = of_map_exn (Key.Map.of_alist_exn alist)
+  let of_alist_multi_exn alist = of_map_exn (Key.Map.of_alist_multi alist)
+
+  let of_alist_multi alist =
+    of_map (Key.Map.of_alist_multi alist) ~if_missing:(fun () -> [])
+  ;;
 
   include Applicative.Make (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let return = create_const
-    let apply t1 t2 = map2 t1 t2 ~f:(fun f x -> f x)
-    let map = `Custom map
-  end)
+      let return = create_const
+      let apply t1 t2 = map2 t1 t2 ~f:(fun f x -> f x)
+      let map = `Custom map
+    end)
 end
 
 module Make_for_include_functor_plain_with_witnesses (Key : Key_plain_with_witnesses) =
@@ -189,49 +368,24 @@ module Make_with_witnesses (Key : Key_with_witnesses) = struct
         with module Key := Key
         with type 'a t := 'a t)
 
-  let all_set = Key.Set.of_list Key.all
-
-  let validate_map_from_serialization map =
-    let keys = Map.key_set map in
-    let keys_minus_all = Set.diff keys all_set in
-    let all_minus_keys = Set.diff all_set keys in
-    Validate.maybe_raise
-      (Validate.of_list
-         [ (if Set.is_empty keys_minus_all
-            then Validate.pass
-            else
-              Validate.fails
-                "map from serialization has keys not provided in the enumeration"
-                keys_minus_all
-                [%sexp_of: Key.Set.t])
-         ; (if Set.is_empty all_minus_keys
-            then Validate.pass
-            else
-              Validate.fails
-                "map from serialization doesn't have keys it should have"
-                all_minus_keys
-                [%sexp_of: Key.Set.t])
-         ])
-  ;;
-
   let t_of_sexp a_of_sexp sexp =
     let t = t_of_sexp a_of_sexp sexp in
-    validate_map_from_serialization t;
+    validate_map_from_serialization (module Key) t;
     t
   ;;
 
   include Bin_prot.Utils.Make_binable1_without_uuid [@alert "-legacy"] (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    module Binable = Key.Map
+      module Binable = Key.Map
 
-    let to_binable x = x
+      let to_binable x = x
 
-    let of_binable x =
-      validate_map_from_serialization x;
-      x
-    ;;
-  end)
+      let of_binable x =
+        validate_map_from_serialization (module Key) x;
+        x
+      ;;
+    end)
   end
 
 module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) = struct
@@ -239,20 +393,20 @@ module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) = stru
 end
 
 module Make_plain (Key : Key_plain) = Make_plain_with_witnesses (struct
-  include Key
-  include Comparable.Make_plain (Key)
-  include Enumeration.Make (Key)
-end)
+    include Key
+    include Comparable.Make_plain (Key)
+    include Enumeration.Make (Key)
+  end)
 
 module Make_for_include_functor_plain (Key : Key_plain) = struct
   module Total_map = Make_plain (Key)
 end
 
 module Make (Key : Key) = Make_with_witnesses (struct
-  include Key
-  include Comparable.Make_binable (Key)
-  include Enumeration.Make (Key)
-end)
+    include Key
+    include Comparable.Make_binable (Key)
+    include Enumeration.Make (Key)
+  end)
 
 module Make_for_include_functor (Key : Key) = struct
   module Total_map = Make (Key)
diff --git a/total_map/src/total_map_intf.ml b/total_map/src/total_map_intf.ml
index a9868c86..02fe49a6 100644
--- a/total_map/src/total_map_intf.ml
+++ b/total_map/src/total_map_intf.ml
@@ -21,6 +21,11 @@ module type Key_with_witnesses = sig
   include Enumeration.S with type t := t
 end
 
+module type Key_with_stable_witness = sig
+  include Key_with_witnesses
+  include Stable_with_witness with type t := t
+end
+
 module type S_plain = sig
   type ('key, 'a, 'cmp, 'enum) total_map
 
@@ -37,6 +42,11 @@ module type S_plain = sig
   val create : (Key.t -> 'a) -> 'a t
   val create_const : 'a -> 'a t
   val of_alist_exn : (Key.t * 'a) list -> 'a t
+  val of_alist_multi_exn : (Key.t * 'a) list -> 'a list t
+
+  (** Note that [of_alist_multi keylist] will contain empty list items if a given [Key.t]
+      is not present in [keylist] *)
+  val of_alist_multi : (Key.t * 'a) list -> 'a list t
 end
 
 (** An alternative interface for [S_plain] which can be used with [include functor]. We
@@ -58,7 +68,7 @@ module type For_include_functor = sig
   module Total_map : S
 end
 
-module type Stable_V1_S = sig
+module type Stable_S = sig
   type ('key, 'a, 'cmp, 'enum) total_map
 
   module Key : Key
@@ -70,8 +80,67 @@ module type Stable_V1_S = sig
   [@@deriving bin_io, sexp, compare]
 end
 
-module type Stable_V1_For_include_functor = sig
-  module Total_map : Stable_V1_S
+module type Stable_For_include_functor = sig
+  module Total_map : Stable_S
+end
+
+module type Stable_S_with_stable_witness = sig
+  type ('key, 'a, 'cmp, 'enum) total_map
+
+  module Key : Key
+
+  type comparator_witness
+  type enumeration_witness
+
+  type 'a t = (Key.t, 'a, comparator_witness, enumeration_witness) total_map
+  [@@deriving bin_io, sexp, compare, stable_witness]
+end
+
+module type Stable_For_include_functor_with_stable_witness = sig
+  module Total_map : Stable_S_with_stable_witness
+end
+
+module type Stable = sig
+  type ('key, 'a, 'cmp, 'enum) t
+
+  module type S =
+    Stable_S with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
+
+  module type S_with_stable_witness =
+    Stable_S_with_stable_witness
+    with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
+
+  module type For_include_functor =
+    Stable_For_include_functor
+    with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+
+  module type For_include_functor_with_stable_witness =
+    Stable_For_include_functor_with_stable_witness
+    with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+
+  module Make_with_witnesses (Key : Key_with_witnesses) :
+    S
+    with module Key = Key
+    with type comparator_witness = Key.comparator_witness
+    with type enumeration_witness = Key.enumeration_witness
+
+  module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) :
+    For_include_functor
+    with module Total_map.Key = Key
+    with type Total_map.comparator_witness = Key.comparator_witness
+    with type Total_map.enumeration_witness = Key.enumeration_witness
+
+  module Make_with_stable_witness (Key : Key_with_stable_witness) :
+    S_with_stable_witness
+    with module Key = Key
+    with type comparator_witness = Key.comparator_witness
+    with type enumeration_witness = Key.enumeration_witness
+
+  module Make_for_include_functor_with_stable_witness (Key : Key_with_stable_witness) :
+    For_include_functor_with_stable_witness
+    with module Total_map.Key = Key
+    with type Total_map.comparator_witness = Key.comparator_witness
+    with type Total_map.enumeration_witness = Key.enumeration_witness
 end
 
 module type Total_map = sig
@@ -124,6 +193,12 @@ module type Total_map = sig
     -> f:('a -> 'b -> 'c)
     -> ('key, 'c, 'cmp, 'enum) t
 
+  val mapi2
+    :  ('key, 'a, 'cmp, 'enum) t
+    -> ('key, 'b, 'cmp, 'enum) t
+    -> f:('key -> 'a -> 'b -> 'c)
+    -> ('key, 'c, 'cmp, 'enum) t
+
   val iter_keys : ('key, _, _, _) t -> f:('key -> unit) -> unit
   val iter : (_, 'a, _, _) t -> f:('a -> unit) -> unit
   val iteri : ('key, 'a, _, _) t -> f:(key:'key -> data:'a -> unit) -> unit
@@ -197,14 +272,14 @@ module type Total_map = sig
 
   module type For_include_functor_plain =
     For_include_functor_plain
-      with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+    with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
 
   module type S =
     S with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
 
   module type For_include_functor =
     For_include_functor
-      with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
+    with type ('key, 'a, 'cmp, 'enum) Total_map.total_map := ('key, 'a, 'cmp, 'enum) t
 
   module Make_plain (Key : Key_plain) : S_plain with module Key = Key
 
@@ -213,15 +288,15 @@ module type Total_map = sig
 
   module Make_plain_with_witnesses (Key : Key_plain_with_witnesses) :
     S_plain
-      with module Key = Key
-      with type comparator_witness = Key.comparator_witness
-      with type enumeration_witness = Key.enumeration_witness
+    with module Key = Key
+    with type comparator_witness = Key.comparator_witness
+    with type enumeration_witness = Key.enumeration_witness
 
   module Make_for_include_functor_plain_with_witnesses (Key : Key_plain_with_witnesses) :
     For_include_functor_plain
-      with module Total_map.Key = Key
-      with type Total_map.comparator_witness = Key.comparator_witness
-      with type Total_map.enumeration_witness = Key.enumeration_witness
+    with module Total_map.Key = Key
+    with type Total_map.comparator_witness = Key.comparator_witness
+    with type Total_map.enumeration_witness = Key.enumeration_witness
 
   module Make (Key : Key) : S with module Key = Key
 
@@ -230,38 +305,18 @@ module type Total_map = sig
 
   module Make_with_witnesses (Key : Key_with_witnesses) :
     S
-      with module Key = Key
-      with type comparator_witness = Key.comparator_witness
-      with type enumeration_witness = Key.enumeration_witness
+    with module Key = Key
+    with type comparator_witness = Key.comparator_witness
+    with type enumeration_witness = Key.enumeration_witness
 
   module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) :
     For_include_functor
-      with module Total_map.Key = Key
-      with type Total_map.comparator_witness = Key.comparator_witness
-      with type Total_map.enumeration_witness = Key.enumeration_witness
+    with module Total_map.Key = Key
+    with type Total_map.comparator_witness = Key.comparator_witness
+    with type Total_map.enumeration_witness = Key.enumeration_witness
 
   module Stable : sig
-    module V1 : sig
-      module type S =
-        Stable_V1_S
-          with type ('key, 'a, 'cmp, 'enum) total_map := ('key, 'a, 'cmp, 'enum) t
-
-      module type For_include_functor =
-        Stable_V1_For_include_functor
-          with type ('key, 'a, 'cmp, 'enum) Total_map.total_map :=
-            ('key, 'a, 'cmp, 'enum) t
-
-      module Make_with_witnesses (Key : Key_with_witnesses) :
-        S
-          with module Key = Key
-          with type comparator_witness = Key.comparator_witness
-          with type enumeration_witness = Key.enumeration_witness
-
-      module Make_for_include_functor_with_witnesses (Key : Key_with_witnesses) :
-        For_include_functor
-          with module Total_map.Key = Key
-          with type Total_map.comparator_witness = Key.comparator_witness
-          with type Total_map.enumeration_witness = Key.enumeration_witness
-    end
+    module V1 : Stable with type ('key, 'a, 'cmp, 'enum) t = ('key, 'a, 'cmp, 'enum) t
+    module V2 : Stable with type ('key, 'a, 'cmp, 'enum) t = ('key, 'a, 'cmp, 'enum) t
   end
 end
diff --git a/tuple_pool/src/tuple_pool.ml b/tuple_pool/src/tuple_pool.ml
index d5ed627d..dc1cff38 100644
--- a/tuple_pool/src/tuple_pool.ml
+++ b/tuple_pool/src/tuple_pool.ml
@@ -907,8 +907,8 @@ module Pool = struct
     else
       (Obj.magic
          (Uniform_array.sub t ~pos:(Pointer.first_slot_index pointer) ~len
-           : Obj.t Uniform_array.t)
-        : tuple)
+          : Obj.t Uniform_array.t)
+       : tuple)
   ;;
 end
 
diff --git a/tuple_pool/src/tuple_pool_intf.ml b/tuple_pool/src/tuple_pool_intf.ml
index 331337df..1f241e3e 100644
--- a/tuple_pool/src/tuple_pool_intf.ml
+++ b/tuple_pool/src/tuple_pool_intf.ml
@@ -219,7 +219,7 @@ module type S = sig
 
   val new12
     :  (('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'a10, 'a11) Slots.t12 as 'slots)
-       t
+         t
     -> 'a0
     -> 'a1
     -> 'a2
@@ -238,7 +238,7 @@ module type S = sig
     :  (('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'a10, 'a11, 'a12) Slots.t13
         as
         'slots)
-       t
+         t
     -> 'a0
     -> 'a1
     -> 'a2
@@ -256,23 +256,23 @@ module type S = sig
 
   val new14
     :  (( 'a0
-        , 'a1
-        , 'a2
-        , 'a3
-        , 'a4
-        , 'a5
-        , 'a6
-        , 'a7
-        , 'a8
-        , 'a9
-        , 'a10
-        , 'a11
-        , 'a12
-        , 'a13 )
-        Slots.t14
+          , 'a1
+          , 'a2
+          , 'a3
+          , 'a4
+          , 'a5
+          , 'a6
+          , 'a7
+          , 'a8
+          , 'a9
+          , 'a10
+          , 'a11
+          , 'a12
+          , 'a13 )
+          Slots.t14
         as
         'slots)
-       t
+         t
     -> 'a0
     -> 'a1
     -> 'a2
@@ -377,9 +377,9 @@ module type Tuple_pool = sig
   module Debug (Tuple_pool : S) : sig
     include
       S
-        with type 'a Pointer.t = 'a Tuple_pool.Pointer.t
-        with type Pointer.Id.t = Tuple_pool.Pointer.Id.t
-        with type 'a t = 'a Tuple_pool.t
+      with type 'a Pointer.t = 'a Tuple_pool.Pointer.t
+      with type Pointer.Id.t = Tuple_pool.Pointer.Id.t
+      with type 'a t = 'a Tuple_pool.t
 
     val check_invariant : bool ref
     val show_messages : bool ref
diff --git a/tuple_pool/src/tuple_type_intf.ml b/tuple_pool/src/tuple_type_intf.ml
index 40f8855d..d3211851 100644
--- a/tuple_pool/src/tuple_type_intf.ml
+++ b/tuple_pool/src/tuple_type_intf.ml
@@ -53,146 +53,147 @@ module type Slots = sig
 
   type ('a0, 'a1, 'a2, 'a3, 'a4) t5 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4
-    , [ `S0 of 'a0 | `S1 of 'a1 | `S2 of 'a2 | `S3 of 'a3 | `S4 of 'a4 ] )
-    t
+      , [ `S0 of 'a0 | `S1 of 'a1 | `S2 of 'a2 | `S3 of 'a3 | `S4 of 'a4 ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5) t6 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5
-    , [ `S0 of 'a0 | `S1 of 'a1 | `S2 of 'a2 | `S3 of 'a3 | `S4 of 'a4 | `S5 of 'a5 ] )
-    t
+      , [ `S0 of 'a0 | `S1 of 'a1 | `S2 of 'a2 | `S3 of 'a3 | `S4 of 'a4 | `S5 of 'a5 ]
+      )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6) t7 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7) t8 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8) t9 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7 * 'a8
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      | `S8 of 'a8
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        | `S8 of 'a8
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9) t10 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7 * 'a8 * 'a9
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      | `S8 of 'a8
-      | `S9 of 'a9
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        | `S8 of 'a8
+        | `S9 of 'a9
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'a10) t11 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7 * 'a8 * 'a9 * 'a10
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      | `S8 of 'a8
-      | `S9 of 'a9
-      | `S10 of 'a10
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        | `S8 of 'a8
+        | `S9 of 'a9
+        | `S10 of 'a10
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'a10, 'a11) t12 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7 * 'a8 * 'a9 * 'a10 * 'a11
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      | `S8 of 'a8
-      | `S9 of 'a9
-      | `S10 of 'a10
-      | `S11 of 'a11
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        | `S8 of 'a8
+        | `S9 of 'a9
+        | `S10 of 'a10
+        | `S11 of 'a11
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'a10, 'a11, 'a12) t13 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7 * 'a8 * 'a9 * 'a10 * 'a11 * 'a12
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      | `S8 of 'a8
-      | `S9 of 'a9
-      | `S10 of 'a10
-      | `S11 of 'a11
-      | `S12 of 'a12
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        | `S8 of 'a8
+        | `S9 of 'a9
+        | `S10 of 'a10
+        | `S11 of 'a11
+        | `S12 of 'a12
+        ] )
+      t
   [@@deriving sexp_of]
 
   type ('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'a10, 'a11, 'a12, 'a13) t14 =
     ( 'a0 * 'a1 * 'a2 * 'a3 * 'a4 * 'a5 * 'a6 * 'a7 * 'a8 * 'a9 * 'a10 * 'a11 * 'a12 * 'a13
-    , [ `S0 of 'a0
-      | `S1 of 'a1
-      | `S2 of 'a2
-      | `S3 of 'a3
-      | `S4 of 'a4
-      | `S5 of 'a5
-      | `S6 of 'a6
-      | `S7 of 'a7
-      | `S8 of 'a8
-      | `S9 of 'a9
-      | `S10 of 'a10
-      | `S11 of 'a11
-      | `S12 of 'a12
-      | `S13 of 'a13
-      ] )
-    t
+      , [ `S0 of 'a0
+        | `S1 of 'a1
+        | `S2 of 'a2
+        | `S3 of 'a3
+        | `S4 of 'a4
+        | `S5 of 'a5
+        | `S6 of 'a6
+        | `S7 of 'a7
+        | `S8 of 'a8
+        | `S9 of 'a9
+        | `S10 of 'a10
+        | `S11 of 'a11
+        | `S12 of 'a12
+        | `S13 of 'a13
+        ] )
+      t
   [@@deriving sexp_of]
 
   val t1 : _ t1
diff --git a/tuple_pool/test-bin/dune b/tuple_pool/test-bin/dune
index c88e1d50..e5a3d9f8 100644
--- a/tuple_pool/test-bin/dune
+++ b/tuple_pool/test-bin/dune
@@ -1,7 +1,7 @@
 (executables
  (modes byte exe)
  (names tuple_pool_caml_modify_check)
- (libraries replace_caml_modify_for_testing tuple_pool)
+ (libraries core replace_caml_modify_for_testing tuple_pool)
  (preprocess
   (pps ppx_jane)))
 
diff --git a/tuple_pool/test/dune b/tuple_pool/test/dune
index 3553bf5e..86aa61f7 100644
--- a/tuple_pool/test/dune
+++ b/tuple_pool/test/dune
@@ -1,5 +1,5 @@
 (library
  (name tuple_pool_test)
- (libraries tuple_pool)
+ (libraries core tuple_pool)
  (preprocess
   (pps ppx_jane)))
diff --git a/tuple_pool/test/test_tuple_pool.ml b/tuple_pool/test/test_tuple_pool.ml
index 339d3320..facb8069 100644
--- a/tuple_pool/test/test_tuple_pool.ml
+++ b/tuple_pool/test/test_tuple_pool.ml
@@ -168,8 +168,8 @@ module Make (Pool : Pool.S) = struct
             (List.init num_to_alloc_this_iter ~f:Fn.id)
             ~init:(p, live)
             ~f:(fun (p, live) i ->
-            let p = if Pool.is_full p then Pool.grow p else p in
-            p, create p i (nil ()) :: live)
+              let p = if Pool.is_full p then Pool.grow p else p in
+              p, create p i (nil ()) :: live)
         in
         let to_free, live =
           let r = ref true in
@@ -260,22 +260,22 @@ let%expect_test "use a pool that has been [grow]n" =
 
 let%test_module _ =
   (module Make (struct
-    include Pool.Unsafe
+      include Pool.Unsafe
 
-    let create (type tuple) (slots : (tuple, _) Slots.t) ~capacity ~dummy:(_ : tuple) =
-      create slots ~capacity
-    ;;
-  end))
+      let create (type tuple) (slots : (tuple, _) Slots.t) ~capacity ~dummy:(_ : tuple) =
+        create slots ~capacity
+      ;;
+    end))
 ;;
 
 let%test_module "Debug without messages" =
   (module Make (struct
-    include Pool.Debug (Pool)
+      include Pool.Debug (Pool)
 
-    let () = show_messages := false
+      let () = show_messages := false
 
-    (* or it prints too much *)
-  end))
+      (* or it prints too much *)
+    end))
 ;;
 
 module Error_checked_pool = Pool.Error_check (Pool)
diff --git a/univ/test/dune b/univ/test/dune
index 3b7fa7b3..43cac4cd 100644
--- a/univ/test/dune
+++ b/univ/test/dune
@@ -1,5 +1,5 @@
 (library
  (name univ_test)
- (libraries univ)
+ (libraries core univ)
  (preprocess
   (pps ppx_jane)))
diff --git a/unpack_buffer/src/unpack_buffer.ml b/unpack_buffer/src/unpack_buffer.ml
index 4bb1a5c2..66c79bc6 100644
--- a/unpack_buffer/src/unpack_buffer.ml
+++ b/unpack_buffer/src/unpack_buffer.ml
@@ -22,62 +22,62 @@ module Unpack_one = struct
   let create ~initial_state ~unpack = T { initial_state; unpack }
 
   include Monad.Make (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let return v =
-      T
-        { initial_state = ()
-        ; unpack = (fun ~state:() ~buf:_ ~pos:_ ~len:_ -> `Ok (v, 0))
-        }
-    ;;
-
-    let map' (t : 'a t) ~f =
-      let (T { initial_state; unpack }) = t in
-      T
-        { initial_state
-        ; unpack =
-            (fun ~state ~buf ~pos ~len ->
-              match unpack ~state ~buf ~pos ~len with
-              | (`Invalid_data _ | `Not_enough_data _) as x -> x
-              | `Ok (a, pos) -> `Ok (f a, pos))
-        }
-    ;;
-
-    let map = `Custom map'
-
-    let bind =
-      let module State = struct
-        type ('sa, 'b) t =
-          | A : 'sa -> ('sa, _) t
-          | B : 'sb * ('b, 'sb) unpack -> (_, 'b) t
-      end
-      in
-      let open State in
-      let do_b ~na sb (ub : (_, _) unpack) ~buf ~pos ~len =
-        match ub ~state:sb ~buf ~pos ~len with
-        | `Invalid_data _ as x -> x
-        | `Not_enough_data (sb, nb) -> `Not_enough_data (B (sb, ub), nb + na)
-        | `Ok (b, nb) -> `Ok (b, na + nb)
-      in
-      fun (T a) ~f ->
-        let do_a sa ~buf ~pos ~len =
-          match a.unpack ~state:sa ~buf ~pos ~len with
-          | `Invalid_data _ as x -> x
-          | `Not_enough_data (sa, n) -> `Not_enough_data (A sa, n)
-          | `Ok (a, na) ->
-            let (T b) = f a in
-            do_b ~na b.initial_state b.unpack ~buf ~pos:(pos + na) ~len:(len - na)
-        in
+      let return v =
+        T
+          { initial_state = ()
+          ; unpack = (fun ~state:() ~buf:_ ~pos:_ ~len:_ -> `Ok (v, 0))
+          }
+      ;;
+
+      let map' (t : 'a t) ~f =
+        let (T { initial_state; unpack }) = t in
         T
-          { initial_state = A a.initial_state
+          { initial_state
           ; unpack =
               (fun ~state ~buf ~pos ~len ->
-                match state with
-                | A sa -> do_a sa ~buf ~pos ~len
-                | B (sb, ub) -> do_b ~na:0 sb ub ~buf ~pos ~len)
+                match unpack ~state ~buf ~pos ~len with
+                | (`Invalid_data _ | `Not_enough_data _) as x -> x
+                | `Ok (a, pos) -> `Ok (f a, pos))
           }
-    ;;
-  end)
+      ;;
+
+      let map = `Custom map'
+
+      let bind =
+        let module State = struct
+          type ('sa, 'b) t =
+            | A : 'sa -> ('sa, _) t
+            | B : 'sb * ('b, 'sb) unpack -> (_, 'b) t
+        end
+        in
+        let open State in
+        let do_b ~na sb (ub : (_, _) unpack) ~buf ~pos ~len =
+          match ub ~state:sb ~buf ~pos ~len with
+          | `Invalid_data _ as x -> x
+          | `Not_enough_data (sb, nb) -> `Not_enough_data (B (sb, ub), nb + na)
+          | `Ok (b, nb) -> `Ok (b, na + nb)
+        in
+        fun (T a) ~f ->
+          let do_a sa ~buf ~pos ~len =
+            match a.unpack ~state:sa ~buf ~pos ~len with
+            | `Invalid_data _ as x -> x
+            | `Not_enough_data (sa, n) -> `Not_enough_data (A sa, n)
+            | `Ok (a, na) ->
+              let (T b) = f a in
+              do_b ~na b.initial_state b.unpack ~buf ~pos:(pos + na) ~len:(len - na)
+          in
+          T
+            { initial_state = A a.initial_state
+            ; unpack =
+                (fun ~state ~buf ~pos ~len ->
+                  match state with
+                  | A sa -> do_a sa ~buf ~pos ~len
+                  | B (sb, ub) -> do_b ~na:0 sb ub ~buf ~pos ~len)
+            }
+      ;;
+    end)
 
   (* [create_bin_prot] doesn't use [Bigstring.read_bin_prot] for performance reasons.  It
      was written prior to [Bigstring.read_bin_prot], and it's not clear whether switching
diff --git a/unpack_buffer/test/dune b/unpack_buffer/test/dune
index 7ad34da8..351dc98f 100644
--- a/unpack_buffer/test/dune
+++ b/unpack_buffer/test/dune
@@ -1,5 +1,5 @@
 (library
  (name unpack_buffer_test)
- (libraries expect_test_helpers_core unpack_buffer)
+ (libraries core expect_test_helpers_core unpack_buffer)
  (preprocess
   (pps ppx_jane)))
diff --git a/unpack_buffer/test/test_unpack_buffer.ml b/unpack_buffer/test/test_unpack_buffer.ml
index 17817e92..9c1ff78b 100644
--- a/unpack_buffer/test/test_unpack_buffer.ml
+++ b/unpack_buffer/test/test_unpack_buffer.ml
@@ -293,7 +293,7 @@ let%test_unit _ =
     let unpack_one =
       Unpack_one.bin_blob
       |> Unpack_one.map ~f:(fun thing ->
-           Bin_prot.Blob.Opaque.Bigstring.of_opaque_exn thing bin_reader_t)
+        Bin_prot.Blob.Opaque.Bigstring.of_opaque_exn thing bin_reader_t)
     ;;
   end
   in
@@ -342,20 +342,20 @@ module Example = struct
     let buf = pack [ t ] in
     let pos_ref = ref 0 in
     ignore
-      (require_allocation_does_not_exceed (Minor_words object_size) [%here] (fun () ->
+      (require_allocation_does_not_exceed (Minor_words object_size) (fun () ->
          let size = Bin_prot.Utils.bin_read_size_header buf ~pos_ref in
          let t = bin_reader_t.read buf ~pos_ref in
          size + t.x + t.y)
-        : int);
+       : int);
     [%expect {| |}]
   ;;
 
   let%expect_test "confirm object size" =
     ignore
-      (require_allocation_does_not_exceed (Minor_words object_size) [%here] (fun () ->
+      (require_allocation_does_not_exceed (Minor_words object_size) (fun () ->
          let n = Sys.opaque_identity 0 in
          { x = n; y = n })
-        : t);
+       : t);
     [%expect {| |}]
   ;;
 end
@@ -371,16 +371,16 @@ let%expect_test "[feed] and [unpack_iter] allocation" =
      (see https://github.com/ocaml/ocaml/pull/10025) hence the bump. *)
   let fixed_cost_of_feed = 30 in
   let buf = Example.pack [] in
-  require_allocation_does_not_exceed (Minor_words fixed_cost_of_feed) [%here] (fun () ->
+  require_allocation_does_not_exceed (Minor_words fixed_cost_of_feed) (fun () ->
     feed unpack buf |> Or_error.ok_exn);
-  require_no_allocation [%here] unpack_iter;
+  require_no_allocation unpack_iter;
   let num_objects = 4 in
   let buf = Example.pack (List.init num_objects ~f:(const Example.t)) in
-  require_allocation_does_not_exceed (Minor_words fixed_cost_of_feed) [%here] (fun () ->
+  require_allocation_does_not_exceed (Minor_words fixed_cost_of_feed) (fun () ->
     feed unpack buf |> Or_error.ok_exn);
   let cost_per_unpack = 19 in
   let expected_allocation = num_objects * (cost_per_unpack + Example.object_size) in
-  require_allocation_does_not_exceed (Minor_words expected_allocation) [%here] unpack_iter;
+  require_allocation_does_not_exceed (Minor_words expected_allocation) unpack_iter;
   [%test_result: int] ~expect:num_objects !num_unpacked;
   [%expect {| |}]
 ;;
diff --git a/uopt/src/dune b/uopt/src/dune
index 52e8b084..92be1ecc 100644
--- a/uopt/src/dune
+++ b/uopt/src/dune
@@ -1,6 +1,6 @@
 (library
  (name uopt_core)
  (public_name core_kernel.uopt)
- (libraries core uopt)
+ (libraries core ppx_stable_witness.stable_witness uopt)
  (preprocess
   (pps ppx_jane)))
diff --git a/uopt/src/uopt_core.mli b/uopt/src/uopt_core.mli
index ec2976d3..9cf77bd6 100644
--- a/uopt/src/uopt_core.mli
+++ b/uopt/src/uopt_core.mli
@@ -1,7 +1,6 @@
 open! Core
 
-(** @@inline *)
-include module type of Uopt with type 'a t = 'a Uopt.t
+include module type of Uopt with type 'a t = 'a Uopt.t (** @inline *)
 
 include Binable.S1 with type 'a t := 'a t
 
diff --git a/uopt/test/dune b/uopt/test/dune
index 886623cc..85d032da 100644
--- a/uopt/test/dune
+++ b/uopt/test/dune
@@ -1,5 +1,5 @@
 (library
  (name uopt_core_test)
- (libraries uopt_core)
+ (libraries core uopt_core)
  (preprocess
   (pps ppx_jane)))
diff --git a/uuid/src/uuid.ml b/uuid/src/uuid.ml
index c8de1206..f22e32e6 100644
--- a/uuid/src/uuid.ml
+++ b/uuid/src/uuid.ml
@@ -73,8 +73,8 @@ module T = struct
   let next_counter =
     let counter = ref 0 in
     fun () ->
-      (* In OCaml this doesn't allocate, and threads can't context switch except on
-         allocation *)
+      (* This is atomic because OCaml threads only context switch at allocations and
+         safepoints, and [incr] is a primitive that has neither. *)
       incr counter;
       !counter
   ;;
@@ -149,11 +149,11 @@ end
 include T
 
 include Identifiable.Make_using_comparator (struct
-  let module_name = "Uuid"
+    let module_name = "Uuid"
 
-  include T
-  include Sexpable.Of_stringable (T)
-end)
+    include T
+    include Sexpable.Of_stringable (T)
+  end)
 
 let invariant t = ignore (of_string t : t)
 let nil = "00000000-0000-0000-0000-000000000000"
diff --git a/uuid/src/uuid.mli b/uuid/src/uuid.mli
index 23f2b8e2..ee571b36 100644
--- a/uuid/src/uuid.mli
+++ b/uuid/src/uuid.mli
@@ -16,7 +16,7 @@ include Invariant.S with type t := t
 include Quickcheckable.S with type t := t
 
 val t_of_sexp : Sexp.t -> t
-  [@@deprecated "[since 2017-11] Use a [Stable] or [Unstable] [t_of_sexp]."]
+[@@deprecated "[since 2017-11] Use a [Stable] or [Unstable] [t_of_sexp]."]
 
 val create_random : Random.State.t -> t
 val arg_type : t Command.Arg_type.t
@@ -36,8 +36,8 @@ module Stable : sig
 
     include
       Stable_comparable.With_stable_witness.V1
-        with type t := t
-        with type comparator_witness = comparator_witness
+      with type t := t
+      with type comparator_witness = comparator_witness
 
     include Stringable.S with type t := t
 
diff --git a/uuid/test/dune b/uuid/test/dune
index 6fb7cd26..1bf9dcb6 100644
--- a/uuid/test/dune
+++ b/uuid/test/dune
@@ -1,5 +1,5 @@
 (library
  (name uuid_test)
- (libraries expect_test_helpers_core uuid)
+ (libraries core expect_test_helpers_core uuid)
  (preprocess
   (pps ppx_jane)))
diff --git a/vec/src/vec.ml b/vec/src/vec.ml
index f297cb40..02cd70bc 100644
--- a/vec/src/vec.ml
+++ b/vec/src/vec.ml
@@ -12,6 +12,7 @@ module With_integer_index = struct
     val init : int -> f:(int -> 'a) -> 'a t
     val unsafe_get : 'a t -> int -> 'a
     val unsafe_set : 'a t -> int -> 'a -> unit
+    val unsafe_set_imm : 'a t -> 'a Type_immediacy.Always.t -> int -> 'a -> unit
 
     val unsafe_blit
       :  src:'a t
@@ -42,7 +43,7 @@ module With_integer_index = struct
       { mutable arr : Obj.t Uniform_array.t
       ; mutable length : int
       ; mutable capacity : int
-          (** Invariant: [capacity = Uniform_array.length arr].
+      (** Invariant: [capacity = Uniform_array.length arr].
           We maintain it here to eliminate an indirection when accessing long arrays. *)
       }
     [@@deriving fields ~getters ~setters]
@@ -89,6 +90,16 @@ module With_integer_index = struct
       Uniform_array.unsafe_set t.arr i (Obj.repr element)
     ;;
 
+    let[@inline always] unsafe_set_imm
+      (type a)
+      (t : a t)
+      (_ : a Type_immediacy.Always.t)
+      i
+      (element : a)
+      =
+      Uniform_array.unsafe_set_int_assuming_currently_int t.arr i (Obj.magic element)
+    ;;
+
     let[@inline always] unsafe_blit ~src ~src_pos ~dst ~dst_pos ~len =
       Uniform_array.unsafe_blit ~src:src.arr ~src_pos ~dst:dst.arr ~dst_pos ~len
     ;;
@@ -193,6 +204,13 @@ module With_integer_index = struct
     !result
   ;;
 
+  include Binary_searchable.Make1 (struct
+      type nonrec 'a t = 'a t
+
+      let length = length
+      let get = unsafe_get
+    end)
+
   let next_free_index = length
 
   let[@cold] raise__bad_index t i ~op =
@@ -204,6 +222,14 @@ module With_integer_index = struct
           (op : string)]
   ;;
 
+  (* Tailcalls to raising functions are to be avoided, as the stack traces are much worse.
+     Instead, we try really hard to inline wrapper functions that just perform non-tail
+     calls to the raising functions.
+  *)
+  let[@inline always] raise__bad_index (type a) t i ~op : a =
+    raise__bad_index t i ~op [@nontail]
+  ;;
+
   let[@inline always] check_index t i ~op =
     if i < 0 || i >= length t then raise__bad_index t i ~op
   ;;
@@ -216,7 +242,7 @@ module With_integer_index = struct
   let maybe_get t i = if i < 0 || i >= length t then None else Some (unsafe_get t i)
 
   let maybe_get_local t i =
-    if i < 0 || i >= length t then None else Some { Gel.g = unsafe_get t i }
+    if i < 0 || i >= length t then None else Some { global = unsafe_get t i }
   ;;
 
   let set t i element =
@@ -224,12 +250,23 @@ module With_integer_index = struct
     unsafe_set t i element
   ;;
 
+  let set_imm (type a) (t : a t) (w : a Type_immediacy.Always.t) i (element : a) : unit =
+    check_index t i ~op:"set_imm";
+    unsafe_set_imm t w i element
+  ;;
+
   let[@inline always] push_back__we_know_we_have_space t element =
     let length = length t in
     unsafe_set t length element;
     set_length t (length + 1)
   ;;
 
+  let[@inline always] push_back__we_know_we_have_space_imm t w element =
+    let length = length t in
+    unsafe_set_imm t w length element;
+    set_length t (length + 1)
+  ;;
+
   let push_back_index t element =
     let length = length t in
     if length = capacity t then grow_capacity_once t;
@@ -237,11 +274,23 @@ module With_integer_index = struct
     length
   ;;
 
+  let push_back_index_imm t w element =
+    let length = length t in
+    if length = capacity t then grow_capacity_once t;
+    push_back__we_know_we_have_space_imm t w element;
+    length
+  ;;
+
   let[@inline always] push_back t element =
     let (_ : int) = push_back_index t element in
     ()
   ;;
 
+  let[@inline always] push_back_imm t w element =
+    let (_ : int) = push_back_index_imm t w element in
+    ()
+  ;;
+
   let remove_exn t i =
     if i < 0 || i >= length t then raise__bad_index t i ~op:"remove_exn";
     let new_length = length t - 1 in
@@ -265,17 +314,34 @@ module With_integer_index = struct
 
   let[@inline always] pop_back_unit_exn t =
     let pos = max_index t in
+    if pos < 0 then raise__bad_index t (length t) ~op:"pop_back_unit_exn";
     (* Don't leak the value. *)
     unsafe_clear_pointer_at t pos;
     set_length t pos
   ;;
 
+  let[@inline always] pop_back_unit_imm_exn
+    (type a)
+    (t : a t)
+    (_ : a Type_immediacy.Always.t)
+    =
+    let pos = max_index t in
+    if pos < 0 then raise__bad_index t (length t) ~op:"pop_back_unit_imm_exn";
+    set_length t pos
+  ;;
+
   let pop_back_exn t =
     let e = peek_back_exn t in
     pop_back_unit_exn t;
     e
   ;;
 
+  let pop_back_imm_exn t w =
+    let e = peek_back_exn t in
+    pop_back_unit_imm_exn t w;
+    e
+  ;;
+
   let[@inline never] grow_to_unchecked t ~len ~default =
     grow_capacity_to_at_least t ~capacity:len;
     for i = length t to len - 1 do
@@ -405,17 +471,17 @@ module With_integer_index = struct
   ;;
 
   include Blit.Make1 (struct
-    type nonrec 'a t = 'a t
+      type nonrec 'a t = 'a t
 
-    let create_like ~len _t =
-      (* Note that even though we [unsafe_create_uninitialized], every time this function
+      let create_like ~len _t =
+        (* Note that even though we [unsafe_create_uninitialized], every time this function
            is called, the [Vec] is immediately blitted with valid values. *)
-      Kernel.unsafe_create_uninitialized ~len
-    ;;
+        Kernel.unsafe_create_uninitialized ~len
+      ;;
 
-    let length = length
-    let unsafe_blit = unsafe_blit
-  end)
+      let length = length
+      let unsafe_blit = unsafe_blit
+    end)
 
   (** Returns the length of the longest prefix for which [f] is true. *)
   let take_while_len t ~f =
@@ -535,6 +601,12 @@ module With_integer_index = struct
     raise (Base.Not_found_s [%message "Vec.find_exn: not found"])
   ;;
 
+  (* Tailcalls to raising functions are to be avoided, as the stack traces are much worse.
+     Instead, we try really hard to inline wrapper functions that just perform non-tail
+     calls to the raising functions.
+  *)
+  let[@inline always] raise__not_found () = raise__not_found () [@nontail]
+
   let rec find_exn' t ~f ~max_index i =
     if i > max_index
     then raise__not_found ()
@@ -664,18 +736,18 @@ module With_integer_index = struct
       type nonrec 'a t = 'a t [@@deriving compare, sexp]
 
       include Bin_prot.Utils.Make_iterable_binable1 (struct
-        type nonrec 'a t = 'a t
-        type 'a el = 'a [@@deriving bin_io]
-
-        let caller_identity =
-          Bin_prot.Shape.Uuid.of_string "2ec1d047-7cf8-49bc-991b-0badd17d8359"
-        ;;
-
-        let module_name = Some "Vec"
-        let init ~len ~next = init len ~f:(fun _ -> next ())
-        let iter = iter
-        let length = length
-      end)
+          type nonrec 'a t = 'a t
+          type 'a el = 'a [@@deriving bin_io]
+
+          let caller_identity =
+            Bin_prot.Shape.Uuid.of_string "2ec1d047-7cf8-49bc-991b-0badd17d8359"
+          ;;
+
+          let module_name = Some "Vec"
+          let init ~len ~next = init len ~f:(fun _ -> next ())
+          let iter = iter
+          let length = length
+        end)
     end
   end
 end
@@ -691,8 +763,14 @@ module Make (M : Intable.S) = struct
   let get t index = get t (M.to_int_exn index)
   let maybe_get t index = maybe_get t (M.to_int_exn index)
   let maybe_get_local t index = maybe_get_local t (M.to_int_exn index)
-  let[@inline always] unsafe_set t index = unsafe_set t (M.to_int_exn index)
-  let set t index = set t (M.to_int_exn index)
+  let[@inline always] unsafe_set t index x : unit = unsafe_set t (M.to_int_exn index) x
+
+  let[@inline always] unsafe_set_imm t w index x : unit =
+    unsafe_set_imm t w (M.to_int_exn index) x
+  ;;
+
+  let set t index x : unit = set t (M.to_int_exn index) x
+  let set_imm t w index x : unit = set_imm t w (M.to_int_exn index) x
   let next_free_index t = next_free_index t |> M.of_int_exn
 
   let foldi t ~init ~f =
@@ -710,6 +788,7 @@ module Make (M : Intable.S) = struct
   ;;
 
   let push_back_index t element = push_back_index t element |> M.of_int_exn
+  let push_back_index_imm t w e = push_back_index_imm t w e |> M.of_int_exn
 
   let to_alist t =
     (* We could do:
@@ -749,3 +828,4 @@ module Make (M : Intable.S) = struct
   let swap t index1 index2 = swap t (M.to_int_exn index1) (M.to_int_exn index2)
   let swap_to_last_and_pop t index = swap_to_last_and_pop t (M.to_int_exn index)
 end
+[@@inline]
diff --git a/vec/src/vec_intf.ml b/vec/src/vec_intf.ml
index 4c7c54f4..479c42fb 100644
--- a/vec/src/vec_intf.ml
+++ b/vec/src/vec_intf.ml
@@ -20,11 +20,13 @@ module type S = sig
   val get : 'a t -> index -> 'a
 
   val maybe_get : 'a t -> index -> 'a option
-  val maybe_get_local : 'a t -> index -> 'a Gel.t option
+  val maybe_get_local : 'a t -> index -> 'a Modes.Global.t option
 
   (** Raises if the index is invalid. *)
   val set : 'a t -> index -> 'a -> unit
 
+  val set_imm : 'a t -> 'a Type_immediacy.Always.t -> index -> 'a -> unit
+
   include Container.S1 with type 'a t := 'a t
   include Blit.S1 with type 'a t := 'a t
 
@@ -37,9 +39,14 @@ module type S = sig
   val sort : ?pos:int -> ?len:int -> 'a t -> compare:('a -> 'a -> int) -> unit
 
   val is_sorted : 'a t -> compare:('a -> 'a -> int) -> bool
+
+  include Binary_searchable.S1 with type 'a t := 'a t
+
   val next_free_index : 'a t -> index
   val push_back : 'a t -> 'a -> unit
   val push_back_index : 'a t -> 'a -> index
+  val push_back_imm : 'a t -> 'a Type_immediacy.Always.t -> 'a -> unit
+  val push_back_index_imm : 'a t -> 'a Type_immediacy.Always.t -> 'a -> index
 
   (** Grows the vec to the specified length if it is currently shorter. Sets all new
       indices to [default]. *)
@@ -70,7 +77,9 @@ module type S = sig
   val find_and_remove : 'a t -> f:('a -> bool) -> 'a option
 
   val pop_back_exn : 'a t -> 'a
+  val pop_back_imm_exn : 'a t -> 'a Type_immediacy.Always.t -> 'a
   val pop_back_unit_exn : 'a t -> unit
+  val pop_back_unit_imm_exn : 'a t -> 'a Type_immediacy.Always.t -> unit
   val peek_back : 'a t -> 'a option
   val peek_back_exn : 'a t -> 'a
   val foldi : 'a t -> init:'accum -> f:(index -> 'accum -> 'a -> 'accum) -> 'accum
@@ -151,6 +160,7 @@ module type S = sig
 
   val unsafe_get : 'a t -> index -> 'a
   val unsafe_set : 'a t -> index -> 'a -> unit
+  val unsafe_set_imm : 'a t -> 'a Type_immediacy.Always.t -> index -> 'a -> unit
 
   module Expert : sig
     val unsafe_inner : 'a t -> Obj.t Uniform_array.t
diff --git a/version_util/src/dune b/version_util/src/dune
index 2b19771b..cd521561 100644
--- a/version_util/src/dune
+++ b/version_util/src/dune
@@ -6,6 +6,6 @@
  (public_name core_kernel.version_util)
  (js_of_ocaml
   (javascript_files version_util.js))
- (libraries core)
+ (libraries core sexplib)
  (preprocess
   (pps ppx_jane)))
diff --git a/version_util/src/section.ml b/version_util/src/section.ml
index c6171cc1..5ff17c43 100644
--- a/version_util/src/section.ml
+++ b/version_util/src/section.ml
@@ -1,10 +1,10 @@
 open! Core
 
 module Make (M : sig
-  val name : string
-  val start_marker : string
-  val length_including_start_marker : int
-end) =
+    val name : string
+    val start_marker : string
+    val length_including_start_marker : int
+  end) =
 struct
   let chop_start_marker_if_exists = String.chop_prefix_if_exists ~prefix:M.start_marker
 
diff --git a/version_util/src/section.mli b/version_util/src/section.mli
index 82867187..3832f1b4 100644
--- a/version_util/src/section.mli
+++ b/version_util/src/section.mli
@@ -4,12 +4,12 @@ open! Core
 
 (** Create a section. Each section has a fixed length and starts with a marker string. *)
 module Make : functor
-  (M : sig
-     val name : string
-     val start_marker : string
-     val length_including_start_marker : int
-   end)
-  -> sig
+    (M : sig
+       val name : string
+       val start_marker : string
+       val length_including_start_marker : int
+     end)
+    -> sig
   (** Extract the first section from an executable, including the start marker. Returns
         [None] if there are no matching sections. *)
   val get : contents_of_exe:string -> string option
diff --git a/version_util/src/version_util.ml b/version_util/src/version_util.ml
index 4d05d7bc..3c65bc2e 100644
--- a/version_util/src/version_util.ml
+++ b/version_util/src/version_util.ml
@@ -27,42 +27,42 @@ external generated_hg_version : unit -> string = "generated_hg_version"
 (** Make sure to update [bin/generate_static_string_c_code.sh] too if you are changing
     these constants. *)
 module Version_util_section = Section.Make (struct
-  let name = "version_util"
-  let length_including_start_marker = 4096
+    let name = "version_util"
+    let length_including_start_marker = 4096
 
-  (* BEFORE CHANGING: Please note the bidirectional version compatibility guarantee
+    (* BEFORE CHANGING: Please note the bidirectional version compatibility guarantee
        granted in the mli file for [Expert.get_version_util]. If we ever need to change the
        version util format, we should update the code to be able to read both the old and
        new formats, then wait a month, then change the write function to only write the new
        format. The old and new formats can be distinguished by minting a new [start_marker]
        for the new format.
     *)
-  let start_marker =
-    (* This trick is to prevent the marker from occurring verbatim in the binary that uses
+    let start_marker =
+      (* This trick is to prevent the marker from occurring verbatim in the binary that uses
          [Expert.insert_version_util], so that we don't by accident rewrite our own code.
 
          [opaque_identity] is used to prevent the compiler from converting this computation
          into a literal, thus undoing this trick. We could split the marker in half instead,
          but that would make grepping hard for humans.
          Grep in the tree to see the place that generates this. *)
-    (Sys.opaque_identity ( ^ )) "rUb71QgfHXXwnBWBoJfb0Sa3R60vihdV" ":"
-  ;;
-end)
+      (Sys.opaque_identity ( ^ )) "rUb71QgfHXXwnBWBoJfb0Sa3R60vihdV" ":"
+    ;;
+  end)
 
 (** Make sure to update [bin/generate_static_string_c_code.sh] too if you are changing
     these constants. *)
 module Build_info_section = Section.Make (struct
-  let name = "build info"
-  let length_including_start_marker = 4096
+    let name = "build info"
+    let length_including_start_marker = 4096
 
-  let start_marker =
-    (* Same trick as in [Version_util_section]. *)
-    (Sys.opaque_identity ( ^ )) "vNxXpiccvPI9MHVFJuNwNxj8eu9W5KCB" ":"
-  ;;
-end)
+    let start_marker =
+      (* Same trick as in [Version_util_section]. *)
+      (Sys.opaque_identity ( ^ )) "vNxXpiccvPI9MHVFJuNwNxj8eu9W5KCB" ":"
+    ;;
+  end)
 
 (* BEFORE CHANGING: Note version compatibility guarantee above. *)
-let parse_generated_hg_version = function
+let parse_generated_hg_version_rev_n ~n = function
   | "" -> [ "NO_VERSION_UTIL" ]
   | generated_hg_version ->
     generated_hg_version
@@ -70,22 +70,23 @@ let parse_generated_hg_version = function
     |> Version_util_section.chop_start_marker_if_exists
     |> String.split ~on:'\n'
     |> List.map ~f:(fun line ->
-         match String.rsplit2 line ~on:' ' with
-         | None -> line (* no version util *)
-         | Some (repo, rev_status) ->
-           (* For compability with downstream tools that might rely on this output format,
+      match String.rsplit2 line ~on:' ' with
+      | None -> line (* no version util *)
+      | Some (repo, rev_status) ->
+        (* For compability with downstream tools that might rely on this output format,
            and with [Version.parse].*)
-           String.concat
-             [ repo
-             ; "_"
-             ; String.prefix rev_status 12
-             ; (* The revision can have a one-character '+' suffix. Keep it. *)
-               (if String.length rev_status mod 2 = 1
-                then String.suffix rev_status 1
-                else "")
-             ])
+        String.concat
+          [ repo
+          ; "_"
+          ; String.prefix rev_status n
+          ; (* The revision can have a one-character '+' suffix. Keep it. *)
+            (if String.length rev_status mod 2 = 1 then String.suffix rev_status 1 else "")
+          ])
 ;;
 
+(* BEFORE CHANGING: Note version compatibility guarantee above. *)
+let parse_generated_hg_version = parse_generated_hg_version_rev_n ~n:12
+let parse_generated_hg_version_rev40 = parse_generated_hg_version_rev_n ~n:40
 let version_list = parse_generated_hg_version (generated_hg_version ())
 let version = String.concat version_list ~sep:" "
 
@@ -144,14 +145,14 @@ module Expert = struct
       versions
       |> List.sort ~compare:Version.compare
       |> List.map ~f:(fun { repo; version } ->
-           if not (String.mem repo '/')
-           then failwith [%string "%{repo} doesn't look like a repo url"];
-           (let version' = String.chop_suffix_if_exists version ~suffix:"+" in
-            if (String.length version' = 40 || String.length version' = 64)
-               && String.for_all version' ~f:Char.is_hex_digit_lower
-            then ()
-            else failwith [%string "%{version} doesn't look like a full hg version"]);
-           repo ^ " " ^ version ^ "\n")
+        if not (String.mem repo '/')
+        then failwith [%string "%{repo} doesn't look like a repo url"];
+        (let version' = String.chop_suffix_if_exists version ~suffix:"+" in
+         if (String.length version' = 40 || String.length version' = 64)
+            && String.for_all version' ~f:Char.is_hex_digit_lower
+         then ()
+         else failwith [%string "%{version} doesn't look like a full hg version"]);
+        repo ^ " " ^ version ^ "\n")
       |> String.concat
   ;;
 
@@ -164,6 +165,7 @@ module Expert = struct
   ;;
 
   let parse_generated_hg_version = parse_generated_hg_version
+  let parse_generated_hg_version_rev40 = parse_generated_hg_version_rev40
 
   module Experimental = struct
     let get_build_info = Build_info_section.get
@@ -330,6 +332,7 @@ let compiled_for_speed = x_library_inlining && not dynlinkable_code
 module For_tests = struct
   let build_info_status = Build_info.build_info_status
   let parse_generated_hg_version = parse_generated_hg_version
+  let parse_generated_hg_version_rev40 = parse_generated_hg_version_rev40
 end
 
 let arg_spec =
diff --git a/version_util/src/version_util.mli b/version_util/src/version_util.mli
index 4b33c96d..f8d17e97 100644
--- a/version_util/src/version_util.mli
+++ b/version_util/src/version_util.mli
@@ -87,6 +87,7 @@ val with_fdo : (string * Md5.t option) option
 
 module For_tests : sig
   val parse_generated_hg_version : string -> string list
+  val parse_generated_hg_version_rev40 : string -> string list
   val build_info_status : [ `Not_supported | `Unset | `Set ]
 end
 
@@ -128,6 +129,8 @@ module Expert : sig
       returns. *)
   val parse_generated_hg_version : string -> string list
 
+  val parse_generated_hg_version_rev40 : string -> string list
+
   module Experimental : sig
     (** Gets the build info if it exists.
 
diff --git a/version_util/src/version_util.wat b/version_util/src/version_util.wat
new file mode 100644
index 00000000..9d21d34d
--- /dev/null
+++ b/version_util/src/version_util.wat
@@ -0,0 +1,37 @@
+(module
+   (import "env" "ocaml_exception" (tag $ocaml_exception (param (ref eq))))
+   (import "env" "caml_read_file_content"
+      (func $caml_read_file_content (param (ref eq)) (result (ref eq))))
+
+   (type $string (array (mut i8)))
+
+   (data $build_info "/static/build_info.sexp")
+
+   (data $default_build_info
+      "((username \"\")(hostname \"\")(kernel \"\")(build_time \"1970-01-01 00:00:00Z\")(x_library_inlining false)(portable_int63 true)(dynlinkable_code false)(ocaml_version \"\")(executable_path \"\")(build_system \"\"))")
+
+   (func (export "generated_build_info") (param (ref eq)) (result (ref eq))
+      (try (result (ref eq))
+         (do
+            (call $caml_read_file_content
+               (array.new_data $string $build_info
+                  (i32.const 0) (i32.const 23))))
+         (catch $ocaml_exception
+            (drop (pop (ref eq)))
+            (array.new_data $string $default_build_info
+               (i32.const 0) (i32.const 200)))))
+
+   (data $hg_version "/static/hg_version.out")
+   (data $default_hg_version "NO_VERSION_UTIL")
+
+   (func (export "generated_hg_version") (param (ref eq)) (result (ref eq))
+      (try (result (ref eq))
+         (do
+            (call $caml_read_file_content
+               (array.new_data $string $hg_version
+                  (i32.const 0) (i32.const 22))))
+         (catch $ocaml_exception
+            (drop (pop (ref eq)))
+            (array.new_data $string $default_hg_version
+               (i32.const 0) (i32.const 15)))))
+)
diff --git a/version_util/test/check_build_info.ml b/version_util/test/check_build_info.ml
index b4e8daf4..269acd8a 100644
--- a/version_util/test/check_build_info.ml
+++ b/version_util/test/check_build_info.ml
@@ -31,7 +31,7 @@ let%expect_test "Version.parse*" =
   print_s
     [%sexp
       (Version.parse_lines (line1 ^ "\n" ^ line2 ^ "\n")
-        : Version.t list option Or_error.t)];
+       : Version.t list option Or_error.t)];
   [%expect
     {|
     (Ok
@@ -59,3 +59,22 @@ let%expect_test "backwards-compatible printing of rev40s" =
   print "ssh://repo1 a1234567b1234567c1234567d1234567e1234567f1234567g1234567h1234567+\n";
   [%expect {| (ssh://repo1_a1234567b123+) |}]
 ;;
+
+let%expect_test "print full rev40s if requested" =
+  let print s =
+    print_s
+      [%sexp (Version_util.For_tests.parse_generated_hg_version_rev40 s : string list)]
+  in
+  (* current jenga *)
+  print
+    "ssh://repo1 a123456789b123456789c123456789d123456789+\n\
+     ssh://repo2 a123456789b123456789c123456789d123456789\n";
+  [%expect
+    {|
+    (ssh://repo1_a123456789b123456789c123456789d123456789+
+     ssh://repo2_a123456789b123456789c123456789d123456789)
+    |}];
+  (* potentially in the future, when we change the hashing scheme: rev64 *)
+  print "ssh://repo1 a1234567b1234567c1234567d1234567e1234567f1234567g1234567h1234567+\n";
+  [%expect {| (ssh://repo1_a1234567b1234567c1234567d1234567e1234567+) |}]
+;;
diff --git a/weak_array/test/dune b/weak_array/test/dune
index 4e992cbc..32c65d45 100644
--- a/weak_array/test/dune
+++ b/weak_array/test/dune
@@ -1,5 +1,5 @@
 (library
  (name weak_array_test)
- (libraries expect_test_helpers_core weak_array)
+ (libraries core expect_test_helpers_core weak_array)
  (preprocess
   (pps ppx_jane)))
diff --git a/weak_array/test/test_weak_array.ml b/weak_array/test/test_weak_array.ml
index 7019beb8..945b92f0 100644
--- a/weak_array/test/test_weak_array.ml
+++ b/weak_array/test/test_weak_array.ml
@@ -11,7 +11,8 @@ let%expect_test "[length]" =
   for len = 0 to 3 do
     print_s [%sexp (length (create ~len) : int)]
   done;
-  [%expect {|
+  [%expect
+    {|
     0
     1
     2
@@ -50,14 +51,16 @@ let%expect_test "[is_none], [is_some]" =
   let t = create ~len:1 in
   let print () = print_s [%message (is_none t 0 : bool) (is_some t 0 : bool)] in
   print ();
-  [%expect {|
+  [%expect
+    {|
     (("is_none t 0" true)
      ("is_some t 0" false))
     |}];
   let b = block 13 in
   set t 0 (Some b);
   print ();
-  [%expect {|
+  [%expect
+    {|
     (("is_none t 0" false)
      ("is_some t 0" true))
     |}];
@@ -78,20 +81,29 @@ let%expect_test ("clearing, with no finalizer attached" [@tags "no-js"]) =
   [%expect {| (()) |}]
 ;;
 
-(* This test demonstrates a difference between OCaml 4.02 and 4.03.  In 4.02, a weak
-   pointer with an attached finalizer is cleared after the first compaction.  In 4.03, the
-   weak is not cleared until the second compaction. *)
+(* This test shows two properties of weak pointers in conjunction with finalizers that
+   are well-specified:
+
+   1. if a finalizer resurrects a weak pointer that would otherwise be cleared
+   immediately, then it is not in fact cleared;
+
+   2. when such a resurrected weak pointer becomes dead, it is indeed cleared.
+*)
 let%expect_test ("clearing, with a finalizer attached" [@tags "no-js"]) =
   let t = create ~len:1 in
   let b = block 13 in
   set t 0 (Some b);
   print t;
   [%expect {| ((13)) |}];
-  Gc.Expert.add_finalizer b (fun b -> print_s [%message "finalized" (b : block)]);
+  let r = ref None in
+  Gc.Expert.add_finalizer b (fun b ->
+    r := Some b;
+    print_s [%message "finalized" (b : block)]);
   Gc.compact ();
   [%expect {| (finalized (b 13)) |}];
   print t;
   [%expect {| ((13)) |}];
+  r := None;
   Gc.compact ();
   print t;
   [%expect {| (()) |}]
diff --git a/weak_hashtbl/src/weak_hashtbl.ml b/weak_hashtbl/src/weak_hashtbl.ml
index 97b18a0e..15fa9afa 100644
--- a/weak_hashtbl/src/weak_hashtbl.ml
+++ b/weak_hashtbl/src/weak_hashtbl.ml
@@ -31,12 +31,12 @@ let clear t = Hashtbl.clear t.entry_by_key
    was previously finalized, the weak pointer must have been cleared.  This relies on the
    fact that the OCaml garbage collector clears weaks and then runs finalizers. *)
 let reclaim_space_for_keys_with_unused_data t =
-  while Thread_safe_queue.length t.keys_with_unused_data > 0 do
-    let key = Thread_safe_queue.dequeue_exn t.keys_with_unused_data in
+  let remove_entry key =
     match Hashtbl.find t.entry_by_key key with
     | None -> ()
     | Some entry -> if Weak_pointer.is_none entry then remove t key
-  done
+  in
+  Thread_safe_queue.dequeue_until_empty ~f:remove_entry t.keys_with_unused_data [@nontail]
 ;;
 
 let get_entry t key =
@@ -78,12 +78,12 @@ let add_exn t ~key ~data =
 let find t key =
   match Hashtbl.find t.entry_by_key key with
   | None -> None
-  | Some entry -> Weak_pointer.get entry
+  | Some entry -> Weak_pointer.get_as_heap_block entry
 ;;
 
 let find_or_add t key ~default =
   let entry = get_entry t key in
-  match Weak_pointer.get entry with
+  match Weak_pointer.get_as_heap_block entry with
   | Some v -> v
   | None ->
     let data = default () in
diff --git a/weak_hashtbl/test/dune b/weak_hashtbl/test/dune
index 3a922438..7a80b82a 100644
--- a/weak_hashtbl/test/dune
+++ b/weak_hashtbl/test/dune
@@ -1,5 +1,5 @@
 (library
  (name weak_hashtbl_test)
- (libraries expect_test_helpers_core weak_hashtbl)
+ (libraries core expect_test_helpers_core weak_hashtbl)
  (preprocess
   (pps ppx_jane)))
diff --git a/weak_hashtbl/test/test_weak_hashtbl.ml b/weak_hashtbl/test/test_weak_hashtbl.ml
index a66324e1..91de07fa 100644
--- a/weak_hashtbl/test/test_weak_hashtbl.ml
+++ b/weak_hashtbl/test/test_weak_hashtbl.ml
@@ -12,13 +12,15 @@ let%expect_test "[add_exn], [find], [mem], [replace], [remove], [clear]" =
   let print_mem i = print_s [%message (i : int) ~mem:(mem t i : bool)] in
   let key = 13 in
   print_mem key;
-  [%expect {|
+  [%expect
+    {|
     ((i   13)
      (mem false))
     |}];
   add_exn t ~key ~data:(data key);
   print_mem key;
-  [%expect {|
+  [%expect
+    {|
     ((i   13)
      (mem true))
     |}];
@@ -50,25 +52,29 @@ let%expect_test ("[key_is_using_space], [reclaim_space_for_keys_with_unused_data
         "" ~key_is_using_space:(key_is_using_space t key : bool) ~mem:(mem t key : bool)]
   in
   print ();
-  [%expect {|
+  [%expect
+    {|
     ((key_is_using_space false)
      (mem                false))
     |}];
   add_exn t ~key ~data:(data ());
   print ();
-  [%expect {|
+  [%expect
+    {|
     ((key_is_using_space true)
      (mem                true))
     |}];
   Gc.compact ();
   print ();
-  [%expect {|
+  [%expect
+    {|
     ((key_is_using_space true)
      (mem                false))
     |}];
   reclaim_space_for_keys_with_unused_data t;
   print ();
-  [%expect {|
+  [%expect
+    {|
     ((key_is_using_space false)
      (mem                false))
     |}]
@@ -135,24 +141,24 @@ let%expect_test (_ [@tags "no-js"]) =
     | None -> false
     | Some v -> phys_equal v b
   in
-  require [%here] (is_block k1 !b1);
-  require [%here] (is_block k2 !b2);
-  require [%here] (is_block k3 !b3);
+  require (is_block k1 !b1);
+  require (is_block k2 !b2);
+  require (is_block k3 !b3);
   blackhole b1;
   stabilize ();
-  require [%here] (is_absent k1);
-  require [%here] (is_block k2 !b2);
-  require [%here] (is_block k3 !b3);
+  require (is_absent k1);
+  require (is_block k2 !b2);
+  require (is_block k3 !b3);
   blackhole b2;
   stabilize ();
-  require [%here] (is_absent k1);
-  require [%here] (is_absent k2);
-  require [%here] (is_block k3 !b3);
+  require (is_absent k1);
+  require (is_absent k2);
+  require (is_block k3 !b3);
   replace tbl ~key:k3 ~data:!b4;
   blackhole b3;
   stabilize ();
-  require [%here] (is_block k3 !b4);
+  require (is_block k3 !b4);
   blackhole b4;
   stabilize ();
-  require [%here] (is_absent k3)
+  require (is_absent k3)
 ;;
diff --git a/weak_pointer/src/dune b/weak_pointer/src/dune
index 2c716dcd..3c8230c2 100644
--- a/weak_pointer/src/dune
+++ b/weak_pointer/src/dune
@@ -1,6 +1,6 @@
 (library
  (name weak_pointer)
  (public_name core_kernel.weak_pointer)
- (libraries base weak_array)
+ (libraries base core.heap_block weak_array)
  (preprocess
   (pps ppx_jane)))
diff --git a/weak_pointer/src/weak_pointer.ml b/weak_pointer/src/weak_pointer.ml
index c1e45c9d..d779970c 100644
--- a/weak_pointer/src/weak_pointer.ml
+++ b/weak_pointer/src/weak_pointer.ml
@@ -8,8 +8,9 @@ let create () = Weak_array.create ~len:1
 
 (* We use a weak array of length 1, so the weak pointer is at index 0. *)
 let index = 0
-let get t = Weak_array.get t index
-let sexp_of_t sexp_of_a t = [%sexp (get t : a Heap_block.t option)]
+let get_as_heap_block t = Weak_array.get t index
+let get t = get_as_heap_block t |> Option.map ~f:Heap_block.value
+let sexp_of_t sexp_of_a t = [%sexp (get t : a option)]
 let is_none t = Weak_array.is_none t index
 let is_some t = Weak_array.is_some t index
 let set t block = Weak_array.set t index (Some block)
diff --git a/weak_pointer/src/weak_pointer.mli b/weak_pointer/src/weak_pointer.mli
index 693b8e6c..539bb951 100644
--- a/weak_pointer/src/weak_pointer.mli
+++ b/weak_pointer/src/weak_pointer.mli
@@ -15,7 +15,8 @@ val create : unit -> _ t
 (** [create_full] is similar to [create], but [set]s the pointer at creation time. *)
 val create_full : 'a Heap_block.t -> 'a t
 
-val get : 'a t -> 'a Heap_block.t option
+val get : 'a t -> 'a option
+val get_as_heap_block : 'a t -> 'a Heap_block.t option
 
 (** [is_some t = Option.is_some (get t)]. *)
 val is_some : _ t -> bool
diff --git a/weak_pointer/test/dune b/weak_pointer/test/dune
index 7b322687..90724c7e 100644
--- a/weak_pointer/test/dune
+++ b/weak_pointer/test/dune
@@ -1,5 +1,5 @@
 (library
  (name weak_pointer_test)
- (libraries expect_test_helpers_core weak_pointer)
+ (libraries core expect_test_helpers_core weak_pointer)
  (preprocess
   (pps ppx_jane)))
diff --git a/weak_pointer/test/test_weak_pointer.ml b/weak_pointer/test/test_weak_pointer.ml
index 6a12b724..51a6dd18 100644
--- a/weak_pointer/test/test_weak_pointer.ml
+++ b/weak_pointer/test/test_weak_pointer.ml
@@ -17,27 +17,50 @@ let print t =
       ""
         ~_:(t : int ref t)
         ~is_some:(is_some t : bool)
-        ~get:(get t : contents Heap_block.t option)]
+        ~get_as_heap_block:(get_as_heap_block t : contents Heap_block.t option)
+        ~get:(get t : contents option)]
 ;;
 
 let%expect_test ("[create], [get], [set], clearing via GC" [@tags "no-js"]) =
   let t = create () in
   print t;
-  [%expect {| (() (is_some false) (get ())) |}];
+  [%expect
+    {|
+    (()
+     (is_some false)
+     (get_as_heap_block ())
+     (get               ()))
+    |}];
   let b = heap_block "b" 13 in
   set t b;
   print t;
-  [%expect {| ((13) (is_some true) (get (13))) |}];
+  [%expect
+    {|
+    ((13)
+     (is_some true)
+     (get_as_heap_block (13))
+     (get               (13)))
+    |}];
   Gc.compact ();
   print t;
-  [%expect {| ((13) (is_some true) (get (13))) |}];
+  [%expect
+    {|
+    ((13)
+     (is_some true)
+     (get_as_heap_block (13))
+     (get               (13)))
+    |}];
   print_s [%sexp (b : heap_block)];
   [%expect {| 13 |}];
   Gc.compact ();
   print t;
-  [%expect {|
+  [%expect
+    {|
     (finalized b)
-    (() (is_some false) (get ()))
+    (()
+     (is_some false)
+     (get_as_heap_block ())
+     (get               ()))
     |}]
 ;;
 
@@ -50,11 +73,23 @@ let%expect_test ("multiple [set]s and clearing" [@tags "no-js"]) =
   Gc.compact ();
   [%expect {| (finalized b1) |}];
   print t;
-  [%expect {| ((14) (is_some true) (get (14))) |}];
+  [%expect
+    {|
+    ((14)
+     (is_some true)
+     (get_as_heap_block (14))
+     (get               (14)))
+    |}];
   print_s [%sexp (b2 : heap_block)];
   [%expect {| 14 |}];
   Gc.compact ();
   [%expect {| (finalized b2) |}];
   print t;
-  [%expect {| (() (is_some false) (get ())) |}]
+  [%expect
+    {|
+    (()
+     (is_some false)
+     (get_as_heap_block ())
+     (get               ()))
+    |}]
 ;;
